source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/sqlite3/operations.py</b><br>


file stats: <b>157 lines, 71 executed: 45.2% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import datetime</font>
<font color="green">   4. import uuid</font>
<font color="black">   5. </font>
<font color="green">   6. from django.conf import settings</font>
<font color="green">   7. from django.core.exceptions import FieldError, ImproperlyConfigured</font>
<font color="green">   8. from django.db import utils</font>
<font color="green">   9. from django.db.backends import utils as backend_utils</font>
<font color="green">  10. from django.db.backends.base.operations import BaseDatabaseOperations</font>
<font color="green">  11. from django.db.models import aggregates, fields</font>
<font color="green">  12. from django.utils import six, timezone</font>
<font color="green">  13. from django.utils.dateparse import parse_date, parse_datetime, parse_time</font>
<font color="green">  14. from django.utils.duration import duration_string</font>
<font color="black">  15. </font>
<font color="green">  16. try:</font>
<font color="green">  17.     import pytz</font>
<font color="green">  18. except ImportError:</font>
<font color="green">  19.     pytz = None</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class DatabaseOperations(BaseDatabaseOperations):</font>
<font color="green">  23.     def bulk_batch_size(self, fields, objs):</font>
<font color="black">  24.         &quot;&quot;&quot;</font>
<font color="black">  25.         SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of</font>
<font color="black">  26.         999 variables per query.</font>
<font color="black">  27. </font>
<font color="black">  28.         If there is just single field to insert, then we can hit another</font>
<font color="black">  29.         limit, SQLITE_MAX_COMPOUND_SELECT which defaults to 500.</font>
<font color="black">  30.         &quot;&quot;&quot;</font>
<font color="green">  31.         limit = 999 if len(fields) &gt; 1 else 500</font>
<font color="green">  32.         return (limit // len(fields)) if len(fields) &gt; 0 else len(objs)</font>
<font color="black">  33. </font>
<font color="green">  34.     def check_expression_support(self, expression):</font>
<font color="green">  35.         bad_fields = (fields.DateField, fields.DateTimeField, fields.TimeField)</font>
<font color="green">  36.         bad_aggregates = (aggregates.Sum, aggregates.Avg, aggregates.Variance, aggregates.StdDev)</font>
<font color="green">  37.         if isinstance(expression, bad_aggregates):</font>
<font color="red">  38.             for expr in expression.get_source_expressions():</font>
<font color="red">  39.                 try:</font>
<font color="red">  40.                     output_field = expr.output_field</font>
<font color="red">  41.                     if isinstance(output_field, bad_fields):</font>
<font color="red">  42.                         raise NotImplementedError(</font>
<font color="red">  43.                             'You cannot use Sum, Avg, StdDev, and Variance '</font>
<font color="black">  44.                             'aggregations on date/time fields in sqlite3 '</font>
<font color="black">  45.                             'since date/time is saved as text.'</font>
<font color="black">  46.                         )</font>
<font color="red">  47.                 except FieldError:</font>
<font color="black">  48.                     # Not every subexpression has an output_field which is fine</font>
<font color="black">  49.                     # to ignore.</font>
<font color="red">  50.                     pass</font>
<font color="black">  51. </font>
<font color="green">  52.     def date_extract_sql(self, lookup_type, field_name):</font>
<font color="black">  53.         # sqlite doesn't support extract, so we fake it with the user-defined</font>
<font color="black">  54.         # function django_date_extract that's registered in connect(). Note that</font>
<font color="black">  55.         # single quotes are used because this is a string (and could otherwise</font>
<font color="black">  56.         # cause a collision with a field name).</font>
<font color="red">  57.         return &quot;django_date_extract('%s', %s)&quot; % (lookup_type.lower(), field_name)</font>
<font color="black">  58. </font>
<font color="green">  59.     def date_interval_sql(self, timedelta):</font>
<font color="red">  60.         return &quot;'%s'&quot; % duration_string(timedelta), []</font>
<font color="black">  61. </font>
<font color="green">  62.     def format_for_duration_arithmetic(self, sql):</font>
<font color="black">  63.         &quot;&quot;&quot;Do nothing here, we will handle it in the custom function.&quot;&quot;&quot;</font>
<font color="red">  64.         return sql</font>
<font color="black">  65. </font>
<font color="green">  66.     def date_trunc_sql(self, lookup_type, field_name):</font>
<font color="black">  67.         # sqlite doesn't support DATE_TRUNC, so we fake it with a user-defined</font>
<font color="black">  68.         # function django_date_trunc that's registered in connect(). Note that</font>
<font color="black">  69.         # single quotes are used because this is a string (and could otherwise</font>
<font color="black">  70.         # cause a collision with a field name).</font>
<font color="red">  71.         return &quot;django_date_trunc('%s', %s)&quot; % (lookup_type.lower(), field_name)</font>
<font color="black">  72. </font>
<font color="green">  73.     def _require_pytz(self):</font>
<font color="red">  74.         if settings.USE_TZ and pytz is None:</font>
<font color="red">  75.             raise ImproperlyConfigured(&quot;This query requires pytz, but it isn't installed.&quot;)</font>
<font color="black">  76. </font>
<font color="green">  77.     def datetime_cast_date_sql(self, field_name, tzname):</font>
<font color="red">  78.         self._require_pytz()</font>
<font color="red">  79.         return &quot;django_datetime_cast_date(%s, %%s)&quot; % field_name, [tzname]</font>
<font color="black">  80. </font>
<font color="green">  81.     def datetime_extract_sql(self, lookup_type, field_name, tzname):</font>
<font color="black">  82.         # Same comment as in date_extract_sql.</font>
<font color="red">  83.         self._require_pytz()</font>
<font color="red">  84.         return &quot;django_datetime_extract('%s', %s, %%s)&quot; % (</font>
<font color="red">  85.             lookup_type.lower(), field_name), [tzname]</font>
<font color="black">  86. </font>
<font color="green">  87.     def datetime_trunc_sql(self, lookup_type, field_name, tzname):</font>
<font color="black">  88.         # Same comment as in date_trunc_sql.</font>
<font color="red">  89.         self._require_pytz()</font>
<font color="red">  90.         return &quot;django_datetime_trunc('%s', %s, %%s)&quot; % (</font>
<font color="red">  91.             lookup_type.lower(), field_name), [tzname]</font>
<font color="black">  92. </font>
<font color="green">  93.     def time_extract_sql(self, lookup_type, field_name):</font>
<font color="black">  94.         # sqlite doesn't support extract, so we fake it with the user-defined</font>
<font color="black">  95.         # function django_time_extract that's registered in connect(). Note that</font>
<font color="black">  96.         # single quotes are used because this is a string (and could otherwise</font>
<font color="black">  97.         # cause a collision with a field name).</font>
<font color="red">  98.         return &quot;django_time_extract('%s', %s)&quot; % (lookup_type.lower(), field_name)</font>
<font color="black">  99. </font>
<font color="green"> 100.     def drop_foreignkey_sql(self):</font>
<font color="red"> 101.         return &quot;&quot;</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def pk_default_value(self):</font>
<font color="red"> 104.         return &quot;NULL&quot;</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def _quote_params_for_last_executed_query(self, params):</font>
<font color="black"> 107.         &quot;&quot;&quot;</font>
<font color="black"> 108.         Only for last_executed_query! Don't use this to execute SQL queries!</font>
<font color="black"> 109.         &quot;&quot;&quot;</font>
<font color="red"> 110.         sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(params))</font>
<font color="black"> 111.         # Bypass Django's wrappers and use the underlying sqlite3 connection</font>
<font color="black"> 112.         # to avoid logging this query - it would trigger infinite recursion.</font>
<font color="red"> 113.         cursor = self.connection.connection.cursor()</font>
<font color="black"> 114.         # Native sqlite3 cursors cannot be used as context managers.</font>
<font color="red"> 115.         try:</font>
<font color="red"> 116.             return cursor.execute(sql, params).fetchone()</font>
<font color="black"> 117.         finally:</font>
<font color="red"> 118.             cursor.close()</font>
<font color="black"> 119. </font>
<font color="green"> 120.     def last_executed_query(self, cursor, sql, params):</font>
<font color="black"> 121.         # Python substitutes parameters in Modules/_sqlite/cursor.c with:</font>
<font color="black"> 122.         # pysqlite_statement_bind_parameters(self-&gt;statement, parameters, allow_8bit_chars);</font>
<font color="black"> 123.         # Unfortunately there is no way to reach self-&gt;statement from Python,</font>
<font color="black"> 124.         # so we quote and substitute parameters manually.</font>
<font color="red"> 125.         if params:</font>
<font color="red"> 126.             if isinstance(params, (list, tuple)):</font>
<font color="red"> 127.                 params = self._quote_params_for_last_executed_query(params)</font>
<font color="black"> 128.             else:</font>
<font color="red"> 129.                 keys = params.keys()</font>
<font color="red"> 130.                 values = tuple(params.values())</font>
<font color="red"> 131.                 values = self._quote_params_for_last_executed_query(values)</font>
<font color="red"> 132.                 params = dict(zip(keys, values))</font>
<font color="red"> 133.             return sql % params</font>
<font color="black"> 134.         # For consistency with SQLiteCursorWrapper.execute(), just return sql</font>
<font color="black"> 135.         # when there are no parameters. See #13648 and #17158.</font>
<font color="black"> 136.         else:</font>
<font color="red"> 137.             return sql</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def quote_name(self, name):</font>
<font color="green"> 140.         if name.startswith('&quot;') and name.endswith('&quot;'):</font>
<font color="red"> 141.             return name  # Quoting once is enough.</font>
<font color="green"> 142.         return '&quot;%s&quot;' % name</font>
<font color="black"> 143. </font>
<font color="green"> 144.     def no_limit_value(self):</font>
<font color="red"> 145.         return -1</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def sql_flush(self, style, tables, sequences, allow_cascade=False):</font>
<font color="black"> 148.         # NB: The generated SQL below is specific to SQLite</font>
<font color="black"> 149.         # Note: The DELETE FROM... SQL generated below works for SQLite databases</font>
<font color="black"> 150.         # because constraints don't exist</font>
<font color="red"> 151.         sql = ['%s %s %s;' % (</font>
<font color="black"> 152.             style.SQL_KEYWORD('DELETE'),</font>
<font color="black"> 153.             style.SQL_KEYWORD('FROM'),</font>
<font color="black"> 154.             style.SQL_FIELD(self.quote_name(table))</font>
<font color="red"> 155.         ) for table in tables]</font>
<font color="black"> 156.         # Note: No requirement for reset of auto-incremented indices (cf. other</font>
<font color="black"> 157.         # sql_flush() implementations). Just return SQL at this point</font>
<font color="red"> 158.         return sql</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def adapt_datetimefield_value(self, value):</font>
<font color="green"> 161.         if value is None:</font>
<font color="red"> 162.             return None</font>
<font color="black"> 163. </font>
<font color="black"> 164.         # SQLite doesn't support tz-aware datetimes</font>
<font color="green"> 165.         if timezone.is_aware(value):</font>
<font color="green"> 166.             if settings.USE_TZ:</font>
<font color="green"> 167.                 value = timezone.make_naive(value, self.connection.timezone)</font>
<font color="black"> 168.             else:</font>
<font color="red"> 169.                 raise ValueError(&quot;SQLite backend does not support timezone-aware datetimes when USE_TZ is False.&quot;)</font>
<font color="black"> 170. </font>
<font color="green"> 171.         return six.text_type(value)</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def adapt_timefield_value(self, value):</font>
<font color="red"> 174.         if value is None:</font>
<font color="red"> 175.             return None</font>
<font color="black"> 176. </font>
<font color="black"> 177.         # SQLite doesn't support tz-aware datetimes</font>
<font color="red"> 178.         if timezone.is_aware(value):</font>
<font color="red"> 179.             raise ValueError(&quot;SQLite backend does not support timezone-aware times.&quot;)</font>
<font color="black"> 180. </font>
<font color="red"> 181.         return six.text_type(value)</font>
<font color="black"> 182. </font>
<font color="green"> 183.     def get_db_converters(self, expression):</font>
<font color="green"> 184.         converters = super(DatabaseOperations, self).get_db_converters(expression)</font>
<font color="green"> 185.         internal_type = expression.output_field.get_internal_type()</font>
<font color="green"> 186.         if internal_type == 'DateTimeField':</font>
<font color="green"> 187.             converters.append(self.convert_datetimefield_value)</font>
<font color="green"> 188.         elif internal_type == 'DateField':</font>
<font color="red"> 189.             converters.append(self.convert_datefield_value)</font>
<font color="green"> 190.         elif internal_type == 'TimeField':</font>
<font color="red"> 191.             converters.append(self.convert_timefield_value)</font>
<font color="green"> 192.         elif internal_type == 'DecimalField':</font>
<font color="red"> 193.             converters.append(self.convert_decimalfield_value)</font>
<font color="green"> 194.         elif internal_type == 'UUIDField':</font>
<font color="red"> 195.             converters.append(self.convert_uuidfield_value)</font>
<font color="green"> 196.         return converters</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def convert_datetimefield_value(self, value, expression, connection, context):</font>
<font color="red"> 199.         if value is not None:</font>
<font color="red"> 200.             if not isinstance(value, datetime.datetime):</font>
<font color="red"> 201.                 value = parse_datetime(value)</font>
<font color="red"> 202.             if settings.USE_TZ:</font>
<font color="red"> 203.                 value = timezone.make_aware(value, self.connection.timezone)</font>
<font color="red"> 204.         return value</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def convert_datefield_value(self, value, expression, connection, context):</font>
<font color="red"> 207.         if value is not None:</font>
<font color="red"> 208.             if not isinstance(value, datetime.date):</font>
<font color="red"> 209.                 value = parse_date(value)</font>
<font color="red"> 210.         return value</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def convert_timefield_value(self, value, expression, connection, context):</font>
<font color="red"> 213.         if value is not None:</font>
<font color="red"> 214.             if not isinstance(value, datetime.time):</font>
<font color="red"> 215.                 value = parse_time(value)</font>
<font color="red"> 216.         return value</font>
<font color="black"> 217. </font>
<font color="green"> 218.     def convert_decimalfield_value(self, value, expression, connection, context):</font>
<font color="red"> 219.         if value is not None:</font>
<font color="red"> 220.             value = expression.output_field.format_number(value)</font>
<font color="red"> 221.             value = backend_utils.typecast_decimal(value)</font>
<font color="red"> 222.         return value</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def convert_uuidfield_value(self, value, expression, connection, context):</font>
<font color="red"> 225.         if value is not None:</font>
<font color="red"> 226.             value = uuid.UUID(value)</font>
<font color="red"> 227.         return value</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def bulk_insert_sql(self, fields, placeholder_rows):</font>
<font color="green"> 230.         return &quot; UNION ALL &quot;.join(</font>
<font color="green"> 231.             &quot;SELECT %s&quot; % &quot;, &quot;.join(row)</font>
<font color="green"> 232.             for row in placeholder_rows</font>
<font color="black"> 233.         )</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def combine_expression(self, connector, sub_expressions):</font>
<font color="black"> 236.         # SQLite doesn't have a power function, so we fake it with a</font>
<font color="black"> 237.         # user-defined function django_power that's registered in connect().</font>
<font color="red"> 238.         if connector == '^':</font>
<font color="red"> 239.             return 'django_power(%s)' % ','.join(sub_expressions)</font>
<font color="red"> 240.         return super(DatabaseOperations, self).combine_expression(connector, sub_expressions)</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def combine_duration_expression(self, connector, sub_expressions):</font>
<font color="red"> 243.         if connector not in ['+', '-']:</font>
<font color="red"> 244.             raise utils.DatabaseError('Invalid connector for timedelta: %s.' % connector)</font>
<font color="red"> 245.         fn_params = [&quot;'%s'&quot; % connector] + sub_expressions</font>
<font color="red"> 246.         if len(fn_params) &gt; 3:</font>
<font color="red"> 247.             raise ValueError('Too many params for timedelta operations.')</font>
<font color="red"> 248.         return &quot;django_format_dtdelta(%s)&quot; % ', '.join(fn_params)</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def integer_field_range(self, internal_type):</font>
<font color="black"> 251.         # SQLite doesn't enforce any integer constraints</font>
<font color="red"> 252.         return (None, None)</font>
</pre>

