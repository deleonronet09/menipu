source file: <b>/usr/lib/python2.7/os.py</b><br>


file stats: <b>387 lines, 6 executed: 1.6% covered</b>
<pre>
<font color="black">   1. r&quot;&quot;&quot;OS routines for Mac, NT, or Posix depending on what system we're on.</font>
<font color="black">   2. </font>
<font color="black">   3. This exports:</font>
<font color="black">   4.   - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.</font>
<font color="black">   5.   - os.path is one of the modules posixpath, or ntpath</font>
<font color="black">   6.   - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos'</font>
<font color="black">   7.   - os.curdir is a string representing the current directory ('.' or ':')</font>
<font color="black">   8.   - os.pardir is a string representing the parent directory ('..' or '::')</font>
<font color="black">   9.   - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')</font>
<font color="black">  10.   - os.extsep is the extension separator ('.' or '/')</font>
<font color="black">  11.   - os.altsep is the alternate pathname separator (None or '/')</font>
<font color="black">  12.   - os.pathsep is the component separator used in $PATH etc</font>
<font color="black">  13.   - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')</font>
<font color="black">  14.   - os.defpath is the default search path for executables</font>
<font color="black">  15.   - os.devnull is the file path of the null device ('/dev/null', etc.)</font>
<font color="black">  16. </font>
<font color="black">  17. Programs that import and use 'os' stand a better chance of being</font>
<font color="black">  18. portable between different platforms.  Of course, they must then</font>
<font color="black">  19. only use functions that are defined by all platforms (e.g., unlink</font>
<font color="black">  20. and opendir), and leave all pathname manipulation to os.path</font>
<font color="black">  21. (e.g., split and join).</font>
<font color="red">  22. &quot;&quot;&quot;</font>
<font color="black">  23. </font>
<font color="black">  24. #'</font>
<font color="black">  25. </font>
<font color="red">  26. import sys, errno</font>
<font color="black">  27. </font>
<font color="red">  28. _names = sys.builtin_module_names</font>
<font color="black">  29. </font>
<font color="black">  30. # Note:  more names are added to __all__ later.</font>
<font color="red">  31. __all__ = [&quot;altsep&quot;, &quot;curdir&quot;, &quot;pardir&quot;, &quot;sep&quot;, &quot;extsep&quot;, &quot;pathsep&quot;, &quot;linesep&quot;,</font>
<font color="red">  32.            &quot;defpath&quot;, &quot;name&quot;, &quot;path&quot;, &quot;devnull&quot;,</font>
<font color="red">  33.            &quot;SEEK_SET&quot;, &quot;SEEK_CUR&quot;, &quot;SEEK_END&quot;]</font>
<font color="black">  34. </font>
<font color="red">  35. def _get_exports_list(module):</font>
<font color="green">  36.     try:</font>
<font color="green">  37.         return list(module.__all__)</font>
<font color="green">  38.     except AttributeError:</font>
<font color="green">  39.         return [n for n in dir(module) if n[0] != '_']</font>
<font color="black">  40. </font>
<font color="red">  41. if 'posix' in _names:</font>
<font color="red">  42.     name = 'posix'</font>
<font color="red">  43.     linesep = '\n'</font>
<font color="red">  44.     from posix import *</font>
<font color="red">  45.     try:</font>
<font color="red">  46.         from posix import _exit</font>
<font color="red">  47.     except ImportError:</font>
<font color="red">  48.         pass</font>
<font color="red">  49.     import posixpath as path</font>
<font color="black">  50. </font>
<font color="red">  51.     import posix</font>
<font color="red">  52.     __all__.extend(_get_exports_list(posix))</font>
<font color="red">  53.     del posix</font>
<font color="black">  54. </font>
<font color="red">  55. elif 'nt' in _names:</font>
<font color="red">  56.     name = 'nt'</font>
<font color="red">  57.     linesep = '\r\n'</font>
<font color="red">  58.     from nt import *</font>
<font color="red">  59.     try:</font>
<font color="red">  60.         from nt import _exit</font>
<font color="red">  61.     except ImportError:</font>
<font color="red">  62.         pass</font>
<font color="red">  63.     import ntpath as path</font>
<font color="black">  64. </font>
<font color="red">  65.     import nt</font>
<font color="red">  66.     __all__.extend(_get_exports_list(nt))</font>
<font color="red">  67.     del nt</font>
<font color="black">  68. </font>
<font color="red">  69. elif 'os2' in _names:</font>
<font color="red">  70.     name = 'os2'</font>
<font color="red">  71.     linesep = '\r\n'</font>
<font color="red">  72.     from os2 import *</font>
<font color="red">  73.     try:</font>
<font color="red">  74.         from os2 import _exit</font>
<font color="red">  75.     except ImportError:</font>
<font color="red">  76.         pass</font>
<font color="red">  77.     if sys.version.find('EMX GCC') == -1:</font>
<font color="red">  78.         import ntpath as path</font>
<font color="black">  79.     else:</font>
<font color="red">  80.         import os2emxpath as path</font>
<font color="red">  81.         from _emx_link import link</font>
<font color="black">  82. </font>
<font color="red">  83.     import os2</font>
<font color="red">  84.     __all__.extend(_get_exports_list(os2))</font>
<font color="red">  85.     del os2</font>
<font color="black">  86. </font>
<font color="red">  87. elif 'ce' in _names:</font>
<font color="red">  88.     name = 'ce'</font>
<font color="red">  89.     linesep = '\r\n'</font>
<font color="red">  90.     from ce import *</font>
<font color="red">  91.     try:</font>
<font color="red">  92.         from ce import _exit</font>
<font color="red">  93.     except ImportError:</font>
<font color="red">  94.         pass</font>
<font color="black">  95.     # We can use the standard Windows path.</font>
<font color="red">  96.     import ntpath as path</font>
<font color="black">  97. </font>
<font color="red">  98.     import ce</font>
<font color="red">  99.     __all__.extend(_get_exports_list(ce))</font>
<font color="red"> 100.     del ce</font>
<font color="black"> 101. </font>
<font color="red"> 102. elif 'riscos' in _names:</font>
<font color="red"> 103.     name = 'riscos'</font>
<font color="red"> 104.     linesep = '\n'</font>
<font color="red"> 105.     from riscos import *</font>
<font color="red"> 106.     try:</font>
<font color="red"> 107.         from riscos import _exit</font>
<font color="red"> 108.     except ImportError:</font>
<font color="red"> 109.         pass</font>
<font color="red"> 110.     import riscospath as path</font>
<font color="black"> 111. </font>
<font color="red"> 112.     import riscos</font>
<font color="red"> 113.     __all__.extend(_get_exports_list(riscos))</font>
<font color="red"> 114.     del riscos</font>
<font color="black"> 115. </font>
<font color="black"> 116. else:</font>
<font color="red"> 117.     raise ImportError, 'no os specific module found'</font>
<font color="black"> 118. </font>
<font color="red"> 119. sys.modules['os.path'] = path</font>
<font color="red"> 120. from os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,</font>
<font color="black"> 121.     devnull)</font>
<font color="black"> 122. </font>
<font color="red"> 123. del _names</font>
<font color="black"> 124. </font>
<font color="black"> 125. # Python uses fixed values for the SEEK_ constants; they are mapped</font>
<font color="black"> 126. # to native constants if necessary in posixmodule.c</font>
<font color="red"> 127. SEEK_SET = 0</font>
<font color="red"> 128. SEEK_CUR = 1</font>
<font color="red"> 129. SEEK_END = 2</font>
<font color="black"> 130. </font>
<font color="black"> 131. #'</font>
<font color="black"> 132. </font>
<font color="black"> 133. # Super directory utilities.</font>
<font color="black"> 134. # (Inspired by Eric Raymond; the doc strings are mostly his)</font>
<font color="black"> 135. </font>
<font color="red"> 136. def makedirs(name, mode=0777):</font>
<font color="black"> 137.     &quot;&quot;&quot;makedirs(path [, mode=0777])</font>
<font color="black"> 138. </font>
<font color="black"> 139.     Super-mkdir; create a leaf directory and all intermediate ones.</font>
<font color="black"> 140.     Works like mkdir, except that any intermediate path segment (not</font>
<font color="black"> 141.     just the rightmost) will be created if it does not exist.  This is</font>
<font color="black"> 142.     recursive.</font>
<font color="black"> 143. </font>
<font color="black"> 144.     &quot;&quot;&quot;</font>
<font color="red"> 145.     head, tail = path.split(name)</font>
<font color="red"> 146.     if not tail:</font>
<font color="red"> 147.         head, tail = path.split(head)</font>
<font color="red"> 148.     if head and tail and not path.exists(head):</font>
<font color="red"> 149.         try:</font>
<font color="red"> 150.             makedirs(head, mode)</font>
<font color="red"> 151.         except OSError, e:</font>
<font color="black"> 152.             # be happy if someone already created the path</font>
<font color="red"> 153.             if e.errno != errno.EEXIST:</font>
<font color="red"> 154.                 raise</font>
<font color="red"> 155.         if tail == curdir:           # xxx/newdir/. exists if xxx/newdir exists</font>
<font color="red"> 156.             return</font>
<font color="red"> 157.     mkdir(name, mode)</font>
<font color="black"> 158. </font>
<font color="red"> 159. def removedirs(name):</font>
<font color="black"> 160.     &quot;&quot;&quot;removedirs(path)</font>
<font color="black"> 161. </font>
<font color="black"> 162.     Super-rmdir; remove a leaf directory and all empty intermediate</font>
<font color="black"> 163.     ones.  Works like rmdir except that, if the leaf directory is</font>
<font color="black"> 164.     successfully removed, directories corresponding to rightmost path</font>
<font color="black"> 165.     segments will be pruned away until either the whole path is</font>
<font color="black"> 166.     consumed or an error occurs.  Errors during this latter phase are</font>
<font color="black"> 167.     ignored -- they generally mean that a directory was not empty.</font>
<font color="black"> 168. </font>
<font color="black"> 169.     &quot;&quot;&quot;</font>
<font color="red"> 170.     rmdir(name)</font>
<font color="red"> 171.     head, tail = path.split(name)</font>
<font color="red"> 172.     if not tail:</font>
<font color="red"> 173.         head, tail = path.split(head)</font>
<font color="red"> 174.     while head and tail:</font>
<font color="red"> 175.         try:</font>
<font color="red"> 176.             rmdir(head)</font>
<font color="red"> 177.         except error:</font>
<font color="red"> 178.             break</font>
<font color="red"> 179.         head, tail = path.split(head)</font>
<font color="black"> 180. </font>
<font color="red"> 181. def renames(old, new):</font>
<font color="black"> 182.     &quot;&quot;&quot;renames(old, new)</font>
<font color="black"> 183. </font>
<font color="black"> 184.     Super-rename; create directories as necessary and delete any left</font>
<font color="black"> 185.     empty.  Works like rename, except creation of any intermediate</font>
<font color="black"> 186.     directories needed to make the new pathname good is attempted</font>
<font color="black"> 187.     first.  After the rename, directories corresponding to rightmost</font>
<font color="black"> 188.     path segments of the old name will be pruned way until either the</font>
<font color="black"> 189.     whole path is consumed or a nonempty directory is found.</font>
<font color="black"> 190. </font>
<font color="black"> 191.     Note: this function can fail with the new directory structure made</font>
<font color="black"> 192.     if you lack permissions needed to unlink the leaf directory or</font>
<font color="black"> 193.     file.</font>
<font color="black"> 194. </font>
<font color="black"> 195.     &quot;&quot;&quot;</font>
<font color="red"> 196.     head, tail = path.split(new)</font>
<font color="red"> 197.     if head and tail and not path.exists(head):</font>
<font color="red"> 198.         makedirs(head)</font>
<font color="red"> 199.     rename(old, new)</font>
<font color="red"> 200.     head, tail = path.split(old)</font>
<font color="red"> 201.     if head and tail:</font>
<font color="red"> 202.         try:</font>
<font color="red"> 203.             removedirs(head)</font>
<font color="red"> 204.         except error:</font>
<font color="red"> 205.             pass</font>
<font color="black"> 206. </font>
<font color="red"> 207. __all__.extend([&quot;makedirs&quot;, &quot;removedirs&quot;, &quot;renames&quot;])</font>
<font color="black"> 208. </font>
<font color="red"> 209. def walk(top, topdown=True, onerror=None, followlinks=False):</font>
<font color="black"> 210.     &quot;&quot;&quot;Directory tree generator.</font>
<font color="black"> 211. </font>
<font color="black"> 212.     For each directory in the directory tree rooted at top (including top</font>
<font color="black"> 213.     itself, but excluding '.' and '..'), yields a 3-tuple</font>
<font color="black"> 214. </font>
<font color="black"> 215.         dirpath, dirnames, filenames</font>
<font color="black"> 216. </font>
<font color="black"> 217.     dirpath is a string, the path to the directory.  dirnames is a list of</font>
<font color="black"> 218.     the names of the subdirectories in dirpath (excluding '.' and '..').</font>
<font color="black"> 219.     filenames is a list of the names of the non-directory files in dirpath.</font>
<font color="black"> 220.     Note that the names in the lists are just names, with no path components.</font>
<font color="black"> 221.     To get a full path (which begins with top) to a file or directory in</font>
<font color="black"> 222.     dirpath, do os.path.join(dirpath, name).</font>
<font color="black"> 223. </font>
<font color="black"> 224.     If optional arg 'topdown' is true or not specified, the triple for a</font>
<font color="black"> 225.     directory is generated before the triples for any of its subdirectories</font>
<font color="black"> 226.     (directories are generated top down).  If topdown is false, the triple</font>
<font color="black"> 227.     for a directory is generated after the triples for all of its</font>
<font color="black"> 228.     subdirectories (directories are generated bottom up).</font>
<font color="black"> 229. </font>
<font color="black"> 230.     When topdown is true, the caller can modify the dirnames list in-place</font>
<font color="black"> 231.     (e.g., via del or slice assignment), and walk will only recurse into the</font>
<font color="black"> 232.     subdirectories whose names remain in dirnames; this can be used to prune</font>
<font color="black"> 233.     the search, or to impose a specific order of visiting.  Modifying</font>
<font color="black"> 234.     dirnames when topdown is false is ineffective, since the directories in</font>
<font color="black"> 235.     dirnames have already been generated by the time dirnames itself is</font>
<font color="black"> 236.     generated.</font>
<font color="black"> 237. </font>
<font color="black"> 238.     By default errors from the os.listdir() call are ignored.  If</font>
<font color="black"> 239.     optional arg 'onerror' is specified, it should be a function; it</font>
<font color="black"> 240.     will be called with one argument, an os.error instance.  It can</font>
<font color="black"> 241.     report the error to continue with the walk, or raise the exception</font>
<font color="black"> 242.     to abort the walk.  Note that the filename is available as the</font>
<font color="black"> 243.     filename attribute of the exception object.</font>
<font color="black"> 244. </font>
<font color="black"> 245.     By default, os.walk does not follow symbolic links to subdirectories on</font>
<font color="black"> 246.     systems that support them.  In order to get this functionality, set the</font>
<font color="black"> 247.     optional argument 'followlinks' to true.</font>
<font color="black"> 248. </font>
<font color="black"> 249.     Caution:  if you pass a relative pathname for top, don't change the</font>
<font color="black"> 250.     current working directory between resumptions of walk.  walk never</font>
<font color="black"> 251.     changes the current directory, and assumes that the client doesn't</font>
<font color="black"> 252.     either.</font>
<font color="black"> 253. </font>
<font color="black"> 254.     Example:</font>
<font color="black"> 255. </font>
<font color="black"> 256.     import os</font>
<font color="black"> 257.     from os.path import join, getsize</font>
<font color="black"> 258.     for root, dirs, files in os.walk('python/Lib/email'):</font>
<font color="black"> 259.         print root, &quot;consumes&quot;,</font>
<font color="black"> 260.         print sum([getsize(join(root, name)) for name in files]),</font>
<font color="black"> 261.         print &quot;bytes in&quot;, len(files), &quot;non-directory files&quot;</font>
<font color="black"> 262.         if 'CVS' in dirs:</font>
<font color="black"> 263.             dirs.remove('CVS')  # don't visit CVS directories</font>
<font color="black"> 264.     &quot;&quot;&quot;</font>
<font color="black"> 265. </font>
<font color="red"> 266.     islink, join, isdir = path.islink, path.join, path.isdir</font>
<font color="black"> 267. </font>
<font color="black"> 268.     # We may not have read permission for top, in which case we can't</font>
<font color="black"> 269.     # get a list of the files the directory contains.  os.path.walk</font>
<font color="black"> 270.     # always suppressed the exception then, rather than blow up for a</font>
<font color="black"> 271.     # minor reason when (say) a thousand readable directories are still</font>
<font color="black"> 272.     # left to visit.  That logic is copied here.</font>
<font color="red"> 273.     try:</font>
<font color="black"> 274.         # Note that listdir and error are globals in this module due</font>
<font color="black"> 275.         # to earlier import-*.</font>
<font color="red"> 276.         names = listdir(top)</font>
<font color="red"> 277.     except error, err:</font>
<font color="red"> 278.         if onerror is not None:</font>
<font color="red"> 279.             onerror(err)</font>
<font color="red"> 280.         return</font>
<font color="black"> 281. </font>
<font color="red"> 282.     dirs, nondirs = [], []</font>
<font color="red"> 283.     for name in names:</font>
<font color="red"> 284.         if isdir(join(top, name)):</font>
<font color="red"> 285.             dirs.append(name)</font>
<font color="black"> 286.         else:</font>
<font color="red"> 287.             nondirs.append(name)</font>
<font color="black"> 288. </font>
<font color="red"> 289.     if topdown:</font>
<font color="red"> 290.         yield top, dirs, nondirs</font>
<font color="red"> 291.     for name in dirs:</font>
<font color="red"> 292.         new_path = join(top, name)</font>
<font color="red"> 293.         if followlinks or not islink(new_path):</font>
<font color="red"> 294.             for x in walk(new_path, topdown, onerror, followlinks):</font>
<font color="red"> 295.                 yield x</font>
<font color="red"> 296.     if not topdown:</font>
<font color="red"> 297.         yield top, dirs, nondirs</font>
<font color="black"> 298. </font>
<font color="red"> 299. __all__.append(&quot;walk&quot;)</font>
<font color="black"> 300. </font>
<font color="black"> 301. # Make sure os.environ exists, at least</font>
<font color="red"> 302. try:</font>
<font color="red"> 303.     environ</font>
<font color="red"> 304. except NameError:</font>
<font color="red"> 305.     environ = {}</font>
<font color="black"> 306. </font>
<font color="red"> 307. def execl(file, *args):</font>
<font color="black"> 308.     &quot;&quot;&quot;execl(file, *args)</font>
<font color="black"> 309. </font>
<font color="black"> 310.     Execute the executable file with argument list args, replacing the</font>
<font color="black"> 311.     current process. &quot;&quot;&quot;</font>
<font color="red"> 312.     execv(file, args)</font>
<font color="black"> 313. </font>
<font color="red"> 314. def execle(file, *args):</font>
<font color="black"> 315.     &quot;&quot;&quot;execle(file, *args, env)</font>
<font color="black"> 316. </font>
<font color="black"> 317.     Execute the executable file with argument list args and</font>
<font color="black"> 318.     environment env, replacing the current process. &quot;&quot;&quot;</font>
<font color="red"> 319.     env = args[-1]</font>
<font color="red"> 320.     execve(file, args[:-1], env)</font>
<font color="black"> 321. </font>
<font color="red"> 322. def execlp(file, *args):</font>
<font color="black"> 323.     &quot;&quot;&quot;execlp(file, *args)</font>
<font color="black"> 324. </font>
<font color="black"> 325.     Execute the executable file (which is searched for along $PATH)</font>
<font color="black"> 326.     with argument list args, replacing the current process. &quot;&quot;&quot;</font>
<font color="red"> 327.     execvp(file, args)</font>
<font color="black"> 328. </font>
<font color="red"> 329. def execlpe(file, *args):</font>
<font color="black"> 330.     &quot;&quot;&quot;execlpe(file, *args, env)</font>
<font color="black"> 331. </font>
<font color="black"> 332.     Execute the executable file (which is searched for along $PATH)</font>
<font color="black"> 333.     with argument list args and environment env, replacing the current</font>
<font color="black"> 334.     process. &quot;&quot;&quot;</font>
<font color="red"> 335.     env = args[-1]</font>
<font color="red"> 336.     execvpe(file, args[:-1], env)</font>
<font color="black"> 337. </font>
<font color="red"> 338. def execvp(file, args):</font>
<font color="black"> 339.     &quot;&quot;&quot;execvp(file, args)</font>
<font color="black"> 340. </font>
<font color="black"> 341.     Execute the executable file (which is searched for along $PATH)</font>
<font color="black"> 342.     with argument list args, replacing the current process.</font>
<font color="black"> 343.     args may be a list or tuple of strings. &quot;&quot;&quot;</font>
<font color="red"> 344.     _execvpe(file, args)</font>
<font color="black"> 345. </font>
<font color="red"> 346. def execvpe(file, args, env):</font>
<font color="black"> 347.     &quot;&quot;&quot;execvpe(file, args, env)</font>
<font color="black"> 348. </font>
<font color="black"> 349.     Execute the executable file (which is searched for along $PATH)</font>
<font color="black"> 350.     with argument list args and environment env , replacing the</font>
<font color="black"> 351.     current process.</font>
<font color="black"> 352.     args may be a list or tuple of strings. &quot;&quot;&quot;</font>
<font color="red"> 353.     _execvpe(file, args, env)</font>
<font color="black"> 354. </font>
<font color="red"> 355. __all__.extend([&quot;execl&quot;,&quot;execle&quot;,&quot;execlp&quot;,&quot;execlpe&quot;,&quot;execvp&quot;,&quot;execvpe&quot;])</font>
<font color="black"> 356. </font>
<font color="red"> 357. def _execvpe(file, args, env=None):</font>
<font color="red"> 358.     if env is not None:</font>
<font color="red"> 359.         func = execve</font>
<font color="red"> 360.         argrest = (args, env)</font>
<font color="black"> 361.     else:</font>
<font color="red"> 362.         func = execv</font>
<font color="red"> 363.         argrest = (args,)</font>
<font color="red"> 364.         env = environ</font>
<font color="black"> 365. </font>
<font color="red"> 366.     head, tail = path.split(file)</font>
<font color="red"> 367.     if head:</font>
<font color="red"> 368.         func(file, *argrest)</font>
<font color="red"> 369.         return</font>
<font color="red"> 370.     if 'PATH' in env:</font>
<font color="red"> 371.         envpath = env['PATH']</font>
<font color="black"> 372.     else:</font>
<font color="red"> 373.         envpath = defpath</font>
<font color="red"> 374.     PATH = envpath.split(pathsep)</font>
<font color="red"> 375.     saved_exc = None</font>
<font color="red"> 376.     saved_tb = None</font>
<font color="red"> 377.     for dir in PATH:</font>
<font color="red"> 378.         fullname = path.join(dir, file)</font>
<font color="red"> 379.         try:</font>
<font color="red"> 380.             func(fullname, *argrest)</font>
<font color="red"> 381.         except error, e:</font>
<font color="red"> 382.             tb = sys.exc_info()[2]</font>
<font color="red"> 383.             if (e.errno != errno.ENOENT and e.errno != errno.ENOTDIR</font>
<font color="red"> 384.                 and saved_exc is None):</font>
<font color="red"> 385.                 saved_exc = e</font>
<font color="red"> 386.                 saved_tb = tb</font>
<font color="red"> 387.     if saved_exc:</font>
<font color="red"> 388.         raise error, saved_exc, saved_tb</font>
<font color="red"> 389.     raise error, e, tb</font>
<font color="black"> 390. </font>
<font color="black"> 391. # Change environ to automatically call putenv() if it exists</font>
<font color="red"> 392. try:</font>
<font color="black"> 393.     # This will fail if there's no putenv</font>
<font color="red"> 394.     putenv</font>
<font color="red"> 395. except NameError:</font>
<font color="red"> 396.     pass</font>
<font color="black"> 397. else:</font>
<font color="red"> 398.     import UserDict</font>
<font color="black"> 399. </font>
<font color="black"> 400.     # Fake unsetenv() for Windows</font>
<font color="black"> 401.     # not sure about os2 here but</font>
<font color="black"> 402.     # I'm guessing they are the same.</font>
<font color="black"> 403. </font>
<font color="red"> 404.     if name in ('os2', 'nt'):</font>
<font color="red"> 405.         def unsetenv(key):</font>
<font color="red"> 406.             putenv(key, &quot;&quot;)</font>
<font color="black"> 407. </font>
<font color="red"> 408.     if name == &quot;riscos&quot;:</font>
<font color="black"> 409.         # On RISC OS, all env access goes through getenv and putenv</font>
<font color="red"> 410.         from riscosenviron import _Environ</font>
<font color="red"> 411.     elif name in ('os2', 'nt'):  # Where Env Var Names Must Be UPPERCASE</font>
<font color="black"> 412.         # But we store them as upper case</font>
<font color="red"> 413.         class _Environ(UserDict.IterableUserDict):</font>
<font color="red"> 414.             def __init__(self, environ):</font>
<font color="red"> 415.                 UserDict.UserDict.__init__(self)</font>
<font color="red"> 416.                 data = self.data</font>
<font color="red"> 417.                 for k, v in environ.items():</font>
<font color="red"> 418.                     data[k.upper()] = v</font>
<font color="red"> 419.             def __setitem__(self, key, item):</font>
<font color="red"> 420.                 putenv(key, item)</font>
<font color="red"> 421.                 self.data[key.upper()] = item</font>
<font color="red"> 422.             def __getitem__(self, key):</font>
<font color="red"> 423.                 return self.data[key.upper()]</font>
<font color="red"> 424.             try:</font>
<font color="red"> 425.                 unsetenv</font>
<font color="red"> 426.             except NameError:</font>
<font color="red"> 427.                 def __delitem__(self, key):</font>
<font color="red"> 428.                     del self.data[key.upper()]</font>
<font color="black"> 429.             else:</font>
<font color="red"> 430.                 def __delitem__(self, key):</font>
<font color="red"> 431.                     unsetenv(key)</font>
<font color="red"> 432.                     del self.data[key.upper()]</font>
<font color="red"> 433.                 def clear(self):</font>
<font color="red"> 434.                     for key in self.data.keys():</font>
<font color="red"> 435.                         unsetenv(key)</font>
<font color="red"> 436.                         del self.data[key]</font>
<font color="red"> 437.                 def pop(self, key, *args):</font>
<font color="red"> 438.                     unsetenv(key)</font>
<font color="red"> 439.                     return self.data.pop(key.upper(), *args)</font>
<font color="red"> 440.             def has_key(self, key):</font>
<font color="red"> 441.                 return key.upper() in self.data</font>
<font color="red"> 442.             def __contains__(self, key):</font>
<font color="red"> 443.                 return key.upper() in self.data</font>
<font color="red"> 444.             def get(self, key, failobj=None):</font>
<font color="red"> 445.                 return self.data.get(key.upper(), failobj)</font>
<font color="red"> 446.             def update(self, dict=None, **kwargs):</font>
<font color="red"> 447.                 if dict:</font>
<font color="red"> 448.                     try:</font>
<font color="red"> 449.                         keys = dict.keys()</font>
<font color="red"> 450.                     except AttributeError:</font>
<font color="black"> 451.                         # List of (key, value)</font>
<font color="red"> 452.                         for k, v in dict:</font>
<font color="red"> 453.                             self[k] = v</font>
<font color="black"> 454.                     else:</font>
<font color="black"> 455.                         # got keys</font>
<font color="black"> 456.                         # cannot use items(), since mappings</font>
<font color="black"> 457.                         # may not have them.</font>
<font color="red"> 458.                         for k in keys:</font>
<font color="red"> 459.                             self[k] = dict[k]</font>
<font color="red"> 460.                 if kwargs:</font>
<font color="red"> 461.                     self.update(kwargs)</font>
<font color="red"> 462.             def copy(self):</font>
<font color="red"> 463.                 return dict(self)</font>
<font color="black"> 464. </font>
<font color="black"> 465.     else:  # Where Env Var Names Can Be Mixed Case</font>
<font color="red"> 466.         class _Environ(UserDict.IterableUserDict):</font>
<font color="red"> 467.             def __init__(self, environ):</font>
<font color="red"> 468.                 UserDict.UserDict.__init__(self)</font>
<font color="red"> 469.                 self.data = environ</font>
<font color="red"> 470.             def __setitem__(self, key, item):</font>
<font color="green"> 471.                 putenv(key, item)</font>
<font color="green"> 472.                 self.data[key] = item</font>
<font color="red"> 473.             def update(self,  dict=None, **kwargs):</font>
<font color="red"> 474.                 if dict:</font>
<font color="red"> 475.                     try:</font>
<font color="red"> 476.                         keys = dict.keys()</font>
<font color="red"> 477.                     except AttributeError:</font>
<font color="black"> 478.                         # List of (key, value)</font>
<font color="red"> 479.                         for k, v in dict:</font>
<font color="red"> 480.                             self[k] = v</font>
<font color="black"> 481.                     else:</font>
<font color="black"> 482.                         # got keys</font>
<font color="black"> 483.                         # cannot use items(), since mappings</font>
<font color="black"> 484.                         # may not have them.</font>
<font color="red"> 485.                         for k in keys:</font>
<font color="red"> 486.                             self[k] = dict[k]</font>
<font color="red"> 487.                 if kwargs:</font>
<font color="red"> 488.                     self.update(kwargs)</font>
<font color="red"> 489.             try:</font>
<font color="red"> 490.                 unsetenv</font>
<font color="red"> 491.             except NameError:</font>
<font color="red"> 492.                 pass</font>
<font color="black"> 493.             else:</font>
<font color="red"> 494.                 def __delitem__(self, key):</font>
<font color="red"> 495.                     unsetenv(key)</font>
<font color="red"> 496.                     del self.data[key]</font>
<font color="red"> 497.                 def clear(self):</font>
<font color="red"> 498.                     for key in self.data.keys():</font>
<font color="red"> 499.                         unsetenv(key)</font>
<font color="red"> 500.                         del self.data[key]</font>
<font color="red"> 501.                 def pop(self, key, *args):</font>
<font color="red"> 502.                     unsetenv(key)</font>
<font color="red"> 503.                     return self.data.pop(key, *args)</font>
<font color="red"> 504.             def copy(self):</font>
<font color="red"> 505.                 return dict(self)</font>
<font color="black"> 506. </font>
<font color="black"> 507. </font>
<font color="red"> 508.     environ = _Environ(environ)</font>
<font color="black"> 509. </font>
<font color="red"> 510. def getenv(key, default=None):</font>
<font color="black"> 511.     &quot;&quot;&quot;Get an environment variable, return None if it doesn't exist.</font>
<font color="black"> 512.     The optional second argument can specify an alternate default.&quot;&quot;&quot;</font>
<font color="red"> 513.     return environ.get(key, default)</font>
<font color="red"> 514. __all__.append(&quot;getenv&quot;)</font>
<font color="black"> 515. </font>
<font color="red"> 516. def _exists(name):</font>
<font color="red"> 517.     return name in globals()</font>
<font color="black"> 518. </font>
<font color="black"> 519. # Supply spawn*() (probably only for Unix)</font>
<font color="red"> 520. if _exists(&quot;fork&quot;) and not _exists(&quot;spawnv&quot;) and _exists(&quot;execv&quot;):</font>
<font color="black"> 521. </font>
<font color="red"> 522.     P_WAIT = 0</font>
<font color="red"> 523.     P_NOWAIT = P_NOWAITO = 1</font>
<font color="black"> 524. </font>
<font color="black"> 525.     # XXX Should we support P_DETACH?  I suppose it could fork()**2</font>
<font color="black"> 526.     # and close the std I/O streams.  Also, P_OVERLAY is the same</font>
<font color="black"> 527.     # as execv*()?</font>
<font color="black"> 528. </font>
<font color="red"> 529.     def _spawnvef(mode, file, args, env, func):</font>
<font color="black"> 530.         # Internal helper; func is the exec*() function to use</font>
<font color="red"> 531.         pid = fork()</font>
<font color="red"> 532.         if not pid:</font>
<font color="black"> 533.             # Child</font>
<font color="red"> 534.             try:</font>
<font color="red"> 535.                 if env is None:</font>
<font color="red"> 536.                     func(file, args)</font>
<font color="black"> 537.                 else:</font>
<font color="red"> 538.                     func(file, args, env)</font>
<font color="red"> 539.             except:</font>
<font color="red"> 540.                 _exit(127)</font>
<font color="black"> 541.         else:</font>
<font color="black"> 542.             # Parent</font>
<font color="red"> 543.             if mode == P_NOWAIT:</font>
<font color="red"> 544.                 return pid # Caller is responsible for waiting!</font>
<font color="red"> 545.             while 1:</font>
<font color="red"> 546.                 wpid, sts = waitpid(pid, 0)</font>
<font color="red"> 547.                 if WIFSTOPPED(sts):</font>
<font color="red"> 548.                     continue</font>
<font color="red"> 549.                 elif WIFSIGNALED(sts):</font>
<font color="red"> 550.                     return -WTERMSIG(sts)</font>
<font color="red"> 551.                 elif WIFEXITED(sts):</font>
<font color="red"> 552.                     return WEXITSTATUS(sts)</font>
<font color="black"> 553.                 else:</font>
<font color="red"> 554.                     raise error, &quot;Not stopped, signaled or exited???&quot;</font>
<font color="black"> 555. </font>
<font color="red"> 556.     def spawnv(mode, file, args):</font>
<font color="black"> 557.         &quot;&quot;&quot;spawnv(mode, file, args) -&gt; integer</font>
<font color="black"> 558. </font>
<font color="black"> 559. Execute file with arguments from args in a subprocess.</font>
<font color="black"> 560. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 561. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 562. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 563.         return _spawnvef(mode, file, args, None, execv)</font>
<font color="black"> 564. </font>
<font color="red"> 565.     def spawnve(mode, file, args, env):</font>
<font color="black"> 566.         &quot;&quot;&quot;spawnve(mode, file, args, env) -&gt; integer</font>
<font color="black"> 567. </font>
<font color="black"> 568. Execute file with arguments from args in a subprocess with the</font>
<font color="black"> 569. specified environment.</font>
<font color="black"> 570. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 571. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 572. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 573.         return _spawnvef(mode, file, args, env, execve)</font>
<font color="black"> 574. </font>
<font color="black"> 575.     # Note: spawnvp[e] is't currently supported on Windows</font>
<font color="black"> 576. </font>
<font color="red"> 577.     def spawnvp(mode, file, args):</font>
<font color="black"> 578.         &quot;&quot;&quot;spawnvp(mode, file, args) -&gt; integer</font>
<font color="black"> 579. </font>
<font color="black"> 580. Execute file (which is looked for along $PATH) with arguments from</font>
<font color="black"> 581. args in a subprocess.</font>
<font color="black"> 582. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 583. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 584. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 585.         return _spawnvef(mode, file, args, None, execvp)</font>
<font color="black"> 586. </font>
<font color="red"> 587.     def spawnvpe(mode, file, args, env):</font>
<font color="black"> 588.         &quot;&quot;&quot;spawnvpe(mode, file, args, env) -&gt; integer</font>
<font color="black"> 589. </font>
<font color="black"> 590. Execute file (which is looked for along $PATH) with arguments from</font>
<font color="black"> 591. args in a subprocess with the supplied environment.</font>
<font color="black"> 592. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 593. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 594. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 595.         return _spawnvef(mode, file, args, env, execvpe)</font>
<font color="black"> 596. </font>
<font color="red"> 597. if _exists(&quot;spawnv&quot;):</font>
<font color="black"> 598.     # These aren't supplied by the basic Windows code</font>
<font color="black"> 599.     # but can be easily implemented in Python</font>
<font color="black"> 600. </font>
<font color="red"> 601.     def spawnl(mode, file, *args):</font>
<font color="black"> 602.         &quot;&quot;&quot;spawnl(mode, file, *args) -&gt; integer</font>
<font color="black"> 603. </font>
<font color="black"> 604. Execute file with arguments from args in a subprocess.</font>
<font color="black"> 605. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 606. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 607. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 608.         return spawnv(mode, file, args)</font>
<font color="black"> 609. </font>
<font color="red"> 610.     def spawnle(mode, file, *args):</font>
<font color="black"> 611.         &quot;&quot;&quot;spawnle(mode, file, *args, env) -&gt; integer</font>
<font color="black"> 612. </font>
<font color="black"> 613. Execute file with arguments from args in a subprocess with the</font>
<font color="black"> 614. supplied environment.</font>
<font color="black"> 615. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 616. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 617. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 618.         env = args[-1]</font>
<font color="red"> 619.         return spawnve(mode, file, args[:-1], env)</font>
<font color="black"> 620. </font>
<font color="black"> 621. </font>
<font color="red"> 622.     __all__.extend([&quot;spawnv&quot;, &quot;spawnve&quot;, &quot;spawnl&quot;, &quot;spawnle&quot;,])</font>
<font color="black"> 623. </font>
<font color="black"> 624. </font>
<font color="red"> 625. if _exists(&quot;spawnvp&quot;):</font>
<font color="black"> 626.     # At the moment, Windows doesn't implement spawnvp[e],</font>
<font color="black"> 627.     # so it won't have spawnlp[e] either.</font>
<font color="red"> 628.     def spawnlp(mode, file, *args):</font>
<font color="black"> 629.         &quot;&quot;&quot;spawnlp(mode, file, *args) -&gt; integer</font>
<font color="black"> 630. </font>
<font color="black"> 631. Execute file (which is looked for along $PATH) with arguments from</font>
<font color="black"> 632. args in a subprocess with the supplied environment.</font>
<font color="black"> 633. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 634. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 635. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 636.         return spawnvp(mode, file, args)</font>
<font color="black"> 637. </font>
<font color="red"> 638.     def spawnlpe(mode, file, *args):</font>
<font color="black"> 639.         &quot;&quot;&quot;spawnlpe(mode, file, *args, env) -&gt; integer</font>
<font color="black"> 640. </font>
<font color="black"> 641. Execute file (which is looked for along $PATH) with arguments from</font>
<font color="black"> 642. args in a subprocess with the supplied environment.</font>
<font color="black"> 643. If mode == P_NOWAIT return the pid of the process.</font>
<font color="black"> 644. If mode == P_WAIT return the process's exit code if it exits normally;</font>
<font color="black"> 645. otherwise return -SIG, where SIG is the signal that killed it. &quot;&quot;&quot;</font>
<font color="red"> 646.         env = args[-1]</font>
<font color="red"> 647.         return spawnvpe(mode, file, args[:-1], env)</font>
<font color="black"> 648. </font>
<font color="black"> 649. </font>
<font color="red"> 650.     __all__.extend([&quot;spawnvp&quot;, &quot;spawnvpe&quot;, &quot;spawnlp&quot;, &quot;spawnlpe&quot;,])</font>
<font color="black"> 651. </font>
<font color="black"> 652. </font>
<font color="black"> 653. # Supply popen2 etc. (for Unix)</font>
<font color="red"> 654. if _exists(&quot;fork&quot;):</font>
<font color="red"> 655.     if not _exists(&quot;popen2&quot;):</font>
<font color="red"> 656.         def popen2(cmd, mode=&quot;t&quot;, bufsize=-1):</font>
<font color="black"> 657.             &quot;&quot;&quot;Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'</font>
<font color="black"> 658.             may be a sequence, in which case arguments will be passed directly to</font>
<font color="black"> 659.             the program without shell intervention (as with os.spawnv()).  If 'cmd'</font>
<font color="black"> 660.             is a string it will be passed to the shell (as with os.system()). If</font>
<font color="black"> 661.             'bufsize' is specified, it sets the buffer size for the I/O pipes.  The</font>
<font color="black"> 662.             file objects (child_stdin, child_stdout) are returned.&quot;&quot;&quot;</font>
<font color="red"> 663.             import warnings</font>
<font color="red"> 664.             msg = &quot;os.popen2 is deprecated.  Use the subprocess module.&quot;</font>
<font color="red"> 665.             warnings.warn(msg, DeprecationWarning, stacklevel=2)</font>
<font color="black"> 666. </font>
<font color="red"> 667.             import subprocess</font>
<font color="red"> 668.             PIPE = subprocess.PIPE</font>
<font color="red"> 669.             p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),</font>
<font color="red"> 670.                                  bufsize=bufsize, stdin=PIPE, stdout=PIPE,</font>
<font color="red"> 671.                                  close_fds=True)</font>
<font color="red"> 672.             return p.stdin, p.stdout</font>
<font color="red"> 673.         __all__.append(&quot;popen2&quot;)</font>
<font color="black"> 674. </font>
<font color="red"> 675.     if not _exists(&quot;popen3&quot;):</font>
<font color="red"> 676.         def popen3(cmd, mode=&quot;t&quot;, bufsize=-1):</font>
<font color="black"> 677.             &quot;&quot;&quot;Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'</font>
<font color="black"> 678.             may be a sequence, in which case arguments will be passed directly to</font>
<font color="black"> 679.             the program without shell intervention (as with os.spawnv()).  If 'cmd'</font>
<font color="black"> 680.             is a string it will be passed to the shell (as with os.system()). If</font>
<font color="black"> 681.             'bufsize' is specified, it sets the buffer size for the I/O pipes.  The</font>
<font color="black"> 682.             file objects (child_stdin, child_stdout, child_stderr) are returned.&quot;&quot;&quot;</font>
<font color="red"> 683.             import warnings</font>
<font color="red"> 684.             msg = &quot;os.popen3 is deprecated.  Use the subprocess module.&quot;</font>
<font color="red"> 685.             warnings.warn(msg, DeprecationWarning, stacklevel=2)</font>
<font color="black"> 686. </font>
<font color="red"> 687.             import subprocess</font>
<font color="red"> 688.             PIPE = subprocess.PIPE</font>
<font color="red"> 689.             p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),</font>
<font color="red"> 690.                                  bufsize=bufsize, stdin=PIPE, stdout=PIPE,</font>
<font color="red"> 691.                                  stderr=PIPE, close_fds=True)</font>
<font color="red"> 692.             return p.stdin, p.stdout, p.stderr</font>
<font color="red"> 693.         __all__.append(&quot;popen3&quot;)</font>
<font color="black"> 694. </font>
<font color="red"> 695.     if not _exists(&quot;popen4&quot;):</font>
<font color="red"> 696.         def popen4(cmd, mode=&quot;t&quot;, bufsize=-1):</font>
<font color="black"> 697.             &quot;&quot;&quot;Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'</font>
<font color="black"> 698.             may be a sequence, in which case arguments will be passed directly to</font>
<font color="black"> 699.             the program without shell intervention (as with os.spawnv()).  If 'cmd'</font>
<font color="black"> 700.             is a string it will be passed to the shell (as with os.system()). If</font>
<font color="black"> 701.             'bufsize' is specified, it sets the buffer size for the I/O pipes.  The</font>
<font color="black"> 702.             file objects (child_stdin, child_stdout_stderr) are returned.&quot;&quot;&quot;</font>
<font color="red"> 703.             import warnings</font>
<font color="red"> 704.             msg = &quot;os.popen4 is deprecated.  Use the subprocess module.&quot;</font>
<font color="red"> 705.             warnings.warn(msg, DeprecationWarning, stacklevel=2)</font>
<font color="black"> 706. </font>
<font color="red"> 707.             import subprocess</font>
<font color="red"> 708.             PIPE = subprocess.PIPE</font>
<font color="red"> 709.             p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),</font>
<font color="red"> 710.                                  bufsize=bufsize, stdin=PIPE, stdout=PIPE,</font>
<font color="red"> 711.                                  stderr=subprocess.STDOUT, close_fds=True)</font>
<font color="red"> 712.             return p.stdin, p.stdout</font>
<font color="red"> 713.         __all__.append(&quot;popen4&quot;)</font>
<font color="black"> 714. </font>
<font color="red"> 715. import copy_reg as _copy_reg</font>
<font color="black"> 716. </font>
<font color="red"> 717. def _make_stat_result(tup, dict):</font>
<font color="red"> 718.     return stat_result(tup, dict)</font>
<font color="black"> 719. </font>
<font color="red"> 720. def _pickle_stat_result(sr):</font>
<font color="red"> 721.     (type, args) = sr.__reduce__()</font>
<font color="red"> 722.     return (_make_stat_result, args)</font>
<font color="black"> 723. </font>
<font color="red"> 724. try:</font>
<font color="red"> 725.     _copy_reg.pickle(stat_result, _pickle_stat_result, _make_stat_result)</font>
<font color="red"> 726. except NameError: # stat_result may not exist</font>
<font color="red"> 727.     pass</font>
<font color="black"> 728. </font>
<font color="red"> 729. def _make_statvfs_result(tup, dict):</font>
<font color="red"> 730.     return statvfs_result(tup, dict)</font>
<font color="black"> 731. </font>
<font color="red"> 732. def _pickle_statvfs_result(sr):</font>
<font color="red"> 733.     (type, args) = sr.__reduce__()</font>
<font color="red"> 734.     return (_make_statvfs_result, args)</font>
<font color="black"> 735. </font>
<font color="red"> 736. try:</font>
<font color="red"> 737.     _copy_reg.pickle(statvfs_result, _pickle_statvfs_result,</font>
<font color="red"> 738.                      _make_statvfs_result)</font>
<font color="red"> 739. except NameError: # statvfs_result may not exist</font>
<font color="red"> 740.     pass</font>
</pre>

