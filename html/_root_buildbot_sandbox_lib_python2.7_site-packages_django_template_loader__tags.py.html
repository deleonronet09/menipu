source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/template/loader_tags.py</b><br>


file stats: <b>200 lines, 37 executed: 18.5% covered</b>
<pre>
<font color="green">   1. import logging</font>
<font color="green">   2. from collections import defaultdict</font>
<font color="black">   3. </font>
<font color="green">   4. from django.utils import six</font>
<font color="green">   5. from django.utils.safestring import mark_safe</font>
<font color="black">   6. </font>
<font color="green">   7. from .base import (</font>
<font color="black">   8.     Node, Template, TemplateSyntaxError, TextNode, Variable, token_kwargs,</font>
<font color="black">   9. )</font>
<font color="green">  10. from .library import Library</font>
<font color="black">  11. </font>
<font color="green">  12. register = Library()</font>
<font color="black">  13. </font>
<font color="green">  14. BLOCK_CONTEXT_KEY = 'block_context'</font>
<font color="black">  15. </font>
<font color="green">  16. logger = logging.getLogger('django.template')</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. class ExtendsError(Exception):</font>
<font color="green">  20.     pass</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="green">  23. class BlockContext(object):</font>
<font color="green">  24.     def __init__(self):</font>
<font color="black">  25.         # Dictionary of FIFO queues.</font>
<font color="red">  26.         self.blocks = defaultdict(list)</font>
<font color="black">  27. </font>
<font color="green">  28.     def add_blocks(self, blocks):</font>
<font color="red">  29.         for name, block in six.iteritems(blocks):</font>
<font color="red">  30.             self.blocks[name].insert(0, block)</font>
<font color="black">  31. </font>
<font color="green">  32.     def pop(self, name):</font>
<font color="red">  33.         try:</font>
<font color="red">  34.             return self.blocks[name].pop()</font>
<font color="red">  35.         except IndexError:</font>
<font color="red">  36.             return None</font>
<font color="black">  37. </font>
<font color="green">  38.     def push(self, name, block):</font>
<font color="red">  39.         self.blocks[name].append(block)</font>
<font color="black">  40. </font>
<font color="green">  41.     def get_block(self, name):</font>
<font color="red">  42.         try:</font>
<font color="red">  43.             return self.blocks[name][-1]</font>
<font color="red">  44.         except IndexError:</font>
<font color="red">  45.             return None</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. class BlockNode(Node):</font>
<font color="green">  49.     def __init__(self, name, nodelist, parent=None):</font>
<font color="red">  50.         self.name, self.nodelist, self.parent = name, nodelist, parent</font>
<font color="black">  51. </font>
<font color="green">  52.     def __repr__(self):</font>
<font color="red">  53.         return &quot;&lt;Block Node: %s. Contents: %r&gt;&quot; % (self.name, self.nodelist)</font>
<font color="black">  54. </font>
<font color="green">  55.     def render(self, context):</font>
<font color="red">  56.         block_context = context.render_context.get(BLOCK_CONTEXT_KEY)</font>
<font color="red">  57.         with context.push():</font>
<font color="red">  58.             if block_context is None:</font>
<font color="red">  59.                 context['block'] = self</font>
<font color="red">  60.                 result = self.nodelist.render(context)</font>
<font color="black">  61.             else:</font>
<font color="red">  62.                 push = block = block_context.pop(self.name)</font>
<font color="red">  63.                 if block is None:</font>
<font color="red">  64.                     block = self</font>
<font color="black">  65.                 # Create new block so we can store context without thread-safety issues.</font>
<font color="red">  66.                 block = type(self)(block.name, block.nodelist)</font>
<font color="red">  67.                 block.context = context</font>
<font color="red">  68.                 context['block'] = block</font>
<font color="red">  69.                 result = block.nodelist.render(context)</font>
<font color="red">  70.                 if push is not None:</font>
<font color="red">  71.                     block_context.push(self.name, push)</font>
<font color="red">  72.         return result</font>
<font color="black">  73. </font>
<font color="green">  74.     def super(self):</font>
<font color="red">  75.         if not hasattr(self, 'context'):</font>
<font color="red">  76.             raise TemplateSyntaxError(</font>
<font color="red">  77.                 &quot;'%s' object has no attribute 'context'. Did you use &quot;</font>
<font color="red">  78.                 &quot;{{ block.super }} in a base template?&quot; % self.__class__.__name__</font>
<font color="black">  79.             )</font>
<font color="red">  80.         render_context = self.context.render_context</font>
<font color="red">  81.         if (BLOCK_CONTEXT_KEY in render_context and</font>
<font color="red">  82.                 render_context[BLOCK_CONTEXT_KEY].get_block(self.name) is not None):</font>
<font color="red">  83.             return mark_safe(self.render(self.context))</font>
<font color="red">  84.         return ''</font>
<font color="black">  85. </font>
<font color="black">  86. </font>
<font color="green">  87. class ExtendsNode(Node):</font>
<font color="green">  88.     must_be_first = True</font>
<font color="green">  89.     context_key = 'extends_context'</font>
<font color="black">  90. </font>
<font color="green">  91.     def __init__(self, nodelist, parent_name, template_dirs=None):</font>
<font color="red">  92.         self.nodelist = nodelist</font>
<font color="red">  93.         self.parent_name = parent_name</font>
<font color="red">  94.         self.template_dirs = template_dirs</font>
<font color="red">  95.         self.blocks = {n.name: n for n in nodelist.get_nodes_by_type(BlockNode)}</font>
<font color="black">  96. </font>
<font color="green">  97.     def __repr__(self):</font>
<font color="red">  98.         return '&lt;ExtendsNode: extends %s&gt;' % self.parent_name.token</font>
<font color="black">  99. </font>
<font color="green"> 100.     def find_template(self, template_name, context):</font>
<font color="black"> 101.         &quot;&quot;&quot;</font>
<font color="black"> 102.         This is a wrapper around engine.find_template(). A history is kept in</font>
<font color="black"> 103.         the render_context attribute between successive extends calls and</font>
<font color="black"> 104.         passed as the skip argument. This enables extends to work recursively</font>
<font color="black"> 105.         without extending the same template twice.</font>
<font color="black"> 106.         &quot;&quot;&quot;</font>
<font color="black"> 107.         # RemovedInDjango20Warning: If any non-recursive loaders are installed</font>
<font color="black"> 108.         # do a direct template lookup. If the same template name appears twice,</font>
<font color="black"> 109.         # raise an exception to avoid system recursion.</font>
<font color="red"> 110.         for loader in context.template.engine.template_loaders:</font>
<font color="red"> 111.             if not loader.supports_recursion:</font>
<font color="red"> 112.                 history = context.render_context.setdefault(</font>
<font color="red"> 113.                     self.context_key, [context.template.origin.template_name],</font>
<font color="black"> 114.                 )</font>
<font color="red"> 115.                 if template_name in history:</font>
<font color="red"> 116.                     raise ExtendsError(</font>
<font color="red"> 117.                         &quot;Cannot extend templates recursively when using &quot;</font>
<font color="black"> 118.                         &quot;non-recursive template loaders&quot;,</font>
<font color="black"> 119.                     )</font>
<font color="red"> 120.                 template = context.template.engine.get_template(template_name)</font>
<font color="red"> 121.                 history.append(template_name)</font>
<font color="red"> 122.                 return template</font>
<font color="black"> 123. </font>
<font color="red"> 124.         history = context.render_context.setdefault(</font>
<font color="red"> 125.             self.context_key, [context.template.origin],</font>
<font color="black"> 126.         )</font>
<font color="red"> 127.         template, origin = context.template.engine.find_template(</font>
<font color="red"> 128.             template_name, skip=history,</font>
<font color="black"> 129.         )</font>
<font color="red"> 130.         history.append(origin)</font>
<font color="red"> 131.         return template</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def get_parent(self, context):</font>
<font color="red"> 134.         parent = self.parent_name.resolve(context)</font>
<font color="red"> 135.         if not parent:</font>
<font color="red"> 136.             error_msg = &quot;Invalid template name in 'extends' tag: %r.&quot; % parent</font>
<font color="red"> 137.             if self.parent_name.filters or\</font>
<font color="red"> 138.                     isinstance(self.parent_name.var, Variable):</font>
<font color="red"> 139.                 error_msg += &quot; Got this from the '%s' variable.&quot; %\</font>
<font color="red"> 140.                     self.parent_name.token</font>
<font color="red"> 141.             raise TemplateSyntaxError(error_msg)</font>
<font color="red"> 142.         if isinstance(parent, Template):</font>
<font color="black"> 143.             # parent is a django.template.Template</font>
<font color="red"> 144.             return parent</font>
<font color="red"> 145.         if isinstance(getattr(parent, 'template', None), Template):</font>
<font color="black"> 146.             # parent is a django.template.backends.django.Template</font>
<font color="red"> 147.             return parent.template</font>
<font color="red"> 148.         return self.find_template(parent, context)</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def render(self, context):</font>
<font color="red"> 151.         compiled_parent = self.get_parent(context)</font>
<font color="black"> 152. </font>
<font color="red"> 153.         if BLOCK_CONTEXT_KEY not in context.render_context:</font>
<font color="red"> 154.             context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()</font>
<font color="red"> 155.         block_context = context.render_context[BLOCK_CONTEXT_KEY]</font>
<font color="black"> 156. </font>
<font color="black"> 157.         # Add the block nodes from this node to the block context</font>
<font color="red"> 158.         block_context.add_blocks(self.blocks)</font>
<font color="black"> 159. </font>
<font color="black"> 160.         # If this block's parent doesn't have an extends node it is the root,</font>
<font color="black"> 161.         # and its block nodes also need to be added to the block context.</font>
<font color="red"> 162.         for node in compiled_parent.nodelist:</font>
<font color="black"> 163.             # The ExtendsNode has to be the first non-text node.</font>
<font color="red"> 164.             if not isinstance(node, TextNode):</font>
<font color="red"> 165.                 if not isinstance(node, ExtendsNode):</font>
<font color="red"> 166.                     blocks = {n.name: n for n in</font>
<font color="red"> 167.                               compiled_parent.nodelist.get_nodes_by_type(BlockNode)}</font>
<font color="red"> 168.                     block_context.add_blocks(blocks)</font>
<font color="red"> 169.                 break</font>
<font color="black"> 170. </font>
<font color="black"> 171.         # Call Template._render explicitly so the parser context stays</font>
<font color="black"> 172.         # the same.</font>
<font color="red"> 173.         return compiled_parent._render(context)</font>
<font color="black"> 174. </font>
<font color="black"> 175. </font>
<font color="green"> 176. class IncludeNode(Node):</font>
<font color="green"> 177.     context_key = '__include_context'</font>
<font color="black"> 178. </font>
<font color="green"> 179.     def __init__(self, template, *args, **kwargs):</font>
<font color="red"> 180.         self.template = template</font>
<font color="red"> 181.         self.extra_context = kwargs.pop('extra_context', {})</font>
<font color="red"> 182.         self.isolated_context = kwargs.pop('isolated_context', False)</font>
<font color="red"> 183.         super(IncludeNode, self).__init__(*args, **kwargs)</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def render(self, context):</font>
<font color="black"> 186.         &quot;&quot;&quot;</font>
<font color="black"> 187.         Render the specified template and context. Cache the template object</font>
<font color="black"> 188.         in render_context to avoid reparsing and loading when used in a for</font>
<font color="black"> 189.         loop.</font>
<font color="black"> 190.         &quot;&quot;&quot;</font>
<font color="red"> 191.         try:</font>
<font color="red"> 192.             template = self.template.resolve(context)</font>
<font color="black"> 193.             # Does this quack like a Template?</font>
<font color="red"> 194.             if not callable(getattr(template, 'render', None)):</font>
<font color="black"> 195.                 # If not, we'll try our cache, and get_template()</font>
<font color="red"> 196.                 template_name = template</font>
<font color="red"> 197.                 cache = context.render_context.setdefault(self.context_key, {})</font>
<font color="red"> 198.                 template = cache.get(template_name)</font>
<font color="red"> 199.                 if template is None:</font>
<font color="red"> 200.                     template = context.template.engine.get_template(template_name)</font>
<font color="red"> 201.                     cache[template_name] = template</font>
<font color="black"> 202.             values = {</font>
<font color="red"> 203.                 name: var.resolve(context)</font>
<font color="red"> 204.                 for name, var in six.iteritems(self.extra_context)</font>
<font color="black"> 205.             }</font>
<font color="red"> 206.             if self.isolated_context:</font>
<font color="red"> 207.                 return template.render(context.new(values))</font>
<font color="red"> 208.             with context.push(**values):</font>
<font color="red"> 209.                 return template.render(context)</font>
<font color="red"> 210.         except Exception:</font>
<font color="red"> 211.             if context.template.engine.debug:</font>
<font color="red"> 212.                 raise</font>
<font color="red"> 213.             template_name = getattr(context, 'template_name', None) or 'unknown'</font>
<font color="red"> 214.             logger.warning(</font>
<font color="red"> 215.                 &quot;Exception raised while rendering {%% include %%} for &quot;</font>
<font color="black"> 216.                 &quot;template '%s'. Empty string rendered instead.&quot;,</font>
<font color="red"> 217.                 template_name,</font>
<font color="red"> 218.                 exc_info=True,</font>
<font color="black"> 219.             )</font>
<font color="red"> 220.             return ''</font>
<font color="black"> 221. </font>
<font color="black"> 222. </font>
<font color="green"> 223. @register.tag('block')</font>
<font color="black"> 224. def do_block(parser, token):</font>
<font color="black"> 225.     &quot;&quot;&quot;</font>
<font color="black"> 226.     Define a block that can be overridden by child templates.</font>
<font color="black"> 227.     &quot;&quot;&quot;</font>
<font color="black"> 228.     # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</font>
<font color="red"> 229.     bits = token.contents.split()</font>
<font color="red"> 230.     if len(bits) != 2:</font>
<font color="red"> 231.         raise TemplateSyntaxError(&quot;'%s' tag takes only one argument&quot; % bits[0])</font>
<font color="red"> 232.     block_name = bits[1]</font>
<font color="black"> 233.     # Keep track of the names of BlockNodes found in this template, so we can</font>
<font color="black"> 234.     # check for duplication.</font>
<font color="red"> 235.     try:</font>
<font color="red"> 236.         if block_name in parser.__loaded_blocks:</font>
<font color="red"> 237.             raise TemplateSyntaxError(&quot;'%s' tag with name '%s' appears more than once&quot; % (bits[0], block_name))</font>
<font color="red"> 238.         parser.__loaded_blocks.append(block_name)</font>
<font color="red"> 239.     except AttributeError:  # parser.__loaded_blocks isn't a list yet</font>
<font color="red"> 240.         parser.__loaded_blocks = [block_name]</font>
<font color="red"> 241.     nodelist = parser.parse(('endblock',))</font>
<font color="black"> 242. </font>
<font color="black"> 243.     # This check is kept for backwards-compatibility. See #3100.</font>
<font color="red"> 244.     endblock = parser.next_token()</font>
<font color="red"> 245.     acceptable_endblocks = ('endblock', 'endblock %s' % block_name)</font>
<font color="red"> 246.     if endblock.contents not in acceptable_endblocks:</font>
<font color="red"> 247.         parser.invalid_block_tag(endblock, 'endblock', acceptable_endblocks)</font>
<font color="black"> 248. </font>
<font color="red"> 249.     return BlockNode(block_name, nodelist)</font>
<font color="black"> 250. </font>
<font color="black"> 251. </font>
<font color="green"> 252. @register.tag('extends')</font>
<font color="black"> 253. def do_extends(parser, token):</font>
<font color="black"> 254.     &quot;&quot;&quot;</font>
<font color="black"> 255.     Signal that this template extends a parent template.</font>
<font color="black"> 256. </font>
<font color="black"> 257.     This tag may be used in two ways: ``{% extends &quot;base&quot; %}`` (with quotes)</font>
<font color="black"> 258.     uses the literal value &quot;base&quot; as the name of the parent template to extend,</font>
<font color="black"> 259.     or ``{% extends variable %}`` uses the value of ``variable`` as either the</font>
<font color="black"> 260.     name of the parent template to extend (if it evaluates to a string) or as</font>
<font color="black"> 261.     the parent template itself (if it evaluates to a Template object).</font>
<font color="black"> 262.     &quot;&quot;&quot;</font>
<font color="red"> 263.     bits = token.split_contents()</font>
<font color="red"> 264.     if len(bits) != 2:</font>
<font color="red"> 265.         raise TemplateSyntaxError(&quot;'%s' takes one argument&quot; % bits[0])</font>
<font color="red"> 266.     parent_name = parser.compile_filter(bits[1])</font>
<font color="red"> 267.     nodelist = parser.parse()</font>
<font color="red"> 268.     if nodelist.get_nodes_by_type(ExtendsNode):</font>
<font color="red"> 269.         raise TemplateSyntaxError(&quot;'%s' cannot appear more than once in the same template&quot; % bits[0])</font>
<font color="red"> 270.     return ExtendsNode(nodelist, parent_name)</font>
<font color="black"> 271. </font>
<font color="black"> 272. </font>
<font color="green"> 273. @register.tag('include')</font>
<font color="black"> 274. def do_include(parser, token):</font>
<font color="black"> 275.     &quot;&quot;&quot;</font>
<font color="black"> 276.     Loads a template and renders it with the current context. You can pass</font>
<font color="black"> 277.     additional context using keyword arguments.</font>
<font color="black"> 278. </font>
<font color="black"> 279.     Example::</font>
<font color="black"> 280. </font>
<font color="black"> 281.         {% include &quot;foo/some_include&quot; %}</font>
<font color="black"> 282.         {% include &quot;foo/some_include&quot; with bar=&quot;BAZZ!&quot; baz=&quot;BING!&quot; %}</font>
<font color="black"> 283. </font>
<font color="black"> 284.     Use the ``only`` argument to exclude the current context when rendering</font>
<font color="black"> 285.     the included template::</font>
<font color="black"> 286. </font>
<font color="black"> 287.         {% include &quot;foo/some_include&quot; only %}</font>
<font color="black"> 288.         {% include &quot;foo/some_include&quot; with bar=&quot;1&quot; only %}</font>
<font color="black"> 289.     &quot;&quot;&quot;</font>
<font color="red"> 290.     bits = token.split_contents()</font>
<font color="red"> 291.     if len(bits) &lt; 2:</font>
<font color="red"> 292.         raise TemplateSyntaxError(</font>
<font color="red"> 293.             &quot;%r tag takes at least one argument: the name of the template to &quot;</font>
<font color="red"> 294.             &quot;be included.&quot; % bits[0]</font>
<font color="black"> 295.         )</font>
<font color="red"> 296.     options = {}</font>
<font color="red"> 297.     remaining_bits = bits[2:]</font>
<font color="red"> 298.     while remaining_bits:</font>
<font color="red"> 299.         option = remaining_bits.pop(0)</font>
<font color="red"> 300.         if option in options:</font>
<font color="red"> 301.             raise TemplateSyntaxError('The %r option was specified more '</font>
<font color="red"> 302.                                       'than once.' % option)</font>
<font color="red"> 303.         if option == 'with':</font>
<font color="red"> 304.             value = token_kwargs(remaining_bits, parser, support_legacy=False)</font>
<font color="red"> 305.             if not value:</font>
<font color="red"> 306.                 raise TemplateSyntaxError('&quot;with&quot; in %r tag needs at least '</font>
<font color="red"> 307.                                           'one keyword argument.' % bits[0])</font>
<font color="red"> 308.         elif option == 'only':</font>
<font color="red"> 309.             value = True</font>
<font color="black"> 310.         else:</font>
<font color="red"> 311.             raise TemplateSyntaxError('Unknown argument for %r tag: %r.' %</font>
<font color="red"> 312.                                       (bits[0], option))</font>
<font color="red"> 313.         options[option] = value</font>
<font color="red"> 314.     isolated_context = options.get('only', False)</font>
<font color="red"> 315.     namemap = options.get('with', {})</font>
<font color="red"> 316.     return IncludeNode(parser.compile_filter(bits[1]), extra_context=namemap,</font>
<font color="red"> 317.                        isolated_context=isolated_context)</font>
</pre>

