source file: <b>/usr/lib/python2.7/email/generator.py</b><br>


file stats: <b>183 lines, 36 executed: 19.7% covered</b>
<pre>
<font color="black">   1. # Copyright (C) 2001-2010 Python Software Foundation</font>
<font color="black">   2. # Contact: email-sig@python.org</font>
<font color="black">   3. </font>
<font color="green">   4. &quot;&quot;&quot;Classes to generate plain text from a message object tree.&quot;&quot;&quot;</font>
<font color="black">   5. </font>
<font color="green">   6. __all__ = ['Generator', 'DecodedGenerator']</font>
<font color="black">   7. </font>
<font color="green">   8. import re</font>
<font color="green">   9. import sys</font>
<font color="green">  10. import time</font>
<font color="green">  11. import random</font>
<font color="green">  12. import warnings</font>
<font color="black">  13. </font>
<font color="green">  14. from cStringIO import StringIO</font>
<font color="green">  15. from email.header import Header</font>
<font color="black">  16. </font>
<font color="green">  17. UNDERSCORE = '_'</font>
<font color="green">  18. NL = '\n'</font>
<font color="black">  19. </font>
<font color="green">  20. fcre = re.compile(r'^From ', re.MULTILINE)</font>
<font color="black">  21. </font>
<font color="green">  22. def _is8bitstring(s):</font>
<font color="red">  23.     if isinstance(s, str):</font>
<font color="red">  24.         try:</font>
<font color="red">  25.             unicode(s, 'us-ascii')</font>
<font color="red">  26.         except UnicodeError:</font>
<font color="red">  27.             return True</font>
<font color="red">  28.     return False</font>
<font color="black">  29. </font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. class Generator:</font>
<font color="black">  33.     &quot;&quot;&quot;Generates output from a Message object tree.</font>
<font color="black">  34. </font>
<font color="black">  35.     This basic generator writes the message to the given file object as plain</font>
<font color="black">  36.     text.</font>
<font color="green">  37.     &quot;&quot;&quot;</font>
<font color="black">  38.     #</font>
<font color="black">  39.     # Public interface</font>
<font color="black">  40.     #</font>
<font color="black">  41. </font>
<font color="green">  42.     def __init__(self, outfp, mangle_from_=True, maxheaderlen=78):</font>
<font color="black">  43.         &quot;&quot;&quot;Create the generator for message flattening.</font>
<font color="black">  44. </font>
<font color="black">  45.         outfp is the output file-like object for writing the message to.  It</font>
<font color="black">  46.         must have a write() method.</font>
<font color="black">  47. </font>
<font color="black">  48.         Optional mangle_from_ is a flag that, when True (the default), escapes</font>
<font color="black">  49.         From_ lines in the body of the message by putting a `&gt;' in front of</font>
<font color="black">  50.         them.</font>
<font color="black">  51. </font>
<font color="black">  52.         Optional maxheaderlen specifies the longest length for a non-continued</font>
<font color="black">  53.         header.  When a header line is longer (in characters, with tabs</font>
<font color="black">  54.         expanded to 8 spaces) than maxheaderlen, the header will split as</font>
<font color="black">  55.         defined in the Header class.  Set maxheaderlen to zero to disable</font>
<font color="black">  56.         header wrapping.  The default is 78, as recommended (but not required)</font>
<font color="black">  57.         by RFC 2822.</font>
<font color="black">  58.         &quot;&quot;&quot;</font>
<font color="red">  59.         self._fp = outfp</font>
<font color="red">  60.         self._mangle_from_ = mangle_from_</font>
<font color="red">  61.         self._maxheaderlen = maxheaderlen</font>
<font color="black">  62. </font>
<font color="green">  63.     def write(self, s):</font>
<font color="black">  64.         # Just delegate to the file object</font>
<font color="red">  65.         self._fp.write(s)</font>
<font color="black">  66. </font>
<font color="green">  67.     def flatten(self, msg, unixfrom=False):</font>
<font color="black">  68.         &quot;&quot;&quot;Print the message object tree rooted at msg to the output file</font>
<font color="black">  69.         specified when the Generator instance was created.</font>
<font color="black">  70. </font>
<font color="black">  71.         unixfrom is a flag that forces the printing of a Unix From_ delimiter</font>
<font color="black">  72.         before the first object in the message tree.  If the original message</font>
<font color="black">  73.         has no From_ delimiter, a `standard' one is crafted.  By default, this</font>
<font color="black">  74.         is False to inhibit the printing of any From_ delimiter.</font>
<font color="black">  75. </font>
<font color="black">  76.         Note that for subobjects, no From_ line is printed.</font>
<font color="black">  77.         &quot;&quot;&quot;</font>
<font color="red">  78.         if unixfrom:</font>
<font color="red">  79.             ufrom = msg.get_unixfrom()</font>
<font color="red">  80.             if not ufrom:</font>
<font color="red">  81.                 ufrom = 'From nobody ' + time.ctime(time.time())</font>
<font color="red">  82.             print &gt;&gt; self._fp, ufrom</font>
<font color="red">  83.         self._write(msg)</font>
<font color="black">  84. </font>
<font color="green">  85.     def clone(self, fp):</font>
<font color="black">  86.         &quot;&quot;&quot;Clone this generator with the exact same options.&quot;&quot;&quot;</font>
<font color="red">  87.         return self.__class__(fp, self._mangle_from_, self._maxheaderlen)</font>
<font color="black">  88. </font>
<font color="black">  89.     #</font>
<font color="black">  90.     # Protected interface - undocumented ;/</font>
<font color="black">  91.     #</font>
<font color="black">  92. </font>
<font color="green">  93.     def _write(self, msg):</font>
<font color="black">  94.         # We can't write the headers yet because of the following scenario:</font>
<font color="black">  95.         # say a multipart message includes the boundary string somewhere in</font>
<font color="black">  96.         # its body.  We'd have to calculate the new boundary /before/ we write</font>
<font color="black">  97.         # the headers so that we can write the correct Content-Type:</font>
<font color="black">  98.         # parameter.</font>
<font color="black">  99.         #</font>
<font color="black"> 100.         # The way we do this, so as to make the _handle_*() methods simpler,</font>
<font color="black"> 101.         # is to cache any subpart writes into a StringIO.  The we write the</font>
<font color="black"> 102.         # headers and the StringIO contents.  That way, subpart handlers can</font>
<font color="black"> 103.         # Do The Right Thing, and can still modify the Content-Type: header if</font>
<font color="black"> 104.         # necessary.</font>
<font color="red"> 105.         oldfp = self._fp</font>
<font color="red"> 106.         try:</font>
<font color="red"> 107.             self._fp = sfp = StringIO()</font>
<font color="red"> 108.             self._dispatch(msg)</font>
<font color="black"> 109.         finally:</font>
<font color="red"> 110.             self._fp = oldfp</font>
<font color="black"> 111.         # Write the headers.  First we see if the message object wants to</font>
<font color="black"> 112.         # handle that itself.  If not, we'll do it generically.</font>
<font color="red"> 113.         meth = getattr(msg, '_write_headers', None)</font>
<font color="red"> 114.         if meth is None:</font>
<font color="red"> 115.             self._write_headers(msg)</font>
<font color="black"> 116.         else:</font>
<font color="red"> 117.             meth(self)</font>
<font color="red"> 118.         self._fp.write(sfp.getvalue())</font>
<font color="black"> 119. </font>
<font color="green"> 120.     def _dispatch(self, msg):</font>
<font color="black"> 121.         # Get the Content-Type: for the message, then try to dispatch to</font>
<font color="black"> 122.         # self._handle_&lt;maintype&gt;_&lt;subtype&gt;().  If there's no handler for the</font>
<font color="black"> 123.         # full MIME type, then dispatch to self._handle_&lt;maintype&gt;().  If</font>
<font color="black"> 124.         # that's missing too, then dispatch to self._writeBody().</font>
<font color="red"> 125.         main = msg.get_content_maintype()</font>
<font color="red"> 126.         sub = msg.get_content_subtype()</font>
<font color="red"> 127.         specific = UNDERSCORE.join((main, sub)).replace('-', '_')</font>
<font color="red"> 128.         meth = getattr(self, '_handle_' + specific, None)</font>
<font color="red"> 129.         if meth is None:</font>
<font color="red"> 130.             generic = main.replace('-', '_')</font>
<font color="red"> 131.             meth = getattr(self, '_handle_' + generic, None)</font>
<font color="red"> 132.             if meth is None:</font>
<font color="red"> 133.                 meth = self._writeBody</font>
<font color="red"> 134.         meth(msg)</font>
<font color="black"> 135. </font>
<font color="black"> 136.     #</font>
<font color="black"> 137.     # Default handlers</font>
<font color="black"> 138.     #</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def _write_headers(self, msg):</font>
<font color="red"> 141.         for h, v in msg.items():</font>
<font color="red"> 142.             print &gt;&gt; self._fp, '%s:' % h,</font>
<font color="red"> 143.             if self._maxheaderlen == 0:</font>
<font color="black"> 144.                 # Explicit no-wrapping</font>
<font color="red"> 145.                 print &gt;&gt; self._fp, v</font>
<font color="red"> 146.             elif isinstance(v, Header):</font>
<font color="black"> 147.                 # Header instances know what to do</font>
<font color="red"> 148.                 print &gt;&gt; self._fp, v.encode()</font>
<font color="red"> 149.             elif _is8bitstring(v):</font>
<font color="black"> 150.                 # If we have raw 8bit data in a byte string, we have no idea</font>
<font color="black"> 151.                 # what the encoding is.  There is no safe way to split this</font>
<font color="black"> 152.                 # string.  If it's ascii-subset, then we could do a normal</font>
<font color="black"> 153.                 # ascii split, but if it's multibyte then we could break the</font>
<font color="black"> 154.                 # string.  There's no way to know so the least harm seems to</font>
<font color="black"> 155.                 # be to not split the string and risk it being too long.</font>
<font color="red"> 156.                 print &gt;&gt; self._fp, v</font>
<font color="black"> 157.             else:</font>
<font color="black"> 158.                 # Header's got lots of smarts, so use it.  Note that this is</font>
<font color="black"> 159.                 # fundamentally broken though because we lose idempotency when</font>
<font color="black"> 160.                 # the header string is continued with tabs.  It will now be</font>
<font color="black"> 161.                 # continued with spaces.  This was reversedly broken before we</font>
<font color="black"> 162.                 # fixed bug 1974.  Either way, we lose.</font>
<font color="red"> 163.                 print &gt;&gt; self._fp, Header(</font>
<font color="red"> 164.                     v, maxlinelen=self._maxheaderlen, header_name=h).encode()</font>
<font color="black"> 165.         # A blank line always separates headers from body</font>
<font color="red"> 166.         print &gt;&gt; self._fp</font>
<font color="black"> 167. </font>
<font color="black"> 168.     #</font>
<font color="black"> 169.     # Handlers for writing types and subtypes</font>
<font color="black"> 170.     #</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def _handle_text(self, msg):</font>
<font color="red"> 173.         payload = msg.get_payload()</font>
<font color="red"> 174.         if payload is None:</font>
<font color="red"> 175.             return</font>
<font color="red"> 176.         if not isinstance(payload, basestring):</font>
<font color="red"> 177.             raise TypeError('string payload expected: %s' % type(payload))</font>
<font color="red"> 178.         if self._mangle_from_:</font>
<font color="red"> 179.             payload = fcre.sub('&gt;From ', payload)</font>
<font color="red"> 180.         self._fp.write(payload)</font>
<font color="black"> 181. </font>
<font color="black"> 182.     # Default body handler</font>
<font color="green"> 183.     _writeBody = _handle_text</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def _handle_multipart(self, msg):</font>
<font color="black"> 186.         # The trick here is to write out each part separately, merge them all</font>
<font color="black"> 187.         # together, and then make sure that the boundary we've chosen isn't</font>
<font color="black"> 188.         # present in the payload.</font>
<font color="red"> 189.         msgtexts = []</font>
<font color="red"> 190.         subparts = msg.get_payload()</font>
<font color="red"> 191.         if subparts is None:</font>
<font color="red"> 192.             subparts = []</font>
<font color="red"> 193.         elif isinstance(subparts, basestring):</font>
<font color="black"> 194.             # e.g. a non-strict parse of a message with no starting boundary.</font>
<font color="red"> 195.             self._fp.write(subparts)</font>
<font color="red"> 196.             return</font>
<font color="red"> 197.         elif not isinstance(subparts, list):</font>
<font color="black"> 198.             # Scalar payload</font>
<font color="red"> 199.             subparts = [subparts]</font>
<font color="red"> 200.         for part in subparts:</font>
<font color="red"> 201.             s = StringIO()</font>
<font color="red"> 202.             g = self.clone(s)</font>
<font color="red"> 203.             g.flatten(part, unixfrom=False)</font>
<font color="red"> 204.             msgtexts.append(s.getvalue())</font>
<font color="black"> 205.         # BAW: What about boundaries that are wrapped in double-quotes?</font>
<font color="red"> 206.         boundary = msg.get_boundary()</font>
<font color="red"> 207.         if not boundary:</font>
<font color="black"> 208.             # Create a boundary that doesn't appear in any of the</font>
<font color="black"> 209.             # message texts.</font>
<font color="red"> 210.             alltext = NL.join(msgtexts)</font>
<font color="red"> 211.             boundary = _make_boundary(alltext)</font>
<font color="red"> 212.             msg.set_boundary(boundary)</font>
<font color="black"> 213.         # If there's a preamble, write it out, with a trailing CRLF</font>
<font color="red"> 214.         if msg.preamble is not None:</font>
<font color="red"> 215.             if self._mangle_from_:</font>
<font color="red"> 216.                 preamble = fcre.sub('&gt;From ', msg.preamble)</font>
<font color="black"> 217.             else:</font>
<font color="red"> 218.                 preamble = msg.preamble</font>
<font color="red"> 219.             print &gt;&gt; self._fp, preamble</font>
<font color="black"> 220.         # dash-boundary transport-padding CRLF</font>
<font color="red"> 221.         print &gt;&gt; self._fp, '--' + boundary</font>
<font color="black"> 222.         # body-part</font>
<font color="red"> 223.         if msgtexts:</font>
<font color="red"> 224.             self._fp.write(msgtexts.pop(0))</font>
<font color="black"> 225.         # *encapsulation</font>
<font color="black"> 226.         # --&gt; delimiter transport-padding</font>
<font color="black"> 227.         # --&gt; CRLF body-part</font>
<font color="red"> 228.         for body_part in msgtexts:</font>
<font color="black"> 229.             # delimiter transport-padding CRLF</font>
<font color="red"> 230.             print &gt;&gt; self._fp, '\n--' + boundary</font>
<font color="black"> 231.             # body-part</font>
<font color="red"> 232.             self._fp.write(body_part)</font>
<font color="black"> 233.         # close-delimiter transport-padding</font>
<font color="red"> 234.         self._fp.write('\n--' + boundary + '--' + NL)</font>
<font color="red"> 235.         if msg.epilogue is not None:</font>
<font color="red"> 236.             if self._mangle_from_:</font>
<font color="red"> 237.                 epilogue = fcre.sub('&gt;From ', msg.epilogue)</font>
<font color="black"> 238.             else:</font>
<font color="red"> 239.                 epilogue = msg.epilogue</font>
<font color="red"> 240.             self._fp.write(epilogue)</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def _handle_multipart_signed(self, msg):</font>
<font color="black"> 243.         # The contents of signed parts has to stay unmodified in order to keep</font>
<font color="black"> 244.         # the signature intact per RFC1847 2.1, so we disable header wrapping.</font>
<font color="black"> 245.         # RDM: This isn't enough to completely preserve the part, but it helps.</font>
<font color="red"> 246.         old_maxheaderlen = self._maxheaderlen</font>
<font color="red"> 247.         try:</font>
<font color="red"> 248.             self._maxheaderlen = 0</font>
<font color="red"> 249.             self._handle_multipart(msg)</font>
<font color="black"> 250.         finally:</font>
<font color="red"> 251.             self._maxheaderlen = old_maxheaderlen</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def _handle_message_delivery_status(self, msg):</font>
<font color="black"> 254.         # We can't just write the headers directly to self's file object</font>
<font color="black"> 255.         # because this will leave an extra newline between the last header</font>
<font color="black"> 256.         # block and the boundary.  Sigh.</font>
<font color="red"> 257.         blocks = []</font>
<font color="red"> 258.         for part in msg.get_payload():</font>
<font color="red"> 259.             s = StringIO()</font>
<font color="red"> 260.             g = self.clone(s)</font>
<font color="red"> 261.             g.flatten(part, unixfrom=False)</font>
<font color="red"> 262.             text = s.getvalue()</font>
<font color="red"> 263.             lines = text.split('\n')</font>
<font color="black"> 264.             # Strip off the unnecessary trailing empty line</font>
<font color="red"> 265.             if lines and lines[-1] == '':</font>
<font color="red"> 266.                 blocks.append(NL.join(lines[:-1]))</font>
<font color="black"> 267.             else:</font>
<font color="red"> 268.                 blocks.append(text)</font>
<font color="black"> 269.         # Now join all the blocks with an empty line.  This has the lovely</font>
<font color="black"> 270.         # effect of separating each block with an empty line, but not adding</font>
<font color="black"> 271.         # an extra one after the last one.</font>
<font color="red"> 272.         self._fp.write(NL.join(blocks))</font>
<font color="black"> 273. </font>
<font color="green"> 274.     def _handle_message(self, msg):</font>
<font color="red"> 275.         s = StringIO()</font>
<font color="red"> 276.         g = self.clone(s)</font>
<font color="black"> 277.         # The payload of a message/rfc822 part should be a multipart sequence</font>
<font color="black"> 278.         # of length 1.  The zeroth element of the list should be the Message</font>
<font color="black"> 279.         # object for the subpart.  Extract that object, stringify it, and</font>
<font color="black"> 280.         # write it out.</font>
<font color="black"> 281.         # Except, it turns out, when it's a string instead, which happens when</font>
<font color="black"> 282.         # and only when HeaderParser is used on a message of mime type</font>
<font color="black"> 283.         # message/rfc822.  Such messages are generated by, for example,</font>
<font color="black"> 284.         # Groupwise when forwarding unadorned messages.  (Issue 7970.)  So</font>
<font color="black"> 285.         # in that case we just emit the string body.</font>
<font color="red"> 286.         payload = msg.get_payload()</font>
<font color="red"> 287.         if isinstance(payload, list):</font>
<font color="red"> 288.             g.flatten(msg.get_payload(0), unixfrom=False)</font>
<font color="red"> 289.             payload = s.getvalue()</font>
<font color="red"> 290.         self._fp.write(payload)</font>
<font color="black"> 291. </font>
<font color="black"> 292. </font>
<font color="black"> 293. </font>
<font color="green"> 294. _FMT = '[Non-text (%(type)s) part of message omitted, filename %(filename)s]'</font>
<font color="black"> 295. </font>
<font color="green"> 296. class DecodedGenerator(Generator):</font>
<font color="black"> 297.     &quot;&quot;&quot;Generates a text representation of a message.</font>
<font color="black"> 298. </font>
<font color="black"> 299.     Like the Generator base class, except that non-text parts are substituted</font>
<font color="black"> 300.     with a format string representing the part.</font>
<font color="green"> 301.     &quot;&quot;&quot;</font>
<font color="green"> 302.     def __init__(self, outfp, mangle_from_=True, maxheaderlen=78, fmt=None):</font>
<font color="black"> 303.         &quot;&quot;&quot;Like Generator.__init__() except that an additional optional</font>
<font color="black"> 304.         argument is allowed.</font>
<font color="black"> 305. </font>
<font color="black"> 306.         Walks through all subparts of a message.  If the subpart is of main</font>
<font color="black"> 307.         type `text', then it prints the decoded payload of the subpart.</font>
<font color="black"> 308. </font>
<font color="black"> 309.         Otherwise, fmt is a format string that is used instead of the message</font>
<font color="black"> 310.         payload.  fmt is expanded with the following keywords (in</font>
<font color="black"> 311.         %(keyword)s format):</font>
<font color="black"> 312. </font>
<font color="black"> 313.         type       : Full MIME type of the non-text part</font>
<font color="black"> 314.         maintype   : Main MIME type of the non-text part</font>
<font color="black"> 315.         subtype    : Sub-MIME type of the non-text part</font>
<font color="black"> 316.         filename   : Filename of the non-text part</font>
<font color="black"> 317.         description: Description associated with the non-text part</font>
<font color="black"> 318.         encoding   : Content transfer encoding of the non-text part</font>
<font color="black"> 319. </font>
<font color="black"> 320.         The default value for fmt is None, meaning</font>
<font color="black"> 321. </font>
<font color="black"> 322.         [Non-text (%(type)s) part of message omitted, filename %(filename)s]</font>
<font color="black"> 323.         &quot;&quot;&quot;</font>
<font color="red"> 324.         Generator.__init__(self, outfp, mangle_from_, maxheaderlen)</font>
<font color="red"> 325.         if fmt is None:</font>
<font color="red"> 326.             self._fmt = _FMT</font>
<font color="black"> 327.         else:</font>
<font color="red"> 328.             self._fmt = fmt</font>
<font color="black"> 329. </font>
<font color="green"> 330.     def _dispatch(self, msg):</font>
<font color="red"> 331.         for part in msg.walk():</font>
<font color="red"> 332.             maintype = part.get_content_maintype()</font>
<font color="red"> 333.             if maintype == 'text':</font>
<font color="red"> 334.                 print &gt;&gt; self, part.get_payload(decode=True)</font>
<font color="red"> 335.             elif maintype == 'multipart':</font>
<font color="black"> 336.                 # Just skip this</font>
<font color="red"> 337.                 pass</font>
<font color="black"> 338.             else:</font>
<font color="red"> 339.                 print &gt;&gt; self, self._fmt % {</font>
<font color="red"> 340.                     'type'       : part.get_content_type(),</font>
<font color="red"> 341.                     'maintype'   : part.get_content_maintype(),</font>
<font color="red"> 342.                     'subtype'    : part.get_content_subtype(),</font>
<font color="red"> 343.                     'filename'   : part.get_filename('[no filename]'),</font>
<font color="red"> 344.                     'description': part.get('Content-Description',</font>
<font color="red"> 345.                                             '[no description]'),</font>
<font color="red"> 346.                     'encoding'   : part.get('Content-Transfer-Encoding',</font>
<font color="red"> 347.                                             '[no encoding]'),</font>
<font color="black"> 348.                     }</font>
<font color="black"> 349. </font>
<font color="black"> 350. </font>
<font color="black"> 351. </font>
<font color="black"> 352. # Helper</font>
<font color="green"> 353. _width = len(repr(sys.maxint-1))</font>
<font color="green"> 354. _fmt = '%%0%dd' % _width</font>
<font color="black"> 355. </font>
<font color="green"> 356. def _make_boundary(text=None):</font>
<font color="black"> 357.     # Craft a random boundary.  If text is given, ensure that the chosen</font>
<font color="black"> 358.     # boundary doesn't appear in the text.</font>
<font color="red"> 359.     token = random.randrange(sys.maxint)</font>
<font color="red"> 360.     boundary = ('=' * 15) + (_fmt % token) + '=='</font>
<font color="red"> 361.     if text is None:</font>
<font color="red"> 362.         return boundary</font>
<font color="red"> 363.     b = boundary</font>
<font color="red"> 364.     counter = 0</font>
<font color="red"> 365.     while True:</font>
<font color="red"> 366.         cre = re.compile('^--' + re.escape(b) + '(--)?$', re.MULTILINE)</font>
<font color="red"> 367.         if not cre.search(text):</font>
<font color="red"> 368.             break</font>
<font color="red"> 369.         b = boundary + '.' + str(counter)</font>
<font color="red"> 370.         counter += 1</font>
<font color="red"> 371.     return b</font>
</pre>

