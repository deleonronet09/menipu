source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/forms/widgets.py</b><br>


file stats: <b>666 lines, 236 executed: 35.4% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. HTML Widget classes</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. from __future__ import unicode_literals</font>
<font color="black">   6. </font>
<font color="green">   7. import copy</font>
<font color="green">   8. import datetime</font>
<font color="green">   9. import re</font>
<font color="green">  10. from itertools import chain</font>
<font color="black">  11. </font>
<font color="green">  12. from django.conf import settings</font>
<font color="green">  13. from django.forms.utils import flatatt, to_current_timezone</font>
<font color="green">  14. from django.utils import datetime_safe, formats, six</font>
<font color="green">  15. from django.utils.datastructures import MultiValueDict</font>
<font color="green">  16. from django.utils.dates import MONTHS</font>
<font color="green">  17. from django.utils.encoding import (</font>
<font color="black">  18.     force_str, force_text, python_2_unicode_compatible,</font>
<font color="black">  19. )</font>
<font color="green">  20. from django.utils.formats import get_format</font>
<font color="green">  21. from django.utils.html import conditional_escape, format_html, html_safe</font>
<font color="green">  22. from django.utils.safestring import mark_safe</font>
<font color="green">  23. from django.utils.six.moves import range</font>
<font color="green">  24. from django.utils.six.moves.urllib.parse import urljoin</font>
<font color="green">  25. from django.utils.translation import ugettext_lazy</font>
<font color="black">  26. </font>
<font color="black">  27. __all__ = (</font>
<font color="black">  28.     'Media', 'MediaDefiningClass', 'Widget', 'TextInput', 'NumberInput',</font>
<font color="black">  29.     'EmailInput', 'URLInput', 'PasswordInput', 'HiddenInput',</font>
<font color="black">  30.     'MultipleHiddenInput', 'FileInput', 'ClearableFileInput', 'Textarea',</font>
<font color="black">  31.     'DateInput', 'DateTimeInput', 'TimeInput', 'CheckboxInput', 'Select',</font>
<font color="black">  32.     'NullBooleanSelect', 'SelectMultiple', 'RadioSelect',</font>
<font color="black">  33.     'CheckboxSelectMultiple', 'MultiWidget', 'SplitDateTimeWidget',</font>
<font color="green">  34.     'SplitHiddenDateTimeWidget', 'SelectDateWidget',</font>
<font color="black">  35. )</font>
<font color="black">  36. </font>
<font color="green">  37. MEDIA_TYPES = ('css', 'js')</font>
<font color="black">  38. </font>
<font color="black">  39. </font>
<font color="green">  40. @html_safe</font>
<font color="green">  41. @python_2_unicode_compatible</font>
<font color="green">  42. class Media(object):</font>
<font color="green">  43.     def __init__(self, media=None, **kwargs):</font>
<font color="red">  44.         if media:</font>
<font color="red">  45.             media_attrs = media.__dict__</font>
<font color="black">  46.         else:</font>
<font color="red">  47.             media_attrs = kwargs</font>
<font color="black">  48. </font>
<font color="red">  49.         self._css = {}</font>
<font color="red">  50.         self._js = []</font>
<font color="black">  51. </font>
<font color="red">  52.         for name in MEDIA_TYPES:</font>
<font color="red">  53.             getattr(self, 'add_' + name)(media_attrs.get(name))</font>
<font color="black">  54. </font>
<font color="green">  55.     def __str__(self):</font>
<font color="red">  56.         return self.render()</font>
<font color="black">  57. </font>
<font color="green">  58.     def render(self):</font>
<font color="red">  59.         return mark_safe('\n'.join(chain(*[getattr(self, 'render_' + name)() for name in MEDIA_TYPES])))</font>
<font color="black">  60. </font>
<font color="green">  61.     def render_js(self):</font>
<font color="black">  62.         return [</font>
<font color="red">  63.             format_html(</font>
<font color="black">  64.                 '&lt;script type=&quot;text/javascript&quot; src=&quot;{}&quot;&gt;&lt;/script&gt;',</font>
<font color="black">  65.                 self.absolute_path(path)</font>
<font color="red">  66.             ) for path in self._js</font>
<font color="black">  67.         ]</font>
<font color="black">  68. </font>
<font color="green">  69.     def render_css(self):</font>
<font color="black">  70.         # To keep rendering order consistent, we can't just iterate over items().</font>
<font color="black">  71.         # We need to sort the keys, and iterate over the sorted list.</font>
<font color="red">  72.         media = sorted(self._css.keys())</font>
<font color="red">  73.         return chain(*[[</font>
<font color="black">  74.             format_html(</font>
<font color="black">  75.                 '&lt;link href=&quot;{}&quot; type=&quot;text/css&quot; media=&quot;{}&quot; rel=&quot;stylesheet&quot; /&gt;',</font>
<font color="black">  76.                 self.absolute_path(path), medium</font>
<font color="black">  77.             ) for path in self._css[medium]</font>
<font color="red">  78.         ] for medium in media])</font>
<font color="black">  79. </font>
<font color="green">  80.     def absolute_path(self, path, prefix=None):</font>
<font color="red">  81.         if path.startswith(('http://', 'https://', '/')):</font>
<font color="red">  82.             return path</font>
<font color="red">  83.         if prefix is None:</font>
<font color="red">  84.             if settings.STATIC_URL is None:</font>
<font color="black">  85.                 # backwards compatibility</font>
<font color="red">  86.                 prefix = settings.MEDIA_URL</font>
<font color="black">  87.             else:</font>
<font color="red">  88.                 prefix = settings.STATIC_URL</font>
<font color="red">  89.         return urljoin(prefix, path)</font>
<font color="black">  90. </font>
<font color="green">  91.     def __getitem__(self, name):</font>
<font color="black">  92.         &quot;Returns a Media object that only contains media of the given type&quot;</font>
<font color="red">  93.         if name in MEDIA_TYPES:</font>
<font color="red">  94.             return Media(**{str(name): getattr(self, '_' + name)})</font>
<font color="red">  95.         raise KeyError('Unknown media type &quot;%s&quot;' % name)</font>
<font color="black">  96. </font>
<font color="green">  97.     def add_js(self, data):</font>
<font color="red">  98.         if data:</font>
<font color="red">  99.             for path in data:</font>
<font color="red"> 100.                 if path not in self._js:</font>
<font color="red"> 101.                     self._js.append(path)</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def add_css(self, data):</font>
<font color="red"> 104.         if data:</font>
<font color="red"> 105.             for medium, paths in data.items():</font>
<font color="red"> 106.                 for path in paths:</font>
<font color="red"> 107.                     if not self._css.get(medium) or path not in self._css[medium]:</font>
<font color="red"> 108.                         self._css.setdefault(medium, []).append(path)</font>
<font color="black"> 109. </font>
<font color="green"> 110.     def __add__(self, other):</font>
<font color="red"> 111.         combined = Media()</font>
<font color="red"> 112.         for name in MEDIA_TYPES:</font>
<font color="red"> 113.             getattr(combined, 'add_' + name)(getattr(self, '_' + name, None))</font>
<font color="red"> 114.             getattr(combined, 'add_' + name)(getattr(other, '_' + name, None))</font>
<font color="red"> 115.         return combined</font>
<font color="black"> 116. </font>
<font color="black"> 117. </font>
<font color="green"> 118. def media_property(cls):</font>
<font color="green"> 119.     def _media(self):</font>
<font color="black"> 120.         # Get the media property of the superclass, if it exists</font>
<font color="red"> 121.         sup_cls = super(cls, self)</font>
<font color="red"> 122.         try:</font>
<font color="red"> 123.             base = sup_cls.media</font>
<font color="red"> 124.         except AttributeError:</font>
<font color="red"> 125.             base = Media()</font>
<font color="black"> 126. </font>
<font color="black"> 127.         # Get the media definition for this class</font>
<font color="red"> 128.         definition = getattr(cls, 'Media', None)</font>
<font color="red"> 129.         if definition:</font>
<font color="red"> 130.             extend = getattr(definition, 'extend', True)</font>
<font color="red"> 131.             if extend:</font>
<font color="red"> 132.                 if extend is True:</font>
<font color="red"> 133.                     m = base</font>
<font color="black"> 134.                 else:</font>
<font color="red"> 135.                     m = Media()</font>
<font color="red"> 136.                     for medium in extend:</font>
<font color="red"> 137.                         m = m + base[medium]</font>
<font color="red"> 138.                 return m + Media(definition)</font>
<font color="black"> 139.             else:</font>
<font color="red"> 140.                 return Media(definition)</font>
<font color="black"> 141.         else:</font>
<font color="red"> 142.             return base</font>
<font color="green"> 143.     return property(_media)</font>
<font color="black"> 144. </font>
<font color="black"> 145. </font>
<font color="green"> 146. class MediaDefiningClass(type):</font>
<font color="black"> 147.     &quot;&quot;&quot;</font>
<font color="black"> 148.     Metaclass for classes that can have media definitions.</font>
<font color="green"> 149.     &quot;&quot;&quot;</font>
<font color="green"> 150.     def __new__(mcs, name, bases, attrs):</font>
<font color="green"> 151.         new_class = (super(MediaDefiningClass, mcs)</font>
<font color="green"> 152.             .__new__(mcs, name, bases, attrs))</font>
<font color="black"> 153. </font>
<font color="green"> 154.         if 'media' not in attrs:</font>
<font color="green"> 155.             new_class.media = media_property(new_class)</font>
<font color="black"> 156. </font>
<font color="green"> 157.         return new_class</font>
<font color="black"> 158. </font>
<font color="black"> 159. </font>
<font color="green"> 160. @html_safe</font>
<font color="green"> 161. @python_2_unicode_compatible</font>
<font color="green"> 162. class SubWidget(object):</font>
<font color="black"> 163.     &quot;&quot;&quot;</font>
<font color="black"> 164.     Some widgets are made of multiple HTML elements -- namely, RadioSelect.</font>
<font color="black"> 165.     This is a class that represents the &quot;inner&quot; HTML element of a widget.</font>
<font color="green"> 166.     &quot;&quot;&quot;</font>
<font color="green"> 167.     def __init__(self, parent_widget, name, value, attrs, choices):</font>
<font color="red"> 168.         self.parent_widget = parent_widget</font>
<font color="red"> 169.         self.name, self.value = name, value</font>
<font color="red"> 170.         self.attrs, self.choices = attrs, choices</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def __str__(self):</font>
<font color="red"> 173.         args = [self.name, self.value, self.attrs]</font>
<font color="red"> 174.         if self.choices:</font>
<font color="red"> 175.             args.append(self.choices)</font>
<font color="red"> 176.         return self.parent_widget.render(*args)</font>
<font color="black"> 177. </font>
<font color="black"> 178. </font>
<font color="green"> 179. class Widget(six.with_metaclass(MediaDefiningClass)):</font>
<font color="green"> 180.     needs_multipart_form = False  # Determines does this widget need multipart form</font>
<font color="green"> 181.     is_localized = False</font>
<font color="green"> 182.     is_required = False</font>
<font color="green"> 183.     supports_microseconds = True</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def __init__(self, attrs=None):</font>
<font color="green"> 186.         if attrs is not None:</font>
<font color="green"> 187.             self.attrs = attrs.copy()</font>
<font color="black"> 188.         else:</font>
<font color="green"> 189.             self.attrs = {}</font>
<font color="black"> 190. </font>
<font color="green"> 191.     def __deepcopy__(self, memo):</font>
<font color="red"> 192.         obj = copy.copy(self)</font>
<font color="red"> 193.         obj.attrs = self.attrs.copy()</font>
<font color="red"> 194.         memo[id(self)] = obj</font>
<font color="red"> 195.         return obj</font>
<font color="black"> 196. </font>
<font color="green"> 197.     @property</font>
<font color="black"> 198.     def is_hidden(self):</font>
<font color="red"> 199.         return self.input_type == 'hidden' if hasattr(self, 'input_type') else False</font>
<font color="black"> 200. </font>
<font color="green"> 201.     def subwidgets(self, name, value, attrs=None, choices=()):</font>
<font color="black"> 202.         &quot;&quot;&quot;</font>
<font color="black"> 203.         Yields all &quot;subwidgets&quot; of this widget. Used only by RadioSelect to</font>
<font color="black"> 204.         allow template access to individual &lt;input type=&quot;radio&quot;&gt; buttons.</font>
<font color="black"> 205. </font>
<font color="black"> 206.         Arguments are the same as for render().</font>
<font color="black"> 207.         &quot;&quot;&quot;</font>
<font color="red"> 208.         yield SubWidget(self, name, value, attrs, choices)</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def render(self, name, value, attrs=None):</font>
<font color="black"> 211.         &quot;&quot;&quot;</font>
<font color="black"> 212.         Returns this Widget rendered as HTML, as a Unicode string.</font>
<font color="black"> 213. </font>
<font color="black"> 214.         The 'value' given is not guaranteed to be valid input, so subclass</font>
<font color="black"> 215.         implementations should program defensively.</font>
<font color="black"> 216.         &quot;&quot;&quot;</font>
<font color="red"> 217.         raise NotImplementedError('subclasses of Widget must provide a render() method')</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def build_attrs(self, extra_attrs=None, **kwargs):</font>
<font color="black"> 220.         &quot;Helper function for building an attribute dictionary.&quot;</font>
<font color="red"> 221.         attrs = dict(self.attrs, **kwargs)</font>
<font color="red"> 222.         if extra_attrs:</font>
<font color="red"> 223.             attrs.update(extra_attrs)</font>
<font color="red"> 224.         return attrs</font>
<font color="black"> 225. </font>
<font color="green"> 226.     def value_from_datadict(self, data, files, name):</font>
<font color="black"> 227.         &quot;&quot;&quot;</font>
<font color="black"> 228.         Given a dictionary of data and this widget's name, returns the value</font>
<font color="black"> 229.         of this widget. Returns None if it's not provided.</font>
<font color="black"> 230.         &quot;&quot;&quot;</font>
<font color="red"> 231.         return data.get(name)</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def id_for_label(self, id_):</font>
<font color="black"> 234.         &quot;&quot;&quot;</font>
<font color="black"> 235.         Returns the HTML ID attribute of this Widget for use by a &lt;label&gt;,</font>
<font color="black"> 236.         given the ID of the field. Returns None if no ID is available.</font>
<font color="black"> 237. </font>
<font color="black"> 238.         This hook is necessary because some widgets have multiple HTML</font>
<font color="black"> 239.         elements and, thus, multiple IDs. In that case, this method should</font>
<font color="black"> 240.         return an ID value that corresponds to the first ID in the widget's</font>
<font color="black"> 241.         tags.</font>
<font color="black"> 242.         &quot;&quot;&quot;</font>
<font color="red"> 243.         return id_</font>
<font color="black"> 244. </font>
<font color="black"> 245. </font>
<font color="green"> 246. class Input(Widget):</font>
<font color="black"> 247.     &quot;&quot;&quot;</font>
<font color="black"> 248.     Base class for all &lt;input&gt; widgets (except type='checkbox' and</font>
<font color="black"> 249.     type='radio', which are special).</font>
<font color="green"> 250.     &quot;&quot;&quot;</font>
<font color="green"> 251.     input_type = None  # Subclasses must define this.</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def _format_value(self, value):</font>
<font color="red"> 254.         if self.is_localized:</font>
<font color="red"> 255.             return formats.localize_input(value)</font>
<font color="red"> 256.         return value</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def render(self, name, value, attrs=None):</font>
<font color="red"> 259.         if value is None:</font>
<font color="red"> 260.             value = ''</font>
<font color="red"> 261.         final_attrs = self.build_attrs(attrs, type=self.input_type, name=name)</font>
<font color="red"> 262.         if value != '':</font>
<font color="black"> 263.             # Only add the 'value' attribute if a value is non-empty.</font>
<font color="red"> 264.             final_attrs['value'] = force_text(self._format_value(value))</font>
<font color="red"> 265.         return format_html('&lt;input{} /&gt;', flatatt(final_attrs))</font>
<font color="black"> 266. </font>
<font color="black"> 267. </font>
<font color="green"> 268. class TextInput(Input):</font>
<font color="green"> 269.     input_type = 'text'</font>
<font color="black"> 270. </font>
<font color="green"> 271.     def __init__(self, attrs=None):</font>
<font color="green"> 272.         if attrs is not None:</font>
<font color="red"> 273.             self.input_type = attrs.pop('type', self.input_type)</font>
<font color="green"> 274.         super(TextInput, self).__init__(attrs)</font>
<font color="black"> 275. </font>
<font color="black"> 276. </font>
<font color="green"> 277. class NumberInput(TextInput):</font>
<font color="green"> 278.     input_type = 'number'</font>
<font color="black"> 279. </font>
<font color="black"> 280. </font>
<font color="green"> 281. class EmailInput(TextInput):</font>
<font color="green"> 282.     input_type = 'email'</font>
<font color="black"> 283. </font>
<font color="black"> 284. </font>
<font color="green"> 285. class URLInput(TextInput):</font>
<font color="green"> 286.     input_type = 'url'</font>
<font color="black"> 287. </font>
<font color="black"> 288. </font>
<font color="green"> 289. class PasswordInput(TextInput):</font>
<font color="green"> 290.     input_type = 'password'</font>
<font color="black"> 291. </font>
<font color="green"> 292.     def __init__(self, attrs=None, render_value=False):</font>
<font color="green"> 293.         super(PasswordInput, self).__init__(attrs)</font>
<font color="green"> 294.         self.render_value = render_value</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def render(self, name, value, attrs=None):</font>
<font color="red"> 297.         if not self.render_value:</font>
<font color="red"> 298.             value = None</font>
<font color="red"> 299.         return super(PasswordInput, self).render(name, value, attrs)</font>
<font color="black"> 300. </font>
<font color="black"> 301. </font>
<font color="green"> 302. class HiddenInput(Input):</font>
<font color="green"> 303.     input_type = 'hidden'</font>
<font color="black"> 304. </font>
<font color="black"> 305. </font>
<font color="green"> 306. class MultipleHiddenInput(HiddenInput):</font>
<font color="black"> 307.     &quot;&quot;&quot;</font>
<font color="black"> 308.     A widget that handles &lt;input type=&quot;hidden&quot;&gt; for fields that have a list</font>
<font color="black"> 309.     of values.</font>
<font color="green"> 310.     &quot;&quot;&quot;</font>
<font color="green"> 311.     def __init__(self, attrs=None, choices=()):</font>
<font color="red"> 312.         super(MultipleHiddenInput, self).__init__(attrs)</font>
<font color="black"> 313.         # choices can be any iterable</font>
<font color="red"> 314.         self.choices = choices</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def render(self, name, value, attrs=None, choices=()):</font>
<font color="red"> 317.         if value is None:</font>
<font color="red"> 318.             value = []</font>
<font color="red"> 319.         final_attrs = self.build_attrs(attrs, type=self.input_type, name=name)</font>
<font color="red"> 320.         id_ = final_attrs.get('id')</font>
<font color="red"> 321.         inputs = []</font>
<font color="red"> 322.         for i, v in enumerate(value):</font>
<font color="red"> 323.             input_attrs = dict(value=force_text(v), **final_attrs)</font>
<font color="red"> 324.             if id_:</font>
<font color="black"> 325.                 # An ID attribute was given. Add a numeric index as a suffix</font>
<font color="black"> 326.                 # so that the inputs don't all have the same ID attribute.</font>
<font color="red"> 327.                 input_attrs['id'] = '%s_%s' % (id_, i)</font>
<font color="red"> 328.             inputs.append(format_html('&lt;input{} /&gt;', flatatt(input_attrs)))</font>
<font color="red"> 329.         return mark_safe('\n'.join(inputs))</font>
<font color="black"> 330. </font>
<font color="green"> 331.     def value_from_datadict(self, data, files, name):</font>
<font color="red"> 332.         if isinstance(data, MultiValueDict):</font>
<font color="red"> 333.             return data.getlist(name)</font>
<font color="red"> 334.         return data.get(name)</font>
<font color="black"> 335. </font>
<font color="black"> 336. </font>
<font color="green"> 337. class FileInput(Input):</font>
<font color="green"> 338.     input_type = 'file'</font>
<font color="green"> 339.     needs_multipart_form = True</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def render(self, name, value, attrs=None):</font>
<font color="red"> 342.         return super(FileInput, self).render(name, None, attrs=attrs)</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def value_from_datadict(self, data, files, name):</font>
<font color="black"> 345.         &quot;File widgets take data from FILES, not POST&quot;</font>
<font color="red"> 346.         return files.get(name)</font>
<font color="black"> 347. </font>
<font color="black"> 348. </font>
<font color="green"> 349. FILE_INPUT_CONTRADICTION = object()</font>
<font color="black"> 350. </font>
<font color="black"> 351. </font>
<font color="green"> 352. class ClearableFileInput(FileInput):</font>
<font color="green"> 353.     initial_text = ugettext_lazy('Currently')</font>
<font color="green"> 354.     input_text = ugettext_lazy('Change')</font>
<font color="green"> 355.     clear_checkbox_label = ugettext_lazy('Clear')</font>
<font color="black"> 356. </font>
<font color="black"> 357.     template_with_initial = (</font>
<font color="green"> 358.         '%(initial_text)s: &lt;a href=&quot;%(initial_url)s&quot;&gt;%(initial)s&lt;/a&gt; '</font>
<font color="black"> 359.         '%(clear_template)s&lt;br /&gt;%(input_text)s: %(input)s'</font>
<font color="black"> 360.     )</font>
<font color="black"> 361. </font>
<font color="green"> 362.     template_with_clear = '%(clear)s &lt;label for=&quot;%(clear_checkbox_id)s&quot;&gt;%(clear_checkbox_label)s&lt;/label&gt;'</font>
<font color="black"> 363. </font>
<font color="green"> 364.     def clear_checkbox_name(self, name):</font>
<font color="black"> 365.         &quot;&quot;&quot;</font>
<font color="black"> 366.         Given the name of the file input, return the name of the clear checkbox</font>
<font color="black"> 367.         input.</font>
<font color="black"> 368.         &quot;&quot;&quot;</font>
<font color="red"> 369.         return name + '-clear'</font>
<font color="black"> 370. </font>
<font color="green"> 371.     def clear_checkbox_id(self, name):</font>
<font color="black"> 372.         &quot;&quot;&quot;</font>
<font color="black"> 373.         Given the name of the clear checkbox input, return the HTML id for it.</font>
<font color="black"> 374.         &quot;&quot;&quot;</font>
<font color="red"> 375.         return name + '_id'</font>
<font color="black"> 376. </font>
<font color="green"> 377.     def is_initial(self, value):</font>
<font color="black"> 378.         &quot;&quot;&quot;</font>
<font color="black"> 379.         Return whether value is considered to be initial value.</font>
<font color="black"> 380.         &quot;&quot;&quot;</font>
<font color="red"> 381.         return bool(value and hasattr(value, 'url'))</font>
<font color="black"> 382. </font>
<font color="green"> 383.     def get_template_substitution_values(self, value):</font>
<font color="black"> 384.         &quot;&quot;&quot;</font>
<font color="black"> 385.         Return value-related substitutions.</font>
<font color="black"> 386.         &quot;&quot;&quot;</font>
<font color="red"> 387.         return {</font>
<font color="red"> 388.             'initial': conditional_escape(value),</font>
<font color="red"> 389.             'initial_url': conditional_escape(value.url),</font>
<font color="black"> 390.         }</font>
<font color="black"> 391. </font>
<font color="green"> 392.     def render(self, name, value, attrs=None):</font>
<font color="red"> 393.         substitutions = {</font>
<font color="red"> 394.             'initial_text': self.initial_text,</font>
<font color="red"> 395.             'input_text': self.input_text,</font>
<font color="red"> 396.             'clear_template': '',</font>
<font color="red"> 397.             'clear_checkbox_label': self.clear_checkbox_label,</font>
<font color="black"> 398.         }</font>
<font color="red"> 399.         template = '%(input)s'</font>
<font color="red"> 400.         substitutions['input'] = super(ClearableFileInput, self).render(name, value, attrs)</font>
<font color="black"> 401. </font>
<font color="red"> 402.         if self.is_initial(value):</font>
<font color="red"> 403.             template = self.template_with_initial</font>
<font color="red"> 404.             substitutions.update(self.get_template_substitution_values(value))</font>
<font color="red"> 405.             if not self.is_required:</font>
<font color="red"> 406.                 checkbox_name = self.clear_checkbox_name(name)</font>
<font color="red"> 407.                 checkbox_id = self.clear_checkbox_id(checkbox_name)</font>
<font color="red"> 408.                 substitutions['clear_checkbox_name'] = conditional_escape(checkbox_name)</font>
<font color="red"> 409.                 substitutions['clear_checkbox_id'] = conditional_escape(checkbox_id)</font>
<font color="red"> 410.                 substitutions['clear'] = CheckboxInput().render(checkbox_name, False, attrs={'id': checkbox_id})</font>
<font color="red"> 411.                 substitutions['clear_template'] = self.template_with_clear % substitutions</font>
<font color="black"> 412. </font>
<font color="red"> 413.         return mark_safe(template % substitutions)</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def value_from_datadict(self, data, files, name):</font>
<font color="red"> 416.         upload = super(ClearableFileInput, self).value_from_datadict(data, files, name)</font>
<font color="red"> 417.         if not self.is_required and CheckboxInput().value_from_datadict(</font>
<font color="red"> 418.                 data, files, self.clear_checkbox_name(name)):</font>
<font color="black"> 419. </font>
<font color="red"> 420.             if upload:</font>
<font color="black"> 421.                 # If the user contradicts themselves (uploads a new file AND</font>
<font color="black"> 422.                 # checks the &quot;clear&quot; checkbox), we return a unique marker</font>
<font color="black"> 423.                 # object that FileField will turn into a ValidationError.</font>
<font color="red"> 424.                 return FILE_INPUT_CONTRADICTION</font>
<font color="black"> 425.             # False signals to clear any existing value, as opposed to just None</font>
<font color="red"> 426.             return False</font>
<font color="red"> 427.         return upload</font>
<font color="black"> 428. </font>
<font color="black"> 429. </font>
<font color="green"> 430. class Textarea(Widget):</font>
<font color="green"> 431.     def __init__(self, attrs=None):</font>
<font color="black"> 432.         # Use slightly better defaults than HTML's 20x2 box</font>
<font color="red"> 433.         default_attrs = {'cols': '40', 'rows': '10'}</font>
<font color="red"> 434.         if attrs:</font>
<font color="red"> 435.             default_attrs.update(attrs)</font>
<font color="red"> 436.         super(Textarea, self).__init__(default_attrs)</font>
<font color="black"> 437. </font>
<font color="green"> 438.     def render(self, name, value, attrs=None):</font>
<font color="red"> 439.         if value is None:</font>
<font color="red"> 440.             value = ''</font>
<font color="red"> 441.         final_attrs = self.build_attrs(attrs, name=name)</font>
<font color="red"> 442.         return format_html('&lt;textarea{}&gt;\r\n{}&lt;/textarea&gt;',</font>
<font color="red"> 443.                            flatatt(final_attrs),</font>
<font color="red"> 444.                            force_text(value))</font>
<font color="black"> 445. </font>
<font color="black"> 446. </font>
<font color="green"> 447. class DateTimeBaseInput(TextInput):</font>
<font color="green"> 448.     format_key = ''</font>
<font color="green"> 449.     supports_microseconds = False</font>
<font color="black"> 450. </font>
<font color="green"> 451.     def __init__(self, attrs=None, format=None):</font>
<font color="green"> 452.         super(DateTimeBaseInput, self).__init__(attrs)</font>
<font color="green"> 453.         self.format = format if format else None</font>
<font color="black"> 454. </font>
<font color="green"> 455.     def _format_value(self, value):</font>
<font color="red"> 456.         return formats.localize_input(value,</font>
<font color="red"> 457.             self.format or formats.get_format(self.format_key)[0])</font>
<font color="black"> 458. </font>
<font color="black"> 459. </font>
<font color="green"> 460. class DateInput(DateTimeBaseInput):</font>
<font color="green"> 461.     format_key = 'DATE_INPUT_FORMATS'</font>
<font color="black"> 462. </font>
<font color="black"> 463. </font>
<font color="green"> 464. class DateTimeInput(DateTimeBaseInput):</font>
<font color="green"> 465.     format_key = 'DATETIME_INPUT_FORMATS'</font>
<font color="black"> 466. </font>
<font color="black"> 467. </font>
<font color="green"> 468. class TimeInput(DateTimeBaseInput):</font>
<font color="green"> 469.     format_key = 'TIME_INPUT_FORMATS'</font>
<font color="black"> 470. </font>
<font color="black"> 471. </font>
<font color="black"> 472. # Defined at module level so that CheckboxInput is picklable (#17976)</font>
<font color="green"> 473. def boolean_check(v):</font>
<font color="red"> 474.     return not (v is False or v is None or v == '')</font>
<font color="black"> 475. </font>
<font color="black"> 476. </font>
<font color="green"> 477. class CheckboxInput(Widget):</font>
<font color="green"> 478.     def __init__(self, attrs=None, check_test=None):</font>
<font color="green"> 479.         super(CheckboxInput, self).__init__(attrs)</font>
<font color="black"> 480.         # check_test is a callable that takes a value and returns True</font>
<font color="black"> 481.         # if the checkbox should be checked for that value.</font>
<font color="green"> 482.         self.check_test = boolean_check if check_test is None else check_test</font>
<font color="black"> 483. </font>
<font color="green"> 484.     def render(self, name, value, attrs=None):</font>
<font color="red"> 485.         final_attrs = self.build_attrs(attrs, type='checkbox', name=name)</font>
<font color="red"> 486.         if self.check_test(value):</font>
<font color="red"> 487.             final_attrs['checked'] = 'checked'</font>
<font color="red"> 488.         if not (value is True or value is False or value is None or value == ''):</font>
<font color="black"> 489.             # Only add the 'value' attribute if a value is non-empty.</font>
<font color="red"> 490.             final_attrs['value'] = force_text(value)</font>
<font color="red"> 491.         return format_html('&lt;input{} /&gt;', flatatt(final_attrs))</font>
<font color="black"> 492. </font>
<font color="green"> 493.     def value_from_datadict(self, data, files, name):</font>
<font color="red"> 494.         if name not in data:</font>
<font color="black"> 495.             # A missing value means False because HTML form submission does not</font>
<font color="black"> 496.             # send results for unselected checkboxes.</font>
<font color="red"> 497.             return False</font>
<font color="red"> 498.         value = data.get(name)</font>
<font color="black"> 499.         # Translate true and false strings to boolean values.</font>
<font color="red"> 500.         values = {'true': True, 'false': False}</font>
<font color="red"> 501.         if isinstance(value, six.string_types):</font>
<font color="red"> 502.             value = values.get(value.lower(), value)</font>
<font color="red"> 503.         return bool(value)</font>
<font color="black"> 504. </font>
<font color="black"> 505. </font>
<font color="green"> 506. class Select(Widget):</font>
<font color="green"> 507.     allow_multiple_selected = False</font>
<font color="black"> 508. </font>
<font color="green"> 509.     def __init__(self, attrs=None, choices=()):</font>
<font color="green"> 510.         super(Select, self).__init__(attrs)</font>
<font color="black"> 511.         # choices can be any iterable, but we may need to render this widget</font>
<font color="black"> 512.         # multiple times. Thus, collapse it into a list so it can be consumed</font>
<font color="black"> 513.         # more than once.</font>
<font color="green"> 514.         self.choices = list(choices)</font>
<font color="black"> 515. </font>
<font color="green"> 516.     def __deepcopy__(self, memo):</font>
<font color="red"> 517.         obj = copy.copy(self)</font>
<font color="red"> 518.         obj.attrs = self.attrs.copy()</font>
<font color="red"> 519.         obj.choices = copy.copy(self.choices)</font>
<font color="red"> 520.         memo[id(self)] = obj</font>
<font color="red"> 521.         return obj</font>
<font color="black"> 522. </font>
<font color="green"> 523.     def render(self, name, value, attrs=None, choices=()):</font>
<font color="red"> 524.         if value is None:</font>
<font color="red"> 525.             value = ''</font>
<font color="red"> 526.         final_attrs = self.build_attrs(attrs, name=name)</font>
<font color="red"> 527.         output = [format_html('&lt;select{}&gt;', flatatt(final_attrs))]</font>
<font color="red"> 528.         options = self.render_options(choices, [value])</font>
<font color="red"> 529.         if options:</font>
<font color="red"> 530.             output.append(options)</font>
<font color="red"> 531.         output.append('&lt;/select&gt;')</font>
<font color="red"> 532.         return mark_safe('\n'.join(output))</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def render_option(self, selected_choices, option_value, option_label):</font>
<font color="red"> 535.         if option_value is None:</font>
<font color="red"> 536.             option_value = ''</font>
<font color="red"> 537.         option_value = force_text(option_value)</font>
<font color="red"> 538.         if option_value in selected_choices:</font>
<font color="red"> 539.             selected_html = mark_safe(' selected=&quot;selected&quot;')</font>
<font color="red"> 540.             if not self.allow_multiple_selected:</font>
<font color="black"> 541.                 # Only allow for a single selection.</font>
<font color="red"> 542.                 selected_choices.remove(option_value)</font>
<font color="black"> 543.         else:</font>
<font color="red"> 544.             selected_html = ''</font>
<font color="red"> 545.         return format_html('&lt;option value=&quot;{}&quot;{}&gt;{}&lt;/option&gt;',</font>
<font color="red"> 546.                            option_value,</font>
<font color="red"> 547.                            selected_html,</font>
<font color="red"> 548.                            force_text(option_label))</font>
<font color="black"> 549. </font>
<font color="green"> 550.     def render_options(self, choices, selected_choices):</font>
<font color="black"> 551.         # Normalize to strings.</font>
<font color="red"> 552.         selected_choices = set(force_text(v) for v in selected_choices)</font>
<font color="red"> 553.         output = []</font>
<font color="red"> 554.         for option_value, option_label in chain(self.choices, choices):</font>
<font color="red"> 555.             if isinstance(option_label, (list, tuple)):</font>
<font color="red"> 556.                 output.append(format_html('&lt;optgroup label=&quot;{}&quot;&gt;', force_text(option_value)))</font>
<font color="red"> 557.                 for option in option_label:</font>
<font color="red"> 558.                     output.append(self.render_option(selected_choices, *option))</font>
<font color="red"> 559.                 output.append('&lt;/optgroup&gt;')</font>
<font color="black"> 560.             else:</font>
<font color="red"> 561.                 output.append(self.render_option(selected_choices, option_value, option_label))</font>
<font color="red"> 562.         return '\n'.join(output)</font>
<font color="black"> 563. </font>
<font color="black"> 564. </font>
<font color="green"> 565. class NullBooleanSelect(Select):</font>
<font color="black"> 566.     &quot;&quot;&quot;</font>
<font color="black"> 567.     A Select Widget intended to be used with NullBooleanField.</font>
<font color="green"> 568.     &quot;&quot;&quot;</font>
<font color="green"> 569.     def __init__(self, attrs=None):</font>
<font color="red"> 570.         choices = (('1', ugettext_lazy('Unknown')),</font>
<font color="red"> 571.                    ('2', ugettext_lazy('Yes')),</font>
<font color="red"> 572.                    ('3', ugettext_lazy('No')))</font>
<font color="red"> 573.         super(NullBooleanSelect, self).__init__(attrs, choices)</font>
<font color="black"> 574. </font>
<font color="green"> 575.     def render(self, name, value, attrs=None, choices=()):</font>
<font color="red"> 576.         try:</font>
<font color="red"> 577.             value = {True: '2', False: '3', '2': '2', '3': '3'}[value]</font>
<font color="red"> 578.         except KeyError:</font>
<font color="red"> 579.             value = '1'</font>
<font color="red"> 580.         return super(NullBooleanSelect, self).render(name, value, attrs, choices)</font>
<font color="black"> 581. </font>
<font color="green"> 582.     def value_from_datadict(self, data, files, name):</font>
<font color="red"> 583.         value = data.get(name)</font>
<font color="red"> 584.         return {'2': True,</font>
<font color="red"> 585.                 True: True,</font>
<font color="red"> 586.                 'True': True,</font>
<font color="red"> 587.                 '3': False,</font>
<font color="red"> 588.                 'False': False,</font>
<font color="red"> 589.                 False: False}.get(value)</font>
<font color="black"> 590. </font>
<font color="black"> 591. </font>
<font color="green"> 592. class SelectMultiple(Select):</font>
<font color="green"> 593.     allow_multiple_selected = True</font>
<font color="black"> 594. </font>
<font color="green"> 595.     def render(self, name, value, attrs=None, choices=()):</font>
<font color="red"> 596.         if value is None:</font>
<font color="red"> 597.             value = []</font>
<font color="red"> 598.         final_attrs = self.build_attrs(attrs, name=name)</font>
<font color="red"> 599.         output = [format_html('&lt;select multiple=&quot;multiple&quot;{}&gt;', flatatt(final_attrs))]</font>
<font color="red"> 600.         options = self.render_options(choices, value)</font>
<font color="red"> 601.         if options:</font>
<font color="red"> 602.             output.append(options)</font>
<font color="red"> 603.         output.append('&lt;/select&gt;')</font>
<font color="red"> 604.         return mark_safe('\n'.join(output))</font>
<font color="black"> 605. </font>
<font color="green"> 606.     def value_from_datadict(self, data, files, name):</font>
<font color="red"> 607.         if isinstance(data, MultiValueDict):</font>
<font color="red"> 608.             return data.getlist(name)</font>
<font color="red"> 609.         return data.get(name)</font>
<font color="black"> 610. </font>
<font color="black"> 611. </font>
<font color="green"> 612. @html_safe</font>
<font color="green"> 613. @python_2_unicode_compatible</font>
<font color="green"> 614. class ChoiceInput(SubWidget):</font>
<font color="black"> 615.     &quot;&quot;&quot;</font>
<font color="black"> 616.     An object used by ChoiceFieldRenderer that represents a single</font>
<font color="black"> 617.     &lt;input type='$input_type'&gt;.</font>
<font color="green"> 618.     &quot;&quot;&quot;</font>
<font color="green"> 619.     input_type = None  # Subclasses must define this</font>
<font color="black"> 620. </font>
<font color="green"> 621.     def __init__(self, name, value, attrs, choice, index):</font>
<font color="red"> 622.         self.name = name</font>
<font color="red"> 623.         self.value = value</font>
<font color="red"> 624.         self.attrs = attrs</font>
<font color="red"> 625.         self.choice_value = force_text(choice[0])</font>
<font color="red"> 626.         self.choice_label = force_text(choice[1])</font>
<font color="red"> 627.         self.index = index</font>
<font color="red"> 628.         if 'id' in self.attrs:</font>
<font color="red"> 629.             self.attrs['id'] += &quot;_%d&quot; % self.index</font>
<font color="black"> 630. </font>
<font color="green"> 631.     def __str__(self):</font>
<font color="red"> 632.         return self.render()</font>
<font color="black"> 633. </font>
<font color="green"> 634.     def render(self, name=None, value=None, attrs=None, choices=()):</font>
<font color="red"> 635.         if self.id_for_label:</font>
<font color="red"> 636.             label_for = format_html(' for=&quot;{}&quot;', self.id_for_label)</font>
<font color="black"> 637.         else:</font>
<font color="red"> 638.             label_for = ''</font>
<font color="red"> 639.         attrs = dict(self.attrs, **attrs) if attrs else self.attrs</font>
<font color="red"> 640.         return format_html(</font>
<font color="red"> 641.             '&lt;label{}&gt;{} {}&lt;/label&gt;', label_for, self.tag(attrs), self.choice_label</font>
<font color="black"> 642.         )</font>
<font color="black"> 643. </font>
<font color="green"> 644.     def is_checked(self):</font>
<font color="red"> 645.         return self.value == self.choice_value</font>
<font color="black"> 646. </font>
<font color="green"> 647.     def tag(self, attrs=None):</font>
<font color="red"> 648.         attrs = attrs or self.attrs</font>
<font color="red"> 649.         final_attrs = dict(attrs, type=self.input_type, name=self.name, value=self.choice_value)</font>
<font color="red"> 650.         if self.is_checked():</font>
<font color="red"> 651.             final_attrs['checked'] = 'checked'</font>
<font color="red"> 652.         return format_html('&lt;input{} /&gt;', flatatt(final_attrs))</font>
<font color="black"> 653. </font>
<font color="green"> 654.     @property</font>
<font color="black"> 655.     def id_for_label(self):</font>
<font color="red"> 656.         return self.attrs.get('id', '')</font>
<font color="black"> 657. </font>
<font color="black"> 658. </font>
<font color="green"> 659. class RadioChoiceInput(ChoiceInput):</font>
<font color="green"> 660.     input_type = 'radio'</font>
<font color="black"> 661. </font>
<font color="green"> 662.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 663.         super(RadioChoiceInput, self).__init__(*args, **kwargs)</font>
<font color="red"> 664.         self.value = force_text(self.value)</font>
<font color="black"> 665. </font>
<font color="black"> 666. </font>
<font color="green"> 667. class CheckboxChoiceInput(ChoiceInput):</font>
<font color="green"> 668.     input_type = 'checkbox'</font>
<font color="black"> 669. </font>
<font color="green"> 670.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 671.         super(CheckboxChoiceInput, self).__init__(*args, **kwargs)</font>
<font color="red"> 672.         self.value = set(force_text(v) for v in self.value)</font>
<font color="black"> 673. </font>
<font color="green"> 674.     def is_checked(self):</font>
<font color="red"> 675.         return self.choice_value in self.value</font>
<font color="black"> 676. </font>
<font color="black"> 677. </font>
<font color="green"> 678. @html_safe</font>
<font color="green"> 679. @python_2_unicode_compatible</font>
<font color="green"> 680. class ChoiceFieldRenderer(object):</font>
<font color="black"> 681.     &quot;&quot;&quot;</font>
<font color="black"> 682.     An object used by RadioSelect to enable customization of radio widgets.</font>
<font color="green"> 683.     &quot;&quot;&quot;</font>
<font color="black"> 684. </font>
<font color="green"> 685.     choice_input_class = None</font>
<font color="green"> 686.     outer_html = '&lt;ul{id_attr}&gt;{content}&lt;/ul&gt;'</font>
<font color="green"> 687.     inner_html = '&lt;li&gt;{choice_value}{sub_widgets}&lt;/li&gt;'</font>
<font color="black"> 688. </font>
<font color="green"> 689.     def __init__(self, name, value, attrs, choices):</font>
<font color="red"> 690.         self.name = name</font>
<font color="red"> 691.         self.value = value</font>
<font color="red"> 692.         self.attrs = attrs</font>
<font color="red"> 693.         self.choices = choices</font>
<font color="black"> 694. </font>
<font color="green"> 695.     def __getitem__(self, idx):</font>
<font color="red"> 696.         choice = self.choices[idx]  # Let the IndexError propagate</font>
<font color="red"> 697.         return self.choice_input_class(self.name, self.value, self.attrs.copy(), choice, idx)</font>
<font color="black"> 698. </font>
<font color="green"> 699.     def __str__(self):</font>
<font color="red"> 700.         return self.render()</font>
<font color="black"> 701. </font>
<font color="green"> 702.     def render(self):</font>
<font color="black"> 703.         &quot;&quot;&quot;</font>
<font color="black"> 704.         Outputs a &lt;ul&gt; for this set of choice fields.</font>
<font color="black"> 705.         If an id was given to the field, it is applied to the &lt;ul&gt; (each</font>
<font color="black"> 706.         item in the list will get an id of `$id_$i`).</font>
<font color="black"> 707.         &quot;&quot;&quot;</font>
<font color="red"> 708.         id_ = self.attrs.get('id')</font>
<font color="red"> 709.         output = []</font>
<font color="red"> 710.         for i, choice in enumerate(self.choices):</font>
<font color="red"> 711.             choice_value, choice_label = choice</font>
<font color="red"> 712.             if isinstance(choice_label, (tuple, list)):</font>
<font color="red"> 713.                 attrs_plus = self.attrs.copy()</font>
<font color="red"> 714.                 if id_:</font>
<font color="red"> 715.                     attrs_plus['id'] += '_{}'.format(i)</font>
<font color="red"> 716.                 sub_ul_renderer = self.__class__(</font>
<font color="red"> 717.                     name=self.name,</font>
<font color="red"> 718.                     value=self.value,</font>
<font color="red"> 719.                     attrs=attrs_plus,</font>
<font color="red"> 720.                     choices=choice_label,</font>
<font color="black"> 721.                 )</font>
<font color="red"> 722.                 sub_ul_renderer.choice_input_class = self.choice_input_class</font>
<font color="red"> 723.                 output.append(format_html(self.inner_html, choice_value=choice_value,</font>
<font color="red"> 724.                                           sub_widgets=sub_ul_renderer.render()))</font>
<font color="black"> 725.             else:</font>
<font color="red"> 726.                 w = self.choice_input_class(self.name, self.value,</font>
<font color="red"> 727.                                             self.attrs.copy(), choice, i)</font>
<font color="red"> 728.                 output.append(format_html(self.inner_html,</font>
<font color="red"> 729.                                           choice_value=force_text(w), sub_widgets=''))</font>
<font color="red"> 730.         return format_html(self.outer_html,</font>
<font color="red"> 731.                            id_attr=format_html(' id=&quot;{}&quot;', id_) if id_ else '',</font>
<font color="red"> 732.                            content=mark_safe('\n'.join(output)))</font>
<font color="black"> 733. </font>
<font color="black"> 734. </font>
<font color="green"> 735. class RadioFieldRenderer(ChoiceFieldRenderer):</font>
<font color="green"> 736.     choice_input_class = RadioChoiceInput</font>
<font color="black"> 737. </font>
<font color="black"> 738. </font>
<font color="green"> 739. class CheckboxFieldRenderer(ChoiceFieldRenderer):</font>
<font color="green"> 740.     choice_input_class = CheckboxChoiceInput</font>
<font color="black"> 741. </font>
<font color="black"> 742. </font>
<font color="green"> 743. class RendererMixin(object):</font>
<font color="green"> 744.     renderer = None  # subclasses must define this</font>
<font color="green"> 745.     _empty_value = None</font>
<font color="black"> 746. </font>
<font color="green"> 747.     def __init__(self, *args, **kwargs):</font>
<font color="black"> 748.         # Override the default renderer if we were passed one.</font>
<font color="red"> 749.         renderer = kwargs.pop('renderer', None)</font>
<font color="red"> 750.         if renderer:</font>
<font color="red"> 751.             self.renderer = renderer</font>
<font color="red"> 752.         super(RendererMixin, self).__init__(*args, **kwargs)</font>
<font color="black"> 753. </font>
<font color="green"> 754.     def subwidgets(self, name, value, attrs=None, choices=()):</font>
<font color="red"> 755.         for widget in self.get_renderer(name, value, attrs, choices):</font>
<font color="red"> 756.             yield widget</font>
<font color="black"> 757. </font>
<font color="green"> 758.     def get_renderer(self, name, value, attrs=None, choices=()):</font>
<font color="black"> 759.         &quot;&quot;&quot;Returns an instance of the renderer.&quot;&quot;&quot;</font>
<font color="red"> 760.         if value is None:</font>
<font color="red"> 761.             value = self._empty_value</font>
<font color="red"> 762.         final_attrs = self.build_attrs(attrs)</font>
<font color="red"> 763.         choices = list(chain(self.choices, choices))</font>
<font color="red"> 764.         return self.renderer(name, value, final_attrs, choices)</font>
<font color="black"> 765. </font>
<font color="green"> 766.     def render(self, name, value, attrs=None, choices=()):</font>
<font color="red"> 767.         return self.get_renderer(name, value, attrs, choices).render()</font>
<font color="black"> 768. </font>
<font color="green"> 769.     def id_for_label(self, id_):</font>
<font color="black"> 770.         # Widgets using this RendererMixin are made of a collection of</font>
<font color="black"> 771.         # subwidgets, each with their own &lt;label&gt;, and distinct ID.</font>
<font color="black"> 772.         # The IDs are made distinct by y &quot;_X&quot; suffix, where X is the zero-based</font>
<font color="black"> 773.         # index of the choice field. Thus, the label for the main widget should</font>
<font color="black"> 774.         # reference the first subwidget, hence the &quot;_0&quot; suffix.</font>
<font color="red"> 775.         if id_:</font>
<font color="red"> 776.             id_ += '_0'</font>
<font color="red"> 777.         return id_</font>
<font color="black"> 778. </font>
<font color="black"> 779. </font>
<font color="green"> 780. class RadioSelect(RendererMixin, Select):</font>
<font color="green"> 781.     renderer = RadioFieldRenderer</font>
<font color="green"> 782.     _empty_value = ''</font>
<font color="black"> 783. </font>
<font color="black"> 784. </font>
<font color="green"> 785. class CheckboxSelectMultiple(RendererMixin, SelectMultiple):</font>
<font color="green"> 786.     renderer = CheckboxFieldRenderer</font>
<font color="green"> 787.     _empty_value = []</font>
<font color="black"> 788. </font>
<font color="black"> 789. </font>
<font color="green"> 790. class MultiWidget(Widget):</font>
<font color="black"> 791.     &quot;&quot;&quot;</font>
<font color="black"> 792.     A widget that is composed of multiple widgets.</font>
<font color="black"> 793. </font>
<font color="black"> 794.     Its render() method is different than other widgets', because it has to</font>
<font color="black"> 795.     figure out how to split a single value for display in multiple widgets.</font>
<font color="black"> 796.     The ``value`` argument can be one of two things:</font>
<font color="black"> 797. </font>
<font color="black"> 798.         * A list.</font>
<font color="black"> 799.         * A normal value (e.g., a string) that has been &quot;compressed&quot; from</font>
<font color="black"> 800.           a list of values.</font>
<font color="black"> 801. </font>
<font color="black"> 802.     In the second case -- i.e., if the value is NOT a list -- render() will</font>
<font color="black"> 803.     first &quot;decompress&quot; the value into a list before rendering it. It does so by</font>
<font color="black"> 804.     calling the decompress() method, which MultiWidget subclasses must</font>
<font color="black"> 805.     implement. This method takes a single &quot;compressed&quot; value and returns a</font>
<font color="black"> 806.     list.</font>
<font color="black"> 807. </font>
<font color="black"> 808.     When render() does its HTML rendering, each value in the list is rendered</font>
<font color="black"> 809.     with the corresponding widget -- the first value is rendered in the first</font>
<font color="black"> 810.     widget, the second value is rendered in the second widget, etc.</font>
<font color="black"> 811. </font>
<font color="black"> 812.     Subclasses may implement format_output(), which takes the list of rendered</font>
<font color="black"> 813.     widgets and returns a string of HTML that formats them any way you'd like.</font>
<font color="black"> 814. </font>
<font color="black"> 815.     You'll probably want to use this class with MultiValueField.</font>
<font color="green"> 816.     &quot;&quot;&quot;</font>
<font color="green"> 817.     def __init__(self, widgets, attrs=None):</font>
<font color="red"> 818.         self.widgets = [w() if isinstance(w, type) else w for w in widgets]</font>
<font color="red"> 819.         super(MultiWidget, self).__init__(attrs)</font>
<font color="black"> 820. </font>
<font color="green"> 821.     @property</font>
<font color="black"> 822.     def is_hidden(self):</font>
<font color="red"> 823.         return all(w.is_hidden for w in self.widgets)</font>
<font color="black"> 824. </font>
<font color="green"> 825.     def render(self, name, value, attrs=None):</font>
<font color="red"> 826.         if self.is_localized:</font>
<font color="red"> 827.             for widget in self.widgets:</font>
<font color="red"> 828.                 widget.is_localized = self.is_localized</font>
<font color="black"> 829.         # value is a list of values, each corresponding to a widget</font>
<font color="black"> 830.         # in self.widgets.</font>
<font color="red"> 831.         if not isinstance(value, list):</font>
<font color="red"> 832.             value = self.decompress(value)</font>
<font color="red"> 833.         output = []</font>
<font color="red"> 834.         final_attrs = self.build_attrs(attrs)</font>
<font color="red"> 835.         id_ = final_attrs.get('id')</font>
<font color="red"> 836.         for i, widget in enumerate(self.widgets):</font>
<font color="red"> 837.             try:</font>
<font color="red"> 838.                 widget_value = value[i]</font>
<font color="red"> 839.             except IndexError:</font>
<font color="red"> 840.                 widget_value = None</font>
<font color="red"> 841.             if id_:</font>
<font color="red"> 842.                 final_attrs = dict(final_attrs, id='%s_%s' % (id_, i))</font>
<font color="red"> 843.             output.append(widget.render(name + '_%s' % i, widget_value, final_attrs))</font>
<font color="red"> 844.         return mark_safe(self.format_output(output))</font>
<font color="black"> 845. </font>
<font color="green"> 846.     def id_for_label(self, id_):</font>
<font color="black"> 847.         # See the comment for RadioSelect.id_for_label()</font>
<font color="red"> 848.         if id_:</font>
<font color="red"> 849.             id_ += '_0'</font>
<font color="red"> 850.         return id_</font>
<font color="black"> 851. </font>
<font color="green"> 852.     def value_from_datadict(self, data, files, name):</font>
<font color="red"> 853.         return [widget.value_from_datadict(data, files, name + '_%s' % i) for i, widget in enumerate(self.widgets)]</font>
<font color="black"> 854. </font>
<font color="green"> 855.     def format_output(self, rendered_widgets):</font>
<font color="black"> 856.         &quot;&quot;&quot;</font>
<font color="black"> 857.         Given a list of rendered widgets (as strings), returns a Unicode string</font>
<font color="black"> 858.         representing the HTML for the whole lot.</font>
<font color="black"> 859. </font>
<font color="black"> 860.         This hook allows you to format the HTML design of the widgets, if</font>
<font color="black"> 861.         needed.</font>
<font color="black"> 862.         &quot;&quot;&quot;</font>
<font color="red"> 863.         return ''.join(rendered_widgets)</font>
<font color="black"> 864. </font>
<font color="green"> 865.     def decompress(self, value):</font>
<font color="black"> 866.         &quot;&quot;&quot;</font>
<font color="black"> 867.         Returns a list of decompressed values for the given compressed value.</font>
<font color="black"> 868.         The given value can be assumed to be valid, but not necessarily</font>
<font color="black"> 869.         non-empty.</font>
<font color="black"> 870.         &quot;&quot;&quot;</font>
<font color="red"> 871.         raise NotImplementedError('Subclasses must implement this method.')</font>
<font color="black"> 872. </font>
<font color="green"> 873.     def _get_media(self):</font>
<font color="black"> 874.         &quot;Media for a multiwidget is the combination of all media of the subwidgets&quot;</font>
<font color="red"> 875.         media = Media()</font>
<font color="red"> 876.         for w in self.widgets:</font>
<font color="red"> 877.             media = media + w.media</font>
<font color="red"> 878.         return media</font>
<font color="green"> 879.     media = property(_get_media)</font>
<font color="black"> 880. </font>
<font color="green"> 881.     def __deepcopy__(self, memo):</font>
<font color="red"> 882.         obj = super(MultiWidget, self).__deepcopy__(memo)</font>
<font color="red"> 883.         obj.widgets = copy.deepcopy(self.widgets)</font>
<font color="red"> 884.         return obj</font>
<font color="black"> 885. </font>
<font color="green"> 886.     @property</font>
<font color="black"> 887.     def needs_multipart_form(self):</font>
<font color="red"> 888.         return any(w.needs_multipart_form for w in self.widgets)</font>
<font color="black"> 889. </font>
<font color="black"> 890. </font>
<font color="green"> 891. class SplitDateTimeWidget(MultiWidget):</font>
<font color="black"> 892.     &quot;&quot;&quot;</font>
<font color="black"> 893.     A Widget that splits datetime input into two &lt;input type=&quot;text&quot;&gt; boxes.</font>
<font color="green"> 894.     &quot;&quot;&quot;</font>
<font color="green"> 895.     supports_microseconds = False</font>
<font color="black"> 896. </font>
<font color="green"> 897.     def __init__(self, attrs=None, date_format=None, time_format=None):</font>
<font color="red"> 898.         widgets = (DateInput(attrs=attrs, format=date_format),</font>
<font color="red"> 899.                    TimeInput(attrs=attrs, format=time_format))</font>
<font color="red"> 900.         super(SplitDateTimeWidget, self).__init__(widgets, attrs)</font>
<font color="black"> 901. </font>
<font color="green"> 902.     def decompress(self, value):</font>
<font color="red"> 903.         if value:</font>
<font color="red"> 904.             value = to_current_timezone(value)</font>
<font color="red"> 905.             return [value.date(), value.time().replace(microsecond=0)]</font>
<font color="red"> 906.         return [None, None]</font>
<font color="black"> 907. </font>
<font color="black"> 908. </font>
<font color="green"> 909. class SplitHiddenDateTimeWidget(SplitDateTimeWidget):</font>
<font color="black"> 910.     &quot;&quot;&quot;</font>
<font color="black"> 911.     A Widget that splits datetime input into two &lt;input type=&quot;hidden&quot;&gt; inputs.</font>
<font color="green"> 912.     &quot;&quot;&quot;</font>
<font color="green"> 913.     def __init__(self, attrs=None, date_format=None, time_format=None):</font>
<font color="red"> 914.         super(SplitHiddenDateTimeWidget, self).__init__(attrs, date_format, time_format)</font>
<font color="red"> 915.         for widget in self.widgets:</font>
<font color="red"> 916.             widget.input_type = 'hidden'</font>
<font color="black"> 917. </font>
<font color="black"> 918. </font>
<font color="green"> 919. class SelectDateWidget(Widget):</font>
<font color="black"> 920.     &quot;&quot;&quot;</font>
<font color="black"> 921.     A Widget that splits date input into three &lt;select&gt; boxes.</font>
<font color="black"> 922. </font>
<font color="black"> 923.     This also serves as an example of a Widget that has more than one HTML</font>
<font color="black"> 924.     element and hence implements value_from_datadict.</font>
<font color="green"> 925.     &quot;&quot;&quot;</font>
<font color="green"> 926.     none_value = (0, '---')</font>
<font color="green"> 927.     month_field = '%s_month'</font>
<font color="green"> 928.     day_field = '%s_day'</font>
<font color="green"> 929.     year_field = '%s_year'</font>
<font color="green"> 930.     select_widget = Select</font>
<font color="black"> 931. </font>
<font color="green"> 932.     date_re = re.compile(r'(\d{4})-(\d\d?)-(\d\d?)$')</font>
<font color="black"> 933. </font>
<font color="green"> 934.     def __init__(self, attrs=None, years=None, months=None, empty_label=None):</font>
<font color="red"> 935.         self.attrs = attrs or {}</font>
<font color="black"> 936. </font>
<font color="black"> 937.         # Optional list or tuple of years to use in the &quot;year&quot; select box.</font>
<font color="red"> 938.         if years:</font>
<font color="red"> 939.             self.years = years</font>
<font color="black"> 940.         else:</font>
<font color="red"> 941.             this_year = datetime.date.today().year</font>
<font color="red"> 942.             self.years = range(this_year, this_year + 10)</font>
<font color="black"> 943. </font>
<font color="black"> 944.         # Optional dict of months to use in the &quot;month&quot; select box.</font>
<font color="red"> 945.         if months:</font>
<font color="red"> 946.             self.months = months</font>
<font color="black"> 947.         else:</font>
<font color="red"> 948.             self.months = MONTHS</font>
<font color="black"> 949. </font>
<font color="black"> 950.         # Optional string, list, or tuple to use as empty_label.</font>
<font color="red"> 951.         if isinstance(empty_label, (list, tuple)):</font>
<font color="red"> 952.             if not len(empty_label) == 3:</font>
<font color="red"> 953.                 raise ValueError('empty_label list/tuple must have 3 elements.')</font>
<font color="black"> 954. </font>
<font color="red"> 955.             self.year_none_value = (0, empty_label[0])</font>
<font color="red"> 956.             self.month_none_value = (0, empty_label[1])</font>
<font color="red"> 957.             self.day_none_value = (0, empty_label[2])</font>
<font color="black"> 958.         else:</font>
<font color="red"> 959.             if empty_label is not None:</font>
<font color="red"> 960.                 self.none_value = (0, empty_label)</font>
<font color="black"> 961. </font>
<font color="red"> 962.             self.year_none_value = self.none_value</font>
<font color="red"> 963.             self.month_none_value = self.none_value</font>
<font color="red"> 964.             self.day_none_value = self.none_value</font>
<font color="black"> 965. </font>
<font color="green"> 966.     @staticmethod</font>
<font color="black"> 967.     def _parse_date_fmt():</font>
<font color="red"> 968.         fmt = get_format('DATE_FORMAT')</font>
<font color="red"> 969.         escaped = False</font>
<font color="red"> 970.         for char in fmt:</font>
<font color="red"> 971.             if escaped:</font>
<font color="red"> 972.                 escaped = False</font>
<font color="red"> 973.             elif char == '\\':</font>
<font color="red"> 974.                 escaped = True</font>
<font color="red"> 975.             elif char in 'Yy':</font>
<font color="red"> 976.                 yield 'year'</font>
<font color="red"> 977.             elif char in 'bEFMmNn':</font>
<font color="red"> 978.                 yield 'month'</font>
<font color="red"> 979.             elif char in 'dj':</font>
<font color="red"> 980.                 yield 'day'</font>
<font color="black"> 981. </font>
<font color="green"> 982.     def render(self, name, value, attrs=None):</font>
<font color="red"> 983.         try:</font>
<font color="red"> 984.             year_val, month_val, day_val = value.year, value.month, value.day</font>
<font color="red"> 985.         except AttributeError:</font>
<font color="red"> 986.             year_val = month_val = day_val = None</font>
<font color="red"> 987.             if isinstance(value, six.string_types):</font>
<font color="red"> 988.                 if settings.USE_L10N:</font>
<font color="red"> 989.                     try:</font>
<font color="red"> 990.                         input_format = get_format('DATE_INPUT_FORMATS')[0]</font>
<font color="red"> 991.                         v = datetime.datetime.strptime(force_str(value), input_format)</font>
<font color="red"> 992.                         year_val, month_val, day_val = v.year, v.month, v.day</font>
<font color="red"> 993.                     except ValueError:</font>
<font color="red"> 994.                         pass</font>
<font color="red"> 995.                 if year_val is None:</font>
<font color="red"> 996.                     match = self.date_re.match(value)</font>
<font color="red"> 997.                     if match:</font>
<font color="red"> 998.                         year_val, month_val, day_val = [int(val) for val in match.groups()]</font>
<font color="red"> 999.         html = {}</font>
<font color="red">1000.         choices = [(i, i) for i in self.years]</font>
<font color="red">1001.         html['year'] = self.create_select(name, self.year_field, value, year_val, choices, self.year_none_value)</font>
<font color="red">1002.         choices = list(self.months.items())</font>
<font color="red">1003.         html['month'] = self.create_select(name, self.month_field, value, month_val, choices, self.month_none_value)</font>
<font color="red">1004.         choices = [(i, i) for i in range(1, 32)]</font>
<font color="red">1005.         html['day'] = self.create_select(name, self.day_field, value, day_val, choices, self.day_none_value)</font>
<font color="black">1006. </font>
<font color="red">1007.         output = []</font>
<font color="red">1008.         for field in self._parse_date_fmt():</font>
<font color="red">1009.             output.append(html[field])</font>
<font color="red">1010.         return mark_safe('\n'.join(output))</font>
<font color="black">1011. </font>
<font color="green">1012.     def id_for_label(self, id_):</font>
<font color="red">1013.         for first_select in self._parse_date_fmt():</font>
<font color="red">1014.             return '%s_%s' % (id_, first_select)</font>
<font color="black">1015.         else:</font>
<font color="red">1016.             return '%s_month' % id_</font>
<font color="black">1017. </font>
<font color="green">1018.     def value_from_datadict(self, data, files, name):</font>
<font color="red">1019.         y = data.get(self.year_field % name)</font>
<font color="red">1020.         m = data.get(self.month_field % name)</font>
<font color="red">1021.         d = data.get(self.day_field % name)</font>
<font color="red">1022.         if y == m == d == &quot;0&quot;:</font>
<font color="red">1023.             return None</font>
<font color="red">1024.         if y and m and d:</font>
<font color="red">1025.             if settings.USE_L10N:</font>
<font color="red">1026.                 input_format = get_format('DATE_INPUT_FORMATS')[0]</font>
<font color="red">1027.                 try:</font>
<font color="red">1028.                     date_value = datetime.date(int(y), int(m), int(d))</font>
<font color="red">1029.                 except ValueError:</font>
<font color="red">1030.                     return '%s-%s-%s' % (y, m, d)</font>
<font color="black">1031.                 else:</font>
<font color="red">1032.                     date_value = datetime_safe.new_date(date_value)</font>
<font color="red">1033.                     return date_value.strftime(input_format)</font>
<font color="black">1034.             else:</font>
<font color="red">1035.                 return '%s-%s-%s' % (y, m, d)</font>
<font color="red">1036.         return data.get(name)</font>
<font color="black">1037. </font>
<font color="green">1038.     def create_select(self, name, field, value, val, choices, none_value):</font>
<font color="red">1039.         if 'id' in self.attrs:</font>
<font color="red">1040.             id_ = self.attrs['id']</font>
<font color="black">1041.         else:</font>
<font color="red">1042.             id_ = 'id_%s' % name</font>
<font color="red">1043.         if not self.is_required:</font>
<font color="red">1044.             choices.insert(0, none_value)</font>
<font color="red">1045.         local_attrs = self.build_attrs(id=field % id_)</font>
<font color="red">1046.         s = self.select_widget(choices=choices)</font>
<font color="red">1047.         select_html = s.render(field % name, val, local_attrs)</font>
<font color="red">1048.         return select_html</font>
</pre>

