source file: <b>/usr/lib/python2.7/subprocess.py</b><br>


file stats: <b>743 lines, 66 executed: 8.9% covered</b>
<pre>
<font color="black">   1. # subprocess - Subprocesses with accessible I/O streams</font>
<font color="black">   2. #</font>
<font color="black">   3. # For more information about this module, see PEP 324.</font>
<font color="black">   4. #</font>
<font color="black">   5. # Copyright (c) 2003-2005 by Peter Astrand &lt;astrand@lysator.liu.se&gt;</font>
<font color="black">   6. #</font>
<font color="black">   7. # Licensed to PSF under a Contributor Agreement.</font>
<font color="black">   8. # See http://www.python.org/2.4/license for licensing details.</font>
<font color="black">   9. </font>
<font color="black">  10. r&quot;&quot;&quot;subprocess - Subprocesses with accessible I/O streams</font>
<font color="black">  11. </font>
<font color="black">  12. This module allows you to spawn processes, connect to their</font>
<font color="black">  13. input/output/error pipes, and obtain their return codes.  This module</font>
<font color="black">  14. intends to replace several older modules and functions:</font>
<font color="black">  15. </font>
<font color="black">  16. os.system</font>
<font color="black">  17. os.spawn*</font>
<font color="black">  18. os.popen*</font>
<font color="black">  19. popen2.*</font>
<font color="black">  20. commands.*</font>
<font color="black">  21. </font>
<font color="black">  22. Information about how the subprocess module can be used to replace these</font>
<font color="black">  23. modules and functions can be found below.</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="black">  27. Using the subprocess module</font>
<font color="black">  28. ===========================</font>
<font color="black">  29. This module defines one class called Popen:</font>
<font color="black">  30. </font>
<font color="black">  31. class Popen(args, bufsize=0, executable=None,</font>
<font color="black">  32.             stdin=None, stdout=None, stderr=None,</font>
<font color="black">  33.             preexec_fn=None, close_fds=False, shell=False,</font>
<font color="black">  34.             cwd=None, env=None, universal_newlines=False,</font>
<font color="black">  35.             startupinfo=None, creationflags=0):</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="black">  38. Arguments are:</font>
<font color="black">  39. </font>
<font color="black">  40. args should be a string, or a sequence of program arguments.  The</font>
<font color="black">  41. program to execute is normally the first item in the args sequence or</font>
<font color="black">  42. string, but can be explicitly set by using the executable argument.</font>
<font color="black">  43. </font>
<font color="black">  44. On UNIX, with shell=False (default): In this case, the Popen class</font>
<font color="black">  45. uses os.execvp() to execute the child program.  args should normally</font>
<font color="black">  46. be a sequence.  A string will be treated as a sequence with the string</font>
<font color="black">  47. as the only item (the program to execute).</font>
<font color="black">  48. </font>
<font color="black">  49. On UNIX, with shell=True: If args is a string, it specifies the</font>
<font color="black">  50. command string to execute through the shell.  If args is a sequence,</font>
<font color="black">  51. the first item specifies the command string, and any additional items</font>
<font color="black">  52. will be treated as additional shell arguments.</font>
<font color="black">  53. </font>
<font color="black">  54. On Windows: the Popen class uses CreateProcess() to execute the child</font>
<font color="black">  55. program, which operates on strings.  If args is a sequence, it will be</font>
<font color="black">  56. converted to a string using the list2cmdline method.  Please note that</font>
<font color="black">  57. not all MS Windows applications interpret the command line the same</font>
<font color="black">  58. way: The list2cmdline is designed for applications using the same</font>
<font color="black">  59. rules as the MS C runtime.</font>
<font color="black">  60. </font>
<font color="black">  61. bufsize, if given, has the same meaning as the corresponding argument</font>
<font color="black">  62. to the built-in open() function: 0 means unbuffered, 1 means line</font>
<font color="black">  63. buffered, any other positive value means use a buffer of</font>
<font color="black">  64. (approximately) that size.  A negative bufsize means to use the system</font>
<font color="black">  65. default, which usually means fully buffered.  The default value for</font>
<font color="black">  66. bufsize is 0 (unbuffered).</font>
<font color="black">  67. </font>
<font color="black">  68. stdin, stdout and stderr specify the executed programs' standard</font>
<font color="black">  69. input, standard output and standard error file handles, respectively.</font>
<font color="black">  70. Valid values are PIPE, an existing file descriptor (a positive</font>
<font color="black">  71. integer), an existing file object, and None.  PIPE indicates that a</font>
<font color="black">  72. new pipe to the child should be created.  With None, no redirection</font>
<font color="black">  73. will occur; the child's file handles will be inherited from the</font>
<font color="black">  74. parent.  Additionally, stderr can be STDOUT, which indicates that the</font>
<font color="black">  75. stderr data from the applications should be captured into the same</font>
<font color="black">  76. file handle as for stdout.</font>
<font color="black">  77. </font>
<font color="black">  78. If preexec_fn is set to a callable object, this object will be called</font>
<font color="black">  79. in the child process just before the child is executed.</font>
<font color="black">  80. </font>
<font color="black">  81. If close_fds is true, all file descriptors except 0, 1 and 2 will be</font>
<font color="black">  82. closed before the child process is executed.</font>
<font color="black">  83. </font>
<font color="black">  84. if shell is true, the specified command will be executed through the</font>
<font color="black">  85. shell.</font>
<font color="black">  86. </font>
<font color="black">  87. If cwd is not None, the current directory will be changed to cwd</font>
<font color="black">  88. before the child is executed.</font>
<font color="black">  89. </font>
<font color="black">  90. If env is not None, it defines the environment variables for the new</font>
<font color="black">  91. process.</font>
<font color="black">  92. </font>
<font color="black">  93. If universal_newlines is true, the file objects stdout and stderr are</font>
<font color="black">  94. opened as a text files, but lines may be terminated by any of '\n',</font>
<font color="black">  95. the Unix end-of-line convention, '\r', the Macintosh convention or</font>
<font color="black">  96. '\r\n', the Windows convention.  All of these external representations</font>
<font color="black">  97. are seen as '\n' by the Python program.  Note: This feature is only</font>
<font color="black">  98. available if Python is built with universal newline support (the</font>
<font color="black">  99. default).  Also, the newlines attribute of the file objects stdout,</font>
<font color="black"> 100. stdin and stderr are not updated by the communicate() method.</font>
<font color="black"> 101. </font>
<font color="black"> 102. The startupinfo and creationflags, if given, will be passed to the</font>
<font color="black"> 103. underlying CreateProcess() function.  They can specify things such as</font>
<font color="black"> 104. appearance of the main window and priority for the new process.</font>
<font color="black"> 105. (Windows only)</font>
<font color="black"> 106. </font>
<font color="black"> 107. </font>
<font color="black"> 108. This module also defines some shortcut functions:</font>
<font color="black"> 109. </font>
<font color="black"> 110. call(*popenargs, **kwargs):</font>
<font color="black"> 111.     Run command with arguments.  Wait for command to complete, then</font>
<font color="black"> 112.     return the returncode attribute.</font>
<font color="black"> 113. </font>
<font color="black"> 114.     The arguments are the same as for the Popen constructor.  Example:</font>
<font color="black"> 115. </font>
<font color="black"> 116.     retcode = call([&quot;ls&quot;, &quot;-l&quot;])</font>
<font color="black"> 117. </font>
<font color="black"> 118. check_call(*popenargs, **kwargs):</font>
<font color="black"> 119.     Run command with arguments.  Wait for command to complete.  If the</font>
<font color="black"> 120.     exit code was zero then return, otherwise raise</font>
<font color="black"> 121.     CalledProcessError.  The CalledProcessError object will have the</font>
<font color="black"> 122.     return code in the returncode attribute.</font>
<font color="black"> 123. </font>
<font color="black"> 124.     The arguments are the same as for the Popen constructor.  Example:</font>
<font color="black"> 125. </font>
<font color="black"> 126.     check_call([&quot;ls&quot;, &quot;-l&quot;])</font>
<font color="black"> 127. </font>
<font color="black"> 128. check_output(*popenargs, **kwargs):</font>
<font color="black"> 129.     Run command with arguments and return its output as a byte string.</font>
<font color="black"> 130. </font>
<font color="black"> 131.     If the exit code was non-zero it raises a CalledProcessError.  The</font>
<font color="black"> 132.     CalledProcessError object will have the return code in the returncode</font>
<font color="black"> 133.     attribute and output in the output attribute.</font>
<font color="black"> 134. </font>
<font color="black"> 135.     The arguments are the same as for the Popen constructor.  Example:</font>
<font color="black"> 136. </font>
<font color="black"> 137.     output = check_output([&quot;ls&quot;, &quot;-l&quot;, &quot;/dev/null&quot;])</font>
<font color="black"> 138. </font>
<font color="black"> 139. </font>
<font color="black"> 140. Exceptions</font>
<font color="black"> 141. ----------</font>
<font color="black"> 142. Exceptions raised in the child process, before the new program has</font>
<font color="black"> 143. started to execute, will be re-raised in the parent.  Additionally,</font>
<font color="black"> 144. the exception object will have one extra attribute called</font>
<font color="black"> 145. 'child_traceback', which is a string containing traceback information</font>
<font color="black"> 146. from the child's point of view.</font>
<font color="black"> 147. </font>
<font color="black"> 148. The most common exception raised is OSError.  This occurs, for</font>
<font color="black"> 149. example, when trying to execute a non-existent file.  Applications</font>
<font color="black"> 150. should prepare for OSErrors.</font>
<font color="black"> 151. </font>
<font color="black"> 152. A ValueError will be raised if Popen is called with invalid arguments.</font>
<font color="black"> 153. </font>
<font color="black"> 154. check_call() and check_output() will raise CalledProcessError, if the</font>
<font color="black"> 155. called process returns a non-zero return code.</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="black"> 158. Security</font>
<font color="black"> 159. --------</font>
<font color="black"> 160. Unlike some other popen functions, this implementation will never call</font>
<font color="black"> 161. /bin/sh implicitly.  This means that all characters, including shell</font>
<font color="black"> 162. metacharacters, can safely be passed to child processes.</font>
<font color="black"> 163. </font>
<font color="black"> 164. </font>
<font color="black"> 165. Popen objects</font>
<font color="black"> 166. =============</font>
<font color="black"> 167. Instances of the Popen class have the following methods:</font>
<font color="black"> 168. </font>
<font color="black"> 169. poll()</font>
<font color="black"> 170.     Check if child process has terminated.  Returns returncode</font>
<font color="black"> 171.     attribute.</font>
<font color="black"> 172. </font>
<font color="black"> 173. wait()</font>
<font color="black"> 174.     Wait for child process to terminate.  Returns returncode attribute.</font>
<font color="black"> 175. </font>
<font color="black"> 176. communicate(input=None)</font>
<font color="black"> 177.     Interact with process: Send data to stdin.  Read data from stdout</font>
<font color="black"> 178.     and stderr, until end-of-file is reached.  Wait for process to</font>
<font color="black"> 179.     terminate.  The optional input argument should be a string to be</font>
<font color="black"> 180.     sent to the child process, or None, if no data should be sent to</font>
<font color="black"> 181.     the child.</font>
<font color="black"> 182. </font>
<font color="black"> 183.     communicate() returns a tuple (stdout, stderr).</font>
<font color="black"> 184. </font>
<font color="black"> 185.     Note: The data read is buffered in memory, so do not use this</font>
<font color="black"> 186.     method if the data size is large or unlimited.</font>
<font color="black"> 187. </font>
<font color="black"> 188. The following attributes are also available:</font>
<font color="black"> 189. </font>
<font color="black"> 190. stdin</font>
<font color="black"> 191.     If the stdin argument is PIPE, this attribute is a file object</font>
<font color="black"> 192.     that provides input to the child process.  Otherwise, it is None.</font>
<font color="black"> 193. </font>
<font color="black"> 194. stdout</font>
<font color="black"> 195.     If the stdout argument is PIPE, this attribute is a file object</font>
<font color="black"> 196.     that provides output from the child process.  Otherwise, it is</font>
<font color="black"> 197.     None.</font>
<font color="black"> 198. </font>
<font color="black"> 199. stderr</font>
<font color="black"> 200.     If the stderr argument is PIPE, this attribute is file object that</font>
<font color="black"> 201.     provides error output from the child process.  Otherwise, it is</font>
<font color="black"> 202.     None.</font>
<font color="black"> 203. </font>
<font color="black"> 204. pid</font>
<font color="black"> 205.     The process ID of the child process.</font>
<font color="black"> 206. </font>
<font color="black"> 207. returncode</font>
<font color="black"> 208.     The child return code.  A None value indicates that the process</font>
<font color="black"> 209.     hasn't terminated yet.  A negative value -N indicates that the</font>
<font color="black"> 210.     child was terminated by signal N (UNIX only).</font>
<font color="black"> 211. </font>
<font color="black"> 212. </font>
<font color="black"> 213. Replacing older functions with the subprocess module</font>
<font color="black"> 214. ====================================================</font>
<font color="black"> 215. In this section, &quot;a ==&gt; b&quot; means that b can be used as a replacement</font>
<font color="black"> 216. for a.</font>
<font color="black"> 217. </font>
<font color="black"> 218. Note: All functions in this section fail (more or less) silently if</font>
<font color="black"> 219. the executed program cannot be found; this module raises an OSError</font>
<font color="black"> 220. exception.</font>
<font color="black"> 221. </font>
<font color="black"> 222. In the following examples, we assume that the subprocess module is</font>
<font color="black"> 223. imported with &quot;from subprocess import *&quot;.</font>
<font color="black"> 224. </font>
<font color="black"> 225. </font>
<font color="black"> 226. Replacing /bin/sh shell backquote</font>
<font color="black"> 227. ---------------------------------</font>
<font color="black"> 228. output=`mycmd myarg`</font>
<font color="black"> 229. ==&gt;</font>
<font color="black"> 230. output = Popen([&quot;mycmd&quot;, &quot;myarg&quot;], stdout=PIPE).communicate()[0]</font>
<font color="black"> 231. </font>
<font color="black"> 232. </font>
<font color="black"> 233. Replacing shell pipe line</font>
<font color="black"> 234. -------------------------</font>
<font color="black"> 235. output=`dmesg | grep hda`</font>
<font color="black"> 236. ==&gt;</font>
<font color="black"> 237. p1 = Popen([&quot;dmesg&quot;], stdout=PIPE)</font>
<font color="black"> 238. p2 = Popen([&quot;grep&quot;, &quot;hda&quot;], stdin=p1.stdout, stdout=PIPE)</font>
<font color="black"> 239. output = p2.communicate()[0]</font>
<font color="black"> 240. </font>
<font color="black"> 241. </font>
<font color="black"> 242. Replacing os.system()</font>
<font color="black"> 243. ---------------------</font>
<font color="black"> 244. sts = os.system(&quot;mycmd&quot; + &quot; myarg&quot;)</font>
<font color="black"> 245. ==&gt;</font>
<font color="black"> 246. p = Popen(&quot;mycmd&quot; + &quot; myarg&quot;, shell=True)</font>
<font color="black"> 247. pid, sts = os.waitpid(p.pid, 0)</font>
<font color="black"> 248. </font>
<font color="black"> 249. Note:</font>
<font color="black"> 250. </font>
<font color="black"> 251. * Calling the program through the shell is usually not required.</font>
<font color="black"> 252. </font>
<font color="black"> 253. * It's easier to look at the returncode attribute than the</font>
<font color="black"> 254.   exitstatus.</font>
<font color="black"> 255. </font>
<font color="black"> 256. A more real-world example would look like this:</font>
<font color="black"> 257. </font>
<font color="black"> 258. try:</font>
<font color="black"> 259.     retcode = call(&quot;mycmd&quot; + &quot; myarg&quot;, shell=True)</font>
<font color="black"> 260.     if retcode &lt; 0:</font>
<font color="black"> 261.         print &gt;&gt;sys.stderr, &quot;Child was terminated by signal&quot;, -retcode</font>
<font color="black"> 262.     else:</font>
<font color="black"> 263.         print &gt;&gt;sys.stderr, &quot;Child returned&quot;, retcode</font>
<font color="black"> 264. except OSError, e:</font>
<font color="black"> 265.     print &gt;&gt;sys.stderr, &quot;Execution failed:&quot;, e</font>
<font color="black"> 266. </font>
<font color="black"> 267. </font>
<font color="black"> 268. Replacing os.spawn*</font>
<font color="black"> 269. -------------------</font>
<font color="black"> 270. P_NOWAIT example:</font>
<font color="black"> 271. </font>
<font color="black"> 272. pid = os.spawnlp(os.P_NOWAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;)</font>
<font color="black"> 273. ==&gt;</font>
<font color="black"> 274. pid = Popen([&quot;/bin/mycmd&quot;, &quot;myarg&quot;]).pid</font>
<font color="black"> 275. </font>
<font color="black"> 276. </font>
<font color="black"> 277. P_WAIT example:</font>
<font color="black"> 278. </font>
<font color="black"> 279. retcode = os.spawnlp(os.P_WAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;)</font>
<font color="black"> 280. ==&gt;</font>
<font color="black"> 281. retcode = call([&quot;/bin/mycmd&quot;, &quot;myarg&quot;])</font>
<font color="black"> 282. </font>
<font color="black"> 283. </font>
<font color="black"> 284. Vector example:</font>
<font color="black"> 285. </font>
<font color="black"> 286. os.spawnvp(os.P_NOWAIT, path, args)</font>
<font color="black"> 287. ==&gt;</font>
<font color="black"> 288. Popen([path] + args[1:])</font>
<font color="black"> 289. </font>
<font color="black"> 290. </font>
<font color="black"> 291. Environment example:</font>
<font color="black"> 292. </font>
<font color="black"> 293. os.spawnlpe(os.P_NOWAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;, env)</font>
<font color="black"> 294. ==&gt;</font>
<font color="black"> 295. Popen([&quot;/bin/mycmd&quot;, &quot;myarg&quot;], env={&quot;PATH&quot;: &quot;/usr/bin&quot;})</font>
<font color="black"> 296. </font>
<font color="black"> 297. </font>
<font color="black"> 298. Replacing os.popen*</font>
<font color="black"> 299. -------------------</font>
<font color="black"> 300. pipe = os.popen(&quot;cmd&quot;, mode='r', bufsize)</font>
<font color="black"> 301. ==&gt;</font>
<font color="black"> 302. pipe = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize, stdout=PIPE).stdout</font>
<font color="black"> 303. </font>
<font color="black"> 304. pipe = os.popen(&quot;cmd&quot;, mode='w', bufsize)</font>
<font color="black"> 305. ==&gt;</font>
<font color="black"> 306. pipe = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize, stdin=PIPE).stdin</font>
<font color="black"> 307. </font>
<font color="black"> 308. </font>
<font color="black"> 309. (child_stdin, child_stdout) = os.popen2(&quot;cmd&quot;, mode, bufsize)</font>
<font color="black"> 310. ==&gt;</font>
<font color="black"> 311. p = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize,</font>
<font color="black"> 312.           stdin=PIPE, stdout=PIPE, close_fds=True)</font>
<font color="black"> 313. (child_stdin, child_stdout) = (p.stdin, p.stdout)</font>
<font color="black"> 314. </font>
<font color="black"> 315. </font>
<font color="black"> 316. (child_stdin,</font>
<font color="black"> 317.  child_stdout,</font>
<font color="black"> 318.  child_stderr) = os.popen3(&quot;cmd&quot;, mode, bufsize)</font>
<font color="black"> 319. ==&gt;</font>
<font color="black"> 320. p = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize,</font>
<font color="black"> 321.           stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)</font>
<font color="black"> 322. (child_stdin,</font>
<font color="black"> 323.  child_stdout,</font>
<font color="black"> 324.  child_stderr) = (p.stdin, p.stdout, p.stderr)</font>
<font color="black"> 325. </font>
<font color="black"> 326. </font>
<font color="black"> 327. (child_stdin, child_stdout_and_stderr) = os.popen4(&quot;cmd&quot;, mode,</font>
<font color="black"> 328.                                                    bufsize)</font>
<font color="black"> 329. ==&gt;</font>
<font color="black"> 330. p = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize,</font>
<font color="black"> 331.           stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)</font>
<font color="black"> 332. (child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)</font>
<font color="black"> 333. </font>
<font color="black"> 334. On Unix, os.popen2, os.popen3 and os.popen4 also accept a sequence as</font>
<font color="black"> 335. the command to execute, in which case arguments will be passed</font>
<font color="black"> 336. directly to the program without shell intervention.  This usage can be</font>
<font color="black"> 337. replaced as follows:</font>
<font color="black"> 338. </font>
<font color="black"> 339. (child_stdin, child_stdout) = os.popen2([&quot;/bin/ls&quot;, &quot;-l&quot;], mode,</font>
<font color="black"> 340.                                         bufsize)</font>
<font color="black"> 341. ==&gt;</font>
<font color="black"> 342. p = Popen([&quot;/bin/ls&quot;, &quot;-l&quot;], bufsize=bufsize, stdin=PIPE, stdout=PIPE)</font>
<font color="black"> 343. (child_stdin, child_stdout) = (p.stdin, p.stdout)</font>
<font color="black"> 344. </font>
<font color="black"> 345. Return code handling translates as follows:</font>
<font color="black"> 346. </font>
<font color="black"> 347. pipe = os.popen(&quot;cmd&quot;, 'w')</font>
<font color="black"> 348. ...</font>
<font color="black"> 349. rc = pipe.close()</font>
<font color="black"> 350. if rc is not None and rc % 256:</font>
<font color="black"> 351.     print &quot;There were some errors&quot;</font>
<font color="black"> 352. ==&gt;</font>
<font color="black"> 353. process = Popen(&quot;cmd&quot;, 'w', shell=True, stdin=PIPE)</font>
<font color="black"> 354. ...</font>
<font color="black"> 355. process.stdin.close()</font>
<font color="black"> 356. if process.wait() != 0:</font>
<font color="black"> 357.     print &quot;There were some errors&quot;</font>
<font color="black"> 358. </font>
<font color="black"> 359. </font>
<font color="black"> 360. Replacing popen2.*</font>
<font color="black"> 361. ------------------</font>
<font color="black"> 362. (child_stdout, child_stdin) = popen2.popen2(&quot;somestring&quot;, bufsize, mode)</font>
<font color="black"> 363. ==&gt;</font>
<font color="black"> 364. p = Popen([&quot;somestring&quot;], shell=True, bufsize=bufsize</font>
<font color="black"> 365.           stdin=PIPE, stdout=PIPE, close_fds=True)</font>
<font color="black"> 366. (child_stdout, child_stdin) = (p.stdout, p.stdin)</font>
<font color="black"> 367. </font>
<font color="black"> 368. On Unix, popen2 also accepts a sequence as the command to execute, in</font>
<font color="black"> 369. which case arguments will be passed directly to the program without</font>
<font color="black"> 370. shell intervention.  This usage can be replaced as follows:</font>
<font color="black"> 371. </font>
<font color="black"> 372. (child_stdout, child_stdin) = popen2.popen2([&quot;mycmd&quot;, &quot;myarg&quot;], bufsize,</font>
<font color="black"> 373.                                             mode)</font>
<font color="black"> 374. ==&gt;</font>
<font color="black"> 375. p = Popen([&quot;mycmd&quot;, &quot;myarg&quot;], bufsize=bufsize,</font>
<font color="black"> 376.           stdin=PIPE, stdout=PIPE, close_fds=True)</font>
<font color="black"> 377. (child_stdout, child_stdin) = (p.stdout, p.stdin)</font>
<font color="black"> 378. </font>
<font color="black"> 379. The popen2.Popen3 and popen2.Popen4 basically works as subprocess.Popen,</font>
<font color="black"> 380. except that:</font>
<font color="black"> 381. </font>
<font color="black"> 382. * subprocess.Popen raises an exception if the execution fails</font>
<font color="black"> 383. * the capturestderr argument is replaced with the stderr argument.</font>
<font color="black"> 384. * stdin=PIPE and stdout=PIPE must be specified.</font>
<font color="black"> 385. * popen2 closes all filedescriptors by default, but you have to specify</font>
<font color="black"> 386.   close_fds=True with subprocess.Popen.</font>
<font color="green"> 387. &quot;&quot;&quot;</font>
<font color="black"> 388. </font>
<font color="green"> 389. import sys</font>
<font color="green"> 390. mswindows = (sys.platform == &quot;win32&quot;)</font>
<font color="black"> 391. </font>
<font color="green"> 392. import os</font>
<font color="green"> 393. import types</font>
<font color="green"> 394. import traceback</font>
<font color="green"> 395. import gc</font>
<font color="green"> 396. import signal</font>
<font color="green"> 397. import errno</font>
<font color="black"> 398. </font>
<font color="black"> 399. # Exception classes used by this module.</font>
<font color="green"> 400. class CalledProcessError(Exception):</font>
<font color="black"> 401.     &quot;&quot;&quot;This exception is raised when a process run by check_call() or</font>
<font color="black"> 402.     check_output() returns a non-zero exit status.</font>
<font color="black"> 403.     The exit status will be stored in the returncode attribute;</font>
<font color="black"> 404.     check_output() will also store the output in the output attribute.</font>
<font color="green"> 405.     &quot;&quot;&quot;</font>
<font color="green"> 406.     def __init__(self, returncode, cmd, output=None):</font>
<font color="red"> 407.         self.returncode = returncode</font>
<font color="red"> 408.         self.cmd = cmd</font>
<font color="red"> 409.         self.output = output</font>
<font color="green"> 410.     def __str__(self):</font>
<font color="red"> 411.         return &quot;Command '%s' returned non-zero exit status %d&quot; % (self.cmd, self.returncode)</font>
<font color="black"> 412. </font>
<font color="black"> 413. </font>
<font color="green"> 414. if mswindows:</font>
<font color="red"> 415.     import threading</font>
<font color="red"> 416.     import msvcrt</font>
<font color="red"> 417.     import _subprocess</font>
<font color="red"> 418.     class STARTUPINFO:</font>
<font color="red"> 419.         dwFlags = 0</font>
<font color="red"> 420.         hStdInput = None</font>
<font color="red"> 421.         hStdOutput = None</font>
<font color="red"> 422.         hStdError = None</font>
<font color="red"> 423.         wShowWindow = 0</font>
<font color="red"> 424.     class pywintypes:</font>
<font color="red"> 425.         error = IOError</font>
<font color="black"> 426. else:</font>
<font color="green"> 427.     import select</font>
<font color="green"> 428.     _has_poll = hasattr(select, 'poll')</font>
<font color="green"> 429.     import fcntl</font>
<font color="green"> 430.     import pickle</font>
<font color="black"> 431. </font>
<font color="black"> 432.     # When select or poll has indicated that the file is writable,</font>
<font color="black"> 433.     # we can write up to _PIPE_BUF bytes without risk of blocking.</font>
<font color="black"> 434.     # POSIX defines PIPE_BUF as &gt;= 512.</font>
<font color="green"> 435.     _PIPE_BUF = getattr(select, 'PIPE_BUF', 512)</font>
<font color="black"> 436. </font>
<font color="black"> 437. </font>
<font color="green"> 438. __all__ = [&quot;Popen&quot;, &quot;PIPE&quot;, &quot;STDOUT&quot;, &quot;call&quot;, &quot;check_call&quot;,</font>
<font color="green"> 439.            &quot;check_output&quot;, &quot;CalledProcessError&quot;]</font>
<font color="black"> 440. </font>
<font color="green"> 441. if mswindows:</font>
<font color="red"> 442.     from _subprocess import (CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS_GROUP,</font>
<font color="black"> 443.                              STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,</font>
<font color="black"> 444.                              STD_ERROR_HANDLE, SW_HIDE,</font>
<font color="black"> 445.                              STARTF_USESTDHANDLES, STARTF_USESHOWWINDOW)</font>
<font color="black"> 446. </font>
<font color="red"> 447.     __all__.extend([&quot;CREATE_NEW_CONSOLE&quot;, &quot;CREATE_NEW_PROCESS_GROUP&quot;,</font>
<font color="red"> 448.                     &quot;STD_INPUT_HANDLE&quot;, &quot;STD_OUTPUT_HANDLE&quot;,</font>
<font color="red"> 449.                     &quot;STD_ERROR_HANDLE&quot;, &quot;SW_HIDE&quot;,</font>
<font color="red"> 450.                     &quot;STARTF_USESTDHANDLES&quot;, &quot;STARTF_USESHOWWINDOW&quot;])</font>
<font color="green"> 451. try:</font>
<font color="green"> 452.     MAXFD = os.sysconf(&quot;SC_OPEN_MAX&quot;)</font>
<font color="red"> 453. except:</font>
<font color="red"> 454.     MAXFD = 256</font>
<font color="black"> 455. </font>
<font color="green"> 456. _active = []</font>
<font color="black"> 457. </font>
<font color="green"> 458. def _cleanup():</font>
<font color="red"> 459.     for inst in _active[:]:</font>
<font color="red"> 460.         res = inst._internal_poll(_deadstate=sys.maxint)</font>
<font color="red"> 461.         if res is not None:</font>
<font color="red"> 462.             try:</font>
<font color="red"> 463.                 _active.remove(inst)</font>
<font color="red"> 464.             except ValueError:</font>
<font color="black"> 465.                 # This can happen if two threads create a new Popen instance.</font>
<font color="black"> 466.                 # It's harmless that it was already removed, so ignore.</font>
<font color="red"> 467.                 pass</font>
<font color="black"> 468. </font>
<font color="green"> 469. PIPE = -1</font>
<font color="green"> 470. STDOUT = -2</font>
<font color="black"> 471. </font>
<font color="black"> 472. </font>
<font color="green"> 473. def _eintr_retry_call(func, *args):</font>
<font color="red"> 474.     while True:</font>
<font color="red"> 475.         try:</font>
<font color="red"> 476.             return func(*args)</font>
<font color="red"> 477.         except (OSError, IOError) as e:</font>
<font color="red"> 478.             if e.errno == errno.EINTR:</font>
<font color="red"> 479.                 continue</font>
<font color="red"> 480.             raise</font>
<font color="black"> 481. </font>
<font color="black"> 482. </font>
<font color="black"> 483. # XXX This function is only used by multiprocessing and the test suite,</font>
<font color="black"> 484. # but it's here so that it can be imported when Python is compiled without</font>
<font color="black"> 485. # threads.</font>
<font color="black"> 486. </font>
<font color="green"> 487. def _args_from_interpreter_flags():</font>
<font color="black"> 488.     &quot;&quot;&quot;Return a list of command-line arguments reproducing the current</font>
<font color="black"> 489.     settings in sys.flags and sys.warnoptions.&quot;&quot;&quot;</font>
<font color="red"> 490.     flag_opt_map = {</font>
<font color="red"> 491.         'debug': 'd',</font>
<font color="black"> 492.         # 'inspect': 'i',</font>
<font color="black"> 493.         # 'interactive': 'i',</font>
<font color="red"> 494.         'optimize': 'O',</font>
<font color="red"> 495.         'dont_write_bytecode': 'B',</font>
<font color="red"> 496.         'no_user_site': 's',</font>
<font color="red"> 497.         'no_site': 'S',</font>
<font color="red"> 498.         'ignore_environment': 'E',</font>
<font color="red"> 499.         'verbose': 'v',</font>
<font color="red"> 500.         'bytes_warning': 'b',</font>
<font color="red"> 501.         'hash_randomization': 'R',</font>
<font color="red"> 502.         'py3k_warning': '3',</font>
<font color="black"> 503.     }</font>
<font color="red"> 504.     args = []</font>
<font color="red"> 505.     for flag, opt in flag_opt_map.items():</font>
<font color="red"> 506.         v = getattr(sys.flags, flag)</font>
<font color="red"> 507.         if v &gt; 0:</font>
<font color="red"> 508.             args.append('-' + opt * v)</font>
<font color="red"> 509.     for opt in sys.warnoptions:</font>
<font color="red"> 510.         args.append('-W' + opt)</font>
<font color="red"> 511.     return args</font>
<font color="black"> 512. </font>
<font color="black"> 513. </font>
<font color="green"> 514. def call(*popenargs, **kwargs):</font>
<font color="black"> 515.     &quot;&quot;&quot;Run command with arguments.  Wait for command to complete, then</font>
<font color="black"> 516.     return the returncode attribute.</font>
<font color="black"> 517. </font>
<font color="black"> 518.     The arguments are the same as for the Popen constructor.  Example:</font>
<font color="black"> 519. </font>
<font color="black"> 520.     retcode = call([&quot;ls&quot;, &quot;-l&quot;])</font>
<font color="black"> 521.     &quot;&quot;&quot;</font>
<font color="red"> 522.     return Popen(*popenargs, **kwargs).wait()</font>
<font color="black"> 523. </font>
<font color="black"> 524. </font>
<font color="green"> 525. def check_call(*popenargs, **kwargs):</font>
<font color="black"> 526.     &quot;&quot;&quot;Run command with arguments.  Wait for command to complete.  If</font>
<font color="black"> 527.     the exit code was zero then return, otherwise raise</font>
<font color="black"> 528.     CalledProcessError.  The CalledProcessError object will have the</font>
<font color="black"> 529.     return code in the returncode attribute.</font>
<font color="black"> 530. </font>
<font color="black"> 531.     The arguments are the same as for the Popen constructor.  Example:</font>
<font color="black"> 532. </font>
<font color="black"> 533.     check_call([&quot;ls&quot;, &quot;-l&quot;])</font>
<font color="black"> 534.     &quot;&quot;&quot;</font>
<font color="red"> 535.     retcode = call(*popenargs, **kwargs)</font>
<font color="red"> 536.     if retcode:</font>
<font color="red"> 537.         cmd = kwargs.get(&quot;args&quot;)</font>
<font color="red"> 538.         if cmd is None:</font>
<font color="red"> 539.             cmd = popenargs[0]</font>
<font color="red"> 540.         raise CalledProcessError(retcode, cmd)</font>
<font color="red"> 541.     return 0</font>
<font color="black"> 542. </font>
<font color="black"> 543. </font>
<font color="green"> 544. def check_output(*popenargs, **kwargs):</font>
<font color="black"> 545.     r&quot;&quot;&quot;Run command with arguments and return its output as a byte string.</font>
<font color="black"> 546. </font>
<font color="black"> 547.     If the exit code was non-zero it raises a CalledProcessError.  The</font>
<font color="black"> 548.     CalledProcessError object will have the return code in the returncode</font>
<font color="black"> 549.     attribute and output in the output attribute.</font>
<font color="black"> 550. </font>
<font color="black"> 551.     The arguments are the same as for the Popen constructor.  Example:</font>
<font color="black"> 552. </font>
<font color="black"> 553.     &gt;&gt;&gt; check_output([&quot;ls&quot;, &quot;-l&quot;, &quot;/dev/null&quot;])</font>
<font color="black"> 554.     'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'</font>
<font color="black"> 555. </font>
<font color="black"> 556.     The stdout argument is not allowed as it is used internally.</font>
<font color="black"> 557.     To capture standard error in the result, use stderr=STDOUT.</font>
<font color="black"> 558. </font>
<font color="black"> 559.     &gt;&gt;&gt; check_output([&quot;/bin/sh&quot;, &quot;-c&quot;,</font>
<font color="black"> 560.     ...               &quot;ls -l non_existent_file ; exit 0&quot;],</font>
<font color="black"> 561.     ...              stderr=STDOUT)</font>
<font color="black"> 562.     'ls: non_existent_file: No such file or directory\n'</font>
<font color="black"> 563.     &quot;&quot;&quot;</font>
<font color="red"> 564.     if 'stdout' in kwargs:</font>
<font color="red"> 565.         raise ValueError('stdout argument not allowed, it will be overridden.')</font>
<font color="red"> 566.     process = Popen(stdout=PIPE, *popenargs, **kwargs)</font>
<font color="red"> 567.     output, unused_err = process.communicate()</font>
<font color="red"> 568.     retcode = process.poll()</font>
<font color="red"> 569.     if retcode:</font>
<font color="red"> 570.         cmd = kwargs.get(&quot;args&quot;)</font>
<font color="red"> 571.         if cmd is None:</font>
<font color="red"> 572.             cmd = popenargs[0]</font>
<font color="red"> 573.         raise CalledProcessError(retcode, cmd, output=output)</font>
<font color="red"> 574.     return output</font>
<font color="black"> 575. </font>
<font color="black"> 576. </font>
<font color="green"> 577. def list2cmdline(seq):</font>
<font color="black"> 578.     &quot;&quot;&quot;</font>
<font color="black"> 579.     Translate a sequence of arguments into a command line</font>
<font color="black"> 580.     string, using the same rules as the MS C runtime:</font>
<font color="black"> 581. </font>
<font color="black"> 582.     1) Arguments are delimited by white space, which is either a</font>
<font color="black"> 583.        space or a tab.</font>
<font color="black"> 584. </font>
<font color="black"> 585.     2) A string surrounded by double quotation marks is</font>
<font color="black"> 586.        interpreted as a single argument, regardless of white space</font>
<font color="black"> 587.        contained within.  A quoted string can be embedded in an</font>
<font color="black"> 588.        argument.</font>
<font color="black"> 589. </font>
<font color="black"> 590.     3) A double quotation mark preceded by a backslash is</font>
<font color="black"> 591.        interpreted as a literal double quotation mark.</font>
<font color="black"> 592. </font>
<font color="black"> 593.     4) Backslashes are interpreted literally, unless they</font>
<font color="black"> 594.        immediately precede a double quotation mark.</font>
<font color="black"> 595. </font>
<font color="black"> 596.     5) If backslashes immediately precede a double quotation mark,</font>
<font color="black"> 597.        every pair of backslashes is interpreted as a literal</font>
<font color="black"> 598.        backslash.  If the number of backslashes is odd, the last</font>
<font color="black"> 599.        backslash escapes the next double quotation mark as</font>
<font color="black"> 600.        described in rule 3.</font>
<font color="black"> 601.     &quot;&quot;&quot;</font>
<font color="black"> 602. </font>
<font color="black"> 603.     # See</font>
<font color="black"> 604.     # http://msdn.microsoft.com/en-us/library/17w5ykft.aspx</font>
<font color="black"> 605.     # or search http://msdn.microsoft.com for</font>
<font color="black"> 606.     # &quot;Parsing C++ Command-Line Arguments&quot;</font>
<font color="red"> 607.     result = []</font>
<font color="red"> 608.     needquote = False</font>
<font color="red"> 609.     for arg in seq:</font>
<font color="red"> 610.         bs_buf = []</font>
<font color="black"> 611. </font>
<font color="black"> 612.         # Add a space to separate this argument from the others</font>
<font color="red"> 613.         if result:</font>
<font color="red"> 614.             result.append(' ')</font>
<font color="black"> 615. </font>
<font color="red"> 616.         needquote = (&quot; &quot; in arg) or (&quot;\t&quot; in arg) or not arg</font>
<font color="red"> 617.         if needquote:</font>
<font color="red"> 618.             result.append('&quot;')</font>
<font color="black"> 619. </font>
<font color="red"> 620.         for c in arg:</font>
<font color="red"> 621.             if c == '\\':</font>
<font color="black"> 622.                 # Don't know if we need to double yet.</font>
<font color="red"> 623.                 bs_buf.append(c)</font>
<font color="red"> 624.             elif c == '&quot;':</font>
<font color="black"> 625.                 # Double backslashes.</font>
<font color="red"> 626.                 result.append('\\' * len(bs_buf)*2)</font>
<font color="red"> 627.                 bs_buf = []</font>
<font color="red"> 628.                 result.append('\\&quot;')</font>
<font color="black"> 629.             else:</font>
<font color="black"> 630.                 # Normal char</font>
<font color="red"> 631.                 if bs_buf:</font>
<font color="red"> 632.                     result.extend(bs_buf)</font>
<font color="red"> 633.                     bs_buf = []</font>
<font color="red"> 634.                 result.append(c)</font>
<font color="black"> 635. </font>
<font color="black"> 636.         # Add remaining backslashes, if any.</font>
<font color="red"> 637.         if bs_buf:</font>
<font color="red"> 638.             result.extend(bs_buf)</font>
<font color="black"> 639. </font>
<font color="red"> 640.         if needquote:</font>
<font color="red"> 641.             result.extend(bs_buf)</font>
<font color="red"> 642.             result.append('&quot;')</font>
<font color="black"> 643. </font>
<font color="red"> 644.     return ''.join(result)</font>
<font color="black"> 645. </font>
<font color="black"> 646. </font>
<font color="green"> 647. class Popen(object):</font>
<font color="green"> 648.     _child_created = False  # Set here since __del__ checks it</font>
<font color="black"> 649. </font>
<font color="green"> 650.     def __init__(self, args, bufsize=0, executable=None,</font>
<font color="green"> 651.                  stdin=None, stdout=None, stderr=None,</font>
<font color="green"> 652.                  preexec_fn=None, close_fds=False, shell=False,</font>
<font color="green"> 653.                  cwd=None, env=None, universal_newlines=False,</font>
<font color="green"> 654.                  startupinfo=None, creationflags=0):</font>
<font color="black"> 655.         &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;</font>
<font color="red"> 656.         _cleanup()</font>
<font color="black"> 657. </font>
<font color="red"> 658.         if not isinstance(bufsize, (int, long)):</font>
<font color="red"> 659.             raise TypeError(&quot;bufsize must be an integer&quot;)</font>
<font color="black"> 660. </font>
<font color="red"> 661.         if mswindows:</font>
<font color="red"> 662.             if preexec_fn is not None:</font>
<font color="red"> 663.                 raise ValueError(&quot;preexec_fn is not supported on Windows &quot;</font>
<font color="black"> 664.                                  &quot;platforms&quot;)</font>
<font color="red"> 665.             if close_fds and (stdin is not None or stdout is not None or</font>
<font color="red"> 666.                               stderr is not None):</font>
<font color="red"> 667.                 raise ValueError(&quot;close_fds is not supported on Windows &quot;</font>
<font color="black"> 668.                                  &quot;platforms if you redirect stdin/stdout/stderr&quot;)</font>
<font color="black"> 669.         else:</font>
<font color="black"> 670.             # POSIX</font>
<font color="red"> 671.             if startupinfo is not None:</font>
<font color="red"> 672.                 raise ValueError(&quot;startupinfo is only supported on Windows &quot;</font>
<font color="black"> 673.                                  &quot;platforms&quot;)</font>
<font color="red"> 674.             if creationflags != 0:</font>
<font color="red"> 675.                 raise ValueError(&quot;creationflags is only supported on Windows &quot;</font>
<font color="black"> 676.                                  &quot;platforms&quot;)</font>
<font color="black"> 677. </font>
<font color="red"> 678.         self.stdin = None</font>
<font color="red"> 679.         self.stdout = None</font>
<font color="red"> 680.         self.stderr = None</font>
<font color="red"> 681.         self.pid = None</font>
<font color="red"> 682.         self.returncode = None</font>
<font color="red"> 683.         self.universal_newlines = universal_newlines</font>
<font color="black"> 684. </font>
<font color="black"> 685.         # Input and output objects. The general principle is like</font>
<font color="black"> 686.         # this:</font>
<font color="black"> 687.         #</font>
<font color="black"> 688.         # Parent                   Child</font>
<font color="black"> 689.         # ------                   -----</font>
<font color="black"> 690.         # p2cwrite   ---stdin---&gt;  p2cread</font>
<font color="black"> 691.         # c2pread    &lt;--stdout---  c2pwrite</font>
<font color="black"> 692.         # errread    &lt;--stderr---  errwrite</font>
<font color="black"> 693.         #</font>
<font color="black"> 694.         # On POSIX, the child objects are file descriptors.  On</font>
<font color="black"> 695.         # Windows, these are Windows file handles.  The parent objects</font>
<font color="black"> 696.         # are file descriptors on both platforms.  The parent objects</font>
<font color="black"> 697.         # are None when not using PIPEs. The child objects are None</font>
<font color="black"> 698.         # when not redirecting.</font>
<font color="black"> 699. </font>
<font color="black"> 700.         (p2cread, p2cwrite,</font>
<font color="black"> 701.          c2pread, c2pwrite,</font>
<font color="red"> 702.          errread, errwrite), to_close = self._get_handles(stdin, stdout, stderr)</font>
<font color="black"> 703. </font>
<font color="red"> 704.         try:</font>
<font color="red"> 705.             self._execute_child(args, executable, preexec_fn, close_fds,</font>
<font color="red"> 706.                                 cwd, env, universal_newlines,</font>
<font color="red"> 707.                                 startupinfo, creationflags, shell, to_close,</font>
<font color="red"> 708.                                 p2cread, p2cwrite,</font>
<font color="red"> 709.                                 c2pread, c2pwrite,</font>
<font color="red"> 710.                                 errread, errwrite)</font>
<font color="red"> 711.         except Exception:</font>
<font color="black"> 712.             # Preserve original exception in case os.close raises.</font>
<font color="red"> 713.             exc_type, exc_value, exc_trace = sys.exc_info()</font>
<font color="black"> 714. </font>
<font color="red"> 715.             for fd in to_close:</font>
<font color="red"> 716.                 try:</font>
<font color="red"> 717.                     if mswindows:</font>
<font color="red"> 718.                         fd.Close()</font>
<font color="black"> 719.                     else:</font>
<font color="red"> 720.                         os.close(fd)</font>
<font color="red"> 721.                 except EnvironmentError:</font>
<font color="red"> 722.                     pass</font>
<font color="black"> 723. </font>
<font color="red"> 724.             raise exc_type, exc_value, exc_trace</font>
<font color="black"> 725. </font>
<font color="red"> 726.         if mswindows:</font>
<font color="red"> 727.             if p2cwrite is not None:</font>
<font color="red"> 728.                 p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)</font>
<font color="red"> 729.             if c2pread is not None:</font>
<font color="red"> 730.                 c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)</font>
<font color="red"> 731.             if errread is not None:</font>
<font color="red"> 732.                 errread = msvcrt.open_osfhandle(errread.Detach(), 0)</font>
<font color="black"> 733. </font>
<font color="red"> 734.         if p2cwrite is not None:</font>
<font color="red"> 735.             self.stdin = os.fdopen(p2cwrite, 'wb', bufsize)</font>
<font color="red"> 736.         if c2pread is not None:</font>
<font color="red"> 737.             if universal_newlines:</font>
<font color="red"> 738.                 self.stdout = os.fdopen(c2pread, 'rU', bufsize)</font>
<font color="black"> 739.             else:</font>
<font color="red"> 740.                 self.stdout = os.fdopen(c2pread, 'rb', bufsize)</font>
<font color="red"> 741.         if errread is not None:</font>
<font color="red"> 742.             if universal_newlines:</font>
<font color="red"> 743.                 self.stderr = os.fdopen(errread, 'rU', bufsize)</font>
<font color="black"> 744.             else:</font>
<font color="red"> 745.                 self.stderr = os.fdopen(errread, 'rb', bufsize)</font>
<font color="black"> 746. </font>
<font color="black"> 747. </font>
<font color="green"> 748.     def _translate_newlines(self, data):</font>
<font color="red"> 749.         data = data.replace(&quot;\r\n&quot;, &quot;\n&quot;)</font>
<font color="red"> 750.         data = data.replace(&quot;\r&quot;, &quot;\n&quot;)</font>
<font color="red"> 751.         return data</font>
<font color="black"> 752. </font>
<font color="black"> 753. </font>
<font color="green"> 754.     def __del__(self, _maxint=sys.maxint):</font>
<font color="black"> 755.         # If __init__ hasn't had a chance to execute (e.g. if it</font>
<font color="black"> 756.         # was passed an undeclared keyword argument), we don't</font>
<font color="black"> 757.         # have a _child_created attribute at all.</font>
<font color="red"> 758.         if not self._child_created:</font>
<font color="black"> 759.             # We didn't get to successfully create a child process.</font>
<font color="red"> 760.             return</font>
<font color="black"> 761.         # In case the child hasn't been waited on, check if it's done.</font>
<font color="red"> 762.         self._internal_poll(_deadstate=_maxint)</font>
<font color="red"> 763.         if self.returncode is None and _active is not None:</font>
<font color="black"> 764.             # Child is still running, keep us alive until we can wait on it.</font>
<font color="red"> 765.             _active.append(self)</font>
<font color="black"> 766. </font>
<font color="black"> 767. </font>
<font color="green"> 768.     def communicate(self, input=None):</font>
<font color="black"> 769.         &quot;&quot;&quot;Interact with process: Send data to stdin.  Read data from</font>
<font color="black"> 770.         stdout and stderr, until end-of-file is reached.  Wait for</font>
<font color="black"> 771.         process to terminate.  The optional input argument should be a</font>
<font color="black"> 772.         string to be sent to the child process, or None, if no data</font>
<font color="black"> 773.         should be sent to the child.</font>
<font color="black"> 774. </font>
<font color="black"> 775.         communicate() returns a tuple (stdout, stderr).&quot;&quot;&quot;</font>
<font color="black"> 776. </font>
<font color="black"> 777.         # Optimization: If we are only using one pipe, or no pipe at</font>
<font color="black"> 778.         # all, using select() or threads is unnecessary.</font>
<font color="red"> 779.         if [self.stdin, self.stdout, self.stderr].count(None) &gt;= 2:</font>
<font color="red"> 780.             stdout = None</font>
<font color="red"> 781.             stderr = None</font>
<font color="red"> 782.             if self.stdin:</font>
<font color="red"> 783.                 if input:</font>
<font color="red"> 784.                     try:</font>
<font color="red"> 785.                         self.stdin.write(input)</font>
<font color="red"> 786.                     except IOError as e:</font>
<font color="red"> 787.                         if e.errno != errno.EPIPE and e.errno != errno.EINVAL:</font>
<font color="red"> 788.                             raise</font>
<font color="red"> 789.                 self.stdin.close()</font>
<font color="red"> 790.             elif self.stdout:</font>
<font color="red"> 791.                 stdout = _eintr_retry_call(self.stdout.read)</font>
<font color="red"> 792.                 self.stdout.close()</font>
<font color="red"> 793.             elif self.stderr:</font>
<font color="red"> 794.                 stderr = _eintr_retry_call(self.stderr.read)</font>
<font color="red"> 795.                 self.stderr.close()</font>
<font color="red"> 796.             self.wait()</font>
<font color="red"> 797.             return (stdout, stderr)</font>
<font color="black"> 798. </font>
<font color="red"> 799.         return self._communicate(input)</font>
<font color="black"> 800. </font>
<font color="black"> 801. </font>
<font color="green"> 802.     def poll(self):</font>
<font color="red"> 803.         return self._internal_poll()</font>
<font color="black"> 804. </font>
<font color="black"> 805. </font>
<font color="green"> 806.     if mswindows:</font>
<font color="black"> 807.         #</font>
<font color="black"> 808.         # Windows methods</font>
<font color="black"> 809.         #</font>
<font color="red"> 810.         def _get_handles(self, stdin, stdout, stderr):</font>
<font color="black"> 811.             &quot;&quot;&quot;Construct and return tuple with IO objects:</font>
<font color="black"> 812.             p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite</font>
<font color="black"> 813.             &quot;&quot;&quot;</font>
<font color="red"> 814.             to_close = set()</font>
<font color="red"> 815.             if stdin is None and stdout is None and stderr is None:</font>
<font color="red"> 816.                 return (None, None, None, None, None, None), to_close</font>
<font color="black"> 817. </font>
<font color="red"> 818.             p2cread, p2cwrite = None, None</font>
<font color="red"> 819.             c2pread, c2pwrite = None, None</font>
<font color="red"> 820.             errread, errwrite = None, None</font>
<font color="black"> 821. </font>
<font color="red"> 822.             if stdin is None:</font>
<font color="red"> 823.                 p2cread = _subprocess.GetStdHandle(_subprocess.STD_INPUT_HANDLE)</font>
<font color="red"> 824.                 if p2cread is None:</font>
<font color="red"> 825.                     p2cread, _ = _subprocess.CreatePipe(None, 0)</font>
<font color="red"> 826.             elif stdin == PIPE:</font>
<font color="red"> 827.                 p2cread, p2cwrite = _subprocess.CreatePipe(None, 0)</font>
<font color="red"> 828.             elif isinstance(stdin, int):</font>
<font color="red"> 829.                 p2cread = msvcrt.get_osfhandle(stdin)</font>
<font color="black"> 830.             else:</font>
<font color="black"> 831.                 # Assuming file-like object</font>
<font color="red"> 832.                 p2cread = msvcrt.get_osfhandle(stdin.fileno())</font>
<font color="red"> 833.             p2cread = self._make_inheritable(p2cread)</font>
<font color="black"> 834.             # We just duplicated the handle, it has to be closed at the end</font>
<font color="red"> 835.             to_close.add(p2cread)</font>
<font color="red"> 836.             if stdin == PIPE:</font>
<font color="red"> 837.                 to_close.add(p2cwrite)</font>
<font color="black"> 838. </font>
<font color="red"> 839.             if stdout is None:</font>
<font color="red"> 840.                 c2pwrite = _subprocess.GetStdHandle(_subprocess.STD_OUTPUT_HANDLE)</font>
<font color="red"> 841.                 if c2pwrite is None:</font>
<font color="red"> 842.                     _, c2pwrite = _subprocess.CreatePipe(None, 0)</font>
<font color="red"> 843.             elif stdout == PIPE:</font>
<font color="red"> 844.                 c2pread, c2pwrite = _subprocess.CreatePipe(None, 0)</font>
<font color="red"> 845.             elif isinstance(stdout, int):</font>
<font color="red"> 846.                 c2pwrite = msvcrt.get_osfhandle(stdout)</font>
<font color="black"> 847.             else:</font>
<font color="black"> 848.                 # Assuming file-like object</font>
<font color="red"> 849.                 c2pwrite = msvcrt.get_osfhandle(stdout.fileno())</font>
<font color="red"> 850.             c2pwrite = self._make_inheritable(c2pwrite)</font>
<font color="black"> 851.             # We just duplicated the handle, it has to be closed at the end</font>
<font color="red"> 852.             to_close.add(c2pwrite)</font>
<font color="red"> 853.             if stdout == PIPE:</font>
<font color="red"> 854.                 to_close.add(c2pread)</font>
<font color="black"> 855. </font>
<font color="red"> 856.             if stderr is None:</font>
<font color="red"> 857.                 errwrite = _subprocess.GetStdHandle(_subprocess.STD_ERROR_HANDLE)</font>
<font color="red"> 858.                 if errwrite is None:</font>
<font color="red"> 859.                     _, errwrite = _subprocess.CreatePipe(None, 0)</font>
<font color="red"> 860.             elif stderr == PIPE:</font>
<font color="red"> 861.                 errread, errwrite = _subprocess.CreatePipe(None, 0)</font>
<font color="red"> 862.             elif stderr == STDOUT:</font>
<font color="red"> 863.                 errwrite = c2pwrite</font>
<font color="red"> 864.             elif isinstance(stderr, int):</font>
<font color="red"> 865.                 errwrite = msvcrt.get_osfhandle(stderr)</font>
<font color="black"> 866.             else:</font>
<font color="black"> 867.                 # Assuming file-like object</font>
<font color="red"> 868.                 errwrite = msvcrt.get_osfhandle(stderr.fileno())</font>
<font color="red"> 869.             errwrite = self._make_inheritable(errwrite)</font>
<font color="black"> 870.             # We just duplicated the handle, it has to be closed at the end</font>
<font color="red"> 871.             to_close.add(errwrite)</font>
<font color="red"> 872.             if stderr == PIPE:</font>
<font color="red"> 873.                 to_close.add(errread)</font>
<font color="black"> 874. </font>
<font color="red"> 875.             return (p2cread, p2cwrite,</font>
<font color="red"> 876.                     c2pread, c2pwrite,</font>
<font color="red"> 877.                     errread, errwrite), to_close</font>
<font color="black"> 878. </font>
<font color="black"> 879. </font>
<font color="red"> 880.         def _make_inheritable(self, handle):</font>
<font color="black"> 881.             &quot;&quot;&quot;Return a duplicate of handle, which is inheritable&quot;&quot;&quot;</font>
<font color="red"> 882.             return _subprocess.DuplicateHandle(_subprocess.GetCurrentProcess(),</font>
<font color="red"> 883.                                 handle, _subprocess.GetCurrentProcess(), 0, 1,</font>
<font color="red"> 884.                                 _subprocess.DUPLICATE_SAME_ACCESS)</font>
<font color="black"> 885. </font>
<font color="black"> 886. </font>
<font color="red"> 887.         def _find_w9xpopen(self):</font>
<font color="black"> 888.             &quot;&quot;&quot;Find and return absolut path to w9xpopen.exe&quot;&quot;&quot;</font>
<font color="red"> 889.             w9xpopen = os.path.join(</font>
<font color="red"> 890.                             os.path.dirname(_subprocess.GetModuleFileName(0)),</font>
<font color="red"> 891.                                     &quot;w9xpopen.exe&quot;)</font>
<font color="red"> 892.             if not os.path.exists(w9xpopen):</font>
<font color="black"> 893.                 # Eeek - file-not-found - possibly an embedding</font>
<font color="black"> 894.                 # situation - see if we can locate it in sys.exec_prefix</font>
<font color="red"> 895.                 w9xpopen = os.path.join(os.path.dirname(sys.exec_prefix),</font>
<font color="red"> 896.                                         &quot;w9xpopen.exe&quot;)</font>
<font color="red"> 897.                 if not os.path.exists(w9xpopen):</font>
<font color="red"> 898.                     raise RuntimeError(&quot;Cannot locate w9xpopen.exe, which is &quot;</font>
<font color="black"> 899.                                        &quot;needed for Popen to work with your &quot;</font>
<font color="black"> 900.                                        &quot;shell or platform.&quot;)</font>
<font color="red"> 901.             return w9xpopen</font>
<font color="black"> 902. </font>
<font color="black"> 903. </font>
<font color="red"> 904.         def _execute_child(self, args, executable, preexec_fn, close_fds,</font>
<font color="black"> 905.                            cwd, env, universal_newlines,</font>
<font color="black"> 906.                            startupinfo, creationflags, shell, to_close,</font>
<font color="black"> 907.                            p2cread, p2cwrite,</font>
<font color="black"> 908.                            c2pread, c2pwrite,</font>
<font color="black"> 909.                            errread, errwrite):</font>
<font color="black"> 910.             &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;</font>
<font color="black"> 911. </font>
<font color="red"> 912.             if not isinstance(args, types.StringTypes):</font>
<font color="red"> 913.                 args = list2cmdline(args)</font>
<font color="black"> 914. </font>
<font color="black"> 915.             # Process startup details</font>
<font color="red"> 916.             if startupinfo is None:</font>
<font color="red"> 917.                 startupinfo = STARTUPINFO()</font>
<font color="red"> 918.             if None not in (p2cread, c2pwrite, errwrite):</font>
<font color="red"> 919.                 startupinfo.dwFlags |= _subprocess.STARTF_USESTDHANDLES</font>
<font color="red"> 920.                 startupinfo.hStdInput = p2cread</font>
<font color="red"> 921.                 startupinfo.hStdOutput = c2pwrite</font>
<font color="red"> 922.                 startupinfo.hStdError = errwrite</font>
<font color="black"> 923. </font>
<font color="red"> 924.             if shell:</font>
<font color="red"> 925.                 startupinfo.dwFlags |= _subprocess.STARTF_USESHOWWINDOW</font>
<font color="red"> 926.                 startupinfo.wShowWindow = _subprocess.SW_HIDE</font>
<font color="red"> 927.                 comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)</font>
<font color="red"> 928.                 args = '{} /c &quot;{}&quot;'.format (comspec, args)</font>
<font color="red"> 929.                 if (_subprocess.GetVersion() &gt;= 0x80000000 or</font>
<font color="red"> 930.                         os.path.basename(comspec).lower() == &quot;command.com&quot;):</font>
<font color="black"> 931.                     # Win9x, or using command.com on NT. We need to</font>
<font color="black"> 932.                     # use the w9xpopen intermediate program. For more</font>
<font color="black"> 933.                     # information, see KB Q150956</font>
<font color="black"> 934.                     # (http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp)</font>
<font color="red"> 935.                     w9xpopen = self._find_w9xpopen()</font>
<font color="red"> 936.                     args = '&quot;%s&quot; %s' % (w9xpopen, args)</font>
<font color="black"> 937.                     # Not passing CREATE_NEW_CONSOLE has been known to</font>
<font color="black"> 938.                     # cause random failures on win9x.  Specifically a</font>
<font color="black"> 939.                     # dialog: &quot;Your program accessed mem currently in</font>
<font color="black"> 940.                     # use at xxx&quot; and a hopeful warning about the</font>
<font color="black"> 941.                     # stability of your system.  Cost is Ctrl+C wont</font>
<font color="black"> 942.                     # kill children.</font>
<font color="red"> 943.                     creationflags |= _subprocess.CREATE_NEW_CONSOLE</font>
<font color="black"> 944. </font>
<font color="red"> 945.             def _close_in_parent(fd):</font>
<font color="red"> 946.                 fd.Close()</font>
<font color="red"> 947.                 to_close.remove(fd)</font>
<font color="black"> 948. </font>
<font color="black"> 949.             # Start the process</font>
<font color="red"> 950.             try:</font>
<font color="red"> 951.                 hp, ht, pid, tid = _subprocess.CreateProcess(executable, args,</font>
<font color="black"> 952.                                          # no special security</font>
<font color="red"> 953.                                          None, None,</font>
<font color="red"> 954.                                          int(not close_fds),</font>
<font color="red"> 955.                                          creationflags,</font>
<font color="red"> 956.                                          env,</font>
<font color="red"> 957.                                          cwd,</font>
<font color="red"> 958.                                          startupinfo)</font>
<font color="red"> 959.             except pywintypes.error, e:</font>
<font color="black"> 960.                 # Translate pywintypes.error to WindowsError, which is</font>
<font color="black"> 961.                 # a subclass of OSError.  FIXME: We should really</font>
<font color="black"> 962.                 # translate errno using _sys_errlist (or similar), but</font>
<font color="black"> 963.                 # how can this be done from Python?</font>
<font color="red"> 964.                 raise WindowsError(*e.args)</font>
<font color="black"> 965.             finally:</font>
<font color="black"> 966.                 # Child is launched. Close the parent's copy of those pipe</font>
<font color="black"> 967.                 # handles that only the child should have open.  You need</font>
<font color="black"> 968.                 # to make sure that no handles to the write end of the</font>
<font color="black"> 969.                 # output pipe are maintained in this process or else the</font>
<font color="black"> 970.                 # pipe will not close when the child process exits and the</font>
<font color="black"> 971.                 # ReadFile will hang.</font>
<font color="red"> 972.                 if p2cread is not None:</font>
<font color="red"> 973.                     _close_in_parent(p2cread)</font>
<font color="red"> 974.                 if c2pwrite is not None:</font>
<font color="red"> 975.                     _close_in_parent(c2pwrite)</font>
<font color="red"> 976.                 if errwrite is not None:</font>
<font color="red"> 977.                     _close_in_parent(errwrite)</font>
<font color="black"> 978. </font>
<font color="black"> 979.             # Retain the process handle, but close the thread handle</font>
<font color="red"> 980.             self._child_created = True</font>
<font color="red"> 981.             self._handle = hp</font>
<font color="red"> 982.             self.pid = pid</font>
<font color="red"> 983.             ht.Close()</font>
<font color="black"> 984. </font>
<font color="red"> 985.         def _internal_poll(self, _deadstate=None,</font>
<font color="red"> 986.                 _WaitForSingleObject=_subprocess.WaitForSingleObject,</font>
<font color="red"> 987.                 _WAIT_OBJECT_0=_subprocess.WAIT_OBJECT_0,</font>
<font color="red"> 988.                 _GetExitCodeProcess=_subprocess.GetExitCodeProcess):</font>
<font color="black"> 989.             &quot;&quot;&quot;Check if child process has terminated.  Returns returncode</font>
<font color="black"> 990.             attribute.</font>
<font color="black"> 991. </font>
<font color="black"> 992.             This method is called by __del__, so it can only refer to objects</font>
<font color="black"> 993.             in its local scope.</font>
<font color="black"> 994. </font>
<font color="black"> 995.             &quot;&quot;&quot;</font>
<font color="red"> 996.             if self.returncode is None:</font>
<font color="red"> 997.                 if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:</font>
<font color="red"> 998.                     self.returncode = _GetExitCodeProcess(self._handle)</font>
<font color="red"> 999.             return self.returncode</font>
<font color="black">1000. </font>
<font color="black">1001. </font>
<font color="red">1002.         def wait(self):</font>
<font color="black">1003.             &quot;&quot;&quot;Wait for child process to terminate.  Returns returncode</font>
<font color="black">1004.             attribute.&quot;&quot;&quot;</font>
<font color="red">1005.             if self.returncode is None:</font>
<font color="red">1006.                 _subprocess.WaitForSingleObject(self._handle,</font>
<font color="red">1007.                                                 _subprocess.INFINITE)</font>
<font color="red">1008.                 self.returncode = _subprocess.GetExitCodeProcess(self._handle)</font>
<font color="red">1009.             return self.returncode</font>
<font color="black">1010. </font>
<font color="black">1011. </font>
<font color="red">1012.         def _readerthread(self, fh, buffer):</font>
<font color="red">1013.             buffer.append(fh.read())</font>
<font color="black">1014. </font>
<font color="black">1015. </font>
<font color="red">1016.         def _communicate(self, input):</font>
<font color="red">1017.             stdout = None # Return</font>
<font color="red">1018.             stderr = None # Return</font>
<font color="black">1019. </font>
<font color="red">1020.             if self.stdout:</font>
<font color="red">1021.                 stdout = []</font>
<font color="red">1022.                 stdout_thread = threading.Thread(target=self._readerthread,</font>
<font color="red">1023.                                                  args=(self.stdout, stdout))</font>
<font color="red">1024.                 stdout_thread.setDaemon(True)</font>
<font color="red">1025.                 stdout_thread.start()</font>
<font color="red">1026.             if self.stderr:</font>
<font color="red">1027.                 stderr = []</font>
<font color="red">1028.                 stderr_thread = threading.Thread(target=self._readerthread,</font>
<font color="red">1029.                                                  args=(self.stderr, stderr))</font>
<font color="red">1030.                 stderr_thread.setDaemon(True)</font>
<font color="red">1031.                 stderr_thread.start()</font>
<font color="black">1032. </font>
<font color="red">1033.             if self.stdin:</font>
<font color="red">1034.                 if input is not None:</font>
<font color="red">1035.                     try:</font>
<font color="red">1036.                         self.stdin.write(input)</font>
<font color="red">1037.                     except IOError as e:</font>
<font color="red">1038.                         if e.errno != errno.EPIPE:</font>
<font color="red">1039.                             raise</font>
<font color="red">1040.                 self.stdin.close()</font>
<font color="black">1041. </font>
<font color="red">1042.             if self.stdout:</font>
<font color="red">1043.                 stdout_thread.join()</font>
<font color="red">1044.             if self.stderr:</font>
<font color="red">1045.                 stderr_thread.join()</font>
<font color="black">1046. </font>
<font color="black">1047.             # All data exchanged.  Translate lists into strings.</font>
<font color="red">1048.             if stdout is not None:</font>
<font color="red">1049.                 stdout = stdout[0]</font>
<font color="red">1050.             if stderr is not None:</font>
<font color="red">1051.                 stderr = stderr[0]</font>
<font color="black">1052. </font>
<font color="black">1053.             # Translate newlines, if requested.  We cannot let the file</font>
<font color="black">1054.             # object do the translation: It is based on stdio, which is</font>
<font color="black">1055.             # impossible to combine with select (unless forcing no</font>
<font color="black">1056.             # buffering).</font>
<font color="red">1057.             if self.universal_newlines and hasattr(file, 'newlines'):</font>
<font color="red">1058.                 if stdout:</font>
<font color="red">1059.                     stdout = self._translate_newlines(stdout)</font>
<font color="red">1060.                 if stderr:</font>
<font color="red">1061.                     stderr = self._translate_newlines(stderr)</font>
<font color="black">1062. </font>
<font color="red">1063.             self.wait()</font>
<font color="red">1064.             return (stdout, stderr)</font>
<font color="black">1065. </font>
<font color="red">1066.         def send_signal(self, sig):</font>
<font color="black">1067.             &quot;&quot;&quot;Send a signal to the process</font>
<font color="black">1068.             &quot;&quot;&quot;</font>
<font color="red">1069.             if sig == signal.SIGTERM:</font>
<font color="red">1070.                 self.terminate()</font>
<font color="red">1071.             elif sig == signal.CTRL_C_EVENT:</font>
<font color="red">1072.                 os.kill(self.pid, signal.CTRL_C_EVENT)</font>
<font color="red">1073.             elif sig == signal.CTRL_BREAK_EVENT:</font>
<font color="red">1074.                 os.kill(self.pid, signal.CTRL_BREAK_EVENT)</font>
<font color="black">1075.             else:</font>
<font color="red">1076.                 raise ValueError(&quot;Unsupported signal: {}&quot;.format(sig))</font>
<font color="black">1077. </font>
<font color="red">1078.         def terminate(self):</font>
<font color="black">1079.             &quot;&quot;&quot;Terminates the process</font>
<font color="black">1080.             &quot;&quot;&quot;</font>
<font color="red">1081.             try:</font>
<font color="red">1082.                 _subprocess.TerminateProcess(self._handle, 1)</font>
<font color="red">1083.             except OSError as e:</font>
<font color="black">1084.                 # ERROR_ACCESS_DENIED (winerror 5) is received when the</font>
<font color="black">1085.                 # process already died.</font>
<font color="red">1086.                 if e.winerror != 5:</font>
<font color="red">1087.                     raise</font>
<font color="red">1088.                 rc = _subprocess.GetExitCodeProcess(self._handle)</font>
<font color="red">1089.                 if rc == _subprocess.STILL_ACTIVE:</font>
<font color="red">1090.                     raise</font>
<font color="red">1091.                 self.returncode = rc</font>
<font color="black">1092. </font>
<font color="red">1093.         kill = terminate</font>
<font color="black">1094. </font>
<font color="black">1095.     else:</font>
<font color="black">1096.         #</font>
<font color="black">1097.         # POSIX methods</font>
<font color="black">1098.         #</font>
<font color="green">1099.         def _get_handles(self, stdin, stdout, stderr):</font>
<font color="black">1100.             &quot;&quot;&quot;Construct and return tuple with IO objects:</font>
<font color="black">1101.             p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite</font>
<font color="black">1102.             &quot;&quot;&quot;</font>
<font color="red">1103.             to_close = set()</font>
<font color="red">1104.             p2cread, p2cwrite = None, None</font>
<font color="red">1105.             c2pread, c2pwrite = None, None</font>
<font color="red">1106.             errread, errwrite = None, None</font>
<font color="black">1107. </font>
<font color="red">1108.             if stdin is None:</font>
<font color="red">1109.                 pass</font>
<font color="red">1110.             elif stdin == PIPE:</font>
<font color="red">1111.                 p2cread, p2cwrite = self.pipe_cloexec()</font>
<font color="red">1112.                 to_close.update((p2cread, p2cwrite))</font>
<font color="red">1113.             elif isinstance(stdin, int):</font>
<font color="red">1114.                 p2cread = stdin</font>
<font color="black">1115.             else:</font>
<font color="black">1116.                 # Assuming file-like object</font>
<font color="red">1117.                 p2cread = stdin.fileno()</font>
<font color="black">1118. </font>
<font color="red">1119.             if stdout is None:</font>
<font color="red">1120.                 pass</font>
<font color="red">1121.             elif stdout == PIPE:</font>
<font color="red">1122.                 c2pread, c2pwrite = self.pipe_cloexec()</font>
<font color="red">1123.                 to_close.update((c2pread, c2pwrite))</font>
<font color="red">1124.             elif isinstance(stdout, int):</font>
<font color="red">1125.                 c2pwrite = stdout</font>
<font color="black">1126.             else:</font>
<font color="black">1127.                 # Assuming file-like object</font>
<font color="red">1128.                 c2pwrite = stdout.fileno()</font>
<font color="black">1129. </font>
<font color="red">1130.             if stderr is None:</font>
<font color="red">1131.                 pass</font>
<font color="red">1132.             elif stderr == PIPE:</font>
<font color="red">1133.                 errread, errwrite = self.pipe_cloexec()</font>
<font color="red">1134.                 to_close.update((errread, errwrite))</font>
<font color="red">1135.             elif stderr == STDOUT:</font>
<font color="red">1136.                 errwrite = c2pwrite</font>
<font color="red">1137.             elif isinstance(stderr, int):</font>
<font color="red">1138.                 errwrite = stderr</font>
<font color="black">1139.             else:</font>
<font color="black">1140.                 # Assuming file-like object</font>
<font color="red">1141.                 errwrite = stderr.fileno()</font>
<font color="black">1142. </font>
<font color="red">1143.             return (p2cread, p2cwrite,</font>
<font color="red">1144.                     c2pread, c2pwrite,</font>
<font color="red">1145.                     errread, errwrite), to_close</font>
<font color="black">1146. </font>
<font color="black">1147. </font>
<font color="green">1148.         def _set_cloexec_flag(self, fd, cloexec=True):</font>
<font color="red">1149.             try:</font>
<font color="red">1150.                 cloexec_flag = fcntl.FD_CLOEXEC</font>
<font color="red">1151.             except AttributeError:</font>
<font color="red">1152.                 cloexec_flag = 1</font>
<font color="black">1153. </font>
<font color="red">1154.             old = fcntl.fcntl(fd, fcntl.F_GETFD)</font>
<font color="red">1155.             if cloexec:</font>
<font color="red">1156.                 fcntl.fcntl(fd, fcntl.F_SETFD, old | cloexec_flag)</font>
<font color="black">1157.             else:</font>
<font color="red">1158.                 fcntl.fcntl(fd, fcntl.F_SETFD, old &amp; ~cloexec_flag)</font>
<font color="black">1159. </font>
<font color="black">1160. </font>
<font color="green">1161.         def pipe_cloexec(self):</font>
<font color="black">1162.             &quot;&quot;&quot;Create a pipe with FDs set CLOEXEC.&quot;&quot;&quot;</font>
<font color="black">1163.             # Pipes' FDs are set CLOEXEC by default because we don't want them</font>
<font color="black">1164.             # to be inherited by other subprocesses: the CLOEXEC flag is removed</font>
<font color="black">1165.             # from the child's FDs by _dup2(), between fork() and exec().</font>
<font color="black">1166.             # This is not atomic: we would need the pipe2() syscall for that.</font>
<font color="red">1167.             r, w = os.pipe()</font>
<font color="red">1168.             self._set_cloexec_flag(r)</font>
<font color="red">1169.             self._set_cloexec_flag(w)</font>
<font color="red">1170.             return r, w</font>
<font color="black">1171. </font>
<font color="black">1172. </font>
<font color="green">1173.         def _close_fds(self, but):</font>
<font color="red">1174.             if hasattr(os, 'closerange'):</font>
<font color="red">1175.                 os.closerange(3, but)</font>
<font color="red">1176.                 os.closerange(but + 1, MAXFD)</font>
<font color="black">1177.             else:</font>
<font color="red">1178.                 for i in xrange(3, MAXFD):</font>
<font color="red">1179.                     if i == but:</font>
<font color="red">1180.                         continue</font>
<font color="red">1181.                     try:</font>
<font color="red">1182.                         os.close(i)</font>
<font color="red">1183.                     except:</font>
<font color="red">1184.                         pass</font>
<font color="black">1185. </font>
<font color="black">1186. </font>
<font color="green">1187.         def _execute_child(self, args, executable, preexec_fn, close_fds,</font>
<font color="black">1188.                            cwd, env, universal_newlines,</font>
<font color="black">1189.                            startupinfo, creationflags, shell, to_close,</font>
<font color="black">1190.                            p2cread, p2cwrite,</font>
<font color="black">1191.                            c2pread, c2pwrite,</font>
<font color="black">1192.                            errread, errwrite):</font>
<font color="black">1193.             &quot;&quot;&quot;Execute program (POSIX version)&quot;&quot;&quot;</font>
<font color="black">1194. </font>
<font color="red">1195.             if isinstance(args, types.StringTypes):</font>
<font color="red">1196.                 args = [args]</font>
<font color="black">1197.             else:</font>
<font color="red">1198.                 args = list(args)</font>
<font color="black">1199. </font>
<font color="red">1200.             if shell:</font>
<font color="red">1201.                 args = [&quot;/bin/sh&quot;, &quot;-c&quot;] + args</font>
<font color="red">1202.                 if executable:</font>
<font color="red">1203.                     args[0] = executable</font>
<font color="black">1204. </font>
<font color="red">1205.             if executable is None:</font>
<font color="red">1206.                 executable = args[0]</font>
<font color="black">1207. </font>
<font color="red">1208.             def _close_in_parent(fd):</font>
<font color="red">1209.                 os.close(fd)</font>
<font color="red">1210.                 to_close.remove(fd)</font>
<font color="black">1211. </font>
<font color="black">1212.             # For transferring possible exec failure from child to parent</font>
<font color="black">1213.             # The first char specifies the exception type: 0 means</font>
<font color="black">1214.             # OSError, 1 means some other error.</font>
<font color="red">1215.             errpipe_read, errpipe_write = self.pipe_cloexec()</font>
<font color="red">1216.             try:</font>
<font color="red">1217.                 try:</font>
<font color="red">1218.                     gc_was_enabled = gc.isenabled()</font>
<font color="black">1219.                     # Disable gc to avoid bug where gc -&gt; file_dealloc -&gt;</font>
<font color="black">1220.                     # write to stderr -&gt; hang.  http://bugs.python.org/issue1336</font>
<font color="red">1221.                     gc.disable()</font>
<font color="red">1222.                     try:</font>
<font color="red">1223.                         self.pid = os.fork()</font>
<font color="red">1224.                     except:</font>
<font color="red">1225.                         if gc_was_enabled:</font>
<font color="red">1226.                             gc.enable()</font>
<font color="red">1227.                         raise</font>
<font color="red">1228.                     self._child_created = True</font>
<font color="red">1229.                     if self.pid == 0:</font>
<font color="black">1230.                         # Child</font>
<font color="red">1231.                         try:</font>
<font color="black">1232.                             # Close parent's pipe ends</font>
<font color="red">1233.                             if p2cwrite is not None:</font>
<font color="red">1234.                                 os.close(p2cwrite)</font>
<font color="red">1235.                             if c2pread is not None:</font>
<font color="red">1236.                                 os.close(c2pread)</font>
<font color="red">1237.                             if errread is not None:</font>
<font color="red">1238.                                 os.close(errread)</font>
<font color="red">1239.                             os.close(errpipe_read)</font>
<font color="black">1240. </font>
<font color="black">1241.                             # When duping fds, if there arises a situation</font>
<font color="black">1242.                             # where one of the fds is either 0, 1 or 2, it</font>
<font color="black">1243.                             # is possible that it is overwritten (#12607).</font>
<font color="red">1244.                             if c2pwrite == 0:</font>
<font color="red">1245.                                 c2pwrite = os.dup(c2pwrite)</font>
<font color="red">1246.                             if errwrite == 0 or errwrite == 1:</font>
<font color="red">1247.                                 errwrite = os.dup(errwrite)</font>
<font color="black">1248. </font>
<font color="black">1249.                             # Dup fds for child</font>
<font color="red">1250.                             def _dup2(a, b):</font>
<font color="black">1251.                                 # dup2() removes the CLOEXEC flag but</font>
<font color="black">1252.                                 # we must do it ourselves if dup2()</font>
<font color="black">1253.                                 # would be a no-op (issue #10806).</font>
<font color="red">1254.                                 if a == b:</font>
<font color="red">1255.                                     self._set_cloexec_flag(a, False)</font>
<font color="red">1256.                                 elif a is not None:</font>
<font color="red">1257.                                     os.dup2(a, b)</font>
<font color="red">1258.                             _dup2(p2cread, 0)</font>
<font color="red">1259.                             _dup2(c2pwrite, 1)</font>
<font color="red">1260.                             _dup2(errwrite, 2)</font>
<font color="black">1261. </font>
<font color="black">1262.                             # Close pipe fds.  Make sure we don't close the</font>
<font color="black">1263.                             # same fd more than once, or standard fds.</font>
<font color="red">1264.                             closed = { None }</font>
<font color="red">1265.                             for fd in [p2cread, c2pwrite, errwrite]:</font>
<font color="red">1266.                                 if fd not in closed and fd &gt; 2:</font>
<font color="red">1267.                                     os.close(fd)</font>
<font color="red">1268.                                     closed.add(fd)</font>
<font color="black">1269. </font>
<font color="red">1270.                             if cwd is not None:</font>
<font color="red">1271.                                 os.chdir(cwd)</font>
<font color="black">1272. </font>
<font color="red">1273.                             if preexec_fn:</font>
<font color="red">1274.                                 preexec_fn()</font>
<font color="black">1275. </font>
<font color="black">1276.                             # Close all other fds, if asked for - after</font>
<font color="black">1277.                             # preexec_fn(), which may open FDs.</font>
<font color="red">1278.                             if close_fds:</font>
<font color="red">1279.                                 self._close_fds(but=errpipe_write)</font>
<font color="black">1280. </font>
<font color="red">1281.                             if env is None:</font>
<font color="red">1282.                                 os.execvp(executable, args)</font>
<font color="black">1283.                             else:</font>
<font color="red">1284.                                 os.execvpe(executable, args, env)</font>
<font color="black">1285. </font>
<font color="red">1286.                         except:</font>
<font color="red">1287.                             exc_type, exc_value, tb = sys.exc_info()</font>
<font color="black">1288.                             # Save the traceback and attach it to the exception object</font>
<font color="red">1289.                             exc_lines = traceback.format_exception(exc_type,</font>
<font color="red">1290.                                                                    exc_value,</font>
<font color="red">1291.                                                                    tb)</font>
<font color="red">1292.                             exc_value.child_traceback = ''.join(exc_lines)</font>
<font color="red">1293.                             os.write(errpipe_write, pickle.dumps(exc_value))</font>
<font color="black">1294. </font>
<font color="black">1295.                         # This exitcode won't be reported to applications, so it</font>
<font color="black">1296.                         # really doesn't matter what we return.</font>
<font color="red">1297.                         os._exit(255)</font>
<font color="black">1298. </font>
<font color="black">1299.                     # Parent</font>
<font color="red">1300.                     if gc_was_enabled:</font>
<font color="red">1301.                         gc.enable()</font>
<font color="black">1302.                 finally:</font>
<font color="black">1303.                     # be sure the FD is closed no matter what</font>
<font color="red">1304.                     os.close(errpipe_write)</font>
<font color="black">1305. </font>
<font color="black">1306.                 # Wait for exec to fail or succeed; possibly raising exception</font>
<font color="black">1307.                 # Exception limited to 1M</font>
<font color="red">1308.                 data = _eintr_retry_call(os.read, errpipe_read, 1048576)</font>
<font color="black">1309.             finally:</font>
<font color="red">1310.                 if p2cread is not None and p2cwrite is not None:</font>
<font color="red">1311.                     _close_in_parent(p2cread)</font>
<font color="red">1312.                 if c2pwrite is not None and c2pread is not None:</font>
<font color="red">1313.                     _close_in_parent(c2pwrite)</font>
<font color="red">1314.                 if errwrite is not None and errread is not None:</font>
<font color="red">1315.                     _close_in_parent(errwrite)</font>
<font color="black">1316. </font>
<font color="black">1317.                 # be sure the FD is closed no matter what</font>
<font color="red">1318.                 os.close(errpipe_read)</font>
<font color="black">1319. </font>
<font color="red">1320.             if data != &quot;&quot;:</font>
<font color="red">1321.                 try:</font>
<font color="red">1322.                     _eintr_retry_call(os.waitpid, self.pid, 0)</font>
<font color="red">1323.                 except OSError as e:</font>
<font color="red">1324.                     if e.errno != errno.ECHILD:</font>
<font color="red">1325.                         raise</font>
<font color="red">1326.                 child_exception = pickle.loads(data)</font>
<font color="red">1327.                 raise child_exception</font>
<font color="black">1328. </font>
<font color="black">1329. </font>
<font color="green">1330.         def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,</font>
<font color="green">1331.                 _WTERMSIG=os.WTERMSIG, _WIFEXITED=os.WIFEXITED,</font>
<font color="green">1332.                 _WEXITSTATUS=os.WEXITSTATUS):</font>
<font color="black">1333.             # This method is called (indirectly) by __del__, so it cannot</font>
<font color="black">1334.             # refer to anything outside of its local scope.</font>
<font color="red">1335.             if _WIFSIGNALED(sts):</font>
<font color="red">1336.                 self.returncode = -_WTERMSIG(sts)</font>
<font color="red">1337.             elif _WIFEXITED(sts):</font>
<font color="red">1338.                 self.returncode = _WEXITSTATUS(sts)</font>
<font color="black">1339.             else:</font>
<font color="black">1340.                 # Should never happen</font>
<font color="red">1341.                 raise RuntimeError(&quot;Unknown child exit status!&quot;)</font>
<font color="black">1342. </font>
<font color="black">1343. </font>
<font color="green">1344.         def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,</font>
<font color="green">1345.                 _WNOHANG=os.WNOHANG, _os_error=os.error, _ECHILD=errno.ECHILD):</font>
<font color="black">1346.             &quot;&quot;&quot;Check if child process has terminated.  Returns returncode</font>
<font color="black">1347.             attribute.</font>
<font color="black">1348. </font>
<font color="black">1349.             This method is called by __del__, so it cannot reference anything</font>
<font color="black">1350.             outside of the local scope (nor can any methods it calls).</font>
<font color="black">1351. </font>
<font color="black">1352.             &quot;&quot;&quot;</font>
<font color="red">1353.             if self.returncode is None:</font>
<font color="red">1354.                 try:</font>
<font color="red">1355.                     pid, sts = _waitpid(self.pid, _WNOHANG)</font>
<font color="red">1356.                     if pid == self.pid:</font>
<font color="red">1357.                         self._handle_exitstatus(sts)</font>
<font color="red">1358.                 except _os_error as e:</font>
<font color="red">1359.                     if _deadstate is not None:</font>
<font color="red">1360.                         self.returncode = _deadstate</font>
<font color="red">1361.                     if e.errno == _ECHILD:</font>
<font color="black">1362.                         # This happens if SIGCLD is set to be ignored or</font>
<font color="black">1363.                         # waiting for child processes has otherwise been</font>
<font color="black">1364.                         # disabled for our process.  This child is dead, we</font>
<font color="black">1365.                         # can't get the status.</font>
<font color="black">1366.                         # http://bugs.python.org/issue15756</font>
<font color="red">1367.                         self.returncode = 0</font>
<font color="red">1368.             return self.returncode</font>
<font color="black">1369. </font>
<font color="black">1370. </font>
<font color="green">1371.         def wait(self):</font>
<font color="black">1372.             &quot;&quot;&quot;Wait for child process to terminate.  Returns returncode</font>
<font color="black">1373.             attribute.&quot;&quot;&quot;</font>
<font color="red">1374.             while self.returncode is None:</font>
<font color="red">1375.                 try:</font>
<font color="red">1376.                     pid, sts = _eintr_retry_call(os.waitpid, self.pid, 0)</font>
<font color="red">1377.                 except OSError as e:</font>
<font color="red">1378.                     if e.errno != errno.ECHILD:</font>
<font color="red">1379.                         raise</font>
<font color="black">1380.                     # This happens if SIGCLD is set to be ignored or waiting</font>
<font color="black">1381.                     # for child processes has otherwise been disabled for our</font>
<font color="black">1382.                     # process.  This child is dead, we can't get the status.</font>
<font color="red">1383.                     pid = self.pid</font>
<font color="red">1384.                     sts = 0</font>
<font color="black">1385.                 # Check the pid and loop as waitpid has been known to return</font>
<font color="black">1386.                 # 0 even without WNOHANG in odd situations.  issue14396.</font>
<font color="red">1387.                 if pid == self.pid:</font>
<font color="red">1388.                     self._handle_exitstatus(sts)</font>
<font color="red">1389.             return self.returncode</font>
<font color="black">1390. </font>
<font color="black">1391. </font>
<font color="green">1392.         def _communicate(self, input):</font>
<font color="red">1393.             if self.stdin:</font>
<font color="black">1394.                 # Flush stdio buffer.  This might block, if the user has</font>
<font color="black">1395.                 # been writing to .stdin in an uncontrolled fashion.</font>
<font color="red">1396.                 self.stdin.flush()</font>
<font color="red">1397.                 if not input:</font>
<font color="red">1398.                     self.stdin.close()</font>
<font color="black">1399. </font>
<font color="red">1400.             if _has_poll:</font>
<font color="red">1401.                 stdout, stderr = self._communicate_with_poll(input)</font>
<font color="black">1402.             else:</font>
<font color="red">1403.                 stdout, stderr = self._communicate_with_select(input)</font>
<font color="black">1404. </font>
<font color="black">1405.             # All data exchanged.  Translate lists into strings.</font>
<font color="red">1406.             if stdout is not None:</font>
<font color="red">1407.                 stdout = ''.join(stdout)</font>
<font color="red">1408.             if stderr is not None:</font>
<font color="red">1409.                 stderr = ''.join(stderr)</font>
<font color="black">1410. </font>
<font color="black">1411.             # Translate newlines, if requested.  We cannot let the file</font>
<font color="black">1412.             # object do the translation: It is based on stdio, which is</font>
<font color="black">1413.             # impossible to combine with select (unless forcing no</font>
<font color="black">1414.             # buffering).</font>
<font color="red">1415.             if self.universal_newlines and hasattr(file, 'newlines'):</font>
<font color="red">1416.                 if stdout:</font>
<font color="red">1417.                     stdout = self._translate_newlines(stdout)</font>
<font color="red">1418.                 if stderr:</font>
<font color="red">1419.                     stderr = self._translate_newlines(stderr)</font>
<font color="black">1420. </font>
<font color="red">1421.             self.wait()</font>
<font color="red">1422.             return (stdout, stderr)</font>
<font color="black">1423. </font>
<font color="black">1424. </font>
<font color="green">1425.         def _communicate_with_poll(self, input):</font>
<font color="red">1426.             stdout = None # Return</font>
<font color="red">1427.             stderr = None # Return</font>
<font color="red">1428.             fd2file = {}</font>
<font color="red">1429.             fd2output = {}</font>
<font color="black">1430. </font>
<font color="red">1431.             poller = select.poll()</font>
<font color="red">1432.             def register_and_append(file_obj, eventmask):</font>
<font color="red">1433.                 poller.register(file_obj.fileno(), eventmask)</font>
<font color="red">1434.                 fd2file[file_obj.fileno()] = file_obj</font>
<font color="black">1435. </font>
<font color="red">1436.             def close_unregister_and_remove(fd):</font>
<font color="red">1437.                 poller.unregister(fd)</font>
<font color="red">1438.                 fd2file[fd].close()</font>
<font color="red">1439.                 fd2file.pop(fd)</font>
<font color="black">1440. </font>
<font color="red">1441.             if self.stdin and input:</font>
<font color="red">1442.                 register_and_append(self.stdin, select.POLLOUT)</font>
<font color="black">1443. </font>
<font color="red">1444.             select_POLLIN_POLLPRI = select.POLLIN | select.POLLPRI</font>
<font color="red">1445.             if self.stdout:</font>
<font color="red">1446.                 register_and_append(self.stdout, select_POLLIN_POLLPRI)</font>
<font color="red">1447.                 fd2output[self.stdout.fileno()] = stdout = []</font>
<font color="red">1448.             if self.stderr:</font>
<font color="red">1449.                 register_and_append(self.stderr, select_POLLIN_POLLPRI)</font>
<font color="red">1450.                 fd2output[self.stderr.fileno()] = stderr = []</font>
<font color="black">1451. </font>
<font color="red">1452.             input_offset = 0</font>
<font color="red">1453.             while fd2file:</font>
<font color="red">1454.                 try:</font>
<font color="red">1455.                     ready = poller.poll()</font>
<font color="red">1456.                 except select.error, e:</font>
<font color="red">1457.                     if e.args[0] == errno.EINTR:</font>
<font color="red">1458.                         continue</font>
<font color="red">1459.                     raise</font>
<font color="black">1460. </font>
<font color="red">1461.                 for fd, mode in ready:</font>
<font color="red">1462.                     if mode &amp; select.POLLOUT:</font>
<font color="red">1463.                         chunk = input[input_offset : input_offset + _PIPE_BUF]</font>
<font color="red">1464.                         try:</font>
<font color="red">1465.                             input_offset += os.write(fd, chunk)</font>
<font color="red">1466.                         except OSError as e:</font>
<font color="red">1467.                             if e.errno == errno.EPIPE:</font>
<font color="red">1468.                                 close_unregister_and_remove(fd)</font>
<font color="black">1469.                             else:</font>
<font color="red">1470.                                 raise</font>
<font color="black">1471.                         else:</font>
<font color="red">1472.                             if input_offset &gt;= len(input):</font>
<font color="red">1473.                                 close_unregister_and_remove(fd)</font>
<font color="red">1474.                     elif mode &amp; select_POLLIN_POLLPRI:</font>
<font color="red">1475.                         data = os.read(fd, 4096)</font>
<font color="red">1476.                         if not data:</font>
<font color="red">1477.                             close_unregister_and_remove(fd)</font>
<font color="red">1478.                         fd2output[fd].append(data)</font>
<font color="black">1479.                     else:</font>
<font color="black">1480.                         # Ignore hang up or errors.</font>
<font color="red">1481.                         close_unregister_and_remove(fd)</font>
<font color="black">1482. </font>
<font color="red">1483.             return (stdout, stderr)</font>
<font color="black">1484. </font>
<font color="black">1485. </font>
<font color="green">1486.         def _communicate_with_select(self, input):</font>
<font color="red">1487.             read_set = []</font>
<font color="red">1488.             write_set = []</font>
<font color="red">1489.             stdout = None # Return</font>
<font color="red">1490.             stderr = None # Return</font>
<font color="black">1491. </font>
<font color="red">1492.             if self.stdin and input:</font>
<font color="red">1493.                 write_set.append(self.stdin)</font>
<font color="red">1494.             if self.stdout:</font>
<font color="red">1495.                 read_set.append(self.stdout)</font>
<font color="red">1496.                 stdout = []</font>
<font color="red">1497.             if self.stderr:</font>
<font color="red">1498.                 read_set.append(self.stderr)</font>
<font color="red">1499.                 stderr = []</font>
<font color="black">1500. </font>
<font color="red">1501.             input_offset = 0</font>
<font color="red">1502.             while read_set or write_set:</font>
<font color="red">1503.                 try:</font>
<font color="red">1504.                     rlist, wlist, xlist = select.select(read_set, write_set, [])</font>
<font color="red">1505.                 except select.error, e:</font>
<font color="red">1506.                     if e.args[0] == errno.EINTR:</font>
<font color="red">1507.                         continue</font>
<font color="red">1508.                     raise</font>
<font color="black">1509. </font>
<font color="red">1510.                 if self.stdin in wlist:</font>
<font color="red">1511.                     chunk = input[input_offset : input_offset + _PIPE_BUF]</font>
<font color="red">1512.                     try:</font>
<font color="red">1513.                         bytes_written = os.write(self.stdin.fileno(), chunk)</font>
<font color="red">1514.                     except OSError as e:</font>
<font color="red">1515.                         if e.errno == errno.EPIPE:</font>
<font color="red">1516.                             self.stdin.close()</font>
<font color="red">1517.                             write_set.remove(self.stdin)</font>
<font color="black">1518.                         else:</font>
<font color="red">1519.                             raise</font>
<font color="black">1520.                     else:</font>
<font color="red">1521.                         input_offset += bytes_written</font>
<font color="red">1522.                         if input_offset &gt;= len(input):</font>
<font color="red">1523.                             self.stdin.close()</font>
<font color="red">1524.                             write_set.remove(self.stdin)</font>
<font color="black">1525. </font>
<font color="red">1526.                 if self.stdout in rlist:</font>
<font color="red">1527.                     data = os.read(self.stdout.fileno(), 1024)</font>
<font color="red">1528.                     if data == &quot;&quot;:</font>
<font color="red">1529.                         self.stdout.close()</font>
<font color="red">1530.                         read_set.remove(self.stdout)</font>
<font color="red">1531.                     stdout.append(data)</font>
<font color="black">1532. </font>
<font color="red">1533.                 if self.stderr in rlist:</font>
<font color="red">1534.                     data = os.read(self.stderr.fileno(), 1024)</font>
<font color="red">1535.                     if data == &quot;&quot;:</font>
<font color="red">1536.                         self.stderr.close()</font>
<font color="red">1537.                         read_set.remove(self.stderr)</font>
<font color="red">1538.                     stderr.append(data)</font>
<font color="black">1539. </font>
<font color="red">1540.             return (stdout, stderr)</font>
<font color="black">1541. </font>
<font color="black">1542. </font>
<font color="green">1543.         def send_signal(self, sig):</font>
<font color="black">1544.             &quot;&quot;&quot;Send a signal to the process</font>
<font color="black">1545.             &quot;&quot;&quot;</font>
<font color="red">1546.             os.kill(self.pid, sig)</font>
<font color="black">1547. </font>
<font color="green">1548.         def terminate(self):</font>
<font color="black">1549.             &quot;&quot;&quot;Terminate the process with SIGTERM</font>
<font color="black">1550.             &quot;&quot;&quot;</font>
<font color="red">1551.             self.send_signal(signal.SIGTERM)</font>
<font color="black">1552. </font>
<font color="green">1553.         def kill(self):</font>
<font color="black">1554.             &quot;&quot;&quot;Kill the process with SIGKILL</font>
<font color="black">1555.             &quot;&quot;&quot;</font>
<font color="red">1556.             self.send_signal(signal.SIGKILL)</font>
<font color="black">1557. </font>
<font color="black">1558. </font>
<font color="green">1559. def _demo_posix():</font>
<font color="black">1560.     #</font>
<font color="black">1561.     # Example 1: Simple redirection: Get process list</font>
<font color="black">1562.     #</font>
<font color="red">1563.     plist = Popen([&quot;ps&quot;], stdout=PIPE).communicate()[0]</font>
<font color="red">1564.     print &quot;Process list:&quot;</font>
<font color="red">1565.     print plist</font>
<font color="black">1566. </font>
<font color="black">1567.     #</font>
<font color="black">1568.     # Example 2: Change uid before executing child</font>
<font color="black">1569.     #</font>
<font color="red">1570.     if os.getuid() == 0:</font>
<font color="red">1571.         p = Popen([&quot;id&quot;], preexec_fn=lambda: os.setuid(100))</font>
<font color="red">1572.         p.wait()</font>
<font color="black">1573. </font>
<font color="black">1574.     #</font>
<font color="black">1575.     # Example 3: Connecting several subprocesses</font>
<font color="black">1576.     #</font>
<font color="red">1577.     print &quot;Looking for 'hda'...&quot;</font>
<font color="red">1578.     p1 = Popen([&quot;dmesg&quot;], stdout=PIPE)</font>
<font color="red">1579.     p2 = Popen([&quot;grep&quot;, &quot;hda&quot;], stdin=p1.stdout, stdout=PIPE)</font>
<font color="red">1580.     print repr(p2.communicate()[0])</font>
<font color="black">1581. </font>
<font color="black">1582.     #</font>
<font color="black">1583.     # Example 4: Catch execution error</font>
<font color="black">1584.     #</font>
<font color="red">1585.     print</font>
<font color="red">1586.     print &quot;Trying a weird file...&quot;</font>
<font color="red">1587.     try:</font>
<font color="red">1588.         print Popen([&quot;/this/path/does/not/exist&quot;]).communicate()</font>
<font color="red">1589.     except OSError, e:</font>
<font color="red">1590.         if e.errno == errno.ENOENT:</font>
<font color="red">1591.             print &quot;The file didn't exist.  I thought so...&quot;</font>
<font color="red">1592.             print &quot;Child traceback:&quot;</font>
<font color="red">1593.             print e.child_traceback</font>
<font color="black">1594.         else:</font>
<font color="red">1595.             print &quot;Error&quot;, e.errno</font>
<font color="black">1596.     else:</font>
<font color="red">1597.         print &gt;&gt;sys.stderr, &quot;Gosh.  No error.&quot;</font>
<font color="black">1598. </font>
<font color="black">1599. </font>
<font color="green">1600. def _demo_windows():</font>
<font color="black">1601.     #</font>
<font color="black">1602.     # Example 1: Connecting several subprocesses</font>
<font color="black">1603.     #</font>
<font color="red">1604.     print &quot;Looking for 'PROMPT' in set output...&quot;</font>
<font color="red">1605.     p1 = Popen(&quot;set&quot;, stdout=PIPE, shell=True)</font>
<font color="red">1606.     p2 = Popen('find &quot;PROMPT&quot;', stdin=p1.stdout, stdout=PIPE)</font>
<font color="red">1607.     print repr(p2.communicate()[0])</font>
<font color="black">1608. </font>
<font color="black">1609.     #</font>
<font color="black">1610.     # Example 2: Simple execution of program</font>
<font color="black">1611.     #</font>
<font color="red">1612.     print &quot;Executing calc...&quot;</font>
<font color="red">1613.     p = Popen(&quot;calc&quot;)</font>
<font color="red">1614.     p.wait()</font>
<font color="black">1615. </font>
<font color="black">1616. </font>
<font color="green">1617. if __name__ == &quot;__main__&quot;:</font>
<font color="red">1618.     if mswindows:</font>
<font color="red">1619.         _demo_windows()</font>
<font color="black">1620.     else:</font>
<font color="red">1621.         _demo_posix()</font>
</pre>

