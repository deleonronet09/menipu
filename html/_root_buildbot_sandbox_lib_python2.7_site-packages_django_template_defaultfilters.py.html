source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/template/defaultfilters.py</b><br>


file stats: <b>475 lines, 132 executed: 27.8% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Default variable filters.&quot;&quot;&quot;</font>
<font color="green">   2. from __future__ import unicode_literals</font>
<font color="black">   3. </font>
<font color="green">   4. import random as random_module</font>
<font color="green">   5. import re</font>
<font color="green">   6. import warnings</font>
<font color="green">   7. from decimal import ROUND_HALF_UP, Context, Decimal, InvalidOperation</font>
<font color="green">   8. from functools import wraps</font>
<font color="green">   9. from pprint import pformat</font>
<font color="black">  10. </font>
<font color="green">  11. from django.conf import settings</font>
<font color="green">  12. from django.utils import formats, six</font>
<font color="green">  13. from django.utils.dateformat import format, time_format</font>
<font color="green">  14. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  15. from django.utils.encoding import force_text, iri_to_uri</font>
<font color="green">  16. from django.utils.html import (</font>
<font color="black">  17.     avoid_wrapping, conditional_escape, escape, escapejs, linebreaks,</font>
<font color="black">  18.     remove_tags, strip_tags, urlize as _urlize,</font>
<font color="black">  19. )</font>
<font color="green">  20. from django.utils.http import urlquote</font>
<font color="green">  21. from django.utils.safestring import SafeData, mark_for_escaping, mark_safe</font>
<font color="green">  22. from django.utils.text import (</font>
<font color="black">  23.     Truncator, normalize_newlines, phone2numeric, slugify as _slugify, wrap,</font>
<font color="black">  24. )</font>
<font color="green">  25. from django.utils.timesince import timesince, timeuntil</font>
<font color="green">  26. from django.utils.translation import ugettext, ungettext</font>
<font color="black">  27. </font>
<font color="green">  28. from .base import Variable, VariableDoesNotExist</font>
<font color="green">  29. from .library import Library</font>
<font color="black">  30. </font>
<font color="green">  31. register = Library()</font>
<font color="black">  32. </font>
<font color="black">  33. </font>
<font color="black">  34. #######################</font>
<font color="black">  35. # STRING DECORATOR    #</font>
<font color="black">  36. #######################</font>
<font color="black">  37. </font>
<font color="green">  38. def stringfilter(func):</font>
<font color="black">  39.     &quot;&quot;&quot;</font>
<font color="black">  40.     Decorator for filters which should only receive unicode objects. The object</font>
<font color="black">  41.     passed as the first positional argument will be converted to a unicode</font>
<font color="black">  42.     object.</font>
<font color="black">  43.     &quot;&quot;&quot;</font>
<font color="green">  44.     def _dec(*args, **kwargs):</font>
<font color="red">  45.         if args:</font>
<font color="red">  46.             args = list(args)</font>
<font color="red">  47.             args[0] = force_text(args[0])</font>
<font color="red">  48.             if (isinstance(args[0], SafeData) and</font>
<font color="red">  49.                     getattr(_dec._decorated_function, 'is_safe', False)):</font>
<font color="red">  50.                 return mark_safe(func(*args, **kwargs))</font>
<font color="red">  51.         return func(*args, **kwargs)</font>
<font color="black">  52. </font>
<font color="black">  53.     # Include a reference to the real function (used to check original</font>
<font color="black">  54.     # arguments by the template parser, and to bear the 'is_safe' attribute</font>
<font color="black">  55.     # when multiple decorators are applied).</font>
<font color="green">  56.     _dec._decorated_function = getattr(func, '_decorated_function', func)</font>
<font color="black">  57. </font>
<font color="green">  58.     return wraps(func)(_dec)</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="black">  61. ###################</font>
<font color="black">  62. # STRINGS         #</font>
<font color="black">  63. ###################</font>
<font color="black">  64. </font>
<font color="green">  65. @register.filter(is_safe=True)</font>
<font color="green">  66. @stringfilter</font>
<font color="black">  67. def addslashes(value):</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="black">  69.     Adds slashes before quotes. Useful for escaping strings in CSV, for</font>
<font color="black">  70.     example. Less useful for escaping JavaScript; use the ``escapejs``</font>
<font color="black">  71.     filter instead.</font>
<font color="black">  72.     &quot;&quot;&quot;</font>
<font color="red">  73.     return value.replace('\\', '\\\\').replace('&quot;', '\\&quot;').replace(&quot;'&quot;, &quot;\\'&quot;)</font>
<font color="black">  74. </font>
<font color="black">  75. </font>
<font color="green">  76. @register.filter(is_safe=True)</font>
<font color="green">  77. @stringfilter</font>
<font color="black">  78. def capfirst(value):</font>
<font color="black">  79.     &quot;&quot;&quot;Capitalizes the first character of the value.&quot;&quot;&quot;</font>
<font color="red">  80.     return value and value[0].upper() + value[1:]</font>
<font color="black">  81. </font>
<font color="black">  82. </font>
<font color="green">  83. @register.filter(&quot;escapejs&quot;)</font>
<font color="green">  84. @stringfilter</font>
<font color="black">  85. def escapejs_filter(value):</font>
<font color="black">  86.     &quot;&quot;&quot;Hex encodes characters for use in JavaScript strings.&quot;&quot;&quot;</font>
<font color="red">  87.     return escapejs(value)</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="black">  90. # Values for testing floatformat input against infinity and NaN representations,</font>
<font color="black">  91. # which differ across platforms and Python versions.  Some (i.e. old Windows</font>
<font color="black">  92. # ones) are not recognized by Decimal but we want to return them unchanged vs.</font>
<font color="black">  93. # returning an empty string as we do for completely invalid input.  Note these</font>
<font color="black">  94. # need to be built up from values that are not inf/nan, since inf/nan values do</font>
<font color="black">  95. # not reload properly from .pyc files on Windows prior to some level of Python 2.5</font>
<font color="black">  96. # (see Python Issue757815 and Issue1080440).</font>
<font color="green">  97. pos_inf = 1e200 * 1e200</font>
<font color="green">  98. neg_inf = -1e200 * 1e200</font>
<font color="green">  99. nan = (1e200 * 1e200) // (1e200 * 1e200)</font>
<font color="green"> 100. special_floats = [str(pos_inf), str(neg_inf), str(nan)]</font>
<font color="black"> 101. </font>
<font color="black"> 102. </font>
<font color="green"> 103. @register.filter(is_safe=True)</font>
<font color="green"> 104. def floatformat(text, arg=-1):</font>
<font color="black"> 105.     &quot;&quot;&quot;</font>
<font color="black"> 106.     Displays a float to a specified number of decimal places.</font>
<font color="black"> 107. </font>
<font color="black"> 108.     If called without an argument, it displays the floating point number with</font>
<font color="black"> 109.     one decimal place -- but only if there's a decimal place to be displayed:</font>
<font color="black"> 110. </font>
<font color="black"> 111.     * num1 = 34.23234</font>
<font color="black"> 112.     * num2 = 34.00000</font>
<font color="black"> 113.     * num3 = 34.26000</font>
<font color="black"> 114.     * {{ num1|floatformat }} displays &quot;34.2&quot;</font>
<font color="black"> 115.     * {{ num2|floatformat }} displays &quot;34&quot;</font>
<font color="black"> 116.     * {{ num3|floatformat }} displays &quot;34.3&quot;</font>
<font color="black"> 117. </font>
<font color="black"> 118.     If arg is positive, it will always display exactly arg number of decimal</font>
<font color="black"> 119.     places:</font>
<font color="black"> 120. </font>
<font color="black"> 121.     * {{ num1|floatformat:3 }} displays &quot;34.232&quot;</font>
<font color="black"> 122.     * {{ num2|floatformat:3 }} displays &quot;34.000&quot;</font>
<font color="black"> 123.     * {{ num3|floatformat:3 }} displays &quot;34.260&quot;</font>
<font color="black"> 124. </font>
<font color="black"> 125.     If arg is negative, it will display arg number of decimal places -- but</font>
<font color="black"> 126.     only if there are places to be displayed:</font>
<font color="black"> 127. </font>
<font color="black"> 128.     * {{ num1|floatformat:&quot;-3&quot; }} displays &quot;34.232&quot;</font>
<font color="black"> 129.     * {{ num2|floatformat:&quot;-3&quot; }} displays &quot;34&quot;</font>
<font color="black"> 130.     * {{ num3|floatformat:&quot;-3&quot; }} displays &quot;34.260&quot;</font>
<font color="black"> 131. </font>
<font color="black"> 132.     If the input float is infinity or NaN, the (platform-dependent) string</font>
<font color="black"> 133.     representation of that value will be displayed.</font>
<font color="black"> 134.     &quot;&quot;&quot;</font>
<font color="black"> 135. </font>
<font color="red"> 136.     try:</font>
<font color="red"> 137.         input_val = force_text(text)</font>
<font color="red"> 138.         d = Decimal(input_val)</font>
<font color="red"> 139.     except UnicodeEncodeError:</font>
<font color="red"> 140.         return ''</font>
<font color="red"> 141.     except InvalidOperation:</font>
<font color="red"> 142.         if input_val in special_floats:</font>
<font color="red"> 143.             return input_val</font>
<font color="red"> 144.         try:</font>
<font color="red"> 145.             d = Decimal(force_text(float(text)))</font>
<font color="red"> 146.         except (ValueError, InvalidOperation, TypeError, UnicodeEncodeError):</font>
<font color="red"> 147.             return ''</font>
<font color="red"> 148.     try:</font>
<font color="red"> 149.         p = int(arg)</font>
<font color="red"> 150.     except ValueError:</font>
<font color="red"> 151.         return input_val</font>
<font color="black"> 152. </font>
<font color="red"> 153.     try:</font>
<font color="red"> 154.         m = int(d) - d</font>
<font color="red"> 155.     except (ValueError, OverflowError, InvalidOperation):</font>
<font color="red"> 156.         return input_val</font>
<font color="black"> 157. </font>
<font color="red"> 158.     if not m and p &lt; 0:</font>
<font color="red"> 159.         return mark_safe(formats.number_format('%d' % (int(d)), 0))</font>
<font color="black"> 160. </font>
<font color="red"> 161.     if p == 0:</font>
<font color="red"> 162.         exp = Decimal(1)</font>
<font color="black"> 163.     else:</font>
<font color="red"> 164.         exp = Decimal('1.0') / (Decimal(10) ** abs(p))</font>
<font color="red"> 165.     try:</font>
<font color="black"> 166.         # Set the precision high enough to avoid an exception, see #15789.</font>
<font color="red"> 167.         tupl = d.as_tuple()</font>
<font color="red"> 168.         units = len(tupl[1]) - tupl[2]</font>
<font color="red"> 169.         prec = abs(p) + units + 1</font>
<font color="black"> 170. </font>
<font color="black"> 171.         # Avoid conversion to scientific notation by accessing `sign`, `digits`</font>
<font color="black"> 172.         # and `exponent` from `Decimal.as_tuple()` directly.</font>
<font color="red"> 173.         sign, digits, exponent = d.quantize(exp, ROUND_HALF_UP,</font>
<font color="red"> 174.             Context(prec=prec)).as_tuple()</font>
<font color="red"> 175.         digits = [six.text_type(digit) for digit in reversed(digits)]</font>
<font color="red"> 176.         while len(digits) &lt;= abs(exponent):</font>
<font color="red"> 177.             digits.append('0')</font>
<font color="red"> 178.         digits.insert(-exponent, '.')</font>
<font color="red"> 179.         if sign:</font>
<font color="red"> 180.             digits.append('-')</font>
<font color="red"> 181.         number = ''.join(reversed(digits))</font>
<font color="red"> 182.         return mark_safe(formats.number_format(number, abs(p)))</font>
<font color="red"> 183.     except InvalidOperation:</font>
<font color="red"> 184.         return input_val</font>
<font color="black"> 185. </font>
<font color="black"> 186. </font>
<font color="green"> 187. @register.filter(is_safe=True)</font>
<font color="green"> 188. @stringfilter</font>
<font color="black"> 189. def iriencode(value):</font>
<font color="black"> 190.     &quot;&quot;&quot;Escapes an IRI value for use in a URL.&quot;&quot;&quot;</font>
<font color="red"> 191.     return force_text(iri_to_uri(value))</font>
<font color="black"> 192. </font>
<font color="black"> 193. </font>
<font color="green"> 194. @register.filter(is_safe=True, needs_autoescape=True)</font>
<font color="green"> 195. @stringfilter</font>
<font color="green"> 196. def linenumbers(value, autoescape=True):</font>
<font color="black"> 197.     &quot;&quot;&quot;Displays text with line numbers.&quot;&quot;&quot;</font>
<font color="red"> 198.     lines = value.split('\n')</font>
<font color="black"> 199.     # Find the maximum width of the line count, for use with zero padding</font>
<font color="black"> 200.     # string format command</font>
<font color="red"> 201.     width = six.text_type(len(six.text_type(len(lines))))</font>
<font color="red"> 202.     if not autoescape or isinstance(value, SafeData):</font>
<font color="red"> 203.         for i, line in enumerate(lines):</font>
<font color="red"> 204.             lines[i] = (&quot;%0&quot; + width + &quot;d. %s&quot;) % (i + 1, line)</font>
<font color="black"> 205.     else:</font>
<font color="red"> 206.         for i, line in enumerate(lines):</font>
<font color="red"> 207.             lines[i] = (&quot;%0&quot; + width + &quot;d. %s&quot;) % (i + 1, escape(line))</font>
<font color="red"> 208.     return mark_safe('\n'.join(lines))</font>
<font color="black"> 209. </font>
<font color="black"> 210. </font>
<font color="green"> 211. @register.filter(is_safe=True)</font>
<font color="green"> 212. @stringfilter</font>
<font color="black"> 213. def lower(value):</font>
<font color="black"> 214.     &quot;&quot;&quot;Converts a string into all lowercase.&quot;&quot;&quot;</font>
<font color="red"> 215.     return value.lower()</font>
<font color="black"> 216. </font>
<font color="black"> 217. </font>
<font color="green"> 218. @register.filter(is_safe=False)</font>
<font color="green"> 219. @stringfilter</font>
<font color="black"> 220. def make_list(value):</font>
<font color="black"> 221.     &quot;&quot;&quot;</font>
<font color="black"> 222.     Returns the value turned into a list.</font>
<font color="black"> 223. </font>
<font color="black"> 224.     For an integer, it's a list of digits.</font>
<font color="black"> 225.     For a string, it's a list of characters.</font>
<font color="black"> 226.     &quot;&quot;&quot;</font>
<font color="red"> 227.     return list(value)</font>
<font color="black"> 228. </font>
<font color="black"> 229. </font>
<font color="green"> 230. @register.filter(is_safe=True)</font>
<font color="green"> 231. @stringfilter</font>
<font color="black"> 232. def slugify(value):</font>
<font color="black"> 233.     &quot;&quot;&quot;</font>
<font color="black"> 234.     Converts to ASCII. Converts spaces to hyphens. Removes characters that</font>
<font color="black"> 235.     aren't alphanumerics, underscores, or hyphens. Converts to lowercase.</font>
<font color="black"> 236.     Also strips leading and trailing whitespace.</font>
<font color="black"> 237.     &quot;&quot;&quot;</font>
<font color="red"> 238.     return _slugify(value)</font>
<font color="black"> 239. </font>
<font color="black"> 240. </font>
<font color="green"> 241. @register.filter(is_safe=True)</font>
<font color="black"> 242. def stringformat(value, arg):</font>
<font color="black"> 243.     &quot;&quot;&quot;</font>
<font color="black"> 244.     Formats the variable according to the arg, a string formatting specifier.</font>
<font color="black"> 245. </font>
<font color="black"> 246.     This specifier uses Python string formating syntax, with the exception that</font>
<font color="black"> 247.     the leading &quot;%&quot; is dropped.</font>
<font color="black"> 248. </font>
<font color="black"> 249.     See http://docs.python.org/lib/typesseq-strings.html for documentation</font>
<font color="black"> 250.     of Python string formatting</font>
<font color="black"> 251.     &quot;&quot;&quot;</font>
<font color="red"> 252.     try:</font>
<font color="red"> 253.         return (&quot;%&quot; + six.text_type(arg)) % value</font>
<font color="red"> 254.     except (ValueError, TypeError):</font>
<font color="red"> 255.         return &quot;&quot;</font>
<font color="black"> 256. </font>
<font color="black"> 257. </font>
<font color="green"> 258. @register.filter(is_safe=True)</font>
<font color="green"> 259. @stringfilter</font>
<font color="black"> 260. def title(value):</font>
<font color="black"> 261.     &quot;&quot;&quot;Converts a string into titlecase.&quot;&quot;&quot;</font>
<font color="red"> 262.     t = re.sub(&quot;([a-z])'([A-Z])&quot;, lambda m: m.group(0).lower(), value.title())</font>
<font color="red"> 263.     return re.sub(&quot;\d([A-Z])&quot;, lambda m: m.group(0).lower(), t)</font>
<font color="black"> 264. </font>
<font color="black"> 265. </font>
<font color="green"> 266. @register.filter(is_safe=True)</font>
<font color="green"> 267. @stringfilter</font>
<font color="black"> 268. def truncatechars(value, arg):</font>
<font color="black"> 269.     &quot;&quot;&quot;</font>
<font color="black"> 270.     Truncates a string after a certain number of characters.</font>
<font color="black"> 271. </font>
<font color="black"> 272.     Argument: Number of characters to truncate after.</font>
<font color="black"> 273.     &quot;&quot;&quot;</font>
<font color="red"> 274.     try:</font>
<font color="red"> 275.         length = int(arg)</font>
<font color="red"> 276.     except ValueError:  # Invalid literal for int().</font>
<font color="red"> 277.         return value  # Fail silently.</font>
<font color="red"> 278.     return Truncator(value).chars(length)</font>
<font color="black"> 279. </font>
<font color="black"> 280. </font>
<font color="green"> 281. @register.filter(is_safe=True)</font>
<font color="green"> 282. @stringfilter</font>
<font color="black"> 283. def truncatechars_html(value, arg):</font>
<font color="black"> 284.     &quot;&quot;&quot;</font>
<font color="black"> 285.     Truncates HTML after a certain number of chars.</font>
<font color="black"> 286. </font>
<font color="black"> 287.     Argument: Number of chars to truncate after.</font>
<font color="black"> 288. </font>
<font color="black"> 289.     Newlines in the HTML are preserved.</font>
<font color="black"> 290.     &quot;&quot;&quot;</font>
<font color="red"> 291.     try:</font>
<font color="red"> 292.         length = int(arg)</font>
<font color="red"> 293.     except ValueError:  # invalid literal for int()</font>
<font color="red"> 294.         return value  # Fail silently.</font>
<font color="red"> 295.     return Truncator(value).chars(length, html=True)</font>
<font color="black"> 296. </font>
<font color="black"> 297. </font>
<font color="green"> 298. @register.filter(is_safe=True)</font>
<font color="green"> 299. @stringfilter</font>
<font color="black"> 300. def truncatewords(value, arg):</font>
<font color="black"> 301.     &quot;&quot;&quot;</font>
<font color="black"> 302.     Truncates a string after a certain number of words.</font>
<font color="black"> 303. </font>
<font color="black"> 304.     Argument: Number of words to truncate after.</font>
<font color="black"> 305. </font>
<font color="black"> 306.     Newlines within the string are removed.</font>
<font color="black"> 307.     &quot;&quot;&quot;</font>
<font color="red"> 308.     try:</font>
<font color="red"> 309.         length = int(arg)</font>
<font color="red"> 310.     except ValueError:  # Invalid literal for int().</font>
<font color="red"> 311.         return value  # Fail silently.</font>
<font color="red"> 312.     return Truncator(value).words(length, truncate=' ...')</font>
<font color="black"> 313. </font>
<font color="black"> 314. </font>
<font color="green"> 315. @register.filter(is_safe=True)</font>
<font color="green"> 316. @stringfilter</font>
<font color="black"> 317. def truncatewords_html(value, arg):</font>
<font color="black"> 318.     &quot;&quot;&quot;</font>
<font color="black"> 319.     Truncates HTML after a certain number of words.</font>
<font color="black"> 320. </font>
<font color="black"> 321.     Argument: Number of words to truncate after.</font>
<font color="black"> 322. </font>
<font color="black"> 323.     Newlines in the HTML are preserved.</font>
<font color="black"> 324.     &quot;&quot;&quot;</font>
<font color="red"> 325.     try:</font>
<font color="red"> 326.         length = int(arg)</font>
<font color="red"> 327.     except ValueError:  # invalid literal for int()</font>
<font color="red"> 328.         return value  # Fail silently.</font>
<font color="red"> 329.     return Truncator(value).words(length, html=True, truncate=' ...')</font>
<font color="black"> 330. </font>
<font color="black"> 331. </font>
<font color="green"> 332. @register.filter(is_safe=False)</font>
<font color="green"> 333. @stringfilter</font>
<font color="black"> 334. def upper(value):</font>
<font color="black"> 335.     &quot;&quot;&quot;Converts a string into all uppercase.&quot;&quot;&quot;</font>
<font color="red"> 336.     return value.upper()</font>
<font color="black"> 337. </font>
<font color="black"> 338. </font>
<font color="green"> 339. @register.filter(is_safe=False)</font>
<font color="green"> 340. @stringfilter</font>
<font color="green"> 341. def urlencode(value, safe=None):</font>
<font color="black"> 342.     &quot;&quot;&quot;</font>
<font color="black"> 343.     Escapes a value for use in a URL.</font>
<font color="black"> 344. </font>
<font color="black"> 345.     Takes an optional ``safe`` parameter used to determine the characters which</font>
<font color="black"> 346.     should not be escaped by Django's ``urlquote`` method. If not provided, the</font>
<font color="black"> 347.     default safe characters will be used (but an empty string can be provided</font>
<font color="black"> 348.     when *all* characters should be escaped).</font>
<font color="black"> 349.     &quot;&quot;&quot;</font>
<font color="red"> 350.     kwargs = {}</font>
<font color="red"> 351.     if safe is not None:</font>
<font color="red"> 352.         kwargs['safe'] = safe</font>
<font color="red"> 353.     return urlquote(value, **kwargs)</font>
<font color="black"> 354. </font>
<font color="black"> 355. </font>
<font color="green"> 356. @register.filter(is_safe=True, needs_autoescape=True)</font>
<font color="green"> 357. @stringfilter</font>
<font color="green"> 358. def urlize(value, autoescape=True):</font>
<font color="black"> 359.     &quot;&quot;&quot;Converts URLs in plain text into clickable links.&quot;&quot;&quot;</font>
<font color="red"> 360.     return mark_safe(_urlize(value, nofollow=True, autoescape=autoescape))</font>
<font color="black"> 361. </font>
<font color="black"> 362. </font>
<font color="green"> 363. @register.filter(is_safe=True, needs_autoescape=True)</font>
<font color="green"> 364. @stringfilter</font>
<font color="green"> 365. def urlizetrunc(value, limit, autoescape=True):</font>
<font color="black"> 366.     &quot;&quot;&quot;</font>
<font color="black"> 367.     Converts URLs into clickable links, truncating URLs to the given character</font>
<font color="black"> 368.     limit, and adding 'rel=nofollow' attribute to discourage spamming.</font>
<font color="black"> 369. </font>
<font color="black"> 370.     Argument: Length to truncate URLs to.</font>
<font color="black"> 371.     &quot;&quot;&quot;</font>
<font color="red"> 372.     return mark_safe(_urlize(value, trim_url_limit=int(limit), nofollow=True,</font>
<font color="red"> 373.                             autoescape=autoescape))</font>
<font color="black"> 374. </font>
<font color="black"> 375. </font>
<font color="green"> 376. @register.filter(is_safe=False)</font>
<font color="green"> 377. @stringfilter</font>
<font color="black"> 378. def wordcount(value):</font>
<font color="black"> 379.     &quot;&quot;&quot;Returns the number of words.&quot;&quot;&quot;</font>
<font color="red"> 380.     return len(value.split())</font>
<font color="black"> 381. </font>
<font color="black"> 382. </font>
<font color="green"> 383. @register.filter(is_safe=True)</font>
<font color="green"> 384. @stringfilter</font>
<font color="black"> 385. def wordwrap(value, arg):</font>
<font color="black"> 386.     &quot;&quot;&quot;</font>
<font color="black"> 387.     Wraps words at specified line length.</font>
<font color="black"> 388. </font>
<font color="black"> 389.     Argument: number of characters to wrap the text at.</font>
<font color="black"> 390.     &quot;&quot;&quot;</font>
<font color="red"> 391.     return wrap(value, int(arg))</font>
<font color="black"> 392. </font>
<font color="black"> 393. </font>
<font color="green"> 394. @register.filter(is_safe=True)</font>
<font color="green"> 395. @stringfilter</font>
<font color="black"> 396. def ljust(value, arg):</font>
<font color="black"> 397.     &quot;&quot;&quot;</font>
<font color="black"> 398.     Left-aligns the value in a field of a given width.</font>
<font color="black"> 399. </font>
<font color="black"> 400.     Argument: field size.</font>
<font color="black"> 401.     &quot;&quot;&quot;</font>
<font color="red"> 402.     return value.ljust(int(arg))</font>
<font color="black"> 403. </font>
<font color="black"> 404. </font>
<font color="green"> 405. @register.filter(is_safe=True)</font>
<font color="green"> 406. @stringfilter</font>
<font color="black"> 407. def rjust(value, arg):</font>
<font color="black"> 408.     &quot;&quot;&quot;</font>
<font color="black"> 409.     Right-aligns the value in a field of a given width.</font>
<font color="black"> 410. </font>
<font color="black"> 411.     Argument: field size.</font>
<font color="black"> 412.     &quot;&quot;&quot;</font>
<font color="red"> 413.     return value.rjust(int(arg))</font>
<font color="black"> 414. </font>
<font color="black"> 415. </font>
<font color="green"> 416. @register.filter(is_safe=True)</font>
<font color="green"> 417. @stringfilter</font>
<font color="black"> 418. def center(value, arg):</font>
<font color="black"> 419.     &quot;&quot;&quot;Centers the value in a field of a given width.&quot;&quot;&quot;</font>
<font color="red"> 420.     return value.center(int(arg))</font>
<font color="black"> 421. </font>
<font color="black"> 422. </font>
<font color="green"> 423. @register.filter</font>
<font color="green"> 424. @stringfilter</font>
<font color="black"> 425. def cut(value, arg):</font>
<font color="black"> 426.     &quot;&quot;&quot;</font>
<font color="black"> 427.     Removes all values of arg from the given string.</font>
<font color="black"> 428.     &quot;&quot;&quot;</font>
<font color="red"> 429.     safe = isinstance(value, SafeData)</font>
<font color="red"> 430.     value = value.replace(arg, '')</font>
<font color="red"> 431.     if safe and arg != ';':</font>
<font color="red"> 432.         return mark_safe(value)</font>
<font color="red"> 433.     return value</font>
<font color="black"> 434. </font>
<font color="black"> 435. </font>
<font color="black"> 436. ###################</font>
<font color="black"> 437. # HTML STRINGS    #</font>
<font color="black"> 438. ###################</font>
<font color="black"> 439. </font>
<font color="green"> 440. @register.filter(&quot;escape&quot;, is_safe=True)</font>
<font color="green"> 441. @stringfilter</font>
<font color="black"> 442. def escape_filter(value):</font>
<font color="black"> 443.     &quot;&quot;&quot;</font>
<font color="black"> 444.     Marks the value as a string that should be auto-escaped.</font>
<font color="black"> 445.     &quot;&quot;&quot;</font>
<font color="red"> 446.     return mark_for_escaping(value)</font>
<font color="black"> 447. </font>
<font color="black"> 448. </font>
<font color="green"> 449. @register.filter(is_safe=True)</font>
<font color="green"> 450. @stringfilter</font>
<font color="black"> 451. def force_escape(value):</font>
<font color="black"> 452.     &quot;&quot;&quot;</font>
<font color="black"> 453.     Escapes a string's HTML. This returns a new string containing the escaped</font>
<font color="black"> 454.     characters (as opposed to &quot;escape&quot;, which marks the content for later</font>
<font color="black"> 455.     possible escaping).</font>
<font color="black"> 456.     &quot;&quot;&quot;</font>
<font color="red"> 457.     return escape(value)</font>
<font color="black"> 458. </font>
<font color="black"> 459. </font>
<font color="green"> 460. @register.filter(&quot;linebreaks&quot;, is_safe=True, needs_autoescape=True)</font>
<font color="green"> 461. @stringfilter</font>
<font color="green"> 462. def linebreaks_filter(value, autoescape=True):</font>
<font color="black"> 463.     &quot;&quot;&quot;</font>
<font color="black"> 464.     Replaces line breaks in plain text with appropriate HTML; a single</font>
<font color="black"> 465.     newline becomes an HTML line break (``&lt;br /&gt;``) and a new line</font>
<font color="black"> 466.     followed by a blank line becomes a paragraph break (``&lt;/p&gt;``).</font>
<font color="black"> 467.     &quot;&quot;&quot;</font>
<font color="red"> 468.     autoescape = autoescape and not isinstance(value, SafeData)</font>
<font color="red"> 469.     return mark_safe(linebreaks(value, autoescape))</font>
<font color="black"> 470. </font>
<font color="black"> 471. </font>
<font color="green"> 472. @register.filter(is_safe=True, needs_autoescape=True)</font>
<font color="green"> 473. @stringfilter</font>
<font color="green"> 474. def linebreaksbr(value, autoescape=True):</font>
<font color="black"> 475.     &quot;&quot;&quot;</font>
<font color="black"> 476.     Converts all newlines in a piece of plain text to HTML line breaks</font>
<font color="black"> 477.     (``&lt;br /&gt;``).</font>
<font color="black"> 478.     &quot;&quot;&quot;</font>
<font color="red"> 479.     autoescape = autoescape and not isinstance(value, SafeData)</font>
<font color="red"> 480.     value = normalize_newlines(value)</font>
<font color="red"> 481.     if autoescape:</font>
<font color="red"> 482.         value = escape(value)</font>
<font color="red"> 483.     return mark_safe(value.replace('\n', '&lt;br /&gt;'))</font>
<font color="black"> 484. </font>
<font color="black"> 485. </font>
<font color="green"> 486. @register.filter(is_safe=True)</font>
<font color="green"> 487. @stringfilter</font>
<font color="black"> 488. def safe(value):</font>
<font color="black"> 489.     &quot;&quot;&quot;</font>
<font color="black"> 490.     Marks the value as a string that should not be auto-escaped.</font>
<font color="black"> 491.     &quot;&quot;&quot;</font>
<font color="red"> 492.     return mark_safe(value)</font>
<font color="black"> 493. </font>
<font color="black"> 494. </font>
<font color="green"> 495. @register.filter(is_safe=True)</font>
<font color="black"> 496. def safeseq(value):</font>
<font color="black"> 497.     &quot;&quot;&quot;</font>
<font color="black"> 498.     A &quot;safe&quot; filter for sequences. Marks each element in the sequence,</font>
<font color="black"> 499.     individually, as safe, after converting them to unicode. Returns a list</font>
<font color="black"> 500.     with the results.</font>
<font color="black"> 501.     &quot;&quot;&quot;</font>
<font color="red"> 502.     return [mark_safe(force_text(obj)) for obj in value]</font>
<font color="black"> 503. </font>
<font color="black"> 504. </font>
<font color="green"> 505. @register.filter(is_safe=True)</font>
<font color="green"> 506. @stringfilter</font>
<font color="black"> 507. def removetags(value, tags):</font>
<font color="black"> 508.     &quot;&quot;&quot;Removes a space separated list of [X]HTML tags from the output.&quot;&quot;&quot;</font>
<font color="red"> 509.     return remove_tags(value, tags)</font>
<font color="black"> 510. </font>
<font color="black"> 511. </font>
<font color="green"> 512. @register.filter(is_safe=True)</font>
<font color="green"> 513. @stringfilter</font>
<font color="black"> 514. def striptags(value):</font>
<font color="black"> 515.     &quot;&quot;&quot;Strips all [X]HTML tags.&quot;&quot;&quot;</font>
<font color="red"> 516.     return strip_tags(value)</font>
<font color="black"> 517. </font>
<font color="black"> 518. </font>
<font color="black"> 519. ###################</font>
<font color="black"> 520. # LISTS           #</font>
<font color="black"> 521. ###################</font>
<font color="black"> 522. </font>
<font color="green"> 523. @register.filter(is_safe=False)</font>
<font color="black"> 524. def dictsort(value, arg):</font>
<font color="black"> 525.     &quot;&quot;&quot;</font>
<font color="black"> 526.     Takes a list of dicts, returns that list sorted by the property given in</font>
<font color="black"> 527.     the argument.</font>
<font color="black"> 528.     &quot;&quot;&quot;</font>
<font color="red"> 529.     try:</font>
<font color="red"> 530.         return sorted(value, key=Variable(arg).resolve)</font>
<font color="red"> 531.     except (TypeError, VariableDoesNotExist):</font>
<font color="red"> 532.         return ''</font>
<font color="black"> 533. </font>
<font color="black"> 534. </font>
<font color="green"> 535. @register.filter(is_safe=False)</font>
<font color="black"> 536. def dictsortreversed(value, arg):</font>
<font color="black"> 537.     &quot;&quot;&quot;</font>
<font color="black"> 538.     Takes a list of dicts, returns that list sorted in reverse order by the</font>
<font color="black"> 539.     property given in the argument.</font>
<font color="black"> 540.     &quot;&quot;&quot;</font>
<font color="red"> 541.     try:</font>
<font color="red"> 542.         return sorted(value, key=Variable(arg).resolve, reverse=True)</font>
<font color="red"> 543.     except (TypeError, VariableDoesNotExist):</font>
<font color="red"> 544.         return ''</font>
<font color="black"> 545. </font>
<font color="black"> 546. </font>
<font color="green"> 547. @register.filter(is_safe=False)</font>
<font color="black"> 548. def first(value):</font>
<font color="black"> 549.     &quot;&quot;&quot;Returns the first item in a list.&quot;&quot;&quot;</font>
<font color="red"> 550.     try:</font>
<font color="red"> 551.         return value[0]</font>
<font color="red"> 552.     except IndexError:</font>
<font color="red"> 553.         return ''</font>
<font color="black"> 554. </font>
<font color="black"> 555. </font>
<font color="green"> 556. @register.filter(is_safe=True, needs_autoescape=True)</font>
<font color="green"> 557. def join(value, arg, autoescape=True):</font>
<font color="black"> 558.     &quot;&quot;&quot;</font>
<font color="black"> 559.     Joins a list with a string, like Python's ``str.join(list)``.</font>
<font color="black"> 560.     &quot;&quot;&quot;</font>
<font color="red"> 561.     value = map(force_text, value)</font>
<font color="red"> 562.     if autoescape:</font>
<font color="red"> 563.         value = [conditional_escape(v) for v in value]</font>
<font color="red"> 564.     try:</font>
<font color="red"> 565.         data = conditional_escape(arg).join(value)</font>
<font color="red"> 566.     except AttributeError:  # fail silently but nicely</font>
<font color="red"> 567.         return value</font>
<font color="red"> 568.     return mark_safe(data)</font>
<font color="black"> 569. </font>
<font color="black"> 570. </font>
<font color="green"> 571. @register.filter(is_safe=True)</font>
<font color="black"> 572. def last(value):</font>
<font color="black"> 573.     &quot;Returns the last item in a list&quot;</font>
<font color="red"> 574.     try:</font>
<font color="red"> 575.         return value[-1]</font>
<font color="red"> 576.     except IndexError:</font>
<font color="red"> 577.         return ''</font>
<font color="black"> 578. </font>
<font color="black"> 579. </font>
<font color="green"> 580. @register.filter(is_safe=False)</font>
<font color="black"> 581. def length(value):</font>
<font color="black"> 582.     &quot;&quot;&quot;Returns the length of the value - useful for lists.&quot;&quot;&quot;</font>
<font color="red"> 583.     try:</font>
<font color="red"> 584.         return len(value)</font>
<font color="red"> 585.     except (ValueError, TypeError):</font>
<font color="red"> 586.         return 0</font>
<font color="black"> 587. </font>
<font color="black"> 588. </font>
<font color="green"> 589. @register.filter(is_safe=False)</font>
<font color="black"> 590. def length_is(value, arg):</font>
<font color="black"> 591.     &quot;&quot;&quot;Returns a boolean of whether the value's length is the argument.&quot;&quot;&quot;</font>
<font color="red"> 592.     try:</font>
<font color="red"> 593.         return len(value) == int(arg)</font>
<font color="red"> 594.     except (ValueError, TypeError):</font>
<font color="red"> 595.         return ''</font>
<font color="black"> 596. </font>
<font color="black"> 597. </font>
<font color="green"> 598. @register.filter(is_safe=True)</font>
<font color="black"> 599. def random(value):</font>
<font color="black"> 600.     &quot;&quot;&quot;Returns a random item from the list.&quot;&quot;&quot;</font>
<font color="red"> 601.     return random_module.choice(value)</font>
<font color="black"> 602. </font>
<font color="black"> 603. </font>
<font color="green"> 604. @register.filter(&quot;slice&quot;, is_safe=True)</font>
<font color="black"> 605. def slice_filter(value, arg):</font>
<font color="black"> 606.     &quot;&quot;&quot;</font>
<font color="black"> 607.     Returns a slice of the list.</font>
<font color="black"> 608. </font>
<font color="black"> 609.     Uses the same syntax as Python's list slicing; see</font>
<font color="black"> 610.     http://www.diveintopython3.net/native-datatypes.html#slicinglists</font>
<font color="black"> 611.     for an introduction.</font>
<font color="black"> 612.     &quot;&quot;&quot;</font>
<font color="red"> 613.     try:</font>
<font color="red"> 614.         bits = []</font>
<font color="red"> 615.         for x in arg.split(':'):</font>
<font color="red"> 616.             if len(x) == 0:</font>
<font color="red"> 617.                 bits.append(None)</font>
<font color="black"> 618.             else:</font>
<font color="red"> 619.                 bits.append(int(x))</font>
<font color="red"> 620.         return value[slice(*bits)]</font>
<font color="black"> 621. </font>
<font color="red"> 622.     except (ValueError, TypeError):</font>
<font color="red"> 623.         return value  # Fail silently.</font>
<font color="black"> 624. </font>
<font color="black"> 625. </font>
<font color="green"> 626. @register.filter(is_safe=True, needs_autoescape=True)</font>
<font color="green"> 627. def unordered_list(value, autoescape=True):</font>
<font color="black"> 628.     &quot;&quot;&quot;</font>
<font color="black"> 629.     Recursively takes a self-nested list and returns an HTML unordered list --</font>
<font color="black"> 630.     WITHOUT opening and closing &lt;ul&gt; tags.</font>
<font color="black"> 631. </font>
<font color="black"> 632.     The list is assumed to be in the proper format. For example, if ``var``</font>
<font color="black"> 633.     contains: ``['States', ['Kansas', ['Lawrence', 'Topeka'], 'Illinois']]``,</font>
<font color="black"> 634.     then ``{{ var|unordered_list }}`` would return::</font>
<font color="black"> 635. </font>
<font color="black"> 636.         &lt;li&gt;States</font>
<font color="black"> 637.         &lt;ul&gt;</font>
<font color="black"> 638.                 &lt;li&gt;Kansas</font>
<font color="black"> 639.                 &lt;ul&gt;</font>
<font color="black"> 640.                         &lt;li&gt;Lawrence&lt;/li&gt;</font>
<font color="black"> 641.                         &lt;li&gt;Topeka&lt;/li&gt;</font>
<font color="black"> 642.                 &lt;/ul&gt;</font>
<font color="black"> 643.                 &lt;/li&gt;</font>
<font color="black"> 644.                 &lt;li&gt;Illinois&lt;/li&gt;</font>
<font color="black"> 645.         &lt;/ul&gt;</font>
<font color="black"> 646.         &lt;/li&gt;</font>
<font color="black"> 647.     &quot;&quot;&quot;</font>
<font color="red"> 648.     if autoescape:</font>
<font color="red"> 649.         escaper = conditional_escape</font>
<font color="black"> 650.     else:</font>
<font color="red"> 651.         escaper = lambda x: x</font>
<font color="black"> 652. </font>
<font color="red"> 653.     def convert_old_style_list(list_):</font>
<font color="black"> 654.         &quot;&quot;&quot;</font>
<font color="black"> 655.         Converts old style lists to the new easier to understand format.</font>
<font color="black"> 656. </font>
<font color="black"> 657.         The old list format looked like:</font>
<font color="black"> 658.             ['Item 1', [['Item 1.1', []], ['Item 1.2', []]]</font>
<font color="black"> 659. </font>
<font color="black"> 660.         And it is converted to:</font>
<font color="black"> 661.             ['Item 1', ['Item 1.1', 'Item 1.2]]</font>
<font color="black"> 662.         &quot;&quot;&quot;</font>
<font color="red"> 663.         if not isinstance(list_, (tuple, list)) or len(list_) != 2:</font>
<font color="red"> 664.             return list_, False</font>
<font color="red"> 665.         first_item, second_item = list_</font>
<font color="red"> 666.         if second_item == []:</font>
<font color="red"> 667.             return [first_item], True</font>
<font color="red"> 668.         try:</font>
<font color="black"> 669.             # see if second item is iterable</font>
<font color="red"> 670.             iter(second_item)</font>
<font color="red"> 671.         except TypeError:</font>
<font color="red"> 672.             return list_, False</font>
<font color="red"> 673.         old_style_list = True</font>
<font color="red"> 674.         new_second_item = []</font>
<font color="red"> 675.         for sublist in second_item:</font>
<font color="red"> 676.             item, old_style_list = convert_old_style_list(sublist)</font>
<font color="red"> 677.             if not old_style_list:</font>
<font color="red"> 678.                 break</font>
<font color="red"> 679.             new_second_item.extend(item)</font>
<font color="red"> 680.         if old_style_list:</font>
<font color="red"> 681.             second_item = new_second_item</font>
<font color="red"> 682.         return [first_item, second_item], old_style_list</font>
<font color="black"> 683. </font>
<font color="red"> 684.     def walk_items(item_list):</font>
<font color="red"> 685.         item_iterator = iter(item_list)</font>
<font color="red"> 686.         try:</font>
<font color="red"> 687.             item = next(item_iterator)</font>
<font color="red"> 688.             while True:</font>
<font color="red"> 689.                 try:</font>
<font color="red"> 690.                     next_item = next(item_iterator)</font>
<font color="red"> 691.                 except StopIteration:</font>
<font color="red"> 692.                     yield item, None</font>
<font color="red"> 693.                     break</font>
<font color="red"> 694.                 if not isinstance(next_item, six.string_types):</font>
<font color="red"> 695.                     try:</font>
<font color="red"> 696.                         iter(next_item)</font>
<font color="red"> 697.                     except TypeError:</font>
<font color="red"> 698.                         pass</font>
<font color="black"> 699.                     else:</font>
<font color="red"> 700.                         yield item, next_item</font>
<font color="red"> 701.                         item = next(item_iterator)</font>
<font color="red"> 702.                         continue</font>
<font color="red"> 703.                 yield item, None</font>
<font color="red"> 704.                 item = next_item</font>
<font color="red"> 705.         except StopIteration:</font>
<font color="red"> 706.             pass</font>
<font color="black"> 707. </font>
<font color="red"> 708.     def list_formatter(item_list, tabs=1):</font>
<font color="red"> 709.         indent = '\t' * tabs</font>
<font color="red"> 710.         output = []</font>
<font color="red"> 711.         for item, children in walk_items(item_list):</font>
<font color="red"> 712.             sublist = ''</font>
<font color="red"> 713.             if children:</font>
<font color="red"> 714.                 sublist = '\n%s&lt;ul&gt;\n%s\n%s&lt;/ul&gt;\n%s' % (</font>
<font color="red"> 715.                     indent, list_formatter(children, tabs + 1), indent, indent)</font>
<font color="red"> 716.             output.append('%s&lt;li&gt;%s%s&lt;/li&gt;' % (</font>
<font color="red"> 717.                 indent, escaper(force_text(item)), sublist))</font>
<font color="red"> 718.         return '\n'.join(output)</font>
<font color="black"> 719. </font>
<font color="red"> 720.     value, converted = convert_old_style_list(value)</font>
<font color="red"> 721.     if converted:</font>
<font color="red"> 722.         warnings.warn(</font>
<font color="red"> 723.             &quot;The old style syntax in `unordered_list` is deprecated and will &quot;</font>
<font color="black"> 724.             &quot;be removed in Django 1.10. Use the the new format instead.&quot;,</font>
<font color="red"> 725.             RemovedInDjango110Warning)</font>
<font color="red"> 726.     return mark_safe(list_formatter(value))</font>
<font color="black"> 727. </font>
<font color="black"> 728. </font>
<font color="black"> 729. ###################</font>
<font color="black"> 730. # INTEGERS        #</font>
<font color="black"> 731. ###################</font>
<font color="black"> 732. </font>
<font color="green"> 733. @register.filter(is_safe=False)</font>
<font color="black"> 734. def add(value, arg):</font>
<font color="black"> 735.     &quot;&quot;&quot;Adds the arg to the value.&quot;&quot;&quot;</font>
<font color="red"> 736.     try:</font>
<font color="red"> 737.         return int(value) + int(arg)</font>
<font color="red"> 738.     except (ValueError, TypeError):</font>
<font color="red"> 739.         try:</font>
<font color="red"> 740.             return value + arg</font>
<font color="red"> 741.         except Exception:</font>
<font color="red"> 742.             return ''</font>
<font color="black"> 743. </font>
<font color="black"> 744. </font>
<font color="green"> 745. @register.filter(is_safe=False)</font>
<font color="black"> 746. def get_digit(value, arg):</font>
<font color="black"> 747.     &quot;&quot;&quot;</font>
<font color="black"> 748.     Given a whole number, returns the requested digit of it, where 1 is the</font>
<font color="black"> 749.     right-most digit, 2 is the second-right-most digit, etc. Returns the</font>
<font color="black"> 750.     original value for invalid input (if input or argument is not an integer,</font>
<font color="black"> 751.     or if argument is less than 1). Otherwise, output is always an integer.</font>
<font color="black"> 752.     &quot;&quot;&quot;</font>
<font color="red"> 753.     try:</font>
<font color="red"> 754.         arg = int(arg)</font>
<font color="red"> 755.         value = int(value)</font>
<font color="red"> 756.     except ValueError:</font>
<font color="red"> 757.         return value  # Fail silently for an invalid argument</font>
<font color="red"> 758.     if arg &lt; 1:</font>
<font color="red"> 759.         return value</font>
<font color="red"> 760.     try:</font>
<font color="red"> 761.         return int(str(value)[-arg])</font>
<font color="red"> 762.     except IndexError:</font>
<font color="red"> 763.         return 0</font>
<font color="black"> 764. </font>
<font color="black"> 765. </font>
<font color="black"> 766. ###################</font>
<font color="black"> 767. # DATES           #</font>
<font color="black"> 768. ###################</font>
<font color="black"> 769. </font>
<font color="green"> 770. @register.filter(expects_localtime=True, is_safe=False)</font>
<font color="green"> 771. def date(value, arg=None):</font>
<font color="black"> 772.     &quot;&quot;&quot;Formats a date according to the given format.&quot;&quot;&quot;</font>
<font color="red"> 773.     if value in (None, ''):</font>
<font color="red"> 774.         return ''</font>
<font color="red"> 775.     if arg is None:</font>
<font color="red"> 776.         arg = settings.DATE_FORMAT</font>
<font color="red"> 777.     try:</font>
<font color="red"> 778.         return formats.date_format(value, arg)</font>
<font color="red"> 779.     except AttributeError:</font>
<font color="red"> 780.         try:</font>
<font color="red"> 781.             return format(value, arg)</font>
<font color="red"> 782.         except AttributeError:</font>
<font color="red"> 783.             return ''</font>
<font color="black"> 784. </font>
<font color="black"> 785. </font>
<font color="green"> 786. @register.filter(expects_localtime=True, is_safe=False)</font>
<font color="green"> 787. def time(value, arg=None):</font>
<font color="black"> 788.     &quot;&quot;&quot;Formats a time according to the given format.&quot;&quot;&quot;</font>
<font color="red"> 789.     if value in (None, ''):</font>
<font color="red"> 790.         return ''</font>
<font color="red"> 791.     if arg is None:</font>
<font color="red"> 792.         arg = settings.TIME_FORMAT</font>
<font color="red"> 793.     try:</font>
<font color="red"> 794.         return formats.time_format(value, arg)</font>
<font color="red"> 795.     except AttributeError:</font>
<font color="red"> 796.         try:</font>
<font color="red"> 797.             return time_format(value, arg)</font>
<font color="red"> 798.         except AttributeError:</font>
<font color="red"> 799.             return ''</font>
<font color="black"> 800. </font>
<font color="black"> 801. </font>
<font color="green"> 802. @register.filter(&quot;timesince&quot;, is_safe=False)</font>
<font color="green"> 803. def timesince_filter(value, arg=None):</font>
<font color="black"> 804.     &quot;&quot;&quot;Formats a date as the time since that date (i.e. &quot;4 days, 6 hours&quot;).&quot;&quot;&quot;</font>
<font color="red"> 805.     if not value:</font>
<font color="red"> 806.         return ''</font>
<font color="red"> 807.     try:</font>
<font color="red"> 808.         if arg:</font>
<font color="red"> 809.             return timesince(value, arg)</font>
<font color="red"> 810.         return timesince(value)</font>
<font color="red"> 811.     except (ValueError, TypeError):</font>
<font color="red"> 812.         return ''</font>
<font color="black"> 813. </font>
<font color="black"> 814. </font>
<font color="green"> 815. @register.filter(&quot;timeuntil&quot;, is_safe=False)</font>
<font color="green"> 816. def timeuntil_filter(value, arg=None):</font>
<font color="black"> 817.     &quot;&quot;&quot;Formats a date as the time until that date (i.e. &quot;4 days, 6 hours&quot;).&quot;&quot;&quot;</font>
<font color="red"> 818.     if not value:</font>
<font color="red"> 819.         return ''</font>
<font color="red"> 820.     try:</font>
<font color="red"> 821.         return timeuntil(value, arg)</font>
<font color="red"> 822.     except (ValueError, TypeError):</font>
<font color="red"> 823.         return ''</font>
<font color="black"> 824. </font>
<font color="black"> 825. </font>
<font color="black"> 826. ###################</font>
<font color="black"> 827. # LOGIC           #</font>
<font color="black"> 828. ###################</font>
<font color="black"> 829. </font>
<font color="green"> 830. @register.filter(is_safe=False)</font>
<font color="black"> 831. def default(value, arg):</font>
<font color="black"> 832.     &quot;&quot;&quot;If value is unavailable, use given default.&quot;&quot;&quot;</font>
<font color="red"> 833.     return value or arg</font>
<font color="black"> 834. </font>
<font color="black"> 835. </font>
<font color="green"> 836. @register.filter(is_safe=False)</font>
<font color="black"> 837. def default_if_none(value, arg):</font>
<font color="black"> 838.     &quot;&quot;&quot;If value is None, use given default.&quot;&quot;&quot;</font>
<font color="red"> 839.     if value is None:</font>
<font color="red"> 840.         return arg</font>
<font color="red"> 841.     return value</font>
<font color="black"> 842. </font>
<font color="black"> 843. </font>
<font color="green"> 844. @register.filter(is_safe=False)</font>
<font color="black"> 845. def divisibleby(value, arg):</font>
<font color="black"> 846.     &quot;&quot;&quot;Returns True if the value is devisible by the argument.&quot;&quot;&quot;</font>
<font color="red"> 847.     return int(value) % int(arg) == 0</font>
<font color="black"> 848. </font>
<font color="black"> 849. </font>
<font color="green"> 850. @register.filter(is_safe=False)</font>
<font color="green"> 851. def yesno(value, arg=None):</font>
<font color="black"> 852.     &quot;&quot;&quot;</font>
<font color="black"> 853.     Given a string mapping values for true, false and (optionally) None,</font>
<font color="black"> 854.     returns one of those strings according to the value:</font>
<font color="black"> 855. </font>
<font color="black"> 856.     ==========  ======================  ==================================</font>
<font color="black"> 857.     Value       Argument                Outputs</font>
<font color="black"> 858.     ==========  ======================  ==================================</font>
<font color="black"> 859.     ``True``    ``&quot;yeah,no,maybe&quot;``     ``yeah``</font>
<font color="black"> 860.     ``False``   ``&quot;yeah,no,maybe&quot;``     ``no``</font>
<font color="black"> 861.     ``None``    ``&quot;yeah,no,maybe&quot;``     ``maybe``</font>
<font color="black"> 862.     ``None``    ``&quot;yeah,no&quot;``           ``&quot;no&quot;`` (converts None to False</font>
<font color="black"> 863.                                         if no mapping for None is given.</font>
<font color="black"> 864.     ==========  ======================  ==================================</font>
<font color="black"> 865.     &quot;&quot;&quot;</font>
<font color="red"> 866.     if arg is None:</font>
<font color="red"> 867.         arg = ugettext('yes,no,maybe')</font>
<font color="red"> 868.     bits = arg.split(',')</font>
<font color="red"> 869.     if len(bits) &lt; 2:</font>
<font color="red"> 870.         return value  # Invalid arg.</font>
<font color="red"> 871.     try:</font>
<font color="red"> 872.         yes, no, maybe = bits</font>
<font color="red"> 873.     except ValueError:</font>
<font color="black"> 874.         # Unpack list of wrong size (no &quot;maybe&quot; value provided).</font>
<font color="red"> 875.         yes, no, maybe = bits[0], bits[1], bits[1]</font>
<font color="red"> 876.     if value is None:</font>
<font color="red"> 877.         return maybe</font>
<font color="red"> 878.     if value:</font>
<font color="red"> 879.         return yes</font>
<font color="red"> 880.     return no</font>
<font color="black"> 881. </font>
<font color="black"> 882. </font>
<font color="black"> 883. ###################</font>
<font color="black"> 884. # MISC            #</font>
<font color="black"> 885. ###################</font>
<font color="black"> 886. </font>
<font color="green"> 887. @register.filter(is_safe=True)</font>
<font color="black"> 888. def filesizeformat(bytes):</font>
<font color="black"> 889.     &quot;&quot;&quot;</font>
<font color="black"> 890.     Formats the value like a 'human-readable' file size (i.e. 13 KB, 4.1 MB,</font>
<font color="black"> 891.     102 bytes, etc).</font>
<font color="black"> 892.     &quot;&quot;&quot;</font>
<font color="red"> 893.     try:</font>
<font color="red"> 894.         bytes = float(bytes)</font>
<font color="red"> 895.     except (TypeError, ValueError, UnicodeDecodeError):</font>
<font color="red"> 896.         value = ungettext(&quot;%(size)d byte&quot;, &quot;%(size)d bytes&quot;, 0) % {'size': 0}</font>
<font color="red"> 897.         return avoid_wrapping(value)</font>
<font color="black"> 898. </font>
<font color="red"> 899.     filesize_number_format = lambda value: formats.number_format(round(value, 1), 1)</font>
<font color="black"> 900. </font>
<font color="red"> 901.     KB = 1 &lt;&lt; 10</font>
<font color="red"> 902.     MB = 1 &lt;&lt; 20</font>
<font color="red"> 903.     GB = 1 &lt;&lt; 30</font>
<font color="red"> 904.     TB = 1 &lt;&lt; 40</font>
<font color="red"> 905.     PB = 1 &lt;&lt; 50</font>
<font color="black"> 906. </font>
<font color="red"> 907.     if bytes &lt; KB:</font>
<font color="red"> 908.         value = ungettext(&quot;%(size)d byte&quot;, &quot;%(size)d bytes&quot;, bytes) % {'size': bytes}</font>
<font color="red"> 909.     elif bytes &lt; MB:</font>
<font color="red"> 910.         value = ugettext(&quot;%s KB&quot;) % filesize_number_format(bytes / KB)</font>
<font color="red"> 911.     elif bytes &lt; GB:</font>
<font color="red"> 912.         value = ugettext(&quot;%s MB&quot;) % filesize_number_format(bytes / MB)</font>
<font color="red"> 913.     elif bytes &lt; TB:</font>
<font color="red"> 914.         value = ugettext(&quot;%s GB&quot;) % filesize_number_format(bytes / GB)</font>
<font color="red"> 915.     elif bytes &lt; PB:</font>
<font color="red"> 916.         value = ugettext(&quot;%s TB&quot;) % filesize_number_format(bytes / TB)</font>
<font color="black"> 917.     else:</font>
<font color="red"> 918.         value = ugettext(&quot;%s PB&quot;) % filesize_number_format(bytes / PB)</font>
<font color="black"> 919. </font>
<font color="red"> 920.     return avoid_wrapping(value)</font>
<font color="black"> 921. </font>
<font color="black"> 922. </font>
<font color="green"> 923. @register.filter(is_safe=False)</font>
<font color="green"> 924. def pluralize(value, arg='s'):</font>
<font color="black"> 925.     &quot;&quot;&quot;</font>
<font color="black"> 926.     Returns a plural suffix if the value is not 1. By default, 's' is used as</font>
<font color="black"> 927.     the suffix:</font>
<font color="black"> 928. </font>
<font color="black"> 929.     * If value is 0, vote{{ value|pluralize }} displays &quot;0 votes&quot;.</font>
<font color="black"> 930.     * If value is 1, vote{{ value|pluralize }} displays &quot;1 vote&quot;.</font>
<font color="black"> 931.     * If value is 2, vote{{ value|pluralize }} displays &quot;2 votes&quot;.</font>
<font color="black"> 932. </font>
<font color="black"> 933.     If an argument is provided, that string is used instead:</font>
<font color="black"> 934. </font>
<font color="black"> 935.     * If value is 0, class{{ value|pluralize:&quot;es&quot; }} displays &quot;0 classes&quot;.</font>
<font color="black"> 936.     * If value is 1, class{{ value|pluralize:&quot;es&quot; }} displays &quot;1 class&quot;.</font>
<font color="black"> 937.     * If value is 2, class{{ value|pluralize:&quot;es&quot; }} displays &quot;2 classes&quot;.</font>
<font color="black"> 938. </font>
<font color="black"> 939.     If the provided argument contains a comma, the text before the comma is</font>
<font color="black"> 940.     used for the singular case and the text after the comma is used for the</font>
<font color="black"> 941.     plural case:</font>
<font color="black"> 942. </font>
<font color="black"> 943.     * If value is 0, cand{{ value|pluralize:&quot;y,ies&quot; }} displays &quot;0 candies&quot;.</font>
<font color="black"> 944.     * If value is 1, cand{{ value|pluralize:&quot;y,ies&quot; }} displays &quot;1 candy&quot;.</font>
<font color="black"> 945.     * If value is 2, cand{{ value|pluralize:&quot;y,ies&quot; }} displays &quot;2 candies&quot;.</font>
<font color="black"> 946.     &quot;&quot;&quot;</font>
<font color="red"> 947.     if ',' not in arg:</font>
<font color="red"> 948.         arg = ',' + arg</font>
<font color="red"> 949.     bits = arg.split(',')</font>
<font color="red"> 950.     if len(bits) &gt; 2:</font>
<font color="red"> 951.         return ''</font>
<font color="red"> 952.     singular_suffix, plural_suffix = bits[:2]</font>
<font color="black"> 953. </font>
<font color="red"> 954.     try:</font>
<font color="red"> 955.         if float(value) != 1:</font>
<font color="red"> 956.             return plural_suffix</font>
<font color="red"> 957.     except ValueError:  # Invalid string that's not a number.</font>
<font color="red"> 958.         pass</font>
<font color="red"> 959.     except TypeError:  # Value isn't a string or a number; maybe it's a list?</font>
<font color="red"> 960.         try:</font>
<font color="red"> 961.             if len(value) != 1:</font>
<font color="red"> 962.                 return plural_suffix</font>
<font color="red"> 963.         except TypeError:  # len() of unsized object.</font>
<font color="red"> 964.             pass</font>
<font color="red"> 965.     return singular_suffix</font>
<font color="black"> 966. </font>
<font color="black"> 967. </font>
<font color="green"> 968. @register.filter(&quot;phone2numeric&quot;, is_safe=True)</font>
<font color="black"> 969. def phone2numeric_filter(value):</font>
<font color="black"> 970.     &quot;&quot;&quot;Takes a phone number and converts it in to its numerical equivalent.&quot;&quot;&quot;</font>
<font color="red"> 971.     return phone2numeric(value)</font>
<font color="black"> 972. </font>
<font color="black"> 973. </font>
<font color="green"> 974. @register.filter(is_safe=True)</font>
<font color="black"> 975. def pprint(value):</font>
<font color="black"> 976.     &quot;&quot;&quot;A wrapper around pprint.pprint -- for debugging, really.&quot;&quot;&quot;</font>
<font color="red"> 977.     try:</font>
<font color="red"> 978.         return pformat(value)</font>
<font color="red"> 979.     except Exception as e:</font>
<font color="red"> 980.         return &quot;Error in formatting: %s: %s&quot; % (e.__class__.__name__, force_text(e, errors=&quot;replace&quot;))</font>
</pre>

