source file: <b>/usr/lib/python2.7/wsgiref/util.py</b><br>


file stats: <b>95 lines, 20 executed: 21.1% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Miscellaneous WSGI-related Utilities&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="green">   3. import posixpath</font>
<font color="black">   4. </font>
<font color="black">   5. __all__ = [</font>
<font color="green">   6.     'FileWrapper', 'guess_scheme', 'application_uri', 'request_uri',</font>
<font color="green">   7.     'shift_path_info', 'setup_testing_defaults',</font>
<font color="black">   8. ]</font>
<font color="black">   9. </font>
<font color="black">  10. </font>
<font color="green">  11. class FileWrapper:</font>
<font color="green">  12.     &quot;&quot;&quot;Wrapper to convert file-like objects to iterables&quot;&quot;&quot;</font>
<font color="black">  13. </font>
<font color="green">  14.     def __init__(self, filelike, blksize=8192):</font>
<font color="red">  15.         self.filelike = filelike</font>
<font color="red">  16.         self.blksize = blksize</font>
<font color="red">  17.         if hasattr(filelike,'close'):</font>
<font color="red">  18.             self.close = filelike.close</font>
<font color="black">  19. </font>
<font color="green">  20.     def __getitem__(self,key):</font>
<font color="red">  21.         data = self.filelike.read(self.blksize)</font>
<font color="red">  22.         if data:</font>
<font color="red">  23.             return data</font>
<font color="red">  24.         raise IndexError</font>
<font color="black">  25. </font>
<font color="green">  26.     def __iter__(self):</font>
<font color="red">  27.         return self</font>
<font color="black">  28. </font>
<font color="green">  29.     def next(self):</font>
<font color="red">  30.         data = self.filelike.read(self.blksize)</font>
<font color="red">  31.         if data:</font>
<font color="red">  32.             return data</font>
<font color="red">  33.         raise StopIteration</font>
<font color="black">  34. </font>
<font color="green">  35. def guess_scheme(environ):</font>
<font color="black">  36.     &quot;&quot;&quot;Return a guess for whether 'wsgi.url_scheme' should be 'http' or 'https'</font>
<font color="black">  37.     &quot;&quot;&quot;</font>
<font color="red">  38.     if environ.get(&quot;HTTPS&quot;) in ('yes','on','1'):</font>
<font color="red">  39.         return 'https'</font>
<font color="black">  40.     else:</font>
<font color="red">  41.         return 'http'</font>
<font color="black">  42. </font>
<font color="green">  43. def application_uri(environ):</font>
<font color="black">  44.     &quot;&quot;&quot;Return the application's base URI (no PATH_INFO or QUERY_STRING)&quot;&quot;&quot;</font>
<font color="red">  45.     url = environ['wsgi.url_scheme']+'://'</font>
<font color="red">  46.     from urllib import quote</font>
<font color="black">  47. </font>
<font color="red">  48.     if environ.get('HTTP_HOST'):</font>
<font color="red">  49.         url += environ['HTTP_HOST']</font>
<font color="black">  50.     else:</font>
<font color="red">  51.         url += environ['SERVER_NAME']</font>
<font color="black">  52. </font>
<font color="red">  53.         if environ['wsgi.url_scheme'] == 'https':</font>
<font color="red">  54.             if environ['SERVER_PORT'] != '443':</font>
<font color="red">  55.                 url += ':' + environ['SERVER_PORT']</font>
<font color="black">  56.         else:</font>
<font color="red">  57.             if environ['SERVER_PORT'] != '80':</font>
<font color="red">  58.                 url += ':' + environ['SERVER_PORT']</font>
<font color="black">  59. </font>
<font color="red">  60.     url += quote(environ.get('SCRIPT_NAME') or '/')</font>
<font color="red">  61.     return url</font>
<font color="black">  62. </font>
<font color="green">  63. def request_uri(environ, include_query=1):</font>
<font color="black">  64.     &quot;&quot;&quot;Return the full request URI, optionally including the query string&quot;&quot;&quot;</font>
<font color="red">  65.     url = application_uri(environ)</font>
<font color="red">  66.     from urllib import quote</font>
<font color="red">  67.     path_info = quote(environ.get('PATH_INFO',''),safe='/;=,')</font>
<font color="red">  68.     if not environ.get('SCRIPT_NAME'):</font>
<font color="red">  69.         url += path_info[1:]</font>
<font color="black">  70.     else:</font>
<font color="red">  71.         url += path_info</font>
<font color="red">  72.     if include_query and environ.get('QUERY_STRING'):</font>
<font color="red">  73.         url += '?' + environ['QUERY_STRING']</font>
<font color="red">  74.     return url</font>
<font color="black">  75. </font>
<font color="green">  76. def shift_path_info(environ):</font>
<font color="black">  77.     &quot;&quot;&quot;Shift a name from PATH_INFO to SCRIPT_NAME, returning it</font>
<font color="black">  78. </font>
<font color="black">  79.     If there are no remaining path segments in PATH_INFO, return None.</font>
<font color="black">  80.     Note: 'environ' is modified in-place; use a copy if you need to keep</font>
<font color="black">  81.     the original PATH_INFO or SCRIPT_NAME.</font>
<font color="black">  82. </font>
<font color="black">  83.     Note: when PATH_INFO is just a '/', this returns '' and appends a trailing</font>
<font color="black">  84.     '/' to SCRIPT_NAME, even though empty path segments are normally ignored,</font>
<font color="black">  85.     and SCRIPT_NAME doesn't normally end in a '/'.  This is intentional</font>
<font color="black">  86.     behavior, to ensure that an application can tell the difference between</font>
<font color="black">  87.     '/x' and '/x/' when traversing to objects.</font>
<font color="black">  88.     &quot;&quot;&quot;</font>
<font color="red">  89.     path_info = environ.get('PATH_INFO','')</font>
<font color="red">  90.     if not path_info:</font>
<font color="red">  91.         return None</font>
<font color="black">  92. </font>
<font color="red">  93.     path_parts = path_info.split('/')</font>
<font color="red">  94.     path_parts[1:-1] = [p for p in path_parts[1:-1] if p and p != '.']</font>
<font color="red">  95.     name = path_parts[1]</font>
<font color="red">  96.     del path_parts[1]</font>
<font color="black">  97. </font>
<font color="red">  98.     script_name = environ.get('SCRIPT_NAME','')</font>
<font color="red">  99.     script_name = posixpath.normpath(script_name+'/'+name)</font>
<font color="red"> 100.     if script_name.endswith('/'):</font>
<font color="red"> 101.         script_name = script_name[:-1]</font>
<font color="red"> 102.     if not name and not script_name.endswith('/'):</font>
<font color="red"> 103.         script_name += '/'</font>
<font color="black"> 104. </font>
<font color="red"> 105.     environ['SCRIPT_NAME'] = script_name</font>
<font color="red"> 106.     environ['PATH_INFO']   = '/'.join(path_parts)</font>
<font color="black"> 107. </font>
<font color="black"> 108.     # Special case: '/.' on PATH_INFO doesn't get stripped,</font>
<font color="black"> 109.     # because we don't strip the last element of PATH_INFO</font>
<font color="black"> 110.     # if there's only one path part left.  Instead of fixing this</font>
<font color="black"> 111.     # above, we fix it here so that PATH_INFO gets normalized to</font>
<font color="black"> 112.     # an empty string in the environ.</font>
<font color="red"> 113.     if name=='.':</font>
<font color="red"> 114.         name = None</font>
<font color="red"> 115.     return name</font>
<font color="black"> 116. </font>
<font color="green"> 117. def setup_testing_defaults(environ):</font>
<font color="black"> 118.     &quot;&quot;&quot;Update 'environ' with trivial defaults for testing purposes</font>
<font color="black"> 119. </font>
<font color="black"> 120.     This adds various parameters required for WSGI, including HTTP_HOST,</font>
<font color="black"> 121.     SERVER_NAME, SERVER_PORT, REQUEST_METHOD, SCRIPT_NAME, PATH_INFO,</font>
<font color="black"> 122.     and all of the wsgi.* variables.  It only supplies default values,</font>
<font color="black"> 123.     and does not replace any existing settings for these variables.</font>
<font color="black"> 124. </font>
<font color="black"> 125.     This routine is intended to make it easier for unit tests of WSGI</font>
<font color="black"> 126.     servers and applications to set up dummy environments.  It should *not*</font>
<font color="black"> 127.     be used by actual WSGI servers or applications, since the data is fake!</font>
<font color="black"> 128.     &quot;&quot;&quot;</font>
<font color="black"> 129. </font>
<font color="red"> 130.     environ.setdefault('SERVER_NAME','127.0.0.1')</font>
<font color="red"> 131.     environ.setdefault('SERVER_PROTOCOL','HTTP/1.0')</font>
<font color="black"> 132. </font>
<font color="red"> 133.     environ.setdefault('HTTP_HOST',environ['SERVER_NAME'])</font>
<font color="red"> 134.     environ.setdefault('REQUEST_METHOD','GET')</font>
<font color="black"> 135. </font>
<font color="red"> 136.     if 'SCRIPT_NAME' not in environ and 'PATH_INFO' not in environ:</font>
<font color="red"> 137.         environ.setdefault('SCRIPT_NAME','')</font>
<font color="red"> 138.         environ.setdefault('PATH_INFO','/')</font>
<font color="black"> 139. </font>
<font color="red"> 140.     environ.setdefault('wsgi.version', (1,0))</font>
<font color="red"> 141.     environ.setdefault('wsgi.run_once', 0)</font>
<font color="red"> 142.     environ.setdefault('wsgi.multithread', 0)</font>
<font color="red"> 143.     environ.setdefault('wsgi.multiprocess', 0)</font>
<font color="black"> 144. </font>
<font color="red"> 145.     from StringIO import StringIO</font>
<font color="red"> 146.     environ.setdefault('wsgi.input', StringIO(&quot;&quot;))</font>
<font color="red"> 147.     environ.setdefault('wsgi.errors', StringIO())</font>
<font color="red"> 148.     environ.setdefault('wsgi.url_scheme',guess_scheme(environ))</font>
<font color="black"> 149. </font>
<font color="red"> 150.     if environ['wsgi.url_scheme']=='http':</font>
<font color="red"> 151.         environ.setdefault('SERVER_PORT', '80')</font>
<font color="red"> 152.     elif environ['wsgi.url_scheme']=='https':</font>
<font color="red"> 153.         environ.setdefault('SERVER_PORT', '443')</font>
<font color="black"> 154. </font>
<font color="black"> 155. </font>
<font color="black"> 156. </font>
<font color="green"> 157. _hoppish = {</font>
<font color="green"> 158.     'connection':1, 'keep-alive':1, 'proxy-authenticate':1,</font>
<font color="green"> 159.     'proxy-authorization':1, 'te':1, 'trailers':1, 'transfer-encoding':1,</font>
<font color="green"> 160.     'upgrade':1</font>
<font color="black"> 161. }.__contains__</font>
<font color="black"> 162. </font>
<font color="green"> 163. def is_hop_by_hop(header_name):</font>
<font color="black"> 164.     &quot;&quot;&quot;Return true if 'header_name' is an HTTP/1.1 &quot;Hop-by-Hop&quot; header&quot;&quot;&quot;</font>
<font color="red"> 165.     return _hoppish(header_name.lower())</font>
</pre>

