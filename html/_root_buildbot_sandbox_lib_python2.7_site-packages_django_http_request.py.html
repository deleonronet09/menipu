source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/http/request.py</b><br>


file stats: <b>321 lines, 79 executed: 24.6% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import copy</font>
<font color="green">   4. import re</font>
<font color="green">   5. import sys</font>
<font color="green">   6. from io import BytesIO</font>
<font color="green">   7. from itertools import chain</font>
<font color="black">   8. </font>
<font color="green">   9. from django.conf import settings</font>
<font color="green">  10. from django.core import signing</font>
<font color="green">  11. from django.core.exceptions import DisallowedHost, ImproperlyConfigured</font>
<font color="green">  12. from django.core.files import uploadhandler</font>
<font color="green">  13. from django.http.multipartparser import MultiPartParser, MultiPartParserError</font>
<font color="green">  14. from django.utils import six</font>
<font color="green">  15. from django.utils.datastructures import ImmutableList, MultiValueDict</font>
<font color="green">  16. from django.utils.encoding import (</font>
<font color="black">  17.     escape_uri_path, force_bytes, force_str, force_text, iri_to_uri,</font>
<font color="black">  18. )</font>
<font color="green">  19. from django.utils.http import is_same_domain</font>
<font color="green">  20. from django.utils.six.moves.urllib.parse import (</font>
<font color="black">  21.     parse_qsl, quote, urlencode, urljoin, urlsplit,</font>
<font color="black">  22. )</font>
<font color="black">  23. </font>
<font color="green">  24. RAISE_ERROR = object()</font>
<font color="green">  25. host_validation_re = re.compile(r&quot;^([a-z0-9.-]+|\[[a-f0-9]*:[a-f0-9:]+\])(:\d+)?$&quot;)</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="green">  28. class UnreadablePostError(IOError):</font>
<font color="green">  29.     pass</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. class RawPostDataException(Exception):</font>
<font color="black">  33.     &quot;&quot;&quot;</font>
<font color="black">  34.     You cannot access raw_post_data from a request that has</font>
<font color="black">  35.     multipart/* POST data if it has been accessed via POST,</font>
<font color="black">  36.     FILES, etc..</font>
<font color="green">  37.     &quot;&quot;&quot;</font>
<font color="green">  38.     pass</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. class HttpRequest(object):</font>
<font color="green">  42.     &quot;&quot;&quot;A basic HTTP request.&quot;&quot;&quot;</font>
<font color="black">  43. </font>
<font color="black">  44.     # The encoding used in GET/POST dicts. None means use default setting.</font>
<font color="green">  45.     _encoding = None</font>
<font color="green">  46.     _upload_handlers = []</font>
<font color="black">  47. </font>
<font color="green">  48.     def __init__(self):</font>
<font color="black">  49.         # WARNING: The `WSGIRequest` subclass doesn't call `super`.</font>
<font color="black">  50.         # Any variable assignment made here should also happen in</font>
<font color="black">  51.         # `WSGIRequest.__init__()`.</font>
<font color="black">  52. </font>
<font color="red">  53.         self.GET = QueryDict(mutable=True)</font>
<font color="red">  54.         self.POST = QueryDict(mutable=True)</font>
<font color="red">  55.         self.COOKIES = {}</font>
<font color="red">  56.         self.META = {}</font>
<font color="red">  57.         self.FILES = MultiValueDict()</font>
<font color="black">  58. </font>
<font color="red">  59.         self.path = ''</font>
<font color="red">  60.         self.path_info = ''</font>
<font color="red">  61.         self.method = None</font>
<font color="red">  62.         self.resolver_match = None</font>
<font color="red">  63.         self._post_parse_error = False</font>
<font color="black">  64. </font>
<font color="green">  65.     def __repr__(self):</font>
<font color="red">  66.         if self.method is None or not self.get_full_path():</font>
<font color="red">  67.             return force_str('&lt;%s&gt;' % self.__class__.__name__)</font>
<font color="red">  68.         return force_str(</font>
<font color="red">  69.             '&lt;%s: %s %r&gt;' % (self.__class__.__name__, self.method, force_str(self.get_full_path()))</font>
<font color="black">  70.         )</font>
<font color="black">  71. </font>
<font color="green">  72.     def _get_raw_host(self):</font>
<font color="black">  73.         &quot;&quot;&quot;</font>
<font color="black">  74.         Return the HTTP host using the environment or request headers. Skip</font>
<font color="black">  75.         allowed hosts protection, so may return an insecure host.</font>
<font color="black">  76.         &quot;&quot;&quot;</font>
<font color="black">  77.         # We try three options, in order of decreasing preference.</font>
<font color="red">  78.         if settings.USE_X_FORWARDED_HOST and (</font>
<font color="red">  79.                 'HTTP_X_FORWARDED_HOST' in self.META):</font>
<font color="red">  80.             host = self.META['HTTP_X_FORWARDED_HOST']</font>
<font color="red">  81.         elif 'HTTP_HOST' in self.META:</font>
<font color="red">  82.             host = self.META['HTTP_HOST']</font>
<font color="black">  83.         else:</font>
<font color="black">  84.             # Reconstruct the host using the algorithm from PEP 333.</font>
<font color="red">  85.             host = self.META['SERVER_NAME']</font>
<font color="red">  86.             server_port = self.get_port()</font>
<font color="red">  87.             if server_port != ('443' if self.is_secure() else '80'):</font>
<font color="red">  88.                 host = '%s:%s' % (host, server_port)</font>
<font color="red">  89.         return host</font>
<font color="black">  90. </font>
<font color="green">  91.     def get_host(self):</font>
<font color="black">  92.         &quot;&quot;&quot;Return the HTTP host using the environment or request headers.&quot;&quot;&quot;</font>
<font color="red">  93.         host = self._get_raw_host()</font>
<font color="black">  94. </font>
<font color="black">  95.         # There is no hostname validation when DEBUG=True</font>
<font color="red">  96.         if settings.DEBUG:</font>
<font color="red">  97.             return host</font>
<font color="black">  98. </font>
<font color="red">  99.         domain, port = split_domain_port(host)</font>
<font color="red"> 100.         if domain and validate_host(domain, settings.ALLOWED_HOSTS):</font>
<font color="red"> 101.             return host</font>
<font color="black"> 102.         else:</font>
<font color="red"> 103.             msg = &quot;Invalid HTTP_HOST header: %r.&quot; % host</font>
<font color="red"> 104.             if domain:</font>
<font color="red"> 105.                 msg += &quot; You may need to add %r to ALLOWED_HOSTS.&quot; % domain</font>
<font color="black"> 106.             else:</font>
<font color="red"> 107.                 msg += &quot; The domain name provided is not valid according to RFC 1034/1035.&quot;</font>
<font color="red"> 108.             raise DisallowedHost(msg)</font>
<font color="black"> 109. </font>
<font color="green"> 110.     def get_port(self):</font>
<font color="black"> 111.         &quot;&quot;&quot;Return the port number for the request as a string.&quot;&quot;&quot;</font>
<font color="red"> 112.         if settings.USE_X_FORWARDED_PORT and 'HTTP_X_FORWARDED_PORT' in self.META:</font>
<font color="red"> 113.             port = self.META['HTTP_X_FORWARDED_PORT']</font>
<font color="black"> 114.         else:</font>
<font color="red"> 115.             port = self.META['SERVER_PORT']</font>
<font color="red"> 116.         return str(port)</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def get_full_path(self, force_append_slash=False):</font>
<font color="black"> 119.         # RFC 3986 requires query string arguments to be in the ASCII range.</font>
<font color="black"> 120.         # Rather than crash if this doesn't happen, we encode defensively.</font>
<font color="red"> 121.         return '%s%s%s' % (</font>
<font color="red"> 122.             escape_uri_path(self.path),</font>
<font color="red"> 123.             '/' if force_append_slash and not self.path.endswith('/') else '',</font>
<font color="red"> 124.             ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else ''</font>
<font color="black"> 125.         )</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):</font>
<font color="black"> 128.         &quot;&quot;&quot;</font>
<font color="black"> 129.         Attempts to return a signed cookie. If the signature fails or the</font>
<font color="black"> 130.         cookie has expired, raises an exception... unless you provide the</font>
<font color="black"> 131.         default argument in which case that value will be returned instead.</font>
<font color="black"> 132.         &quot;&quot;&quot;</font>
<font color="red"> 133.         try:</font>
<font color="red"> 134.             cookie_value = self.COOKIES[key]</font>
<font color="red"> 135.         except KeyError:</font>
<font color="red"> 136.             if default is not RAISE_ERROR:</font>
<font color="red"> 137.                 return default</font>
<font color="black"> 138.             else:</font>
<font color="red"> 139.                 raise</font>
<font color="red"> 140.         try:</font>
<font color="red"> 141.             value = signing.get_cookie_signer(salt=key + salt).unsign(</font>
<font color="red"> 142.                 cookie_value, max_age=max_age)</font>
<font color="red"> 143.         except signing.BadSignature:</font>
<font color="red"> 144.             if default is not RAISE_ERROR:</font>
<font color="red"> 145.                 return default</font>
<font color="black"> 146.             else:</font>
<font color="red"> 147.                 raise</font>
<font color="red"> 148.         return value</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def get_raw_uri(self):</font>
<font color="black"> 151.         &quot;&quot;&quot;</font>
<font color="black"> 152.         Return an absolute URI from variables available in this request. Skip</font>
<font color="black"> 153.         allowed hosts protection, so may return insecure URI.</font>
<font color="black"> 154.         &quot;&quot;&quot;</font>
<font color="red"> 155.         return '{scheme}://{host}{path}'.format(</font>
<font color="red"> 156.             scheme=self.scheme,</font>
<font color="red"> 157.             host=self._get_raw_host(),</font>
<font color="red"> 158.             path=self.get_full_path(),</font>
<font color="black"> 159.         )</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def build_absolute_uri(self, location=None):</font>
<font color="black"> 162.         &quot;&quot;&quot;</font>
<font color="black"> 163.         Builds an absolute URI from the location and the variables available in</font>
<font color="black"> 164.         this request. If no ``location`` is specified, the absolute URI is</font>
<font color="black"> 165.         built on ``request.get_full_path()``. Anyway, if the location is</font>
<font color="black"> 166.         absolute, it is simply converted to an RFC 3987 compliant URI and</font>
<font color="black"> 167.         returned and if location is relative or is scheme-relative (i.e.,</font>
<font color="black"> 168.         ``//example.com/``), it is urljoined to a base URL constructed from the</font>
<font color="black"> 169.         request variables.</font>
<font color="black"> 170.         &quot;&quot;&quot;</font>
<font color="red"> 171.         if location is None:</font>
<font color="black"> 172.             # Make it an absolute url (but schemeless and domainless) for the</font>
<font color="black"> 173.             # edge case that the path starts with '//'.</font>
<font color="red"> 174.             location = '//%s' % self.get_full_path()</font>
<font color="red"> 175.         bits = urlsplit(location)</font>
<font color="red"> 176.         if not (bits.scheme and bits.netloc):</font>
<font color="red"> 177.             current_uri = '{scheme}://{host}{path}'.format(scheme=self.scheme,</font>
<font color="red"> 178.                                                            host=self.get_host(),</font>
<font color="red"> 179.                                                            path=self.path)</font>
<font color="black"> 180.             # Join the constructed URL with the provided location, which will</font>
<font color="black"> 181.             # allow the provided ``location`` to apply query strings to the</font>
<font color="black"> 182.             # base path as well as override the host, if it begins with //</font>
<font color="red"> 183.             location = urljoin(current_uri, location)</font>
<font color="red"> 184.         return iri_to_uri(location)</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def _get_scheme(self):</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="black"> 188.         Hook for subclasses like WSGIRequest to implement. Returns 'http' by</font>
<font color="black"> 189.         default.</font>
<font color="black"> 190.         &quot;&quot;&quot;</font>
<font color="red"> 191.         return 'http'</font>
<font color="black"> 192. </font>
<font color="green"> 193.     @property</font>
<font color="black"> 194.     def scheme(self):</font>
<font color="red"> 195.         if settings.SECURE_PROXY_SSL_HEADER:</font>
<font color="red"> 196.             try:</font>
<font color="red"> 197.                 header, value = settings.SECURE_PROXY_SSL_HEADER</font>
<font color="red"> 198.             except ValueError:</font>
<font color="red"> 199.                 raise ImproperlyConfigured(</font>
<font color="red"> 200.                     'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.'</font>
<font color="black"> 201.                 )</font>
<font color="red"> 202.             if self.META.get(header) == value:</font>
<font color="red"> 203.                 return 'https'</font>
<font color="red"> 204.         return self._get_scheme()</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def is_secure(self):</font>
<font color="red"> 207.         return self.scheme == 'https'</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def is_ajax(self):</font>
<font color="red"> 210.         return self.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest'</font>
<font color="black"> 211. </font>
<font color="green"> 212.     @property</font>
<font color="black"> 213.     def encoding(self):</font>
<font color="red"> 214.         return self._encoding</font>
<font color="black"> 215. </font>
<font color="green"> 216.     @encoding.setter</font>
<font color="black"> 217.     def encoding(self, val):</font>
<font color="black"> 218.         &quot;&quot;&quot;</font>
<font color="black"> 219.         Sets the encoding used for GET/POST accesses. If the GET or POST</font>
<font color="black"> 220.         dictionary has already been created, it is removed and recreated on the</font>
<font color="black"> 221.         next access (so that it is decoded correctly).</font>
<font color="black"> 222.         &quot;&quot;&quot;</font>
<font color="red"> 223.         self._encoding = val</font>
<font color="red"> 224.         if hasattr(self, '_get'):</font>
<font color="red"> 225.             del self._get</font>
<font color="red"> 226.         if hasattr(self, '_post'):</font>
<font color="red"> 227.             del self._post</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def _initialize_handlers(self):</font>
<font color="red"> 230.         self._upload_handlers = [uploadhandler.load_handler(handler, self)</font>
<font color="red"> 231.                                  for handler in settings.FILE_UPLOAD_HANDLERS]</font>
<font color="black"> 232. </font>
<font color="green"> 233.     @property</font>
<font color="black"> 234.     def upload_handlers(self):</font>
<font color="red"> 235.         if not self._upload_handlers:</font>
<font color="black"> 236.             # If there are no upload handlers defined, initialize them from settings.</font>
<font color="red"> 237.             self._initialize_handlers()</font>
<font color="red"> 238.         return self._upload_handlers</font>
<font color="black"> 239. </font>
<font color="green"> 240.     @upload_handlers.setter</font>
<font color="black"> 241.     def upload_handlers(self, upload_handlers):</font>
<font color="red"> 242.         if hasattr(self, '_files'):</font>
<font color="red"> 243.             raise AttributeError(&quot;You cannot set the upload handlers after the upload has been processed.&quot;)</font>
<font color="red"> 244.         self._upload_handlers = upload_handlers</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def parse_file_upload(self, META, post_data):</font>
<font color="black"> 247.         &quot;&quot;&quot;Returns a tuple of (POST QueryDict, FILES MultiValueDict).&quot;&quot;&quot;</font>
<font color="red"> 248.         self.upload_handlers = ImmutableList(</font>
<font color="red"> 249.             self.upload_handlers,</font>
<font color="red"> 250.             warning=&quot;You cannot alter upload handlers after the upload has been processed.&quot;</font>
<font color="black"> 251.         )</font>
<font color="red"> 252.         parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)</font>
<font color="red"> 253.         return parser.parse()</font>
<font color="black"> 254. </font>
<font color="green"> 255.     @property</font>
<font color="black"> 256.     def body(self):</font>
<font color="red"> 257.         if not hasattr(self, '_body'):</font>
<font color="red"> 258.             if self._read_started:</font>
<font color="red"> 259.                 raise RawPostDataException(&quot;You cannot access body after reading from request's data stream&quot;)</font>
<font color="red"> 260.             try:</font>
<font color="red"> 261.                 self._body = self.read()</font>
<font color="red"> 262.             except IOError as e:</font>
<font color="red"> 263.                 six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])</font>
<font color="red"> 264.             self._stream = BytesIO(self._body)</font>
<font color="red"> 265.         return self._body</font>
<font color="black"> 266. </font>
<font color="green"> 267.     def _mark_post_parse_error(self):</font>
<font color="red"> 268.         self._post = QueryDict('')</font>
<font color="red"> 269.         self._files = MultiValueDict()</font>
<font color="red"> 270.         self._post_parse_error = True</font>
<font color="black"> 271. </font>
<font color="green"> 272.     def _load_post_and_files(self):</font>
<font color="black"> 273.         &quot;&quot;&quot;Populate self._post and self._files if the content-type is a form type&quot;&quot;&quot;</font>
<font color="red"> 274.         if self.method != 'POST':</font>
<font color="red"> 275.             self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()</font>
<font color="red"> 276.             return</font>
<font color="red"> 277.         if self._read_started and not hasattr(self, '_body'):</font>
<font color="red"> 278.             self._mark_post_parse_error()</font>
<font color="red"> 279.             return</font>
<font color="black"> 280. </font>
<font color="red"> 281.         if self.META.get('CONTENT_TYPE', '').startswith('multipart/form-data'):</font>
<font color="red"> 282.             if hasattr(self, '_body'):</font>
<font color="black"> 283.                 # Use already read data</font>
<font color="red"> 284.                 data = BytesIO(self._body)</font>
<font color="black"> 285.             else:</font>
<font color="red"> 286.                 data = self</font>
<font color="red"> 287.             try:</font>
<font color="red"> 288.                 self._post, self._files = self.parse_file_upload(self.META, data)</font>
<font color="red"> 289.             except MultiPartParserError:</font>
<font color="black"> 290.                 # An error occurred while parsing POST data. Since when</font>
<font color="black"> 291.                 # formatting the error the request handler might access</font>
<font color="black"> 292.                 # self.POST, set self._post and self._file to prevent</font>
<font color="black"> 293.                 # attempts to parse POST data again.</font>
<font color="black"> 294.                 # Mark that an error occurred. This allows self.__repr__ to</font>
<font color="black"> 295.                 # be explicit about it instead of simply representing an</font>
<font color="black"> 296.                 # empty POST</font>
<font color="red"> 297.                 self._mark_post_parse_error()</font>
<font color="red"> 298.                 raise</font>
<font color="red"> 299.         elif self.META.get('CONTENT_TYPE', '').startswith('application/x-www-form-urlencoded'):</font>
<font color="red"> 300.             self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()</font>
<font color="black"> 301.         else:</font>
<font color="red"> 302.             self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def close(self):</font>
<font color="red"> 305.         if hasattr(self, '_files'):</font>
<font color="red"> 306.             for f in chain.from_iterable(l[1] for l in self._files.lists()):</font>
<font color="red"> 307.                 f.close()</font>
<font color="black"> 308. </font>
<font color="black"> 309.     # File-like and iterator interface.</font>
<font color="black"> 310.     #</font>
<font color="black"> 311.     # Expects self._stream to be set to an appropriate source of bytes by</font>
<font color="black"> 312.     # a corresponding request subclass (e.g. WSGIRequest).</font>
<font color="black"> 313.     # Also when request data has already been read by request.POST or</font>
<font color="black"> 314.     # request.body, self._stream points to a BytesIO instance</font>
<font color="black"> 315.     # containing that data.</font>
<font color="black"> 316. </font>
<font color="green"> 317.     def read(self, *args, **kwargs):</font>
<font color="red"> 318.         self._read_started = True</font>
<font color="red"> 319.         try:</font>
<font color="red"> 320.             return self._stream.read(*args, **kwargs)</font>
<font color="red"> 321.         except IOError as e:</font>
<font color="red"> 322.             six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def readline(self, *args, **kwargs):</font>
<font color="red"> 325.         self._read_started = True</font>
<font color="red"> 326.         try:</font>
<font color="red"> 327.             return self._stream.readline(*args, **kwargs)</font>
<font color="red"> 328.         except IOError as e:</font>
<font color="red"> 329.             six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])</font>
<font color="black"> 330. </font>
<font color="green"> 331.     def xreadlines(self):</font>
<font color="red"> 332.         while True:</font>
<font color="red"> 333.             buf = self.readline()</font>
<font color="red"> 334.             if not buf:</font>
<font color="red"> 335.                 break</font>
<font color="red"> 336.             yield buf</font>
<font color="black"> 337. </font>
<font color="green"> 338.     __iter__ = xreadlines</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def readlines(self):</font>
<font color="red"> 341.         return list(iter(self))</font>
<font color="black"> 342. </font>
<font color="black"> 343. </font>
<font color="green"> 344. class QueryDict(MultiValueDict):</font>
<font color="black"> 345.     &quot;&quot;&quot;</font>
<font color="black"> 346.     A specialized MultiValueDict which represents a query string.</font>
<font color="black"> 347. </font>
<font color="black"> 348.     A QueryDict can be used to represent GET or POST data. It subclasses</font>
<font color="black"> 349.     MultiValueDict since keys in such data can be repeated, for instance</font>
<font color="black"> 350.     in the data from a form with a &lt;select multiple&gt; field.</font>
<font color="black"> 351. </font>
<font color="black"> 352.     By default QueryDicts are immutable, though the copy() method</font>
<font color="black"> 353.     will always return a mutable copy.</font>
<font color="black"> 354. </font>
<font color="black"> 355.     Both keys and values set on this class are converted from the given encoding</font>
<font color="black"> 356.     (DEFAULT_CHARSET by default) to unicode.</font>
<font color="green"> 357.     &quot;&quot;&quot;</font>
<font color="black"> 358. </font>
<font color="black"> 359.     # These are both reset in __init__, but is specified here at the class</font>
<font color="black"> 360.     # level so that unpickling will have valid values</font>
<font color="green"> 361.     _mutable = True</font>
<font color="green"> 362.     _encoding = None</font>
<font color="black"> 363. </font>
<font color="green"> 364.     def __init__(self, query_string=None, mutable=False, encoding=None):</font>
<font color="red"> 365.         super(QueryDict, self).__init__()</font>
<font color="red"> 366.         if not encoding:</font>
<font color="red"> 367.             encoding = settings.DEFAULT_CHARSET</font>
<font color="red"> 368.         self.encoding = encoding</font>
<font color="red"> 369.         if six.PY3:</font>
<font color="red"> 370.             if isinstance(query_string, bytes):</font>
<font color="black"> 371.                 # query_string normally contains URL-encoded data, a subset of ASCII.</font>
<font color="red"> 372.                 try:</font>
<font color="red"> 373.                     query_string = query_string.decode(encoding)</font>
<font color="red"> 374.                 except UnicodeDecodeError:</font>
<font color="black"> 375.                     # ... but some user agents are misbehaving :-(</font>
<font color="red"> 376.                     query_string = query_string.decode('iso-8859-1')</font>
<font color="red"> 377.             for key, value in parse_qsl(query_string or '',</font>
<font color="red"> 378.                                         keep_blank_values=True,</font>
<font color="red"> 379.                                         encoding=encoding):</font>
<font color="red"> 380.                 self.appendlist(key, value)</font>
<font color="black"> 381.         else:</font>
<font color="red"> 382.             for key, value in parse_qsl(query_string or '',</font>
<font color="red"> 383.                                         keep_blank_values=True):</font>
<font color="red"> 384.                 try:</font>
<font color="red"> 385.                     value = value.decode(encoding)</font>
<font color="red"> 386.                 except UnicodeDecodeError:</font>
<font color="red"> 387.                     value = value.decode('iso-8859-1')</font>
<font color="red"> 388.                 self.appendlist(force_text(key, encoding, errors='replace'),</font>
<font color="red"> 389.                                 value)</font>
<font color="red"> 390.         self._mutable = mutable</font>
<font color="black"> 391. </font>
<font color="green"> 392.     @property</font>
<font color="black"> 393.     def encoding(self):</font>
<font color="red"> 394.         if self._encoding is None:</font>
<font color="red"> 395.             self._encoding = settings.DEFAULT_CHARSET</font>
<font color="red"> 396.         return self._encoding</font>
<font color="black"> 397. </font>
<font color="green"> 398.     @encoding.setter</font>
<font color="black"> 399.     def encoding(self, value):</font>
<font color="red"> 400.         self._encoding = value</font>
<font color="black"> 401. </font>
<font color="green"> 402.     def _assert_mutable(self):</font>
<font color="red"> 403.         if not self._mutable:</font>
<font color="red"> 404.             raise AttributeError(&quot;This QueryDict instance is immutable&quot;)</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def __setitem__(self, key, value):</font>
<font color="red"> 407.         self._assert_mutable()</font>
<font color="red"> 408.         key = bytes_to_text(key, self.encoding)</font>
<font color="red"> 409.         value = bytes_to_text(value, self.encoding)</font>
<font color="red"> 410.         super(QueryDict, self).__setitem__(key, value)</font>
<font color="black"> 411. </font>
<font color="green"> 412.     def __delitem__(self, key):</font>
<font color="red"> 413.         self._assert_mutable()</font>
<font color="red"> 414.         super(QueryDict, self).__delitem__(key)</font>
<font color="black"> 415. </font>
<font color="green"> 416.     def __copy__(self):</font>
<font color="red"> 417.         result = self.__class__('', mutable=True, encoding=self.encoding)</font>
<font color="red"> 418.         for key, value in six.iterlists(self):</font>
<font color="red"> 419.             result.setlist(key, value)</font>
<font color="red"> 420.         return result</font>
<font color="black"> 421. </font>
<font color="green"> 422.     def __deepcopy__(self, memo):</font>
<font color="red"> 423.         result = self.__class__('', mutable=True, encoding=self.encoding)</font>
<font color="red"> 424.         memo[id(self)] = result</font>
<font color="red"> 425.         for key, value in six.iterlists(self):</font>
<font color="red"> 426.             result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))</font>
<font color="red"> 427.         return result</font>
<font color="black"> 428. </font>
<font color="green"> 429.     def setlist(self, key, list_):</font>
<font color="red"> 430.         self._assert_mutable()</font>
<font color="red"> 431.         key = bytes_to_text(key, self.encoding)</font>
<font color="red"> 432.         list_ = [bytes_to_text(elt, self.encoding) for elt in list_]</font>
<font color="red"> 433.         super(QueryDict, self).setlist(key, list_)</font>
<font color="black"> 434. </font>
<font color="green"> 435.     def setlistdefault(self, key, default_list=None):</font>
<font color="red"> 436.         self._assert_mutable()</font>
<font color="red"> 437.         return super(QueryDict, self).setlistdefault(key, default_list)</font>
<font color="black"> 438. </font>
<font color="green"> 439.     def appendlist(self, key, value):</font>
<font color="red"> 440.         self._assert_mutable()</font>
<font color="red"> 441.         key = bytes_to_text(key, self.encoding)</font>
<font color="red"> 442.         value = bytes_to_text(value, self.encoding)</font>
<font color="red"> 443.         super(QueryDict, self).appendlist(key, value)</font>
<font color="black"> 444. </font>
<font color="green"> 445.     def pop(self, key, *args):</font>
<font color="red"> 446.         self._assert_mutable()</font>
<font color="red"> 447.         return super(QueryDict, self).pop(key, *args)</font>
<font color="black"> 448. </font>
<font color="green"> 449.     def popitem(self):</font>
<font color="red"> 450.         self._assert_mutable()</font>
<font color="red"> 451.         return super(QueryDict, self).popitem()</font>
<font color="black"> 452. </font>
<font color="green"> 453.     def clear(self):</font>
<font color="red"> 454.         self._assert_mutable()</font>
<font color="red"> 455.         super(QueryDict, self).clear()</font>
<font color="black"> 456. </font>
<font color="green"> 457.     def setdefault(self, key, default=None):</font>
<font color="red"> 458.         self._assert_mutable()</font>
<font color="red"> 459.         key = bytes_to_text(key, self.encoding)</font>
<font color="red"> 460.         default = bytes_to_text(default, self.encoding)</font>
<font color="red"> 461.         return super(QueryDict, self).setdefault(key, default)</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def copy(self):</font>
<font color="black"> 464.         &quot;&quot;&quot;Returns a mutable copy of this object.&quot;&quot;&quot;</font>
<font color="red"> 465.         return self.__deepcopy__({})</font>
<font color="black"> 466. </font>
<font color="green"> 467.     def urlencode(self, safe=None):</font>
<font color="black"> 468.         &quot;&quot;&quot;</font>
<font color="black"> 469.         Returns an encoded string of all query string arguments.</font>
<font color="black"> 470. </font>
<font color="black"> 471.         :arg safe: Used to specify characters which do not require quoting, for</font>
<font color="black"> 472.             example::</font>
<font color="black"> 473. </font>
<font color="black"> 474.                 &gt;&gt;&gt; q = QueryDict('', mutable=True)</font>
<font color="black"> 475.                 &gt;&gt;&gt; q['next'] = '/a&amp;b/'</font>
<font color="black"> 476.                 &gt;&gt;&gt; q.urlencode()</font>
<font color="black"> 477.                 'next=%2Fa%26b%2F'</font>
<font color="black"> 478.                 &gt;&gt;&gt; q.urlencode(safe='/')</font>
<font color="black"> 479.                 'next=/a%26b/'</font>
<font color="black"> 480.         &quot;&quot;&quot;</font>
<font color="red"> 481.         output = []</font>
<font color="red"> 482.         if safe:</font>
<font color="red"> 483.             safe = force_bytes(safe, self.encoding)</font>
<font color="red"> 484.             encode = lambda k, v: '%s=%s' % ((quote(k, safe), quote(v, safe)))</font>
<font color="black"> 485.         else:</font>
<font color="red"> 486.             encode = lambda k, v: urlencode({k: v})</font>
<font color="red"> 487.         for k, list_ in self.lists():</font>
<font color="red"> 488.             k = force_bytes(k, self.encoding)</font>
<font color="red"> 489.             output.extend(encode(k, force_bytes(v, self.encoding))</font>
<font color="red"> 490.                           for v in list_)</font>
<font color="red"> 491.         return '&amp;'.join(output)</font>
<font color="black"> 492. </font>
<font color="black"> 493. </font>
<font color="black"> 494. # It's neither necessary nor appropriate to use</font>
<font color="black"> 495. # django.utils.encoding.smart_text for parsing URLs and form inputs. Thus,</font>
<font color="black"> 496. # this slightly more restricted function, used by QueryDict.</font>
<font color="green"> 497. def bytes_to_text(s, encoding):</font>
<font color="black"> 498.     &quot;&quot;&quot;</font>
<font color="black"> 499.     Converts basestring objects to unicode, using the given encoding. Illegally</font>
<font color="black"> 500.     encoded input characters are replaced with Unicode &quot;unknown&quot; codepoint</font>
<font color="black"> 501.     (\ufffd).</font>
<font color="black"> 502. </font>
<font color="black"> 503.     Returns any non-basestring objects without change.</font>
<font color="black"> 504.     &quot;&quot;&quot;</font>
<font color="red"> 505.     if isinstance(s, bytes):</font>
<font color="red"> 506.         return six.text_type(s, encoding, 'replace')</font>
<font color="black"> 507.     else:</font>
<font color="red"> 508.         return s</font>
<font color="black"> 509. </font>
<font color="black"> 510. </font>
<font color="green"> 511. def split_domain_port(host):</font>
<font color="black"> 512.     &quot;&quot;&quot;</font>
<font color="black"> 513.     Return a (domain, port) tuple from a given host.</font>
<font color="black"> 514. </font>
<font color="black"> 515.     Returned domain is lower-cased. If the host is invalid, the domain will be</font>
<font color="black"> 516.     empty.</font>
<font color="black"> 517.     &quot;&quot;&quot;</font>
<font color="red"> 518.     host = host.lower()</font>
<font color="black"> 519. </font>
<font color="red"> 520.     if not host_validation_re.match(host):</font>
<font color="red"> 521.         return '', ''</font>
<font color="black"> 522. </font>
<font color="red"> 523.     if host[-1] == ']':</font>
<font color="black"> 524.         # It's an IPv6 address without a port.</font>
<font color="red"> 525.         return host, ''</font>
<font color="red"> 526.     bits = host.rsplit(':', 1)</font>
<font color="red"> 527.     if len(bits) == 2:</font>
<font color="red"> 528.         return tuple(bits)</font>
<font color="red"> 529.     return bits[0], ''</font>
<font color="black"> 530. </font>
<font color="black"> 531. </font>
<font color="green"> 532. def validate_host(host, allowed_hosts):</font>
<font color="black"> 533.     &quot;&quot;&quot;</font>
<font color="black"> 534.     Validate the given host for this site.</font>
<font color="black"> 535. </font>
<font color="black"> 536.     Check that the host looks valid and matches a host or host pattern in the</font>
<font color="black"> 537.     given list of ``allowed_hosts``. Any pattern beginning with a period</font>
<font color="black"> 538.     matches a domain and all its subdomains (e.g. ``.example.com`` matches</font>
<font color="black"> 539.     ``example.com`` and any subdomain), ``*`` matches anything, and anything</font>
<font color="black"> 540.     else must match exactly.</font>
<font color="black"> 541. </font>
<font color="black"> 542.     Note: This function assumes that the given host is lower-cased and has</font>
<font color="black"> 543.     already had the port, if any, stripped off.</font>
<font color="black"> 544. </font>
<font color="black"> 545.     Return ``True`` for a valid host, ``False`` otherwise.</font>
<font color="black"> 546.     &quot;&quot;&quot;</font>
<font color="red"> 547.     host = host[:-1] if host.endswith('.') else host</font>
<font color="black"> 548. </font>
<font color="red"> 549.     for pattern in allowed_hosts:</font>
<font color="red"> 550.         if pattern == '*' or is_same_domain(host, pattern):</font>
<font color="red"> 551.             return True</font>
<font color="black"> 552. </font>
<font color="red"> 553.     return False</font>
</pre>

