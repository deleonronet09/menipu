source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/encoding.py</b><br>


file stats: <b>115 lines, 60 executed: 52.2% covered</b>
<pre>
<font color="black">   1. # -*- encoding: utf-8 -*-</font>
<font color="green">   2. from __future__ import unicode_literals</font>
<font color="black">   3. </font>
<font color="green">   4. import codecs</font>
<font color="green">   5. import datetime</font>
<font color="green">   6. import locale</font>
<font color="green">   7. from decimal import Decimal</font>
<font color="black">   8. </font>
<font color="green">   9. from django.utils import six</font>
<font color="green">  10. from django.utils.functional import Promise</font>
<font color="green">  11. from django.utils.six.moves.urllib.parse import quote, unquote</font>
<font color="black">  12. </font>
<font color="green">  13. if six.PY3:</font>
<font color="red">  14.     from urllib.parse import unquote_to_bytes</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. class DjangoUnicodeDecodeError(UnicodeDecodeError):</font>
<font color="green">  18.     def __init__(self, obj, *args):</font>
<font color="red">  19.         self.obj = obj</font>
<font color="red">  20.         UnicodeDecodeError.__init__(self, *args)</font>
<font color="black">  21. </font>
<font color="green">  22.     def __str__(self):</font>
<font color="red">  23.         original = UnicodeDecodeError.__str__(self)</font>
<font color="red">  24.         return '%s. You passed in %r (%s)' % (original, self.obj,</font>
<font color="red">  25.                 type(self.obj))</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="black">  28. # For backwards compatibility. (originally in Django, then added to six 1.9)</font>
<font color="green">  29. python_2_unicode_compatible = six.python_2_unicode_compatible</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. def smart_text(s, encoding='utf-8', strings_only=False, errors='strict'):</font>
<font color="black">  33.     &quot;&quot;&quot;</font>
<font color="black">  34.     Returns a text object representing 's' -- unicode on Python 2 and str on</font>
<font color="black">  35.     Python 3. Treats bytestrings using the 'encoding' codec.</font>
<font color="black">  36. </font>
<font color="black">  37.     If strings_only is True, don't convert (some) non-string-like objects.</font>
<font color="black">  38.     &quot;&quot;&quot;</font>
<font color="green">  39.     if isinstance(s, Promise):</font>
<font color="black">  40.         # The input is the result of a gettext_lazy() call.</font>
<font color="red">  41.         return s</font>
<font color="green">  42.     return force_text(s, encoding, strings_only, errors)</font>
<font color="black">  43. </font>
<font color="black">  44. </font>
<font color="green">  45. _PROTECTED_TYPES = six.integer_types + (type(None), float, Decimal,</font>
<font color="green">  46.     datetime.datetime, datetime.date, datetime.time)</font>
<font color="black">  47. </font>
<font color="black">  48. </font>
<font color="green">  49. def is_protected_type(obj):</font>
<font color="black">  50.     &quot;&quot;&quot;Determine if the object instance is of a protected type.</font>
<font color="black">  51. </font>
<font color="black">  52.     Objects of protected types are preserved as-is when passed to</font>
<font color="black">  53.     force_text(strings_only=True).</font>
<font color="black">  54.     &quot;&quot;&quot;</font>
<font color="green">  55.     return isinstance(obj, _PROTECTED_TYPES)</font>
<font color="black">  56. </font>
<font color="black">  57. </font>
<font color="green">  58. def force_text(s, encoding='utf-8', strings_only=False, errors='strict'):</font>
<font color="black">  59.     &quot;&quot;&quot;</font>
<font color="black">  60.     Similar to smart_text, except that lazy instances are resolved to</font>
<font color="black">  61.     strings, rather than kept as lazy objects.</font>
<font color="black">  62. </font>
<font color="black">  63.     If strings_only is True, don't convert (some) non-string-like objects.</font>
<font color="black">  64.     &quot;&quot;&quot;</font>
<font color="black">  65.     # Handle the common case first for performance reasons.</font>
<font color="green">  66.     if issubclass(type(s), six.text_type):</font>
<font color="green">  67.         return s</font>
<font color="green">  68.     if strings_only and is_protected_type(s):</font>
<font color="green">  69.         return s</font>
<font color="green">  70.     try:</font>
<font color="green">  71.         if not issubclass(type(s), six.string_types):</font>
<font color="green">  72.             if six.PY3:</font>
<font color="red">  73.                 if isinstance(s, bytes):</font>
<font color="red">  74.                     s = six.text_type(s, encoding, errors)</font>
<font color="black">  75.                 else:</font>
<font color="red">  76.                     s = six.text_type(s)</font>
<font color="green">  77.             elif hasattr(s, '__unicode__'):</font>
<font color="green">  78.                 s = six.text_type(s)</font>
<font color="black">  79.             else:</font>
<font color="red">  80.                 s = six.text_type(bytes(s), encoding, errors)</font>
<font color="black">  81.         else:</font>
<font color="black">  82.             # Note: We use .decode() here, instead of six.text_type(s, encoding,</font>
<font color="black">  83.             # errors), so that if s is a SafeBytes, it ends up being a</font>
<font color="black">  84.             # SafeText at the end.</font>
<font color="green">  85.             s = s.decode(encoding, errors)</font>
<font color="red">  86.     except UnicodeDecodeError as e:</font>
<font color="red">  87.         if not isinstance(s, Exception):</font>
<font color="red">  88.             raise DjangoUnicodeDecodeError(s, *e.args)</font>
<font color="black">  89.         else:</font>
<font color="black">  90.             # If we get to here, the caller has passed in an Exception</font>
<font color="black">  91.             # subclass populated with non-ASCII bytestring data without a</font>
<font color="black">  92.             # working unicode method. Try to handle this without raising a</font>
<font color="black">  93.             # further exception by individually forcing the exception args</font>
<font color="black">  94.             # to unicode.</font>
<font color="red">  95.             s = ' '.join(force_text(arg, encoding, strings_only, errors)</font>
<font color="red">  96.                          for arg in s)</font>
<font color="green">  97.     return s</font>
<font color="black">  98. </font>
<font color="black">  99. </font>
<font color="green"> 100. def smart_bytes(s, encoding='utf-8', strings_only=False, errors='strict'):</font>
<font color="black"> 101.     &quot;&quot;&quot;</font>
<font color="black"> 102.     Returns a bytestring version of 's', encoded as specified in 'encoding'.</font>
<font color="black"> 103. </font>
<font color="black"> 104.     If strings_only is True, don't convert (some) non-string-like objects.</font>
<font color="black"> 105.     &quot;&quot;&quot;</font>
<font color="red"> 106.     if isinstance(s, Promise):</font>
<font color="black"> 107.         # The input is the result of a gettext_lazy() call.</font>
<font color="red"> 108.         return s</font>
<font color="red"> 109.     return force_bytes(s, encoding, strings_only, errors)</font>
<font color="black"> 110. </font>
<font color="black"> 111. </font>
<font color="green"> 112. def force_bytes(s, encoding='utf-8', strings_only=False, errors='strict'):</font>
<font color="black"> 113.     &quot;&quot;&quot;</font>
<font color="black"> 114.     Similar to smart_bytes, except that lazy instances are resolved to</font>
<font color="black"> 115.     strings, rather than kept as lazy objects.</font>
<font color="black"> 116. </font>
<font color="black"> 117.     If strings_only is True, don't convert (some) non-string-like objects.</font>
<font color="black"> 118.     &quot;&quot;&quot;</font>
<font color="black"> 119.     # Handle the common case first for performance reasons.</font>
<font color="green"> 120.     if isinstance(s, bytes):</font>
<font color="green"> 121.         if encoding == 'utf-8':</font>
<font color="green"> 122.             return s</font>
<font color="black"> 123.         else:</font>
<font color="red"> 124.             return s.decode('utf-8', errors).encode(encoding, errors)</font>
<font color="green"> 125.     if strings_only and is_protected_type(s):</font>
<font color="red"> 126.         return s</font>
<font color="green"> 127.     if isinstance(s, six.memoryview):</font>
<font color="red"> 128.         return bytes(s)</font>
<font color="green"> 129.     if isinstance(s, Promise):</font>
<font color="red"> 130.         return six.text_type(s).encode(encoding, errors)</font>
<font color="green"> 131.     if not isinstance(s, six.string_types):</font>
<font color="red"> 132.         try:</font>
<font color="red"> 133.             if six.PY3:</font>
<font color="red"> 134.                 return six.text_type(s).encode(encoding)</font>
<font color="black"> 135.             else:</font>
<font color="red"> 136.                 return bytes(s)</font>
<font color="red"> 137.         except UnicodeEncodeError:</font>
<font color="red"> 138.             if isinstance(s, Exception):</font>
<font color="black"> 139.                 # An Exception subclass containing non-ASCII data that doesn't</font>
<font color="black"> 140.                 # know how to print itself properly. We shouldn't raise a</font>
<font color="black"> 141.                 # further exception.</font>
<font color="red"> 142.                 return b' '.join(force_bytes(arg, encoding, strings_only, errors)</font>
<font color="red"> 143.                                  for arg in s)</font>
<font color="red"> 144.             return six.text_type(s).encode(encoding, errors)</font>
<font color="black"> 145.     else:</font>
<font color="green"> 146.         return s.encode(encoding, errors)</font>
<font color="black"> 147. </font>
<font color="green"> 148. if six.PY3:</font>
<font color="red"> 149.     smart_str = smart_text</font>
<font color="red"> 150.     force_str = force_text</font>
<font color="black"> 151. else:</font>
<font color="green"> 152.     smart_str = smart_bytes</font>
<font color="green"> 153.     force_str = force_bytes</font>
<font color="black"> 154.     # backwards compatibility for Python 2</font>
<font color="green"> 155.     smart_unicode = smart_text</font>
<font color="green"> 156.     force_unicode = force_text</font>
<font color="black"> 157. </font>
<font color="black"> 158. smart_str.__doc__ = &quot;&quot;&quot;</font>
<font color="black"> 159. Apply smart_text in Python 3 and smart_bytes in Python 2.</font>
<font color="black"> 160. </font>
<font color="black"> 161. This is suitable for writing to sys.stdout (for instance).</font>
<font color="green"> 162. &quot;&quot;&quot;</font>
<font color="black"> 163. </font>
<font color="black"> 164. force_str.__doc__ = &quot;&quot;&quot;</font>
<font color="black"> 165. Apply force_text in Python 3 and force_bytes in Python 2.</font>
<font color="green"> 166. &quot;&quot;&quot;</font>
<font color="black"> 167. </font>
<font color="black"> 168. </font>
<font color="green"> 169. def iri_to_uri(iri):</font>
<font color="black"> 170.     &quot;&quot;&quot;</font>
<font color="black"> 171.     Convert an Internationalized Resource Identifier (IRI) portion to a URI</font>
<font color="black"> 172.     portion that is suitable for inclusion in a URL.</font>
<font color="black"> 173. </font>
<font color="black"> 174.     This is the algorithm from section 3.1 of RFC 3987.  However, since we are</font>
<font color="black"> 175.     assuming input is either UTF-8 or unicode already, we can simplify things a</font>
<font color="black"> 176.     little from the full method.</font>
<font color="black"> 177. </font>
<font color="black"> 178.     Takes an IRI in UTF-8 bytes (e.g. '/I \xe2\x99\xa5 Django/') or unicode</font>
<font color="black"> 179.     (e.g. '/I ♥ Django/') and returns ASCII bytes containing the encoded result</font>
<font color="black"> 180.     (e.g. '/I%20%E2%99%A5%20Django/').</font>
<font color="black"> 181.     &quot;&quot;&quot;</font>
<font color="black"> 182.     # The list of safe characters here is constructed from the &quot;reserved&quot; and</font>
<font color="black"> 183.     # &quot;unreserved&quot; characters specified in sections 2.2 and 2.3 of RFC 3986:</font>
<font color="black"> 184.     #     reserved    = gen-delims / sub-delims</font>
<font color="black"> 185.     #     gen-delims  = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot;</font>
<font color="black"> 186.     #     sub-delims  = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot;</font>
<font color="black"> 187.     #                   / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;</font>
<font color="black"> 188.     #     unreserved  = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</font>
<font color="black"> 189.     # Of the unreserved characters, urllib.quote already considers all but</font>
<font color="black"> 190.     # the ~ safe.</font>
<font color="black"> 191.     # The % character is also added to the list of safe characters here, as the</font>
<font color="black"> 192.     # end of section 3.1 of RFC 3987 specifically mentions that % must not be</font>
<font color="black"> 193.     # converted.</font>
<font color="red"> 194.     if iri is None:</font>
<font color="red"> 195.         return iri</font>
<font color="red"> 196.     return quote(force_bytes(iri), safe=b&quot;/#%[]=:;$&amp;()+,!?*@'~&quot;)</font>
<font color="black"> 197. </font>
<font color="black"> 198. </font>
<font color="green"> 199. def uri_to_iri(uri):</font>
<font color="black"> 200.     &quot;&quot;&quot;</font>
<font color="black"> 201.     Converts a Uniform Resource Identifier(URI) into an Internationalized</font>
<font color="black"> 202.     Resource Identifier(IRI).</font>
<font color="black"> 203. </font>
<font color="black"> 204.     This is the algorithm from section 3.2 of RFC 3987.</font>
<font color="black"> 205. </font>
<font color="black"> 206.     Takes an URI in ASCII bytes (e.g. '/I%20%E2%99%A5%20Django/') and returns</font>
<font color="black"> 207.     unicode containing the encoded result (e.g. '/I \xe2\x99\xa5 Django/').</font>
<font color="black"> 208.     &quot;&quot;&quot;</font>
<font color="red"> 209.     if uri is None:</font>
<font color="red"> 210.         return uri</font>
<font color="red"> 211.     uri = force_bytes(uri)</font>
<font color="red"> 212.     iri = unquote_to_bytes(uri) if six.PY3 else unquote(uri)</font>
<font color="red"> 213.     return repercent_broken_unicode(iri).decode('utf-8')</font>
<font color="black"> 214. </font>
<font color="black"> 215. </font>
<font color="green"> 216. def escape_uri_path(path):</font>
<font color="black"> 217.     &quot;&quot;&quot;</font>
<font color="black"> 218.     Escape the unsafe characters from the path portion of a Uniform Resource</font>
<font color="black"> 219.     Identifier (URI).</font>
<font color="black"> 220.     &quot;&quot;&quot;</font>
<font color="black"> 221.     # These are the &quot;reserved&quot; and &quot;unreserved&quot; characters specified in</font>
<font color="black"> 222.     # sections 2.2 and 2.3 of RFC 2396:</font>
<font color="black"> 223.     #   reserved    = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;</font>
<font color="black"> 224.     #   unreserved  = alphanum | mark</font>
<font color="black"> 225.     #   mark        = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;'&quot; | &quot;(&quot; | &quot;)&quot;</font>
<font color="black"> 226.     # The list of safe characters here is constructed subtracting &quot;;&quot;, &quot;=&quot;,</font>
<font color="black"> 227.     # and &quot;?&quot; according to section 3.3 of RFC 2396.</font>
<font color="black"> 228.     # The reason for not subtracting and escaping &quot;/&quot; is that we are escaping</font>
<font color="black"> 229.     # the entire path, not a path segment.</font>
<font color="red"> 230.     return quote(force_bytes(path), safe=b&quot;/:@&amp;+$,-_.!~*'()&quot;)</font>
<font color="black"> 231. </font>
<font color="black"> 232. </font>
<font color="green"> 233. def repercent_broken_unicode(path):</font>
<font color="black"> 234.     &quot;&quot;&quot;</font>
<font color="black"> 235.     As per section 3.2 of RFC 3987, step three of converting a URI into an IRI,</font>
<font color="black"> 236.     we need to re-percent-encode any octet produced that is not part of a</font>
<font color="black"> 237.     strictly legal UTF-8 octet sequence.</font>
<font color="black"> 238.     &quot;&quot;&quot;</font>
<font color="red"> 239.     try:</font>
<font color="red"> 240.         path.decode('utf-8')</font>
<font color="red"> 241.     except UnicodeDecodeError as e:</font>
<font color="red"> 242.         repercent = quote(path[e.start:e.end], safe=b&quot;/#%[]=:;$&amp;()+,!?*@'~&quot;)</font>
<font color="red"> 243.         path = repercent_broken_unicode(</font>
<font color="red"> 244.             path[:e.start] + force_bytes(repercent) + path[e.end:])</font>
<font color="red"> 245.     return path</font>
<font color="black"> 246. </font>
<font color="black"> 247. </font>
<font color="green"> 248. def filepath_to_uri(path):</font>
<font color="black"> 249.     &quot;&quot;&quot;Convert a file system path to a URI portion that is suitable for</font>
<font color="black"> 250.     inclusion in a URL.</font>
<font color="black"> 251. </font>
<font color="black"> 252.     We are assuming input is either UTF-8 or unicode already.</font>
<font color="black"> 253. </font>
<font color="black"> 254.     This method will encode certain chars that would normally be recognized as</font>
<font color="black"> 255.     special chars for URIs.  Note that this method does not encode the '</font>
<font color="black"> 256.     character, as it is a valid character within URIs.  See</font>
<font color="black"> 257.     encodeURIComponent() JavaScript function for more details.</font>
<font color="black"> 258. </font>
<font color="black"> 259.     Returns an ASCII string containing the encoded result.</font>
<font color="black"> 260.     &quot;&quot;&quot;</font>
<font color="red"> 261.     if path is None:</font>
<font color="red"> 262.         return path</font>
<font color="black"> 263.     # I know about `os.sep` and `os.altsep` but I want to leave</font>
<font color="black"> 264.     # some flexibility for hardcoding separators.</font>
<font color="red"> 265.     return quote(force_bytes(path).replace(b&quot;\\&quot;, b&quot;/&quot;), safe=b&quot;/~!*()'&quot;)</font>
<font color="black"> 266. </font>
<font color="black"> 267. </font>
<font color="green"> 268. def get_system_encoding():</font>
<font color="black"> 269.     &quot;&quot;&quot;</font>
<font color="black"> 270.     The encoding of the default system locale but falls back to the given</font>
<font color="black"> 271.     fallback encoding if the encoding is unsupported by python or could</font>
<font color="black"> 272.     not be determined.  See tickets #10335 and #5846</font>
<font color="black"> 273.     &quot;&quot;&quot;</font>
<font color="green"> 274.     try:</font>
<font color="green"> 275.         encoding = locale.getdefaultlocale()[1] or 'ascii'</font>
<font color="green"> 276.         codecs.lookup(encoding)</font>
<font color="red"> 277.     except Exception:</font>
<font color="red"> 278.         encoding = 'ascii'</font>
<font color="green"> 279.     return encoding</font>
<font color="black"> 280. </font>
<font color="green"> 281. DEFAULT_LOCALE_ENCODING = get_system_encoding()</font>
</pre>

