source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/template/base.py</b><br>


file stats: <b>629 lines, 142 executed: 22.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. This is the Django template system.</font>
<font color="black">   3. </font>
<font color="black">   4. How it works:</font>
<font color="black">   5. </font>
<font color="black">   6. The Lexer.tokenize() function converts a template string (i.e., a string containing</font>
<font color="black">   7. markup with custom template tags) to tokens, which can be either plain text</font>
<font color="black">   8. (TOKEN_TEXT), variables (TOKEN_VAR) or block statements (TOKEN_BLOCK).</font>
<font color="black">   9. </font>
<font color="black">  10. The Parser() class takes a list of tokens in its constructor, and its parse()</font>
<font color="black">  11. method returns a compiled template -- which is, under the hood, a list of</font>
<font color="black">  12. Node objects.</font>
<font color="black">  13. </font>
<font color="black">  14. Each Node is responsible for creating some sort of output -- e.g. simple text</font>
<font color="black">  15. (TextNode), variable values in a given context (VariableNode), results of basic</font>
<font color="black">  16. logic (IfNode), results of looping (ForNode), or anything else. The core Node</font>
<font color="black">  17. types are TextNode, VariableNode, IfNode and ForNode, but plugin modules can</font>
<font color="black">  18. define their own custom node types.</font>
<font color="black">  19. </font>
<font color="black">  20. Each Node has a render() method, which takes a Context and returns a string of</font>
<font color="black">  21. the rendered node. For example, the render() method of a Variable Node returns</font>
<font color="black">  22. the variable's value as a string. The render() method of a ForNode returns the</font>
<font color="black">  23. rendered output of whatever was inside the loop, recursively.</font>
<font color="black">  24. </font>
<font color="black">  25. The Template class is a convenient wrapper that takes care of template</font>
<font color="black">  26. compilation and rendering.</font>
<font color="black">  27. </font>
<font color="black">  28. Usage:</font>
<font color="black">  29. </font>
<font color="black">  30. The only thing you should ever use directly in this file is the Template class.</font>
<font color="black">  31. Create a compiled template object with a template_string, then call render()</font>
<font color="black">  32. with a context. In the compilation stage, the TemplateSyntaxError exception</font>
<font color="black">  33. will be raised if the template doesn't have proper syntax.</font>
<font color="black">  34. </font>
<font color="black">  35. Sample code:</font>
<font color="black">  36. </font>
<font color="black">  37. &gt;&gt;&gt; from django import template</font>
<font color="black">  38. &gt;&gt;&gt; s = '&lt;html&gt;{% if test %}&lt;h1&gt;{{ varvalue }}&lt;/h1&gt;{% endif %}&lt;/html&gt;'</font>
<font color="black">  39. &gt;&gt;&gt; t = template.Template(s)</font>
<font color="black">  40. </font>
<font color="black">  41. (t is now a compiled template, and its render() method can be called multiple</font>
<font color="black">  42. times with multiple contexts)</font>
<font color="black">  43. </font>
<font color="black">  44. &gt;&gt;&gt; c = template.Context({'test':True, 'varvalue': 'Hello'})</font>
<font color="black">  45. &gt;&gt;&gt; t.render(c)</font>
<font color="black">  46. '&lt;html&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/html&gt;'</font>
<font color="black">  47. &gt;&gt;&gt; c = template.Context({'test':False, 'varvalue': 'Hello'})</font>
<font color="black">  48. &gt;&gt;&gt; t.render(c)</font>
<font color="black">  49. '&lt;html&gt;&lt;/html&gt;'</font>
<font color="green">  50. &quot;&quot;&quot;</font>
<font color="black">  51. </font>
<font color="green">  52. from __future__ import unicode_literals</font>
<font color="black">  53. </font>
<font color="green">  54. import inspect</font>
<font color="green">  55. import logging</font>
<font color="green">  56. import re</font>
<font color="green">  57. import warnings</font>
<font color="black">  58. </font>
<font color="green">  59. from django.template.context import (  # NOQA: imported for backwards compatibility</font>
<font color="black">  60.     BaseContext, Context, ContextPopException, RequestContext,</font>
<font color="black">  61. )</font>
<font color="green">  62. from django.utils import six</font>
<font color="green">  63. from django.utils.deprecation import (</font>
<font color="black">  64.     DeprecationInstanceCheck, RemovedInDjango20Warning,</font>
<font color="black">  65.     RemovedInDjango110Warning,</font>
<font color="black">  66. )</font>
<font color="green">  67. from django.utils.encoding import (</font>
<font color="black">  68.     force_str, force_text, python_2_unicode_compatible,</font>
<font color="black">  69. )</font>
<font color="green">  70. from django.utils.formats import localize</font>
<font color="green">  71. from django.utils.html import conditional_escape, escape</font>
<font color="green">  72. from django.utils.inspect import getargspec</font>
<font color="green">  73. from django.utils.safestring import (</font>
<font color="black">  74.     EscapeData, SafeData, mark_for_escaping, mark_safe,</font>
<font color="black">  75. )</font>
<font color="green">  76. from django.utils.text import (</font>
<font color="black">  77.     get_text_list, smart_split, unescape_string_literal,</font>
<font color="black">  78. )</font>
<font color="green">  79. from django.utils.timezone import template_localtime</font>
<font color="green">  80. from django.utils.translation import pgettext_lazy, ugettext_lazy</font>
<font color="black">  81. </font>
<font color="green">  82. from .exceptions import TemplateSyntaxError</font>
<font color="black">  83. </font>
<font color="green">  84. TOKEN_TEXT = 0</font>
<font color="green">  85. TOKEN_VAR = 1</font>
<font color="green">  86. TOKEN_BLOCK = 2</font>
<font color="green">  87. TOKEN_COMMENT = 3</font>
<font color="green">  88. TOKEN_MAPPING = {</font>
<font color="green">  89.     TOKEN_TEXT: 'Text',</font>
<font color="green">  90.     TOKEN_VAR: 'Var',</font>
<font color="green">  91.     TOKEN_BLOCK: 'Block',</font>
<font color="green">  92.     TOKEN_COMMENT: 'Comment',</font>
<font color="black">  93. }</font>
<font color="black">  94. </font>
<font color="black">  95. # template syntax constants</font>
<font color="green">  96. FILTER_SEPARATOR = '|'</font>
<font color="green">  97. FILTER_ARGUMENT_SEPARATOR = ':'</font>
<font color="green">  98. VARIABLE_ATTRIBUTE_SEPARATOR = '.'</font>
<font color="green">  99. BLOCK_TAG_START = '{%'</font>
<font color="green"> 100. BLOCK_TAG_END = '%}'</font>
<font color="green"> 101. VARIABLE_TAG_START = '{{'</font>
<font color="green"> 102. VARIABLE_TAG_END = '}}'</font>
<font color="green"> 103. COMMENT_TAG_START = '{#'</font>
<font color="green"> 104. COMMENT_TAG_END = '#}'</font>
<font color="green"> 105. TRANSLATOR_COMMENT_MARK = 'Translators'</font>
<font color="green"> 106. SINGLE_BRACE_START = '{'</font>
<font color="green"> 107. SINGLE_BRACE_END = '}'</font>
<font color="black"> 108. </font>
<font color="black"> 109. # what to report as the origin for templates that come from non-loader sources</font>
<font color="black"> 110. # (e.g. strings)</font>
<font color="green"> 111. UNKNOWN_SOURCE = '&lt;unknown source&gt;'</font>
<font color="black"> 112. </font>
<font color="black"> 113. # match a variable or block tag and capture the entire tag, including start/end</font>
<font color="black"> 114. # delimiters</font>
<font color="green"> 115. tag_re = (re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' %</font>
<font color="green"> 116.           (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END),</font>
<font color="green"> 117.            re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END),</font>
<font color="green"> 118.            re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END))))</font>
<font color="black"> 119. </font>
<font color="green"> 120. logger = logging.getLogger('django.template')</font>
<font color="black"> 121. </font>
<font color="black"> 122. </font>
<font color="green"> 123. class TemplateEncodingError(Exception):</font>
<font color="green"> 124.     pass</font>
<font color="black"> 125. </font>
<font color="black"> 126. </font>
<font color="green"> 127. @python_2_unicode_compatible</font>
<font color="green"> 128. class VariableDoesNotExist(Exception):</font>
<font color="black"> 129. </font>
<font color="green"> 130.     def __init__(self, msg, params=()):</font>
<font color="red"> 131.         self.msg = msg</font>
<font color="red"> 132.         self.params = params</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def __str__(self):</font>
<font color="red"> 135.         return self.msg % tuple(force_text(p, errors='replace') for p in self.params)</font>
<font color="black"> 136. </font>
<font color="black"> 137. </font>
<font color="green"> 138. class Origin(object):</font>
<font color="green"> 139.     def __init__(self, name, template_name=None, loader=None):</font>
<font color="red"> 140.         self.name = name</font>
<font color="red"> 141.         self.template_name = template_name</font>
<font color="red"> 142.         self.loader = loader</font>
<font color="black"> 143. </font>
<font color="green"> 144.     def __str__(self):</font>
<font color="red"> 145.         return self.name</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def __eq__(self, other):</font>
<font color="red"> 148.         if not isinstance(other, Origin):</font>
<font color="red"> 149.             return False</font>
<font color="black"> 150. </font>
<font color="black"> 151.         return (</font>
<font color="red"> 152.             self.name == other.name and</font>
<font color="red"> 153.             self.loader == other.loader</font>
<font color="black"> 154.         )</font>
<font color="black"> 155. </font>
<font color="green"> 156.     @property</font>
<font color="black"> 157.     def loader_name(self):</font>
<font color="red"> 158.         if self.loader:</font>
<font color="red"> 159.             return '%s.%s' % (</font>
<font color="red"> 160.                 self.loader.__module__, self.loader.__class__.__name__,</font>
<font color="black"> 161.             )</font>
<font color="black"> 162. </font>
<font color="black"> 163. </font>
<font color="green"> 164. class StringOrigin(six.with_metaclass(DeprecationInstanceCheck, Origin)):</font>
<font color="green"> 165.     alternative = 'django.template.Origin'</font>
<font color="green"> 166.     deprecation_warning = RemovedInDjango20Warning</font>
<font color="black"> 167. </font>
<font color="black"> 168. </font>
<font color="green"> 169. class Template(object):</font>
<font color="green"> 170.     def __init__(self, template_string, origin=None, name=None, engine=None):</font>
<font color="red"> 171.         try:</font>
<font color="red"> 172.             template_string = force_text(template_string)</font>
<font color="red"> 173.         except UnicodeDecodeError:</font>
<font color="red"> 174.             raise TemplateEncodingError(&quot;Templates can only be constructed &quot;</font>
<font color="black"> 175.                                         &quot;from unicode or UTF-8 strings.&quot;)</font>
<font color="black"> 176.         # If Template is instantiated directly rather than from an Engine and</font>
<font color="black"> 177.         # exactly one Django template engine is configured, use that engine.</font>
<font color="black"> 178.         # This is required to preserve backwards-compatibility for direct use</font>
<font color="black"> 179.         # e.g. Template('...').render(Context({...}))</font>
<font color="red"> 180.         if engine is None:</font>
<font color="red"> 181.             from .engine import Engine</font>
<font color="red"> 182.             engine = Engine.get_default()</font>
<font color="red"> 183.         if origin is None:</font>
<font color="red"> 184.             origin = Origin(UNKNOWN_SOURCE)</font>
<font color="red"> 185.         self.name = name</font>
<font color="red"> 186.         self.origin = origin</font>
<font color="red"> 187.         self.engine = engine</font>
<font color="red"> 188.         self.source = template_string</font>
<font color="red"> 189.         self.nodelist = self.compile_nodelist()</font>
<font color="black"> 190. </font>
<font color="green"> 191.     def __iter__(self):</font>
<font color="red"> 192.         for node in self.nodelist:</font>
<font color="red"> 193.             for subnode in node:</font>
<font color="red"> 194.                 yield subnode</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def _render(self, context):</font>
<font color="red"> 197.         return self.nodelist.render(context)</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def render(self, context):</font>
<font color="black"> 200.         &quot;Display stage -- can be called many times&quot;</font>
<font color="red"> 201.         context.render_context.push()</font>
<font color="red"> 202.         try:</font>
<font color="red"> 203.             if context.template is None:</font>
<font color="red"> 204.                 with context.bind_template(self):</font>
<font color="red"> 205.                     context.template_name = self.name</font>
<font color="red"> 206.                     return self._render(context)</font>
<font color="black"> 207.             else:</font>
<font color="red"> 208.                 return self._render(context)</font>
<font color="black"> 209.         finally:</font>
<font color="red"> 210.             context.render_context.pop()</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def compile_nodelist(self):</font>
<font color="black"> 213.         &quot;&quot;&quot;</font>
<font color="black"> 214.         Parse and compile the template source into a nodelist. If debug</font>
<font color="black"> 215.         is True and an exception occurs during parsing, the exception is</font>
<font color="black"> 216.         is annotated with contextual line information where it occurred in the</font>
<font color="black"> 217.         template source.</font>
<font color="black"> 218.         &quot;&quot;&quot;</font>
<font color="red"> 219.         if self.engine.debug:</font>
<font color="red"> 220.             lexer = DebugLexer(self.source)</font>
<font color="black"> 221.         else:</font>
<font color="red"> 222.             lexer = Lexer(self.source)</font>
<font color="black"> 223. </font>
<font color="red"> 224.         tokens = lexer.tokenize()</font>
<font color="red"> 225.         parser = Parser(</font>
<font color="red"> 226.             tokens, self.engine.template_libraries, self.engine.template_builtins,</font>
<font color="black"> 227.         )</font>
<font color="black"> 228. </font>
<font color="red"> 229.         try:</font>
<font color="red"> 230.             return parser.parse()</font>
<font color="red"> 231.         except Exception as e:</font>
<font color="red"> 232.             if self.engine.debug:</font>
<font color="red"> 233.                 e.template_debug = self.get_exception_info(e, e.token)</font>
<font color="red"> 234.             raise</font>
<font color="black"> 235. </font>
<font color="green"> 236.     def get_exception_info(self, exception, token):</font>
<font color="black"> 237.         &quot;&quot;&quot;</font>
<font color="black"> 238.         Return a dictionary containing contextual line information of where</font>
<font color="black"> 239.         the exception occurred in the template. The following information is</font>
<font color="black"> 240.         provided:</font>
<font color="black"> 241. </font>
<font color="black"> 242.         message</font>
<font color="black"> 243.             The message of the exception raised.</font>
<font color="black"> 244. </font>
<font color="black"> 245.         source_lines</font>
<font color="black"> 246.             The lines before, after, and including the line the exception</font>
<font color="black"> 247.             occurred on.</font>
<font color="black"> 248. </font>
<font color="black"> 249.         line</font>
<font color="black"> 250.             The line number the exception occurred on.</font>
<font color="black"> 251. </font>
<font color="black"> 252.         before, during, after</font>
<font color="black"> 253.             The line the exception occurred on split into three parts:</font>
<font color="black"> 254.             1. The content before the token that raised the error.</font>
<font color="black"> 255.             2. The token that raised the error.</font>
<font color="black"> 256.             3. The content after the token that raised the error.</font>
<font color="black"> 257. </font>
<font color="black"> 258.         total</font>
<font color="black"> 259.             The number of lines in source_lines.</font>
<font color="black"> 260. </font>
<font color="black"> 261.         top</font>
<font color="black"> 262.             The line number where source_lines starts.</font>
<font color="black"> 263. </font>
<font color="black"> 264.         bottom</font>
<font color="black"> 265.             The line number where source_lines ends.</font>
<font color="black"> 266. </font>
<font color="black"> 267.         start</font>
<font color="black"> 268.             The start position of the token in the template source.</font>
<font color="black"> 269. </font>
<font color="black"> 270.         end</font>
<font color="black"> 271.             The end position of the token in the template source.</font>
<font color="black"> 272.         &quot;&quot;&quot;</font>
<font color="red"> 273.         start, end = token.position</font>
<font color="red"> 274.         context_lines = 10</font>
<font color="red"> 275.         line = 0</font>
<font color="red"> 276.         upto = 0</font>
<font color="red"> 277.         source_lines = []</font>
<font color="red"> 278.         before = during = after = &quot;&quot;</font>
<font color="red"> 279.         for num, next in enumerate(linebreak_iter(self.source)):</font>
<font color="red"> 280.             if start &gt;= upto and end &lt;= next:</font>
<font color="red"> 281.                 line = num</font>
<font color="red"> 282.                 before = escape(self.source[upto:start])</font>
<font color="red"> 283.                 during = escape(self.source[start:end])</font>
<font color="red"> 284.                 after = escape(self.source[end:next])</font>
<font color="red"> 285.             source_lines.append((num, escape(self.source[upto:next])))</font>
<font color="red"> 286.             upto = next</font>
<font color="red"> 287.         total = len(source_lines)</font>
<font color="black"> 288. </font>
<font color="red"> 289.         top = max(1, line - context_lines)</font>
<font color="red"> 290.         bottom = min(total, line + 1 + context_lines)</font>
<font color="black"> 291. </font>
<font color="black"> 292.         # In some rare cases exc_value.args can be empty or an invalid</font>
<font color="black"> 293.         # unicode string.</font>
<font color="red"> 294.         try:</font>
<font color="red"> 295.             message = force_text(exception.args[0])</font>
<font color="red"> 296.         except (IndexError, UnicodeDecodeError):</font>
<font color="red"> 297.             message = '(Could not get exception message)'</font>
<font color="black"> 298. </font>
<font color="red"> 299.         return {</font>
<font color="red"> 300.             'message': message,</font>
<font color="red"> 301.             'source_lines': source_lines[top:bottom],</font>
<font color="red"> 302.             'before': before,</font>
<font color="red"> 303.             'during': during,</font>
<font color="red"> 304.             'after': after,</font>
<font color="red"> 305.             'top': top,</font>
<font color="red"> 306.             'bottom': bottom,</font>
<font color="red"> 307.             'total': total,</font>
<font color="red"> 308.             'line': line,</font>
<font color="red"> 309.             'name': self.origin.name,</font>
<font color="red"> 310.             'start': start,</font>
<font color="red"> 311.             'end': end,</font>
<font color="black"> 312.         }</font>
<font color="black"> 313. </font>
<font color="black"> 314. </font>
<font color="green"> 315. def linebreak_iter(template_source):</font>
<font color="red"> 316.     yield 0</font>
<font color="red"> 317.     p = template_source.find('\n')</font>
<font color="red"> 318.     while p &gt;= 0:</font>
<font color="red"> 319.         yield p + 1</font>
<font color="red"> 320.         p = template_source.find('\n', p + 1)</font>
<font color="red"> 321.     yield len(template_source) + 1</font>
<font color="black"> 322. </font>
<font color="black"> 323. </font>
<font color="green"> 324. class Token(object):</font>
<font color="green"> 325.     def __init__(self, token_type, contents, position=None, lineno=None):</font>
<font color="black"> 326.         &quot;&quot;&quot;</font>
<font color="black"> 327.         A token representing a string from the template.</font>
<font color="black"> 328. </font>
<font color="black"> 329.         token_type</font>
<font color="black"> 330.             One of TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK, or TOKEN_COMMENT.</font>
<font color="black"> 331. </font>
<font color="black"> 332.         contents</font>
<font color="black"> 333.             The token source string.</font>
<font color="black"> 334. </font>
<font color="black"> 335.         position</font>
<font color="black"> 336.             An optional tuple containing the start and end index of the token</font>
<font color="black"> 337.             in the template source. This is used for traceback information</font>
<font color="black"> 338.             when debug is on.</font>
<font color="black"> 339. </font>
<font color="black"> 340.         lineno</font>
<font color="black"> 341.             The line number the token appears on in the template source.</font>
<font color="black"> 342.             This is used for traceback information and gettext files.</font>
<font color="black"> 343.         &quot;&quot;&quot;</font>
<font color="red"> 344.         self.token_type, self.contents = token_type, contents</font>
<font color="red"> 345.         self.lineno = lineno</font>
<font color="red"> 346.         self.position = position</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def __str__(self):</font>
<font color="red"> 349.         token_name = TOKEN_MAPPING[self.token_type]</font>
<font color="red"> 350.         return ('&lt;%s token: &quot;%s...&quot;&gt;' %</font>
<font color="red"> 351.                 (token_name, self.contents[:20].replace('\n', '')))</font>
<font color="black"> 352. </font>
<font color="green"> 353.     def split_contents(self):</font>
<font color="red"> 354.         split = []</font>
<font color="red"> 355.         bits = iter(smart_split(self.contents))</font>
<font color="red"> 356.         for bit in bits:</font>
<font color="black"> 357.             # Handle translation-marked template pieces</font>
<font color="red"> 358.             if bit.startswith(('_(&quot;', &quot;_('&quot;)):</font>
<font color="red"> 359.                 sentinal = bit[2] + ')'</font>
<font color="red"> 360.                 trans_bit = [bit]</font>
<font color="red"> 361.                 while not bit.endswith(sentinal):</font>
<font color="red"> 362.                     bit = next(bits)</font>
<font color="red"> 363.                     trans_bit.append(bit)</font>
<font color="red"> 364.                 bit = ' '.join(trans_bit)</font>
<font color="red"> 365.             split.append(bit)</font>
<font color="red"> 366.         return split</font>
<font color="black"> 367. </font>
<font color="black"> 368. </font>
<font color="green"> 369. class Lexer(object):</font>
<font color="green"> 370.     def __init__(self, template_string):</font>
<font color="red"> 371.         self.template_string = template_string</font>
<font color="red"> 372.         self.verbatim = False</font>
<font color="black"> 373. </font>
<font color="green"> 374.     def tokenize(self):</font>
<font color="black"> 375.         &quot;&quot;&quot;</font>
<font color="black"> 376.         Return a list of tokens from a given template_string.</font>
<font color="black"> 377.         &quot;&quot;&quot;</font>
<font color="red"> 378.         in_tag = False</font>
<font color="red"> 379.         lineno = 1</font>
<font color="red"> 380.         result = []</font>
<font color="red"> 381.         for bit in tag_re.split(self.template_string):</font>
<font color="red"> 382.             if bit:</font>
<font color="red"> 383.                 result.append(self.create_token(bit, None, lineno, in_tag))</font>
<font color="red"> 384.             in_tag = not in_tag</font>
<font color="red"> 385.             lineno += bit.count('\n')</font>
<font color="red"> 386.         return result</font>
<font color="black"> 387. </font>
<font color="green"> 388.     def create_token(self, token_string, position, lineno, in_tag):</font>
<font color="black"> 389.         &quot;&quot;&quot;</font>
<font color="black"> 390.         Convert the given token string into a new Token object and return it.</font>
<font color="black"> 391.         If in_tag is True, we are processing something that matched a tag,</font>
<font color="black"> 392.         otherwise it should be treated as a literal string.</font>
<font color="black"> 393.         &quot;&quot;&quot;</font>
<font color="red"> 394.         if in_tag and token_string.startswith(BLOCK_TAG_START):</font>
<font color="black"> 395.             # The [2:-2] ranges below strip off *_TAG_START and *_TAG_END.</font>
<font color="black"> 396.             # We could do len(BLOCK_TAG_START) to be more &quot;correct&quot;, but we've</font>
<font color="black"> 397.             # hard-coded the 2s here for performance. And it's not like</font>
<font color="black"> 398.             # the TAG_START values are going to change anytime, anyway.</font>
<font color="red"> 399.             block_content = token_string[2:-2].strip()</font>
<font color="red"> 400.             if self.verbatim and block_content == self.verbatim:</font>
<font color="red"> 401.                 self.verbatim = False</font>
<font color="red"> 402.         if in_tag and not self.verbatim:</font>
<font color="red"> 403.             if token_string.startswith(VARIABLE_TAG_START):</font>
<font color="red"> 404.                 token = Token(TOKEN_VAR, token_string[2:-2].strip(), position, lineno)</font>
<font color="red"> 405.             elif token_string.startswith(BLOCK_TAG_START):</font>
<font color="red"> 406.                 if block_content[:9] in ('verbatim', 'verbatim '):</font>
<font color="red"> 407.                     self.verbatim = 'end%s' % block_content</font>
<font color="red"> 408.                 token = Token(TOKEN_BLOCK, block_content, position, lineno)</font>
<font color="red"> 409.             elif token_string.startswith(COMMENT_TAG_START):</font>
<font color="red"> 410.                 content = ''</font>
<font color="red"> 411.                 if token_string.find(TRANSLATOR_COMMENT_MARK):</font>
<font color="red"> 412.                     content = token_string[2:-2].strip()</font>
<font color="red"> 413.                 token = Token(TOKEN_COMMENT, content, position, lineno)</font>
<font color="black"> 414.         else:</font>
<font color="red"> 415.             token = Token(TOKEN_TEXT, token_string, position, lineno)</font>
<font color="red"> 416.         return token</font>
<font color="black"> 417. </font>
<font color="black"> 418. </font>
<font color="green"> 419. class DebugLexer(Lexer):</font>
<font color="green"> 420.     def tokenize(self):</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="black"> 422.         Split a template string into tokens and annotates each token with its</font>
<font color="black"> 423.         start and end position in the source. This is slower than the default</font>
<font color="black"> 424.         lexer so we only use it when debug is True.</font>
<font color="black"> 425.         &quot;&quot;&quot;</font>
<font color="red"> 426.         lineno = 1</font>
<font color="red"> 427.         result = []</font>
<font color="red"> 428.         upto = 0</font>
<font color="red"> 429.         for match in tag_re.finditer(self.template_string):</font>
<font color="red"> 430.             start, end = match.span()</font>
<font color="red"> 431.             if start &gt; upto:</font>
<font color="red"> 432.                 token_string = self.template_string[upto:start]</font>
<font color="red"> 433.                 result.append(self.create_token(token_string, (upto, start), lineno, in_tag=False))</font>
<font color="red"> 434.                 lineno += token_string.count('\n')</font>
<font color="red"> 435.                 upto = start</font>
<font color="red"> 436.             token_string = self.template_string[start:end]</font>
<font color="red"> 437.             result.append(self.create_token(token_string, (start, end), lineno, in_tag=True))</font>
<font color="red"> 438.             lineno += token_string.count('\n')</font>
<font color="red"> 439.             upto = end</font>
<font color="red"> 440.         last_bit = self.template_string[upto:]</font>
<font color="red"> 441.         if last_bit:</font>
<font color="red"> 442.             result.append(self.create_token(last_bit, (upto, upto + len(last_bit)), lineno, in_tag=False))</font>
<font color="red"> 443.         return result</font>
<font color="black"> 444. </font>
<font color="black"> 445. </font>
<font color="green"> 446. class Parser(object):</font>
<font color="green"> 447.     def __init__(self, tokens, libraries=None, builtins=None):</font>
<font color="red"> 448.         self.tokens = tokens</font>
<font color="red"> 449.         self.tags = {}</font>
<font color="red"> 450.         self.filters = {}</font>
<font color="red"> 451.         self.command_stack = []</font>
<font color="black"> 452. </font>
<font color="red"> 453.         if libraries is None:</font>
<font color="red"> 454.             libraries = {}</font>
<font color="red"> 455.         if builtins is None:</font>
<font color="red"> 456.             builtins = []</font>
<font color="black"> 457. </font>
<font color="red"> 458.         self.libraries = libraries</font>
<font color="red"> 459.         for builtin in builtins:</font>
<font color="red"> 460.             self.add_library(builtin)</font>
<font color="black"> 461. </font>
<font color="green"> 462.     def parse(self, parse_until=None):</font>
<font color="black"> 463.         &quot;&quot;&quot;</font>
<font color="black"> 464.         Iterate through the parser tokens and compiles each one into a node.</font>
<font color="black"> 465. </font>
<font color="black"> 466.         If parse_until is provided, parsing will stop once one of the</font>
<font color="black"> 467.         specified tokens has been reached. This is formatted as a list of</font>
<font color="black"> 468.         tokens, e.g. ['elif', 'else', 'endif']. If no matching token is</font>
<font color="black"> 469.         reached, raise an exception with the unclosed block tag details.</font>
<font color="black"> 470.         &quot;&quot;&quot;</font>
<font color="red"> 471.         if parse_until is None:</font>
<font color="red"> 472.             parse_until = []</font>
<font color="red"> 473.         nodelist = NodeList()</font>
<font color="red"> 474.         while self.tokens:</font>
<font color="red"> 475.             token = self.next_token()</font>
<font color="black"> 476.             # Use the raw values here for TOKEN_* for a tiny performance boost.</font>
<font color="red"> 477.             if token.token_type == 0:  # TOKEN_TEXT</font>
<font color="red"> 478.                 self.extend_nodelist(nodelist, TextNode(token.contents), token)</font>
<font color="red"> 479.             elif token.token_type == 1:  # TOKEN_VAR</font>
<font color="red"> 480.                 if not token.contents:</font>
<font color="red"> 481.                     raise self.error(token, 'Empty variable tag on line %d' % token.lineno)</font>
<font color="red"> 482.                 try:</font>
<font color="red"> 483.                     filter_expression = self.compile_filter(token.contents)</font>
<font color="red"> 484.                 except TemplateSyntaxError as e:</font>
<font color="red"> 485.                     raise self.error(token, e)</font>
<font color="red"> 486.                 var_node = VariableNode(filter_expression)</font>
<font color="red"> 487.                 self.extend_nodelist(nodelist, var_node, token)</font>
<font color="red"> 488.             elif token.token_type == 2:  # TOKEN_BLOCK</font>
<font color="red"> 489.                 try:</font>
<font color="red"> 490.                     command = token.contents.split()[0]</font>
<font color="red"> 491.                 except IndexError:</font>
<font color="red"> 492.                     raise self.error(token, 'Empty block tag on line %d' % token.lineno)</font>
<font color="red"> 493.                 if command in parse_until:</font>
<font color="black"> 494.                     # A matching token has been reached. Return control to</font>
<font color="black"> 495.                     # the caller. Put the token back on the token list so the</font>
<font color="black"> 496.                     # caller knows where it terminated.</font>
<font color="red"> 497.                     self.prepend_token(token)</font>
<font color="red"> 498.                     return nodelist</font>
<font color="black"> 499.                 # Add the token to the command stack. This is used for error</font>
<font color="black"> 500.                 # messages if further parsing fails due to an unclosed block</font>
<font color="black"> 501.                 # tag.</font>
<font color="red"> 502.                 self.command_stack.append((command, token))</font>
<font color="black"> 503.                 # Get the tag callback function from the ones registered with</font>
<font color="black"> 504.                 # the parser.</font>
<font color="red"> 505.                 try:</font>
<font color="red"> 506.                     compile_func = self.tags[command]</font>
<font color="red"> 507.                 except KeyError:</font>
<font color="red"> 508.                     self.invalid_block_tag(token, command, parse_until)</font>
<font color="black"> 509.                 # Compile the callback into a node object and add it to</font>
<font color="black"> 510.                 # the node list.</font>
<font color="red"> 511.                 try:</font>
<font color="red"> 512.                     compiled_result = compile_func(self, token)</font>
<font color="red"> 513.                 except Exception as e:</font>
<font color="red"> 514.                     raise self.error(token, e)</font>
<font color="red"> 515.                 self.extend_nodelist(nodelist, compiled_result, token)</font>
<font color="black"> 516.                 # Compile success. Remove the token from the command stack.</font>
<font color="red"> 517.                 self.command_stack.pop()</font>
<font color="red"> 518.         if parse_until:</font>
<font color="red"> 519.             self.unclosed_block_tag(parse_until)</font>
<font color="red"> 520.         return nodelist</font>
<font color="black"> 521. </font>
<font color="green"> 522.     def skip_past(self, endtag):</font>
<font color="red"> 523.         while self.tokens:</font>
<font color="red"> 524.             token = self.next_token()</font>
<font color="red"> 525.             if token.token_type == TOKEN_BLOCK and token.contents == endtag:</font>
<font color="red"> 526.                 return</font>
<font color="red"> 527.         self.unclosed_block_tag([endtag])</font>
<font color="black"> 528. </font>
<font color="green"> 529.     def extend_nodelist(self, nodelist, node, token):</font>
<font color="black"> 530.         # Check that non-text nodes don't appear before an extends tag.</font>
<font color="red"> 531.         if node.must_be_first and nodelist.contains_nontext:</font>
<font color="red"> 532.             raise self.error(</font>
<font color="red"> 533.                 token, '%r must be the first tag in the template.' % node,</font>
<font color="black"> 534.             )</font>
<font color="red"> 535.         if isinstance(nodelist, NodeList) and not isinstance(node, TextNode):</font>
<font color="red"> 536.             nodelist.contains_nontext = True</font>
<font color="black"> 537.         # Set token here since we can't modify the node __init__ method</font>
<font color="red"> 538.         node.token = token</font>
<font color="red"> 539.         nodelist.append(node)</font>
<font color="black"> 540. </font>
<font color="green"> 541.     def error(self, token, e):</font>
<font color="black"> 542.         &quot;&quot;&quot;</font>
<font color="black"> 543.         Return an exception annotated with the originating token. Since the</font>
<font color="black"> 544.         parser can be called recursively, check if a token is already set. This</font>
<font color="black"> 545.         ensures the innermost token is highlighted if an exception occurs,</font>
<font color="black"> 546.         e.g. a compile error within the body of an if statement.</font>
<font color="black"> 547.         &quot;&quot;&quot;</font>
<font color="red"> 548.         if not isinstance(e, Exception):</font>
<font color="red"> 549.             e = TemplateSyntaxError(e)</font>
<font color="red"> 550.         if not hasattr(e, 'token'):</font>
<font color="red"> 551.             e.token = token</font>
<font color="red"> 552.         return e</font>
<font color="black"> 553. </font>
<font color="green"> 554.     def invalid_block_tag(self, token, command, parse_until=None):</font>
<font color="red"> 555.         if parse_until:</font>
<font color="red"> 556.             raise self.error(</font>
<font color="red"> 557.                 token,</font>
<font color="red"> 558.                 &quot;Invalid block tag on line %d: '%s', expected %s. Did you &quot;</font>
<font color="black"> 559.                 &quot;forget to register or load this tag?&quot; % (</font>
<font color="red"> 560.                     token.lineno,</font>
<font color="red"> 561.                     command,</font>
<font color="red"> 562.                     get_text_list([&quot;'%s'&quot; % p for p in parse_until]),</font>
<font color="black"> 563.                 ),</font>
<font color="black"> 564.             )</font>
<font color="red"> 565.         raise self.error(</font>
<font color="red"> 566.             token,</font>
<font color="red"> 567.             &quot;Invalid block tag on line %d: '%s'. Did you forget to register &quot;</font>
<font color="red"> 568.             &quot;or load this tag?&quot; % (token.lineno, command)</font>
<font color="black"> 569.         )</font>
<font color="black"> 570. </font>
<font color="green"> 571.     def unclosed_block_tag(self, parse_until):</font>
<font color="red"> 572.         command, token = self.command_stack.pop()</font>
<font color="red"> 573.         msg = &quot;Unclosed tag on line %d: '%s'. Looking for one of: %s.&quot; % (</font>
<font color="red"> 574.             token.lineno,</font>
<font color="red"> 575.             command,</font>
<font color="red"> 576.             ', '.join(parse_until),</font>
<font color="black"> 577.         )</font>
<font color="red"> 578.         raise self.error(token, msg)</font>
<font color="black"> 579. </font>
<font color="green"> 580.     def next_token(self):</font>
<font color="red"> 581.         return self.tokens.pop(0)</font>
<font color="black"> 582. </font>
<font color="green"> 583.     def prepend_token(self, token):</font>
<font color="red"> 584.         self.tokens.insert(0, token)</font>
<font color="black"> 585. </font>
<font color="green"> 586.     def delete_first_token(self):</font>
<font color="red"> 587.         del self.tokens[0]</font>
<font color="black"> 588. </font>
<font color="green"> 589.     def add_library(self, lib):</font>
<font color="red"> 590.         self.tags.update(lib.tags)</font>
<font color="red"> 591.         self.filters.update(lib.filters)</font>
<font color="black"> 592. </font>
<font color="green"> 593.     def compile_filter(self, token):</font>
<font color="black"> 594.         &quot;&quot;&quot;</font>
<font color="black"> 595.         Convenient wrapper for FilterExpression</font>
<font color="black"> 596.         &quot;&quot;&quot;</font>
<font color="red"> 597.         return FilterExpression(token, self)</font>
<font color="black"> 598. </font>
<font color="green"> 599.     def find_filter(self, filter_name):</font>
<font color="red"> 600.         if filter_name in self.filters:</font>
<font color="red"> 601.             return self.filters[filter_name]</font>
<font color="black"> 602.         else:</font>
<font color="red"> 603.             raise TemplateSyntaxError(&quot;Invalid filter: '%s'&quot; % filter_name)</font>
<font color="black"> 604. </font>
<font color="black"> 605. </font>
<font color="black"> 606. # This only matches constant *strings* (things in quotes or marked for</font>
<font color="black"> 607. # translation). Numbers are treated as variables for implementation reasons</font>
<font color="black"> 608. # (so that they retain their type when passed to filters).</font>
<font color="black"> 609. constant_string = r&quot;&quot;&quot;</font>
<font color="black"> 610. (?:%(i18n_open)s%(strdq)s%(i18n_close)s|</font>
<font color="black"> 611. %(i18n_open)s%(strsq)s%(i18n_close)s|</font>
<font color="black"> 612. %(strdq)s|</font>
<font color="black"> 613. %(strsq)s)</font>
<font color="green"> 614. &quot;&quot;&quot; % {</font>
<font color="green"> 615.     'strdq': r'&quot;[^&quot;\\]*(?:\\.[^&quot;\\]*)*&quot;',  # double-quoted string</font>
<font color="green"> 616.     'strsq': r&quot;'[^'\\]*(?:\\.[^'\\]*)*'&quot;,  # single-quoted string</font>
<font color="green"> 617.     'i18n_open': re.escape(&quot;_(&quot;),</font>
<font color="green"> 618.     'i18n_close': re.escape(&quot;)&quot;),</font>
<font color="black"> 619. }</font>
<font color="green"> 620. constant_string = constant_string.replace(&quot;\n&quot;, &quot;&quot;)</font>
<font color="black"> 621. </font>
<font color="black"> 622. filter_raw_string = r&quot;&quot;&quot;</font>
<font color="black"> 623. ^(?P&lt;constant&gt;%(constant)s)|</font>
<font color="black"> 624. ^(?P&lt;var&gt;[%(var_chars)s]+|%(num)s)|</font>
<font color="black"> 625.  (?:\s*%(filter_sep)s\s*</font>
<font color="black"> 626.      (?P&lt;filter_name&gt;\w+)</font>
<font color="black"> 627.          (?:%(arg_sep)s</font>
<font color="black"> 628.              (?:</font>
<font color="black"> 629.               (?P&lt;constant_arg&gt;%(constant)s)|</font>
<font color="black"> 630.               (?P&lt;var_arg&gt;[%(var_chars)s]+|%(num)s)</font>
<font color="black"> 631.              )</font>
<font color="black"> 632.          )?</font>
<font color="green"> 633.  )&quot;&quot;&quot; % {</font>
<font color="green"> 634.     'constant': constant_string,</font>
<font color="green"> 635.     'num': r'[-+\.]?\d[\d\.e]*',</font>
<font color="green"> 636.     'var_chars': &quot;\w\.&quot;,</font>
<font color="green"> 637.     'filter_sep': re.escape(FILTER_SEPARATOR),</font>
<font color="green"> 638.     'arg_sep': re.escape(FILTER_ARGUMENT_SEPARATOR),</font>
<font color="black"> 639. }</font>
<font color="black"> 640. </font>
<font color="green"> 641. filter_re = re.compile(filter_raw_string, re.UNICODE | re.VERBOSE)</font>
<font color="black"> 642. </font>
<font color="black"> 643. </font>
<font color="green"> 644. class FilterExpression(object):</font>
<font color="black"> 645.     &quot;&quot;&quot;</font>
<font color="black"> 646.     Parses a variable token and its optional filters (all as a single string),</font>
<font color="black"> 647.     and return a list of tuples of the filter name and arguments.</font>
<font color="black"> 648.     Sample::</font>
<font color="black"> 649. </font>
<font color="black"> 650.         &gt;&gt;&gt; token = 'variable|default:&quot;Default value&quot;|date:&quot;Y-m-d&quot;'</font>
<font color="black"> 651.         &gt;&gt;&gt; p = Parser('')</font>
<font color="black"> 652.         &gt;&gt;&gt; fe = FilterExpression(token, p)</font>
<font color="black"> 653.         &gt;&gt;&gt; len(fe.filters)</font>
<font color="black"> 654.         2</font>
<font color="black"> 655.         &gt;&gt;&gt; fe.var</font>
<font color="black"> 656.         &lt;Variable: 'variable'&gt;</font>
<font color="green"> 657.     &quot;&quot;&quot;</font>
<font color="green"> 658.     def __init__(self, token, parser):</font>
<font color="red"> 659.         self.token = token</font>
<font color="red"> 660.         matches = filter_re.finditer(token)</font>
<font color="red"> 661.         var_obj = None</font>
<font color="red"> 662.         filters = []</font>
<font color="red"> 663.         upto = 0</font>
<font color="red"> 664.         for match in matches:</font>
<font color="red"> 665.             start = match.start()</font>
<font color="red"> 666.             if upto != start:</font>
<font color="red"> 667.                 raise TemplateSyntaxError(&quot;Could not parse some characters: &quot;</font>
<font color="black"> 668.                                           &quot;%s|%s|%s&quot; %</font>
<font color="red"> 669.                                           (token[:upto], token[upto:start],</font>
<font color="red"> 670.                                            token[start:]))</font>
<font color="red"> 671.             if var_obj is None:</font>
<font color="red"> 672.                 var, constant = match.group(&quot;var&quot;, &quot;constant&quot;)</font>
<font color="red"> 673.                 if constant:</font>
<font color="red"> 674.                     try:</font>
<font color="red"> 675.                         var_obj = Variable(constant).resolve({})</font>
<font color="red"> 676.                     except VariableDoesNotExist:</font>
<font color="red"> 677.                         var_obj = None</font>
<font color="red"> 678.                 elif var is None:</font>
<font color="red"> 679.                     raise TemplateSyntaxError(&quot;Could not find variable at &quot;</font>
<font color="red"> 680.                                               &quot;start of %s.&quot; % token)</font>
<font color="black"> 681.                 else:</font>
<font color="red"> 682.                     var_obj = Variable(var)</font>
<font color="black"> 683.             else:</font>
<font color="red"> 684.                 filter_name = match.group(&quot;filter_name&quot;)</font>
<font color="red"> 685.                 args = []</font>
<font color="red"> 686.                 constant_arg, var_arg = match.group(&quot;constant_arg&quot;, &quot;var_arg&quot;)</font>
<font color="red"> 687.                 if constant_arg:</font>
<font color="red"> 688.                     args.append((False, Variable(constant_arg).resolve({})))</font>
<font color="red"> 689.                 elif var_arg:</font>
<font color="red"> 690.                     args.append((True, Variable(var_arg)))</font>
<font color="red"> 691.                 filter_func = parser.find_filter(filter_name)</font>
<font color="red"> 692.                 self.args_check(filter_name, filter_func, args)</font>
<font color="red"> 693.                 filters.append((filter_func, args))</font>
<font color="red"> 694.             upto = match.end()</font>
<font color="red"> 695.         if upto != len(token):</font>
<font color="red"> 696.             raise TemplateSyntaxError(&quot;Could not parse the remainder: '%s' &quot;</font>
<font color="red"> 697.                                       &quot;from '%s'&quot; % (token[upto:], token))</font>
<font color="black"> 698. </font>
<font color="red"> 699.         self.filters = filters</font>
<font color="red"> 700.         self.var = var_obj</font>
<font color="black"> 701. </font>
<font color="green"> 702.     def resolve(self, context, ignore_failures=False):</font>
<font color="red"> 703.         if isinstance(self.var, Variable):</font>
<font color="red"> 704.             try:</font>
<font color="red"> 705.                 obj = self.var.resolve(context)</font>
<font color="red"> 706.             except VariableDoesNotExist:</font>
<font color="red"> 707.                 if ignore_failures:</font>
<font color="red"> 708.                     obj = None</font>
<font color="black"> 709.                 else:</font>
<font color="red"> 710.                     string_if_invalid = context.template.engine.string_if_invalid</font>
<font color="red"> 711.                     if string_if_invalid:</font>
<font color="red"> 712.                         if '%s' in string_if_invalid:</font>
<font color="red"> 713.                             return string_if_invalid % self.var</font>
<font color="black"> 714.                         else:</font>
<font color="red"> 715.                             return string_if_invalid</font>
<font color="black"> 716.                     else:</font>
<font color="red"> 717.                         obj = string_if_invalid</font>
<font color="black"> 718.         else:</font>
<font color="red"> 719.             obj = self.var</font>
<font color="red"> 720.         for func, args in self.filters:</font>
<font color="red"> 721.             arg_vals = []</font>
<font color="red"> 722.             for lookup, arg in args:</font>
<font color="red"> 723.                 if not lookup:</font>
<font color="red"> 724.                     arg_vals.append(mark_safe(arg))</font>
<font color="black"> 725.                 else:</font>
<font color="red"> 726.                     arg_vals.append(arg.resolve(context))</font>
<font color="red"> 727.             if getattr(func, 'expects_localtime', False):</font>
<font color="red"> 728.                 obj = template_localtime(obj, context.use_tz)</font>
<font color="red"> 729.             if getattr(func, 'needs_autoescape', False):</font>
<font color="red"> 730.                 new_obj = func(obj, autoescape=context.autoescape, *arg_vals)</font>
<font color="black"> 731.             else:</font>
<font color="red"> 732.                 new_obj = func(obj, *arg_vals)</font>
<font color="red"> 733.             if getattr(func, 'is_safe', False) and isinstance(obj, SafeData):</font>
<font color="red"> 734.                 obj = mark_safe(new_obj)</font>
<font color="red"> 735.             elif isinstance(obj, EscapeData):</font>
<font color="red"> 736.                 obj = mark_for_escaping(new_obj)</font>
<font color="black"> 737.             else:</font>
<font color="red"> 738.                 obj = new_obj</font>
<font color="red"> 739.         return obj</font>
<font color="black"> 740. </font>
<font color="green"> 741.     def args_check(name, func, provided):</font>
<font color="red"> 742.         provided = list(provided)</font>
<font color="black"> 743.         # First argument, filter input, is implied.</font>
<font color="red"> 744.         plen = len(provided) + 1</font>
<font color="black"> 745.         # Check to see if a decorator is providing the real function.</font>
<font color="red"> 746.         func = getattr(func, '_decorated_function', func)</font>
<font color="black"> 747. </font>
<font color="red"> 748.         args, _, _, defaults = getargspec(func)</font>
<font color="red"> 749.         alen = len(args)</font>
<font color="red"> 750.         dlen = len(defaults or [])</font>
<font color="black"> 751.         # Not enough OR Too many</font>
<font color="red"> 752.         if plen &lt; (alen - dlen) or plen &gt; alen:</font>
<font color="red"> 753.             raise TemplateSyntaxError(&quot;%s requires %d arguments, %d provided&quot; %</font>
<font color="red"> 754.                                       (name, alen - dlen, plen))</font>
<font color="black"> 755. </font>
<font color="red"> 756.         return True</font>
<font color="green"> 757.     args_check = staticmethod(args_check)</font>
<font color="black"> 758. </font>
<font color="green"> 759.     def __str__(self):</font>
<font color="red"> 760.         return self.token</font>
<font color="black"> 761. </font>
<font color="black"> 762. </font>
<font color="green"> 763. def resolve_variable(path, context):</font>
<font color="black"> 764.     &quot;&quot;&quot;</font>
<font color="black"> 765.     Returns the resolved variable, which may contain attribute syntax, within</font>
<font color="black"> 766.     the given context.</font>
<font color="black"> 767. </font>
<font color="black"> 768.     Deprecated; use the Variable class instead.</font>
<font color="black"> 769.     &quot;&quot;&quot;</font>
<font color="red"> 770.     warnings.warn(&quot;resolve_variable() is deprecated. Use django.template.&quot;</font>
<font color="black"> 771.                   &quot;Variable(path).resolve(context) instead&quot;,</font>
<font color="red"> 772.                   RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 773.     return Variable(path).resolve(context)</font>
<font color="black"> 774. </font>
<font color="black"> 775. </font>
<font color="green"> 776. class Variable(object):</font>
<font color="black"> 777.     &quot;&quot;&quot;</font>
<font color="black"> 778.     A template variable, resolvable against a given context. The variable may</font>
<font color="black"> 779.     be a hard-coded string (if it begins and ends with single or double quote</font>
<font color="black"> 780.     marks)::</font>
<font color="black"> 781. </font>
<font color="black"> 782.         &gt;&gt;&gt; c = {'article': {'section':'News'}}</font>
<font color="black"> 783.         &gt;&gt;&gt; Variable('article.section').resolve(c)</font>
<font color="black"> 784.         'News'</font>
<font color="black"> 785.         &gt;&gt;&gt; Variable('article').resolve(c)</font>
<font color="black"> 786.         {'section': 'News'}</font>
<font color="black"> 787.         &gt;&gt;&gt; class AClass: pass</font>
<font color="black"> 788.         &gt;&gt;&gt; c = AClass()</font>
<font color="black"> 789.         &gt;&gt;&gt; c.article = AClass()</font>
<font color="black"> 790.         &gt;&gt;&gt; c.article.section = 'News'</font>
<font color="black"> 791. </font>
<font color="black"> 792.     (The example assumes VARIABLE_ATTRIBUTE_SEPARATOR is '.')</font>
<font color="green"> 793.     &quot;&quot;&quot;</font>
<font color="black"> 794. </font>
<font color="green"> 795.     def __init__(self, var):</font>
<font color="red"> 796.         self.var = var</font>
<font color="red"> 797.         self.literal = None</font>
<font color="red"> 798.         self.lookups = None</font>
<font color="red"> 799.         self.translate = False</font>
<font color="red"> 800.         self.message_context = None</font>
<font color="black"> 801. </font>
<font color="red"> 802.         if not isinstance(var, six.string_types):</font>
<font color="red"> 803.             raise TypeError(</font>
<font color="red"> 804.                 &quot;Variable must be a string or number, got %s&quot; % type(var))</font>
<font color="red"> 805.         try:</font>
<font color="black"> 806.             # First try to treat this variable as a number.</font>
<font color="black"> 807.             #</font>
<font color="black"> 808.             # Note that this could cause an OverflowError here that we're not</font>
<font color="black"> 809.             # catching. Since this should only happen at compile time, that's</font>
<font color="black"> 810.             # probably OK.</font>
<font color="red"> 811.             self.literal = float(var)</font>
<font color="black"> 812. </font>
<font color="black"> 813.             # So it's a float... is it an int? If the original value contained a</font>
<font color="black"> 814.             # dot or an &quot;e&quot; then it was a float, not an int.</font>
<font color="red"> 815.             if '.' not in var and 'e' not in var.lower():</font>
<font color="red"> 816.                 self.literal = int(self.literal)</font>
<font color="black"> 817. </font>
<font color="black"> 818.             # &quot;2.&quot; is invalid</font>
<font color="red"> 819.             if var.endswith('.'):</font>
<font color="red"> 820.                 raise ValueError</font>
<font color="black"> 821. </font>
<font color="red"> 822.         except ValueError:</font>
<font color="black"> 823.             # A ValueError means that the variable isn't a number.</font>
<font color="red"> 824.             if var.startswith('_(') and var.endswith(')'):</font>
<font color="black"> 825.                 # The result of the lookup should be translated at rendering</font>
<font color="black"> 826.                 # time.</font>
<font color="red"> 827.                 self.translate = True</font>
<font color="red"> 828.                 var = var[2:-1]</font>
<font color="black"> 829.             # If it's wrapped with quotes (single or double), then</font>
<font color="black"> 830.             # we're also dealing with a literal.</font>
<font color="red"> 831.             try:</font>
<font color="red"> 832.                 self.literal = mark_safe(unescape_string_literal(var))</font>
<font color="red"> 833.             except ValueError:</font>
<font color="black"> 834.                 # Otherwise we'll set self.lookups so that resolve() knows we're</font>
<font color="black"> 835.                 # dealing with a bonafide variable</font>
<font color="red"> 836.                 if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') &gt; -1 or var[0] == '_':</font>
<font color="red"> 837.                     raise TemplateSyntaxError(&quot;Variables and attributes may &quot;</font>
<font color="black"> 838.                                               &quot;not begin with underscores: '%s'&quot; %</font>
<font color="red"> 839.                                               var)</font>
<font color="red"> 840.                 self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))</font>
<font color="black"> 841. </font>
<font color="green"> 842.     def resolve(self, context):</font>
<font color="black"> 843.         &quot;&quot;&quot;Resolve this variable against a given context.&quot;&quot;&quot;</font>
<font color="red"> 844.         if self.lookups is not None:</font>
<font color="black"> 845.             # We're dealing with a variable that needs to be resolved</font>
<font color="red"> 846.             value = self._resolve_lookup(context)</font>
<font color="black"> 847.         else:</font>
<font color="black"> 848.             # We're dealing with a literal, so it's already been &quot;resolved&quot;</font>
<font color="red"> 849.             value = self.literal</font>
<font color="red"> 850.         if self.translate:</font>
<font color="red"> 851.             is_safe = isinstance(value, SafeData)</font>
<font color="red"> 852.             msgid = value.replace('%', '%%')</font>
<font color="red"> 853.             msgid = mark_safe(msgid) if is_safe else msgid</font>
<font color="red"> 854.             if self.message_context:</font>
<font color="red"> 855.                 return pgettext_lazy(self.message_context, msgid)</font>
<font color="black"> 856.             else:</font>
<font color="red"> 857.                 return ugettext_lazy(msgid)</font>
<font color="red"> 858.         return value</font>
<font color="black"> 859. </font>
<font color="green"> 860.     def __repr__(self):</font>
<font color="red"> 861.         return &quot;&lt;%s: %r&gt;&quot; % (self.__class__.__name__, self.var)</font>
<font color="black"> 862. </font>
<font color="green"> 863.     def __str__(self):</font>
<font color="red"> 864.         return self.var</font>
<font color="black"> 865. </font>
<font color="green"> 866.     def _resolve_lookup(self, context):</font>
<font color="black"> 867.         &quot;&quot;&quot;</font>
<font color="black"> 868.         Performs resolution of a real variable (i.e. not a literal) against the</font>
<font color="black"> 869.         given context.</font>
<font color="black"> 870. </font>
<font color="black"> 871.         As indicated by the method's name, this method is an implementation</font>
<font color="black"> 872.         detail and shouldn't be called by external code. Use Variable.resolve()</font>
<font color="black"> 873.         instead.</font>
<font color="black"> 874.         &quot;&quot;&quot;</font>
<font color="red"> 875.         current = context</font>
<font color="red"> 876.         try:  # catch-all for silent variable failures</font>
<font color="red"> 877.             for bit in self.lookups:</font>
<font color="red"> 878.                 try:  # dictionary lookup</font>
<font color="red"> 879.                     current = current[bit]</font>
<font color="black"> 880.                     # ValueError/IndexError are for numpy.array lookup on</font>
<font color="black"> 881.                     # numpy &lt; 1.9 and 1.9+ respectively</font>
<font color="red"> 882.                 except (TypeError, AttributeError, KeyError, ValueError, IndexError):</font>
<font color="red"> 883.                     try:  # attribute lookup</font>
<font color="black"> 884.                         # Don't return class attributes if the class is the context:</font>
<font color="red"> 885.                         if isinstance(current, BaseContext) and getattr(type(current), bit):</font>
<font color="red"> 886.                             raise AttributeError</font>
<font color="red"> 887.                         current = getattr(current, bit)</font>
<font color="red"> 888.                     except (TypeError, AttributeError) as e:</font>
<font color="black"> 889.                         # Reraise an AttributeError raised by a @property</font>
<font color="red"> 890.                         if (isinstance(e, AttributeError) and</font>
<font color="red"> 891.                                 not isinstance(current, BaseContext) and bit in dir(current)):</font>
<font color="red"> 892.                             raise</font>
<font color="red"> 893.                         try:  # list-index lookup</font>
<font color="red"> 894.                             current = current[int(bit)]</font>
<font color="red"> 895.                         except (IndexError,  # list index out of range</font>
<font color="red"> 896.                                 ValueError,  # invalid literal for int()</font>
<font color="red"> 897.                                 KeyError,    # current is a dict without `int(bit)` key</font>
<font color="red"> 898.                                 TypeError):  # unsubscriptable object</font>
<font color="red"> 899.                             raise VariableDoesNotExist(&quot;Failed lookup for key &quot;</font>
<font color="black"> 900.                                                        &quot;[%s] in %r&quot;,</font>
<font color="red"> 901.                                                        (bit, current))  # missing attribute</font>
<font color="red"> 902.                 if callable(current):</font>
<font color="red"> 903.                     if getattr(current, 'do_not_call_in_templates', False):</font>
<font color="red"> 904.                         pass</font>
<font color="red"> 905.                     elif getattr(current, 'alters_data', False):</font>
<font color="red"> 906.                         current = context.template.engine.string_if_invalid</font>
<font color="black"> 907.                     else:</font>
<font color="red"> 908.                         try:  # method call (assuming no args required)</font>
<font color="red"> 909.                             current = current()</font>
<font color="red"> 910.                         except TypeError:</font>
<font color="red"> 911.                             try:</font>
<font color="red"> 912.                                 inspect.getcallargs(current)</font>
<font color="red"> 913.                             except TypeError:  # arguments *were* required</font>
<font color="red"> 914.                                 current = context.template.engine.string_if_invalid  # invalid method call</font>
<font color="black"> 915.                             else:</font>
<font color="red"> 916.                                 raise</font>
<font color="red"> 917.         except Exception as e:</font>
<font color="red"> 918.             template_name = getattr(context, 'template_name', None) or 'unknown'</font>
<font color="red"> 919.             logger.debug(</font>
<font color="red"> 920.                 &quot;Exception while resolving variable '%s' in template '%s'.&quot;,</font>
<font color="red"> 921.                 bit,</font>
<font color="red"> 922.                 template_name,</font>
<font color="red"> 923.                 exc_info=True,</font>
<font color="black"> 924.             )</font>
<font color="black"> 925. </font>
<font color="red"> 926.             if getattr(e, 'silent_variable_failure', False):</font>
<font color="red"> 927.                 current = context.template.engine.string_if_invalid</font>
<font color="black"> 928.             else:</font>
<font color="red"> 929.                 raise</font>
<font color="black"> 930. </font>
<font color="red"> 931.         return current</font>
<font color="black"> 932. </font>
<font color="black"> 933. </font>
<font color="green"> 934. class Node(object):</font>
<font color="black"> 935.     # Set this to True for nodes that must be first in the template (although</font>
<font color="black"> 936.     # they can be preceded by text nodes.</font>
<font color="green"> 937.     must_be_first = False</font>
<font color="green"> 938.     child_nodelists = ('nodelist',)</font>
<font color="green"> 939.     token = None</font>
<font color="black"> 940. </font>
<font color="green"> 941.     def render(self, context):</font>
<font color="black"> 942.         &quot;&quot;&quot;</font>
<font color="black"> 943.         Return the node rendered as a string.</font>
<font color="black"> 944.         &quot;&quot;&quot;</font>
<font color="red"> 945.         pass</font>
<font color="black"> 946. </font>
<font color="green"> 947.     def render_annotated(self, context):</font>
<font color="black"> 948.         &quot;&quot;&quot;</font>
<font color="black"> 949.         Render the node. If debug is True and an exception occurs during</font>
<font color="black"> 950.         rendering, the exception is annotated with contextual line information</font>
<font color="black"> 951.         where it occurred in the template. For internal usage this method is</font>
<font color="black"> 952.         preferred over using the render method directly.</font>
<font color="black"> 953.         &quot;&quot;&quot;</font>
<font color="red"> 954.         try:</font>
<font color="red"> 955.             return self.render(context)</font>
<font color="red"> 956.         except Exception as e:</font>
<font color="red"> 957.             if context.template.engine.debug and not hasattr(e, 'template_debug'):</font>
<font color="red"> 958.                 e.template_debug = context.template.get_exception_info(e, self.token)</font>
<font color="red"> 959.             raise</font>
<font color="black"> 960. </font>
<font color="green"> 961.     def __iter__(self):</font>
<font color="red"> 962.         yield self</font>
<font color="black"> 963. </font>
<font color="green"> 964.     def get_nodes_by_type(self, nodetype):</font>
<font color="black"> 965.         &quot;&quot;&quot;</font>
<font color="black"> 966.         Return a list of all nodes (within this node and its nodelist)</font>
<font color="black"> 967.         of the given type</font>
<font color="black"> 968.         &quot;&quot;&quot;</font>
<font color="red"> 969.         nodes = []</font>
<font color="red"> 970.         if isinstance(self, nodetype):</font>
<font color="red"> 971.             nodes.append(self)</font>
<font color="red"> 972.         for attr in self.child_nodelists:</font>
<font color="red"> 973.             nodelist = getattr(self, attr, None)</font>
<font color="red"> 974.             if nodelist:</font>
<font color="red"> 975.                 nodes.extend(nodelist.get_nodes_by_type(nodetype))</font>
<font color="red"> 976.         return nodes</font>
<font color="black"> 977. </font>
<font color="black"> 978. </font>
<font color="green"> 979. class NodeList(list):</font>
<font color="black"> 980.     # Set to True the first time a non-TextNode is inserted by</font>
<font color="black"> 981.     # extend_nodelist().</font>
<font color="green"> 982.     contains_nontext = False</font>
<font color="black"> 983. </font>
<font color="green"> 984.     def render(self, context):</font>
<font color="red"> 985.         bits = []</font>
<font color="red"> 986.         for node in self:</font>
<font color="red"> 987.             if isinstance(node, Node):</font>
<font color="red"> 988.                 bit = node.render_annotated(context)</font>
<font color="black"> 989.             else:</font>
<font color="red"> 990.                 bit = node</font>
<font color="red"> 991.             bits.append(force_text(bit))</font>
<font color="red"> 992.         return mark_safe(''.join(bits))</font>
<font color="black"> 993. </font>
<font color="green"> 994.     def get_nodes_by_type(self, nodetype):</font>
<font color="black"> 995.         &quot;Return a list of all nodes of the given type&quot;</font>
<font color="red"> 996.         nodes = []</font>
<font color="red"> 997.         for node in self:</font>
<font color="red"> 998.             nodes.extend(node.get_nodes_by_type(nodetype))</font>
<font color="red"> 999.         return nodes</font>
<font color="black">1000. </font>
<font color="black">1001. </font>
<font color="green">1002. class TextNode(Node):</font>
<font color="green">1003.     def __init__(self, s):</font>
<font color="red">1004.         self.s = s</font>
<font color="black">1005. </font>
<font color="green">1006.     def __repr__(self):</font>
<font color="red">1007.         rep = &quot;&lt;%s: %r&gt;&quot; % (self.__class__.__name__, self.s[:25])</font>
<font color="red">1008.         return force_str(rep, 'ascii', errors='replace')</font>
<font color="black">1009. </font>
<font color="green">1010.     def render(self, context):</font>
<font color="red">1011.         return self.s</font>
<font color="black">1012. </font>
<font color="black">1013. </font>
<font color="green">1014. def render_value_in_context(value, context):</font>
<font color="black">1015.     &quot;&quot;&quot;</font>
<font color="black">1016.     Converts any value to a string to become part of a rendered template. This</font>
<font color="black">1017.     means escaping, if required, and conversion to a unicode object. If value</font>
<font color="black">1018.     is a string, it is expected to have already been translated.</font>
<font color="black">1019.     &quot;&quot;&quot;</font>
<font color="red">1020.     value = template_localtime(value, use_tz=context.use_tz)</font>
<font color="red">1021.     value = localize(value, use_l10n=context.use_l10n)</font>
<font color="red">1022.     value = force_text(value)</font>
<font color="red">1023.     if ((context.autoescape and not isinstance(value, SafeData)) or</font>
<font color="red">1024.             isinstance(value, EscapeData)):</font>
<font color="red">1025.         return conditional_escape(value)</font>
<font color="black">1026.     else:</font>
<font color="red">1027.         return value</font>
<font color="black">1028. </font>
<font color="black">1029. </font>
<font color="green">1030. class VariableNode(Node):</font>
<font color="green">1031.     def __init__(self, filter_expression):</font>
<font color="red">1032.         self.filter_expression = filter_expression</font>
<font color="black">1033. </font>
<font color="green">1034.     def __repr__(self):</font>
<font color="red">1035.         return &quot;&lt;Variable Node: %s&gt;&quot; % self.filter_expression</font>
<font color="black">1036. </font>
<font color="green">1037.     def render(self, context):</font>
<font color="red">1038.         try:</font>
<font color="red">1039.             output = self.filter_expression.resolve(context)</font>
<font color="red">1040.         except UnicodeDecodeError:</font>
<font color="black">1041.             # Unicode conversion can fail sometimes for reasons out of our</font>
<font color="black">1042.             # control (e.g. exception rendering). In that case, we fail</font>
<font color="black">1043.             # quietly.</font>
<font color="red">1044.             return ''</font>
<font color="red">1045.         return render_value_in_context(output, context)</font>
<font color="black">1046. </font>
<font color="black">1047. # Regex for token keyword arguments</font>
<font color="green">1048. kwarg_re = re.compile(r&quot;(?:(\w+)=)?(.+)&quot;)</font>
<font color="black">1049. </font>
<font color="black">1050. </font>
<font color="green">1051. def token_kwargs(bits, parser, support_legacy=False):</font>
<font color="black">1052.     &quot;&quot;&quot;</font>
<font color="black">1053.     A utility method for parsing token keyword arguments.</font>
<font color="black">1054. </font>
<font color="black">1055.     :param bits: A list containing remainder of the token (split by spaces)</font>
<font color="black">1056.         that is to be checked for arguments. Valid arguments will be removed</font>
<font color="black">1057.         from this list.</font>
<font color="black">1058. </font>
<font color="black">1059.     :param support_legacy: If set to true ``True``, the legacy format</font>
<font color="black">1060.         ``1 as foo`` will be accepted. Otherwise, only the standard ``foo=1``</font>
<font color="black">1061.         format is allowed.</font>
<font color="black">1062. </font>
<font color="black">1063.     :returns: A dictionary of the arguments retrieved from the ``bits`` token</font>
<font color="black">1064.         list.</font>
<font color="black">1065. </font>
<font color="black">1066.     There is no requirement for all remaining token ``bits`` to be keyword</font>
<font color="black">1067.     arguments, so the dictionary will be returned as soon as an invalid</font>
<font color="black">1068.     argument format is reached.</font>
<font color="black">1069.     &quot;&quot;&quot;</font>
<font color="red">1070.     if not bits:</font>
<font color="red">1071.         return {}</font>
<font color="red">1072.     match = kwarg_re.match(bits[0])</font>
<font color="red">1073.     kwarg_format = match and match.group(1)</font>
<font color="red">1074.     if not kwarg_format:</font>
<font color="red">1075.         if not support_legacy:</font>
<font color="red">1076.             return {}</font>
<font color="red">1077.         if len(bits) &lt; 3 or bits[1] != 'as':</font>
<font color="red">1078.             return {}</font>
<font color="black">1079. </font>
<font color="red">1080.     kwargs = {}</font>
<font color="red">1081.     while bits:</font>
<font color="red">1082.         if kwarg_format:</font>
<font color="red">1083.             match = kwarg_re.match(bits[0])</font>
<font color="red">1084.             if not match or not match.group(1):</font>
<font color="red">1085.                 return kwargs</font>
<font color="red">1086.             key, value = match.groups()</font>
<font color="red">1087.             del bits[:1]</font>
<font color="black">1088.         else:</font>
<font color="red">1089.             if len(bits) &lt; 3 or bits[1] != 'as':</font>
<font color="red">1090.                 return kwargs</font>
<font color="red">1091.             key, value = bits[2], bits[0]</font>
<font color="red">1092.             del bits[:3]</font>
<font color="red">1093.         kwargs[key] = parser.compile_filter(value)</font>
<font color="red">1094.         if bits and not kwarg_format:</font>
<font color="red">1095.             if bits[0] != 'and':</font>
<font color="red">1096.                 return kwargs</font>
<font color="red">1097.             del bits[:1]</font>
<font color="red">1098.     return kwargs</font>
</pre>

