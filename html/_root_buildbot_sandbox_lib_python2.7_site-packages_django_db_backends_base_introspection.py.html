source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/base/introspection.py</b><br>


file stats: <b>81 lines, 27 executed: 33.3% covered</b>
<pre>
<font color="green">   1. from collections import namedtuple</font>
<font color="black">   2. </font>
<font color="green">   3. from django.utils import six</font>
<font color="black">   4. </font>
<font color="black">   5. # Structure returned by DatabaseIntrospection.get_table_list()</font>
<font color="green">   6. TableInfo = namedtuple('TableInfo', ['name', 'type'])</font>
<font color="black">   7. </font>
<font color="black">   8. # Structure returned by the DB-API cursor.description interface (PEP 249)</font>
<font color="green">   9. FieldInfo = namedtuple('FieldInfo',</font>
<font color="green">  10.     'name type_code display_size internal_size precision scale null_ok')</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class BaseDatabaseIntrospection(object):</font>
<font color="black">  14.     &quot;&quot;&quot;</font>
<font color="black">  15.     This class encapsulates all backend-specific introspection utilities</font>
<font color="green">  16.     &quot;&quot;&quot;</font>
<font color="green">  17.     data_types_reverse = {}</font>
<font color="black">  18. </font>
<font color="green">  19.     def __init__(self, connection):</font>
<font color="green">  20.         self.connection = connection</font>
<font color="black">  21. </font>
<font color="green">  22.     def get_field_type(self, data_type, description):</font>
<font color="black">  23.         &quot;&quot;&quot;Hook for a database backend to use the cursor description to</font>
<font color="black">  24.         match a Django field type to a database column.</font>
<font color="black">  25. </font>
<font color="black">  26.         For Oracle, the column data_type on its own is insufficient to</font>
<font color="black">  27.         distinguish between a FloatField and IntegerField, for example.&quot;&quot;&quot;</font>
<font color="red">  28.         return self.data_types_reverse[data_type]</font>
<font color="black">  29. </font>
<font color="green">  30.     def table_name_converter(self, name):</font>
<font color="black">  31.         &quot;&quot;&quot;Apply a conversion to the name for the purposes of comparison.</font>
<font color="black">  32. </font>
<font color="black">  33.         The default table name converter is for case sensitive comparison.</font>
<font color="black">  34.         &quot;&quot;&quot;</font>
<font color="red">  35.         return name</font>
<font color="black">  36. </font>
<font color="green">  37.     def column_name_converter(self, name):</font>
<font color="black">  38.         &quot;&quot;&quot;</font>
<font color="black">  39.         Apply a conversion to the column name for the purposes of comparison.</font>
<font color="black">  40. </font>
<font color="black">  41.         Uses table_name_converter() by default.</font>
<font color="black">  42.         &quot;&quot;&quot;</font>
<font color="red">  43.         return self.table_name_converter(name)</font>
<font color="black">  44. </font>
<font color="green">  45.     def table_names(self, cursor=None, include_views=False):</font>
<font color="black">  46.         &quot;&quot;&quot;</font>
<font color="black">  47.         Returns a list of names of all tables that exist in the database.</font>
<font color="black">  48.         The returned table list is sorted by Python's default sorting. We</font>
<font color="black">  49.         do NOT use database's ORDER BY here to avoid subtle differences</font>
<font color="black">  50.         in sorting order between databases.</font>
<font color="black">  51.         &quot;&quot;&quot;</font>
<font color="green">  52.         def get_names(cursor):</font>
<font color="green">  53.             return sorted(ti.name for ti in self.get_table_list(cursor)</font>
<font color="green">  54.                           if include_views or ti.type == 't')</font>
<font color="green">  55.         if cursor is None:</font>
<font color="red">  56.             with self.connection.cursor() as cursor:</font>
<font color="red">  57.                 return get_names(cursor)</font>
<font color="green">  58.         return get_names(cursor)</font>
<font color="black">  59. </font>
<font color="green">  60.     def get_table_list(self, cursor):</font>
<font color="black">  61.         &quot;&quot;&quot;</font>
<font color="black">  62.         Returns an unsorted list of TableInfo named tuples of all tables and</font>
<font color="black">  63.         views that exist in the database.</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="red">  65.         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_table_list() method')</font>
<font color="black">  66. </font>
<font color="green">  67.     def django_table_names(self, only_existing=False, include_views=True):</font>
<font color="black">  68.         &quot;&quot;&quot;</font>
<font color="black">  69.         Returns a list of all table names that have associated Django models and</font>
<font color="black">  70.         are in INSTALLED_APPS.</font>
<font color="black">  71. </font>
<font color="black">  72.         If only_existing is True, the resulting list will only include the tables</font>
<font color="black">  73.         that actually exist in the database.</font>
<font color="black">  74.         &quot;&quot;&quot;</font>
<font color="red">  75.         from django.apps import apps</font>
<font color="red">  76.         from django.db import router</font>
<font color="red">  77.         tables = set()</font>
<font color="red">  78.         for app_config in apps.get_app_configs():</font>
<font color="red">  79.             for model in router.get_migratable_models(app_config, self.connection.alias):</font>
<font color="red">  80.                 if not model._meta.managed:</font>
<font color="red">  81.                     continue</font>
<font color="red">  82.                 tables.add(model._meta.db_table)</font>
<font color="red">  83.                 tables.update(f.m2m_db_table() for f in model._meta.local_many_to_many)</font>
<font color="red">  84.         tables = list(tables)</font>
<font color="red">  85.         if only_existing:</font>
<font color="red">  86.             existing_tables = self.table_names(include_views=include_views)</font>
<font color="black">  87.             tables = [</font>
<font color="red">  88.                 t</font>
<font color="red">  89.                 for t in tables</font>
<font color="red">  90.                 if self.table_name_converter(t) in existing_tables</font>
<font color="black">  91.             ]</font>
<font color="red">  92.         return tables</font>
<font color="black">  93. </font>
<font color="green">  94.     def installed_models(self, tables):</font>
<font color="black">  95.         &quot;Returns a set of all models represented by the provided list of table names.&quot;</font>
<font color="red">  96.         from django.apps import apps</font>
<font color="red">  97.         from django.db import router</font>
<font color="red">  98.         all_models = []</font>
<font color="red">  99.         for app_config in apps.get_app_configs():</font>
<font color="red"> 100.             all_models.extend(router.get_migratable_models(app_config, self.connection.alias))</font>
<font color="red"> 101.         tables = list(map(self.table_name_converter, tables))</font>
<font color="black"> 102.         return {</font>
<font color="red"> 103.             m for m in all_models</font>
<font color="red"> 104.             if self.table_name_converter(m._meta.db_table) in tables</font>
<font color="black"> 105.         }</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def sequence_list(self):</font>
<font color="black"> 108.         &quot;Returns a list of information about all DB sequences for all models in all apps.&quot;</font>
<font color="red"> 109.         from django.apps import apps</font>
<font color="red"> 110.         from django.db import models, router</font>
<font color="black"> 111. </font>
<font color="red"> 112.         sequence_list = []</font>
<font color="black"> 113. </font>
<font color="red"> 114.         for app_config in apps.get_app_configs():</font>
<font color="red"> 115.             for model in router.get_migratable_models(app_config, self.connection.alias):</font>
<font color="red"> 116.                 if not model._meta.managed:</font>
<font color="red"> 117.                     continue</font>
<font color="red"> 118.                 if model._meta.swapped:</font>
<font color="red"> 119.                     continue</font>
<font color="red"> 120.                 for f in model._meta.local_fields:</font>
<font color="red"> 121.                     if isinstance(f, models.AutoField):</font>
<font color="red"> 122.                         sequence_list.append({'table': model._meta.db_table, 'column': f.column})</font>
<font color="red"> 123.                         break  # Only one AutoField is allowed per model, so don't bother continuing.</font>
<font color="black"> 124. </font>
<font color="red"> 125.                 for f in model._meta.local_many_to_many:</font>
<font color="black"> 126.                     # If this is an m2m using an intermediate table,</font>
<font color="black"> 127.                     # we don't need to reset the sequence.</font>
<font color="red"> 128.                     if f.remote_field.through is None:</font>
<font color="red"> 129.                         sequence_list.append({'table': f.m2m_db_table(), 'column': None})</font>
<font color="black"> 130. </font>
<font color="red"> 131.         return sequence_list</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def get_key_columns(self, cursor, table_name):</font>
<font color="black"> 134.         &quot;&quot;&quot;</font>
<font color="black"> 135.         Backends can override this to return a list of (column_name, referenced_table_name,</font>
<font color="black"> 136.         referenced_column_name) for all key columns in given table.</font>
<font color="black"> 137.         &quot;&quot;&quot;</font>
<font color="red"> 138.         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_key_columns() method')</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def get_primary_key_column(self, cursor, table_name):</font>
<font color="black"> 141.         &quot;&quot;&quot;</font>
<font color="black"> 142.         Returns the name of the primary key column for the given table.</font>
<font color="black"> 143.         &quot;&quot;&quot;</font>
<font color="red"> 144.         for column in six.iteritems(self.get_indexes(cursor, table_name)):</font>
<font color="red"> 145.             if column[1]['primary_key']:</font>
<font color="red"> 146.                 return column[0]</font>
<font color="red"> 147.         return None</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def get_indexes(self, cursor, table_name):</font>
<font color="black"> 150.         &quot;&quot;&quot;</font>
<font color="black"> 151.         Returns a dictionary of indexed fieldname -&gt; infodict for the given</font>
<font color="black"> 152.         table, where each infodict is in the format:</font>
<font color="black"> 153.             {'primary_key': boolean representing whether it's the primary key,</font>
<font color="black"> 154.              'unique': boolean representing whether it's a unique index}</font>
<font color="black"> 155. </font>
<font color="black"> 156.         Only single-column indexes are introspected.</font>
<font color="black"> 157.         &quot;&quot;&quot;</font>
<font color="red"> 158.         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_indexes() method')</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def get_constraints(self, cursor, table_name):</font>
<font color="black"> 161.         &quot;&quot;&quot;</font>
<font color="black"> 162.         Retrieves any constraints or keys (unique, pk, fk, check, index)</font>
<font color="black"> 163.         across one or more columns.</font>
<font color="black"> 164. </font>
<font color="black"> 165.         Returns a dict mapping constraint names to their attributes,</font>
<font color="black"> 166.         where attributes is a dict with keys:</font>
<font color="black"> 167.          * columns: List of columns this covers</font>
<font color="black"> 168.          * primary_key: True if primary key, False otherwise</font>
<font color="black"> 169.          * unique: True if this is a unique constraint, False otherwise</font>
<font color="black"> 170.          * foreign_key: (table, column) of target, or None</font>
<font color="black"> 171.          * check: True if check constraint, False otherwise</font>
<font color="black"> 172.          * index: True if index, False otherwise.</font>
<font color="black"> 173. </font>
<font color="black"> 174.         Some backends may return special constraint names that don't exist</font>
<font color="black"> 175.         if they don't name constraints of a certain type (e.g. SQLite)</font>
<font color="black"> 176.         &quot;&quot;&quot;</font>
<font color="red"> 177.         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_constraints() method')</font>
</pre>

