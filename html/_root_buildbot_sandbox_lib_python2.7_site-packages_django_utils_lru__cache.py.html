source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/lru_cache.py</b><br>


file stats: <b>108 lines, 64 executed: 59.3% covered</b>
<pre>
<font color="green">   1. try:</font>
<font color="green">   2.     from functools import lru_cache</font>
<font color="black">   3. </font>
<font color="green">   4. except ImportError:</font>
<font color="black">   5.     # backport of Python's 3.3 lru_cache, written by Raymond Hettinger and</font>
<font color="black">   6.     # licensed under MIT license, from:</font>
<font color="black">   7.     # &lt;http://code.activestate.com/recipes/578078-py26-and-py30-backport-of-python-33s-lru-cache/&gt;</font>
<font color="black">   8.     # Should be removed when Django only supports Python 3.2 and above.</font>
<font color="black">   9. </font>
<font color="green">  10.     from collections import namedtuple</font>
<font color="green">  11.     from functools import update_wrapper</font>
<font color="green">  12.     from threading import RLock</font>
<font color="black">  13. </font>
<font color="green">  14.     _CacheInfo = namedtuple(&quot;CacheInfo&quot;, [&quot;hits&quot;, &quot;misses&quot;, &quot;maxsize&quot;, &quot;currsize&quot;])</font>
<font color="black">  15. </font>
<font color="green">  16.     class _HashedSeq(list):</font>
<font color="green">  17.         __slots__ = 'hashvalue'</font>
<font color="black">  18. </font>
<font color="green">  19.         def __init__(self, tup, hash=hash):</font>
<font color="green">  20.             self[:] = tup</font>
<font color="green">  21.             self.hashvalue = hash(tup)</font>
<font color="black">  22. </font>
<font color="green">  23.         def __hash__(self):</font>
<font color="green">  24.             return self.hashvalue</font>
<font color="black">  25. </font>
<font color="black">  26.     def _make_key(args, kwds, typed,</font>
<font color="green">  27.                  kwd_mark = (object(),),</font>
<font color="green">  28.                  fasttypes = {int, str, frozenset, type(None)},</font>
<font color="green">  29.                  sorted=sorted, tuple=tuple, type=type, len=len):</font>
<font color="black">  30.         'Make a cache key from optionally typed positional and keyword arguments'</font>
<font color="green">  31.         key = args</font>
<font color="green">  32.         if kwds:</font>
<font color="green">  33.             sorted_items = sorted(kwds.items())</font>
<font color="green">  34.             key += kwd_mark</font>
<font color="green">  35.             for item in sorted_items:</font>
<font color="green">  36.                 key += item</font>
<font color="green">  37.         if typed:</font>
<font color="red">  38.             key += tuple(type(v) for v in args)</font>
<font color="red">  39.             if kwds:</font>
<font color="red">  40.                 key += tuple(type(v) for k, v in sorted_items)</font>
<font color="green">  41.         elif len(key) == 1 and type(key[0]) in fasttypes:</font>
<font color="red">  42.             return key[0]</font>
<font color="green">  43.         return _HashedSeq(key)</font>
<font color="black">  44. </font>
<font color="green">  45.     def lru_cache(maxsize=100, typed=False):</font>
<font color="black">  46.         &quot;&quot;&quot;Least-recently-used cache decorator.</font>
<font color="black">  47. </font>
<font color="black">  48.         If *maxsize* is set to None, the LRU features are disabled and the cache</font>
<font color="black">  49.         can grow without bound.</font>
<font color="black">  50. </font>
<font color="black">  51.         If *typed* is True, arguments of different types will be cached separately.</font>
<font color="black">  52.         For example, f(3.0) and f(3) will be treated as distinct calls with</font>
<font color="black">  53.         distinct results.</font>
<font color="black">  54. </font>
<font color="black">  55.         Arguments to the cached function must be hashable.</font>
<font color="black">  56. </font>
<font color="black">  57.         View the cache statistics named tuple (hits, misses, maxsize, currsize) with</font>
<font color="black">  58.         f.cache_info().  Clear the cache and statistics with f.cache_clear().</font>
<font color="black">  59.         Access the underlying function with f.__wrapped__.</font>
<font color="black">  60. </font>
<font color="black">  61.         See:  https://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="black">  63. </font>
<font color="black">  64.         # Users should only access the lru_cache through its public API:</font>
<font color="black">  65.         #       cache_info, cache_clear, and f.__wrapped__</font>
<font color="black">  66.         # The internals of the lru_cache are encapsulated for thread safety and</font>
<font color="black">  67.         # to allow the implementation to change (including a possible C version).</font>
<font color="black">  68. </font>
<font color="green">  69.         def decorating_function(user_function):</font>
<font color="black">  70. </font>
<font color="green">  71.             cache = dict()</font>
<font color="green">  72.             stats = [0, 0]                  # make statistics updateable non-locally</font>
<font color="green">  73.             HITS, MISSES = 0, 1             # names for the stats fields</font>
<font color="green">  74.             make_key = _make_key</font>
<font color="green">  75.             cache_get = cache.get           # bound method to lookup key or return None</font>
<font color="green">  76.             _len = len                      # localize the global len() function</font>
<font color="green">  77.             lock = RLock()                  # because linkedlist updates aren't threadsafe</font>
<font color="green">  78.             root = []                       # root of the circular doubly linked list</font>
<font color="green">  79.             root[:] = [root, root, None, None]      # initialize by pointing to self</font>
<font color="green">  80.             nonlocal_root = [root]                  # make updateable non-locally</font>
<font color="green">  81.             PREV, NEXT, KEY, RESULT = 0, 1, 2, 3    # names for the link fields</font>
<font color="black">  82. </font>
<font color="green">  83.             if maxsize == 0:</font>
<font color="black">  84. </font>
<font color="red">  85.                 def wrapper(*args, **kwds):</font>
<font color="black">  86.                     # no caching, just do a statistics update after a successful call</font>
<font color="red">  87.                     result = user_function(*args, **kwds)</font>
<font color="red">  88.                     stats[MISSES] += 1</font>
<font color="red">  89.                     return result</font>
<font color="black">  90. </font>
<font color="green">  91.             elif maxsize is None:</font>
<font color="black">  92. </font>
<font color="green">  93.                 def wrapper(*args, **kwds):</font>
<font color="black">  94.                     # simple caching without ordering or size limit</font>
<font color="green">  95.                     key = make_key(args, kwds, typed)</font>
<font color="green">  96.                     result = cache_get(key, root)   # root used here as a unique not-found sentinel</font>
<font color="green">  97.                     if result is not root:</font>
<font color="green">  98.                         stats[HITS] += 1</font>
<font color="green">  99.                         return result</font>
<font color="green"> 100.                     result = user_function(*args, **kwds)</font>
<font color="green"> 101.                     cache[key] = result</font>
<font color="green"> 102.                     stats[MISSES] += 1</font>
<font color="green"> 103.                     return result</font>
<font color="black"> 104. </font>
<font color="black"> 105.             else:</font>
<font color="black"> 106. </font>
<font color="green"> 107.                 def wrapper(*args, **kwds):</font>
<font color="black"> 108.                     # size limited caching that tracks accesses by recency</font>
<font color="red"> 109.                     key = make_key(args, kwds, typed) if kwds or typed else args</font>
<font color="red"> 110.                     with lock:</font>
<font color="red"> 111.                         link = cache_get(key)</font>
<font color="red"> 112.                         if link is not None:</font>
<font color="black"> 113.                             # record recent use of the key by moving it to the front of the list</font>
<font color="red"> 114.                             root, = nonlocal_root</font>
<font color="red"> 115.                             link_prev, link_next, key, result = link</font>
<font color="red"> 116.                             link_prev[NEXT] = link_next</font>
<font color="red"> 117.                             link_next[PREV] = link_prev</font>
<font color="red"> 118.                             last = root[PREV]</font>
<font color="red"> 119.                             last[NEXT] = root[PREV] = link</font>
<font color="red"> 120.                             link[PREV] = last</font>
<font color="red"> 121.                             link[NEXT] = root</font>
<font color="red"> 122.                             stats[HITS] += 1</font>
<font color="red"> 123.                             return result</font>
<font color="red"> 124.                     result = user_function(*args, **kwds)</font>
<font color="red"> 125.                     with lock:</font>
<font color="red"> 126.                         root, = nonlocal_root</font>
<font color="red"> 127.                         if key in cache:</font>
<font color="black"> 128.                             # getting here means that this same key was added to the</font>
<font color="black"> 129.                             # cache while the lock was released.  since the link</font>
<font color="black"> 130.                             # update is already done, we need only return the</font>
<font color="black"> 131.                             # computed result and update the count of misses.</font>
<font color="red"> 132.                             pass</font>
<font color="red"> 133.                         elif _len(cache) &gt;= maxsize:</font>
<font color="black"> 134.                             # use the old root to store the new key and result</font>
<font color="red"> 135.                             oldroot = root</font>
<font color="red"> 136.                             oldroot[KEY] = key</font>
<font color="red"> 137.                             oldroot[RESULT] = result</font>
<font color="black"> 138.                             # empty the oldest link and make it the new root</font>
<font color="red"> 139.                             root = nonlocal_root[0] = oldroot[NEXT]</font>
<font color="red"> 140.                             oldkey = root[KEY]</font>
<font color="red"> 141.                             oldvalue = root[RESULT]</font>
<font color="red"> 142.                             root[KEY] = root[RESULT] = None</font>
<font color="black"> 143.                             # now update the cache dictionary for the new links</font>
<font color="red"> 144.                             del cache[oldkey]</font>
<font color="red"> 145.                             cache[key] = oldroot</font>
<font color="black"> 146.                         else:</font>
<font color="black"> 147.                             # put result in a new link at the front of the list</font>
<font color="red"> 148.                             last = root[PREV]</font>
<font color="red"> 149.                             link = [last, root, key, result]</font>
<font color="red"> 150.                             last[NEXT] = root[PREV] = cache[key] = link</font>
<font color="red"> 151.                         stats[MISSES] += 1</font>
<font color="red"> 152.                     return result</font>
<font color="black"> 153. </font>
<font color="green"> 154.             def cache_info():</font>
<font color="black"> 155.                 &quot;&quot;&quot;Report cache statistics&quot;&quot;&quot;</font>
<font color="red"> 156.                 with lock:</font>
<font color="red"> 157.                     return _CacheInfo(stats[HITS], stats[MISSES], maxsize, len(cache))</font>
<font color="black"> 158. </font>
<font color="green"> 159.             def cache_clear():</font>
<font color="black"> 160.                 &quot;&quot;&quot;Clear the cache and cache statistics&quot;&quot;&quot;</font>
<font color="green"> 161.                 with lock:</font>
<font color="green"> 162.                     cache.clear()</font>
<font color="green"> 163.                     root = nonlocal_root[0]</font>
<font color="green"> 164.                     root[:] = [root, root, None, None]</font>
<font color="green"> 165.                     stats[:] = [0, 0]</font>
<font color="black"> 166. </font>
<font color="green"> 167.             wrapper.__wrapped__ = user_function</font>
<font color="green"> 168.             wrapper.cache_info = cache_info</font>
<font color="green"> 169.             wrapper.cache_clear = cache_clear</font>
<font color="green"> 170.             return update_wrapper(wrapper, user_function)</font>
<font color="black"> 171. </font>
<font color="green"> 172.         return decorating_function</font>
</pre>

