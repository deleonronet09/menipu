source file: <b>/usr/lib/python2.7/quopri.py</b><br>


file stats: <b>162 lines, 18 executed: 11.1% covered</b>
<pre>
<font color="black">   1. #! /usr/bin/python2.7</font>
<font color="black">   2. </font>
<font color="green">   3. &quot;&quot;&quot;Conversions to/from quoted-printable transport encoding as per RFC 1521.&quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="black">   5. # (Dec 1991 version).</font>
<font color="black">   6. </font>
<font color="green">   7. __all__ = [&quot;encode&quot;, &quot;decode&quot;, &quot;encodestring&quot;, &quot;decodestring&quot;]</font>
<font color="black">   8. </font>
<font color="green">   9. ESCAPE = '='</font>
<font color="green">  10. MAXLINESIZE = 76</font>
<font color="green">  11. HEX = '0123456789ABCDEF'</font>
<font color="green">  12. EMPTYSTRING = ''</font>
<font color="black">  13. </font>
<font color="green">  14. try:</font>
<font color="green">  15.     from binascii import a2b_qp, b2a_qp</font>
<font color="red">  16. except ImportError:</font>
<font color="red">  17.     a2b_qp = None</font>
<font color="red">  18.     b2a_qp = None</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. def needsquoting(c, quotetabs, header):</font>
<font color="black">  22.     &quot;&quot;&quot;Decide whether a particular character needs to be quoted.</font>
<font color="black">  23. </font>
<font color="black">  24.     The 'quotetabs' flag indicates whether embedded tabs and spaces should be</font>
<font color="black">  25.     quoted.  Note that line-ending tabs and spaces are always encoded, as per</font>
<font color="black">  26.     RFC 1521.</font>
<font color="black">  27.     &quot;&quot;&quot;</font>
<font color="red">  28.     if c in ' \t':</font>
<font color="red">  29.         return quotetabs</font>
<font color="black">  30.     # if header, we have to escape _ because _ is used to escape space</font>
<font color="red">  31.     if c == '_':</font>
<font color="red">  32.         return header</font>
<font color="red">  33.     return c == ESCAPE or not (' ' &lt;= c &lt;= '~')</font>
<font color="black">  34. </font>
<font color="green">  35. def quote(c):</font>
<font color="black">  36.     &quot;&quot;&quot;Quote a single character.&quot;&quot;&quot;</font>
<font color="red">  37.     i = ord(c)</font>
<font color="red">  38.     return ESCAPE + HEX[i//16] + HEX[i%16]</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. def encode(input, output, quotetabs, header = 0):</font>
<font color="black">  43.     &quot;&quot;&quot;Read 'input', apply quoted-printable encoding, and write to 'output'.</font>
<font color="black">  44. </font>
<font color="black">  45.     'input' and 'output' are files with readline() and write() methods.</font>
<font color="black">  46.     The 'quotetabs' flag indicates whether embedded tabs and spaces should be</font>
<font color="black">  47.     quoted.  Note that line-ending tabs and spaces are always encoded, as per</font>
<font color="black">  48.     RFC 1521.</font>
<font color="black">  49.     The 'header' flag indicates whether we are encoding spaces as _ as per</font>
<font color="black">  50.     RFC 1522.</font>
<font color="black">  51.     &quot;&quot;&quot;</font>
<font color="black">  52. </font>
<font color="red">  53.     if b2a_qp is not None:</font>
<font color="red">  54.         data = input.read()</font>
<font color="red">  55.         odata = b2a_qp(data, quotetabs = quotetabs, header = header)</font>
<font color="red">  56.         output.write(odata)</font>
<font color="red">  57.         return</font>
<font color="black">  58. </font>
<font color="red">  59.     def write(s, output=output, lineEnd='\n'):</font>
<font color="black">  60.         # RFC 1521 requires that the line ending in a space or tab must have</font>
<font color="black">  61.         # that trailing character encoded.</font>
<font color="red">  62.         if s and s[-1:] in ' \t':</font>
<font color="red">  63.             output.write(s[:-1] + quote(s[-1]) + lineEnd)</font>
<font color="red">  64.         elif s == '.':</font>
<font color="red">  65.             output.write(quote(s) + lineEnd)</font>
<font color="black">  66.         else:</font>
<font color="red">  67.             output.write(s + lineEnd)</font>
<font color="black">  68. </font>
<font color="red">  69.     prevline = None</font>
<font color="red">  70.     while 1:</font>
<font color="red">  71.         line = input.readline()</font>
<font color="red">  72.         if not line:</font>
<font color="red">  73.             break</font>
<font color="red">  74.         outline = []</font>
<font color="black">  75.         # Strip off any readline induced trailing newline</font>
<font color="red">  76.         stripped = ''</font>
<font color="red">  77.         if line[-1:] == '\n':</font>
<font color="red">  78.             line = line[:-1]</font>
<font color="red">  79.             stripped = '\n'</font>
<font color="black">  80.         # Calculate the un-length-limited encoded line</font>
<font color="red">  81.         for c in line:</font>
<font color="red">  82.             if needsquoting(c, quotetabs, header):</font>
<font color="red">  83.                 c = quote(c)</font>
<font color="red">  84.             if header and c == ' ':</font>
<font color="red">  85.                 outline.append('_')</font>
<font color="black">  86.             else:</font>
<font color="red">  87.                 outline.append(c)</font>
<font color="black">  88.         # First, write out the previous line</font>
<font color="red">  89.         if prevline is not None:</font>
<font color="red">  90.             write(prevline)</font>
<font color="black">  91.         # Now see if we need any soft line breaks because of RFC-imposed</font>
<font color="black">  92.         # length limitations.  Then do the thisline-&gt;prevline dance.</font>
<font color="red">  93.         thisline = EMPTYSTRING.join(outline)</font>
<font color="red">  94.         while len(thisline) &gt; MAXLINESIZE:</font>
<font color="black">  95.             # Don't forget to include the soft line break `=' sign in the</font>
<font color="black">  96.             # length calculation!</font>
<font color="red">  97.             write(thisline[:MAXLINESIZE-1], lineEnd='=\n')</font>
<font color="red">  98.             thisline = thisline[MAXLINESIZE-1:]</font>
<font color="black">  99.         # Write out the current line</font>
<font color="red"> 100.         prevline = thisline</font>
<font color="black"> 101.     # Write out the last line, without a trailing newline</font>
<font color="red"> 102.     if prevline is not None:</font>
<font color="red"> 103.         write(prevline, lineEnd=stripped)</font>
<font color="black"> 104. </font>
<font color="green"> 105. def encodestring(s, quotetabs = 0, header = 0):</font>
<font color="red"> 106.     if b2a_qp is not None:</font>
<font color="red"> 107.         return b2a_qp(s, quotetabs = quotetabs, header = header)</font>
<font color="red"> 108.     from cStringIO import StringIO</font>
<font color="red"> 109.     infp = StringIO(s)</font>
<font color="red"> 110.     outfp = StringIO()</font>
<font color="red"> 111.     encode(infp, outfp, quotetabs, header)</font>
<font color="red"> 112.     return outfp.getvalue()</font>
<font color="black"> 113. </font>
<font color="black"> 114. </font>
<font color="black"> 115. </font>
<font color="green"> 116. def decode(input, output, header = 0):</font>
<font color="black"> 117.     &quot;&quot;&quot;Read 'input', apply quoted-printable decoding, and write to 'output'.</font>
<font color="black"> 118.     'input' and 'output' are files with readline() and write() methods.</font>
<font color="black"> 119.     If 'header' is true, decode underscore as space (per RFC 1522).&quot;&quot;&quot;</font>
<font color="black"> 120. </font>
<font color="red"> 121.     if a2b_qp is not None:</font>
<font color="red"> 122.         data = input.read()</font>
<font color="red"> 123.         odata = a2b_qp(data, header = header)</font>
<font color="red"> 124.         output.write(odata)</font>
<font color="red"> 125.         return</font>
<font color="black"> 126. </font>
<font color="red"> 127.     new = ''</font>
<font color="red"> 128.     while 1:</font>
<font color="red"> 129.         line = input.readline()</font>
<font color="red"> 130.         if not line: break</font>
<font color="red"> 131.         i, n = 0, len(line)</font>
<font color="red"> 132.         if n &gt; 0 and line[n-1] == '\n':</font>
<font color="red"> 133.             partial = 0; n = n-1</font>
<font color="black"> 134.             # Strip trailing whitespace</font>
<font color="red"> 135.             while n &gt; 0 and line[n-1] in &quot; \t\r&quot;:</font>
<font color="red"> 136.                 n = n-1</font>
<font color="black"> 137.         else:</font>
<font color="red"> 138.             partial = 1</font>
<font color="red"> 139.         while i &lt; n:</font>
<font color="red"> 140.             c = line[i]</font>
<font color="red"> 141.             if c == '_' and header:</font>
<font color="red"> 142.                 new = new + ' '; i = i+1</font>
<font color="red"> 143.             elif c != ESCAPE:</font>
<font color="red"> 144.                 new = new + c; i = i+1</font>
<font color="red"> 145.             elif i+1 == n and not partial:</font>
<font color="red"> 146.                 partial = 1; break</font>
<font color="red"> 147.             elif i+1 &lt; n and line[i+1] == ESCAPE:</font>
<font color="red"> 148.                 new = new + ESCAPE; i = i+2</font>
<font color="red"> 149.             elif i+2 &lt; n and ishex(line[i+1]) and ishex(line[i+2]):</font>
<font color="red"> 150.                 new = new + chr(unhex(line[i+1:i+3])); i = i+3</font>
<font color="black"> 151.             else: # Bad escape sequence -- leave it in</font>
<font color="red"> 152.                 new = new + c; i = i+1</font>
<font color="red"> 153.         if not partial:</font>
<font color="red"> 154.             output.write(new + '\n')</font>
<font color="red"> 155.             new = ''</font>
<font color="red"> 156.     if new:</font>
<font color="red"> 157.         output.write(new)</font>
<font color="black"> 158. </font>
<font color="green"> 159. def decodestring(s, header = 0):</font>
<font color="red"> 160.     if a2b_qp is not None:</font>
<font color="red"> 161.         return a2b_qp(s, header = header)</font>
<font color="red"> 162.     from cStringIO import StringIO</font>
<font color="red"> 163.     infp = StringIO(s)</font>
<font color="red"> 164.     outfp = StringIO()</font>
<font color="red"> 165.     decode(infp, outfp, header = header)</font>
<font color="red"> 166.     return outfp.getvalue()</font>
<font color="black"> 167. </font>
<font color="black"> 168. </font>
<font color="black"> 169. </font>
<font color="black"> 170. # Other helper functions</font>
<font color="green"> 171. def ishex(c):</font>
<font color="black"> 172.     &quot;&quot;&quot;Return true if the character 'c' is a hexadecimal digit.&quot;&quot;&quot;</font>
<font color="red"> 173.     return '0' &lt;= c &lt;= '9' or 'a' &lt;= c &lt;= 'f' or 'A' &lt;= c &lt;= 'F'</font>
<font color="black"> 174. </font>
<font color="green"> 175. def unhex(s):</font>
<font color="black"> 176.     &quot;&quot;&quot;Get the integer value of a hexadecimal number.&quot;&quot;&quot;</font>
<font color="red"> 177.     bits = 0</font>
<font color="red"> 178.     for c in s:</font>
<font color="red"> 179.         if '0' &lt;= c &lt;= '9':</font>
<font color="red"> 180.             i = ord('0')</font>
<font color="red"> 181.         elif 'a' &lt;= c &lt;= 'f':</font>
<font color="red"> 182.             i = ord('a')-10</font>
<font color="red"> 183.         elif 'A' &lt;= c &lt;= 'F':</font>
<font color="red"> 184.             i = ord('A')-10</font>
<font color="black"> 185.         else:</font>
<font color="red"> 186.             break</font>
<font color="red"> 187.         bits = bits*16 + (ord(c) - i)</font>
<font color="red"> 188.     return bits</font>
<font color="black"> 189. </font>
<font color="black"> 190. </font>
<font color="black"> 191. </font>
<font color="green"> 192. def main():</font>
<font color="red"> 193.     import sys</font>
<font color="red"> 194.     import getopt</font>
<font color="red"> 195.     try:</font>
<font color="red"> 196.         opts, args = getopt.getopt(sys.argv[1:], 'td')</font>
<font color="red"> 197.     except getopt.error, msg:</font>
<font color="red"> 198.         sys.stdout = sys.stderr</font>
<font color="red"> 199.         print msg</font>
<font color="red"> 200.         print &quot;usage: quopri [-t | -d] [file] ...&quot;</font>
<font color="red"> 201.         print &quot;-t: quote tabs&quot;</font>
<font color="red"> 202.         print &quot;-d: decode; default encode&quot;</font>
<font color="red"> 203.         sys.exit(2)</font>
<font color="red"> 204.     deco = 0</font>
<font color="red"> 205.     tabs = 0</font>
<font color="red"> 206.     for o, a in opts:</font>
<font color="red"> 207.         if o == '-t': tabs = 1</font>
<font color="red"> 208.         if o == '-d': deco = 1</font>
<font color="red"> 209.     if tabs and deco:</font>
<font color="red"> 210.         sys.stdout = sys.stderr</font>
<font color="red"> 211.         print &quot;-t and -d are mutually exclusive&quot;</font>
<font color="red"> 212.         sys.exit(2)</font>
<font color="red"> 213.     if not args: args = ['-']</font>
<font color="red"> 214.     sts = 0</font>
<font color="red"> 215.     for file in args:</font>
<font color="red"> 216.         if file == '-':</font>
<font color="red"> 217.             fp = sys.stdin</font>
<font color="black"> 218.         else:</font>
<font color="red"> 219.             try:</font>
<font color="red"> 220.                 fp = open(file)</font>
<font color="red"> 221.             except IOError, msg:</font>
<font color="red"> 222.                 sys.stderr.write(&quot;%s: can't open (%s)\n&quot; % (file, msg))</font>
<font color="red"> 223.                 sts = 1</font>
<font color="red"> 224.                 continue</font>
<font color="red"> 225.         if deco:</font>
<font color="red"> 226.             decode(fp, sys.stdout)</font>
<font color="black"> 227.         else:</font>
<font color="red"> 228.             encode(fp, sys.stdout, tabs)</font>
<font color="red"> 229.         if fp is not sys.stdin:</font>
<font color="red"> 230.             fp.close()</font>
<font color="red"> 231.     if sts:</font>
<font color="red"> 232.         sys.exit(sts)</font>
<font color="black"> 233. </font>
<font color="black"> 234. </font>
<font color="black"> 235. </font>
<font color="green"> 236. if __name__ == '__main__':</font>
<font color="red"> 237.     main()</font>
</pre>

