source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/_compat.py</b><br>


file stats: <b>69 lines, 43 executed: 62.3% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2._compat</font>
<font color="black">   4.     ~~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Some py2/py3 compatibility support based on a stripped down</font>
<font color="black">   7.     version of six so we don't have to depend on a specific version</font>
<font color="black">   8.     of it.</font>
<font color="black">   9. </font>
<font color="black">  10.     :copyright: Copyright 2013 by the Jinja team, see AUTHORS.</font>
<font color="black">  11.     :license: BSD, see LICENSE for details.</font>
<font color="green">  12. &quot;&quot;&quot;</font>
<font color="green">  13. import sys</font>
<font color="black">  14. </font>
<font color="green">  15. PY2 = sys.version_info[0] == 2</font>
<font color="green">  16. PYPY = hasattr(sys, 'pypy_translation_info')</font>
<font color="green">  17. _identity = lambda x: x</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. if not PY2:</font>
<font color="red">  21.     unichr = chr</font>
<font color="red">  22.     range_type = range</font>
<font color="red">  23.     text_type = str</font>
<font color="red">  24.     string_types = (str,)</font>
<font color="red">  25.     integer_types = (int,)</font>
<font color="black">  26. </font>
<font color="red">  27.     iterkeys = lambda d: iter(d.keys())</font>
<font color="red">  28.     itervalues = lambda d: iter(d.values())</font>
<font color="red">  29.     iteritems = lambda d: iter(d.items())</font>
<font color="black">  30. </font>
<font color="red">  31.     import pickle</font>
<font color="red">  32.     from io import BytesIO, StringIO</font>
<font color="red">  33.     NativeStringIO = StringIO</font>
<font color="black">  34. </font>
<font color="red">  35.     def reraise(tp, value, tb=None):</font>
<font color="red">  36.         if value.__traceback__ is not tb:</font>
<font color="red">  37.             raise value.with_traceback(tb)</font>
<font color="red">  38.         raise value</font>
<font color="black">  39. </font>
<font color="red">  40.     ifilter = filter</font>
<font color="red">  41.     imap = map</font>
<font color="red">  42.     izip = zip</font>
<font color="red">  43.     intern = sys.intern</font>
<font color="black">  44. </font>
<font color="red">  45.     implements_iterator = _identity</font>
<font color="red">  46.     implements_to_string = _identity</font>
<font color="red">  47.     encode_filename = _identity</font>
<font color="red">  48.     get_next = lambda x: x.__next__</font>
<font color="black">  49. </font>
<font color="black">  50. else:</font>
<font color="green">  51.     unichr = unichr</font>
<font color="green">  52.     text_type = unicode</font>
<font color="green">  53.     range_type = xrange</font>
<font color="green">  54.     string_types = (str, unicode)</font>
<font color="green">  55.     integer_types = (int, long)</font>
<font color="black">  56. </font>
<font color="green">  57.     iterkeys = lambda d: d.iterkeys()</font>
<font color="green">  58.     itervalues = lambda d: d.itervalues()</font>
<font color="green">  59.     iteritems = lambda d: d.iteritems()</font>
<font color="black">  60. </font>
<font color="green">  61.     import cPickle as pickle</font>
<font color="green">  62.     from cStringIO import StringIO as BytesIO, StringIO</font>
<font color="green">  63.     NativeStringIO = BytesIO</font>
<font color="black">  64. </font>
<font color="green">  65.     exec('def reraise(tp, value, tb=None):\n raise tp, value, tb')</font>
<font color="black">  66. </font>
<font color="green">  67.     from itertools import imap, izip, ifilter</font>
<font color="green">  68.     intern = intern</font>
<font color="black">  69. </font>
<font color="green">  70.     def implements_iterator(cls):</font>
<font color="green">  71.         cls.next = cls.__next__</font>
<font color="green">  72.         del cls.__next__</font>
<font color="green">  73.         return cls</font>
<font color="black">  74. </font>
<font color="green">  75.     def implements_to_string(cls):</font>
<font color="green">  76.         cls.__unicode__ = cls.__str__</font>
<font color="green">  77.         cls.__str__ = lambda x: x.__unicode__().encode('utf-8')</font>
<font color="green">  78.         return cls</font>
<font color="black">  79. </font>
<font color="green">  80.     get_next = lambda x: x.next</font>
<font color="black">  81. </font>
<font color="green">  82.     def encode_filename(filename):</font>
<font color="red">  83.         if isinstance(filename, unicode):</font>
<font color="red">  84.             return filename.encode('utf-8')</font>
<font color="red">  85.         return filename</font>
<font color="black">  86. </font>
<font color="black">  87. </font>
<font color="green">  88. def with_metaclass(meta, *bases):</font>
<font color="black">  89.     # This requires a bit of explanation: the basic idea is to make a</font>
<font color="black">  90.     # dummy metaclass for one level of class instanciation that replaces</font>
<font color="black">  91.     # itself with the actual metaclass.  Because of internal type checks</font>
<font color="black">  92.     # we also need to make sure that we downgrade the custom metaclass</font>
<font color="black">  93.     # for one level to something closer to type (that's why __call__ and</font>
<font color="black">  94.     # __init__ comes back from type etc.).</font>
<font color="black">  95.     #</font>
<font color="black">  96.     # This has the advantage over six.with_metaclass in that it does not</font>
<font color="black">  97.     # introduce dummy classes into the final MRO.</font>
<font color="green">  98.     class metaclass(meta):</font>
<font color="green">  99.         __call__ = type.__call__</font>
<font color="green"> 100.         __init__ = type.__init__</font>
<font color="green"> 101.         def __new__(cls, name, this_bases, d):</font>
<font color="green"> 102.             if this_bases is None:</font>
<font color="green"> 103.                 return type.__new__(cls, name, (), d)</font>
<font color="green"> 104.             return meta(name, bases, d)</font>
<font color="green"> 105.     return metaclass('temporary_class', None, {})</font>
<font color="black"> 106. </font>
<font color="black"> 107. </font>
<font color="green"> 108. try:</font>
<font color="green"> 109.     from urllib.parse import quote_from_bytes as url_quote</font>
<font color="green"> 110. except ImportError:</font>
<font color="green"> 111.     from urllib import quote as url_quote</font>
</pre>

