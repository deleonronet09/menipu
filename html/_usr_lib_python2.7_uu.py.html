source file: <b>/usr/lib/python2.7/uu.py</b><br>


file stats: <b>121 lines, 11 executed: 9.1% covered</b>
<pre>
<font color="black">   1. #! /usr/bin/python2.7</font>
<font color="black">   2. </font>
<font color="black">   3. # Copyright 1994 by Lance Ellinghouse</font>
<font color="black">   4. # Cathedral City, California Republic, United States of America.</font>
<font color="black">   5. #                        All Rights Reserved</font>
<font color="black">   6. # Permission to use, copy, modify, and distribute this software and its</font>
<font color="black">   7. # documentation for any purpose and without fee is hereby granted,</font>
<font color="black">   8. # provided that the above copyright notice appear in all copies and that</font>
<font color="black">   9. # both that copyright notice and this permission notice appear in</font>
<font color="black">  10. # supporting documentation, and that the name of Lance Ellinghouse</font>
<font color="black">  11. # not be used in advertising or publicity pertaining to distribution</font>
<font color="black">  12. # of the software without specific, written prior permission.</font>
<font color="black">  13. # LANCE ELLINGHOUSE DISCLAIMS ALL WARRANTIES WITH REGARD TO</font>
<font color="black">  14. # THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND</font>
<font color="black">  15. # FITNESS, IN NO EVENT SHALL LANCE ELLINGHOUSE CENTRUM BE LIABLE</font>
<font color="black">  16. # FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</font>
<font color="black">  17. # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</font>
<font color="black">  18. # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</font>
<font color="black">  19. # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</font>
<font color="black">  20. #</font>
<font color="black">  21. # Modified by Jack Jansen, CWI, July 1995:</font>
<font color="black">  22. # - Use binascii module to do the actual line-by-line conversion</font>
<font color="black">  23. #   between ascii and binary. This results in a 1000-fold speedup. The C</font>
<font color="black">  24. #   version is still 5 times faster, though.</font>
<font color="black">  25. # - Arguments more compliant with python standard</font>
<font color="black">  26. </font>
<font color="black">  27. &quot;&quot;&quot;Implementation of the UUencode and UUdecode functions.</font>
<font color="black">  28. </font>
<font color="black">  29. encode(in_file, out_file [,name, mode])</font>
<font color="black">  30. decode(in_file [, out_file, mode])</font>
<font color="green">  31. &quot;&quot;&quot;</font>
<font color="black">  32. </font>
<font color="green">  33. import binascii</font>
<font color="green">  34. import os</font>
<font color="green">  35. import sys</font>
<font color="black">  36. </font>
<font color="green">  37. __all__ = [&quot;Error&quot;, &quot;encode&quot;, &quot;decode&quot;]</font>
<font color="black">  38. </font>
<font color="green">  39. class Error(Exception):</font>
<font color="green">  40.     pass</font>
<font color="black">  41. </font>
<font color="green">  42. def encode(in_file, out_file, name=None, mode=None):</font>
<font color="black">  43.     &quot;&quot;&quot;Uuencode file&quot;&quot;&quot;</font>
<font color="black">  44.     #</font>
<font color="black">  45.     # If in_file is a pathname open it and change defaults</font>
<font color="black">  46.     #</font>
<font color="red">  47.     opened_files = []</font>
<font color="red">  48.     try:</font>
<font color="red">  49.         if in_file == '-':</font>
<font color="red">  50.             in_file = sys.stdin</font>
<font color="red">  51.         elif isinstance(in_file, basestring):</font>
<font color="red">  52.             if name is None:</font>
<font color="red">  53.                 name = os.path.basename(in_file)</font>
<font color="red">  54.             if mode is None:</font>
<font color="red">  55.                 try:</font>
<font color="red">  56.                     mode = os.stat(in_file).st_mode</font>
<font color="red">  57.                 except AttributeError:</font>
<font color="red">  58.                     pass</font>
<font color="red">  59.             in_file = open(in_file, 'rb')</font>
<font color="red">  60.             opened_files.append(in_file)</font>
<font color="black">  61.         #</font>
<font color="black">  62.         # Open out_file if it is a pathname</font>
<font color="black">  63.         #</font>
<font color="red">  64.         if out_file == '-':</font>
<font color="red">  65.             out_file = sys.stdout</font>
<font color="red">  66.         elif isinstance(out_file, basestring):</font>
<font color="red">  67.             out_file = open(out_file, 'wb')</font>
<font color="red">  68.             opened_files.append(out_file)</font>
<font color="black">  69.         #</font>
<font color="black">  70.         # Set defaults for name and mode</font>
<font color="black">  71.         #</font>
<font color="red">  72.         if name is None:</font>
<font color="red">  73.             name = '-'</font>
<font color="red">  74.         if mode is None:</font>
<font color="red">  75.             mode = 0666</font>
<font color="black">  76.         #</font>
<font color="black">  77.         # Write the data</font>
<font color="black">  78.         #</font>
<font color="red">  79.         out_file.write('begin %o %s\n' % ((mode&amp;0777),name))</font>
<font color="red">  80.         data = in_file.read(45)</font>
<font color="red">  81.         while len(data) &gt; 0:</font>
<font color="red">  82.             out_file.write(binascii.b2a_uu(data))</font>
<font color="red">  83.             data = in_file.read(45)</font>
<font color="red">  84.         out_file.write(' \nend\n')</font>
<font color="black">  85.     finally:</font>
<font color="red">  86.         for f in opened_files:</font>
<font color="red">  87.             f.close()</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="green">  90. def decode(in_file, out_file=None, mode=None, quiet=0):</font>
<font color="black">  91.     &quot;&quot;&quot;Decode uuencoded file&quot;&quot;&quot;</font>
<font color="black">  92.     #</font>
<font color="black">  93.     # Open the input file, if needed.</font>
<font color="black">  94.     #</font>
<font color="red">  95.     opened_files = []</font>
<font color="red">  96.     if in_file == '-':</font>
<font color="red">  97.         in_file = sys.stdin</font>
<font color="red">  98.     elif isinstance(in_file, basestring):</font>
<font color="red">  99.         in_file = open(in_file)</font>
<font color="red"> 100.         opened_files.append(in_file)</font>
<font color="red"> 101.     try:</font>
<font color="black"> 102.         #</font>
<font color="black"> 103.         # Read until a begin is encountered or we've exhausted the file</font>
<font color="black"> 104.         #</font>
<font color="red"> 105.         while True:</font>
<font color="red"> 106.             hdr = in_file.readline()</font>
<font color="red"> 107.             if not hdr:</font>
<font color="red"> 108.                 raise Error('No valid begin line found in input file')</font>
<font color="red"> 109.             if not hdr.startswith('begin'):</font>
<font color="red"> 110.                 continue</font>
<font color="red"> 111.             hdrfields = hdr.split(' ', 2)</font>
<font color="red"> 112.             if len(hdrfields) == 3 and hdrfields[0] == 'begin':</font>
<font color="red"> 113.                 try:</font>
<font color="red"> 114.                     int(hdrfields[1], 8)</font>
<font color="red"> 115.                     break</font>
<font color="red"> 116.                 except ValueError:</font>
<font color="red"> 117.                     pass</font>
<font color="red"> 118.         if out_file is None:</font>
<font color="red"> 119.             out_file = hdrfields[2].rstrip()</font>
<font color="red"> 120.             if os.path.exists(out_file):</font>
<font color="red"> 121.                 raise Error('Cannot overwrite existing file: %s' % out_file)</font>
<font color="red"> 122.         if mode is None:</font>
<font color="red"> 123.             mode = int(hdrfields[1], 8)</font>
<font color="black"> 124.         #</font>
<font color="black"> 125.         # Open the output file</font>
<font color="black"> 126.         #</font>
<font color="red"> 127.         if out_file == '-':</font>
<font color="red"> 128.             out_file = sys.stdout</font>
<font color="red"> 129.         elif isinstance(out_file, basestring):</font>
<font color="red"> 130.             fp = open(out_file, 'wb')</font>
<font color="red"> 131.             try:</font>
<font color="red"> 132.                 os.path.chmod(out_file, mode)</font>
<font color="red"> 133.             except AttributeError:</font>
<font color="red"> 134.                 pass</font>
<font color="red"> 135.             out_file = fp</font>
<font color="red"> 136.             opened_files.append(out_file)</font>
<font color="black"> 137.         #</font>
<font color="black"> 138.         # Main decoding loop</font>
<font color="black"> 139.         #</font>
<font color="red"> 140.         s = in_file.readline()</font>
<font color="red"> 141.         while s and s.strip() != 'end':</font>
<font color="red"> 142.             try:</font>
<font color="red"> 143.                 data = binascii.a2b_uu(s)</font>
<font color="red"> 144.             except binascii.Error, v:</font>
<font color="black"> 145.                 # Workaround for broken uuencoders by /Fredrik Lundh</font>
<font color="red"> 146.                 nbytes = (((ord(s[0])-32) &amp; 63) * 4 + 5) // 3</font>
<font color="red"> 147.                 data = binascii.a2b_uu(s[:nbytes])</font>
<font color="red"> 148.                 if not quiet:</font>
<font color="red"> 149.                     sys.stderr.write(&quot;Warning: %s\n&quot; % v)</font>
<font color="red"> 150.             out_file.write(data)</font>
<font color="red"> 151.             s = in_file.readline()</font>
<font color="red"> 152.         if not s:</font>
<font color="red"> 153.             raise Error('Truncated input file')</font>
<font color="black"> 154.     finally:</font>
<font color="red"> 155.         for f in opened_files:</font>
<font color="red"> 156.             f.close()</font>
<font color="black"> 157. </font>
<font color="green"> 158. def test():</font>
<font color="black"> 159.     &quot;&quot;&quot;uuencode/uudecode main program&quot;&quot;&quot;</font>
<font color="black"> 160. </font>
<font color="red"> 161.     import optparse</font>
<font color="red"> 162.     parser = optparse.OptionParser(usage='usage: %prog [-d] [-t] [input [output]]')</font>
<font color="red"> 163.     parser.add_option('-d', '--decode', dest='decode', help='Decode (instead of encode)?', default=False, action='store_true')</font>
<font color="red"> 164.     parser.add_option('-t', '--text', dest='text', help='data is text, encoded format unix-compatible text?', default=False, action='store_true')</font>
<font color="black"> 165. </font>
<font color="red"> 166.     (options, args) = parser.parse_args()</font>
<font color="red"> 167.     if len(args) &gt; 2:</font>
<font color="red"> 168.         parser.error('incorrect number of arguments')</font>
<font color="red"> 169.         sys.exit(1)</font>
<font color="black"> 170. </font>
<font color="red"> 171.     input = sys.stdin</font>
<font color="red"> 172.     output = sys.stdout</font>
<font color="red"> 173.     if len(args) &gt; 0:</font>
<font color="red"> 174.         input = args[0]</font>
<font color="red"> 175.     if len(args) &gt; 1:</font>
<font color="red"> 176.         output = args[1]</font>
<font color="black"> 177. </font>
<font color="red"> 178.     if options.decode:</font>
<font color="red"> 179.         if options.text:</font>
<font color="red"> 180.             if isinstance(output, basestring):</font>
<font color="red"> 181.                 output = open(output, 'w')</font>
<font color="black"> 182.             else:</font>
<font color="red"> 183.                 print sys.argv[0], ': cannot do -t to stdout'</font>
<font color="red"> 184.                 sys.exit(1)</font>
<font color="red"> 185.         decode(input, output)</font>
<font color="black"> 186.     else:</font>
<font color="red"> 187.         if options.text:</font>
<font color="red"> 188.             if isinstance(input, basestring):</font>
<font color="red"> 189.                 input = open(input, 'r')</font>
<font color="black"> 190.             else:</font>
<font color="red"> 191.                 print sys.argv[0], ': cannot do -t from stdin'</font>
<font color="red"> 192.                 sys.exit(1)</font>
<font color="red"> 193.         encode(input, output)</font>
<font color="black"> 194. </font>
<font color="green"> 195. if __name__ == '__main__':</font>
<font color="red"> 196.     test()</font>
</pre>

