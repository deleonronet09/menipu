source file: <b>/usr/lib/python2.7/hmac.py</b><br>


file stats: <b>60 lines, 16 executed: 26.7% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;HMAC (Keyed-Hashing for Message Authentication) Python module.</font>
<font color="black">   2. </font>
<font color="black">   3. Implements the HMAC algorithm as described by RFC 2104.</font>
<font color="green">   4. &quot;&quot;&quot;</font>
<font color="black">   5. </font>
<font color="green">   6. import warnings as _warnings</font>
<font color="black">   7. </font>
<font color="green">   8. trans_5C = &quot;&quot;.join ([chr (x ^ 0x5C) for x in xrange(256)])</font>
<font color="green">   9. trans_36 = &quot;&quot;.join ([chr (x ^ 0x36) for x in xrange(256)])</font>
<font color="black">  10. </font>
<font color="black">  11. # The size of the digests returned by HMAC depends on the underlying</font>
<font color="black">  12. # hashing module used.  Use digest_size from the instance of HMAC instead.</font>
<font color="green">  13. digest_size = None</font>
<font color="black">  14. </font>
<font color="black">  15. # A unique object passed by HMAC.copy() to the HMAC constructor, in order</font>
<font color="black">  16. # that the latter return very quickly.  HMAC(&quot;&quot;) in contrast is quite</font>
<font color="black">  17. # expensive.</font>
<font color="green">  18. _secret_backdoor_key = []</font>
<font color="black">  19. </font>
<font color="green">  20. class HMAC:</font>
<font color="black">  21.     &quot;&quot;&quot;RFC 2104 HMAC class.  Also complies with RFC 4231.</font>
<font color="black">  22. </font>
<font color="black">  23.     This supports the API for Cryptographic Hash Functions (PEP 247).</font>
<font color="green">  24.     &quot;&quot;&quot;</font>
<font color="green">  25.     blocksize = 64  # 512-bit HMAC; can be changed in subclasses.</font>
<font color="black">  26. </font>
<font color="green">  27.     def __init__(self, key, msg = None, digestmod = None):</font>
<font color="black">  28.         &quot;&quot;&quot;Create a new HMAC object.</font>
<font color="black">  29. </font>
<font color="black">  30.         key:       key for the keyed hash object.</font>
<font color="black">  31.         msg:       Initial input for the hash, if provided.</font>
<font color="black">  32.         digestmod: A module supporting PEP 247.  *OR*</font>
<font color="black">  33.                    A hashlib constructor returning a new hash object.</font>
<font color="black">  34.                    Defaults to hashlib.md5.</font>
<font color="black">  35.         &quot;&quot;&quot;</font>
<font color="black">  36. </font>
<font color="red">  37.         if key is _secret_backdoor_key: # cheap</font>
<font color="red">  38.             return</font>
<font color="black">  39. </font>
<font color="red">  40.         if digestmod is None:</font>
<font color="red">  41.             import hashlib</font>
<font color="red">  42.             digestmod = hashlib.md5</font>
<font color="black">  43. </font>
<font color="red">  44.         if hasattr(digestmod, '__call__'):</font>
<font color="red">  45.             self.digest_cons = digestmod</font>
<font color="black">  46.         else:</font>
<font color="red">  47.             self.digest_cons = lambda d='': digestmod.new(d)</font>
<font color="black">  48. </font>
<font color="red">  49.         self.outer = self.digest_cons()</font>
<font color="red">  50.         self.inner = self.digest_cons()</font>
<font color="red">  51.         self.digest_size = self.inner.digest_size</font>
<font color="black">  52. </font>
<font color="red">  53.         if hasattr(self.inner, 'block_size'):</font>
<font color="red">  54.             blocksize = self.inner.block_size</font>
<font color="red">  55.             if blocksize &lt; 16:</font>
<font color="black">  56.                 # Very low blocksize, most likely a legacy value like</font>
<font color="black">  57.                 # Lib/sha.py and Lib/md5.py have.</font>
<font color="red">  58.                 _warnings.warn('block_size of %d seems too small; using our '</font>
<font color="red">  59.                                'default of %d.' % (blocksize, self.blocksize),</font>
<font color="red">  60.                                RuntimeWarning, 2)</font>
<font color="red">  61.                 blocksize = self.blocksize</font>
<font color="black">  62.         else:</font>
<font color="red">  63.             _warnings.warn('No block_size attribute on given digest object; '</font>
<font color="red">  64.                            'Assuming %d.' % (self.blocksize),</font>
<font color="red">  65.                            RuntimeWarning, 2)</font>
<font color="red">  66.             blocksize = self.blocksize</font>
<font color="black">  67. </font>
<font color="red">  68.         if len(key) &gt; blocksize:</font>
<font color="red">  69.             key = self.digest_cons(key).digest()</font>
<font color="black">  70. </font>
<font color="red">  71.         key = key + chr(0) * (blocksize - len(key))</font>
<font color="red">  72.         self.outer.update(key.translate(trans_5C))</font>
<font color="red">  73.         self.inner.update(key.translate(trans_36))</font>
<font color="red">  74.         if msg is not None:</font>
<font color="red">  75.             self.update(msg)</font>
<font color="black">  76. </font>
<font color="black">  77. ##    def clear(self):</font>
<font color="black">  78. ##        raise NotImplementedError, &quot;clear() method not available in HMAC.&quot;</font>
<font color="black">  79. </font>
<font color="green">  80.     def update(self, msg):</font>
<font color="black">  81.         &quot;&quot;&quot;Update this hashing object with the string msg.</font>
<font color="black">  82.         &quot;&quot;&quot;</font>
<font color="red">  83.         self.inner.update(msg)</font>
<font color="black">  84. </font>
<font color="green">  85.     def copy(self):</font>
<font color="black">  86.         &quot;&quot;&quot;Return a separate copy of this hashing object.</font>
<font color="black">  87. </font>
<font color="black">  88.         An update to this copy won't affect the original object.</font>
<font color="black">  89.         &quot;&quot;&quot;</font>
<font color="red">  90.         other = self.__class__(_secret_backdoor_key)</font>
<font color="red">  91.         other.digest_cons = self.digest_cons</font>
<font color="red">  92.         other.digest_size = self.digest_size</font>
<font color="red">  93.         other.inner = self.inner.copy()</font>
<font color="red">  94.         other.outer = self.outer.copy()</font>
<font color="red">  95.         return other</font>
<font color="black">  96. </font>
<font color="green">  97.     def _current(self):</font>
<font color="black">  98.         &quot;&quot;&quot;Return a hash object for the current state.</font>
<font color="black">  99. </font>
<font color="black"> 100.         To be used only internally with digest() and hexdigest().</font>
<font color="black"> 101.         &quot;&quot;&quot;</font>
<font color="red"> 102.         h = self.outer.copy()</font>
<font color="red"> 103.         h.update(self.inner.digest())</font>
<font color="red"> 104.         return h</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def digest(self):</font>
<font color="black"> 107.         &quot;&quot;&quot;Return the hash value of this hashing object.</font>
<font color="black"> 108. </font>
<font color="black"> 109.         This returns a string containing 8-bit data.  The object is</font>
<font color="black"> 110.         not altered in any way by this function; you can continue</font>
<font color="black"> 111.         updating the object after calling this function.</font>
<font color="black"> 112.         &quot;&quot;&quot;</font>
<font color="red"> 113.         h = self._current()</font>
<font color="red"> 114.         return h.digest()</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def hexdigest(self):</font>
<font color="black"> 117.         &quot;&quot;&quot;Like digest(), but returns a string of hexadecimal digits instead.</font>
<font color="black"> 118.         &quot;&quot;&quot;</font>
<font color="red"> 119.         h = self._current()</font>
<font color="red"> 120.         return h.hexdigest()</font>
<font color="black"> 121. </font>
<font color="green"> 122. def new(key, msg = None, digestmod = None):</font>
<font color="black"> 123.     &quot;&quot;&quot;Create a new hashing object and return it.</font>
<font color="black"> 124. </font>
<font color="black"> 125.     key: The starting key for the hash.</font>
<font color="black"> 126.     msg: if available, will immediately be hashed into the object's starting</font>
<font color="black"> 127.     state.</font>
<font color="black"> 128. </font>
<font color="black"> 129.     You can now feed arbitrary strings into the object using its update()</font>
<font color="black"> 130.     method, and can ask for the hash value at any time by calling its digest()</font>
<font color="black"> 131.     method.</font>
<font color="black"> 132.     &quot;&quot;&quot;</font>
<font color="red"> 133.     return HMAC(key, msg, digestmod)</font>
</pre>

