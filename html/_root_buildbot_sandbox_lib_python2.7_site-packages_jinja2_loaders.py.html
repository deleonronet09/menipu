source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/loaders.py</b><br>


file stats: <b>241 lines, 63 executed: 26.1% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.loaders</font>
<font color="black">   4.     ~~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Jinja loader classes.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">   9.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. import os</font>
<font color="green">  12. import sys</font>
<font color="green">  13. import weakref</font>
<font color="green">  14. from types import ModuleType</font>
<font color="green">  15. from os import path</font>
<font color="green">  16. from hashlib import sha1</font>
<font color="green">  17. from jinja2.exceptions import TemplateNotFound</font>
<font color="green">  18. from jinja2.utils import open_if_exists, internalcode</font>
<font color="green">  19. from jinja2._compat import string_types, iteritems</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. def split_template_path(template):</font>
<font color="black">  23.     &quot;&quot;&quot;Split a path into segments and perform a sanity check.  If it detects</font>
<font color="black">  24.     '..' in the path it will raise a `TemplateNotFound` error.</font>
<font color="black">  25.     &quot;&quot;&quot;</font>
<font color="red">  26.     pieces = []</font>
<font color="red">  27.     for piece in template.split('/'):</font>
<font color="red">  28.         if path.sep in piece \</font>
<font color="red">  29.            or (path.altsep and path.altsep in piece) or \</font>
<font color="red">  30.            piece == path.pardir:</font>
<font color="red">  31.             raise TemplateNotFound(template)</font>
<font color="red">  32.         elif piece and piece != '.':</font>
<font color="red">  33.             pieces.append(piece)</font>
<font color="red">  34.     return pieces</font>
<font color="black">  35. </font>
<font color="black">  36. </font>
<font color="green">  37. class BaseLoader(object):</font>
<font color="black">  38.     &quot;&quot;&quot;Baseclass for all loaders.  Subclass this and override `get_source` to</font>
<font color="black">  39.     implement a custom loading mechanism.  The environment provides a</font>
<font color="black">  40.     `get_template` method that calls the loader's `load` method to get the</font>
<font color="black">  41.     :class:`Template` object.</font>
<font color="black">  42. </font>
<font color="black">  43.     A very basic example for a loader that looks up templates on the file</font>
<font color="black">  44.     system could look like this::</font>
<font color="black">  45. </font>
<font color="black">  46.         from jinja2 import BaseLoader, TemplateNotFound</font>
<font color="black">  47.         from os.path import join, exists, getmtime</font>
<font color="black">  48. </font>
<font color="black">  49.         class MyLoader(BaseLoader):</font>
<font color="black">  50. </font>
<font color="black">  51.             def __init__(self, path):</font>
<font color="black">  52.                 self.path = path</font>
<font color="black">  53. </font>
<font color="black">  54.             def get_source(self, environment, template):</font>
<font color="black">  55.                 path = join(self.path, template)</font>
<font color="black">  56.                 if not exists(path):</font>
<font color="black">  57.                     raise TemplateNotFound(template)</font>
<font color="black">  58.                 mtime = getmtime(path)</font>
<font color="black">  59.                 with file(path) as f:</font>
<font color="black">  60.                     source = f.read().decode('utf-8')</font>
<font color="black">  61.                 return source, path, lambda: mtime == getmtime(path)</font>
<font color="green">  62.     &quot;&quot;&quot;</font>
<font color="black">  63. </font>
<font color="black">  64.     #: if set to `False` it indicates that the loader cannot provide access</font>
<font color="black">  65.     #: to the source of templates.</font>
<font color="black">  66.     #:</font>
<font color="black">  67.     #: .. versionadded:: 2.4</font>
<font color="green">  68.     has_source_access = True</font>
<font color="black">  69. </font>
<font color="green">  70.     def get_source(self, environment, template):</font>
<font color="black">  71.         &quot;&quot;&quot;Get the template source, filename and reload helper for a template.</font>
<font color="black">  72.         It's passed the environment and template name and has to return a</font>
<font color="black">  73.         tuple in the form ``(source, filename, uptodate)`` or raise a</font>
<font color="black">  74.         `TemplateNotFound` error if it can't locate the template.</font>
<font color="black">  75. </font>
<font color="black">  76.         The source part of the returned tuple must be the source of the</font>
<font color="black">  77.         template as unicode string or a ASCII bytestring.  The filename should</font>
<font color="black">  78.         be the name of the file on the filesystem if it was loaded from there,</font>
<font color="black">  79.         otherwise `None`.  The filename is used by python for the tracebacks</font>
<font color="black">  80.         if no loader extension is used.</font>
<font color="black">  81. </font>
<font color="black">  82.         The last item in the tuple is the `uptodate` function.  If auto</font>
<font color="black">  83.         reloading is enabled it's always called to check if the template</font>
<font color="black">  84.         changed.  No arguments are passed so the function must store the</font>
<font color="black">  85.         old state somewhere (for example in a closure).  If it returns `False`</font>
<font color="black">  86.         the template will be reloaded.</font>
<font color="black">  87.         &quot;&quot;&quot;</font>
<font color="red">  88.         if not self.has_source_access:</font>
<font color="red">  89.             raise RuntimeError('%s cannot provide access to the source' %</font>
<font color="red">  90.                                self.__class__.__name__)</font>
<font color="red">  91.         raise TemplateNotFound(template)</font>
<font color="black">  92. </font>
<font color="green">  93.     def list_templates(self):</font>
<font color="black">  94.         &quot;&quot;&quot;Iterates over all templates.  If the loader does not support that</font>
<font color="black">  95.         it should raise a :exc:`TypeError` which is the default behavior.</font>
<font color="black">  96.         &quot;&quot;&quot;</font>
<font color="red">  97.         raise TypeError('this loader cannot iterate over all templates')</font>
<font color="black">  98. </font>
<font color="green">  99.     @internalcode</font>
<font color="green"> 100.     def load(self, environment, name, globals=None):</font>
<font color="black"> 101.         &quot;&quot;&quot;Loads a template.  This method looks up the template in the cache</font>
<font color="black"> 102.         or loads one by calling :meth:`get_source`.  Subclasses should not</font>
<font color="black"> 103.         override this method as loaders working on collections of other</font>
<font color="black"> 104.         loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)</font>
<font color="black"> 105.         will not call this method but `get_source` directly.</font>
<font color="black"> 106.         &quot;&quot;&quot;</font>
<font color="red"> 107.         code = None</font>
<font color="red"> 108.         if globals is None:</font>
<font color="red"> 109.             globals = {}</font>
<font color="black"> 110. </font>
<font color="black"> 111.         # first we try to get the source for this template together</font>
<font color="black"> 112.         # with the filename and the uptodate function.</font>
<font color="red"> 113.         source, filename, uptodate = self.get_source(environment, name)</font>
<font color="black"> 114. </font>
<font color="black"> 115.         # try to load the code from the bytecode cache if there is a</font>
<font color="black"> 116.         # bytecode cache configured.</font>
<font color="red"> 117.         bcc = environment.bytecode_cache</font>
<font color="red"> 118.         if bcc is not None:</font>
<font color="red"> 119.             bucket = bcc.get_bucket(environment, name, filename, source)</font>
<font color="red"> 120.             code = bucket.code</font>
<font color="black"> 121. </font>
<font color="black"> 122.         # if we don't have code so far (not cached, no longer up to</font>
<font color="black"> 123.         # date) etc. we compile the template</font>
<font color="red"> 124.         if code is None:</font>
<font color="red"> 125.             code = environment.compile(source, name, filename)</font>
<font color="black"> 126. </font>
<font color="black"> 127.         # if the bytecode cache is available and the bucket doesn't</font>
<font color="black"> 128.         # have a code so far, we give the bucket the new code and put</font>
<font color="black"> 129.         # it back to the bytecode cache.</font>
<font color="red"> 130.         if bcc is not None and bucket.code is None:</font>
<font color="red"> 131.             bucket.code = code</font>
<font color="red"> 132.             bcc.set_bucket(bucket)</font>
<font color="black"> 133. </font>
<font color="red"> 134.         return environment.template_class.from_code(environment, code,</font>
<font color="red"> 135.                                                     globals, uptodate)</font>
<font color="black"> 136. </font>
<font color="black"> 137. </font>
<font color="green"> 138. class FileSystemLoader(BaseLoader):</font>
<font color="black"> 139.     &quot;&quot;&quot;Loads templates from the file system.  This loader can find templates</font>
<font color="black"> 140.     in folders on the file system and is the preferred way to load them.</font>
<font color="black"> 141. </font>
<font color="black"> 142.     The loader takes the path to the templates as string, or if multiple</font>
<font color="black"> 143.     locations are wanted a list of them which is then looked up in the</font>
<font color="black"> 144.     given order::</font>
<font color="black"> 145. </font>
<font color="black"> 146.     &gt;&gt;&gt; loader = FileSystemLoader('/path/to/templates')</font>
<font color="black"> 147.     &gt;&gt;&gt; loader = FileSystemLoader(['/path/to/templates', '/other/path'])</font>
<font color="black"> 148. </font>
<font color="black"> 149.     Per default the template encoding is ``'utf-8'`` which can be changed</font>
<font color="black"> 150.     by setting the `encoding` parameter to something else.</font>
<font color="black"> 151. </font>
<font color="black"> 152.     To follow symbolic links, set the *followlinks* parameter to ``True``::</font>
<font color="black"> 153. </font>
<font color="black"> 154.     &gt;&gt;&gt; loader = FileSystemLoader('/path/to/templates', followlinks=True)</font>
<font color="black"> 155. </font>
<font color="black"> 156.     .. versionchanged:: 2.8+</font>
<font color="black"> 157.        The *followlinks* parameter was added.</font>
<font color="green"> 158.     &quot;&quot;&quot;</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def __init__(self, searchpath, encoding='utf-8', followlinks=False):</font>
<font color="red"> 161.         if isinstance(searchpath, string_types):</font>
<font color="red"> 162.             searchpath = [searchpath]</font>
<font color="red"> 163.         self.searchpath = list(searchpath)</font>
<font color="red"> 164.         self.encoding = encoding</font>
<font color="red"> 165.         self.followlinks = followlinks</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def get_source(self, environment, template):</font>
<font color="red"> 168.         pieces = split_template_path(template)</font>
<font color="red"> 169.         for searchpath in self.searchpath:</font>
<font color="red"> 170.             filename = path.join(searchpath, *pieces)</font>
<font color="red"> 171.             f = open_if_exists(filename)</font>
<font color="red"> 172.             if f is None:</font>
<font color="red"> 173.                 continue</font>
<font color="red"> 174.             try:</font>
<font color="red"> 175.                 contents = f.read().decode(self.encoding)</font>
<font color="black"> 176.             finally:</font>
<font color="red"> 177.                 f.close()</font>
<font color="black"> 178. </font>
<font color="red"> 179.             mtime = path.getmtime(filename)</font>
<font color="black"> 180. </font>
<font color="red"> 181.             def uptodate():</font>
<font color="red"> 182.                 try:</font>
<font color="red"> 183.                     return path.getmtime(filename) == mtime</font>
<font color="red"> 184.                 except OSError:</font>
<font color="red"> 185.                     return False</font>
<font color="red"> 186.             return contents, filename, uptodate</font>
<font color="red"> 187.         raise TemplateNotFound(template)</font>
<font color="black"> 188. </font>
<font color="green"> 189.     def list_templates(self):</font>
<font color="red"> 190.         found = set()</font>
<font color="red"> 191.         for searchpath in self.searchpath:</font>
<font color="red"> 192.             walk_dir = os.walk(searchpath, followlinks=self.followlinks)</font>
<font color="red"> 193.             for dirpath, dirnames, filenames in walk_dir:</font>
<font color="red"> 194.                 for filename in filenames:</font>
<font color="red"> 195.                     template = os.path.join(dirpath, filename) \</font>
<font color="red"> 196.                         [len(searchpath):].strip(os.path.sep) \</font>
<font color="red"> 197.                                           .replace(os.path.sep, '/')</font>
<font color="red"> 198.                     if template[:2] == './':</font>
<font color="red"> 199.                         template = template[2:]</font>
<font color="red"> 200.                     if template not in found:</font>
<font color="red"> 201.                         found.add(template)</font>
<font color="red"> 202.         return sorted(found)</font>
<font color="black"> 203. </font>
<font color="black"> 204. </font>
<font color="green"> 205. class PackageLoader(BaseLoader):</font>
<font color="black"> 206.     &quot;&quot;&quot;Load templates from python eggs or packages.  It is constructed with</font>
<font color="black"> 207.     the name of the python package and the path to the templates in that</font>
<font color="black"> 208.     package::</font>
<font color="black"> 209. </font>
<font color="black"> 210.         loader = PackageLoader('mypackage', 'views')</font>
<font color="black"> 211. </font>
<font color="black"> 212.     If the package path is not given, ``'templates'`` is assumed.</font>
<font color="black"> 213. </font>
<font color="black"> 214.     Per default the template encoding is ``'utf-8'`` which can be changed</font>
<font color="black"> 215.     by setting the `encoding` parameter to something else.  Due to the nature</font>
<font color="black"> 216.     of eggs it's only possible to reload templates if the package was loaded</font>
<font color="black"> 217.     from the file system and not a zip file.</font>
<font color="green"> 218.     &quot;&quot;&quot;</font>
<font color="black"> 219. </font>
<font color="green"> 220.     def __init__(self, package_name, package_path='templates',</font>
<font color="green"> 221.                  encoding='utf-8'):</font>
<font color="red"> 222.         from pkg_resources import DefaultProvider, ResourceManager, \</font>
<font color="black"> 223.                                   get_provider</font>
<font color="red"> 224.         provider = get_provider(package_name)</font>
<font color="red"> 225.         self.encoding = encoding</font>
<font color="red"> 226.         self.manager = ResourceManager()</font>
<font color="red"> 227.         self.filesystem_bound = isinstance(provider, DefaultProvider)</font>
<font color="red"> 228.         self.provider = provider</font>
<font color="red"> 229.         self.package_path = package_path</font>
<font color="black"> 230. </font>
<font color="green"> 231.     def get_source(self, environment, template):</font>
<font color="red"> 232.         pieces = split_template_path(template)</font>
<font color="red"> 233.         p = '/'.join((self.package_path,) + tuple(pieces))</font>
<font color="red"> 234.         if not self.provider.has_resource(p):</font>
<font color="red"> 235.             raise TemplateNotFound(template)</font>
<font color="black"> 236. </font>
<font color="red"> 237.         filename = uptodate = None</font>
<font color="red"> 238.         if self.filesystem_bound:</font>
<font color="red"> 239.             filename = self.provider.get_resource_filename(self.manager, p)</font>
<font color="red"> 240.             mtime = path.getmtime(filename)</font>
<font color="red"> 241.             def uptodate():</font>
<font color="red"> 242.                 try:</font>
<font color="red"> 243.                     return path.getmtime(filename) == mtime</font>
<font color="red"> 244.                 except OSError:</font>
<font color="red"> 245.                     return False</font>
<font color="black"> 246. </font>
<font color="red"> 247.         source = self.provider.get_resource_string(self.manager, p)</font>
<font color="red"> 248.         return source.decode(self.encoding), filename, uptodate</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def list_templates(self):</font>
<font color="red"> 251.         path = self.package_path</font>
<font color="red"> 252.         if path[:2] == './':</font>
<font color="red"> 253.             path = path[2:]</font>
<font color="red"> 254.         elif path == '.':</font>
<font color="red"> 255.             path = ''</font>
<font color="red"> 256.         offset = len(path)</font>
<font color="red"> 257.         results = []</font>
<font color="red"> 258.         def _walk(path):</font>
<font color="red"> 259.             for filename in self.provider.resource_listdir(path):</font>
<font color="red"> 260.                 fullname = path + '/' + filename</font>
<font color="red"> 261.                 if self.provider.resource_isdir(fullname):</font>
<font color="red"> 262.                     _walk(fullname)</font>
<font color="black"> 263.                 else:</font>
<font color="red"> 264.                     results.append(fullname[offset:].lstrip('/'))</font>
<font color="red"> 265.         _walk(path)</font>
<font color="red"> 266.         results.sort()</font>
<font color="red"> 267.         return results</font>
<font color="black"> 268. </font>
<font color="black"> 269. </font>
<font color="green"> 270. class DictLoader(BaseLoader):</font>
<font color="black"> 271.     &quot;&quot;&quot;Loads a template from a python dict.  It's passed a dict of unicode</font>
<font color="black"> 272.     strings bound to template names.  This loader is useful for unittesting:</font>
<font color="black"> 273. </font>
<font color="black"> 274.     &gt;&gt;&gt; loader = DictLoader({'index.html': 'source here'})</font>
<font color="black"> 275. </font>
<font color="black"> 276.     Because auto reloading is rarely useful this is disabled per default.</font>
<font color="green"> 277.     &quot;&quot;&quot;</font>
<font color="black"> 278. </font>
<font color="green"> 279.     def __init__(self, mapping):</font>
<font color="red"> 280.         self.mapping = mapping</font>
<font color="black"> 281. </font>
<font color="green"> 282.     def get_source(self, environment, template):</font>
<font color="red"> 283.         if template in self.mapping:</font>
<font color="red"> 284.             source = self.mapping[template]</font>
<font color="red"> 285.             return source, None, lambda: source == self.mapping.get(template)</font>
<font color="red"> 286.         raise TemplateNotFound(template)</font>
<font color="black"> 287. </font>
<font color="green"> 288.     def list_templates(self):</font>
<font color="red"> 289.         return sorted(self.mapping)</font>
<font color="black"> 290. </font>
<font color="black"> 291. </font>
<font color="green"> 292. class FunctionLoader(BaseLoader):</font>
<font color="black"> 293.     &quot;&quot;&quot;A loader that is passed a function which does the loading.  The</font>
<font color="black"> 294.     function receives the name of the template and has to return either</font>
<font color="black"> 295.     an unicode string with the template source, a tuple in the form ``(source,</font>
<font color="black"> 296.     filename, uptodatefunc)`` or `None` if the template does not exist.</font>
<font color="black"> 297. </font>
<font color="black"> 298.     &gt;&gt;&gt; def load_template(name):</font>
<font color="black"> 299.     ...     if name == 'index.html':</font>
<font color="black"> 300.     ...         return '...'</font>
<font color="black"> 301.     ...</font>
<font color="black"> 302.     &gt;&gt;&gt; loader = FunctionLoader(load_template)</font>
<font color="black"> 303. </font>
<font color="black"> 304.     The `uptodatefunc` is a function that is called if autoreload is enabled</font>
<font color="black"> 305.     and has to return `True` if the template is still up to date.  For more</font>
<font color="black"> 306.     details have a look at :meth:`BaseLoader.get_source` which has the same</font>
<font color="black"> 307.     return value.</font>
<font color="green"> 308.     &quot;&quot;&quot;</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def __init__(self, load_func):</font>
<font color="red"> 311.         self.load_func = load_func</font>
<font color="black"> 312. </font>
<font color="green"> 313.     def get_source(self, environment, template):</font>
<font color="red"> 314.         rv = self.load_func(template)</font>
<font color="red"> 315.         if rv is None:</font>
<font color="red"> 316.             raise TemplateNotFound(template)</font>
<font color="red"> 317.         elif isinstance(rv, string_types):</font>
<font color="red"> 318.             return rv, None, None</font>
<font color="red"> 319.         return rv</font>
<font color="black"> 320. </font>
<font color="black"> 321. </font>
<font color="green"> 322. class PrefixLoader(BaseLoader):</font>
<font color="black"> 323.     &quot;&quot;&quot;A loader that is passed a dict of loaders where each loader is bound</font>
<font color="black"> 324.     to a prefix.  The prefix is delimited from the template by a slash per</font>
<font color="black"> 325.     default, which can be changed by setting the `delimiter` argument to</font>
<font color="black"> 326.     something else::</font>
<font color="black"> 327. </font>
<font color="black"> 328.         loader = PrefixLoader({</font>
<font color="black"> 329.             'app1':     PackageLoader('mypackage.app1'),</font>
<font color="black"> 330.             'app2':     PackageLoader('mypackage.app2')</font>
<font color="black"> 331.         })</font>
<font color="black"> 332. </font>
<font color="black"> 333.     By loading ``'app1/index.html'`` the file from the app1 package is loaded,</font>
<font color="black"> 334.     by loading ``'app2/index.html'`` the file from the second.</font>
<font color="green"> 335.     &quot;&quot;&quot;</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def __init__(self, mapping, delimiter='/'):</font>
<font color="red"> 338.         self.mapping = mapping</font>
<font color="red"> 339.         self.delimiter = delimiter</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def get_loader(self, template):</font>
<font color="red"> 342.         try:</font>
<font color="red"> 343.             prefix, name = template.split(self.delimiter, 1)</font>
<font color="red"> 344.             loader = self.mapping[prefix]</font>
<font color="red"> 345.         except (ValueError, KeyError):</font>
<font color="red"> 346.             raise TemplateNotFound(template)</font>
<font color="red"> 347.         return loader, name</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def get_source(self, environment, template):</font>
<font color="red"> 350.         loader, name = self.get_loader(template)</font>
<font color="red"> 351.         try:</font>
<font color="red"> 352.             return loader.get_source(environment, name)</font>
<font color="red"> 353.         except TemplateNotFound:</font>
<font color="black"> 354.             # re-raise the exception with the correct fileame here.</font>
<font color="black"> 355.             # (the one that includes the prefix)</font>
<font color="red"> 356.             raise TemplateNotFound(template)</font>
<font color="black"> 357. </font>
<font color="green"> 358.     @internalcode</font>
<font color="green"> 359.     def load(self, environment, name, globals=None):</font>
<font color="red"> 360.         loader, local_name = self.get_loader(name)</font>
<font color="red"> 361.         try:</font>
<font color="red"> 362.             return loader.load(environment, local_name, globals)</font>
<font color="red"> 363.         except TemplateNotFound:</font>
<font color="black"> 364.             # re-raise the exception with the correct fileame here.</font>
<font color="black"> 365.             # (the one that includes the prefix)</font>
<font color="red"> 366.             raise TemplateNotFound(name)</font>
<font color="black"> 367. </font>
<font color="green"> 368.     def list_templates(self):</font>
<font color="red"> 369.         result = []</font>
<font color="red"> 370.         for prefix, loader in iteritems(self.mapping):</font>
<font color="red"> 371.             for template in loader.list_templates():</font>
<font color="red"> 372.                 result.append(prefix + self.delimiter + template)</font>
<font color="red"> 373.         return result</font>
<font color="black"> 374. </font>
<font color="black"> 375. </font>
<font color="green"> 376. class ChoiceLoader(BaseLoader):</font>
<font color="black"> 377.     &quot;&quot;&quot;This loader works like the `PrefixLoader` just that no prefix is</font>
<font color="black"> 378.     specified.  If a template could not be found by one loader the next one</font>
<font color="black"> 379.     is tried.</font>
<font color="black"> 380. </font>
<font color="black"> 381.     &gt;&gt;&gt; loader = ChoiceLoader([</font>
<font color="black"> 382.     ...     FileSystemLoader('/path/to/user/templates'),</font>
<font color="black"> 383.     ...     FileSystemLoader('/path/to/system/templates')</font>
<font color="black"> 384.     ... ])</font>
<font color="black"> 385. </font>
<font color="black"> 386.     This is useful if you want to allow users to override builtin templates</font>
<font color="black"> 387.     from a different location.</font>
<font color="green"> 388.     &quot;&quot;&quot;</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def __init__(self, loaders):</font>
<font color="red"> 391.         self.loaders = loaders</font>
<font color="black"> 392. </font>
<font color="green"> 393.     def get_source(self, environment, template):</font>
<font color="red"> 394.         for loader in self.loaders:</font>
<font color="red"> 395.             try:</font>
<font color="red"> 396.                 return loader.get_source(environment, template)</font>
<font color="red"> 397.             except TemplateNotFound:</font>
<font color="red"> 398.                 pass</font>
<font color="red"> 399.         raise TemplateNotFound(template)</font>
<font color="black"> 400. </font>
<font color="green"> 401.     @internalcode</font>
<font color="green"> 402.     def load(self, environment, name, globals=None):</font>
<font color="red"> 403.         for loader in self.loaders:</font>
<font color="red"> 404.             try:</font>
<font color="red"> 405.                 return loader.load(environment, name, globals)</font>
<font color="red"> 406.             except TemplateNotFound:</font>
<font color="red"> 407.                 pass</font>
<font color="red"> 408.         raise TemplateNotFound(name)</font>
<font color="black"> 409. </font>
<font color="green"> 410.     def list_templates(self):</font>
<font color="red"> 411.         found = set()</font>
<font color="red"> 412.         for loader in self.loaders:</font>
<font color="red"> 413.             found.update(loader.list_templates())</font>
<font color="red"> 414.         return sorted(found)</font>
<font color="black"> 415. </font>
<font color="black"> 416. </font>
<font color="green"> 417. class _TemplateModule(ModuleType):</font>
<font color="green"> 418.     &quot;&quot;&quot;Like a normal module but with support for weak references&quot;&quot;&quot;</font>
<font color="black"> 419. </font>
<font color="black"> 420. </font>
<font color="green"> 421. class ModuleLoader(BaseLoader):</font>
<font color="black"> 422.     &quot;&quot;&quot;This loader loads templates from precompiled templates.</font>
<font color="black"> 423. </font>
<font color="black"> 424.     Example usage:</font>
<font color="black"> 425. </font>
<font color="black"> 426.     &gt;&gt;&gt; loader = ChoiceLoader([</font>
<font color="black"> 427.     ...     ModuleLoader('/path/to/compiled/templates'),</font>
<font color="black"> 428.     ...     FileSystemLoader('/path/to/templates')</font>
<font color="black"> 429.     ... ])</font>
<font color="black"> 430. </font>
<font color="black"> 431.     Templates can be precompiled with :meth:`Environment.compile_templates`.</font>
<font color="green"> 432.     &quot;&quot;&quot;</font>
<font color="black"> 433. </font>
<font color="green"> 434.     has_source_access = False</font>
<font color="black"> 435. </font>
<font color="green"> 436.     def __init__(self, path):</font>
<font color="red"> 437.         package_name = '_jinja2_module_templates_%x' % id(self)</font>
<font color="black"> 438. </font>
<font color="black"> 439.         # create a fake module that looks for the templates in the</font>
<font color="black"> 440.         # path given.</font>
<font color="red"> 441.         mod = _TemplateModule(package_name)</font>
<font color="red"> 442.         if isinstance(path, string_types):</font>
<font color="red"> 443.             path = [path]</font>
<font color="black"> 444.         else:</font>
<font color="red"> 445.             path = list(path)</font>
<font color="red"> 446.         mod.__path__ = path</font>
<font color="black"> 447. </font>
<font color="red"> 448.         sys.modules[package_name] = weakref.proxy(mod,</font>
<font color="red"> 449.             lambda x: sys.modules.pop(package_name, None))</font>
<font color="black"> 450. </font>
<font color="black"> 451.         # the only strong reference, the sys.modules entry is weak</font>
<font color="black"> 452.         # so that the garbage collector can remove it once the</font>
<font color="black"> 453.         # loader that created it goes out of business.</font>
<font color="red"> 454.         self.module = mod</font>
<font color="red"> 455.         self.package_name = package_name</font>
<font color="black"> 456. </font>
<font color="green"> 457.     @staticmethod</font>
<font color="black"> 458.     def get_template_key(name):</font>
<font color="red"> 459.         return 'tmpl_' + sha1(name.encode('utf-8')).hexdigest()</font>
<font color="black"> 460. </font>
<font color="green"> 461.     @staticmethod</font>
<font color="black"> 462.     def get_module_filename(name):</font>
<font color="red"> 463.         return ModuleLoader.get_template_key(name) + '.py'</font>
<font color="black"> 464. </font>
<font color="green"> 465.     @internalcode</font>
<font color="green"> 466.     def load(self, environment, name, globals=None):</font>
<font color="red"> 467.         key = self.get_template_key(name)</font>
<font color="red"> 468.         module = '%s.%s' % (self.package_name, key)</font>
<font color="red"> 469.         mod = getattr(self.module, module, None)</font>
<font color="red"> 470.         if mod is None:</font>
<font color="red"> 471.             try:</font>
<font color="red"> 472.                 mod = __import__(module, None, None, ['root'])</font>
<font color="red"> 473.             except ImportError:</font>
<font color="red"> 474.                 raise TemplateNotFound(name)</font>
<font color="black"> 475. </font>
<font color="black"> 476.             # remove the entry from sys.modules, we only want the attribute</font>
<font color="black"> 477.             # on the module object we have stored on the loader.</font>
<font color="red"> 478.             sys.modules.pop(module, None)</font>
<font color="black"> 479. </font>
<font color="red"> 480.         return environment.template_class.from_module_dict(</font>
<font color="red"> 481.             environment, mod.__dict__, globals)</font>
</pre>

