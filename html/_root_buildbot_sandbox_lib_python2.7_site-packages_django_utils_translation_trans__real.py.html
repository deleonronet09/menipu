source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/translation/trans_real.py</b><br>


file stats: <b>444 lines, 157 executed: 35.4% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Translation helper functions.&quot;&quot;&quot;</font>
<font color="green">   2. from __future__ import unicode_literals</font>
<font color="black">   3. </font>
<font color="green">   4. import gettext as gettext_module</font>
<font color="green">   5. import os</font>
<font color="green">   6. import re</font>
<font color="green">   7. import sys</font>
<font color="green">   8. import warnings</font>
<font color="green">   9. from collections import OrderedDict</font>
<font color="green">  10. from threading import local</font>
<font color="black">  11. </font>
<font color="green">  12. from django.apps import apps</font>
<font color="green">  13. from django.conf import settings</font>
<font color="green">  14. from django.conf.locale import LANG_INFO</font>
<font color="green">  15. from django.core.exceptions import AppRegistryNotReady</font>
<font color="green">  16. from django.core.signals import setting_changed</font>
<font color="green">  17. from django.dispatch import receiver</font>
<font color="green">  18. from django.utils import lru_cache, six</font>
<font color="green">  19. from django.utils._os import upath</font>
<font color="green">  20. from django.utils.encoding import force_text</font>
<font color="green">  21. from django.utils.safestring import SafeData, mark_safe</font>
<font color="green">  22. from django.utils.six import StringIO</font>
<font color="green">  23. from django.utils.translation import (</font>
<font color="black">  24.     LANGUAGE_SESSION_KEY, TranslatorCommentWarning, trim_whitespace,</font>
<font color="black">  25. )</font>
<font color="black">  26. </font>
<font color="black">  27. # Translations are cached in a dictionary for every language.</font>
<font color="black">  28. # The active translations are stored by threadid to make them thread local.</font>
<font color="green">  29. _translations = {}</font>
<font color="green">  30. _active = local()</font>
<font color="black">  31. </font>
<font color="black">  32. # The default translation is based on the settings file.</font>
<font color="green">  33. _default = None</font>
<font color="black">  34. </font>
<font color="black">  35. # magic gettext number to separate context from message</font>
<font color="green">  36. CONTEXT_SEPARATOR = &quot;\x04&quot;</font>
<font color="black">  37. </font>
<font color="black">  38. # Format of Accept-Language header values. From RFC 2616, section 14.4 and 3.9</font>
<font color="black">  39. # and RFC 3066, section 2.1</font>
<font color="green">  40. accept_language_re = re.compile(r'''</font>
<font color="black">  41.         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # &quot;en&quot;, &quot;en-au&quot;, &quot;x-y-z&quot;, &quot;es-419&quot;, &quot;*&quot;</font>
<font color="black">  42.         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:.0{,3})?))?   # Optional &quot;q=1.00&quot;, &quot;q=0.8&quot;</font>
<font color="black">  43.         (?:\s*,\s*|$)                                 # Multiple accepts per header.</font>
<font color="green">  44.         ''', re.VERBOSE)</font>
<font color="black">  45. </font>
<font color="green">  46. language_code_re = re.compile(</font>
<font color="green">  47.     r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$',</font>
<font color="green">  48.     re.IGNORECASE</font>
<font color="black">  49. )</font>
<font color="black">  50. </font>
<font color="green">  51. language_code_prefix_re = re.compile(r'^/([\w@-]+)(/|$)')</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. @receiver(setting_changed)</font>
<font color="black">  55. def reset_cache(**kwargs):</font>
<font color="black">  56.     &quot;&quot;&quot;</font>
<font color="black">  57.     Reset global state when LANGUAGES setting has been changed, as some</font>
<font color="black">  58.     languages should no longer be accepted.</font>
<font color="black">  59.     &quot;&quot;&quot;</font>
<font color="red">  60.     if kwargs['setting'] in ('LANGUAGES', 'LANGUAGE_CODE'):</font>
<font color="red">  61.         check_for_language.cache_clear()</font>
<font color="red">  62.         get_languages.cache_clear()</font>
<font color="red">  63.         get_supported_language_variant.cache_clear()</font>
<font color="black">  64. </font>
<font color="black">  65. </font>
<font color="green">  66. def to_locale(language, to_lower=False):</font>
<font color="black">  67.     &quot;&quot;&quot;</font>
<font color="black">  68.     Turns a language name (en-us) into a locale name (en_US). If 'to_lower' is</font>
<font color="black">  69.     True, the last component is lower-cased (en_us).</font>
<font color="black">  70.     &quot;&quot;&quot;</font>
<font color="green">  71.     p = language.find('-')</font>
<font color="green">  72.     if p &gt;= 0:</font>
<font color="green">  73.         if to_lower:</font>
<font color="red">  74.             return language[:p].lower() + '_' + language[p + 1:].lower()</font>
<font color="black">  75.         else:</font>
<font color="black">  76.             # Get correct locale for sr-latn</font>
<font color="green">  77.             if len(language[p + 1:]) &gt; 2:</font>
<font color="red">  78.                 return language[:p].lower() + '_' + language[p + 1].upper() + language[p + 2:].lower()</font>
<font color="green">  79.             return language[:p].lower() + '_' + language[p + 1:].upper()</font>
<font color="black">  80.     else:</font>
<font color="red">  81.         return language.lower()</font>
<font color="black">  82. </font>
<font color="black">  83. </font>
<font color="green">  84. def to_language(locale):</font>
<font color="black">  85.     &quot;&quot;&quot;Turns a locale name (en_US) into a language name (en-us).&quot;&quot;&quot;</font>
<font color="green">  86.     p = locale.find('_')</font>
<font color="green">  87.     if p &gt;= 0:</font>
<font color="red">  88.         return locale[:p].lower() + '-' + locale[p + 1:].lower()</font>
<font color="black">  89.     else:</font>
<font color="green">  90.         return locale.lower()</font>
<font color="black">  91. </font>
<font color="black">  92. </font>
<font color="green">  93. class DjangoTranslation(gettext_module.GNUTranslations):</font>
<font color="black">  94.     &quot;&quot;&quot;</font>
<font color="black">  95.     This class sets up the GNUTranslations context with regard to output</font>
<font color="black">  96.     charset.</font>
<font color="black">  97. </font>
<font color="black">  98.     This translation object will be constructed out of multiple GNUTranslations</font>
<font color="black">  99.     objects by merging their catalogs. It will construct an object for the</font>
<font color="black"> 100.     requested language and add a fallback to the default language, if it's</font>
<font color="black"> 101.     different from the requested language.</font>
<font color="green"> 102.     &quot;&quot;&quot;</font>
<font color="green"> 103.     def __init__(self, language):</font>
<font color="black"> 104.         &quot;&quot;&quot;Create a GNUTranslations() using many locale directories&quot;&quot;&quot;</font>
<font color="green"> 105.         gettext_module.GNUTranslations.__init__(self)</font>
<font color="green"> 106.         self.set_output_charset('utf-8')  # For Python 2 gettext() (#25720)</font>
<font color="black"> 107. </font>
<font color="green"> 108.         self.__language = language</font>
<font color="green"> 109.         self.__to_language = to_language(language)</font>
<font color="green"> 110.         self.__locale = to_locale(language)</font>
<font color="black"> 111. </font>
<font color="green"> 112.         self._init_translation_catalog()</font>
<font color="green"> 113.         self._add_installed_apps_translations()</font>
<font color="green"> 114.         self._add_local_translations()</font>
<font color="green"> 115.         self._add_fallback()</font>
<font color="black"> 116. </font>
<font color="green"> 117.     def __repr__(self):</font>
<font color="red"> 118.         return &quot;&lt;DjangoTranslation lang:%s&gt;&quot; % self.__language</font>
<font color="black"> 119. </font>
<font color="green"> 120.     def _new_gnu_trans(self, localedir, use_null_fallback=True):</font>
<font color="black"> 121.         &quot;&quot;&quot;</font>
<font color="black"> 122.         Returns a mergeable gettext.GNUTranslations instance.</font>
<font color="black"> 123. </font>
<font color="black"> 124.         A convenience wrapper. By default gettext uses 'fallback=False'.</font>
<font color="black"> 125.         Using param `use_null_fallback` to avoid confusion with any other</font>
<font color="black"> 126.         references to 'fallback'.</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="green"> 128.         translation = gettext_module.translation(</font>
<font color="green"> 129.             domain='django',</font>
<font color="green"> 130.             localedir=localedir,</font>
<font color="green"> 131.             languages=[self.__locale],</font>
<font color="green"> 132.             codeset='utf-8',</font>
<font color="green"> 133.             fallback=use_null_fallback)</font>
<font color="green"> 134.         if not hasattr(translation, '_catalog'):</font>
<font color="black"> 135.             # provides merge support for NullTranslations()</font>
<font color="green"> 136.             translation._catalog = {}</font>
<font color="green"> 137.             translation._info = {}</font>
<font color="green"> 138.             translation.plural = lambda n: int(n != 1)</font>
<font color="green"> 139.         return translation</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def _init_translation_catalog(self):</font>
<font color="black"> 142.         &quot;&quot;&quot;Creates a base catalog using global django translations.&quot;&quot;&quot;</font>
<font color="green"> 143.         settingsfile = upath(sys.modules[settings.__module__].__file__)</font>
<font color="green"> 144.         localedir = os.path.join(os.path.dirname(settingsfile), 'locale')</font>
<font color="green"> 145.         use_null_fallback = True</font>
<font color="green"> 146.         if self.__language == settings.LANGUAGE_CODE:</font>
<font color="black"> 147.             # default lang should be present and parseable, if not</font>
<font color="black"> 148.             # gettext will raise an IOError (refs #18192).</font>
<font color="green"> 149.             use_null_fallback = False</font>
<font color="green"> 150.         translation = self._new_gnu_trans(localedir, use_null_fallback)</font>
<font color="green"> 151.         self.plural = translation.plural</font>
<font color="green"> 152.         self._info = translation._info.copy()</font>
<font color="green"> 153.         self._catalog = translation._catalog.copy()</font>
<font color="black"> 154. </font>
<font color="green"> 155.     def _add_installed_apps_translations(self):</font>
<font color="black"> 156.         &quot;&quot;&quot;Merges translations from each installed app.&quot;&quot;&quot;</font>
<font color="green"> 157.         try:</font>
<font color="green"> 158.             app_configs = reversed(list(apps.get_app_configs()))</font>
<font color="red"> 159.         except AppRegistryNotReady:</font>
<font color="red"> 160.             raise AppRegistryNotReady(</font>
<font color="red"> 161.                 &quot;The translation infrastructure cannot be initialized before the &quot;</font>
<font color="black"> 162.                 &quot;apps registry is ready. Check that you don't make non-lazy &quot;</font>
<font color="black"> 163.                 &quot;gettext calls at import time.&quot;)</font>
<font color="green"> 164.         for app_config in app_configs:</font>
<font color="green"> 165.             localedir = os.path.join(app_config.path, 'locale')</font>
<font color="green"> 166.             translation = self._new_gnu_trans(localedir)</font>
<font color="green"> 167.             self.merge(translation)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def _add_local_translations(self):</font>
<font color="black"> 170.         &quot;&quot;&quot;Merges translations defined in LOCALE_PATHS.&quot;&quot;&quot;</font>
<font color="green"> 171.         for localedir in reversed(settings.LOCALE_PATHS):</font>
<font color="red"> 172.             translation = self._new_gnu_trans(localedir)</font>
<font color="red"> 173.             self.merge(translation)</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def _add_fallback(self):</font>
<font color="black"> 176.         &quot;&quot;&quot;Sets the GNUTranslations() fallback with the default language.&quot;&quot;&quot;</font>
<font color="black"> 177.         # Don't set a fallback for the default language or any English variant</font>
<font color="black"> 178.         # (as it's empty, so it'll ALWAYS fall back to the default language)</font>
<font color="green"> 179.         if self.__language == settings.LANGUAGE_CODE or self.__language.startswith('en'):</font>
<font color="green"> 180.             return</font>
<font color="red"> 181.         default_translation = translation(settings.LANGUAGE_CODE)</font>
<font color="red"> 182.         self.add_fallback(default_translation)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def merge(self, other):</font>
<font color="black"> 185.         &quot;&quot;&quot;Merge another translation into this catalog.&quot;&quot;&quot;</font>
<font color="green"> 186.         self._catalog.update(other._catalog)</font>
<font color="black"> 187. </font>
<font color="green"> 188.     def language(self):</font>
<font color="black"> 189.         &quot;&quot;&quot;Returns the translation language.&quot;&quot;&quot;</font>
<font color="red"> 190.         return self.__language</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def to_language(self):</font>
<font color="black"> 193.         &quot;&quot;&quot;Returns the translation language name.&quot;&quot;&quot;</font>
<font color="green"> 194.         return self.__to_language</font>
<font color="black"> 195. </font>
<font color="black"> 196. </font>
<font color="green"> 197. def translation(language):</font>
<font color="black"> 198.     &quot;&quot;&quot;</font>
<font color="black"> 199.     Returns a translation object.</font>
<font color="black"> 200.     &quot;&quot;&quot;</font>
<font color="black"> 201.     global _translations</font>
<font color="green"> 202.     if language not in _translations:</font>
<font color="green"> 203.         _translations[language] = DjangoTranslation(language)</font>
<font color="green"> 204.     return _translations[language]</font>
<font color="black"> 205. </font>
<font color="black"> 206. </font>
<font color="green"> 207. def activate(language):</font>
<font color="black"> 208.     &quot;&quot;&quot;</font>
<font color="black"> 209.     Fetches the translation object for a given language and installs it as the</font>
<font color="black"> 210.     current translation object for the current thread.</font>
<font color="black"> 211.     &quot;&quot;&quot;</font>
<font color="green"> 212.     if not language:</font>
<font color="red"> 213.         return</font>
<font color="green"> 214.     _active.value = translation(language)</font>
<font color="black"> 215. </font>
<font color="black"> 216. </font>
<font color="green"> 217. def deactivate():</font>
<font color="black"> 218.     &quot;&quot;&quot;</font>
<font color="black"> 219.     Deinstalls the currently active translation object so that further _ calls</font>
<font color="black"> 220.     will resolve against the default translation object, again.</font>
<font color="black"> 221.     &quot;&quot;&quot;</font>
<font color="green"> 222.     if hasattr(_active, &quot;value&quot;):</font>
<font color="green"> 223.         del _active.value</font>
<font color="black"> 224. </font>
<font color="black"> 225. </font>
<font color="green"> 226. def deactivate_all():</font>
<font color="black"> 227.     &quot;&quot;&quot;</font>
<font color="black"> 228.     Makes the active translation object a NullTranslations() instance. This is</font>
<font color="black"> 229.     useful when we want delayed translations to appear as the original string</font>
<font color="black"> 230.     for some reason.</font>
<font color="black"> 231.     &quot;&quot;&quot;</font>
<font color="green"> 232.     _active.value = gettext_module.NullTranslations()</font>
<font color="green"> 233.     _active.value.to_language = lambda *args: None</font>
<font color="black"> 234. </font>
<font color="black"> 235. </font>
<font color="green"> 236. def get_language():</font>
<font color="black"> 237.     &quot;&quot;&quot;Returns the currently selected language.&quot;&quot;&quot;</font>
<font color="green"> 238.     t = getattr(_active, &quot;value&quot;, None)</font>
<font color="green"> 239.     if t is not None:</font>
<font color="green"> 240.         try:</font>
<font color="green"> 241.             return t.to_language()</font>
<font color="red"> 242.         except AttributeError:</font>
<font color="red"> 243.             pass</font>
<font color="black"> 244.     # If we don't have a real translation object, assume it's the default language.</font>
<font color="green"> 245.     return settings.LANGUAGE_CODE</font>
<font color="black"> 246. </font>
<font color="black"> 247. </font>
<font color="green"> 248. def get_language_bidi():</font>
<font color="black"> 249.     &quot;&quot;&quot;</font>
<font color="black"> 250.     Returns selected language's BiDi layout.</font>
<font color="black"> 251. </font>
<font color="black"> 252.     * False = left-to-right layout</font>
<font color="black"> 253.     * True = right-to-left layout</font>
<font color="black"> 254.     &quot;&quot;&quot;</font>
<font color="red"> 255.     lang = get_language()</font>
<font color="red"> 256.     if lang is None:</font>
<font color="red"> 257.         return False</font>
<font color="black"> 258.     else:</font>
<font color="red"> 259.         base_lang = get_language().split('-')[0]</font>
<font color="red"> 260.         return base_lang in settings.LANGUAGES_BIDI</font>
<font color="black"> 261. </font>
<font color="black"> 262. </font>
<font color="green"> 263. def catalog():</font>
<font color="black"> 264.     &quot;&quot;&quot;</font>
<font color="black"> 265.     Returns the current active catalog for further processing.</font>
<font color="black"> 266.     This can be used if you need to modify the catalog or want to access the</font>
<font color="black"> 267.     whole message catalog instead of just translating one string.</font>
<font color="black"> 268.     &quot;&quot;&quot;</font>
<font color="black"> 269.     global _default</font>
<font color="black"> 270. </font>
<font color="red"> 271.     t = getattr(_active, &quot;value&quot;, None)</font>
<font color="red"> 272.     if t is not None:</font>
<font color="red"> 273.         return t</font>
<font color="red"> 274.     if _default is None:</font>
<font color="red"> 275.         _default = translation(settings.LANGUAGE_CODE)</font>
<font color="red"> 276.     return _default</font>
<font color="black"> 277. </font>
<font color="black"> 278. </font>
<font color="green"> 279. def do_translate(message, translation_function):</font>
<font color="black"> 280.     &quot;&quot;&quot;</font>
<font color="black"> 281.     Translates 'message' using the given 'translation_function' name -- which</font>
<font color="black"> 282.     will be either gettext or ugettext. It uses the current thread to find the</font>
<font color="black"> 283.     translation object to use. If no current translation is activated, the</font>
<font color="black"> 284.     message will be run through the default translation object.</font>
<font color="black"> 285.     &quot;&quot;&quot;</font>
<font color="black"> 286.     global _default</font>
<font color="black"> 287. </font>
<font color="black"> 288.     # str() is allowing a bytestring message to remain bytestring on Python 2</font>
<font color="green"> 289.     eol_message = message.replace(str('\r\n'), str('\n')).replace(str('\r'), str('\n'))</font>
<font color="black"> 290. </font>
<font color="green"> 291.     if len(eol_message) == 0:</font>
<font color="black"> 292.         # Returns an empty value of the corresponding type if an empty message</font>
<font color="black"> 293.         # is given, instead of metadata, which is the default gettext behavior.</font>
<font color="red"> 294.         result = type(message)(&quot;&quot;)</font>
<font color="black"> 295.     else:</font>
<font color="green"> 296.         _default = _default or translation(settings.LANGUAGE_CODE)</font>
<font color="green"> 297.         translation_object = getattr(_active, &quot;value&quot;, _default)</font>
<font color="black"> 298. </font>
<font color="green"> 299.         result = getattr(translation_object, translation_function)(eol_message)</font>
<font color="black"> 300. </font>
<font color="green"> 301.     if isinstance(message, SafeData):</font>
<font color="red"> 302.         return mark_safe(result)</font>
<font color="black"> 303. </font>
<font color="green"> 304.     return result</font>
<font color="black"> 305. </font>
<font color="black"> 306. </font>
<font color="green"> 307. def gettext(message):</font>
<font color="black"> 308.     &quot;&quot;&quot;</font>
<font color="black"> 309.     Returns a string of the translation of the message.</font>
<font color="black"> 310. </font>
<font color="black"> 311.     Returns a string on Python 3 and an UTF-8-encoded bytestring on Python 2.</font>
<font color="black"> 312.     &quot;&quot;&quot;</font>
<font color="red"> 313.     return do_translate(message, 'gettext')</font>
<font color="black"> 314. </font>
<font color="green"> 315. if six.PY3:</font>
<font color="red"> 316.     ugettext = gettext</font>
<font color="black"> 317. else:</font>
<font color="green"> 318.     def ugettext(message):</font>
<font color="green"> 319.         return do_translate(message, 'ugettext')</font>
<font color="black"> 320. </font>
<font color="black"> 321. </font>
<font color="green"> 322. def pgettext(context, message):</font>
<font color="red"> 323.     msg_with_ctxt = &quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, message)</font>
<font color="red"> 324.     result = ugettext(msg_with_ctxt)</font>
<font color="red"> 325.     if CONTEXT_SEPARATOR in result:</font>
<font color="black"> 326.         # Translation not found</font>
<font color="black"> 327.         # force unicode, because lazy version expects unicode</font>
<font color="red"> 328.         result = force_text(message)</font>
<font color="red"> 329.     return result</font>
<font color="black"> 330. </font>
<font color="black"> 331. </font>
<font color="green"> 332. def gettext_noop(message):</font>
<font color="black"> 333.     &quot;&quot;&quot;</font>
<font color="black"> 334.     Marks strings for translation but doesn't translate them now. This can be</font>
<font color="black"> 335.     used to store strings in global variables that should stay in the base</font>
<font color="black"> 336.     language (because they might be used externally) and will be translated</font>
<font color="black"> 337.     later.</font>
<font color="black"> 338.     &quot;&quot;&quot;</font>
<font color="red"> 339.     return message</font>
<font color="black"> 340. </font>
<font color="black"> 341. </font>
<font color="green"> 342. def do_ntranslate(singular, plural, number, translation_function):</font>
<font color="black"> 343.     global _default</font>
<font color="black"> 344. </font>
<font color="green"> 345.     t = getattr(_active, &quot;value&quot;, None)</font>
<font color="green"> 346.     if t is not None:</font>
<font color="red"> 347.         return getattr(t, translation_function)(singular, plural, number)</font>
<font color="green"> 348.     if _default is None:</font>
<font color="red"> 349.         _default = translation(settings.LANGUAGE_CODE)</font>
<font color="green"> 350.     return getattr(_default, translation_function)(singular, plural, number)</font>
<font color="black"> 351. </font>
<font color="black"> 352. </font>
<font color="green"> 353. def ngettext(singular, plural, number):</font>
<font color="black"> 354.     &quot;&quot;&quot;</font>
<font color="black"> 355.     Returns a string of the translation of either the singular or plural,</font>
<font color="black"> 356.     based on the number.</font>
<font color="black"> 357. </font>
<font color="black"> 358.     Returns a string on Python 3 and an UTF-8-encoded bytestring on Python 2.</font>
<font color="black"> 359.     &quot;&quot;&quot;</font>
<font color="red"> 360.     return do_ntranslate(singular, plural, number, 'ngettext')</font>
<font color="black"> 361. </font>
<font color="green"> 362. if six.PY3:</font>
<font color="red"> 363.     ungettext = ngettext</font>
<font color="black"> 364. else:</font>
<font color="green"> 365.     def ungettext(singular, plural, number):</font>
<font color="black"> 366.         &quot;&quot;&quot;</font>
<font color="black"> 367.         Returns a unicode strings of the translation of either the singular or</font>
<font color="black"> 368.         plural, based on the number.</font>
<font color="black"> 369.         &quot;&quot;&quot;</font>
<font color="green"> 370.         return do_ntranslate(singular, plural, number, 'ungettext')</font>
<font color="black"> 371. </font>
<font color="black"> 372. </font>
<font color="green"> 373. def npgettext(context, singular, plural, number):</font>
<font color="red"> 374.     msgs_with_ctxt = (&quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, singular),</font>
<font color="red"> 375.                       &quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, plural),</font>
<font color="red"> 376.                       number)</font>
<font color="red"> 377.     result = ungettext(*msgs_with_ctxt)</font>
<font color="red"> 378.     if CONTEXT_SEPARATOR in result:</font>
<font color="black"> 379.         # Translation not found</font>
<font color="red"> 380.         result = ungettext(singular, plural, number)</font>
<font color="red"> 381.     return result</font>
<font color="black"> 382. </font>
<font color="black"> 383. </font>
<font color="green"> 384. def all_locale_paths():</font>
<font color="black"> 385.     &quot;&quot;&quot;</font>
<font color="black"> 386.     Returns a list of paths to user-provides languages files.</font>
<font color="black"> 387.     &quot;&quot;&quot;</font>
<font color="red"> 388.     globalpath = os.path.join(</font>
<font color="red"> 389.         os.path.dirname(upath(sys.modules[settings.__module__].__file__)), 'locale')</font>
<font color="red"> 390.     return [globalpath] + list(settings.LOCALE_PATHS)</font>
<font color="black"> 391. </font>
<font color="black"> 392. </font>
<font color="green"> 393. @lru_cache.lru_cache(maxsize=1000)</font>
<font color="black"> 394. def check_for_language(lang_code):</font>
<font color="black"> 395.     &quot;&quot;&quot;</font>
<font color="black"> 396.     Checks whether there is a global language file for the given language</font>
<font color="black"> 397.     code. This is used to decide whether a user-provided language is</font>
<font color="black"> 398.     available.</font>
<font color="black"> 399. </font>
<font color="black"> 400.     lru_cache should have a maxsize to prevent from memory exhaustion attacks,</font>
<font color="black"> 401.     as the provided language codes are taken from the HTTP request. See also</font>
<font color="black"> 402.     &lt;https://www.djangoproject.com/weblog/2007/oct/26/security-fix/&gt;.</font>
<font color="black"> 403.     &quot;&quot;&quot;</font>
<font color="black"> 404.     # First, a quick check to make sure lang_code is well-formed (#21458)</font>
<font color="red"> 405.     if lang_code is None or not language_code_re.search(lang_code):</font>
<font color="red"> 406.         return False</font>
<font color="red"> 407.     for path in all_locale_paths():</font>
<font color="red"> 408.         if gettext_module.find('django', path, [to_locale(lang_code)]) is not None:</font>
<font color="red"> 409.             return True</font>
<font color="red"> 410.     return False</font>
<font color="black"> 411. </font>
<font color="black"> 412. </font>
<font color="green"> 413. @lru_cache.lru_cache()</font>
<font color="black"> 414. def get_languages():</font>
<font color="black"> 415.     &quot;&quot;&quot;</font>
<font color="black"> 416.     Cache of settings.LANGUAGES in an OrderedDict for easy lookups by key.</font>
<font color="black"> 417.     &quot;&quot;&quot;</font>
<font color="red"> 418.     return OrderedDict(settings.LANGUAGES)</font>
<font color="black"> 419. </font>
<font color="black"> 420. </font>
<font color="green"> 421. @lru_cache.lru_cache(maxsize=1000)</font>
<font color="green"> 422. def get_supported_language_variant(lang_code, strict=False):</font>
<font color="black"> 423.     &quot;&quot;&quot;</font>
<font color="black"> 424.     Returns the language-code that's listed in supported languages, possibly</font>
<font color="black"> 425.     selecting a more generic variant. Raises LookupError if nothing found.</font>
<font color="black"> 426. </font>
<font color="black"> 427.     If `strict` is False (the default), the function will look for an alternative</font>
<font color="black"> 428.     country-specific variant when the currently checked is not found.</font>
<font color="black"> 429. </font>
<font color="black"> 430.     lru_cache should have a maxsize to prevent from memory exhaustion attacks,</font>
<font color="black"> 431.     as the provided language codes are taken from the HTTP request. See also</font>
<font color="black"> 432.     &lt;https://www.djangoproject.com/weblog/2007/oct/26/security-fix/&gt;.</font>
<font color="black"> 433.     &quot;&quot;&quot;</font>
<font color="red"> 434.     if lang_code:</font>
<font color="black"> 435.         # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.</font>
<font color="red"> 436.         possible_lang_codes = [lang_code]</font>
<font color="red"> 437.         try:</font>
<font color="red"> 438.             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])</font>
<font color="red"> 439.         except KeyError:</font>
<font color="red"> 440.             pass</font>
<font color="red"> 441.         generic_lang_code = lang_code.split('-')[0]</font>
<font color="red"> 442.         possible_lang_codes.append(generic_lang_code)</font>
<font color="red"> 443.         supported_lang_codes = get_languages()</font>
<font color="black"> 444. </font>
<font color="red"> 445.         for code in possible_lang_codes:</font>
<font color="red"> 446.             if code in supported_lang_codes and check_for_language(code):</font>
<font color="red"> 447.                 return code</font>
<font color="red"> 448.         if not strict:</font>
<font color="black"> 449.             # if fr-fr is not supported, try fr-ca.</font>
<font color="red"> 450.             for supported_code in supported_lang_codes:</font>
<font color="red"> 451.                 if supported_code.startswith(generic_lang_code + '-'):</font>
<font color="red"> 452.                     return supported_code</font>
<font color="red"> 453.     raise LookupError(lang_code)</font>
<font color="black"> 454. </font>
<font color="black"> 455. </font>
<font color="green"> 456. def get_language_from_path(path, strict=False):</font>
<font color="black"> 457.     &quot;&quot;&quot;</font>
<font color="black"> 458.     Returns the language-code if there is a valid language-code</font>
<font color="black"> 459.     found in the `path`.</font>
<font color="black"> 460. </font>
<font color="black"> 461.     If `strict` is False (the default), the function will look for an alternative</font>
<font color="black"> 462.     country-specific variant when the currently checked is not found.</font>
<font color="black"> 463.     &quot;&quot;&quot;</font>
<font color="red"> 464.     regex_match = language_code_prefix_re.match(path)</font>
<font color="red"> 465.     if not regex_match:</font>
<font color="red"> 466.         return None</font>
<font color="red"> 467.     lang_code = regex_match.group(1)</font>
<font color="red"> 468.     try:</font>
<font color="red"> 469.         return get_supported_language_variant(lang_code, strict=strict)</font>
<font color="red"> 470.     except LookupError:</font>
<font color="red"> 471.         return None</font>
<font color="black"> 472. </font>
<font color="black"> 473. </font>
<font color="green"> 474. def get_language_from_request(request, check_path=False):</font>
<font color="black"> 475.     &quot;&quot;&quot;</font>
<font color="black"> 476.     Analyzes the request to find what language the user wants the system to</font>
<font color="black"> 477.     show. Only languages listed in settings.LANGUAGES are taken into account.</font>
<font color="black"> 478.     If the user requests a sublanguage where we have a main language, we send</font>
<font color="black"> 479.     out the main language.</font>
<font color="black"> 480. </font>
<font color="black"> 481.     If check_path is True, the URL path prefix will be checked for a language</font>
<font color="black"> 482.     code, otherwise this is skipped for backwards compatibility.</font>
<font color="black"> 483.     &quot;&quot;&quot;</font>
<font color="red"> 484.     if check_path:</font>
<font color="red"> 485.         lang_code = get_language_from_path(request.path_info)</font>
<font color="red"> 486.         if lang_code is not None:</font>
<font color="red"> 487.             return lang_code</font>
<font color="black"> 488. </font>
<font color="red"> 489.     supported_lang_codes = get_languages()</font>
<font color="black"> 490. </font>
<font color="red"> 491.     if hasattr(request, 'session'):</font>
<font color="red"> 492.         lang_code = request.session.get(LANGUAGE_SESSION_KEY)</font>
<font color="red"> 493.         if lang_code in supported_lang_codes and lang_code is not None and check_for_language(lang_code):</font>
<font color="red"> 494.             return lang_code</font>
<font color="black"> 495. </font>
<font color="red"> 496.     lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME)</font>
<font color="black"> 497. </font>
<font color="red"> 498.     try:</font>
<font color="red"> 499.         return get_supported_language_variant(lang_code)</font>
<font color="red"> 500.     except LookupError:</font>
<font color="red"> 501.         pass</font>
<font color="black"> 502. </font>
<font color="red"> 503.     accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '')</font>
<font color="red"> 504.     for accept_lang, unused in parse_accept_lang_header(accept):</font>
<font color="red"> 505.         if accept_lang == '*':</font>
<font color="red"> 506.             break</font>
<font color="black"> 507. </font>
<font color="red"> 508.         if not language_code_re.search(accept_lang):</font>
<font color="red"> 509.             continue</font>
<font color="black"> 510. </font>
<font color="red"> 511.         try:</font>
<font color="red"> 512.             return get_supported_language_variant(accept_lang)</font>
<font color="red"> 513.         except LookupError:</font>
<font color="red"> 514.             continue</font>
<font color="black"> 515. </font>
<font color="red"> 516.     try:</font>
<font color="red"> 517.         return get_supported_language_variant(settings.LANGUAGE_CODE)</font>
<font color="red"> 518.     except LookupError:</font>
<font color="red"> 519.         return settings.LANGUAGE_CODE</font>
<font color="black"> 520. </font>
<font color="green"> 521. dot_re = re.compile(r'\S')</font>
<font color="black"> 522. </font>
<font color="black"> 523. </font>
<font color="green"> 524. def blankout(src, char):</font>
<font color="black"> 525.     &quot;&quot;&quot;</font>
<font color="black"> 526.     Changes every non-whitespace character to the given char.</font>
<font color="black"> 527.     Used in the templatize function.</font>
<font color="black"> 528.     &quot;&quot;&quot;</font>
<font color="red"> 529.     return dot_re.sub(char, src)</font>
<font color="black"> 530. </font>
<font color="black"> 531. </font>
<font color="green"> 532. context_re = re.compile(r&quot;&quot;&quot;^\s+.*context\s+((?:&quot;[^&quot;]*?&quot;)|(?:'[^']*?'))\s*&quot;&quot;&quot;)</font>
<font color="green"> 533. inline_re = re.compile(</font>
<font color="black"> 534.     # Match the trans 'some text' part</font>
<font color="green"> 535.     r&quot;&quot;&quot;^\s*trans\s+((?:&quot;[^&quot;]*?&quot;)|(?:'[^']*?'))&quot;&quot;&quot;</font>
<font color="black"> 536.     # Match and ignore optional filters</font>
<font color="black"> 537.     r&quot;&quot;&quot;(?:\s*\|\s*[^\s:]+(?::(?:[^\s'&quot;:]+|(?:&quot;[^&quot;]*?&quot;)|(?:'[^']*?')))?)*&quot;&quot;&quot;</font>
<font color="black"> 538.     # Match the optional context part</font>
<font color="black"> 539.     r&quot;&quot;&quot;(\s+.*context\s+((?:&quot;[^&quot;]*?&quot;)|(?:'[^']*?')))?\s*&quot;&quot;&quot;</font>
<font color="black"> 540. )</font>
<font color="green"> 541. block_re = re.compile(r&quot;&quot;&quot;^\s*blocktrans(\s+.*context\s+((?:&quot;[^&quot;]*?&quot;)|(?:'[^']*?')))?(?:\s+|$)&quot;&quot;&quot;)</font>
<font color="green"> 542. endblock_re = re.compile(r&quot;&quot;&quot;^\s*endblocktrans$&quot;&quot;&quot;)</font>
<font color="green"> 543. plural_re = re.compile(r&quot;&quot;&quot;^\s*plural$&quot;&quot;&quot;)</font>
<font color="green"> 544. constant_re = re.compile(r&quot;&quot;&quot;_\(((?:&quot;.*?&quot;)|(?:'.*?'))\)&quot;&quot;&quot;)</font>
<font color="black"> 545. </font>
<font color="black"> 546. </font>
<font color="green"> 547. def templatize(src, origin=None):</font>
<font color="black"> 548.     &quot;&quot;&quot;</font>
<font color="black"> 549.     Turns a Django template into something that is understood by xgettext. It</font>
<font color="black"> 550.     does so by translating the Django translation tags into standard gettext</font>
<font color="black"> 551.     function invocations.</font>
<font color="black"> 552.     &quot;&quot;&quot;</font>
<font color="red"> 553.     from django.template.base import (Lexer, TOKEN_TEXT, TOKEN_VAR,</font>
<font color="black"> 554.         TOKEN_BLOCK, TOKEN_COMMENT, TRANSLATOR_COMMENT_MARK)</font>
<font color="red"> 555.     src = force_text(src, settings.FILE_CHARSET)</font>
<font color="red"> 556.     out = StringIO('')</font>
<font color="red"> 557.     message_context = None</font>
<font color="red"> 558.     intrans = False</font>
<font color="red"> 559.     inplural = False</font>
<font color="red"> 560.     trimmed = False</font>
<font color="red"> 561.     singular = []</font>
<font color="red"> 562.     plural = []</font>
<font color="red"> 563.     incomment = False</font>
<font color="red"> 564.     comment = []</font>
<font color="red"> 565.     lineno_comment_map = {}</font>
<font color="red"> 566.     comment_lineno_cache = None</font>
<font color="black"> 567. </font>
<font color="red"> 568.     def join_tokens(tokens, trim=False):</font>
<font color="red"> 569.         message = ''.join(tokens)</font>
<font color="red"> 570.         if trim:</font>
<font color="red"> 571.             message = trim_whitespace(message)</font>
<font color="red"> 572.         return message</font>
<font color="black"> 573. </font>
<font color="red"> 574.     for t in Lexer(src).tokenize():</font>
<font color="red"> 575.         if incomment:</font>
<font color="red"> 576.             if t.token_type == TOKEN_BLOCK and t.contents == 'endcomment':</font>
<font color="red"> 577.                 content = ''.join(comment)</font>
<font color="red"> 578.                 translators_comment_start = None</font>
<font color="red"> 579.                 for lineno, line in enumerate(content.splitlines(True)):</font>
<font color="red"> 580.                     if line.lstrip().startswith(TRANSLATOR_COMMENT_MARK):</font>
<font color="red"> 581.                         translators_comment_start = lineno</font>
<font color="red"> 582.                 for lineno, line in enumerate(content.splitlines(True)):</font>
<font color="red"> 583.                     if translators_comment_start is not None and lineno &gt;= translators_comment_start:</font>
<font color="red"> 584.                         out.write(' # %s' % line)</font>
<font color="black"> 585.                     else:</font>
<font color="red"> 586.                         out.write(' #\n')</font>
<font color="red"> 587.                 incomment = False</font>
<font color="red"> 588.                 comment = []</font>
<font color="black"> 589.             else:</font>
<font color="red"> 590.                 comment.append(t.contents)</font>
<font color="red"> 591.         elif intrans:</font>
<font color="red"> 592.             if t.token_type == TOKEN_BLOCK:</font>
<font color="red"> 593.                 endbmatch = endblock_re.match(t.contents)</font>
<font color="red"> 594.                 pluralmatch = plural_re.match(t.contents)</font>
<font color="red"> 595.                 if endbmatch:</font>
<font color="red"> 596.                     if inplural:</font>
<font color="red"> 597.                         if message_context:</font>
<font color="red"> 598.                             out.write(' npgettext(%r, %r, %r,count) ' % (</font>
<font color="red"> 599.                                 message_context,</font>
<font color="red"> 600.                                 join_tokens(singular, trimmed),</font>
<font color="red"> 601.                                 join_tokens(plural, trimmed)))</font>
<font color="black"> 602.                         else:</font>
<font color="red"> 603.                             out.write(' ngettext(%r, %r, count) ' % (</font>
<font color="red"> 604.                                 join_tokens(singular, trimmed),</font>
<font color="red"> 605.                                 join_tokens(plural, trimmed)))</font>
<font color="red"> 606.                         for part in singular:</font>
<font color="red"> 607.                             out.write(blankout(part, 'S'))</font>
<font color="red"> 608.                         for part in plural:</font>
<font color="red"> 609.                             out.write(blankout(part, 'P'))</font>
<font color="black"> 610.                     else:</font>
<font color="red"> 611.                         if message_context:</font>
<font color="red"> 612.                             out.write(' pgettext(%r, %r) ' % (</font>
<font color="red"> 613.                                 message_context,</font>
<font color="red"> 614.                                 join_tokens(singular, trimmed)))</font>
<font color="black"> 615.                         else:</font>
<font color="red"> 616.                             out.write(' gettext(%r) ' % join_tokens(singular,</font>
<font color="red"> 617.                                                                     trimmed))</font>
<font color="red"> 618.                         for part in singular:</font>
<font color="red"> 619.                             out.write(blankout(part, 'S'))</font>
<font color="red"> 620.                     message_context = None</font>
<font color="red"> 621.                     intrans = False</font>
<font color="red"> 622.                     inplural = False</font>
<font color="red"> 623.                     singular = []</font>
<font color="red"> 624.                     plural = []</font>
<font color="red"> 625.                 elif pluralmatch:</font>
<font color="red"> 626.                     inplural = True</font>
<font color="black"> 627.                 else:</font>
<font color="red"> 628.                     filemsg = ''</font>
<font color="red"> 629.                     if origin:</font>
<font color="red"> 630.                         filemsg = 'file %s, ' % origin</font>
<font color="red"> 631.                     raise SyntaxError(</font>
<font color="red"> 632.                         &quot;Translation blocks must not include other block tags: &quot;</font>
<font color="red"> 633.                         &quot;%s (%sline %d)&quot; % (t.contents, filemsg, t.lineno)</font>
<font color="black"> 634.                     )</font>
<font color="red"> 635.             elif t.token_type == TOKEN_VAR:</font>
<font color="red"> 636.                 if inplural:</font>
<font color="red"> 637.                     plural.append('%%(%s)s' % t.contents)</font>
<font color="black"> 638.                 else:</font>
<font color="red"> 639.                     singular.append('%%(%s)s' % t.contents)</font>
<font color="red"> 640.             elif t.token_type == TOKEN_TEXT:</font>
<font color="red"> 641.                 contents = t.contents.replace('%', '%%')</font>
<font color="red"> 642.                 if inplural:</font>
<font color="red"> 643.                     plural.append(contents)</font>
<font color="black"> 644.                 else:</font>
<font color="red"> 645.                     singular.append(contents)</font>
<font color="black"> 646. </font>
<font color="black"> 647.         else:</font>
<font color="black"> 648.             # Handle comment tokens (`{# ... #}`) plus other constructs on</font>
<font color="black"> 649.             # the same line:</font>
<font color="red"> 650.             if comment_lineno_cache is not None:</font>
<font color="red"> 651.                 cur_lineno = t.lineno + t.contents.count('\n')</font>
<font color="red"> 652.                 if comment_lineno_cache == cur_lineno:</font>
<font color="red"> 653.                     if t.token_type != TOKEN_COMMENT:</font>
<font color="red"> 654.                         for c in lineno_comment_map[comment_lineno_cache]:</font>
<font color="red"> 655.                             filemsg = ''</font>
<font color="red"> 656.                             if origin:</font>
<font color="red"> 657.                                 filemsg = 'file %s, ' % origin</font>
<font color="red"> 658.                             warn_msg = (&quot;The translator-targeted comment '%s' &quot;</font>
<font color="black"> 659.                                 &quot;(%sline %d) was ignored, because it wasn't the last item &quot;</font>
<font color="red"> 660.                                 &quot;on the line.&quot;) % (c, filemsg, comment_lineno_cache)</font>
<font color="red"> 661.                             warnings.warn(warn_msg, TranslatorCommentWarning)</font>
<font color="red"> 662.                         lineno_comment_map[comment_lineno_cache] = []</font>
<font color="black"> 663.                 else:</font>
<font color="red"> 664.                     out.write('# %s' % ' | '.join(lineno_comment_map[comment_lineno_cache]))</font>
<font color="red"> 665.                 comment_lineno_cache = None</font>
<font color="black"> 666. </font>
<font color="red"> 667.             if t.token_type == TOKEN_BLOCK:</font>
<font color="red"> 668.                 imatch = inline_re.match(t.contents)</font>
<font color="red"> 669.                 bmatch = block_re.match(t.contents)</font>
<font color="red"> 670.                 cmatches = constant_re.findall(t.contents)</font>
<font color="red"> 671.                 if imatch:</font>
<font color="red"> 672.                     g = imatch.group(1)</font>
<font color="red"> 673.                     if g[0] == '&quot;':</font>
<font color="red"> 674.                         g = g.strip('&quot;')</font>
<font color="red"> 675.                     elif g[0] == &quot;'&quot;:</font>
<font color="red"> 676.                         g = g.strip(&quot;'&quot;)</font>
<font color="red"> 677.                     g = g.replace('%', '%%')</font>
<font color="red"> 678.                     if imatch.group(2):</font>
<font color="black"> 679.                         # A context is provided</font>
<font color="red"> 680.                         context_match = context_re.match(imatch.group(2))</font>
<font color="red"> 681.                         message_context = context_match.group(1)</font>
<font color="red"> 682.                         if message_context[0] == '&quot;':</font>
<font color="red"> 683.                             message_context = message_context.strip('&quot;')</font>
<font color="red"> 684.                         elif message_context[0] == &quot;'&quot;:</font>
<font color="red"> 685.                             message_context = message_context.strip(&quot;'&quot;)</font>
<font color="red"> 686.                         out.write(' pgettext(%r, %r) ' % (message_context, g))</font>
<font color="red"> 687.                         message_context = None</font>
<font color="black"> 688.                     else:</font>
<font color="red"> 689.                         out.write(' gettext(%r) ' % g)</font>
<font color="red"> 690.                 elif bmatch:</font>
<font color="red"> 691.                     for fmatch in constant_re.findall(t.contents):</font>
<font color="red"> 692.                         out.write(' _(%s) ' % fmatch)</font>
<font color="red"> 693.                     if bmatch.group(1):</font>
<font color="black"> 694.                         # A context is provided</font>
<font color="red"> 695.                         context_match = context_re.match(bmatch.group(1))</font>
<font color="red"> 696.                         message_context = context_match.group(1)</font>
<font color="red"> 697.                         if message_context[0] == '&quot;':</font>
<font color="red"> 698.                             message_context = message_context.strip('&quot;')</font>
<font color="red"> 699.                         elif message_context[0] == &quot;'&quot;:</font>
<font color="red"> 700.                             message_context = message_context.strip(&quot;'&quot;)</font>
<font color="red"> 701.                     intrans = True</font>
<font color="red"> 702.                     inplural = False</font>
<font color="red"> 703.                     trimmed = 'trimmed' in t.split_contents()</font>
<font color="red"> 704.                     singular = []</font>
<font color="red"> 705.                     plural = []</font>
<font color="red"> 706.                 elif cmatches:</font>
<font color="red"> 707.                     for cmatch in cmatches:</font>
<font color="red"> 708.                         out.write(' _(%s) ' % cmatch)</font>
<font color="red"> 709.                 elif t.contents == 'comment':</font>
<font color="red"> 710.                     incomment = True</font>
<font color="black"> 711.                 else:</font>
<font color="red"> 712.                     out.write(blankout(t.contents, 'B'))</font>
<font color="red"> 713.             elif t.token_type == TOKEN_VAR:</font>
<font color="red"> 714.                 parts = t.contents.split('|')</font>
<font color="red"> 715.                 cmatch = constant_re.match(parts[0])</font>
<font color="red"> 716.                 if cmatch:</font>
<font color="red"> 717.                     out.write(' _(%s) ' % cmatch.group(1))</font>
<font color="red"> 718.                 for p in parts[1:]:</font>
<font color="red"> 719.                     if p.find(':_(') &gt;= 0:</font>
<font color="red"> 720.                         out.write(' %s ' % p.split(':', 1)[1])</font>
<font color="black"> 721.                     else:</font>
<font color="red"> 722.                         out.write(blankout(p, 'F'))</font>
<font color="red"> 723.             elif t.token_type == TOKEN_COMMENT:</font>
<font color="red"> 724.                 if t.contents.lstrip().startswith(TRANSLATOR_COMMENT_MARK):</font>
<font color="red"> 725.                     lineno_comment_map.setdefault(t.lineno,</font>
<font color="red"> 726.                                                   []).append(t.contents)</font>
<font color="red"> 727.                     comment_lineno_cache = t.lineno</font>
<font color="black"> 728.             else:</font>
<font color="red"> 729.                 out.write(blankout(t.contents, 'X'))</font>
<font color="red"> 730.     return out.getvalue()</font>
<font color="black"> 731. </font>
<font color="black"> 732. </font>
<font color="green"> 733. def parse_accept_lang_header(lang_string):</font>
<font color="black"> 734.     &quot;&quot;&quot;</font>
<font color="black"> 735.     Parses the lang_string, which is the body of an HTTP Accept-Language</font>
<font color="black"> 736.     header, and returns a list of (lang, q-value), ordered by 'q' values.</font>
<font color="black"> 737. </font>
<font color="black"> 738.     Any format errors in lang_string results in an empty list being returned.</font>
<font color="black"> 739.     &quot;&quot;&quot;</font>
<font color="red"> 740.     result = []</font>
<font color="red"> 741.     pieces = accept_language_re.split(lang_string.lower())</font>
<font color="red"> 742.     if pieces[-1]:</font>
<font color="red"> 743.         return []</font>
<font color="red"> 744.     for i in range(0, len(pieces) - 1, 3):</font>
<font color="red"> 745.         first, lang, priority = pieces[i:i + 3]</font>
<font color="red"> 746.         if first:</font>
<font color="red"> 747.             return []</font>
<font color="red"> 748.         if priority:</font>
<font color="red"> 749.             try:</font>
<font color="red"> 750.                 priority = float(priority)</font>
<font color="red"> 751.             except ValueError:</font>
<font color="red"> 752.                 return []</font>
<font color="red"> 753.         if not priority:        # if priority is 0.0 at this point make it 1.0</font>
<font color="red"> 754.             priority = 1.0</font>
<font color="red"> 755.         result.append((lang, priority))</font>
<font color="red"> 756.     result.sort(key=lambda k: k[1], reverse=True)</font>
<font color="red"> 757.     return result</font>
</pre>

