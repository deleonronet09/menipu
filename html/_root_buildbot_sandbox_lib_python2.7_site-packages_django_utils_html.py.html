source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/html.py</b><br>


file stats: <b>230 lines, 85 executed: 37.0% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;HTML utilities suitable for global use.&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="green">   3. from __future__ import unicode_literals</font>
<font color="black">   4. </font>
<font color="green">   5. import re</font>
<font color="green">   6. import warnings</font>
<font color="black">   7. </font>
<font color="green">   8. from django.utils import six</font>
<font color="green">   9. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  10. from django.utils.encoding import force_str, force_text</font>
<font color="green">  11. from django.utils.functional import allow_lazy</font>
<font color="green">  12. from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS</font>
<font color="green">  13. from django.utils.safestring import SafeData, SafeText, mark_safe</font>
<font color="green">  14. from django.utils.six.moves.urllib.parse import (</font>
<font color="black">  15.     parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit,</font>
<font color="black">  16. )</font>
<font color="green">  17. from django.utils.text import normalize_newlines</font>
<font color="black">  18. </font>
<font color="green">  19. from .html_parser import HTMLParseError, HTMLParser</font>
<font color="black">  20. </font>
<font color="black">  21. # Configuration for urlize() function.</font>
<font color="green">  22. TRAILING_PUNCTUATION = ['.', ',', ':', ';', '.)', '&quot;', '\'', '!']</font>
<font color="green">  23. WRAPPING_PUNCTUATION = [('(', ')'), ('&lt;', '&gt;'), ('[', ']'), ('&amp;lt;', '&amp;gt;'), ('&quot;', '&quot;'), ('\'', '\'')]</font>
<font color="black">  24. </font>
<font color="black">  25. # List of possible strings used for bullets in bulleted lists.</font>
<font color="green">  26. DOTS = ['&amp;middot;', '*', '\u2022', '&amp;#149;', '&amp;bull;', '&amp;#8226;']</font>
<font color="black">  27. </font>
<font color="green">  28. unencoded_ampersands_re = re.compile(r'&amp;(?!(\w+|#\d+);)')</font>
<font color="green">  29. word_split_re = re.compile(r'''([\s&lt;&gt;&quot;']+)''')</font>
<font color="green">  30. simple_url_re = re.compile(r'^https?://\[?\w', re.IGNORECASE)</font>
<font color="green">  31. simple_url_2_re = re.compile(r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$', re.IGNORECASE)</font>
<font color="green">  32. simple_email_re = re.compile(r'^\S+@\S+\.\S+$')</font>
<font color="green">  33. link_target_attribute_re = re.compile(r'(&lt;a [^&gt;]*?)target=[^\s&gt;]+')</font>
<font color="green">  34. html_gunk_re = re.compile(</font>
<font color="green">  35.     r'(?:&lt;br clear=&quot;all&quot;&gt;|&lt;i&gt;&lt;\/i&gt;|&lt;b&gt;&lt;\/b&gt;|&lt;em&gt;&lt;\/em&gt;|&lt;strong&gt;&lt;\/strong&gt;|'</font>
<font color="green">  36.     '&lt;\/?smallcaps&gt;|&lt;\/?uppercase&gt;)', re.IGNORECASE)</font>
<font color="green">  37. hard_coded_bullets_re = re.compile(</font>
<font color="green">  38.     r'((?:&lt;p&gt;(?:%s).*?[a-zA-Z].*?&lt;/p&gt;\s*)+)' % '|'.join(re.escape(x)</font>
<font color="green">  39.     for x in DOTS), re.DOTALL)</font>
<font color="green">  40. trailing_empty_content_re = re.compile(r'(?:&lt;p&gt;(?:&amp;nbsp;|\s|&lt;br \/&gt;)*?&lt;/p&gt;\s*)+\Z')</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. def escape(text):</font>
<font color="black">  44.     &quot;&quot;&quot;</font>
<font color="black">  45.     Returns the given text with ampersands, quotes and angle brackets encoded</font>
<font color="black">  46.     for use in HTML.</font>
<font color="black">  47. </font>
<font color="black">  48.     This function always escapes its input, even if it's already escaped and</font>
<font color="black">  49.     marked as such. This may result in double-escaping. If this is a concern,</font>
<font color="black">  50.     use conditional_escape() instead.</font>
<font color="black">  51.     &quot;&quot;&quot;</font>
<font color="green">  52.     return mark_safe(force_text(text).replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;')</font>
<font color="green">  53.         .replace('&gt;', '&amp;gt;').replace('&quot;', '&amp;quot;').replace(&quot;'&quot;, '&amp;#39;'))</font>
<font color="green">  54. escape = allow_lazy(escape, six.text_type, SafeText)</font>
<font color="black">  55. </font>
<font color="green">  56. _js_escapes = {</font>
<font color="green">  57.     ord('\\'): '\\u005C',</font>
<font color="green">  58.     ord('\''): '\\u0027',</font>
<font color="green">  59.     ord('&quot;'): '\\u0022',</font>
<font color="green">  60.     ord('&gt;'): '\\u003E',</font>
<font color="green">  61.     ord('&lt;'): '\\u003C',</font>
<font color="green">  62.     ord('&amp;'): '\\u0026',</font>
<font color="green">  63.     ord('='): '\\u003D',</font>
<font color="green">  64.     ord('-'): '\\u002D',</font>
<font color="green">  65.     ord(';'): '\\u003B',</font>
<font color="green">  66.     ord('\u2028'): '\\u2028',</font>
<font color="green">  67.     ord('\u2029'): '\\u2029'</font>
<font color="black">  68. }</font>
<font color="black">  69. </font>
<font color="black">  70. # Escape every ASCII character with a value less than 32.</font>
<font color="green">  71. _js_escapes.update((ord('%c' % z), '\\u%04X' % z) for z in range(32))</font>
<font color="black">  72. </font>
<font color="black">  73. </font>
<font color="green">  74. def escapejs(value):</font>
<font color="black">  75.     &quot;&quot;&quot;Hex encodes characters for use in JavaScript strings.&quot;&quot;&quot;</font>
<font color="red">  76.     return mark_safe(force_text(value).translate(_js_escapes))</font>
<font color="green">  77. escapejs = allow_lazy(escapejs, six.text_type, SafeText)</font>
<font color="black">  78. </font>
<font color="black">  79. </font>
<font color="green">  80. def conditional_escape(text):</font>
<font color="black">  81.     &quot;&quot;&quot;</font>
<font color="black">  82.     Similar to escape(), except that it doesn't operate on pre-escaped strings.</font>
<font color="black">  83. </font>
<font color="black">  84.     This function relies on the __html__ convention used both by Django's</font>
<font color="black">  85.     SafeData class and by third-party libraries like markupsafe.</font>
<font color="black">  86.     &quot;&quot;&quot;</font>
<font color="green">  87.     if hasattr(text, '__html__'):</font>
<font color="red">  88.         return text.__html__()</font>
<font color="black">  89.     else:</font>
<font color="green">  90.         return escape(text)</font>
<font color="black">  91. </font>
<font color="black">  92. </font>
<font color="green">  93. def format_html(format_string, *args, **kwargs):</font>
<font color="black">  94.     &quot;&quot;&quot;</font>
<font color="black">  95.     Similar to str.format, but passes all arguments through conditional_escape,</font>
<font color="black">  96.     and calls 'mark_safe' on the result. This function should be used instead</font>
<font color="black">  97.     of str.format or % interpolation to build up small HTML fragments.</font>
<font color="black">  98.     &quot;&quot;&quot;</font>
<font color="green">  99.     args_safe = map(conditional_escape, args)</font>
<font color="green"> 100.     kwargs_safe = {k: conditional_escape(v) for (k, v) in six.iteritems(kwargs)}</font>
<font color="green"> 101.     return mark_safe(format_string.format(*args_safe, **kwargs_safe))</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. def format_html_join(sep, format_string, args_generator):</font>
<font color="black"> 105.     &quot;&quot;&quot;</font>
<font color="black"> 106.     A wrapper of format_html, for the common case of a group of arguments that</font>
<font color="black"> 107.     need to be formatted using the same format string, and then joined using</font>
<font color="black"> 108.     'sep'. 'sep' is also passed through conditional_escape.</font>
<font color="black"> 109. </font>
<font color="black"> 110.     'args_generator' should be an iterator that returns the sequence of 'args'</font>
<font color="black"> 111.     that will be passed to format_html.</font>
<font color="black"> 112. </font>
<font color="black"> 113.     Example:</font>
<font color="black"> 114. </font>
<font color="black"> 115.       format_html_join('\n', &quot;&lt;li&gt;{} {}&lt;/li&gt;&quot;, ((u.first_name, u.last_name)</font>
<font color="black"> 116.                                                   for u in users))</font>
<font color="black"> 117.     &quot;&quot;&quot;</font>
<font color="red"> 118.     return mark_safe(conditional_escape(sep).join(</font>
<font color="red"> 119.         format_html(format_string, *tuple(args))</font>
<font color="red"> 120.         for args in args_generator))</font>
<font color="black"> 121. </font>
<font color="black"> 122. </font>
<font color="green"> 123. def linebreaks(value, autoescape=False):</font>
<font color="black"> 124.     &quot;&quot;&quot;Converts newlines into &lt;p&gt; and &lt;br /&gt;s.&quot;&quot;&quot;</font>
<font color="red"> 125.     value = normalize_newlines(value)</font>
<font color="red"> 126.     paras = re.split('\n{2,}', value)</font>
<font color="red"> 127.     if autoescape:</font>
<font color="red"> 128.         paras = ['&lt;p&gt;%s&lt;/p&gt;' % escape(p).replace('\n', '&lt;br /&gt;') for p in paras]</font>
<font color="black"> 129.     else:</font>
<font color="red"> 130.         paras = ['&lt;p&gt;%s&lt;/p&gt;' % p.replace('\n', '&lt;br /&gt;') for p in paras]</font>
<font color="red"> 131.     return '\n\n'.join(paras)</font>
<font color="green"> 132. linebreaks = allow_lazy(linebreaks, six.text_type)</font>
<font color="black"> 133. </font>
<font color="black"> 134. </font>
<font color="green"> 135. class MLStripper(HTMLParser):</font>
<font color="green"> 136.     def __init__(self):</font>
<font color="red"> 137.         HTMLParser.__init__(self)</font>
<font color="red"> 138.         self.reset()</font>
<font color="red"> 139.         self.fed = []</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def handle_data(self, d):</font>
<font color="red"> 142.         self.fed.append(d)</font>
<font color="black"> 143. </font>
<font color="green"> 144.     def handle_entityref(self, name):</font>
<font color="red"> 145.         self.fed.append('&amp;%s;' % name)</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def handle_charref(self, name):</font>
<font color="red"> 148.         self.fed.append('&amp;#%s;' % name)</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def get_data(self):</font>
<font color="red"> 151.         return ''.join(self.fed)</font>
<font color="black"> 152. </font>
<font color="black"> 153. </font>
<font color="green"> 154. def _strip_once(value):</font>
<font color="black"> 155.     &quot;&quot;&quot;</font>
<font color="black"> 156.     Internal tag stripping utility used by strip_tags.</font>
<font color="black"> 157.     &quot;&quot;&quot;</font>
<font color="red"> 158.     s = MLStripper()</font>
<font color="red"> 159.     try:</font>
<font color="red"> 160.         s.feed(value)</font>
<font color="red"> 161.     except HTMLParseError:</font>
<font color="red"> 162.         return value</font>
<font color="red"> 163.     try:</font>
<font color="red"> 164.         s.close()</font>
<font color="red"> 165.     except HTMLParseError:</font>
<font color="red"> 166.         return s.get_data() + s.rawdata</font>
<font color="black"> 167.     else:</font>
<font color="red"> 168.         return s.get_data()</font>
<font color="black"> 169. </font>
<font color="black"> 170. </font>
<font color="green"> 171. def strip_tags(value):</font>
<font color="black"> 172.     &quot;&quot;&quot;Returns the given HTML with all tags stripped.&quot;&quot;&quot;</font>
<font color="black"> 173.     # Note: in typical case this loop executes _strip_once once. Loop condition</font>
<font color="black"> 174.     # is redundant, but helps to reduce number of executions of _strip_once.</font>
<font color="red"> 175.     while '&lt;' in value and '&gt;' in value:</font>
<font color="red"> 176.         new_value = _strip_once(value)</font>
<font color="red"> 177.         if len(new_value) &gt;= len(value):</font>
<font color="black"> 178.             # _strip_once was not able to detect more tags or length increased</font>
<font color="black"> 179.             # due to http://bugs.python.org/issue20288</font>
<font color="black"> 180.             # (affects Python 2 &lt; 2.7.7 and Python 3 &lt; 3.3.5)</font>
<font color="red"> 181.             break</font>
<font color="red"> 182.         value = new_value</font>
<font color="red"> 183.     return value</font>
<font color="green"> 184. strip_tags = allow_lazy(strip_tags)</font>
<font color="black"> 185. </font>
<font color="black"> 186. </font>
<font color="green"> 187. def remove_tags(html, tags):</font>
<font color="black"> 188.     &quot;&quot;&quot;Returns the given HTML with given tags removed.&quot;&quot;&quot;</font>
<font color="red"> 189.     warnings.warn(</font>
<font color="red"> 190.         &quot;django.utils.html.remove_tags() and the removetags template filter &quot;</font>
<font color="black"> 191.         &quot;are deprecated. Consider using the bleach library instead.&quot;,</font>
<font color="red"> 192.         RemovedInDjango110Warning, stacklevel=3</font>
<font color="black"> 193.     )</font>
<font color="red"> 194.     tags = [re.escape(tag) for tag in tags.split()]</font>
<font color="red"> 195.     tags_re = '(%s)' % '|'.join(tags)</font>
<font color="red"> 196.     starttag_re = re.compile(r'&lt;%s(/?&gt;|(\s+[^&gt;]*&gt;))' % tags_re, re.U)</font>
<font color="red"> 197.     endtag_re = re.compile('&lt;/%s&gt;' % tags_re)</font>
<font color="red"> 198.     html = starttag_re.sub('', html)</font>
<font color="red"> 199.     html = endtag_re.sub('', html)</font>
<font color="red"> 200.     return html</font>
<font color="green"> 201. remove_tags = allow_lazy(remove_tags, six.text_type)</font>
<font color="black"> 202. </font>
<font color="black"> 203. </font>
<font color="green"> 204. def strip_spaces_between_tags(value):</font>
<font color="black"> 205.     &quot;&quot;&quot;Returns the given HTML with spaces between tags removed.&quot;&quot;&quot;</font>
<font color="red"> 206.     return re.sub(r'&gt;\s+&lt;', '&gt;&lt;', force_text(value))</font>
<font color="green"> 207. strip_spaces_between_tags = allow_lazy(strip_spaces_between_tags, six.text_type)</font>
<font color="black"> 208. </font>
<font color="black"> 209. </font>
<font color="green"> 210. def strip_entities(value):</font>
<font color="black"> 211.     &quot;&quot;&quot;Returns the given HTML with all entities (&amp;something;) stripped.&quot;&quot;&quot;</font>
<font color="red"> 212.     warnings.warn(</font>
<font color="red"> 213.         &quot;django.utils.html.strip_entities() is deprecated.&quot;,</font>
<font color="red"> 214.         RemovedInDjango110Warning, stacklevel=2</font>
<font color="black"> 215.     )</font>
<font color="red"> 216.     return re.sub(r'&amp;(?:\w+|#\d+);', '', force_text(value))</font>
<font color="green"> 217. strip_entities = allow_lazy(strip_entities, six.text_type)</font>
<font color="black"> 218. </font>
<font color="black"> 219. </font>
<font color="green"> 220. def smart_urlquote(url):</font>
<font color="black"> 221.     &quot;Quotes a URL if it isn't already quoted.&quot;</font>
<font color="red"> 222.     def unquote_quote(segment):</font>
<font color="red"> 223.         segment = unquote(force_str(segment))</font>
<font color="black"> 224.         # Tilde is part of RFC3986 Unreserved Characters</font>
<font color="black"> 225.         # http://tools.ietf.org/html/rfc3986#section-2.3</font>
<font color="black"> 226.         # See also http://bugs.python.org/issue16285</font>
<font color="red"> 227.         segment = quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + str('~'))</font>
<font color="red"> 228.         return force_text(segment)</font>
<font color="black"> 229. </font>
<font color="black"> 230.     # Handle IDN before quoting.</font>
<font color="red"> 231.     try:</font>
<font color="red"> 232.         scheme, netloc, path, query, fragment = urlsplit(url)</font>
<font color="red"> 233.     except ValueError:</font>
<font color="black"> 234.         # invalid IPv6 URL (normally square brackets in hostname part).</font>
<font color="red"> 235.         return unquote_quote(url)</font>
<font color="black"> 236. </font>
<font color="red"> 237.     try:</font>
<font color="red"> 238.         netloc = netloc.encode('idna').decode('ascii')  # IDN -&gt; ACE</font>
<font color="red"> 239.     except UnicodeError:  # invalid domain part</font>
<font color="red"> 240.         return unquote_quote(url)</font>
<font color="black"> 241. </font>
<font color="red"> 242.     if query:</font>
<font color="black"> 243.         # Separately unquoting key/value, so as to not mix querystring separators</font>
<font color="black"> 244.         # included in query values. See #22267.</font>
<font color="red"> 245.         query_parts = [(unquote(force_str(q[0])), unquote(force_str(q[1])))</font>
<font color="red"> 246.                        for q in parse_qsl(query, keep_blank_values=True)]</font>
<font color="black"> 247.         # urlencode will take care of quoting</font>
<font color="red"> 248.         query = urlencode(query_parts)</font>
<font color="black"> 249. </font>
<font color="red"> 250.     path = unquote_quote(path)</font>
<font color="red"> 251.     fragment = unquote_quote(fragment)</font>
<font color="black"> 252. </font>
<font color="red"> 253.     return urlunsplit((scheme, netloc, path, query, fragment))</font>
<font color="black"> 254. </font>
<font color="black"> 255. </font>
<font color="green"> 256. def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):</font>
<font color="black"> 257.     &quot;&quot;&quot;</font>
<font color="black"> 258.     Converts any URLs in text into clickable links.</font>
<font color="black"> 259. </font>
<font color="black"> 260.     Works on http://, https://, www. links, and also on links ending in one of</font>
<font color="black"> 261.     the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).</font>
<font color="black"> 262.     Links can have trailing punctuation (periods, commas, close-parens) and</font>
<font color="black"> 263.     leading punctuation (opening parens) and it'll still do the right thing.</font>
<font color="black"> 264. </font>
<font color="black"> 265.     If trim_url_limit is not None, the URLs in the link text longer than this</font>
<font color="black"> 266.     limit will be truncated to trim_url_limit-3 characters and appended with</font>
<font color="black"> 267.     an ellipsis.</font>
<font color="black"> 268. </font>
<font color="black"> 269.     If nofollow is True, the links will get a rel=&quot;nofollow&quot; attribute.</font>
<font color="black"> 270. </font>
<font color="black"> 271.     If autoescape is True, the link text and URLs will be autoescaped.</font>
<font color="black"> 272.     &quot;&quot;&quot;</font>
<font color="red"> 273.     safe_input = isinstance(text, SafeData)</font>
<font color="black"> 274. </font>
<font color="red"> 275.     def trim_url(x, limit=trim_url_limit):</font>
<font color="red"> 276.         if limit is None or len(x) &lt;= limit:</font>
<font color="red"> 277.             return x</font>
<font color="red"> 278.         return '%s...' % x[:max(0, limit - 3)]</font>
<font color="black"> 279. </font>
<font color="red"> 280.     def unescape(text, trail):</font>
<font color="black"> 281.         &quot;&quot;&quot;</font>
<font color="black"> 282.         If input URL is HTML-escaped, unescape it so as we can safely feed it to</font>
<font color="black"> 283.         smart_urlquote. For example:</font>
<font color="black"> 284.         http://example.com?x=1&amp;amp;y=&amp;lt;2&amp;gt; =&gt; http://example.com?x=1&amp;y=&lt;2&gt;</font>
<font color="black"> 285.         &quot;&quot;&quot;</font>
<font color="red"> 286.         unescaped = (text + trail).replace(</font>
<font color="red"> 287.             '&amp;amp;', '&amp;').replace('&amp;lt;', '&lt;').replace(</font>
<font color="red"> 288.             '&amp;gt;', '&gt;').replace('&amp;quot;', '&quot;').replace('&amp;#39;', &quot;'&quot;)</font>
<font color="red"> 289.         if trail and unescaped.endswith(trail):</font>
<font color="black"> 290.             # Remove trail for unescaped if it was not consumed by unescape</font>
<font color="red"> 291.             unescaped = unescaped[:-len(trail)]</font>
<font color="red"> 292.         elif trail == ';':</font>
<font color="black"> 293.             # Trail was consumed by unescape (as end-of-entity marker), move it to text</font>
<font color="red"> 294.             text += trail</font>
<font color="red"> 295.             trail = ''</font>
<font color="red"> 296.         return text, unescaped, trail</font>
<font color="black"> 297. </font>
<font color="red"> 298.     words = word_split_re.split(force_text(text))</font>
<font color="red"> 299.     for i, word in enumerate(words):</font>
<font color="red"> 300.         if '.' in word or '@' in word or ':' in word:</font>
<font color="black"> 301.             # Deal with punctuation.</font>
<font color="red"> 302.             lead, middle, trail = '', word, ''</font>
<font color="red"> 303.             for punctuation in TRAILING_PUNCTUATION:</font>
<font color="red"> 304.                 if middle.endswith(punctuation):</font>
<font color="red"> 305.                     middle = middle[:-len(punctuation)]</font>
<font color="red"> 306.                     trail = punctuation + trail</font>
<font color="red"> 307.             for opening, closing in WRAPPING_PUNCTUATION:</font>
<font color="red"> 308.                 if middle.startswith(opening):</font>
<font color="red"> 309.                     middle = middle[len(opening):]</font>
<font color="red"> 310.                     lead = lead + opening</font>
<font color="black"> 311.                 # Keep parentheses at the end only if they're balanced.</font>
<font color="red"> 312.                 if (middle.endswith(closing)</font>
<font color="red"> 313.                         and middle.count(closing) == middle.count(opening) + 1):</font>
<font color="red"> 314.                     middle = middle[:-len(closing)]</font>
<font color="red"> 315.                     trail = closing + trail</font>
<font color="black"> 316. </font>
<font color="black"> 317.             # Make URL we want to point to.</font>
<font color="red"> 318.             url = None</font>
<font color="red"> 319.             nofollow_attr = ' rel=&quot;nofollow&quot;' if nofollow else ''</font>
<font color="red"> 320.             if simple_url_re.match(middle):</font>
<font color="red"> 321.                 middle, middle_unescaped, trail = unescape(middle, trail)</font>
<font color="red"> 322.                 url = smart_urlquote(middle_unescaped)</font>
<font color="red"> 323.             elif simple_url_2_re.match(middle):</font>
<font color="red"> 324.                 middle, middle_unescaped, trail = unescape(middle, trail)</font>
<font color="red"> 325.                 url = smart_urlquote('http://%s' % middle_unescaped)</font>
<font color="red"> 326.             elif ':' not in middle and simple_email_re.match(middle):</font>
<font color="red"> 327.                 local, domain = middle.rsplit('@', 1)</font>
<font color="red"> 328.                 try:</font>
<font color="red"> 329.                     domain = domain.encode('idna').decode('ascii')</font>
<font color="red"> 330.                 except UnicodeError:</font>
<font color="red"> 331.                     continue</font>
<font color="red"> 332.                 url = 'mailto:%s@%s' % (local, domain)</font>
<font color="red"> 333.                 nofollow_attr = ''</font>
<font color="black"> 334. </font>
<font color="black"> 335.             # Make link.</font>
<font color="red"> 336.             if url:</font>
<font color="red"> 337.                 trimmed = trim_url(middle)</font>
<font color="red"> 338.                 if autoescape and not safe_input:</font>
<font color="red"> 339.                     lead, trail = escape(lead), escape(trail)</font>
<font color="red"> 340.                     trimmed = escape(trimmed)</font>
<font color="red"> 341.                 middle = '&lt;a href=&quot;%s&quot;%s&gt;%s&lt;/a&gt;' % (escape(url), nofollow_attr, trimmed)</font>
<font color="red"> 342.                 words[i] = mark_safe('%s%s%s' % (lead, middle, trail))</font>
<font color="black"> 343.             else:</font>
<font color="red"> 344.                 if safe_input:</font>
<font color="red"> 345.                     words[i] = mark_safe(word)</font>
<font color="red"> 346.                 elif autoescape:</font>
<font color="red"> 347.                     words[i] = escape(word)</font>
<font color="red"> 348.         elif safe_input:</font>
<font color="red"> 349.             words[i] = mark_safe(word)</font>
<font color="red"> 350.         elif autoescape:</font>
<font color="red"> 351.             words[i] = escape(word)</font>
<font color="red"> 352.     return ''.join(words)</font>
<font color="green"> 353. urlize = allow_lazy(urlize, six.text_type)</font>
<font color="black"> 354. </font>
<font color="black"> 355. </font>
<font color="green"> 356. def avoid_wrapping(value):</font>
<font color="black"> 357.     &quot;&quot;&quot;</font>
<font color="black"> 358.     Avoid text wrapping in the middle of a phrase by adding non-breaking</font>
<font color="black"> 359.     spaces where there previously were normal spaces.</font>
<font color="black"> 360.     &quot;&quot;&quot;</font>
<font color="red"> 361.     return value.replace(&quot; &quot;, &quot;\xa0&quot;)</font>
<font color="black"> 362. </font>
<font color="black"> 363. </font>
<font color="green"> 364. def html_safe(klass):</font>
<font color="black"> 365.     &quot;&quot;&quot;</font>
<font color="black"> 366.     A decorator that defines the __html__ method. This helps non-Django</font>
<font color="black"> 367.     templates to detect classes whose __str__ methods return SafeText.</font>
<font color="black"> 368.     &quot;&quot;&quot;</font>
<font color="green"> 369.     if '__html__' in klass.__dict__:</font>
<font color="red"> 370.         raise ValueError(</font>
<font color="red"> 371.             &quot;can't apply @html_safe to %s because it defines &quot;</font>
<font color="red"> 372.             &quot;__html__().&quot; % klass.__name__</font>
<font color="black"> 373.         )</font>
<font color="green"> 374.     if six.PY2:</font>
<font color="green"> 375.         if '__unicode__' not in klass.__dict__:</font>
<font color="red"> 376.             raise ValueError(</font>
<font color="red"> 377.                 &quot;can't apply @html_safe to %s because it doesn't &quot;</font>
<font color="red"> 378.                 &quot;define __unicode__().&quot; % klass.__name__</font>
<font color="black"> 379.             )</font>
<font color="green"> 380.         klass_unicode = klass.__unicode__</font>
<font color="green"> 381.         klass.__unicode__ = lambda self: mark_safe(klass_unicode(self))</font>
<font color="green"> 382.         klass.__html__ = lambda self: unicode(self)  # NOQA: unicode undefined on PY3</font>
<font color="black"> 383.     else:</font>
<font color="red"> 384.         if '__str__' not in klass.__dict__:</font>
<font color="red"> 385.             raise ValueError(</font>
<font color="red"> 386.                 &quot;can't apply @html_safe to %s because it doesn't &quot;</font>
<font color="red"> 387.                 &quot;define __str__().&quot; % klass.__name__</font>
<font color="black"> 388.             )</font>
<font color="red"> 389.         klass_str = klass.__str__</font>
<font color="red"> 390.         klass.__str__ = lambda self: mark_safe(klass_str(self))</font>
<font color="red"> 391.         klass.__html__ = lambda self: str(self)</font>
<font color="green"> 392.     return klass</font>
</pre>

