source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/apps/config.py</b><br>


file stats: <b>95 lines, 64 executed: 67.4% covered</b>
<pre>
<font color="green">   1. import os</font>
<font color="green">   2. from importlib import import_module</font>
<font color="black">   3. </font>
<font color="green">   4. from django.core.exceptions import AppRegistryNotReady, ImproperlyConfigured</font>
<font color="green">   5. from django.utils._os import upath</font>
<font color="green">   6. from django.utils.module_loading import module_has_submodule</font>
<font color="black">   7. </font>
<font color="green">   8. MODELS_MODULE_NAME = 'models'</font>
<font color="black">   9. </font>
<font color="black">  10. </font>
<font color="green">  11. class AppConfig(object):</font>
<font color="black">  12.     &quot;&quot;&quot;</font>
<font color="black">  13.     Class representing a Django application and its configuration.</font>
<font color="green">  14.     &quot;&quot;&quot;</font>
<font color="black">  15. </font>
<font color="green">  16.     def __init__(self, app_name, app_module):</font>
<font color="black">  17.         # Full Python path to the application eg. 'django.contrib.admin'.</font>
<font color="green">  18.         self.name = app_name</font>
<font color="black">  19. </font>
<font color="black">  20.         # Root module for the application eg. &lt;module 'django.contrib.admin'</font>
<font color="black">  21.         # from 'django/contrib/admin/__init__.pyc'&gt;.</font>
<font color="green">  22.         self.module = app_module</font>
<font color="black">  23. </font>
<font color="black">  24.         # The following attributes could be defined at the class level in a</font>
<font color="black">  25.         # subclass, hence the test-and-set pattern.</font>
<font color="black">  26. </font>
<font color="black">  27.         # Last component of the Python path to the application eg. 'admin'.</font>
<font color="black">  28.         # This value must be unique across a Django project.</font>
<font color="green">  29.         if not hasattr(self, 'label'):</font>
<font color="green">  30.             self.label = app_name.rpartition(&quot;.&quot;)[2]</font>
<font color="black">  31. </font>
<font color="black">  32.         # Human-readable name for the application eg. &quot;Admin&quot;.</font>
<font color="green">  33.         if not hasattr(self, 'verbose_name'):</font>
<font color="green">  34.             self.verbose_name = self.label.title()</font>
<font color="black">  35. </font>
<font color="black">  36.         # Filesystem path to the application directory eg.</font>
<font color="black">  37.         # u'/usr/lib/python2.7/dist-packages/django/contrib/admin'. Unicode on</font>
<font color="black">  38.         # Python 2 and a str on Python 3.</font>
<font color="green">  39.         if not hasattr(self, 'path'):</font>
<font color="green">  40.             self.path = self._path_from_module(app_module)</font>
<font color="black">  41. </font>
<font color="black">  42.         # Module containing models eg. &lt;module 'django.contrib.admin.models'</font>
<font color="black">  43.         # from 'django/contrib/admin/models.pyc'&gt;. Set by import_models().</font>
<font color="black">  44.         # None if the application doesn't have a models module.</font>
<font color="green">  45.         self.models_module = None</font>
<font color="black">  46. </font>
<font color="black">  47.         # Mapping of lower case model names to model classes. Initially set to</font>
<font color="black">  48.         # None to prevent accidental access before import_models() runs.</font>
<font color="green">  49.         self.models = None</font>
<font color="black">  50. </font>
<font color="green">  51.     def __repr__(self):</font>
<font color="red">  52.         return '&lt;%s: %s&gt;' % (self.__class__.__name__, self.label)</font>
<font color="black">  53. </font>
<font color="green">  54.     def _path_from_module(self, module):</font>
<font color="black">  55.         &quot;&quot;&quot;Attempt to determine app's filesystem path from its module.&quot;&quot;&quot;</font>
<font color="black">  56.         # See #21874 for extended discussion of the behavior of this method in</font>
<font color="black">  57.         # various cases.</font>
<font color="black">  58.         # Convert paths to list because Python 3's _NamespacePath does not</font>
<font color="black">  59.         # support indexing.</font>
<font color="green">  60.         paths = list(getattr(module, '__path__', []))</font>
<font color="green">  61.         if len(paths) != 1:</font>
<font color="red">  62.             filename = getattr(module, '__file__', None)</font>
<font color="red">  63.             if filename is not None:</font>
<font color="red">  64.                 paths = [os.path.dirname(filename)]</font>
<font color="black">  65.             else:</font>
<font color="black">  66.                 # For unknown reasons, sometimes the list returned by __path__</font>
<font color="black">  67.                 # contains duplicates that must be removed (#25246).</font>
<font color="red">  68.                 paths = list(set(paths))</font>
<font color="green">  69.         if len(paths) &gt; 1:</font>
<font color="red">  70.             raise ImproperlyConfigured(</font>
<font color="red">  71.                 &quot;The app module %r has multiple filesystem locations (%r); &quot;</font>
<font color="black">  72.                 &quot;you must configure this app with an AppConfig subclass &quot;</font>
<font color="red">  73.                 &quot;with a 'path' class attribute.&quot; % (module, paths))</font>
<font color="green">  74.         elif not paths:</font>
<font color="red">  75.             raise ImproperlyConfigured(</font>
<font color="red">  76.                 &quot;The app module %r has no filesystem location, &quot;</font>
<font color="black">  77.                 &quot;you must configure this app with an AppConfig subclass &quot;</font>
<font color="red">  78.                 &quot;with a 'path' class attribute.&quot; % (module,))</font>
<font color="green">  79.         return upath(paths[0])</font>
<font color="black">  80. </font>
<font color="green">  81.     @classmethod</font>
<font color="black">  82.     def create(cls, entry):</font>
<font color="black">  83.         &quot;&quot;&quot;</font>
<font color="black">  84.         Factory that creates an app config from an entry in INSTALLED_APPS.</font>
<font color="black">  85.         &quot;&quot;&quot;</font>
<font color="green">  86.         try:</font>
<font color="black">  87.             # If import_module succeeds, entry is a path to an app module,</font>
<font color="black">  88.             # which may specify an app config class with default_app_config.</font>
<font color="black">  89.             # Otherwise, entry is a path to an app config class or an error.</font>
<font color="green">  90.             module = import_module(entry)</font>
<font color="black">  91. </font>
<font color="red">  92.         except ImportError:</font>
<font color="black">  93.             # Track that importing as an app module failed. If importing as an</font>
<font color="black">  94.             # app config class fails too, we'll trigger the ImportError again.</font>
<font color="red">  95.             module = None</font>
<font color="black">  96. </font>
<font color="red">  97.             mod_path, _, cls_name = entry.rpartition('.')</font>
<font color="black">  98. </font>
<font color="black">  99.             # Raise the original exception when entry cannot be a path to an</font>
<font color="black"> 100.             # app config class.</font>
<font color="red"> 101.             if not mod_path:</font>
<font color="red"> 102.                 raise</font>
<font color="black"> 103. </font>
<font color="black"> 104.         else:</font>
<font color="green"> 105.             try:</font>
<font color="black"> 106.                 # If this works, the app module specifies an app config class.</font>
<font color="green"> 107.                 entry = module.default_app_config</font>
<font color="red"> 108.             except AttributeError:</font>
<font color="black"> 109.                 # Otherwise, it simply uses the default app config class.</font>
<font color="red"> 110.                 return cls(entry, module)</font>
<font color="black"> 111.             else:</font>
<font color="green"> 112.                 mod_path, _, cls_name = entry.rpartition('.')</font>
<font color="black"> 113. </font>
<font color="black"> 114.         # If we're reaching this point, we must attempt to load the app config</font>
<font color="black"> 115.         # class located at &lt;mod_path&gt;.&lt;cls_name&gt;</font>
<font color="green"> 116.         mod = import_module(mod_path)</font>
<font color="green"> 117.         try:</font>
<font color="green"> 118.             cls = getattr(mod, cls_name)</font>
<font color="red"> 119.         except AttributeError:</font>
<font color="red"> 120.             if module is None:</font>
<font color="black"> 121.                 # If importing as an app module failed, that error probably</font>
<font color="black"> 122.                 # contains the most informative traceback. Trigger it again.</font>
<font color="red"> 123.                 import_module(entry)</font>
<font color="black"> 124.             else:</font>
<font color="red"> 125.                 raise</font>
<font color="black"> 126. </font>
<font color="black"> 127.         # Check for obvious errors. (This check prevents duck typing, but</font>
<font color="black"> 128.         # it could be removed if it became a problem in practice.)</font>
<font color="green"> 129.         if not issubclass(cls, AppConfig):</font>
<font color="red"> 130.             raise ImproperlyConfigured(</font>
<font color="red"> 131.                 &quot;'%s' isn't a subclass of AppConfig.&quot; % entry)</font>
<font color="black"> 132. </font>
<font color="black"> 133.         # Obtain app name here rather than in AppClass.__init__ to keep</font>
<font color="black"> 134.         # all error checking for entries in INSTALLED_APPS in one place.</font>
<font color="green"> 135.         try:</font>
<font color="green"> 136.             app_name = cls.name</font>
<font color="red"> 137.         except AttributeError:</font>
<font color="red"> 138.             raise ImproperlyConfigured(</font>
<font color="red"> 139.                 &quot;'%s' must supply a name attribute.&quot; % entry)</font>
<font color="black"> 140. </font>
<font color="black"> 141.         # Ensure app_name points to a valid module.</font>
<font color="green"> 142.         app_module = import_module(app_name)</font>
<font color="black"> 143. </font>
<font color="black"> 144.         # Entry is a path to an app config class.</font>
<font color="green"> 145.         return cls(app_name, app_module)</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def check_models_ready(self):</font>
<font color="black"> 148.         &quot;&quot;&quot;</font>
<font color="black"> 149.         Raises an exception if models haven't been imported yet.</font>
<font color="black"> 150.         &quot;&quot;&quot;</font>
<font color="green"> 151.         if self.models is None:</font>
<font color="red"> 152.             raise AppRegistryNotReady(</font>
<font color="red"> 153.                 &quot;Models for app '%s' haven't been imported yet.&quot; % self.label)</font>
<font color="black"> 154. </font>
<font color="green"> 155.     def get_model(self, model_name):</font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="black"> 157.         Returns the model with the given case-insensitive model_name.</font>
<font color="black"> 158. </font>
<font color="black"> 159.         Raises LookupError if no model exists with this name.</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="green"> 161.         self.check_models_ready()</font>
<font color="green"> 162.         try:</font>
<font color="green"> 163.             return self.models[model_name.lower()]</font>
<font color="green"> 164.         except KeyError:</font>
<font color="green"> 165.             raise LookupError(</font>
<font color="green"> 166.                 &quot;App '%s' doesn't have a '%s' model.&quot; % (self.label, model_name))</font>
<font color="black"> 167. </font>
<font color="green"> 168.     def get_models(self, include_auto_created=False,</font>
<font color="green"> 169.                    include_deferred=False, include_swapped=False):</font>
<font color="black"> 170.         &quot;&quot;&quot;</font>
<font color="black"> 171.         Returns an iterable of models.</font>
<font color="black"> 172. </font>
<font color="black"> 173.         By default, the following models aren't included:</font>
<font color="black"> 174. </font>
<font color="black"> 175.         - auto-created models for many-to-many relations without</font>
<font color="black"> 176.           an explicit intermediate table,</font>
<font color="black"> 177.         - models created to satisfy deferred attribute queries,</font>
<font color="black"> 178.         - models that have been swapped out.</font>
<font color="black"> 179. </font>
<font color="black"> 180.         Set the corresponding keyword argument to True to include such models.</font>
<font color="black"> 181.         Keyword arguments aren't documented; they're a private API.</font>
<font color="black"> 182.         &quot;&quot;&quot;</font>
<font color="green"> 183.         self.check_models_ready()</font>
<font color="green"> 184.         for model in self.models.values():</font>
<font color="green"> 185.             if model._deferred and not include_deferred:</font>
<font color="red"> 186.                 continue</font>
<font color="green"> 187.             if model._meta.auto_created and not include_auto_created:</font>
<font color="green"> 188.                 continue</font>
<font color="green"> 189.             if model._meta.swapped and not include_swapped:</font>
<font color="red"> 190.                 continue</font>
<font color="green"> 191.             yield model</font>
<font color="black"> 192. </font>
<font color="green"> 193.     def import_models(self, all_models):</font>
<font color="black"> 194.         # Dictionary of models for this app, primarily maintained in the</font>
<font color="black"> 195.         # 'all_models' attribute of the Apps this AppConfig is attached to.</font>
<font color="black"> 196.         # Injected as a parameter because it gets populated when models are</font>
<font color="black"> 197.         # imported, which might happen before populate() imports models.</font>
<font color="green"> 198.         self.models = all_models</font>
<font color="black"> 199. </font>
<font color="green"> 200.         if module_has_submodule(self.module, MODELS_MODULE_NAME):</font>
<font color="green"> 201.             models_module_name = '%s.%s' % (self.name, MODELS_MODULE_NAME)</font>
<font color="green"> 202.             self.models_module = import_module(models_module_name)</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def ready(self):</font>
<font color="black"> 205.         &quot;&quot;&quot;</font>
<font color="black"> 206.         Override this method in subclasses to run code when Django starts.</font>
<font color="black"> 207.         &quot;&quot;&quot;</font>
</pre>

