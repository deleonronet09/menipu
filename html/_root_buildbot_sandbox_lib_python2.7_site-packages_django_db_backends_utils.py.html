source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/utils.py</b><br>


file stats: <b>136 lines, 46 executed: 33.8% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import datetime</font>
<font color="green">   4. import decimal</font>
<font color="green">   5. import hashlib</font>
<font color="green">   6. import logging</font>
<font color="green">   7. from time import time</font>
<font color="black">   8. </font>
<font color="green">   9. from django.conf import settings</font>
<font color="green">  10. from django.utils.encoding import force_bytes</font>
<font color="green">  11. from django.utils.timezone import utc</font>
<font color="black">  12. </font>
<font color="green">  13. logger = logging.getLogger('django.db.backends')</font>
<font color="black">  14. </font>
<font color="black">  15. </font>
<font color="green">  16. class CursorWrapper(object):</font>
<font color="green">  17.     def __init__(self, cursor, db):</font>
<font color="green">  18.         self.cursor = cursor</font>
<font color="green">  19.         self.db = db</font>
<font color="black">  20. </font>
<font color="green">  21.     WRAP_ERROR_ATTRS = frozenset(['fetchone', 'fetchmany', 'fetchall', 'nextset'])</font>
<font color="black">  22. </font>
<font color="green">  23.     def __getattr__(self, attr):</font>
<font color="green">  24.         cursor_attr = getattr(self.cursor, attr)</font>
<font color="green">  25.         if attr in CursorWrapper.WRAP_ERROR_ATTRS:</font>
<font color="green">  26.             return self.db.wrap_database_errors(cursor_attr)</font>
<font color="black">  27.         else:</font>
<font color="green">  28.             return cursor_attr</font>
<font color="black">  29. </font>
<font color="green">  30.     def __iter__(self):</font>
<font color="red">  31.         with self.db.wrap_database_errors:</font>
<font color="red">  32.             for item in self.cursor:</font>
<font color="red">  33.                 yield item</font>
<font color="black">  34. </font>
<font color="green">  35.     def __enter__(self):</font>
<font color="green">  36.         return self</font>
<font color="black">  37. </font>
<font color="green">  38.     def __exit__(self, type, value, traceback):</font>
<font color="black">  39.         # Ticket #17671 - Close instead of passing thru to avoid backend</font>
<font color="black">  40.         # specific behavior. Catch errors liberally because errors in cleanup</font>
<font color="black">  41.         # code aren't useful.</font>
<font color="green">  42.         try:</font>
<font color="green">  43.             self.close()</font>
<font color="red">  44.         except self.db.Database.Error:</font>
<font color="red">  45.             pass</font>
<font color="black">  46. </font>
<font color="black">  47.     # The following methods cannot be implemented in __getattr__, because the</font>
<font color="black">  48.     # code must run when the method is invoked, not just when it is accessed.</font>
<font color="black">  49. </font>
<font color="green">  50.     def callproc(self, procname, params=None):</font>
<font color="red">  51.         self.db.validate_no_broken_transaction()</font>
<font color="red">  52.         with self.db.wrap_database_errors:</font>
<font color="red">  53.             if params is None:</font>
<font color="red">  54.                 return self.cursor.callproc(procname)</font>
<font color="black">  55.             else:</font>
<font color="red">  56.                 return self.cursor.callproc(procname, params)</font>
<font color="black">  57. </font>
<font color="green">  58.     def execute(self, sql, params=None):</font>
<font color="green">  59.         self.db.validate_no_broken_transaction()</font>
<font color="green">  60.         with self.db.wrap_database_errors:</font>
<font color="green">  61.             if params is None:</font>
<font color="green">  62.                 return self.cursor.execute(sql)</font>
<font color="black">  63.             else:</font>
<font color="green">  64.                 return self.cursor.execute(sql, params)</font>
<font color="black">  65. </font>
<font color="green">  66.     def executemany(self, sql, param_list):</font>
<font color="red">  67.         self.db.validate_no_broken_transaction()</font>
<font color="red">  68.         with self.db.wrap_database_errors:</font>
<font color="red">  69.             return self.cursor.executemany(sql, param_list)</font>
<font color="black">  70. </font>
<font color="black">  71. </font>
<font color="green">  72. class CursorDebugWrapper(CursorWrapper):</font>
<font color="black">  73. </font>
<font color="black">  74.     # XXX callproc isn't instrumented at this time.</font>
<font color="black">  75. </font>
<font color="green">  76.     def execute(self, sql, params=None):</font>
<font color="red">  77.         start = time()</font>
<font color="red">  78.         try:</font>
<font color="red">  79.             return super(CursorDebugWrapper, self).execute(sql, params)</font>
<font color="black">  80.         finally:</font>
<font color="red">  81.             stop = time()</font>
<font color="red">  82.             duration = stop - start</font>
<font color="red">  83.             sql = self.db.ops.last_executed_query(self.cursor, sql, params)</font>
<font color="red">  84.             self.db.queries_log.append({</font>
<font color="red">  85.                 'sql': sql,</font>
<font color="red">  86.                 'time': &quot;%.3f&quot; % duration,</font>
<font color="black">  87.             })</font>
<font color="red">  88.             logger.debug('(%.3f) %s; args=%s' % (duration, sql, params),</font>
<font color="red">  89.                 extra={'duration': duration, 'sql': sql, 'params': params}</font>
<font color="black">  90.             )</font>
<font color="black">  91. </font>
<font color="green">  92.     def executemany(self, sql, param_list):</font>
<font color="red">  93.         start = time()</font>
<font color="red">  94.         try:</font>
<font color="red">  95.             return super(CursorDebugWrapper, self).executemany(sql, param_list)</font>
<font color="black">  96.         finally:</font>
<font color="red">  97.             stop = time()</font>
<font color="red">  98.             duration = stop - start</font>
<font color="red">  99.             try:</font>
<font color="red"> 100.                 times = len(param_list)</font>
<font color="red"> 101.             except TypeError:           # param_list could be an iterator</font>
<font color="red"> 102.                 times = '?'</font>
<font color="red"> 103.             self.db.queries_log.append({</font>
<font color="red"> 104.                 'sql': '%s times: %s' % (times, sql),</font>
<font color="red"> 105.                 'time': &quot;%.3f&quot; % duration,</font>
<font color="black"> 106.             })</font>
<font color="red"> 107.             logger.debug('(%.3f) %s; args=%s' % (duration, sql, param_list),</font>
<font color="red"> 108.                 extra={'duration': duration, 'sql': sql, 'params': param_list}</font>
<font color="black"> 109.             )</font>
<font color="black"> 110. </font>
<font color="black"> 111. </font>
<font color="black"> 112. ###############################################</font>
<font color="black"> 113. # Converters from database (string) to Python #</font>
<font color="black"> 114. ###############################################</font>
<font color="black"> 115. </font>
<font color="green"> 116. def typecast_date(s):</font>
<font color="red"> 117.     return datetime.date(*map(int, s.split('-'))) if s else None  # returns None if s is null</font>
<font color="black"> 118. </font>
<font color="black"> 119. </font>
<font color="green"> 120. def typecast_time(s):  # does NOT store time zone information</font>
<font color="red"> 121.     if not s:</font>
<font color="red"> 122.         return None</font>
<font color="red"> 123.     hour, minutes, seconds = s.split(':')</font>
<font color="red"> 124.     if '.' in seconds:  # check whether seconds have a fractional part</font>
<font color="red"> 125.         seconds, microseconds = seconds.split('.')</font>
<font color="black"> 126.     else:</font>
<font color="red"> 127.         microseconds = '0'</font>
<font color="red"> 128.     return datetime.time(int(hour), int(minutes), int(seconds), int(float('.' + microseconds) * 1000000))</font>
<font color="black"> 129. </font>
<font color="black"> 130. </font>
<font color="green"> 131. def typecast_timestamp(s):  # does NOT store time zone information</font>
<font color="black"> 132.     # &quot;2005-07-29 15:48:00.590358-05&quot;</font>
<font color="black"> 133.     # &quot;2005-07-29 09:56:00-05&quot;</font>
<font color="red"> 134.     if not s:</font>
<font color="red"> 135.         return None</font>
<font color="red"> 136.     if ' ' not in s:</font>
<font color="red"> 137.         return typecast_date(s)</font>
<font color="red"> 138.     d, t = s.split()</font>
<font color="black"> 139.     # Extract timezone information, if it exists. Currently we just throw</font>
<font color="black"> 140.     # it away, but in the future we may make use of it.</font>
<font color="red"> 141.     if '-' in t:</font>
<font color="red"> 142.         t, tz = t.split('-', 1)</font>
<font color="red"> 143.         tz = '-' + tz</font>
<font color="red"> 144.     elif '+' in t:</font>
<font color="red"> 145.         t, tz = t.split('+', 1)</font>
<font color="red"> 146.         tz = '+' + tz</font>
<font color="black"> 147.     else:</font>
<font color="red"> 148.         tz = ''</font>
<font color="red"> 149.     dates = d.split('-')</font>
<font color="red"> 150.     times = t.split(':')</font>
<font color="red"> 151.     seconds = times[2]</font>
<font color="red"> 152.     if '.' in seconds:  # check whether seconds have a fractional part</font>
<font color="red"> 153.         seconds, microseconds = seconds.split('.')</font>
<font color="black"> 154.     else:</font>
<font color="red"> 155.         microseconds = '0'</font>
<font color="red"> 156.     tzinfo = utc if settings.USE_TZ else None</font>
<font color="red"> 157.     return datetime.datetime(int(dates[0]), int(dates[1]), int(dates[2]),</font>
<font color="red"> 158.         int(times[0]), int(times[1]), int(seconds),</font>
<font color="red"> 159.         int((microseconds + '000000')[:6]), tzinfo)</font>
<font color="black"> 160. </font>
<font color="black"> 161. </font>
<font color="green"> 162. def typecast_decimal(s):</font>
<font color="red"> 163.     if s is None or s == '':</font>
<font color="red"> 164.         return None</font>
<font color="red"> 165.     return decimal.Decimal(s)</font>
<font color="black"> 166. </font>
<font color="black"> 167. </font>
<font color="black"> 168. ###############################################</font>
<font color="black"> 169. # Converters from Python to database (string) #</font>
<font color="black"> 170. ###############################################</font>
<font color="black"> 171. </font>
<font color="green"> 172. def rev_typecast_decimal(d):</font>
<font color="red"> 173.     if d is None:</font>
<font color="red"> 174.         return None</font>
<font color="red"> 175.     return str(d)</font>
<font color="black"> 176. </font>
<font color="black"> 177. </font>
<font color="green"> 178. def truncate_name(name, length=None, hash_len=4):</font>
<font color="black"> 179.     &quot;&quot;&quot;Shortens a string to a repeatable mangled version with the given length.</font>
<font color="black"> 180.     &quot;&quot;&quot;</font>
<font color="green"> 181.     if length is None or len(name) &lt;= length:</font>
<font color="green"> 182.         return name</font>
<font color="black"> 183. </font>
<font color="red"> 184.     hsh = hashlib.md5(force_bytes(name)).hexdigest()[:hash_len]</font>
<font color="red"> 185.     return '%s%s' % (name[:length - hash_len], hsh)</font>
<font color="black"> 186. </font>
<font color="black"> 187. </font>
<font color="green"> 188. def format_number(value, max_digits, decimal_places):</font>
<font color="black"> 189.     &quot;&quot;&quot;</font>
<font color="black"> 190.     Formats a number into a string with the requisite number of digits and</font>
<font color="black"> 191.     decimal places.</font>
<font color="black"> 192.     &quot;&quot;&quot;</font>
<font color="red"> 193.     if value is None:</font>
<font color="red"> 194.         return None</font>
<font color="red"> 195.     if isinstance(value, decimal.Decimal):</font>
<font color="red"> 196.         context = decimal.getcontext().copy()</font>
<font color="red"> 197.         if max_digits is not None:</font>
<font color="red"> 198.             context.prec = max_digits</font>
<font color="red"> 199.         if decimal_places is not None:</font>
<font color="red"> 200.             value = value.quantize(decimal.Decimal(&quot;.1&quot;) ** decimal_places, context=context)</font>
<font color="black"> 201.         else:</font>
<font color="red"> 202.             context.traps[decimal.Rounded] = 1</font>
<font color="red"> 203.             value = context.create_decimal(value)</font>
<font color="red"> 204.         return &quot;{:f}&quot;.format(value)</font>
<font color="red"> 205.     if decimal_places is not None:</font>
<font color="red"> 206.         return &quot;%.*f&quot; % (decimal_places, value)</font>
<font color="red"> 207.     return &quot;{:f}&quot;.format(value)</font>
</pre>

