source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/test/runner.py</b><br>


file stats: <b>424 lines, 252 executed: 59.4% covered</b>
<pre>
<font color="green">   1. import collections</font>
<font color="green">   2. import ctypes</font>
<font color="green">   3. import itertools</font>
<font color="green">   4. import logging</font>
<font color="green">   5. import multiprocessing</font>
<font color="green">   6. import os</font>
<font color="green">   7. import pickle</font>
<font color="green">   8. import textwrap</font>
<font color="green">   9. import unittest</font>
<font color="green">  10. from importlib import import_module</font>
<font color="black">  11. </font>
<font color="green">  12. from django.conf import settings</font>
<font color="green">  13. from django.core.exceptions import ImproperlyConfigured</font>
<font color="green">  14. from django.db import DEFAULT_DB_ALIAS, connections</font>
<font color="green">  15. from django.test import SimpleTestCase, TestCase</font>
<font color="green">  16. from django.test.utils import setup_test_environment, teardown_test_environment</font>
<font color="green">  17. from django.utils.datastructures import OrderedSet</font>
<font color="green">  18. from django.utils.six import StringIO</font>
<font color="black">  19. </font>
<font color="green">  20. try:</font>
<font color="green">  21.     import tblib.pickling_support</font>
<font color="green">  22. except ImportError:</font>
<font color="green">  23.     tblib = None</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. class DebugSQLTextTestResult(unittest.TextTestResult):</font>
<font color="green">  27.     def __init__(self, stream, descriptions, verbosity):</font>
<font color="red">  28.         self.logger = logging.getLogger('django.db.backends')</font>
<font color="red">  29.         self.logger.setLevel(logging.DEBUG)</font>
<font color="red">  30.         super(DebugSQLTextTestResult, self).__init__(stream, descriptions, verbosity)</font>
<font color="black">  31. </font>
<font color="green">  32.     def startTest(self, test):</font>
<font color="red">  33.         self.debug_sql_stream = StringIO()</font>
<font color="red">  34.         self.handler = logging.StreamHandler(self.debug_sql_stream)</font>
<font color="red">  35.         self.logger.addHandler(self.handler)</font>
<font color="red">  36.         super(DebugSQLTextTestResult, self).startTest(test)</font>
<font color="black">  37. </font>
<font color="green">  38.     def stopTest(self, test):</font>
<font color="red">  39.         super(DebugSQLTextTestResult, self).stopTest(test)</font>
<font color="red">  40.         self.logger.removeHandler(self.handler)</font>
<font color="red">  41.         if self.showAll:</font>
<font color="red">  42.             self.debug_sql_stream.seek(0)</font>
<font color="red">  43.             self.stream.write(self.debug_sql_stream.read())</font>
<font color="red">  44.             self.stream.writeln(self.separator2)</font>
<font color="black">  45. </font>
<font color="green">  46.     def addError(self, test, err):</font>
<font color="red">  47.         super(DebugSQLTextTestResult, self).addError(test, err)</font>
<font color="red">  48.         self.debug_sql_stream.seek(0)</font>
<font color="red">  49.         self.errors[-1] = self.errors[-1] + (self.debug_sql_stream.read(),)</font>
<font color="black">  50. </font>
<font color="green">  51.     def addFailure(self, test, err):</font>
<font color="red">  52.         super(DebugSQLTextTestResult, self).addFailure(test, err)</font>
<font color="red">  53.         self.debug_sql_stream.seek(0)</font>
<font color="red">  54.         self.failures[-1] = self.failures[-1] + (self.debug_sql_stream.read(),)</font>
<font color="black">  55. </font>
<font color="green">  56.     def printErrorList(self, flavour, errors):</font>
<font color="red">  57.         for test, err, sql_debug in errors:</font>
<font color="red">  58.             self.stream.writeln(self.separator1)</font>
<font color="red">  59.             self.stream.writeln(&quot;%s: %s&quot; % (flavour, self.getDescription(test)))</font>
<font color="red">  60.             self.stream.writeln(self.separator2)</font>
<font color="red">  61.             self.stream.writeln(&quot;%s&quot; % err)</font>
<font color="red">  62.             self.stream.writeln(self.separator2)</font>
<font color="red">  63.             self.stream.writeln(&quot;%s&quot; % sql_debug)</font>
<font color="black">  64. </font>
<font color="black">  65. </font>
<font color="green">  66. class RemoteTestResult(object):</font>
<font color="black">  67.     &quot;&quot;&quot;</font>
<font color="black">  68.     Record information about which tests have succeeded and which have failed.</font>
<font color="black">  69. </font>
<font color="black">  70.     The sole purpose of this class is to record events in the child processes</font>
<font color="black">  71.     so they can be replayed in the master process. As a consequence it doesn't</font>
<font color="black">  72.     inherit unittest.TestResult and doesn't attempt to implement all its API.</font>
<font color="black">  73. </font>
<font color="black">  74.     The implementation matches the unpythonic coding style of unittest2.</font>
<font color="green">  75.     &quot;&quot;&quot;</font>
<font color="black">  76. </font>
<font color="green">  77.     def __init__(self):</font>
<font color="red">  78.         self.events = []</font>
<font color="red">  79.         self.failfast = False</font>
<font color="red">  80.         self.shouldStop = False</font>
<font color="red">  81.         self.testsRun = 0</font>
<font color="black">  82. </font>
<font color="green">  83.     @property</font>
<font color="black">  84.     def test_index(self):</font>
<font color="red">  85.         return self.testsRun - 1</font>
<font color="black">  86. </font>
<font color="green">  87.     def check_pickleable(self, test, err):</font>
<font color="black">  88.         # Ensure that sys.exc_info() tuples are picklable. This displays a</font>
<font color="black">  89.         # clear multiprocessing.pool.RemoteTraceback generated in the child</font>
<font color="black">  90.         # process instead of a multiprocessing.pool.MaybeEncodingError, making</font>
<font color="black">  91.         # the root cause easier to figure out for users who aren't familiar</font>
<font color="black">  92.         # with the multiprocessing module. Since we're in a forked process,</font>
<font color="black">  93.         # our best chance to communicate with them is to print to stdout.</font>
<font color="red">  94.         try:</font>
<font color="red">  95.             pickle.dumps(err)</font>
<font color="red">  96.         except Exception as exc:</font>
<font color="red">  97.             original_exc_txt = repr(err[1])</font>
<font color="red">  98.             original_exc_txt = textwrap.fill(original_exc_txt, 75, initial_indent='    ', subsequent_indent='    ')</font>
<font color="red">  99.             pickle_exc_txt = repr(exc)</font>
<font color="red"> 100.             pickle_exc_txt = textwrap.fill(pickle_exc_txt, 75, initial_indent='    ', subsequent_indent='    ')</font>
<font color="red"> 101.             if tblib is None:</font>
<font color="black"> 102.                 print(&quot;&quot;&quot;</font>
<font color="black"> 103. </font>
<font color="black"> 104. {} failed:</font>
<font color="black"> 105. </font>
<font color="black"> 106. {}</font>
<font color="black"> 107. </font>
<font color="black"> 108. Unfortunately, tracebacks cannot be pickled, making it impossible for the</font>
<font color="black"> 109. parallel test runner to handle this exception cleanly.</font>
<font color="black"> 110. </font>
<font color="black"> 111. In order to see the traceback, you should install tblib:</font>
<font color="black"> 112. </font>
<font color="black"> 113.     pip install tblib</font>
<font color="red"> 114. &quot;&quot;&quot;.format(test, original_exc_txt))</font>
<font color="black"> 115.             else:</font>
<font color="black"> 116.                 print(&quot;&quot;&quot;</font>
<font color="black"> 117. </font>
<font color="black"> 118. {} failed:</font>
<font color="black"> 119. </font>
<font color="black"> 120. {}</font>
<font color="black"> 121. </font>
<font color="black"> 122. Unfortunately, the exception it raised cannot be pickled, making it impossible</font>
<font color="black"> 123. for the parallel test runner to handle it cleanly.</font>
<font color="black"> 124. </font>
<font color="black"> 125. Here's the error encountered while trying to pickle the exception:</font>
<font color="black"> 126. </font>
<font color="black"> 127. {}</font>
<font color="black"> 128. </font>
<font color="black"> 129. You should re-run this test without the --parallel option to reproduce the</font>
<font color="black"> 130. failure and get a correct traceback.</font>
<font color="red"> 131. &quot;&quot;&quot;.format(test, original_exc_txt, pickle_exc_txt))</font>
<font color="red"> 132.             raise</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def stop_if_failfast(self):</font>
<font color="red"> 135.         if self.failfast:</font>
<font color="red"> 136.             self.stop()</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def stop(self):</font>
<font color="red"> 139.         self.shouldStop = True</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def startTestRun(self):</font>
<font color="red"> 142.         self.events.append(('startTestRun',))</font>
<font color="black"> 143. </font>
<font color="green"> 144.     def stopTestRun(self):</font>
<font color="red"> 145.         self.events.append(('stopTestRun',))</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def startTest(self, test):</font>
<font color="red"> 148.         self.testsRun += 1</font>
<font color="red"> 149.         self.events.append(('startTest', self.test_index))</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def stopTest(self, test):</font>
<font color="red"> 152.         self.events.append(('stopTest', self.test_index))</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def addError(self, test, err):</font>
<font color="red"> 155.         self.check_pickleable(test, err)</font>
<font color="red"> 156.         self.events.append(('addError', self.test_index, err))</font>
<font color="red"> 157.         self.stop_if_failfast()</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def addFailure(self, test, err):</font>
<font color="red"> 160.         self.check_pickleable(test, err)</font>
<font color="red"> 161.         self.events.append(('addFailure', self.test_index, err))</font>
<font color="red"> 162.         self.stop_if_failfast()</font>
<font color="black"> 163. </font>
<font color="green"> 164.     def addSubTest(self, test, subtest, err):</font>
<font color="red"> 165.         raise NotImplementedError(&quot;subtests aren't supported at this time&quot;)</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def addSuccess(self, test):</font>
<font color="red"> 168.         self.events.append(('addSuccess', self.test_index))</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def addSkip(self, test, reason):</font>
<font color="red"> 171.         self.events.append(('addSkip', self.test_index, reason))</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def addExpectedFailure(self, test, err):</font>
<font color="black"> 174.         # If tblib isn't installed, pickling the traceback will always fail.</font>
<font color="black"> 175.         # However we don't want tblib to be required for running the tests</font>
<font color="black"> 176.         # when they pass or fail as expected. Drop the traceback when an</font>
<font color="black"> 177.         # expected failure occurs.</font>
<font color="red"> 178.         if tblib is None:</font>
<font color="red"> 179.             err = err[0], err[1], None</font>
<font color="red"> 180.         self.check_pickleable(test, err)</font>
<font color="red"> 181.         self.events.append(('addExpectedFailure', self.test_index, err))</font>
<font color="black"> 182. </font>
<font color="green"> 183.     def addUnexpectedSuccess(self, test):</font>
<font color="red"> 184.         self.events.append(('addUnexpectedSuccess', self.test_index))</font>
<font color="red"> 185.         self.stop_if_failfast()</font>
<font color="black"> 186. </font>
<font color="black"> 187. </font>
<font color="green"> 188. class RemoteTestRunner(object):</font>
<font color="black"> 189.     &quot;&quot;&quot;</font>
<font color="black"> 190.     Run tests and record everything but don't display anything.</font>
<font color="black"> 191. </font>
<font color="black"> 192.     The implementation matches the unpythonic coding style of unittest2.</font>
<font color="green"> 193.     &quot;&quot;&quot;</font>
<font color="black"> 194. </font>
<font color="green"> 195.     resultclass = RemoteTestResult</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def __init__(self, failfast=False, resultclass=None):</font>
<font color="red"> 198.         self.failfast = failfast</font>
<font color="red"> 199.         if resultclass is not None:</font>
<font color="red"> 200.             self.resultclass = resultclass</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def run(self, test):</font>
<font color="red"> 203.         result = self.resultclass()</font>
<font color="red"> 204.         unittest.registerResult(result)</font>
<font color="red"> 205.         result.failfast = self.failfast</font>
<font color="red"> 206.         test(result)</font>
<font color="red"> 207.         return result</font>
<font color="black"> 208. </font>
<font color="black"> 209. </font>
<font color="green"> 210. def default_test_processes():</font>
<font color="black"> 211.     &quot;&quot;&quot;</font>
<font color="black"> 212.     Default number of test processes when using the --parallel option.</font>
<font color="black"> 213.     &quot;&quot;&quot;</font>
<font color="black"> 214.     # The current implementation of the parallel test runner requires</font>
<font color="black"> 215.     # multiprocessing to start subprocesses with fork().</font>
<font color="black"> 216.     # On Python 3.4+: if multiprocessing.get_start_method() != 'fork':</font>
<font color="green"> 217.     if not hasattr(os, 'fork'):</font>
<font color="red"> 218.         return 1</font>
<font color="green"> 219.     try:</font>
<font color="green"> 220.         return int(os.environ['DJANGO_TEST_PROCESSES'])</font>
<font color="green"> 221.     except KeyError:</font>
<font color="green"> 222.         return multiprocessing.cpu_count()</font>
<font color="black"> 223. </font>
<font color="black"> 224. </font>
<font color="green"> 225. _worker_id = 0</font>
<font color="black"> 226. </font>
<font color="black"> 227. </font>
<font color="green"> 228. def _init_worker(counter):</font>
<font color="black"> 229.     &quot;&quot;&quot;</font>
<font color="black"> 230.     Switch to databases dedicated to this worker.</font>
<font color="black"> 231. </font>
<font color="black"> 232.     This helper lives at module-level because of the multiprocessing module's</font>
<font color="black"> 233.     requirements.</font>
<font color="black"> 234.     &quot;&quot;&quot;</font>
<font color="black"> 235. </font>
<font color="black"> 236.     global _worker_id</font>
<font color="black"> 237. </font>
<font color="red"> 238.     with counter.get_lock():</font>
<font color="red"> 239.         counter.value += 1</font>
<font color="red"> 240.         _worker_id = counter.value</font>
<font color="black"> 241. </font>
<font color="red"> 242.     for alias in connections:</font>
<font color="red"> 243.         connection = connections[alias]</font>
<font color="red"> 244.         settings_dict = connection.creation.get_test_db_clone_settings(_worker_id)</font>
<font color="black"> 245.         # connection.settings_dict must be updated in place for changes to be</font>
<font color="black"> 246.         # reflected in django.db.connections. If the following line assigned</font>
<font color="black"> 247.         # connection.settings_dict = settings_dict, new threads would connect</font>
<font color="black"> 248.         # to the default database instead of the appropriate clone.</font>
<font color="red"> 249.         connection.settings_dict.update(settings_dict)</font>
<font color="red"> 250.         connection.close()</font>
<font color="black"> 251. </font>
<font color="black"> 252. </font>
<font color="green"> 253. def _run_subsuite(args):</font>
<font color="black"> 254.     &quot;&quot;&quot;</font>
<font color="black"> 255.     Run a suite of tests with a RemoteTestRunner and return a RemoteTestResult.</font>
<font color="black"> 256. </font>
<font color="black"> 257.     This helper lives at module-level and its arguments are wrapped in a tuple</font>
<font color="black"> 258.     because of the multiprocessing module's requirements.</font>
<font color="black"> 259.     &quot;&quot;&quot;</font>
<font color="red"> 260.     subsuite_index, subsuite, failfast = args</font>
<font color="red"> 261.     runner = RemoteTestRunner(failfast=failfast)</font>
<font color="red"> 262.     result = runner.run(subsuite)</font>
<font color="red"> 263.     return subsuite_index, result.events</font>
<font color="black"> 264. </font>
<font color="black"> 265. </font>
<font color="green"> 266. class ParallelTestSuite(unittest.TestSuite):</font>
<font color="black"> 267.     &quot;&quot;&quot;</font>
<font color="black"> 268.     Run a series of tests in parallel in several processes.</font>
<font color="black"> 269. </font>
<font color="black"> 270.     While the unittest module's documentation implies that orchestrating the</font>
<font color="black"> 271.     execution of tests is the responsibility of the test runner, in practice,</font>
<font color="black"> 272.     it appears that TestRunner classes are more concerned with formatting and</font>
<font color="black"> 273.     displaying test results.</font>
<font color="black"> 274. </font>
<font color="black"> 275.     Since there are fewer use cases for customizing TestSuite than TestRunner,</font>
<font color="black"> 276.     implementing parallelization at the level of the TestSuite improves</font>
<font color="black"> 277.     interoperability with existing custom test runners. A single instance of a</font>
<font color="black"> 278.     test runner can still collect results from all tests without being aware</font>
<font color="black"> 279.     that they have been run in parallel.</font>
<font color="green"> 280.     &quot;&quot;&quot;</font>
<font color="black"> 281. </font>
<font color="black"> 282.     # In case someone wants to modify these in a subclass.</font>
<font color="green"> 283.     init_worker = _init_worker</font>
<font color="green"> 284.     run_subsuite = _run_subsuite</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def __init__(self, suite, processes, failfast=False):</font>
<font color="red"> 287.         self.subsuites = partition_suite_by_case(suite)</font>
<font color="red"> 288.         self.processes = processes</font>
<font color="red"> 289.         self.failfast = failfast</font>
<font color="red"> 290.         super(ParallelTestSuite, self).__init__()</font>
<font color="black"> 291. </font>
<font color="green"> 292.     def run(self, result):</font>
<font color="black"> 293.         &quot;&quot;&quot;</font>
<font color="black"> 294.         Distribute test cases across workers.</font>
<font color="black"> 295. </font>
<font color="black"> 296.         Return an identifier of each test case with its result in order to use</font>
<font color="black"> 297.         imap_unordered to show results as soon as they're available.</font>
<font color="black"> 298. </font>
<font color="black"> 299.         To minimize pickling errors when getting results from workers:</font>
<font color="black"> 300. </font>
<font color="black"> 301.         - pass back numeric indexes in self.subsuites instead of tests</font>
<font color="black"> 302.         - make tracebacks pickleable with tblib, if available</font>
<font color="black"> 303. </font>
<font color="black"> 304.         Even with tblib, errors may still occur for dynamically created</font>
<font color="black"> 305.         exception classes such Model.DoesNotExist which cannot be unpickled.</font>
<font color="black"> 306.         &quot;&quot;&quot;</font>
<font color="red"> 307.         if tblib is not None:</font>
<font color="red"> 308.             tblib.pickling_support.install()</font>
<font color="black"> 309. </font>
<font color="red"> 310.         counter = multiprocessing.Value(ctypes.c_int, 0)</font>
<font color="red"> 311.         pool = multiprocessing.Pool(</font>
<font color="red"> 312.             processes=self.processes,</font>
<font color="red"> 313.             initializer=self.init_worker.__func__,</font>
<font color="red"> 314.             initargs=[counter])</font>
<font color="black"> 315.         args = [</font>
<font color="red"> 316.             (index, subsuite, self.failfast)</font>
<font color="red"> 317.             for index, subsuite in enumerate(self.subsuites)</font>
<font color="black"> 318.         ]</font>
<font color="red"> 319.         test_results = pool.imap_unordered(self.run_subsuite.__func__, args)</font>
<font color="black"> 320. </font>
<font color="red"> 321.         while True:</font>
<font color="red"> 322.             if result.shouldStop:</font>
<font color="red"> 323.                 pool.terminate()</font>
<font color="red"> 324.                 break</font>
<font color="black"> 325. </font>
<font color="red"> 326.             try:</font>
<font color="red"> 327.                 subsuite_index, events = test_results.next(timeout=0.1)</font>
<font color="red"> 328.             except multiprocessing.TimeoutError:</font>
<font color="red"> 329.                 continue</font>
<font color="red"> 330.             except StopIteration:</font>
<font color="red"> 331.                 pool.close()</font>
<font color="red"> 332.                 break</font>
<font color="black"> 333. </font>
<font color="red"> 334.             tests = list(self.subsuites[subsuite_index])</font>
<font color="red"> 335.             for event in events:</font>
<font color="red"> 336.                 event_name = event[0]</font>
<font color="red"> 337.                 handler = getattr(result, event_name, None)</font>
<font color="red"> 338.                 if handler is None:</font>
<font color="red"> 339.                     continue</font>
<font color="red"> 340.                 test = tests[event[1]]</font>
<font color="red"> 341.                 args = event[2:]</font>
<font color="red"> 342.                 handler(test, *args)</font>
<font color="black"> 343. </font>
<font color="red"> 344.         pool.join()</font>
<font color="black"> 345. </font>
<font color="red"> 346.         return result</font>
<font color="black"> 347. </font>
<font color="black"> 348. </font>
<font color="green"> 349. class DiscoverRunner(object):</font>
<font color="black"> 350.     &quot;&quot;&quot;</font>
<font color="black"> 351.     A Django test runner that uses unittest2 test discovery.</font>
<font color="green"> 352.     &quot;&quot;&quot;</font>
<font color="black"> 353. </font>
<font color="green"> 354.     test_suite = unittest.TestSuite</font>
<font color="green"> 355.     parallel_test_suite = ParallelTestSuite</font>
<font color="green"> 356.     test_runner = unittest.TextTestRunner</font>
<font color="green"> 357.     test_loader = unittest.defaultTestLoader</font>
<font color="green"> 358.     reorder_by = (TestCase, SimpleTestCase)</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def __init__(self, pattern=None, top_level=None, verbosity=1,</font>
<font color="green"> 361.                  interactive=True, failfast=False, keepdb=False,</font>
<font color="green"> 362.                  reverse=False, debug_sql=False, parallel=0,</font>
<font color="black"> 363.                  **kwargs):</font>
<font color="black"> 364. </font>
<font color="green"> 365.         self.pattern = pattern</font>
<font color="green"> 366.         self.top_level = top_level</font>
<font color="black"> 367. </font>
<font color="green"> 368.         self.verbosity = verbosity</font>
<font color="green"> 369.         self.interactive = interactive</font>
<font color="green"> 370.         self.failfast = failfast</font>
<font color="green"> 371.         self.keepdb = keepdb</font>
<font color="green"> 372.         self.reverse = reverse</font>
<font color="green"> 373.         self.debug_sql = debug_sql</font>
<font color="green"> 374.         self.parallel = parallel</font>
<font color="black"> 375. </font>
<font color="green"> 376.     @classmethod</font>
<font color="black"> 377.     def add_arguments(cls, parser):</font>
<font color="green"> 378.         parser.add_argument('-t', '--top-level-directory',</font>
<font color="green"> 379.             action='store', dest='top_level', default=None,</font>
<font color="green"> 380.             help='Top level of project for unittest discovery.')</font>
<font color="green"> 381.         parser.add_argument('-p', '--pattern', action='store', dest='pattern',</font>
<font color="green"> 382.             default=&quot;test*.py&quot;,</font>
<font color="green"> 383.             help='The test matching pattern. Defaults to test*.py.')</font>
<font color="green"> 384.         parser.add_argument('-k', '--keepdb', action='store_true', dest='keepdb',</font>
<font color="green"> 385.             default=False,</font>
<font color="green"> 386.             help='Preserves the test DB between runs.')</font>
<font color="green"> 387.         parser.add_argument('-r', '--reverse', action='store_true', dest='reverse',</font>
<font color="green"> 388.             default=False,</font>
<font color="green"> 389.             help='Reverses test cases order.')</font>
<font color="green"> 390.         parser.add_argument('-d', '--debug-sql', action='store_true', dest='debug_sql',</font>
<font color="green"> 391.             default=False,</font>
<font color="green"> 392.             help='Prints logged SQL queries on failure.')</font>
<font color="green"> 393.         parser.add_argument(</font>
<font color="green"> 394.             '--parallel', dest='parallel', nargs='?', default=1, type=int,</font>
<font color="green"> 395.             const=default_test_processes(), metavar='N',</font>
<font color="green"> 396.             help='Run tests using up to N parallel processes.')</font>
<font color="black"> 397. </font>
<font color="green"> 398.     def setup_test_environment(self, **kwargs):</font>
<font color="green"> 399.         setup_test_environment()</font>
<font color="green"> 400.         settings.DEBUG = False</font>
<font color="green"> 401.         unittest.installHandler()</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def build_suite(self, test_labels=None, extra_tests=None, **kwargs):</font>
<font color="green"> 404.         suite = self.test_suite()</font>
<font color="green"> 405.         test_labels = test_labels or ['.']</font>
<font color="green"> 406.         extra_tests = extra_tests or []</font>
<font color="black"> 407. </font>
<font color="green"> 408.         discover_kwargs = {}</font>
<font color="green"> 409.         if self.pattern is not None:</font>
<font color="green"> 410.             discover_kwargs['pattern'] = self.pattern</font>
<font color="green"> 411.         if self.top_level is not None:</font>
<font color="red"> 412.             discover_kwargs['top_level_dir'] = self.top_level</font>
<font color="black"> 413. </font>
<font color="green"> 414.         for label in test_labels:</font>
<font color="green"> 415.             kwargs = discover_kwargs.copy()</font>
<font color="green"> 416.             tests = None</font>
<font color="black"> 417. </font>
<font color="green"> 418.             label_as_path = os.path.abspath(label)</font>
<font color="black"> 419. </font>
<font color="black"> 420.             # if a module, or &quot;module.ClassName[.method_name]&quot;, just run those</font>
<font color="green"> 421.             if not os.path.exists(label_as_path):</font>
<font color="red"> 422.                 tests = self.test_loader.loadTestsFromName(label)</font>
<font color="green"> 423.             elif os.path.isdir(label_as_path) and not self.top_level:</font>
<font color="black"> 424.                 # Try to be a bit smarter than unittest about finding the</font>
<font color="black"> 425.                 # default top-level for a given directory path, to avoid</font>
<font color="black"> 426.                 # breaking relative imports. (Unittest's default is to set</font>
<font color="black"> 427.                 # top-level equal to the path, which means relative imports</font>
<font color="black"> 428.                 # will result in &quot;Attempted relative import in non-package.&quot;).</font>
<font color="black"> 429. </font>
<font color="black"> 430.                 # We'd be happy to skip this and require dotted module paths</font>
<font color="black"> 431.                 # (which don't cause this problem) instead of file paths (which</font>
<font color="black"> 432.                 # do), but in the case of a directory in the cwd, which would</font>
<font color="black"> 433.                 # be equally valid if considered as a top-level module or as a</font>
<font color="black"> 434.                 # directory path, unittest unfortunately prefers the latter.</font>
<font color="black"> 435. </font>
<font color="green"> 436.                 top_level = label_as_path</font>
<font color="green"> 437.                 while True:</font>
<font color="green"> 438.                     init_py = os.path.join(top_level, '__init__.py')</font>
<font color="green"> 439.                     if os.path.exists(init_py):</font>
<font color="red"> 440.                         try_next = os.path.dirname(top_level)</font>
<font color="red"> 441.                         if try_next == top_level:</font>
<font color="black"> 442.                             # __init__.py all the way down? give up.</font>
<font color="red"> 443.                             break</font>
<font color="red"> 444.                         top_level = try_next</font>
<font color="red"> 445.                         continue</font>
<font color="green"> 446.                     break</font>
<font color="green"> 447.                 kwargs['top_level_dir'] = top_level</font>
<font color="black"> 448. </font>
<font color="green"> 449.             if not (tests and tests.countTestCases()) and is_discoverable(label):</font>
<font color="black"> 450.                 # Try discovery if path is a package or directory</font>
<font color="green"> 451.                 tests = self.test_loader.discover(start_dir=label, **kwargs)</font>
<font color="black"> 452. </font>
<font color="black"> 453.                 # Make unittest forget the top-level dir it calculated from this</font>
<font color="black"> 454.                 # run, to support running tests from two different top-levels.</font>
<font color="green"> 455.                 self.test_loader._top_level_dir = None</font>
<font color="black"> 456. </font>
<font color="green"> 457.             suite.addTests(tests)</font>
<font color="black"> 458. </font>
<font color="green"> 459.         for test in extra_tests:</font>
<font color="red"> 460.             suite.addTest(test)</font>
<font color="black"> 461. </font>
<font color="green"> 462.         suite = reorder_suite(suite, self.reorder_by, self.reverse)</font>
<font color="black"> 463. </font>
<font color="green"> 464.         if self.parallel &gt; 1:</font>
<font color="red"> 465.             parallel_suite = self.parallel_test_suite(suite, self.parallel, self.failfast)</font>
<font color="black"> 466. </font>
<font color="black"> 467.             # Since tests are distributed across processes on a per-TestCase</font>
<font color="black"> 468.             # basis, there's no need for more processes than TestCases.</font>
<font color="red"> 469.             parallel_units = len(parallel_suite.subsuites)</font>
<font color="red"> 470.             if self.parallel &gt; parallel_units:</font>
<font color="red"> 471.                 self.parallel = parallel_units</font>
<font color="black"> 472. </font>
<font color="black"> 473.             # If there's only one TestCase, parallelization isn't needed.</font>
<font color="red"> 474.             if self.parallel &gt; 1:</font>
<font color="red"> 475.                 suite = parallel_suite</font>
<font color="black"> 476. </font>
<font color="green"> 477.         return suite</font>
<font color="black"> 478. </font>
<font color="green"> 479.     def setup_databases(self, **kwargs):</font>
<font color="green"> 480.         return setup_databases(</font>
<font color="green"> 481.             self.verbosity, self.interactive, self.keepdb, self.debug_sql,</font>
<font color="green"> 482.             self.parallel, **kwargs</font>
<font color="black"> 483.         )</font>
<font color="black"> 484. </font>
<font color="green"> 485.     def get_resultclass(self):</font>
<font color="green"> 486.         return DebugSQLTextTestResult if self.debug_sql else None</font>
<font color="black"> 487. </font>
<font color="green"> 488.     def run_suite(self, suite, **kwargs):</font>
<font color="green"> 489.         resultclass = self.get_resultclass()</font>
<font color="green"> 490.         return self.test_runner(</font>
<font color="green"> 491.             verbosity=self.verbosity,</font>
<font color="green"> 492.             failfast=self.failfast,</font>
<font color="green"> 493.             resultclass=resultclass,</font>
<font color="green"> 494.         ).run(suite)</font>
<font color="black"> 495. </font>
<font color="green"> 496.     def teardown_databases(self, old_config, **kwargs):</font>
<font color="black"> 497.         &quot;&quot;&quot;</font>
<font color="black"> 498.         Destroys all the non-mirror databases.</font>
<font color="black"> 499.         &quot;&quot;&quot;</font>
<font color="green"> 500.         for connection, old_name, destroy in old_config:</font>
<font color="green"> 501.             if destroy:</font>
<font color="green"> 502.                 if self.parallel &gt; 1:</font>
<font color="red"> 503.                     for index in range(self.parallel):</font>
<font color="red"> 504.                         connection.creation.destroy_test_db(</font>
<font color="red"> 505.                             number=index + 1,</font>
<font color="red"> 506.                             verbosity=self.verbosity,</font>
<font color="red"> 507.                             keepdb=self.keepdb,</font>
<font color="black"> 508.                         )</font>
<font color="green"> 509.                 connection.creation.destroy_test_db(old_name, self.verbosity, self.keepdb)</font>
<font color="black"> 510. </font>
<font color="green"> 511.     def teardown_test_environment(self, **kwargs):</font>
<font color="green"> 512.         unittest.removeHandler()</font>
<font color="green"> 513.         teardown_test_environment()</font>
<font color="black"> 514. </font>
<font color="green"> 515.     def suite_result(self, suite, result, **kwargs):</font>
<font color="green"> 516.         return len(result.failures) + len(result.errors)</font>
<font color="black"> 517. </font>
<font color="green"> 518.     def run_tests(self, test_labels, extra_tests=None, **kwargs):</font>
<font color="black"> 519.         &quot;&quot;&quot;</font>
<font color="black"> 520.         Run the unit tests for all the test labels in the provided list.</font>
<font color="black"> 521. </font>
<font color="black"> 522.         Test labels should be dotted Python paths to test modules, test</font>
<font color="black"> 523.         classes, or test methods.</font>
<font color="black"> 524. </font>
<font color="black"> 525.         A list of 'extra' tests may also be provided; these tests</font>
<font color="black"> 526.         will be added to the test suite.</font>
<font color="black"> 527. </font>
<font color="black"> 528.         Returns the number of tests that failed.</font>
<font color="black"> 529.         &quot;&quot;&quot;</font>
<font color="green"> 530.         self.setup_test_environment()</font>
<font color="green"> 531.         suite = self.build_suite(test_labels, extra_tests)</font>
<font color="green"> 532.         old_config = self.setup_databases()</font>
<font color="green"> 533.         result = self.run_suite(suite)</font>
<font color="green"> 534.         self.teardown_databases(old_config)</font>
<font color="green"> 535.         self.teardown_test_environment()</font>
<font color="green"> 536.         return self.suite_result(suite, result)</font>
<font color="black"> 537. </font>
<font color="black"> 538. </font>
<font color="green"> 539. def is_discoverable(label):</font>
<font color="black"> 540.     &quot;&quot;&quot;</font>
<font color="black"> 541.     Check if a test label points to a python package or file directory.</font>
<font color="black"> 542. </font>
<font color="black"> 543.     Relative labels like &quot;.&quot; and &quot;..&quot; are seen as directories.</font>
<font color="black"> 544.     &quot;&quot;&quot;</font>
<font color="green"> 545.     try:</font>
<font color="green"> 546.         mod = import_module(label)</font>
<font color="green"> 547.     except (ImportError, TypeError):</font>
<font color="green"> 548.         pass</font>
<font color="black"> 549.     else:</font>
<font color="red"> 550.         return hasattr(mod, '__path__')</font>
<font color="black"> 551. </font>
<font color="green"> 552.     return os.path.isdir(os.path.abspath(label))</font>
<font color="black"> 553. </font>
<font color="black"> 554. </font>
<font color="green"> 555. def dependency_ordered(test_databases, dependencies):</font>
<font color="black"> 556.     &quot;&quot;&quot;</font>
<font color="black"> 557.     Reorder test_databases into an order that honors the dependencies</font>
<font color="black"> 558.     described in TEST[DEPENDENCIES].</font>
<font color="black"> 559.     &quot;&quot;&quot;</font>
<font color="green"> 560.     ordered_test_databases = []</font>
<font color="green"> 561.     resolved_databases = set()</font>
<font color="black"> 562. </font>
<font color="black"> 563.     # Maps db signature to dependencies of all it's aliases</font>
<font color="green"> 564.     dependencies_map = {}</font>
<font color="black"> 565. </font>
<font color="black"> 566.     # sanity check - no DB can depend on its own alias</font>
<font color="green"> 567.     for sig, (_, aliases) in test_databases:</font>
<font color="green"> 568.         all_deps = set()</font>
<font color="green"> 569.         for alias in aliases:</font>
<font color="green"> 570.             all_deps.update(dependencies.get(alias, []))</font>
<font color="green"> 571.         if not all_deps.isdisjoint(aliases):</font>
<font color="red"> 572.             raise ImproperlyConfigured(</font>
<font color="red"> 573.                 &quot;Circular dependency: databases %r depend on each other, &quot;</font>
<font color="red"> 574.                 &quot;but are aliases.&quot; % aliases)</font>
<font color="green"> 575.         dependencies_map[sig] = all_deps</font>
<font color="black"> 576. </font>
<font color="green"> 577.     while test_databases:</font>
<font color="green"> 578.         changed = False</font>
<font color="green"> 579.         deferred = []</font>
<font color="black"> 580. </font>
<font color="black"> 581.         # Try to find a DB that has all it's dependencies met</font>
<font color="green"> 582.         for signature, (db_name, aliases) in test_databases:</font>
<font color="green"> 583.             if dependencies_map[signature].issubset(resolved_databases):</font>
<font color="green"> 584.                 resolved_databases.update(aliases)</font>
<font color="green"> 585.                 ordered_test_databases.append((signature, (db_name, aliases)))</font>
<font color="green"> 586.                 changed = True</font>
<font color="black"> 587.             else:</font>
<font color="red"> 588.                 deferred.append((signature, (db_name, aliases)))</font>
<font color="black"> 589. </font>
<font color="green"> 590.         if not changed:</font>
<font color="red"> 591.             raise ImproperlyConfigured(</font>
<font color="red"> 592.                 &quot;Circular dependency in TEST[DEPENDENCIES]&quot;)</font>
<font color="green"> 593.         test_databases = deferred</font>
<font color="green"> 594.     return ordered_test_databases</font>
<font color="black"> 595. </font>
<font color="black"> 596. </font>
<font color="green"> 597. def reorder_suite(suite, classes, reverse=False):</font>
<font color="black"> 598.     &quot;&quot;&quot;</font>
<font color="black"> 599.     Reorders a test suite by test type.</font>
<font color="black"> 600. </font>
<font color="black"> 601.     `classes` is a sequence of types</font>
<font color="black"> 602. </font>
<font color="black"> 603.     All tests of type classes[0] are placed first, then tests of type</font>
<font color="black"> 604.     classes[1], etc. Tests with no match in classes are placed last.</font>
<font color="black"> 605. </font>
<font color="black"> 606.     If `reverse` is True, tests within classes are sorted in opposite order,</font>
<font color="black"> 607.     but test classes are not reversed.</font>
<font color="black"> 608.     &quot;&quot;&quot;</font>
<font color="green"> 609.     class_count = len(classes)</font>
<font color="green"> 610.     suite_class = type(suite)</font>
<font color="green"> 611.     bins = [OrderedSet() for i in range(class_count + 1)]</font>
<font color="green"> 612.     partition_suite_by_type(suite, classes, bins, reverse=reverse)</font>
<font color="green"> 613.     reordered_suite = suite_class()</font>
<font color="green"> 614.     for i in range(class_count + 1):</font>
<font color="green"> 615.         reordered_suite.addTests(bins[i])</font>
<font color="green"> 616.     return reordered_suite</font>
<font color="black"> 617. </font>
<font color="black"> 618. </font>
<font color="green"> 619. def partition_suite_by_type(suite, classes, bins, reverse=False):</font>
<font color="black"> 620.     &quot;&quot;&quot;</font>
<font color="black"> 621.     Partitions a test suite by test type. Also prevents duplicated tests.</font>
<font color="black"> 622. </font>
<font color="black"> 623.     classes is a sequence of types</font>
<font color="black"> 624.     bins is a sequence of TestSuites, one more than classes</font>
<font color="black"> 625.     reverse changes the ordering of tests within bins</font>
<font color="black"> 626. </font>
<font color="black"> 627.     Tests of type classes[i] are added to bins[i],</font>
<font color="black"> 628.     tests with no match found in classes are place in bins[-1]</font>
<font color="black"> 629.     &quot;&quot;&quot;</font>
<font color="green"> 630.     suite_class = type(suite)</font>
<font color="green"> 631.     if reverse:</font>
<font color="red"> 632.         suite = reversed(tuple(suite))</font>
<font color="green"> 633.     for test in suite:</font>
<font color="green"> 634.         if isinstance(test, suite_class):</font>
<font color="green"> 635.             partition_suite_by_type(test, classes, bins, reverse=reverse)</font>
<font color="black"> 636.         else:</font>
<font color="green"> 637.             for i in range(len(classes)):</font>
<font color="green"> 638.                 if isinstance(test, classes[i]):</font>
<font color="green"> 639.                     bins[i].add(test)</font>
<font color="green"> 640.                     break</font>
<font color="black"> 641.             else:</font>
<font color="red"> 642.                 bins[-1].add(test)</font>
<font color="black"> 643. </font>
<font color="black"> 644. </font>
<font color="green"> 645. def partition_suite_by_case(suite):</font>
<font color="black"> 646.     &quot;&quot;&quot;</font>
<font color="black"> 647.     Partitions a test suite by test case, preserving the order of tests.</font>
<font color="black"> 648.     &quot;&quot;&quot;</font>
<font color="red"> 649.     groups = []</font>
<font color="red"> 650.     suite_class = type(suite)</font>
<font color="red"> 651.     for test_type, test_group in itertools.groupby(suite, type):</font>
<font color="red"> 652.         if issubclass(test_type, unittest.TestCase):</font>
<font color="red"> 653.             groups.append(suite_class(test_group))</font>
<font color="black"> 654.         else:</font>
<font color="red"> 655.             for item in test_group:</font>
<font color="red"> 656.                 groups.extend(partition_suite_by_case(item))</font>
<font color="red"> 657.     return groups</font>
<font color="black"> 658. </font>
<font color="black"> 659. </font>
<font color="green"> 660. def get_unique_databases_and_mirrors():</font>
<font color="black"> 661.     &quot;&quot;&quot;</font>
<font color="black"> 662.     Figure out which databases actually need to be created.</font>
<font color="black"> 663. </font>
<font color="black"> 664.     Deduplicate entries in DATABASES that correspond the same database or are</font>
<font color="black"> 665.     configured as test mirrors.</font>
<font color="black"> 666. </font>
<font color="black"> 667.     Return two values:</font>
<font color="black"> 668.     - test_databases: ordered mapping of signatures to (name, list of aliases)</font>
<font color="black"> 669.                       where all aliases share the same underlying database.</font>
<font color="black"> 670.     - mirrored_aliases: mapping of mirror aliases to original aliases.</font>
<font color="black"> 671.     &quot;&quot;&quot;</font>
<font color="green"> 672.     mirrored_aliases = {}</font>
<font color="green"> 673.     test_databases = {}</font>
<font color="green"> 674.     dependencies = {}</font>
<font color="green"> 675.     default_sig = connections[DEFAULT_DB_ALIAS].creation.test_db_signature()</font>
<font color="black"> 676. </font>
<font color="green"> 677.     for alias in connections:</font>
<font color="green"> 678.         connection = connections[alias]</font>
<font color="green"> 679.         test_settings = connection.settings_dict['TEST']</font>
<font color="black"> 680. </font>
<font color="green"> 681.         if test_settings['MIRROR']:</font>
<font color="black"> 682.             # If the database is marked as a test mirror, save the alias.</font>
<font color="red"> 683.             mirrored_aliases[alias] = test_settings['MIRROR']</font>
<font color="black"> 684.         else:</font>
<font color="black"> 685.             # Store a tuple with DB parameters that uniquely identify it.</font>
<font color="black"> 686.             # If we have two aliases with the same values for that tuple,</font>
<font color="black"> 687.             # we only need to create the test database once.</font>
<font color="green"> 688.             item = test_databases.setdefault(</font>
<font color="green"> 689.                 connection.creation.test_db_signature(),</font>
<font color="green"> 690.                 (connection.settings_dict['NAME'], set())</font>
<font color="black"> 691.             )</font>
<font color="green"> 692.             item[1].add(alias)</font>
<font color="black"> 693. </font>
<font color="green"> 694.             if 'DEPENDENCIES' in test_settings:</font>
<font color="red"> 695.                 dependencies[alias] = test_settings['DEPENDENCIES']</font>
<font color="black"> 696.             else:</font>
<font color="green"> 697.                 if alias != DEFAULT_DB_ALIAS and connection.creation.test_db_signature() != default_sig:</font>
<font color="red"> 698.                     dependencies[alias] = test_settings.get('DEPENDENCIES', [DEFAULT_DB_ALIAS])</font>
<font color="black"> 699. </font>
<font color="green"> 700.     test_databases = dependency_ordered(test_databases.items(), dependencies)</font>
<font color="green"> 701.     test_databases = collections.OrderedDict(test_databases)</font>
<font color="green"> 702.     return test_databases, mirrored_aliases</font>
<font color="black"> 703. </font>
<font color="black"> 704. </font>
<font color="green"> 705. def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, **kwargs):</font>
<font color="black"> 706.     &quot;&quot;&quot;</font>
<font color="black"> 707.     Creates the test databases.</font>
<font color="black"> 708.     &quot;&quot;&quot;</font>
<font color="green"> 709.     test_databases, mirrored_aliases = get_unique_databases_and_mirrors()</font>
<font color="black"> 710. </font>
<font color="green"> 711.     old_names = []</font>
<font color="black"> 712. </font>
<font color="green"> 713.     for signature, (db_name, aliases) in test_databases.items():</font>
<font color="green"> 714.         first_alias = None</font>
<font color="green"> 715.         for alias in aliases:</font>
<font color="green"> 716.             connection = connections[alias]</font>
<font color="green"> 717.             old_names.append((connection, db_name, first_alias is None))</font>
<font color="black"> 718. </font>
<font color="black"> 719.             # Actually create the database for the first connection</font>
<font color="green"> 720.             if first_alias is None:</font>
<font color="green"> 721.                 first_alias = alias</font>
<font color="green"> 722.                 connection.creation.create_test_db(</font>
<font color="green"> 723.                     verbosity=verbosity,</font>
<font color="green"> 724.                     autoclobber=not interactive,</font>
<font color="green"> 725.                     keepdb=keepdb,</font>
<font color="green"> 726.                     serialize=connection.settings_dict.get(&quot;TEST&quot;, {}).get(&quot;SERIALIZE&quot;, True),</font>
<font color="black"> 727.                 )</font>
<font color="green"> 728.                 if parallel &gt; 1:</font>
<font color="red"> 729.                     for index in range(parallel):</font>
<font color="red"> 730.                         connection.creation.clone_test_db(</font>
<font color="red"> 731.                             number=index + 1,</font>
<font color="red"> 732.                             verbosity=verbosity,</font>
<font color="red"> 733.                             keepdb=keepdb,</font>
<font color="black"> 734.                         )</font>
<font color="black"> 735.             # Configure all other connections as mirrors of the first one</font>
<font color="black"> 736.             else:</font>
<font color="red"> 737.                 connections[alias].creation.set_as_test_mirror(</font>
<font color="red"> 738.                     connections[first_alias].settings_dict)</font>
<font color="black"> 739. </font>
<font color="black"> 740.     # Configure the test mirrors.</font>
<font color="green"> 741.     for alias, mirror_alias in mirrored_aliases.items():</font>
<font color="red"> 742.         connections[alias].creation.set_as_test_mirror(</font>
<font color="red"> 743.             connections[mirror_alias].settings_dict)</font>
<font color="black"> 744. </font>
<font color="green"> 745.     if debug_sql:</font>
<font color="red"> 746.         for alias in connections:</font>
<font color="red"> 747.             connections[alias].force_debug_cursor = True</font>
<font color="black"> 748. </font>
<font color="green"> 749.     return old_names</font>
</pre>

