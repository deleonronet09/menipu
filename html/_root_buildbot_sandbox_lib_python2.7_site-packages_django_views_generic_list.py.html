source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/views/generic/list.py</b><br>


file stats: <b>123 lines, 38 executed: 30.9% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. from django.core.exceptions import ImproperlyConfigured</font>
<font color="green">   4. from django.core.paginator import InvalidPage, Paginator</font>
<font color="green">   5. from django.db.models.query import QuerySet</font>
<font color="green">   6. from django.http import Http404</font>
<font color="green">   7. from django.utils import six</font>
<font color="green">   8. from django.utils.translation import ugettext as _</font>
<font color="green">   9. from django.views.generic.base import ContextMixin, TemplateResponseMixin, View</font>
<font color="black">  10. </font>
<font color="black">  11. </font>
<font color="green">  12. class MultipleObjectMixin(ContextMixin):</font>
<font color="black">  13.     &quot;&quot;&quot;</font>
<font color="black">  14.     A mixin for views manipulating multiple objects.</font>
<font color="green">  15.     &quot;&quot;&quot;</font>
<font color="green">  16.     allow_empty = True</font>
<font color="green">  17.     queryset = None</font>
<font color="green">  18.     model = None</font>
<font color="green">  19.     paginate_by = None</font>
<font color="green">  20.     paginate_orphans = 0</font>
<font color="green">  21.     context_object_name = None</font>
<font color="green">  22.     paginator_class = Paginator</font>
<font color="green">  23.     page_kwarg = 'page'</font>
<font color="green">  24.     ordering = None</font>
<font color="black">  25. </font>
<font color="green">  26.     def get_queryset(self):</font>
<font color="black">  27.         &quot;&quot;&quot;</font>
<font color="black">  28.         Return the list of items for this view.</font>
<font color="black">  29. </font>
<font color="black">  30.         The return value must be an iterable and may be an instance of</font>
<font color="black">  31.         `QuerySet` in which case `QuerySet` specific behavior will be enabled.</font>
<font color="black">  32.         &quot;&quot;&quot;</font>
<font color="red">  33.         if self.queryset is not None:</font>
<font color="red">  34.             queryset = self.queryset</font>
<font color="red">  35.             if isinstance(queryset, QuerySet):</font>
<font color="red">  36.                 queryset = queryset.all()</font>
<font color="red">  37.         elif self.model is not None:</font>
<font color="red">  38.             queryset = self.model._default_manager.all()</font>
<font color="black">  39.         else:</font>
<font color="red">  40.             raise ImproperlyConfigured(</font>
<font color="red">  41.                 &quot;%(cls)s is missing a QuerySet. Define &quot;</font>
<font color="black">  42.                 &quot;%(cls)s.model, %(cls)s.queryset, or override &quot;</font>
<font color="red">  43.                 &quot;%(cls)s.get_queryset().&quot; % {</font>
<font color="red">  44.                     'cls': self.__class__.__name__</font>
<font color="black">  45.                 }</font>
<font color="black">  46.             )</font>
<font color="red">  47.         ordering = self.get_ordering()</font>
<font color="red">  48.         if ordering:</font>
<font color="red">  49.             if isinstance(ordering, six.string_types):</font>
<font color="red">  50.                 ordering = (ordering,)</font>
<font color="red">  51.             queryset = queryset.order_by(*ordering)</font>
<font color="black">  52. </font>
<font color="red">  53.         return queryset</font>
<font color="black">  54. </font>
<font color="green">  55.     def get_ordering(self):</font>
<font color="black">  56.         &quot;&quot;&quot;</font>
<font color="black">  57.         Return the field or fields to use for ordering the queryset.</font>
<font color="black">  58.         &quot;&quot;&quot;</font>
<font color="red">  59.         return self.ordering</font>
<font color="black">  60. </font>
<font color="green">  61.     def paginate_queryset(self, queryset, page_size):</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="black">  63.         Paginate the queryset, if needed.</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="red">  65.         paginator = self.get_paginator(</font>
<font color="red">  66.             queryset, page_size, orphans=self.get_paginate_orphans(),</font>
<font color="red">  67.             allow_empty_first_page=self.get_allow_empty())</font>
<font color="red">  68.         page_kwarg = self.page_kwarg</font>
<font color="red">  69.         page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1</font>
<font color="red">  70.         try:</font>
<font color="red">  71.             page_number = int(page)</font>
<font color="red">  72.         except ValueError:</font>
<font color="red">  73.             if page == 'last':</font>
<font color="red">  74.                 page_number = paginator.num_pages</font>
<font color="black">  75.             else:</font>
<font color="red">  76.                 raise Http404(_(&quot;Page is not 'last', nor can it be converted to an int.&quot;))</font>
<font color="red">  77.         try:</font>
<font color="red">  78.             page = paginator.page(page_number)</font>
<font color="red">  79.             return (paginator, page, page.object_list, page.has_other_pages())</font>
<font color="red">  80.         except InvalidPage as e:</font>
<font color="red">  81.             raise Http404(_('Invalid page (%(page_number)s): %(message)s') % {</font>
<font color="red">  82.                 'page_number': page_number,</font>
<font color="red">  83.                 'message': str(e)</font>
<font color="black">  84.             })</font>
<font color="black">  85. </font>
<font color="green">  86.     def get_paginate_by(self, queryset):</font>
<font color="black">  87.         &quot;&quot;&quot;</font>
<font color="black">  88.         Get the number of items to paginate by, or ``None`` for no pagination.</font>
<font color="black">  89.         &quot;&quot;&quot;</font>
<font color="red">  90.         return self.paginate_by</font>
<font color="black">  91. </font>
<font color="green">  92.     def get_paginator(self, queryset, per_page, orphans=0,</font>
<font color="green">  93.                       allow_empty_first_page=True, **kwargs):</font>
<font color="black">  94.         &quot;&quot;&quot;</font>
<font color="black">  95.         Return an instance of the paginator for this view.</font>
<font color="black">  96.         &quot;&quot;&quot;</font>
<font color="red">  97.         return self.paginator_class(</font>
<font color="red">  98.             queryset, per_page, orphans=orphans,</font>
<font color="red">  99.             allow_empty_first_page=allow_empty_first_page, **kwargs)</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def get_paginate_orphans(self):</font>
<font color="black"> 102.         &quot;&quot;&quot;</font>
<font color="black"> 103.         Returns the maximum number of orphans extend the last page by when</font>
<font color="black"> 104.         paginating.</font>
<font color="black"> 105.         &quot;&quot;&quot;</font>
<font color="red"> 106.         return self.paginate_orphans</font>
<font color="black"> 107. </font>
<font color="green"> 108.     def get_allow_empty(self):</font>
<font color="black"> 109.         &quot;&quot;&quot;</font>
<font color="black"> 110.         Returns ``True`` if the view should display empty lists, and ``False``</font>
<font color="black"> 111.         if a 404 should be raised instead.</font>
<font color="black"> 112.         &quot;&quot;&quot;</font>
<font color="red"> 113.         return self.allow_empty</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def get_context_object_name(self, object_list):</font>
<font color="black"> 116.         &quot;&quot;&quot;</font>
<font color="black"> 117.         Get the name of the item to be used in the context.</font>
<font color="black"> 118.         &quot;&quot;&quot;</font>
<font color="red"> 119.         if self.context_object_name:</font>
<font color="red"> 120.             return self.context_object_name</font>
<font color="red"> 121.         elif hasattr(object_list, 'model'):</font>
<font color="red"> 122.             return '%s_list' % object_list.model._meta.model_name</font>
<font color="black"> 123.         else:</font>
<font color="red"> 124.             return None</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def get_context_data(self, **kwargs):</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         Get the context for this view.</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="red"> 130.         queryset = kwargs.pop('object_list', self.object_list)</font>
<font color="red"> 131.         page_size = self.get_paginate_by(queryset)</font>
<font color="red"> 132.         context_object_name = self.get_context_object_name(queryset)</font>
<font color="red"> 133.         if page_size:</font>
<font color="red"> 134.             paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)</font>
<font color="red"> 135.             context = {</font>
<font color="red"> 136.                 'paginator': paginator,</font>
<font color="red"> 137.                 'page_obj': page,</font>
<font color="red"> 138.                 'is_paginated': is_paginated,</font>
<font color="red"> 139.                 'object_list': queryset</font>
<font color="black"> 140.             }</font>
<font color="black"> 141.         else:</font>
<font color="red"> 142.             context = {</font>
<font color="red"> 143.                 'paginator': None,</font>
<font color="red"> 144.                 'page_obj': None,</font>
<font color="red"> 145.                 'is_paginated': False,</font>
<font color="red"> 146.                 'object_list': queryset</font>
<font color="black"> 147.             }</font>
<font color="red"> 148.         if context_object_name is not None:</font>
<font color="red"> 149.             context[context_object_name] = queryset</font>
<font color="red"> 150.         context.update(kwargs)</font>
<font color="red"> 151.         return super(MultipleObjectMixin, self).get_context_data(**context)</font>
<font color="black"> 152. </font>
<font color="black"> 153. </font>
<font color="green"> 154. class BaseListView(MultipleObjectMixin, View):</font>
<font color="black"> 155.     &quot;&quot;&quot;</font>
<font color="black"> 156.     A base view for displaying a list of objects.</font>
<font color="green"> 157.     &quot;&quot;&quot;</font>
<font color="green"> 158.     def get(self, request, *args, **kwargs):</font>
<font color="red"> 159.         self.object_list = self.get_queryset()</font>
<font color="red"> 160.         allow_empty = self.get_allow_empty()</font>
<font color="black"> 161. </font>
<font color="red"> 162.         if not allow_empty:</font>
<font color="black"> 163.             # When pagination is enabled and object_list is a queryset,</font>
<font color="black"> 164.             # it's better to do a cheap query than to load the unpaginated</font>
<font color="black"> 165.             # queryset in memory.</font>
<font color="red"> 166.             if (self.get_paginate_by(self.object_list) is not None</font>
<font color="red"> 167.                     and hasattr(self.object_list, 'exists')):</font>
<font color="red"> 168.                 is_empty = not self.object_list.exists()</font>
<font color="black"> 169.             else:</font>
<font color="red"> 170.                 is_empty = len(self.object_list) == 0</font>
<font color="red"> 171.             if is_empty:</font>
<font color="red"> 172.                 raise Http404(_(&quot;Empty list and '%(class_name)s.allow_empty' is False.&quot;)</font>
<font color="red"> 173.                         % {'class_name': self.__class__.__name__})</font>
<font color="red"> 174.         context = self.get_context_data()</font>
<font color="red"> 175.         return self.render_to_response(context)</font>
<font color="black"> 176. </font>
<font color="black"> 177. </font>
<font color="green"> 178. class MultipleObjectTemplateResponseMixin(TemplateResponseMixin):</font>
<font color="black"> 179.     &quot;&quot;&quot;</font>
<font color="black"> 180.     Mixin for responding with a template and list of objects.</font>
<font color="green"> 181.     &quot;&quot;&quot;</font>
<font color="green"> 182.     template_name_suffix = '_list'</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def get_template_names(self):</font>
<font color="black"> 185.         &quot;&quot;&quot;</font>
<font color="black"> 186.         Return a list of template names to be used for the request. Must return</font>
<font color="black"> 187.         a list. May not be called if render_to_response is overridden.</font>
<font color="black"> 188.         &quot;&quot;&quot;</font>
<font color="red"> 189.         try:</font>
<font color="red"> 190.             names = super(MultipleObjectTemplateResponseMixin, self).get_template_names()</font>
<font color="red"> 191.         except ImproperlyConfigured:</font>
<font color="black"> 192.             # If template_name isn't specified, it's not a problem --</font>
<font color="black"> 193.             # we just start with an empty list.</font>
<font color="red"> 194.             names = []</font>
<font color="black"> 195. </font>
<font color="black"> 196.         # If the list is a queryset, we'll invent a template name based on the</font>
<font color="black"> 197.         # app and model name. This name gets put at the end of the template</font>
<font color="black"> 198.         # name list so that user-supplied names override the automatically-</font>
<font color="black"> 199.         # generated ones.</font>
<font color="red"> 200.         if hasattr(self.object_list, 'model'):</font>
<font color="red"> 201.             opts = self.object_list.model._meta</font>
<font color="red"> 202.             names.append(&quot;%s/%s%s.html&quot; % (opts.app_label, opts.model_name, self.template_name_suffix))</font>
<font color="black"> 203. </font>
<font color="red"> 204.         return names</font>
<font color="black"> 205. </font>
<font color="black"> 206. </font>
<font color="green"> 207. class ListView(MultipleObjectTemplateResponseMixin, BaseListView):</font>
<font color="black"> 208.     &quot;&quot;&quot;</font>
<font color="black"> 209.     Render some list of objects, set by `self.model` or `self.queryset`.</font>
<font color="black"> 210.     `self.queryset` can actually be any iterable of items, not just a queryset.</font>
<font color="green"> 211.     &quot;&quot;&quot;</font>
</pre>

