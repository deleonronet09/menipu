source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/migrations/executor.py</b><br>


file stats: <b>178 lines, 76 executed: 42.7% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. from django.apps.registry import apps as global_apps</font>
<font color="green">   4. from django.db import migrations</font>
<font color="black">   5. </font>
<font color="green">   6. from .exceptions import InvalidMigrationPlan</font>
<font color="green">   7. from .loader import MigrationLoader</font>
<font color="green">   8. from .recorder import MigrationRecorder</font>
<font color="green">   9. from .state import ProjectState</font>
<font color="black">  10. </font>
<font color="black">  11. </font>
<font color="green">  12. class MigrationExecutor(object):</font>
<font color="black">  13.     &quot;&quot;&quot;</font>
<font color="black">  14.     End-to-end migration execution - loads migrations, and runs them</font>
<font color="black">  15.     up or down to a specified set of targets.</font>
<font color="green">  16.     &quot;&quot;&quot;</font>
<font color="black">  17. </font>
<font color="green">  18.     def __init__(self, connection, progress_callback=None):</font>
<font color="green">  19.         self.connection = connection</font>
<font color="green">  20.         self.loader = MigrationLoader(self.connection)</font>
<font color="green">  21.         self.recorder = MigrationRecorder(self.connection)</font>
<font color="green">  22.         self.progress_callback = progress_callback</font>
<font color="black">  23. </font>
<font color="green">  24.     def migration_plan(self, targets, clean_start=False):</font>
<font color="black">  25.         &quot;&quot;&quot;</font>
<font color="black">  26.         Given a set of targets, returns a list of (Migration instance, backwards?).</font>
<font color="black">  27.         &quot;&quot;&quot;</font>
<font color="green">  28.         plan = []</font>
<font color="green">  29.         if clean_start:</font>
<font color="green">  30.             applied = set()</font>
<font color="black">  31.         else:</font>
<font color="green">  32.             applied = set(self.loader.applied_migrations)</font>
<font color="green">  33.         for target in targets:</font>
<font color="black">  34.             # If the target is (app_label, None), that means unmigrate everything</font>
<font color="green">  35.             if target[1] is None:</font>
<font color="red">  36.                 for root in self.loader.graph.root_nodes():</font>
<font color="red">  37.                     if root[0] == target[0]:</font>
<font color="red">  38.                         for migration in self.loader.graph.backwards_plan(root):</font>
<font color="red">  39.                             if migration in applied:</font>
<font color="red">  40.                                 plan.append((self.loader.graph.nodes[migration], True))</font>
<font color="red">  41.                                 applied.remove(migration)</font>
<font color="black">  42.             # If the migration is already applied, do backwards mode,</font>
<font color="black">  43.             # otherwise do forwards mode.</font>
<font color="green">  44.             elif target in applied:</font>
<font color="black">  45.                 # Don't migrate backwards all the way to the target node (that</font>
<font color="black">  46.                 # may roll back dependencies in other apps that don't need to</font>
<font color="black">  47.                 # be rolled back); instead roll back through target's immediate</font>
<font color="black">  48.                 # child(ren) in the same app, and no further.</font>
<font color="green">  49.                 next_in_app = sorted(</font>
<font color="green">  50.                     n for n in</font>
<font color="green">  51.                     self.loader.graph.node_map[target].children</font>
<font color="green">  52.                     if n[0] == target[0]</font>
<font color="black">  53.                 )</font>
<font color="green">  54.                 for node in next_in_app:</font>
<font color="red">  55.                     for migration in self.loader.graph.backwards_plan(node):</font>
<font color="red">  56.                         if migration in applied:</font>
<font color="red">  57.                             plan.append((self.loader.graph.nodes[migration], True))</font>
<font color="red">  58.                             applied.remove(migration)</font>
<font color="black">  59.             else:</font>
<font color="green">  60.                 for migration in self.loader.graph.forwards_plan(target):</font>
<font color="green">  61.                     if migration not in applied:</font>
<font color="green">  62.                         plan.append((self.loader.graph.nodes[migration], False))</font>
<font color="green">  63.                         applied.add(migration)</font>
<font color="green">  64.         return plan</font>
<font color="black">  65. </font>
<font color="green">  66.     def migrate(self, targets, plan=None, fake=False, fake_initial=False):</font>
<font color="black">  67.         &quot;&quot;&quot;</font>
<font color="black">  68.         Migrates the database up to the given targets.</font>
<font color="black">  69. </font>
<font color="black">  70.         Django first needs to create all project states before a migration is</font>
<font color="black">  71.         (un)applied and in a second step run all the database operations.</font>
<font color="black">  72.         &quot;&quot;&quot;</font>
<font color="green">  73.         if plan is None:</font>
<font color="red">  74.             plan = self.migration_plan(targets)</font>
<font color="black">  75.         # Create the forwards plan Django would follow on an empty database</font>
<font color="green">  76.         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)</font>
<font color="black">  77. </font>
<font color="green">  78.         all_forwards = all(not backwards for mig, backwards in plan)</font>
<font color="green">  79.         all_backwards = all(backwards for mig, backwards in plan)</font>
<font color="black">  80. </font>
<font color="green">  81.         if not plan:</font>
<font color="red">  82.             pass  # Nothing to do for an empty plan</font>
<font color="green">  83.         elif all_forwards == all_backwards:</font>
<font color="black">  84.             # This should only happen if there's a mixed plan</font>
<font color="red">  85.             raise InvalidMigrationPlan(</font>
<font color="red">  86.                 &quot;Migration plans with both forwards and backwards migrations &quot;</font>
<font color="black">  87.                 &quot;are not supported. Please split your migration process into &quot;</font>
<font color="black">  88.                 &quot;separate plans of only forwards OR backwards migrations.&quot;,</font>
<font color="red">  89.                 plan</font>
<font color="black">  90.             )</font>
<font color="green">  91.         elif all_forwards:</font>
<font color="green">  92.             self._migrate_all_forwards(plan, full_plan, fake=fake, fake_initial=fake_initial)</font>
<font color="black">  93.         else:</font>
<font color="black">  94.             # No need to check for `elif all_backwards` here, as that condition</font>
<font color="black">  95.             # would always evaluate to true.</font>
<font color="red">  96.             self._migrate_all_backwards(plan, full_plan, fake=fake)</font>
<font color="black">  97. </font>
<font color="green">  98.         self.check_replacements()</font>
<font color="black">  99. </font>
<font color="green"> 100.     def _migrate_all_forwards(self, plan, full_plan, fake, fake_initial):</font>
<font color="black"> 101.         &quot;&quot;&quot;</font>
<font color="black"> 102.         Take a list of 2-tuples of the form (migration instance, False) and</font>
<font color="black"> 103.         apply them in the order they occur in the full_plan.</font>
<font color="black"> 104.         &quot;&quot;&quot;</font>
<font color="green"> 105.         migrations_to_run = {m[0] for m in plan}</font>
<font color="green"> 106.         state = ProjectState(real_apps=list(self.loader.unmigrated_apps))</font>
<font color="green"> 107.         for migration, _ in full_plan:</font>
<font color="green"> 108.             if not migrations_to_run:</font>
<font color="black"> 109.                 # We remove every migration that we applied from this set so</font>
<font color="black"> 110.                 # that we can bail out once the last migration has been applied</font>
<font color="black"> 111.                 # and don't always run until the very end of the migration</font>
<font color="black"> 112.                 # process.</font>
<font color="red"> 113.                 break</font>
<font color="green"> 114.             if migration in migrations_to_run:</font>
<font color="green"> 115.                 if 'apps' not in state.__dict__:</font>
<font color="green"> 116.                     if self.progress_callback:</font>
<font color="green"> 117.                         self.progress_callback(&quot;render_start&quot;)</font>
<font color="green"> 118.                     state.apps  # Render all -- performance critical</font>
<font color="green"> 119.                     if self.progress_callback:</font>
<font color="green"> 120.                         self.progress_callback(&quot;render_success&quot;)</font>
<font color="green"> 121.                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)</font>
<font color="green"> 122.                 migrations_to_run.remove(migration)</font>
<font color="black"> 123.             else:</font>
<font color="red"> 124.                 migration.mutate_state(state, preserve=False)</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def _migrate_all_backwards(self, plan, full_plan, fake):</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         Take a list of 2-tuples of the form (migration instance, True) and</font>
<font color="black"> 129.         unapply them in reverse order they occur in the full_plan.</font>
<font color="black"> 130. </font>
<font color="black"> 131.         Since unapplying a migration requires the project state prior to that</font>
<font color="black"> 132.         migration, Django will compute the migration states before each of them</font>
<font color="black"> 133.         in a first run over the plan and then unapply them in a second run over</font>
<font color="black"> 134.         the plan.</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="red"> 136.         migrations_to_run = {m[0] for m in plan}</font>
<font color="black"> 137.         # Holds all migration states prior to the migrations being unapplied</font>
<font color="red"> 138.         states = {}</font>
<font color="red"> 139.         state = ProjectState(real_apps=list(self.loader.unmigrated_apps))</font>
<font color="red"> 140.         if self.progress_callback:</font>
<font color="red"> 141.             self.progress_callback(&quot;render_start&quot;)</font>
<font color="red"> 142.         for migration, _ in full_plan:</font>
<font color="red"> 143.             if not migrations_to_run:</font>
<font color="black"> 144.                 # We remove every migration that we applied from this set so</font>
<font color="black"> 145.                 # that we can bail out once the last migration has been applied</font>
<font color="black"> 146.                 # and don't always run until the very end of the migration</font>
<font color="black"> 147.                 # process.</font>
<font color="red"> 148.                 break</font>
<font color="red"> 149.             if migration in migrations_to_run:</font>
<font color="red"> 150.                 if 'apps' not in state.__dict__:</font>
<font color="red"> 151.                     state.apps  # Render all -- performance critical</font>
<font color="black"> 152.                 # The state before this migration</font>
<font color="red"> 153.                 states[migration] = state</font>
<font color="black"> 154.                 # The old state keeps as-is, we continue with the new state</font>
<font color="red"> 155.                 state = migration.mutate_state(state, preserve=True)</font>
<font color="red"> 156.                 migrations_to_run.remove(migration)</font>
<font color="black"> 157.             else:</font>
<font color="red"> 158.                 migration.mutate_state(state, preserve=False)</font>
<font color="red"> 159.         if self.progress_callback:</font>
<font color="red"> 160.             self.progress_callback(&quot;render_success&quot;)</font>
<font color="black"> 161. </font>
<font color="red"> 162.         for migration, _ in plan:</font>
<font color="red"> 163.             self.unapply_migration(states[migration], migration, fake=fake)</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def collect_sql(self, plan):</font>
<font color="black"> 166.         &quot;&quot;&quot;</font>
<font color="black"> 167.         Takes a migration plan and returns a list of collected SQL</font>
<font color="black"> 168.         statements that represent the best-efforts version of that plan.</font>
<font color="black"> 169.         &quot;&quot;&quot;</font>
<font color="red"> 170.         statements = []</font>
<font color="red"> 171.         state = None</font>
<font color="red"> 172.         for migration, backwards in plan:</font>
<font color="red"> 173.             with self.connection.schema_editor(collect_sql=True) as schema_editor:</font>
<font color="red"> 174.                 if state is None:</font>
<font color="red"> 175.                     state = self.loader.project_state((migration.app_label, migration.name), at_end=False)</font>
<font color="red"> 176.                 if not backwards:</font>
<font color="red"> 177.                     state = migration.apply(state, schema_editor, collect_sql=True)</font>
<font color="black"> 178.                 else:</font>
<font color="red"> 179.                     state = migration.unapply(state, schema_editor, collect_sql=True)</font>
<font color="red"> 180.             statements.extend(schema_editor.collected_sql)</font>
<font color="red"> 181.         return statements</font>
<font color="black"> 182. </font>
<font color="green"> 183.     def apply_migration(self, state, migration, fake=False, fake_initial=False):</font>
<font color="black"> 184.         &quot;&quot;&quot;</font>
<font color="black"> 185.         Runs a migration forwards.</font>
<font color="black"> 186.         &quot;&quot;&quot;</font>
<font color="green"> 187.         if self.progress_callback:</font>
<font color="green"> 188.             self.progress_callback(&quot;apply_start&quot;, migration, fake)</font>
<font color="green"> 189.         if not fake:</font>
<font color="green"> 190.             if fake_initial:</font>
<font color="black"> 191.                 # Test to see if this is an already-applied initial migration</font>
<font color="red"> 192.                 applied, state = self.detect_soft_applied(state, migration)</font>
<font color="red"> 193.                 if applied:</font>
<font color="red"> 194.                     fake = True</font>
<font color="green"> 195.             if not fake:</font>
<font color="black"> 196.                 # Alright, do it normally</font>
<font color="green"> 197.                 with self.connection.schema_editor() as schema_editor:</font>
<font color="green"> 198.                     state = migration.apply(state, schema_editor)</font>
<font color="black"> 199.         # For replacement migrations, record individual statuses</font>
<font color="green"> 200.         if migration.replaces:</font>
<font color="red"> 201.             for app_label, name in migration.replaces:</font>
<font color="red"> 202.                 self.recorder.record_applied(app_label, name)</font>
<font color="black"> 203.         else:</font>
<font color="green"> 204.             self.recorder.record_applied(migration.app_label, migration.name)</font>
<font color="black"> 205.         # Report progress</font>
<font color="green"> 206.         if self.progress_callback:</font>
<font color="green"> 207.             self.progress_callback(&quot;apply_success&quot;, migration, fake)</font>
<font color="green"> 208.         return state</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def unapply_migration(self, state, migration, fake=False):</font>
<font color="black"> 211.         &quot;&quot;&quot;</font>
<font color="black"> 212.         Runs a migration backwards.</font>
<font color="black"> 213.         &quot;&quot;&quot;</font>
<font color="red"> 214.         if self.progress_callback:</font>
<font color="red"> 215.             self.progress_callback(&quot;unapply_start&quot;, migration, fake)</font>
<font color="red"> 216.         if not fake:</font>
<font color="red"> 217.             with self.connection.schema_editor() as schema_editor:</font>
<font color="red"> 218.                 state = migration.unapply(state, schema_editor)</font>
<font color="black"> 219.         # For replacement migrations, record individual statuses</font>
<font color="red"> 220.         if migration.replaces:</font>
<font color="red"> 221.             for app_label, name in migration.replaces:</font>
<font color="red"> 222.                 self.recorder.record_unapplied(app_label, name)</font>
<font color="black"> 223.         else:</font>
<font color="red"> 224.             self.recorder.record_unapplied(migration.app_label, migration.name)</font>
<font color="black"> 225.         # Report progress</font>
<font color="red"> 226.         if self.progress_callback:</font>
<font color="red"> 227.             self.progress_callback(&quot;unapply_success&quot;, migration, fake)</font>
<font color="red"> 228.         return state</font>
<font color="black"> 229. </font>
<font color="green"> 230.     def check_replacements(self):</font>
<font color="black"> 231.         &quot;&quot;&quot;</font>
<font color="black"> 232.         Mark replacement migrations applied if their replaced set all are.</font>
<font color="black"> 233. </font>
<font color="black"> 234.         We do this unconditionally on every migrate, rather than just when</font>
<font color="black"> 235.         migrations are applied or unapplied, so as to correctly handle the case</font>
<font color="black"> 236.         when a new squash migration is pushed to a deployment that already had</font>
<font color="black"> 237.         all its replaced migrations applied. In this case no new migration will</font>
<font color="black"> 238.         be applied, but we still want to correctly maintain the applied state</font>
<font color="black"> 239.         of the squash migration.</font>
<font color="black"> 240.         &quot;&quot;&quot;</font>
<font color="green"> 241.         applied = self.recorder.applied_migrations()</font>
<font color="green"> 242.         for key, migration in self.loader.replacements.items():</font>
<font color="red"> 243.             all_applied = all(m in applied for m in migration.replaces)</font>
<font color="red"> 244.             if all_applied and key not in applied:</font>
<font color="red"> 245.                 self.recorder.record_applied(*key)</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def detect_soft_applied(self, project_state, migration):</font>
<font color="black"> 248.         &quot;&quot;&quot;</font>
<font color="black"> 249.         Tests whether a migration has been implicitly applied - that the</font>
<font color="black"> 250.         tables or columns it would create exist. This is intended only for use</font>
<font color="black"> 251.         on initial migrations (as it only looks for CreateModel and AddField).</font>
<font color="black"> 252.         &quot;&quot;&quot;</font>
<font color="red"> 253.         if migration.initial is None:</font>
<font color="black"> 254.             # Bail if the migration isn't the first one in its app</font>
<font color="red"> 255.             if any(app == migration.app_label for app, name in migration.dependencies):</font>
<font color="red"> 256.                 return False, project_state</font>
<font color="red"> 257.         elif migration.initial is False:</font>
<font color="black"> 258.             # Bail if it's NOT an initial migration</font>
<font color="red"> 259.             return False, project_state</font>
<font color="black"> 260. </font>
<font color="red"> 261.         if project_state is None:</font>
<font color="red"> 262.             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)</font>
<font color="black"> 263.         else:</font>
<font color="red"> 264.             after_state = migration.mutate_state(project_state)</font>
<font color="red"> 265.         apps = after_state.apps</font>
<font color="red"> 266.         found_create_model_migration = False</font>
<font color="red"> 267.         found_add_field_migration = False</font>
<font color="black"> 268.         # Make sure all create model and add field operations are done</font>
<font color="red"> 269.         for operation in migration.operations:</font>
<font color="red"> 270.             if isinstance(operation, migrations.CreateModel):</font>
<font color="red"> 271.                 model = apps.get_model(migration.app_label, operation.name)</font>
<font color="red"> 272.                 if model._meta.swapped:</font>
<font color="black"> 273.                     # We have to fetch the model to test with from the</font>
<font color="black"> 274.                     # main app cache, as it's not a direct dependency.</font>
<font color="red"> 275.                     model = global_apps.get_model(model._meta.swapped)</font>
<font color="red"> 276.                 if model._meta.proxy or not model._meta.managed:</font>
<font color="red"> 277.                     continue</font>
<font color="red"> 278.                 if model._meta.db_table not in self.connection.introspection.table_names(self.connection.cursor()):</font>
<font color="red"> 279.                     return False, project_state</font>
<font color="red"> 280.                 found_create_model_migration = True</font>
<font color="red"> 281.             elif isinstance(operation, migrations.AddField):</font>
<font color="red"> 282.                 model = apps.get_model(migration.app_label, operation.model_name)</font>
<font color="red"> 283.                 if model._meta.swapped:</font>
<font color="black"> 284.                     # We have to fetch the model to test with from the</font>
<font color="black"> 285.                     # main app cache, as it's not a direct dependency.</font>
<font color="red"> 286.                     model = global_apps.get_model(model._meta.swapped)</font>
<font color="red"> 287.                 if model._meta.proxy or not model._meta.managed:</font>
<font color="red"> 288.                     continue</font>
<font color="black"> 289. </font>
<font color="red"> 290.                 table = model._meta.db_table</font>
<font color="red"> 291.                 db_field = model._meta.get_field(operation.name).column</font>
<font color="red"> 292.                 fields = self.connection.introspection.get_table_description(self.connection.cursor(), table)</font>
<font color="red"> 293.                 if db_field not in (f.name for f in fields):</font>
<font color="red"> 294.                     return False, project_state</font>
<font color="red"> 295.                 found_add_field_migration = True</font>
<font color="black"> 296.         # If we get this far and we found at least one CreateModel or AddField migration,</font>
<font color="black"> 297.         # the migration is considered implicitly applied.</font>
<font color="red"> 298.         return (found_create_model_migration or found_add_field_migration), after_state</font>
</pre>

