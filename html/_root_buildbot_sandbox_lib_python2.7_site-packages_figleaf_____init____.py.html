source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/figleaf/__init__.py</b><br>


file stats: <b>130 lines, 2 executed: 1.5% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. figleaf is another tool to trace Python code coverage.</font>
<font color="black">   3. </font>
<font color="black">   4. figleaf uses the sys.settrace hook to record which statements are</font>
<font color="black">   5. executed by the CPython interpreter; this record can then be saved</font>
<font color="black">   6. into a file, or otherwise communicated back to a reporting script.</font>
<font color="black">   7. </font>
<font color="black">   8. figleaf differs from the gold standard of Python coverage tools</font>
<font color="black">   9. ('coverage.py') in several ways.  First and foremost, figleaf uses the</font>
<font color="black">  10. same criterion for &quot;interesting&quot; lines of code as the sys.settrace</font>
<font color="black">  11. function, which obviates some of the complexity in coverage.py (but</font>
<font color="black">  12. does mean that your &quot;loc&quot; count goes down).  Second, figleaf does not</font>
<font color="black">  13. record code executed in the Python standard library, which results in</font>
<font color="black">  14. a significant speedup.  And third, the format in which the coverage</font>
<font color="black">  15. format is saved is very simple and easy to work with.</font>
<font color="black">  16. </font>
<font color="black">  17. You might want to use figleaf if you're recording coverage from</font>
<font color="black">  18. multiple types of tests and need to aggregate the coverage in</font>
<font color="black">  19. interesting ways, and/or control when coverage is recorded.</font>
<font color="black">  20. coverage.py is a better choice for command-line execution, and its</font>
<font color="black">  21. reporting is a fair bit nicer.</font>
<font color="black">  22. </font>
<font color="black">  23. Command line usage: ::</font>
<font color="black">  24. </font>
<font color="black">  25.   figleaf &lt;python file to execute&gt; &lt;args to python file&gt;</font>
<font color="black">  26. </font>
<font color="black">  27. The figleaf output is saved into the file '.figleaf', which is an</font>
<font color="black">  28. *aggregate* of coverage reports from all figleaf runs from this</font>
<font color="black">  29. directory.  '.figleaf' contains a pickled dictionary of sets; the keys</font>
<font color="black">  30. are source code filenames, and the sets contain all line numbers</font>
<font color="black">  31. executed by the Python interpreter. See the docs or command-line</font>
<font color="black">  32. programs in bin/ for more information.</font>
<font color="black">  33. </font>
<font color="black">  34. High level API: ::</font>
<font color="black">  35. </font>
<font color="black">  36.  * ``start(ignore_lib=True)`` -- start recording code coverage.</font>
<font color="black">  37.  * ``stop()``                 -- stop recording code coverage.</font>
<font color="black">  38.  * ``get_trace_obj()``        -- return the (singleton) trace object.</font>
<font color="black">  39.  * ``get_info()``             -- get the coverage dictionary</font>
<font color="black">  40. </font>
<font color="black">  41. Classes &amp; functions worth knowing about (lower level API):</font>
<font color="black">  42. </font>
<font color="black">  43.  * ``get_lines(fp)`` -- return the set of interesting lines in the fp.</font>
<font color="black">  44.  * ``combine_coverage(d1, d2)`` -- combine coverage info from two dicts.</font>
<font color="black">  45.  * ``read_coverage(filename)`` -- load the coverage dictionary</font>
<font color="black">  46.  * ``write_coverage(filename)`` -- write the coverage out.</font>
<font color="black">  47.  * ``annotate_coverage(...)`` -- annotate a Python file with its coverage info.</font>
<font color="black">  48. </font>
<font color="black">  49. Known problems:</font>
<font color="black">  50. </font>
<font color="black">  51.  -- module docstrings are *covered* but not found.</font>
<font color="black">  52. </font>
<font color="black">  53. AUTHOR: C. Titus Brown, titus@idyll.org, with contributions from Iain Lowe.</font>
<font color="black">  54. </font>
<font color="black">  55. 'figleaf' is Copyright (C) 2006, 2007 C. Titus Brown.  It is under the</font>
<font color="black">  56. BSD license.</font>
<font color="red">  57. &quot;&quot;&quot;</font>
<font color="red">  58. __version__ = &quot;0.6.1&quot;</font>
<font color="black">  59. </font>
<font color="black">  60. # __all__ == @CTB</font>
<font color="black">  61. </font>
<font color="red">  62. import sys</font>
<font color="red">  63. import os</font>
<font color="red">  64. from cPickle import dump, load</font>
<font color="red">  65. from optparse import OptionParser</font>
<font color="black">  66. </font>
<font color="red">  67. import internals</font>
<font color="black">  68. </font>
<font color="black">  69. # use builtin sets if in &gt;= 2.4, otherwise use 'sets' module.</font>
<font color="red">  70. try:</font>
<font color="red">  71.     set()</font>
<font color="red">  72. except NameError:</font>
<font color="red">  73.     from sets import Set as set</font>
<font color="black">  74. </font>
<font color="red">  75. def get_lines(fp):</font>
<font color="black">  76.     &quot;&quot;&quot;</font>
<font color="black">  77.     Return the set of interesting lines in the source code read from</font>
<font color="black">  78.     this file handle.</font>
<font color="black">  79.     &quot;&quot;&quot;</font>
<font color="black">  80.     # rstrip is a workaround for http://bugs.python.org/issue4262</font>
<font color="red">  81.     src = fp.read().rstrip() + &quot;\n&quot;</font>
<font color="red">  82.     code = compile(src, &quot;&quot;, &quot;exec&quot;)</font>
<font color="black">  83. </font>
<font color="red">  84.     return internals.get_interesting_lines(code)</font>
<font color="black">  85. </font>
<font color="red">  86. def combine_coverage(d1, d2):</font>
<font color="black">  87.     &quot;&quot;&quot;</font>
<font color="black">  88.     Given two coverage dictionaries, combine the recorded coverage</font>
<font color="black">  89.     and return a new dictionary.</font>
<font color="black">  90.     &quot;&quot;&quot;</font>
<font color="red">  91.     keys = set(d1.keys())</font>
<font color="red">  92.     keys.update(set(d2.keys()))</font>
<font color="black">  93. </font>
<font color="red">  94.     new_d = {}</font>
<font color="red">  95.     for k in keys:</font>
<font color="red">  96.         v = d1.get(k, set())</font>
<font color="red">  97.         v2 = d2.get(k, set())</font>
<font color="black">  98. </font>
<font color="red">  99.         s = set(v)</font>
<font color="red"> 100.         s.update(v2)</font>
<font color="red"> 101.         new_d[k] = s</font>
<font color="black"> 102. </font>
<font color="red"> 103.     return new_d</font>
<font color="black"> 104. </font>
<font color="red"> 105. def write_coverage(filename, append=True):</font>
<font color="black"> 106.     &quot;&quot;&quot;</font>
<font color="black"> 107.     Write the current coverage info out to the given filename.  If</font>
<font color="black"> 108.     'append' is false, destroy any previously recorded coverage info.</font>
<font color="black"> 109.     &quot;&quot;&quot;</font>
<font color="red"> 110.     if _t is None:</font>
<font color="red"> 111.         return</font>
<font color="black"> 112. </font>
<font color="red"> 113.     data = internals.CoverageData(_t)</font>
<font color="black"> 114. </font>
<font color="red"> 115.     d = data.gather_files()</font>
<font color="black"> 116. </font>
<font color="black"> 117.     # sum existing coverage?</font>
<font color="red"> 118.     if append:</font>
<font color="red"> 119.         old = {}</font>
<font color="red"> 120.         fp = None</font>
<font color="red"> 121.         try:</font>
<font color="red"> 122.             fp = open(filename)</font>
<font color="red"> 123.         except IOError:</font>
<font color="red"> 124.             pass</font>
<font color="black"> 125. </font>
<font color="red"> 126.         if fp:</font>
<font color="red"> 127.             old = load(fp)</font>
<font color="red"> 128.             fp.close()</font>
<font color="red"> 129.             d = combine_coverage(d, old)</font>
<font color="black"> 130. </font>
<font color="black"> 131.     # ok, save.</font>
<font color="red"> 132.     outfp = open(filename, 'w')</font>
<font color="red"> 133.     try:</font>
<font color="red"> 134.         dump(d, outfp)</font>
<font color="black"> 135.     finally:</font>
<font color="red"> 136.         outfp.close()</font>
<font color="black"> 137. </font>
<font color="red"> 138. def read_coverage(filename):</font>
<font color="black"> 139.     &quot;&quot;&quot;</font>
<font color="black"> 140.     Read a coverage dictionary in from the given file.</font>
<font color="black"> 141.     &quot;&quot;&quot;</font>
<font color="red"> 142.     fp = open(filename)</font>
<font color="red"> 143.     try:</font>
<font color="red"> 144.         d = load(fp)</font>
<font color="black"> 145.     finally:</font>
<font color="red"> 146.         fp.close()</font>
<font color="black"> 147. </font>
<font color="red"> 148.     return d</font>
<font color="black"> 149. </font>
<font color="red"> 150. def dump_pickled_coverage(out_fp):</font>
<font color="black"> 151.     &quot;&quot;&quot;</font>
<font color="black"> 152.     Dump coverage information in pickled format into the given file handle.</font>
<font color="black"> 153.     &quot;&quot;&quot;</font>
<font color="red"> 154.     dump(_t, out_fp)</font>
<font color="black"> 155. </font>
<font color="red"> 156. def load_pickled_coverage(in_fp):</font>
<font color="black"> 157.     &quot;&quot;&quot;</font>
<font color="black"> 158.     Replace (overwrite) coverage information from the given file handle.</font>
<font color="black"> 159.     &quot;&quot;&quot;</font>
<font color="black"> 160.     global _t</font>
<font color="red"> 161.     _t = load(in_fp)</font>
<font color="black"> 162. </font>
<font color="black"> 163. def annotate_coverage(in_fp, out_fp, covered, all_lines,</font>
<font color="red"> 164.                       mark_possible_lines=False):</font>
<font color="black"> 165.     &quot;&quot;&quot;</font>
<font color="black"> 166.     A simple example coverage annotator that outputs text.</font>
<font color="black"> 167.     &quot;&quot;&quot;</font>
<font color="red"> 168.     for i, line in enumerate(in_fp):</font>
<font color="red"> 169.         i = i + 1</font>
<font color="black"> 170. </font>
<font color="red"> 171.         if i in covered:</font>
<font color="red"> 172.             symbol = '&gt;'</font>
<font color="red"> 173.         elif i in all_lines:</font>
<font color="red"> 174.             symbol = '!'</font>
<font color="black"> 175.         else:</font>
<font color="red"> 176.             symbol = ' '</font>
<font color="black"> 177. </font>
<font color="red"> 178.         symbol2 = ''</font>
<font color="red"> 179.         if mark_possible_lines:</font>
<font color="red"> 180.             symbol2 = ' '</font>
<font color="red"> 181.             if i in all_lines:</font>
<font color="red"> 182.                 symbol2 = '-'</font>
<font color="black"> 183. </font>
<font color="red"> 184.         out_fp.write('%s%s %s' % (symbol, symbol2, line,))</font>
<font color="black"> 185. </font>
<font color="red"> 186. def get_data():</font>
<font color="red"> 187.     if _t:</font>
<font color="red"> 188.         return internals.CoverageData(_t)</font>
<font color="black"> 189. </font>
<font color="black"> 190. #######################</font>
<font color="black"> 191. </font>
<font color="black"> 192. #</font>
<font color="black"> 193. # singleton functions/top-level API</font>
<font color="black"> 194. #</font>
<font color="black"> 195. </font>
<font color="red"> 196. _t = None</font>
<font color="black"> 197. </font>
<font color="red"> 198. def init(exclude_path=None, include_only=None):</font>
<font color="red"> 199.     from internals import CodeTracer</font>
<font color="black"> 200. </font>
<font color="black"> 201.     global _t</font>
<font color="red"> 202.     if _t is None:</font>
<font color="red"> 203.         _t = CodeTracer(exclude_path, include_only)</font>
<font color="black"> 204. </font>
<font color="red"> 205. def start(ignore_python_lib=True):</font>
<font color="black"> 206.     &quot;&quot;&quot;</font>
<font color="black"> 207.     Start tracing code coverage.  If 'ignore_python_lib' is True on</font>
<font color="black"> 208.     initial call, ignore all files that live below the same directory as</font>
<font color="black"> 209.     the 'os' module.</font>
<font color="black"> 210.     &quot;&quot;&quot;</font>
<font color="black"> 211.     global _t</font>
<font color="red"> 212.     if not _t:</font>
<font color="red"> 213.         exclude_path = None</font>
<font color="red"> 214.         if ignore_python_lib:</font>
<font color="red"> 215.             exclude_path = os.path.realpath(os.path.dirname(os.__file__))</font>
<font color="black"> 216. </font>
<font color="red"> 217.         init(exclude_path, None)</font>
<font color="black"> 218. </font>
<font color="red"> 219.     _t.start()</font>
<font color="black"> 220. </font>
<font color="red"> 221. def start_section(name):</font>
<font color="black"> 222.     global _t</font>
<font color="red"> 223.     _t.start_section(name)</font>
<font color="black"> 224. </font>
<font color="red"> 225. def stop_section():</font>
<font color="black"> 226.     global _t</font>
<font color="red"> 227.     _t.stop_section()</font>
<font color="black"> 228. </font>
<font color="red"> 229. def stop():</font>
<font color="black"> 230.     &quot;&quot;&quot;</font>
<font color="black"> 231.     Stop tracing code coverage.</font>
<font color="black"> 232.     &quot;&quot;&quot;</font>
<font color="black"> 233.     global _t</font>
<font color="green"> 234.     if _t is not None:</font>
<font color="green"> 235.         _t.stop()</font>
<font color="black"> 236. </font>
<font color="red"> 237. def get_trace_obj():</font>
<font color="black"> 238.     &quot;&quot;&quot;</font>
<font color="black"> 239.     Return the (singleton) trace object, if it exists.</font>
<font color="black"> 240.     &quot;&quot;&quot;</font>
<font color="red"> 241.     return _t</font>
<font color="black"> 242. </font>
<font color="red"> 243. def get_info(section_name=None):</font>
<font color="black"> 244.     &quot;&quot;&quot;</font>
<font color="black"> 245.     Get the coverage dictionary from the trace object.</font>
<font color="black"> 246.     &quot;&quot;&quot;</font>
<font color="red"> 247.     if _t:</font>
<font color="red"> 248.         return get_data().gather_files(section_name)</font>
<font color="black"> 249. </font>
<font color="black"> 250. #############</font>
<font color="black"> 251. </font>
<font color="red"> 252. def display_ast():</font>
<font color="red"> 253.     l = internals.LineGrabber(open(sys.argv[1]))</font>
<font color="red"> 254.     l.pretty_print()</font>
<font color="red"> 255.     print l.lines</font>
<font color="black"> 256. </font>
<font color="red"> 257. def main():</font>
<font color="black"> 258.     &quot;&quot;&quot;</font>
<font color="black"> 259.     Execute the given Python file with coverage, making it look like it is</font>
<font color="black"> 260.     __main__.</font>
<font color="black"> 261.     &quot;&quot;&quot;</font>
<font color="red"> 262.     ignore_pylibs = False</font>
<font color="black"> 263. </font>
<font color="black"> 264.     # gather args</font>
<font color="black"> 265. </font>
<font color="red"> 266.     n = 1</font>
<font color="red"> 267.     figleaf_args = []</font>
<font color="red"> 268.     for n in range(1, len(sys.argv)):</font>
<font color="red"> 269.         arg = sys.argv[n]</font>
<font color="red"> 270.         if arg.startswith('-'):</font>
<font color="red"> 271.             figleaf_args.append(arg)</font>
<font color="black"> 272.         else:</font>
<font color="red"> 273.             break</font>
<font color="black"> 274. </font>
<font color="red"> 275.     remaining_args = sys.argv[n:]</font>
<font color="black"> 276. </font>
<font color="red"> 277.     usage = &quot;usage: %prog [options] [python_script arg1 arg2 ...]&quot;</font>
<font color="red"> 278.     option_parser = OptionParser(usage=usage)</font>
<font color="black"> 279. </font>
<font color="red"> 280.     option_parser.add_option('-i', '--ignore-pylibs', action=&quot;store_true&quot;,</font>
<font color="red"> 281.                              dest=&quot;ignore_pylibs&quot;, default=False,</font>
<font color="red"> 282.                              help=&quot;ignore Python library modules&quot;)</font>
<font color="black"> 283. </font>
<font color="red"> 284.     (options, args) = option_parser.parse_args(args=figleaf_args)</font>
<font color="red"> 285.     assert len(args) == 0</font>
<font color="black"> 286. </font>
<font color="red"> 287.     if not remaining_args:</font>
<font color="red"> 288.         option_parser.error(&quot;you must specify a python script to run!&quot;)</font>
<font color="black"> 289. </font>
<font color="red"> 290.     ignore_pylibs = options.ignore_pylibs</font>
<font color="black"> 291. </font>
<font color="black"> 292.     ## Reset system args so that the subsequently exec'd file can read</font>
<font color="black"> 293.     ## from sys.argv</font>
<font color="black"> 294. </font>
<font color="red"> 295.     sys.argv = remaining_args</font>
<font color="black"> 296. </font>
<font color="red"> 297.     sys.path[0] = os.path.dirname(sys.argv[0])</font>
<font color="black"> 298. </font>
<font color="red"> 299.     cwd = os.getcwd()</font>
<font color="black"> 300. </font>
<font color="red"> 301.     start(ignore_pylibs)        # START code coverage</font>
<font color="black"> 302. </font>
<font color="red"> 303.     import __main__</font>
<font color="red"> 304.     try:</font>
<font color="red"> 305.         execfile(sys.argv[0], __main__.__dict__)</font>
<font color="black"> 306.     finally:</font>
<font color="red"> 307.         stop()                          # STOP code coverage</font>
<font color="black"> 308. </font>
<font color="red"> 309.         write_coverage(os.path.join(cwd, '.figleaf'))</font>
</pre>

