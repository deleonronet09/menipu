source file: <b>/usr/lib/python2.7/weakref.py</b><br>


file stats: <b>286 lines, 24 executed: 8.4% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Weak reference support for Python.</font>
<font color="black">   2. </font>
<font color="black">   3. This module is an implementation of PEP 205:</font>
<font color="black">   4. </font>
<font color="black">   5. http://www.python.org/dev/peps/pep-0205/</font>
<font color="red">   6. &quot;&quot;&quot;</font>
<font color="black">   7. </font>
<font color="black">   8. # Naming convention: Variables named &quot;wr&quot; are weak reference objects;</font>
<font color="black">   9. # they are called this instead of &quot;ref&quot; to avoid name collisions with</font>
<font color="black">  10. # the module-global ref() function imported from _weakref.</font>
<font color="black">  11. </font>
<font color="red">  12. import UserDict</font>
<font color="black">  13. </font>
<font color="red">  14. from _weakref import (</font>
<font color="black">  15.      getweakrefcount,</font>
<font color="black">  16.      getweakrefs,</font>
<font color="black">  17.      ref,</font>
<font color="black">  18.      proxy,</font>
<font color="black">  19.      CallableProxyType,</font>
<font color="black">  20.      ProxyType,</font>
<font color="black">  21.      ReferenceType)</font>
<font color="black">  22. </font>
<font color="red">  23. from _weakrefset import WeakSet, _IterationGuard</font>
<font color="black">  24. </font>
<font color="red">  25. from exceptions import ReferenceError</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="red">  28. ProxyTypes = (ProxyType, CallableProxyType)</font>
<font color="black">  29. </font>
<font color="red">  30. __all__ = [&quot;ref&quot;, &quot;proxy&quot;, &quot;getweakrefcount&quot;, &quot;getweakrefs&quot;,</font>
<font color="red">  31.            &quot;WeakKeyDictionary&quot;, &quot;ReferenceError&quot;, &quot;ReferenceType&quot;, &quot;ProxyType&quot;,</font>
<font color="red">  32.            &quot;CallableProxyType&quot;, &quot;ProxyTypes&quot;, &quot;WeakValueDictionary&quot;, 'WeakSet']</font>
<font color="black">  33. </font>
<font color="black">  34. </font>
<font color="red">  35. class WeakValueDictionary(UserDict.UserDict):</font>
<font color="black">  36.     &quot;&quot;&quot;Mapping class that references values weakly.</font>
<font color="black">  37. </font>
<font color="black">  38.     Entries in the dictionary will be discarded when no strong</font>
<font color="black">  39.     reference to the value exists anymore</font>
<font color="red">  40.     &quot;&quot;&quot;</font>
<font color="black">  41.     # We inherit the constructor without worrying about the input</font>
<font color="black">  42.     # dictionary; since it uses our .update() method, we get the right</font>
<font color="black">  43.     # checks (if the other dictionary is a WeakValueDictionary,</font>
<font color="black">  44.     # objects are unwrapped on the way out, and we always wrap on the</font>
<font color="black">  45.     # way in).</font>
<font color="black">  46. </font>
<font color="red">  47.     def __init__(self, *args, **kw):</font>
<font color="green">  48.         def remove(wr, selfref=ref(self)):</font>
<font color="red">  49.             self = selfref()</font>
<font color="red">  50.             if self is not None:</font>
<font color="red">  51.                 if self._iterating:</font>
<font color="red">  52.                     self._pending_removals.append(wr.key)</font>
<font color="black">  53.                 else:</font>
<font color="red">  54.                     del self.data[wr.key]</font>
<font color="green">  55.         self._remove = remove</font>
<font color="black">  56.         # A list of keys to be removed</font>
<font color="green">  57.         self._pending_removals = []</font>
<font color="green">  58.         self._iterating = set()</font>
<font color="green">  59.         UserDict.UserDict.__init__(self, *args, **kw)</font>
<font color="black">  60. </font>
<font color="red">  61.     def _commit_removals(self):</font>
<font color="red">  62.         l = self._pending_removals</font>
<font color="red">  63.         d = self.data</font>
<font color="black">  64.         # We shouldn't encounter any KeyError, because this method should</font>
<font color="black">  65.         # always be called *before* mutating the dict.</font>
<font color="red">  66.         while l:</font>
<font color="red">  67.             del d[l.pop()]</font>
<font color="black">  68. </font>
<font color="red">  69.     def __getitem__(self, key):</font>
<font color="red">  70.         o = self.data[key]()</font>
<font color="red">  71.         if o is None:</font>
<font color="red">  72.             raise KeyError, key</font>
<font color="black">  73.         else:</font>
<font color="red">  74.             return o</font>
<font color="black">  75. </font>
<font color="red">  76.     def __delitem__(self, key):</font>
<font color="red">  77.         if self._pending_removals:</font>
<font color="red">  78.             self._commit_removals()</font>
<font color="red">  79.         del self.data[key]</font>
<font color="black">  80. </font>
<font color="red">  81.     def __contains__(self, key):</font>
<font color="green">  82.         try:</font>
<font color="green">  83.             o = self.data[key]()</font>
<font color="green">  84.         except KeyError:</font>
<font color="green">  85.             return False</font>
<font color="red">  86.         return o is not None</font>
<font color="black">  87. </font>
<font color="red">  88.     def has_key(self, key):</font>
<font color="red">  89.         try:</font>
<font color="red">  90.             o = self.data[key]()</font>
<font color="red">  91.         except KeyError:</font>
<font color="red">  92.             return False</font>
<font color="red">  93.         return o is not None</font>
<font color="black">  94. </font>
<font color="red">  95.     def __repr__(self):</font>
<font color="red">  96.         return &quot;&lt;WeakValueDictionary at %s&gt;&quot; % id(self)</font>
<font color="black">  97. </font>
<font color="red">  98.     def __setitem__(self, key, value):</font>
<font color="green">  99.         if self._pending_removals:</font>
<font color="red"> 100.             self._commit_removals()</font>
<font color="green"> 101.         self.data[key] = KeyedRef(value, self._remove, key)</font>
<font color="black"> 102. </font>
<font color="red"> 103.     def clear(self):</font>
<font color="green"> 104.         if self._pending_removals:</font>
<font color="red"> 105.             self._commit_removals()</font>
<font color="green"> 106.         self.data.clear()</font>
<font color="black"> 107. </font>
<font color="red"> 108.     def copy(self):</font>
<font color="red"> 109.         new = WeakValueDictionary()</font>
<font color="red"> 110.         for key, wr in self.data.items():</font>
<font color="red"> 111.             o = wr()</font>
<font color="red"> 112.             if o is not None:</font>
<font color="red"> 113.                 new[key] = o</font>
<font color="red"> 114.         return new</font>
<font color="black"> 115. </font>
<font color="red"> 116.     __copy__ = copy</font>
<font color="black"> 117. </font>
<font color="red"> 118.     def __deepcopy__(self, memo):</font>
<font color="red"> 119.         from copy import deepcopy</font>
<font color="red"> 120.         new = self.__class__()</font>
<font color="red"> 121.         for key, wr in self.data.items():</font>
<font color="red"> 122.             o = wr()</font>
<font color="red"> 123.             if o is not None:</font>
<font color="red"> 124.                 new[deepcopy(key, memo)] = o</font>
<font color="red"> 125.         return new</font>
<font color="black"> 126. </font>
<font color="red"> 127.     def get(self, key, default=None):</font>
<font color="red"> 128.         try:</font>
<font color="red"> 129.             wr = self.data[key]</font>
<font color="red"> 130.         except KeyError:</font>
<font color="red"> 131.             return default</font>
<font color="black"> 132.         else:</font>
<font color="red"> 133.             o = wr()</font>
<font color="red"> 134.             if o is None:</font>
<font color="black"> 135.                 # This should only happen</font>
<font color="red"> 136.                 return default</font>
<font color="black"> 137.             else:</font>
<font color="red"> 138.                 return o</font>
<font color="black"> 139. </font>
<font color="red"> 140.     def items(self):</font>
<font color="red"> 141.         L = []</font>
<font color="red"> 142.         for key, wr in self.data.items():</font>
<font color="red"> 143.             o = wr()</font>
<font color="red"> 144.             if o is not None:</font>
<font color="red"> 145.                 L.append((key, o))</font>
<font color="red"> 146.         return L</font>
<font color="black"> 147. </font>
<font color="red"> 148.     def iteritems(self):</font>
<font color="red"> 149.         with _IterationGuard(self):</font>
<font color="red"> 150.             for wr in self.data.itervalues():</font>
<font color="red"> 151.                 value = wr()</font>
<font color="red"> 152.                 if value is not None:</font>
<font color="red"> 153.                     yield wr.key, value</font>
<font color="black"> 154. </font>
<font color="red"> 155.     def iterkeys(self):</font>
<font color="red"> 156.         with _IterationGuard(self):</font>
<font color="red"> 157.             for k in self.data.iterkeys():</font>
<font color="red"> 158.                 yield k</font>
<font color="black"> 159. </font>
<font color="red"> 160.     __iter__ = iterkeys</font>
<font color="black"> 161. </font>
<font color="red"> 162.     def itervaluerefs(self):</font>
<font color="black"> 163.         &quot;&quot;&quot;Return an iterator that yields the weak references to the values.</font>
<font color="black"> 164. </font>
<font color="black"> 165.         The references are not guaranteed to be 'live' at the time</font>
<font color="black"> 166.         they are used, so the result of calling the references needs</font>
<font color="black"> 167.         to be checked before being used.  This can be used to avoid</font>
<font color="black"> 168.         creating references that will cause the garbage collector to</font>
<font color="black"> 169.         keep the values around longer than needed.</font>
<font color="black"> 170. </font>
<font color="black"> 171.         &quot;&quot;&quot;</font>
<font color="red"> 172.         with _IterationGuard(self):</font>
<font color="red"> 173.             for wr in self.data.itervalues():</font>
<font color="red"> 174.                 yield wr</font>
<font color="black"> 175. </font>
<font color="red"> 176.     def itervalues(self):</font>
<font color="red"> 177.         with _IterationGuard(self):</font>
<font color="red"> 178.             for wr in self.data.itervalues():</font>
<font color="red"> 179.                 obj = wr()</font>
<font color="red"> 180.                 if obj is not None:</font>
<font color="red"> 181.                     yield obj</font>
<font color="black"> 182. </font>
<font color="red"> 183.     def popitem(self):</font>
<font color="red"> 184.         if self._pending_removals:</font>
<font color="red"> 185.             self._commit_removals()</font>
<font color="red"> 186.         while 1:</font>
<font color="red"> 187.             key, wr = self.data.popitem()</font>
<font color="red"> 188.             o = wr()</font>
<font color="red"> 189.             if o is not None:</font>
<font color="red"> 190.                 return key, o</font>
<font color="black"> 191. </font>
<font color="red"> 192.     def pop(self, key, *args):</font>
<font color="red"> 193.         if self._pending_removals:</font>
<font color="red"> 194.             self._commit_removals()</font>
<font color="red"> 195.         try:</font>
<font color="red"> 196.             o = self.data.pop(key)()</font>
<font color="red"> 197.         except KeyError:</font>
<font color="red"> 198.             if args:</font>
<font color="red"> 199.                 return args[0]</font>
<font color="red"> 200.             raise</font>
<font color="red"> 201.         if o is None:</font>
<font color="red"> 202.             raise KeyError, key</font>
<font color="black"> 203.         else:</font>
<font color="red"> 204.             return o</font>
<font color="black"> 205. </font>
<font color="red"> 206.     def setdefault(self, key, default=None):</font>
<font color="red"> 207.         try:</font>
<font color="red"> 208.             wr = self.data[key]</font>
<font color="red"> 209.         except KeyError:</font>
<font color="red"> 210.             if self._pending_removals:</font>
<font color="red"> 211.                 self._commit_removals()</font>
<font color="red"> 212.             self.data[key] = KeyedRef(default, self._remove, key)</font>
<font color="red"> 213.             return default</font>
<font color="black"> 214.         else:</font>
<font color="red"> 215.             return wr()</font>
<font color="black"> 216. </font>
<font color="red"> 217.     def update(self, dict=None, **kwargs):</font>
<font color="red"> 218.         if self._pending_removals:</font>
<font color="red"> 219.             self._commit_removals()</font>
<font color="red"> 220.         d = self.data</font>
<font color="red"> 221.         if dict is not None:</font>
<font color="red"> 222.             if not hasattr(dict, &quot;items&quot;):</font>
<font color="red"> 223.                 dict = type({})(dict)</font>
<font color="red"> 224.             for key, o in dict.items():</font>
<font color="red"> 225.                 d[key] = KeyedRef(o, self._remove, key)</font>
<font color="red"> 226.         if len(kwargs):</font>
<font color="red"> 227.             self.update(kwargs)</font>
<font color="black"> 228. </font>
<font color="red"> 229.     def valuerefs(self):</font>
<font color="black"> 230.         &quot;&quot;&quot;Return a list of weak references to the values.</font>
<font color="black"> 231. </font>
<font color="black"> 232.         The references are not guaranteed to be 'live' at the time</font>
<font color="black"> 233.         they are used, so the result of calling the references needs</font>
<font color="black"> 234.         to be checked before being used.  This can be used to avoid</font>
<font color="black"> 235.         creating references that will cause the garbage collector to</font>
<font color="black"> 236.         keep the values around longer than needed.</font>
<font color="black"> 237. </font>
<font color="black"> 238.         &quot;&quot;&quot;</font>
<font color="red"> 239.         return self.data.values()</font>
<font color="black"> 240. </font>
<font color="red"> 241.     def values(self):</font>
<font color="red"> 242.         L = []</font>
<font color="red"> 243.         for wr in self.data.values():</font>
<font color="red"> 244.             o = wr()</font>
<font color="red"> 245.             if o is not None:</font>
<font color="red"> 246.                 L.append(o)</font>
<font color="red"> 247.         return L</font>
<font color="black"> 248. </font>
<font color="black"> 249. </font>
<font color="red"> 250. class KeyedRef(ref):</font>
<font color="black"> 251.     &quot;&quot;&quot;Specialized reference that includes a key corresponding to the value.</font>
<font color="black"> 252. </font>
<font color="black"> 253.     This is used in the WeakValueDictionary to avoid having to create</font>
<font color="black"> 254.     a function object for each key stored in the mapping.  A shared</font>
<font color="black"> 255.     callback object can use the 'key' attribute of a KeyedRef instead</font>
<font color="black"> 256.     of getting a reference to the key from an enclosing scope.</font>
<font color="black"> 257. </font>
<font color="red"> 258.     &quot;&quot;&quot;</font>
<font color="black"> 259. </font>
<font color="red"> 260.     __slots__ = &quot;key&quot;,</font>
<font color="black"> 261. </font>
<font color="red"> 262.     def __new__(type, ob, callback, key):</font>
<font color="green"> 263.         self = ref.__new__(type, ob, callback)</font>
<font color="green"> 264.         self.key = key</font>
<font color="green"> 265.         return self</font>
<font color="black"> 266. </font>
<font color="red"> 267.     def __init__(self, ob, callback, key):</font>
<font color="green"> 268.         super(KeyedRef,  self).__init__(ob, callback)</font>
<font color="black"> 269. </font>
<font color="black"> 270. </font>
<font color="red"> 271. class WeakKeyDictionary(UserDict.UserDict):</font>
<font color="black"> 272.     &quot;&quot;&quot; Mapping class that references keys weakly.</font>
<font color="black"> 273. </font>
<font color="black"> 274.     Entries in the dictionary will be discarded when there is no</font>
<font color="black"> 275.     longer a strong reference to the key. This can be used to</font>
<font color="black"> 276.     associate additional data with an object owned by other parts of</font>
<font color="black"> 277.     an application without adding attributes to those objects. This</font>
<font color="black"> 278.     can be especially useful with objects that override attribute</font>
<font color="black"> 279.     accesses.</font>
<font color="red"> 280.     &quot;&quot;&quot;</font>
<font color="black"> 281. </font>
<font color="red"> 282.     def __init__(self, dict=None):</font>
<font color="green"> 283.         self.data = {}</font>
<font color="green"> 284.         def remove(k, selfref=ref(self)):</font>
<font color="red"> 285.             self = selfref()</font>
<font color="red"> 286.             if self is not None:</font>
<font color="red"> 287.                 if self._iterating:</font>
<font color="red"> 288.                     self._pending_removals.append(k)</font>
<font color="black"> 289.                 else:</font>
<font color="red"> 290.                     del self.data[k]</font>
<font color="green"> 291.         self._remove = remove</font>
<font color="black"> 292.         # A list of dead weakrefs (keys to be removed)</font>
<font color="green"> 293.         self._pending_removals = []</font>
<font color="green"> 294.         self._iterating = set()</font>
<font color="green"> 295.         if dict is not None:</font>
<font color="red"> 296.             self.update(dict)</font>
<font color="black"> 297. </font>
<font color="red"> 298.     def _commit_removals(self):</font>
<font color="black"> 299.         # NOTE: We don't need to call this method before mutating the dict,</font>
<font color="black"> 300.         # because a dead weakref never compares equal to a live weakref,</font>
<font color="black"> 301.         # even if they happened to refer to equal objects.</font>
<font color="black"> 302.         # However, it means keys may already have been removed.</font>
<font color="red"> 303.         l = self._pending_removals</font>
<font color="red"> 304.         d = self.data</font>
<font color="red"> 305.         while l:</font>
<font color="red"> 306.             try:</font>
<font color="red"> 307.                 del d[l.pop()]</font>
<font color="red"> 308.             except KeyError:</font>
<font color="red"> 309.                 pass</font>
<font color="black"> 310. </font>
<font color="red"> 311.     def __delitem__(self, key):</font>
<font color="red"> 312.         del self.data[ref(key)]</font>
<font color="black"> 313. </font>
<font color="red"> 314.     def __getitem__(self, key):</font>
<font color="red"> 315.         return self.data[ref(key)]</font>
<font color="black"> 316. </font>
<font color="red"> 317.     def __repr__(self):</font>
<font color="red"> 318.         return &quot;&lt;WeakKeyDictionary at %s&gt;&quot; % id(self)</font>
<font color="black"> 319. </font>
<font color="red"> 320.     def __setitem__(self, key, value):</font>
<font color="green"> 321.         self.data[ref(key, self._remove)] = value</font>
<font color="black"> 322. </font>
<font color="red"> 323.     def copy(self):</font>
<font color="red"> 324.         new = WeakKeyDictionary()</font>
<font color="red"> 325.         for key, value in self.data.items():</font>
<font color="red"> 326.             o = key()</font>
<font color="red"> 327.             if o is not None:</font>
<font color="red"> 328.                 new[o] = value</font>
<font color="red"> 329.         return new</font>
<font color="black"> 330. </font>
<font color="red"> 331.     __copy__ = copy</font>
<font color="black"> 332. </font>
<font color="red"> 333.     def __deepcopy__(self, memo):</font>
<font color="red"> 334.         from copy import deepcopy</font>
<font color="red"> 335.         new = self.__class__()</font>
<font color="red"> 336.         for key, value in self.data.items():</font>
<font color="red"> 337.             o = key()</font>
<font color="red"> 338.             if o is not None:</font>
<font color="red"> 339.                 new[o] = deepcopy(value, memo)</font>
<font color="red"> 340.         return new</font>
<font color="black"> 341. </font>
<font color="red"> 342.     def get(self, key, default=None):</font>
<font color="red"> 343.         return self.data.get(ref(key),default)</font>
<font color="black"> 344. </font>
<font color="red"> 345.     def has_key(self, key):</font>
<font color="red"> 346.         try:</font>
<font color="red"> 347.             wr = ref(key)</font>
<font color="red"> 348.         except TypeError:</font>
<font color="red"> 349.             return 0</font>
<font color="red"> 350.         return wr in self.data</font>
<font color="black"> 351. </font>
<font color="red"> 352.     def __contains__(self, key):</font>
<font color="red"> 353.         try:</font>
<font color="red"> 354.             wr = ref(key)</font>
<font color="red"> 355.         except TypeError:</font>
<font color="red"> 356.             return 0</font>
<font color="red"> 357.         return wr in self.data</font>
<font color="black"> 358. </font>
<font color="red"> 359.     def items(self):</font>
<font color="red"> 360.         L = []</font>
<font color="red"> 361.         for key, value in self.data.items():</font>
<font color="red"> 362.             o = key()</font>
<font color="red"> 363.             if o is not None:</font>
<font color="red"> 364.                 L.append((o, value))</font>
<font color="red"> 365.         return L</font>
<font color="black"> 366. </font>
<font color="red"> 367.     def iteritems(self):</font>
<font color="red"> 368.         with _IterationGuard(self):</font>
<font color="red"> 369.             for wr, value in self.data.iteritems():</font>
<font color="red"> 370.                 key = wr()</font>
<font color="red"> 371.                 if key is not None:</font>
<font color="red"> 372.                     yield key, value</font>
<font color="black"> 373. </font>
<font color="red"> 374.     def iterkeyrefs(self):</font>
<font color="black"> 375.         &quot;&quot;&quot;Return an iterator that yields the weak references to the keys.</font>
<font color="black"> 376. </font>
<font color="black"> 377.         The references are not guaranteed to be 'live' at the time</font>
<font color="black"> 378.         they are used, so the result of calling the references needs</font>
<font color="black"> 379.         to be checked before being used.  This can be used to avoid</font>
<font color="black"> 380.         creating references that will cause the garbage collector to</font>
<font color="black"> 381.         keep the keys around longer than needed.</font>
<font color="black"> 382. </font>
<font color="black"> 383.         &quot;&quot;&quot;</font>
<font color="red"> 384.         with _IterationGuard(self):</font>
<font color="red"> 385.             for wr in self.data.iterkeys():</font>
<font color="red"> 386.                 yield wr</font>
<font color="black"> 387. </font>
<font color="red"> 388.     def iterkeys(self):</font>
<font color="red"> 389.         with _IterationGuard(self):</font>
<font color="red"> 390.             for wr in self.data.iterkeys():</font>
<font color="red"> 391.                 obj = wr()</font>
<font color="red"> 392.                 if obj is not None:</font>
<font color="red"> 393.                     yield obj</font>
<font color="black"> 394. </font>
<font color="red"> 395.     __iter__ = iterkeys</font>
<font color="black"> 396. </font>
<font color="red"> 397.     def itervalues(self):</font>
<font color="red"> 398.         with _IterationGuard(self):</font>
<font color="red"> 399.             for value in self.data.itervalues():</font>
<font color="red"> 400.                 yield value</font>
<font color="black"> 401. </font>
<font color="red"> 402.     def keyrefs(self):</font>
<font color="black"> 403.         &quot;&quot;&quot;Return a list of weak references to the keys.</font>
<font color="black"> 404. </font>
<font color="black"> 405.         The references are not guaranteed to be 'live' at the time</font>
<font color="black"> 406.         they are used, so the result of calling the references needs</font>
<font color="black"> 407.         to be checked before being used.  This can be used to avoid</font>
<font color="black"> 408.         creating references that will cause the garbage collector to</font>
<font color="black"> 409.         keep the keys around longer than needed.</font>
<font color="black"> 410. </font>
<font color="black"> 411.         &quot;&quot;&quot;</font>
<font color="red"> 412.         return self.data.keys()</font>
<font color="black"> 413. </font>
<font color="red"> 414.     def keys(self):</font>
<font color="red"> 415.         L = []</font>
<font color="red"> 416.         for wr in self.data.keys():</font>
<font color="red"> 417.             o = wr()</font>
<font color="red"> 418.             if o is not None:</font>
<font color="red"> 419.                 L.append(o)</font>
<font color="red"> 420.         return L</font>
<font color="black"> 421. </font>
<font color="red"> 422.     def popitem(self):</font>
<font color="red"> 423.         while 1:</font>
<font color="red"> 424.             key, value = self.data.popitem()</font>
<font color="red"> 425.             o = key()</font>
<font color="red"> 426.             if o is not None:</font>
<font color="red"> 427.                 return o, value</font>
<font color="black"> 428. </font>
<font color="red"> 429.     def pop(self, key, *args):</font>
<font color="red"> 430.         return self.data.pop(ref(key), *args)</font>
<font color="black"> 431. </font>
<font color="red"> 432.     def setdefault(self, key, default=None):</font>
<font color="red"> 433.         return self.data.setdefault(ref(key, self._remove),default)</font>
<font color="black"> 434. </font>
<font color="red"> 435.     def update(self, dict=None, **kwargs):</font>
<font color="red"> 436.         d = self.data</font>
<font color="red"> 437.         if dict is not None:</font>
<font color="red"> 438.             if not hasattr(dict, &quot;items&quot;):</font>
<font color="red"> 439.                 dict = type({})(dict)</font>
<font color="red"> 440.             for key, value in dict.items():</font>
<font color="red"> 441.                 d[ref(key, self._remove)] = value</font>
<font color="red"> 442.         if len(kwargs):</font>
<font color="red"> 443.             self.update(kwargs)</font>
</pre>

