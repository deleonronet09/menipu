source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/fields/related_descriptors.py</b><br>


file stats: <b>569 lines, 54 executed: 9.5% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Accessors for related objects.</font>
<font color="black">   3. </font>
<font color="black">   4. When a field defines a relation between two models, each model class provides</font>
<font color="black">   5. an attribute to access related instances of the other model class (unless the</font>
<font color="black">   6. reverse accessor has been disabled with related_name='+').</font>
<font color="black">   7. </font>
<font color="black">   8. Accessors are implemented as descriptors in order to customize access and</font>
<font color="black">   9. assignment. This module defines the descriptor classes.</font>
<font color="black">  10. </font>
<font color="black">  11. Forward accessors follow foreign keys. Reverse accessors trace them back. For</font>
<font color="black">  12. example, with the following models::</font>
<font color="black">  13. </font>
<font color="black">  14.     class Parent(Model):</font>
<font color="black">  15.         pass</font>
<font color="black">  16. </font>
<font color="black">  17.     class Child(Model):</font>
<font color="black">  18.         parent = ForeignKey(Parent, related_name='children')</font>
<font color="black">  19. </font>
<font color="black">  20.  ``child.parent`` is a forward many-to-one relation. ``parent.children`` is a</font>
<font color="black">  21. reverse many-to-one relation.</font>
<font color="black">  22. </font>
<font color="black">  23. There are three types of relations (many-to-one, one-to-one, and many-to-many)</font>
<font color="black">  24. and two directions (forward and reverse) for a total of six combinations.</font>
<font color="black">  25. </font>
<font color="black">  26. 1. Related instance on the forward side of a many-to-one or one-to-one</font>
<font color="black">  27.    relation: ``ForwardManyToOneDescriptor``.</font>
<font color="black">  28. </font>
<font color="black">  29.    Uniqueness of foreign key values is irrelevant to accessing the related</font>
<font color="black">  30.    instance, making the many-to-one and one-to-one cases identical as far as</font>
<font color="black">  31.    the descriptor is concerned. The constraint is checked upstream (unicity</font>
<font color="black">  32.    validation in forms) or downstream (unique indexes in the database).</font>
<font color="black">  33. </font>
<font color="black">  34.    If you're looking for ``ForwardOneToOneDescriptor``, use</font>
<font color="black">  35.    ``ForwardManyToOneDescriptor`` instead.</font>
<font color="black">  36. </font>
<font color="black">  37. 2. Related instance on the reverse side of a one-to-one relation:</font>
<font color="black">  38.    ``ReverseOneToOneDescriptor``.</font>
<font color="black">  39. </font>
<font color="black">  40.    One-to-one relations are asymmetrical, despite the apparent symmetry of the</font>
<font color="black">  41.    name, because they're implemented in the database with a foreign key from</font>
<font color="black">  42.    one table to another. As a consequence ``ReverseOneToOneDescriptor`` is</font>
<font color="black">  43.    slightly different from ``ForwardManyToOneDescriptor``.</font>
<font color="black">  44. </font>
<font color="black">  45. 3. Related objects manager for related instances on the reverse side of a</font>
<font color="black">  46.    many-to-one relation: ``ReverseManyToOneDescriptor``.</font>
<font color="black">  47. </font>
<font color="black">  48.    Unlike the previous two classes, this one provides access to a collection</font>
<font color="black">  49.    of objects. It returns a manager rather than an instance.</font>
<font color="black">  50. </font>
<font color="black">  51. 4. Related objects manager for related instances on the forward or reverse</font>
<font color="black">  52.    sides of a many-to-many relation: ``ManyToManyDescriptor``.</font>
<font color="black">  53. </font>
<font color="black">  54.    Many-to-many relations are symmetrical. The syntax of Django models</font>
<font color="black">  55.    requires declaring them on one side but that's an implementation detail.</font>
<font color="black">  56.    They could be declared on the other side without any change in behavior.</font>
<font color="black">  57.    Therefore the forward and reverse descriptors can be the same.</font>
<font color="black">  58. </font>
<font color="black">  59.    If you're looking for ``ForwardManyToManyDescriptor`` or</font>
<font color="black">  60.    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.</font>
<font color="green">  61. &quot;&quot;&quot;</font>
<font color="black">  62. </font>
<font color="green">  63. from __future__ import unicode_literals</font>
<font color="black">  64. </font>
<font color="green">  65. from operator import attrgetter</font>
<font color="black">  66. </font>
<font color="green">  67. from django.db import connections, router, transaction</font>
<font color="green">  68. from django.db.models import Q, signals</font>
<font color="green">  69. from django.db.models.query import QuerySet</font>
<font color="green">  70. from django.utils.functional import cached_property</font>
<font color="black">  71. </font>
<font color="black">  72. </font>
<font color="green">  73. class ForwardManyToOneDescriptor(object):</font>
<font color="black">  74.     &quot;&quot;&quot;</font>
<font color="black">  75.     Accessor to the related object on the forward side of a many-to-one or</font>
<font color="black">  76.     one-to-one relation.</font>
<font color="black">  77. </font>
<font color="black">  78.     In the example::</font>
<font color="black">  79. </font>
<font color="black">  80.         class Child(Model):</font>
<font color="black">  81.             parent = ForeignKey(Parent, related_name='children')</font>
<font color="black">  82. </font>
<font color="black">  83.     ``child.parent`` is a ``ForwardManyToOneDescriptor`` instance.</font>
<font color="green">  84.     &quot;&quot;&quot;</font>
<font color="black">  85. </font>
<font color="green">  86.     def __init__(self, field_with_rel):</font>
<font color="green">  87.         self.field = field_with_rel</font>
<font color="green">  88.         self.cache_name = self.field.get_cache_name()</font>
<font color="black">  89. </font>
<font color="green">  90.     @cached_property</font>
<font color="black">  91.     def RelatedObjectDoesNotExist(self):</font>
<font color="black">  92.         # The exception can't be created at initialization time since the</font>
<font color="black">  93.         # related model might not be resolved yet; `rel.model` might still be</font>
<font color="black">  94.         # a string model reference.</font>
<font color="red">  95.         return type(</font>
<font color="red">  96.             str('RelatedObjectDoesNotExist'),</font>
<font color="red">  97.             (self.field.remote_field.model.DoesNotExist, AttributeError),</font>
<font color="red">  98.             {}</font>
<font color="black">  99.         )</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def is_cached(self, instance):</font>
<font color="red"> 102.         return hasattr(instance, self.cache_name)</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def get_queryset(self, **hints):</font>
<font color="red"> 105.         manager = self.field.remote_field.model._default_manager</font>
<font color="black"> 106.         # If the related manager indicates that it should be used for</font>
<font color="black"> 107.         # related fields, respect that.</font>
<font color="red"> 108.         if not getattr(manager, 'use_for_related_fields', False):</font>
<font color="red"> 109.             manager = self.field.remote_field.model._base_manager</font>
<font color="red"> 110.         return manager.db_manager(hints=hints).all()</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def get_prefetch_queryset(self, instances, queryset=None):</font>
<font color="red"> 113.         if queryset is None:</font>
<font color="red"> 114.             queryset = self.get_queryset()</font>
<font color="red"> 115.         queryset._add_hints(instance=instances[0])</font>
<font color="black"> 116. </font>
<font color="red"> 117.         rel_obj_attr = self.field.get_foreign_related_value</font>
<font color="red"> 118.         instance_attr = self.field.get_local_related_value</font>
<font color="red"> 119.         instances_dict = {instance_attr(inst): inst for inst in instances}</font>
<font color="red"> 120.         related_field = self.field.foreign_related_fields[0]</font>
<font color="black"> 121. </font>
<font color="black"> 122.         # FIXME: This will need to be revisited when we introduce support for</font>
<font color="black"> 123.         # composite fields. In the meantime we take this practical approach to</font>
<font color="black"> 124.         # solve a regression on 1.6 when the reverse manager in hidden</font>
<font color="black"> 125.         # (related_name ends with a '+'). Refs #21410.</font>
<font color="black"> 126.         # The check for len(...) == 1 is a special case that allows the query</font>
<font color="black"> 127.         # to be join-less and smaller. Refs #21760.</font>
<font color="red"> 128.         if self.field.remote_field.is_hidden() or len(self.field.foreign_related_fields) == 1:</font>
<font color="red"> 129.             query = {'%s__in' % related_field.name: set(instance_attr(inst)[0] for inst in instances)}</font>
<font color="black"> 130.         else:</font>
<font color="red"> 131.             query = {'%s__in' % self.field.related_query_name(): instances}</font>
<font color="red"> 132.         queryset = queryset.filter(**query)</font>
<font color="black"> 133. </font>
<font color="black"> 134.         # Since we're going to assign directly in the cache,</font>
<font color="black"> 135.         # we must manage the reverse relation cache manually.</font>
<font color="red"> 136.         if not self.field.remote_field.multiple:</font>
<font color="red"> 137.             rel_obj_cache_name = self.field.remote_field.get_cache_name()</font>
<font color="red"> 138.             for rel_obj in queryset:</font>
<font color="red"> 139.                 instance = instances_dict[rel_obj_attr(rel_obj)]</font>
<font color="red"> 140.                 setattr(rel_obj, rel_obj_cache_name, instance)</font>
<font color="red"> 141.         return queryset, rel_obj_attr, instance_attr, True, self.cache_name</font>
<font color="black"> 142. </font>
<font color="green"> 143.     def __get__(self, instance, instance_type=None):</font>
<font color="black"> 144.         &quot;&quot;&quot;</font>
<font color="black"> 145.         Get the related instance through the forward relation.</font>
<font color="black"> 146. </font>
<font color="black"> 147.         With the example above, when getting ``child.parent``:</font>
<font color="black"> 148. </font>
<font color="black"> 149.         - ``self`` is the descriptor managing the ``parent`` attribute</font>
<font color="black"> 150.         - ``instance`` is the ``child`` instance</font>
<font color="black"> 151.         - ``instance_type`` in the ``Child`` class (we don't need it)</font>
<font color="black"> 152.         &quot;&quot;&quot;</font>
<font color="red"> 153.         if instance is None:</font>
<font color="red"> 154.             return self</font>
<font color="black"> 155. </font>
<font color="black"> 156.         # The related instance is loaded from the database and then cached in</font>
<font color="black"> 157.         # the attribute defined in self.cache_name. It can also be pre-cached</font>
<font color="black"> 158.         # by the reverse accessor (ReverseOneToOneDescriptor).</font>
<font color="red"> 159.         try:</font>
<font color="red"> 160.             rel_obj = getattr(instance, self.cache_name)</font>
<font color="red"> 161.         except AttributeError:</font>
<font color="red"> 162.             val = self.field.get_local_related_value(instance)</font>
<font color="red"> 163.             if None in val:</font>
<font color="red"> 164.                 rel_obj = None</font>
<font color="black"> 165.             else:</font>
<font color="red"> 166.                 qs = self.get_queryset(instance=instance)</font>
<font color="red"> 167.                 qs = qs.filter(**self.field.get_reverse_related_filter(instance))</font>
<font color="black"> 168.                 # Assuming the database enforces foreign keys, this won't fail.</font>
<font color="red"> 169.                 rel_obj = qs.get()</font>
<font color="black"> 170.                 # If this is a one-to-one relation, set the reverse accessor</font>
<font color="black"> 171.                 # cache on the related object to the current instance to avoid</font>
<font color="black"> 172.                 # an extra SQL query if it's accessed later on.</font>
<font color="red"> 173.                 if not self.field.remote_field.multiple:</font>
<font color="red"> 174.                     setattr(rel_obj, self.field.remote_field.get_cache_name(), instance)</font>
<font color="red"> 175.             setattr(instance, self.cache_name, rel_obj)</font>
<font color="black"> 176. </font>
<font color="red"> 177.         if rel_obj is None and not self.field.null:</font>
<font color="red"> 178.             raise self.RelatedObjectDoesNotExist(</font>
<font color="red"> 179.                 &quot;%s has no %s.&quot; % (self.field.model.__name__, self.field.name)</font>
<font color="black"> 180.             )</font>
<font color="black"> 181.         else:</font>
<font color="red"> 182.             return rel_obj</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def __set__(self, instance, value):</font>
<font color="black"> 185.         &quot;&quot;&quot;</font>
<font color="black"> 186.         Set the related instance through the forward relation.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         With the example above, when setting ``child.parent = parent``:</font>
<font color="black"> 189. </font>
<font color="black"> 190.         - ``self`` is the descriptor managing the ``parent`` attribute</font>
<font color="black"> 191.         - ``instance`` is the ``child`` instance</font>
<font color="black"> 192.         - ``value`` in the ``parent`` instance on the right of the equal sign</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="black"> 194.         # If null=True, we can assign null here, but otherwise the value needs</font>
<font color="black"> 195.         # to be an instance of the related class.</font>
<font color="green"> 196.         if value is None and self.field.null is False:</font>
<font color="red"> 197.             raise ValueError(</font>
<font color="red"> 198.                 'Cannot assign None: &quot;%s.%s&quot; does not allow null values.' %</font>
<font color="red"> 199.                 (instance._meta.object_name, self.field.name)</font>
<font color="black"> 200.             )</font>
<font color="green"> 201.         elif value is not None and not isinstance(value, self.field.remote_field.model):</font>
<font color="red"> 202.             raise ValueError(</font>
<font color="red"> 203.                 'Cannot assign &quot;%r&quot;: &quot;%s.%s&quot; must be a &quot;%s&quot; instance.' % (</font>
<font color="red"> 204.                     value,</font>
<font color="red"> 205.                     instance._meta.object_name,</font>
<font color="red"> 206.                     self.field.name,</font>
<font color="red"> 207.                     self.field.remote_field.model._meta.object_name,</font>
<font color="black"> 208.                 )</font>
<font color="black"> 209.             )</font>
<font color="green"> 210.         elif value is not None:</font>
<font color="green"> 211.             if instance._state.db is None:</font>
<font color="green"> 212.                 instance._state.db = router.db_for_write(instance.__class__, instance=value)</font>
<font color="red"> 213.             elif value._state.db is None:</font>
<font color="red"> 214.                 value._state.db = router.db_for_write(value.__class__, instance=instance)</font>
<font color="red"> 215.             elif value._state.db is not None and instance._state.db is not None:</font>
<font color="red"> 216.                 if not router.allow_relation(value, instance):</font>
<font color="red"> 217.                     raise ValueError('Cannot assign &quot;%r&quot;: the current database router prevents this relation.' % value)</font>
<font color="black"> 218. </font>
<font color="black"> 219.         # If we're setting the value of a OneToOneField to None, we need to clear</font>
<font color="black"> 220.         # out the cache on any old related object. Otherwise, deleting the</font>
<font color="black"> 221.         # previously-related object will also cause this object to be deleted,</font>
<font color="black"> 222.         # which is wrong.</font>
<font color="green"> 223.         if value is None:</font>
<font color="black"> 224.             # Look up the previously-related object, which may still be available</font>
<font color="black"> 225.             # since we've not yet cleared out the related field.</font>
<font color="black"> 226.             # Use the cache directly, instead of the accessor; if we haven't</font>
<font color="black"> 227.             # populated the cache, then we don't care - we're only accessing</font>
<font color="black"> 228.             # the object to invalidate the accessor cache, so there's no</font>
<font color="black"> 229.             # need to populate the cache just to expire it again.</font>
<font color="red"> 230.             related = getattr(instance, self.cache_name, None)</font>
<font color="black"> 231. </font>
<font color="black"> 232.             # If we've got an old related object, we need to clear out its</font>
<font color="black"> 233.             # cache. This cache also might not exist if the related object</font>
<font color="black"> 234.             # hasn't been accessed yet.</font>
<font color="red"> 235.             if related is not None:</font>
<font color="red"> 236.                 setattr(related, self.field.remote_field.get_cache_name(), None)</font>
<font color="black"> 237. </font>
<font color="red"> 238.             for lh_field, rh_field in self.field.related_fields:</font>
<font color="red"> 239.                 setattr(instance, lh_field.attname, None)</font>
<font color="black"> 240. </font>
<font color="black"> 241.         # Set the values of the related field.</font>
<font color="black"> 242.         else:</font>
<font color="green"> 243.             for lh_field, rh_field in self.field.related_fields:</font>
<font color="green"> 244.                 setattr(instance, lh_field.attname, getattr(value, rh_field.attname))</font>
<font color="black"> 245. </font>
<font color="black"> 246.         # Set the related instance cache used by __get__ to avoid a SQL query</font>
<font color="black"> 247.         # when accessing the attribute we just set.</font>
<font color="green"> 248.         setattr(instance, self.cache_name, value)</font>
<font color="black"> 249. </font>
<font color="black"> 250.         # If this is a one-to-one relation, set the reverse accessor cache on</font>
<font color="black"> 251.         # the related object to the current instance to avoid an extra SQL</font>
<font color="black"> 252.         # query if it's accessed later on.</font>
<font color="green"> 253.         if value is not None and not self.field.remote_field.multiple:</font>
<font color="red"> 254.             setattr(value, self.field.remote_field.get_cache_name(), instance)</font>
<font color="black"> 255. </font>
<font color="black"> 256. </font>
<font color="green"> 257. class ReverseOneToOneDescriptor(object):</font>
<font color="black"> 258.     &quot;&quot;&quot;</font>
<font color="black"> 259.     Accessor to the related object on the reverse side of a one-to-one</font>
<font color="black"> 260.     relation.</font>
<font color="black"> 261. </font>
<font color="black"> 262.     In the example::</font>
<font color="black"> 263. </font>
<font color="black"> 264.         class Restaurant(Model):</font>
<font color="black"> 265.             place = OneToOneField(Place, related_name='restaurant')</font>
<font color="black"> 266. </font>
<font color="black"> 267.     ``place.restaurant`` is a ``ReverseOneToOneDescriptor`` instance.</font>
<font color="green"> 268.     &quot;&quot;&quot;</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def __init__(self, related):</font>
<font color="red"> 271.         self.related = related</font>
<font color="red"> 272.         self.cache_name = related.get_cache_name()</font>
<font color="black"> 273. </font>
<font color="green"> 274.     @cached_property</font>
<font color="black"> 275.     def RelatedObjectDoesNotExist(self):</font>
<font color="black"> 276.         # The exception isn't created at initialization time for the sake of</font>
<font color="black"> 277.         # consistency with `ForwardManyToOneDescriptor`.</font>
<font color="red"> 278.         return type(</font>
<font color="red"> 279.             str('RelatedObjectDoesNotExist'),</font>
<font color="red"> 280.             (self.related.related_model.DoesNotExist, AttributeError),</font>
<font color="red"> 281.             {}</font>
<font color="black"> 282.         )</font>
<font color="black"> 283. </font>
<font color="green"> 284.     def is_cached(self, instance):</font>
<font color="red"> 285.         return hasattr(instance, self.cache_name)</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def get_queryset(self, **hints):</font>
<font color="red"> 288.         manager = self.related.related_model._default_manager</font>
<font color="black"> 289.         # If the related manager indicates that it should be used for</font>
<font color="black"> 290.         # related fields, respect that.</font>
<font color="red"> 291.         if not getattr(manager, 'use_for_related_fields', False):</font>
<font color="red"> 292.             manager = self.related.related_model._base_manager</font>
<font color="red"> 293.         return manager.db_manager(hints=hints).all()</font>
<font color="black"> 294. </font>
<font color="green"> 295.     def get_prefetch_queryset(self, instances, queryset=None):</font>
<font color="red"> 296.         if queryset is None:</font>
<font color="red"> 297.             queryset = self.get_queryset()</font>
<font color="red"> 298.         queryset._add_hints(instance=instances[0])</font>
<font color="black"> 299. </font>
<font color="red"> 300.         rel_obj_attr = attrgetter(self.related.field.attname)</font>
<font color="red"> 301.         instance_attr = lambda obj: obj._get_pk_val()</font>
<font color="red"> 302.         instances_dict = {instance_attr(inst): inst for inst in instances}</font>
<font color="red"> 303.         query = {'%s__in' % self.related.field.name: instances}</font>
<font color="red"> 304.         queryset = queryset.filter(**query)</font>
<font color="black"> 305. </font>
<font color="black"> 306.         # Since we're going to assign directly in the cache,</font>
<font color="black"> 307.         # we must manage the reverse relation cache manually.</font>
<font color="red"> 308.         rel_obj_cache_name = self.related.field.get_cache_name()</font>
<font color="red"> 309.         for rel_obj in queryset:</font>
<font color="red"> 310.             instance = instances_dict[rel_obj_attr(rel_obj)]</font>
<font color="red"> 311.             setattr(rel_obj, rel_obj_cache_name, instance)</font>
<font color="red"> 312.         return queryset, rel_obj_attr, instance_attr, True, self.cache_name</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def __get__(self, instance, instance_type=None):</font>
<font color="black"> 315.         &quot;&quot;&quot;</font>
<font color="black"> 316.         Get the related instance through the reverse relation.</font>
<font color="black"> 317. </font>
<font color="black"> 318.         With the example above, when getting ``place.restaurant``:</font>
<font color="black"> 319. </font>
<font color="black"> 320.         - ``self`` is the descriptor managing the ``restaurant`` attribute</font>
<font color="black"> 321.         - ``instance`` is the ``place`` instance</font>
<font color="black"> 322.         - ``instance_type`` in the ``Place`` class (we don't need it)</font>
<font color="black"> 323. </font>
<font color="black"> 324.         Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.</font>
<font color="black"> 325.         &quot;&quot;&quot;</font>
<font color="red"> 326.         if instance is None:</font>
<font color="red"> 327.             return self</font>
<font color="black"> 328. </font>
<font color="black"> 329.         # The related instance is loaded from the database and then cached in</font>
<font color="black"> 330.         # the attribute defined in self.cache_name. It can also be pre-cached</font>
<font color="black"> 331.         # by the forward accessor (ForwardManyToOneDescriptor).</font>
<font color="red"> 332.         try:</font>
<font color="red"> 333.             rel_obj = getattr(instance, self.cache_name)</font>
<font color="red"> 334.         except AttributeError:</font>
<font color="red"> 335.             related_pk = instance._get_pk_val()</font>
<font color="red"> 336.             if related_pk is None:</font>
<font color="red"> 337.                 rel_obj = None</font>
<font color="black"> 338.             else:</font>
<font color="red"> 339.                 filter_args = self.related.field.get_forward_related_filter(instance)</font>
<font color="red"> 340.                 try:</font>
<font color="red"> 341.                     rel_obj = self.get_queryset(instance=instance).get(**filter_args)</font>
<font color="red"> 342.                 except self.related.related_model.DoesNotExist:</font>
<font color="red"> 343.                     rel_obj = None</font>
<font color="black"> 344.                 else:</font>
<font color="black"> 345.                     # Set the forward accessor cache on the related object to</font>
<font color="black"> 346.                     # the current instance to avoid an extra SQL query if it's</font>
<font color="black"> 347.                     # accessed later on.</font>
<font color="red"> 348.                     setattr(rel_obj, self.related.field.get_cache_name(), instance)</font>
<font color="red"> 349.             setattr(instance, self.cache_name, rel_obj)</font>
<font color="black"> 350. </font>
<font color="red"> 351.         if rel_obj is None:</font>
<font color="red"> 352.             raise self.RelatedObjectDoesNotExist(</font>
<font color="red"> 353.                 &quot;%s has no %s.&quot; % (</font>
<font color="red"> 354.                     instance.__class__.__name__,</font>
<font color="red"> 355.                     self.related.get_accessor_name()</font>
<font color="black"> 356.                 )</font>
<font color="black"> 357.             )</font>
<font color="black"> 358.         else:</font>
<font color="red"> 359.             return rel_obj</font>
<font color="black"> 360. </font>
<font color="green"> 361.     def __set__(self, instance, value):</font>
<font color="black"> 362.         &quot;&quot;&quot;</font>
<font color="black"> 363.         Set the related instance through the reverse relation.</font>
<font color="black"> 364. </font>
<font color="black"> 365.         With the example above, when setting ``place.restaurant = restaurant``:</font>
<font color="black"> 366. </font>
<font color="black"> 367.         - ``self`` is the descriptor managing the ``restaurant`` attribute</font>
<font color="black"> 368.         - ``instance`` is the ``place`` instance</font>
<font color="black"> 369.         - ``value`` in the ``restaurant`` instance on the right of the equal sign</font>
<font color="black"> 370. </font>
<font color="black"> 371.         Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.</font>
<font color="black"> 372.         &quot;&quot;&quot;</font>
<font color="black"> 373.         # The similarity of the code below to the code in</font>
<font color="black"> 374.         # ForwardManyToOneDescriptor is annoying, but there's a bunch</font>
<font color="black"> 375.         # of small differences that would make a common base class convoluted.</font>
<font color="black"> 376. </font>
<font color="black"> 377.         # If null=True, we can assign null here, but otherwise the value needs</font>
<font color="black"> 378.         # to be an instance of the related class.</font>
<font color="red"> 379.         if value is None:</font>
<font color="red"> 380.             if self.related.field.null:</font>
<font color="black"> 381.                 # Update the cached related instance (if any) &amp; clear the cache.</font>
<font color="red"> 382.                 try:</font>
<font color="red"> 383.                     rel_obj = getattr(instance, self.cache_name)</font>
<font color="red"> 384.                 except AttributeError:</font>
<font color="red"> 385.                     pass</font>
<font color="black"> 386.                 else:</font>
<font color="red"> 387.                     delattr(instance, self.cache_name)</font>
<font color="red"> 388.                     setattr(rel_obj, self.related.field.name, None)</font>
<font color="black"> 389.             else:</font>
<font color="red"> 390.                 raise ValueError(</font>
<font color="red"> 391.                     'Cannot assign None: &quot;%s.%s&quot; does not allow null values.' % (</font>
<font color="red"> 392.                         instance._meta.object_name,</font>
<font color="red"> 393.                         self.related.get_accessor_name(),</font>
<font color="black"> 394.                     )</font>
<font color="black"> 395.                 )</font>
<font color="red"> 396.         elif not isinstance(value, self.related.related_model):</font>
<font color="red"> 397.             raise ValueError(</font>
<font color="red"> 398.                 'Cannot assign &quot;%r&quot;: &quot;%s.%s&quot; must be a &quot;%s&quot; instance.' % (</font>
<font color="red"> 399.                     value,</font>
<font color="red"> 400.                     instance._meta.object_name,</font>
<font color="red"> 401.                     self.related.get_accessor_name(),</font>
<font color="red"> 402.                     self.related.related_model._meta.object_name,</font>
<font color="black"> 403.                 )</font>
<font color="black"> 404.             )</font>
<font color="black"> 405.         else:</font>
<font color="red"> 406.             if instance._state.db is None:</font>
<font color="red"> 407.                 instance._state.db = router.db_for_write(instance.__class__, instance=value)</font>
<font color="red"> 408.             elif value._state.db is None:</font>
<font color="red"> 409.                 value._state.db = router.db_for_write(value.__class__, instance=instance)</font>
<font color="red"> 410.             elif value._state.db is not None and instance._state.db is not None:</font>
<font color="red"> 411.                 if not router.allow_relation(value, instance):</font>
<font color="red"> 412.                     raise ValueError('Cannot assign &quot;%r&quot;: the current database router prevents this relation.' % value)</font>
<font color="black"> 413. </font>
<font color="red"> 414.             related_pk = tuple(getattr(instance, field.attname) for field in self.related.field.foreign_related_fields)</font>
<font color="black"> 415.             # Set the value of the related field to the value of the related object's related field</font>
<font color="red"> 416.             for index, field in enumerate(self.related.field.local_related_fields):</font>
<font color="red"> 417.                 setattr(value, field.attname, related_pk[index])</font>
<font color="black"> 418. </font>
<font color="black"> 419.             # Set the related instance cache used by __get__ to avoid a SQL query</font>
<font color="black"> 420.             # when accessing the attribute we just set.</font>
<font color="red"> 421.             setattr(instance, self.cache_name, value)</font>
<font color="black"> 422. </font>
<font color="black"> 423.             # Set the forward accessor cache on the related object to the current</font>
<font color="black"> 424.             # instance to avoid an extra SQL query if it's accessed later on.</font>
<font color="red"> 425.             setattr(value, self.related.field.get_cache_name(), instance)</font>
<font color="black"> 426. </font>
<font color="black"> 427. </font>
<font color="green"> 428. class ReverseManyToOneDescriptor(object):</font>
<font color="black"> 429.     &quot;&quot;&quot;</font>
<font color="black"> 430.     Accessor to the related objects manager on the reverse side of a</font>
<font color="black"> 431.     many-to-one relation.</font>
<font color="black"> 432. </font>
<font color="black"> 433.     In the example::</font>
<font color="black"> 434. </font>
<font color="black"> 435.         class Child(Model):</font>
<font color="black"> 436.             parent = ForeignKey(Parent, related_name='children')</font>
<font color="black"> 437. </font>
<font color="black"> 438.     ``parent.children`` is a ``ReverseManyToOneDescriptor`` instance.</font>
<font color="black"> 439. </font>
<font color="black"> 440.     Most of the implementation is delegated to a dynamically defined manager</font>
<font color="black"> 441.     class built by ``create_forward_many_to_many_manager()`` defined below.</font>
<font color="green"> 442.     &quot;&quot;&quot;</font>
<font color="black"> 443. </font>
<font color="green"> 444.     def __init__(self, rel):</font>
<font color="green"> 445.         self.rel = rel</font>
<font color="green"> 446.         self.field = rel.field</font>
<font color="black"> 447. </font>
<font color="green"> 448.     @cached_property</font>
<font color="black"> 449.     def related_manager_cls(self):</font>
<font color="red"> 450.         return create_reverse_many_to_one_manager(</font>
<font color="red"> 451.             self.rel.related_model._default_manager.__class__,</font>
<font color="red"> 452.             self.rel,</font>
<font color="black"> 453.         )</font>
<font color="black"> 454. </font>
<font color="green"> 455.     def __get__(self, instance, instance_type=None):</font>
<font color="black"> 456.         &quot;&quot;&quot;</font>
<font color="black"> 457.         Get the related objects through the reverse relation.</font>
<font color="black"> 458. </font>
<font color="black"> 459.         With the example above, when getting ``parent.children``:</font>
<font color="black"> 460. </font>
<font color="black"> 461.         - ``self`` is the descriptor managing the ``children`` attribute</font>
<font color="black"> 462.         - ``instance`` is the ``parent`` instance</font>
<font color="black"> 463.         - ``instance_type`` in the ``Parent`` class (we don't need it)</font>
<font color="black"> 464.         &quot;&quot;&quot;</font>
<font color="red"> 465.         if instance is None:</font>
<font color="red"> 466.             return self</font>
<font color="black"> 467. </font>
<font color="red"> 468.         return self.related_manager_cls(instance)</font>
<font color="black"> 469. </font>
<font color="green"> 470.     def __set__(self, instance, value):</font>
<font color="black"> 471.         &quot;&quot;&quot;</font>
<font color="black"> 472.         Set the related objects through the reverse relation.</font>
<font color="black"> 473. </font>
<font color="black"> 474.         With the example above, when setting ``parent.children = children``:</font>
<font color="black"> 475. </font>
<font color="black"> 476.         - ``self`` is the descriptor managing the ``children`` attribute</font>
<font color="black"> 477.         - ``instance`` is the ``parent`` instance</font>
<font color="black"> 478.         - ``value`` in the ``children`` sequence on the right of the equal sign</font>
<font color="black"> 479.         &quot;&quot;&quot;</font>
<font color="red"> 480.         manager = self.__get__(instance)</font>
<font color="red"> 481.         manager.set(value)</font>
<font color="black"> 482. </font>
<font color="black"> 483. </font>
<font color="green"> 484. def create_reverse_many_to_one_manager(superclass, rel):</font>
<font color="black"> 485.     &quot;&quot;&quot;</font>
<font color="black"> 486.     Create a manager for the reverse side of a many-to-one relation.</font>
<font color="black"> 487. </font>
<font color="black"> 488.     This manager subclasses another manager, generally the default manager of</font>
<font color="black"> 489.     the related model, and adds behaviors specific to many-to-one relations.</font>
<font color="black"> 490.     &quot;&quot;&quot;</font>
<font color="black"> 491. </font>
<font color="red"> 492.     class RelatedManager(superclass):</font>
<font color="red"> 493.         def __init__(self, instance):</font>
<font color="red"> 494.             super(RelatedManager, self).__init__()</font>
<font color="black"> 495. </font>
<font color="red"> 496.             self.instance = instance</font>
<font color="red"> 497.             self.model = rel.related_model</font>
<font color="red"> 498.             self.field = rel.field</font>
<font color="black"> 499. </font>
<font color="red"> 500.             self.core_filters = {self.field.name: instance}</font>
<font color="black"> 501. </font>
<font color="red"> 502.         def __call__(self, **kwargs):</font>
<font color="black"> 503.             # We use **kwargs rather than a kwarg argument to enforce the</font>
<font color="black"> 504.             # `manager='manager_name'` syntax.</font>
<font color="red"> 505.             manager = getattr(self.model, kwargs.pop('manager'))</font>
<font color="red"> 506.             manager_class = create_reverse_many_to_one_manager(manager.__class__, rel)</font>
<font color="red"> 507.             return manager_class(self.instance)</font>
<font color="red"> 508.         do_not_call_in_templates = True</font>
<font color="black"> 509. </font>
<font color="red"> 510.         def get_queryset(self):</font>
<font color="red"> 511.             try:</font>
<font color="red"> 512.                 return self.instance._prefetched_objects_cache[self.field.related_query_name()]</font>
<font color="red"> 513.             except (AttributeError, KeyError):</font>
<font color="red"> 514.                 db = self._db or router.db_for_read(self.model, instance=self.instance)</font>
<font color="red"> 515.                 empty_strings_as_null = connections[db].features.interprets_empty_strings_as_nulls</font>
<font color="red"> 516.                 qs = super(RelatedManager, self).get_queryset()</font>
<font color="red"> 517.                 qs._add_hints(instance=self.instance)</font>
<font color="red"> 518.                 if self._db:</font>
<font color="red"> 519.                     qs = qs.using(self._db)</font>
<font color="red"> 520.                 qs = qs.filter(**self.core_filters)</font>
<font color="red"> 521.                 for field in self.field.foreign_related_fields:</font>
<font color="red"> 522.                     val = getattr(self.instance, field.attname)</font>
<font color="red"> 523.                     if val is None or (val == '' and empty_strings_as_null):</font>
<font color="red"> 524.                         return qs.none()</font>
<font color="red"> 525.                 qs._known_related_objects = {self.field: {self.instance.pk: self.instance}}</font>
<font color="red"> 526.                 return qs</font>
<font color="black"> 527. </font>
<font color="red"> 528.         def get_prefetch_queryset(self, instances, queryset=None):</font>
<font color="red"> 529.             if queryset is None:</font>
<font color="red"> 530.                 queryset = super(RelatedManager, self).get_queryset()</font>
<font color="black"> 531. </font>
<font color="red"> 532.             queryset._add_hints(instance=instances[0])</font>
<font color="red"> 533.             queryset = queryset.using(queryset._db or self._db)</font>
<font color="black"> 534. </font>
<font color="red"> 535.             rel_obj_attr = self.field.get_local_related_value</font>
<font color="red"> 536.             instance_attr = self.field.get_foreign_related_value</font>
<font color="red"> 537.             instances_dict = {instance_attr(inst): inst for inst in instances}</font>
<font color="red"> 538.             query = {'%s__in' % self.field.name: instances}</font>
<font color="red"> 539.             queryset = queryset.filter(**query)</font>
<font color="black"> 540. </font>
<font color="black"> 541.             # Since we just bypassed this class' get_queryset(), we must manage</font>
<font color="black"> 542.             # the reverse relation manually.</font>
<font color="red"> 543.             for rel_obj in queryset:</font>
<font color="red"> 544.                 instance = instances_dict[rel_obj_attr(rel_obj)]</font>
<font color="red"> 545.                 setattr(rel_obj, self.field.name, instance)</font>
<font color="red"> 546.             cache_name = self.field.related_query_name()</font>
<font color="red"> 547.             return queryset, rel_obj_attr, instance_attr, False, cache_name</font>
<font color="black"> 548. </font>
<font color="red"> 549.         def add(self, *objs, **kwargs):</font>
<font color="red"> 550.             bulk = kwargs.pop('bulk', True)</font>
<font color="red"> 551.             objs = list(objs)</font>
<font color="red"> 552.             db = router.db_for_write(self.model, instance=self.instance)</font>
<font color="black"> 553. </font>
<font color="red"> 554.             def check_and_update_obj(obj):</font>
<font color="red"> 555.                 if not isinstance(obj, self.model):</font>
<font color="red"> 556.                     raise TypeError(&quot;'%s' instance expected, got %r&quot; % (</font>
<font color="red"> 557.                         self.model._meta.object_name, obj,</font>
<font color="black"> 558.                     ))</font>
<font color="red"> 559.                 setattr(obj, self.field.name, self.instance)</font>
<font color="black"> 560. </font>
<font color="red"> 561.             if bulk:</font>
<font color="red"> 562.                 pks = []</font>
<font color="red"> 563.                 for obj in objs:</font>
<font color="red"> 564.                     check_and_update_obj(obj)</font>
<font color="red"> 565.                     if obj._state.adding or obj._state.db != db:</font>
<font color="red"> 566.                         raise ValueError(</font>
<font color="red"> 567.                             &quot;%r instance isn't saved. Use bulk=False or save &quot;</font>
<font color="red"> 568.                             &quot;the object first.&quot; % obj</font>
<font color="black"> 569.                         )</font>
<font color="red"> 570.                     pks.append(obj.pk)</font>
<font color="red"> 571.                 self.model._base_manager.using(db).filter(pk__in=pks).update(**{</font>
<font color="red"> 572.                     self.field.name: self.instance,</font>
<font color="black"> 573.                 })</font>
<font color="black"> 574.             else:</font>
<font color="red"> 575.                 with transaction.atomic(using=db, savepoint=False):</font>
<font color="red"> 576.                     for obj in objs:</font>
<font color="red"> 577.                         check_and_update_obj(obj)</font>
<font color="red"> 578.                         obj.save()</font>
<font color="red"> 579.         add.alters_data = True</font>
<font color="black"> 580. </font>
<font color="red"> 581.         def create(self, **kwargs):</font>
<font color="red"> 582.             kwargs[self.field.name] = self.instance</font>
<font color="red"> 583.             db = router.db_for_write(self.model, instance=self.instance)</font>
<font color="red"> 584.             return super(RelatedManager, self.db_manager(db)).create(**kwargs)</font>
<font color="red"> 585.         create.alters_data = True</font>
<font color="black"> 586. </font>
<font color="red"> 587.         def get_or_create(self, **kwargs):</font>
<font color="red"> 588.             kwargs[self.field.name] = self.instance</font>
<font color="red"> 589.             db = router.db_for_write(self.model, instance=self.instance)</font>
<font color="red"> 590.             return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)</font>
<font color="red"> 591.         get_or_create.alters_data = True</font>
<font color="black"> 592. </font>
<font color="red"> 593.         def update_or_create(self, **kwargs):</font>
<font color="red"> 594.             kwargs[self.field.name] = self.instance</font>
<font color="red"> 595.             db = router.db_for_write(self.model, instance=self.instance)</font>
<font color="red"> 596.             return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)</font>
<font color="red"> 597.         update_or_create.alters_data = True</font>
<font color="black"> 598. </font>
<font color="black"> 599.         # remove() and clear() are only provided if the ForeignKey can have a value of null.</font>
<font color="red"> 600.         if rel.field.null:</font>
<font color="red"> 601.             def remove(self, *objs, **kwargs):</font>
<font color="red"> 602.                 if not objs:</font>
<font color="red"> 603.                     return</font>
<font color="red"> 604.                 bulk = kwargs.pop('bulk', True)</font>
<font color="red"> 605.                 val = self.field.get_foreign_related_value(self.instance)</font>
<font color="red"> 606.                 old_ids = set()</font>
<font color="red"> 607.                 for obj in objs:</font>
<font color="black"> 608.                     # Is obj actually part of this descriptor set?</font>
<font color="red"> 609.                     if self.field.get_local_related_value(obj) == val:</font>
<font color="red"> 610.                         old_ids.add(obj.pk)</font>
<font color="black"> 611.                     else:</font>
<font color="red"> 612.                         raise self.field.remote_field.model.DoesNotExist(</font>
<font color="red"> 613.                             &quot;%r is not related to %r.&quot; % (obj, self.instance)</font>
<font color="black"> 614.                         )</font>
<font color="red"> 615.                 self._clear(self.filter(pk__in=old_ids), bulk)</font>
<font color="red"> 616.             remove.alters_data = True</font>
<font color="black"> 617. </font>
<font color="red"> 618.             def clear(self, **kwargs):</font>
<font color="red"> 619.                 bulk = kwargs.pop('bulk', True)</font>
<font color="red"> 620.                 self._clear(self, bulk)</font>
<font color="red"> 621.             clear.alters_data = True</font>
<font color="black"> 622. </font>
<font color="red"> 623.             def _clear(self, queryset, bulk):</font>
<font color="red"> 624.                 db = router.db_for_write(self.model, instance=self.instance)</font>
<font color="red"> 625.                 queryset = queryset.using(db)</font>
<font color="red"> 626.                 if bulk:</font>
<font color="black"> 627.                     # `QuerySet.update()` is intrinsically atomic.</font>
<font color="red"> 628.                     queryset.update(**{self.field.name: None})</font>
<font color="black"> 629.                 else:</font>
<font color="red"> 630.                     with transaction.atomic(using=db, savepoint=False):</font>
<font color="red"> 631.                         for obj in queryset:</font>
<font color="red"> 632.                             setattr(obj, self.field.name, None)</font>
<font color="red"> 633.                             obj.save(update_fields=[self.field.name])</font>
<font color="red"> 634.             _clear.alters_data = True</font>
<font color="black"> 635. </font>
<font color="red"> 636.         def set(self, objs, **kwargs):</font>
<font color="black"> 637.             # Force evaluation of `objs` in case it's a queryset whose value</font>
<font color="black"> 638.             # could be affected by `manager.clear()`. Refs #19816.</font>
<font color="red"> 639.             objs = tuple(objs)</font>
<font color="black"> 640. </font>
<font color="red"> 641.             bulk = kwargs.pop('bulk', True)</font>
<font color="red"> 642.             clear = kwargs.pop('clear', False)</font>
<font color="black"> 643. </font>
<font color="red"> 644.             if self.field.null:</font>
<font color="red"> 645.                 db = router.db_for_write(self.model, instance=self.instance)</font>
<font color="red"> 646.                 with transaction.atomic(using=db, savepoint=False):</font>
<font color="red"> 647.                     if clear:</font>
<font color="red"> 648.                         self.clear()</font>
<font color="red"> 649.                         self.add(*objs, bulk=bulk)</font>
<font color="black"> 650.                     else:</font>
<font color="red"> 651.                         old_objs = set(self.using(db).all())</font>
<font color="red"> 652.                         new_objs = []</font>
<font color="red"> 653.                         for obj in objs:</font>
<font color="red"> 654.                             if obj in old_objs:</font>
<font color="red"> 655.                                 old_objs.remove(obj)</font>
<font color="black"> 656.                             else:</font>
<font color="red"> 657.                                 new_objs.append(obj)</font>
<font color="black"> 658. </font>
<font color="red"> 659.                         self.remove(*old_objs, bulk=bulk)</font>
<font color="red"> 660.                         self.add(*new_objs, bulk=bulk)</font>
<font color="black"> 661.             else:</font>
<font color="red"> 662.                 self.add(*objs, bulk=bulk)</font>
<font color="red"> 663.         set.alters_data = True</font>
<font color="black"> 664. </font>
<font color="red"> 665.     return RelatedManager</font>
<font color="black"> 666. </font>
<font color="black"> 667. </font>
<font color="green"> 668. class ManyToManyDescriptor(ReverseManyToOneDescriptor):</font>
<font color="black"> 669.     &quot;&quot;&quot;</font>
<font color="black"> 670.     Accessor to the related objects manager on the forward and reverse sides of</font>
<font color="black"> 671.     a many-to-many relation.</font>
<font color="black"> 672. </font>
<font color="black"> 673.     In the example::</font>
<font color="black"> 674. </font>
<font color="black"> 675.         class Pizza(Model):</font>
<font color="black"> 676.             toppings = ManyToManyField(Topping, related_name='pizzas')</font>
<font color="black"> 677. </font>
<font color="black"> 678.     ``pizza.toppings`` and ``topping.pizzas`` are ``ManyToManyDescriptor``</font>
<font color="black"> 679.     instances.</font>
<font color="black"> 680. </font>
<font color="black"> 681.     Most of the implementation is delegated to a dynamically defined manager</font>
<font color="black"> 682.     class built by ``create_forward_many_to_many_manager()`` defined below.</font>
<font color="green"> 683.     &quot;&quot;&quot;</font>
<font color="black"> 684. </font>
<font color="green"> 685.     def __init__(self, rel, reverse=False):</font>
<font color="green"> 686.         super(ManyToManyDescriptor, self).__init__(rel)</font>
<font color="black"> 687. </font>
<font color="green"> 688.         self.reverse = reverse</font>
<font color="black"> 689. </font>
<font color="green"> 690.     @property</font>
<font color="black"> 691.     def through(self):</font>
<font color="black"> 692.         # through is provided so that you have easy access to the through</font>
<font color="black"> 693.         # model (Book.authors.through) for inlines, etc. This is done as</font>
<font color="black"> 694.         # a property to ensure that the fully resolved value is returned.</font>
<font color="red"> 695.         return self.rel.through</font>
<font color="black"> 696. </font>
<font color="green"> 697.     @cached_property</font>
<font color="black"> 698.     def related_manager_cls(self):</font>
<font color="red"> 699.         model = self.rel.related_model if self.reverse else self.rel.model</font>
<font color="red"> 700.         return create_forward_many_to_many_manager(</font>
<font color="red"> 701.             model._default_manager.__class__,</font>
<font color="red"> 702.             self.rel,</font>
<font color="red"> 703.             reverse=self.reverse,</font>
<font color="black"> 704.         )</font>
<font color="black"> 705. </font>
<font color="black"> 706. </font>
<font color="green"> 707. def create_forward_many_to_many_manager(superclass, rel, reverse):</font>
<font color="black"> 708.     &quot;&quot;&quot;</font>
<font color="black"> 709.     Create a manager for the either side of a many-to-many relation.</font>
<font color="black"> 710. </font>
<font color="black"> 711.     This manager subclasses another manager, generally the default manager of</font>
<font color="black"> 712.     the related model, and adds behaviors specific to many-to-many relations.</font>
<font color="black"> 713.     &quot;&quot;&quot;</font>
<font color="black"> 714. </font>
<font color="red"> 715.     class ManyRelatedManager(superclass):</font>
<font color="red"> 716.         def __init__(self, instance=None):</font>
<font color="red"> 717.             super(ManyRelatedManager, self).__init__()</font>
<font color="black"> 718. </font>
<font color="red"> 719.             self.instance = instance</font>
<font color="black"> 720. </font>
<font color="red"> 721.             if not reverse:</font>
<font color="red"> 722.                 self.model = rel.model</font>
<font color="red"> 723.                 self.query_field_name = rel.field.related_query_name()</font>
<font color="red"> 724.                 self.prefetch_cache_name = rel.field.name</font>
<font color="red"> 725.                 self.source_field_name = rel.field.m2m_field_name()</font>
<font color="red"> 726.                 self.target_field_name = rel.field.m2m_reverse_field_name()</font>
<font color="red"> 727.                 self.symmetrical = rel.symmetrical</font>
<font color="black"> 728.             else:</font>
<font color="red"> 729.                 self.model = rel.related_model</font>
<font color="red"> 730.                 self.query_field_name = rel.field.name</font>
<font color="red"> 731.                 self.prefetch_cache_name = rel.field.related_query_name()</font>
<font color="red"> 732.                 self.source_field_name = rel.field.m2m_reverse_field_name()</font>
<font color="red"> 733.                 self.target_field_name = rel.field.m2m_field_name()</font>
<font color="red"> 734.                 self.symmetrical = False</font>
<font color="black"> 735. </font>
<font color="red"> 736.             self.through = rel.through</font>
<font color="red"> 737.             self.reverse = reverse</font>
<font color="black"> 738. </font>
<font color="red"> 739.             self.source_field = self.through._meta.get_field(self.source_field_name)</font>
<font color="red"> 740.             self.target_field = self.through._meta.get_field(self.target_field_name)</font>
<font color="black"> 741. </font>
<font color="red"> 742.             self.core_filters = {}</font>
<font color="red"> 743.             for lh_field, rh_field in self.source_field.related_fields:</font>
<font color="red"> 744.                 core_filter_key = '%s__%s' % (self.query_field_name, rh_field.name)</font>
<font color="red"> 745.                 self.core_filters[core_filter_key] = getattr(instance, rh_field.attname)</font>
<font color="black"> 746. </font>
<font color="red"> 747.             self.related_val = self.source_field.get_foreign_related_value(instance)</font>
<font color="red"> 748.             if None in self.related_val:</font>
<font color="red"> 749.                 raise ValueError('&quot;%r&quot; needs to have a value for field &quot;%s&quot; before '</font>
<font color="black"> 750.                                  'this many-to-many relationship can be used.' %</font>
<font color="red"> 751.                                  (instance, self.source_field_name))</font>
<font color="black"> 752.             # Even if this relation is not to pk, we require still pk value.</font>
<font color="black"> 753.             # The wish is that the instance has been already saved to DB,</font>
<font color="black"> 754.             # although having a pk value isn't a guarantee of that.</font>
<font color="red"> 755.             if instance.pk is None:</font>
<font color="red"> 756.                 raise ValueError(&quot;%r instance needs to have a primary key value before &quot;</font>
<font color="black"> 757.                                  &quot;a many-to-many relationship can be used.&quot; %</font>
<font color="red"> 758.                                  instance.__class__.__name__)</font>
<font color="black"> 759. </font>
<font color="red"> 760.         def __call__(self, **kwargs):</font>
<font color="black"> 761.             # We use **kwargs rather than a kwarg argument to enforce the</font>
<font color="black"> 762.             # `manager='manager_name'` syntax.</font>
<font color="red"> 763.             manager = getattr(self.model, kwargs.pop('manager'))</font>
<font color="red"> 764.             manager_class = create_forward_many_to_many_manager(manager.__class__, rel, reverse)</font>
<font color="red"> 765.             return manager_class(instance=self.instance)</font>
<font color="red"> 766.         do_not_call_in_templates = True</font>
<font color="black"> 767. </font>
<font color="red"> 768.         def _build_remove_filters(self, removed_vals):</font>
<font color="red"> 769.             filters = Q(**{self.source_field_name: self.related_val})</font>
<font color="black"> 770.             # No need to add a subquery condition if removed_vals is a QuerySet without</font>
<font color="black"> 771.             # filters.</font>
<font color="red"> 772.             removed_vals_filters = (not isinstance(removed_vals, QuerySet) or</font>
<font color="red"> 773.                                     removed_vals._has_filters())</font>
<font color="red"> 774.             if removed_vals_filters:</font>
<font color="red"> 775.                 filters &amp;= Q(**{'%s__in' % self.target_field_name: removed_vals})</font>
<font color="red"> 776.             if self.symmetrical:</font>
<font color="red"> 777.                 symmetrical_filters = Q(**{self.target_field_name: self.related_val})</font>
<font color="red"> 778.                 if removed_vals_filters:</font>
<font color="red"> 779.                     symmetrical_filters &amp;= Q(</font>
<font color="red"> 780.                         **{'%s__in' % self.source_field_name: removed_vals})</font>
<font color="red"> 781.                 filters |= symmetrical_filters</font>
<font color="red"> 782.             return filters</font>
<font color="black"> 783. </font>
<font color="red"> 784.         def get_queryset(self):</font>
<font color="red"> 785.             try:</font>
<font color="red"> 786.                 return self.instance._prefetched_objects_cache[self.prefetch_cache_name]</font>
<font color="red"> 787.             except (AttributeError, KeyError):</font>
<font color="red"> 788.                 qs = super(ManyRelatedManager, self).get_queryset()</font>
<font color="red"> 789.                 qs._add_hints(instance=self.instance)</font>
<font color="red"> 790.                 if self._db:</font>
<font color="red"> 791.                     qs = qs.using(self._db)</font>
<font color="red"> 792.                 return qs._next_is_sticky().filter(**self.core_filters)</font>
<font color="black"> 793. </font>
<font color="red"> 794.         def get_prefetch_queryset(self, instances, queryset=None):</font>
<font color="red"> 795.             if queryset is None:</font>
<font color="red"> 796.                 queryset = super(ManyRelatedManager, self).get_queryset()</font>
<font color="black"> 797. </font>
<font color="red"> 798.             queryset._add_hints(instance=instances[0])</font>
<font color="red"> 799.             queryset = queryset.using(queryset._db or self._db)</font>
<font color="black"> 800. </font>
<font color="red"> 801.             query = {'%s__in' % self.query_field_name: instances}</font>
<font color="red"> 802.             queryset = queryset._next_is_sticky().filter(**query)</font>
<font color="black"> 803. </font>
<font color="black"> 804.             # M2M: need to annotate the query in order to get the primary model</font>
<font color="black"> 805.             # that the secondary model was actually related to. We know that</font>
<font color="black"> 806.             # there will already be a join on the join table, so we can just add</font>
<font color="black"> 807.             # the select.</font>
<font color="black"> 808. </font>
<font color="black"> 809.             # For non-autocreated 'through' models, can't assume we are</font>
<font color="black"> 810.             # dealing with PK values.</font>
<font color="red"> 811.             fk = self.through._meta.get_field(self.source_field_name)</font>
<font color="red"> 812.             join_table = self.through._meta.db_table</font>
<font color="red"> 813.             connection = connections[queryset.db]</font>
<font color="red"> 814.             qn = connection.ops.quote_name</font>
<font color="red"> 815.             queryset = queryset.extra(select={</font>
<font color="red"> 816.                 '_prefetch_related_val_%s' % f.attname:</font>
<font color="red"> 817.                 '%s.%s' % (qn(join_table), qn(f.column)) for f in fk.local_related_fields})</font>
<font color="black"> 818.             return (</font>
<font color="red"> 819.                 queryset,</font>
<font color="red"> 820.                 lambda result: tuple(</font>
<font color="red"> 821.                     getattr(result, '_prefetch_related_val_%s' % f.attname)</font>
<font color="red"> 822.                     for f in fk.local_related_fields</font>
<font color="black"> 823.                 ),</font>
<font color="red"> 824.                 lambda inst: tuple(</font>
<font color="red"> 825.                     f.get_db_prep_value(getattr(inst, f.attname), connection)</font>
<font color="red"> 826.                     for f in fk.foreign_related_fields</font>
<font color="black"> 827.                 ),</font>
<font color="red"> 828.                 False,</font>
<font color="red"> 829.                 self.prefetch_cache_name,</font>
<font color="black"> 830.             )</font>
<font color="black"> 831. </font>
<font color="red"> 832.         def add(self, *objs):</font>
<font color="red"> 833.             if not rel.through._meta.auto_created:</font>
<font color="red"> 834.                 opts = self.through._meta</font>
<font color="red"> 835.                 raise AttributeError(</font>
<font color="red"> 836.                     &quot;Cannot use add() on a ManyToManyField which specifies an &quot;</font>
<font color="black"> 837.                     &quot;intermediary model. Use %s.%s's Manager instead.&quot; %</font>
<font color="red"> 838.                     (opts.app_label, opts.object_name)</font>
<font color="black"> 839.                 )</font>
<font color="black"> 840. </font>
<font color="red"> 841.             db = router.db_for_write(self.through, instance=self.instance)</font>
<font color="red"> 842.             with transaction.atomic(using=db, savepoint=False):</font>
<font color="red"> 843.                 self._add_items(self.source_field_name, self.target_field_name, *objs)</font>
<font color="black"> 844. </font>
<font color="black"> 845.                 # If this is a symmetrical m2m relation to self, add the mirror entry in the m2m table</font>
<font color="red"> 846.                 if self.symmetrical:</font>
<font color="red"> 847.                     self._add_items(self.target_field_name, self.source_field_name, *objs)</font>
<font color="red"> 848.         add.alters_data = True</font>
<font color="black"> 849. </font>
<font color="red"> 850.         def remove(self, *objs):</font>
<font color="red"> 851.             if not rel.through._meta.auto_created:</font>
<font color="red"> 852.                 opts = self.through._meta</font>
<font color="red"> 853.                 raise AttributeError(</font>
<font color="red"> 854.                     &quot;Cannot use remove() on a ManyToManyField which specifies &quot;</font>
<font color="black"> 855.                     &quot;an intermediary model. Use %s.%s's Manager instead.&quot; %</font>
<font color="red"> 856.                     (opts.app_label, opts.object_name)</font>
<font color="black"> 857.                 )</font>
<font color="red"> 858.             self._remove_items(self.source_field_name, self.target_field_name, *objs)</font>
<font color="red"> 859.         remove.alters_data = True</font>
<font color="black"> 860. </font>
<font color="red"> 861.         def clear(self):</font>
<font color="red"> 862.             db = router.db_for_write(self.through, instance=self.instance)</font>
<font color="red"> 863.             with transaction.atomic(using=db, savepoint=False):</font>
<font color="red"> 864.                 signals.m2m_changed.send(sender=self.through, action=&quot;pre_clear&quot;,</font>
<font color="red"> 865.                     instance=self.instance, reverse=self.reverse,</font>
<font color="red"> 866.                     model=self.model, pk_set=None, using=db)</font>
<font color="black"> 867. </font>
<font color="red"> 868.                 filters = self._build_remove_filters(super(ManyRelatedManager, self).get_queryset().using(db))</font>
<font color="red"> 869.                 self.through._default_manager.using(db).filter(filters).delete()</font>
<font color="black"> 870. </font>
<font color="red"> 871.                 signals.m2m_changed.send(sender=self.through, action=&quot;post_clear&quot;,</font>
<font color="red"> 872.                     instance=self.instance, reverse=self.reverse,</font>
<font color="red"> 873.                     model=self.model, pk_set=None, using=db)</font>
<font color="red"> 874.         clear.alters_data = True</font>
<font color="black"> 875. </font>
<font color="red"> 876.         def set(self, objs, **kwargs):</font>
<font color="red"> 877.             if not rel.through._meta.auto_created:</font>
<font color="red"> 878.                 opts = self.through._meta</font>
<font color="red"> 879.                 raise AttributeError(</font>
<font color="red"> 880.                     &quot;Cannot set values on a ManyToManyField which specifies an &quot;</font>
<font color="black"> 881.                     &quot;intermediary model. Use %s.%s's Manager instead.&quot; %</font>
<font color="red"> 882.                     (opts.app_label, opts.object_name)</font>
<font color="black"> 883.                 )</font>
<font color="black"> 884. </font>
<font color="black"> 885.             # Force evaluation of `objs` in case it's a queryset whose value</font>
<font color="black"> 886.             # could be affected by `manager.clear()`. Refs #19816.</font>
<font color="red"> 887.             objs = tuple(objs)</font>
<font color="black"> 888. </font>
<font color="red"> 889.             clear = kwargs.pop('clear', False)</font>
<font color="black"> 890. </font>
<font color="red"> 891.             db = router.db_for_write(self.through, instance=self.instance)</font>
<font color="red"> 892.             with transaction.atomic(using=db, savepoint=False):</font>
<font color="red"> 893.                 if clear:</font>
<font color="red"> 894.                     self.clear()</font>
<font color="red"> 895.                     self.add(*objs)</font>
<font color="black"> 896.                 else:</font>
<font color="red"> 897.                     old_ids = set(self.using(db).values_list(self.target_field.target_field.attname, flat=True))</font>
<font color="black"> 898. </font>
<font color="red"> 899.                     new_objs = []</font>
<font color="red"> 900.                     for obj in objs:</font>
<font color="black"> 901.                         fk_val = (self.target_field.get_foreign_related_value(obj)[0]</font>
<font color="red"> 902.                             if isinstance(obj, self.model) else obj)</font>
<font color="black"> 903. </font>
<font color="red"> 904.                         if fk_val in old_ids:</font>
<font color="red"> 905.                             old_ids.remove(fk_val)</font>
<font color="black"> 906.                         else:</font>
<font color="red"> 907.                             new_objs.append(obj)</font>
<font color="black"> 908. </font>
<font color="red"> 909.                     self.remove(*old_ids)</font>
<font color="red"> 910.                     self.add(*new_objs)</font>
<font color="red"> 911.         set.alters_data = True</font>
<font color="black"> 912. </font>
<font color="red"> 913.         def create(self, **kwargs):</font>
<font color="black"> 914.             # This check needs to be done here, since we can't later remove this</font>
<font color="black"> 915.             # from the method lookup table, as we do with add and remove.</font>
<font color="red"> 916.             if not self.through._meta.auto_created:</font>
<font color="red"> 917.                 opts = self.through._meta</font>
<font color="red"> 918.                 raise AttributeError(</font>
<font color="red"> 919.                     &quot;Cannot use create() on a ManyToManyField which specifies &quot;</font>
<font color="black"> 920.                     &quot;an intermediary model. Use %s.%s's Manager instead.&quot; %</font>
<font color="red"> 921.                     (opts.app_label, opts.object_name)</font>
<font color="black"> 922.                 )</font>
<font color="red"> 923.             db = router.db_for_write(self.instance.__class__, instance=self.instance)</font>
<font color="red"> 924.             new_obj = super(ManyRelatedManager, self.db_manager(db)).create(**kwargs)</font>
<font color="red"> 925.             self.add(new_obj)</font>
<font color="red"> 926.             return new_obj</font>
<font color="red"> 927.         create.alters_data = True</font>
<font color="black"> 928. </font>
<font color="red"> 929.         def get_or_create(self, **kwargs):</font>
<font color="red"> 930.             db = router.db_for_write(self.instance.__class__, instance=self.instance)</font>
<font color="red"> 931.             obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(**kwargs)</font>
<font color="black"> 932.             # We only need to add() if created because if we got an object back</font>
<font color="black"> 933.             # from get() then the relationship already exists.</font>
<font color="red"> 934.             if created:</font>
<font color="red"> 935.                 self.add(obj)</font>
<font color="red"> 936.             return obj, created</font>
<font color="red"> 937.         get_or_create.alters_data = True</font>
<font color="black"> 938. </font>
<font color="red"> 939.         def update_or_create(self, **kwargs):</font>
<font color="red"> 940.             db = router.db_for_write(self.instance.__class__, instance=self.instance)</font>
<font color="red"> 941.             obj, created = super(ManyRelatedManager, self.db_manager(db)).update_or_create(**kwargs)</font>
<font color="black"> 942.             # We only need to add() if created because if we got an object back</font>
<font color="black"> 943.             # from get() then the relationship already exists.</font>
<font color="red"> 944.             if created:</font>
<font color="red"> 945.                 self.add(obj)</font>
<font color="red"> 946.             return obj, created</font>
<font color="red"> 947.         update_or_create.alters_data = True</font>
<font color="black"> 948. </font>
<font color="red"> 949.         def _add_items(self, source_field_name, target_field_name, *objs):</font>
<font color="black"> 950.             # source_field_name: the PK fieldname in join table for the source object</font>
<font color="black"> 951.             # target_field_name: the PK fieldname in join table for the target object</font>
<font color="black"> 952.             # *objs - objects to add. Either object instances, or primary keys of object instances.</font>
<font color="black"> 953. </font>
<font color="black"> 954.             # If there aren't any objects, there is nothing to do.</font>
<font color="red"> 955.             from django.db.models import Model</font>
<font color="red"> 956.             if objs:</font>
<font color="red"> 957.                 new_ids = set()</font>
<font color="red"> 958.                 for obj in objs:</font>
<font color="red"> 959.                     if isinstance(obj, self.model):</font>
<font color="red"> 960.                         if not router.allow_relation(obj, self.instance):</font>
<font color="red"> 961.                             raise ValueError(</font>
<font color="red"> 962.                                 'Cannot add &quot;%r&quot;: instance is on database &quot;%s&quot;, value is on database &quot;%s&quot;' %</font>
<font color="red"> 963.                                 (obj, self.instance._state.db, obj._state.db)</font>
<font color="black"> 964.                             )</font>
<font color="red"> 965.                         fk_val = self.through._meta.get_field(</font>
<font color="red"> 966.                             target_field_name).get_foreign_related_value(obj)[0]</font>
<font color="red"> 967.                         if fk_val is None:</font>
<font color="red"> 968.                             raise ValueError(</font>
<font color="red"> 969.                                 'Cannot add &quot;%r&quot;: the value for field &quot;%s&quot; is None' %</font>
<font color="red"> 970.                                 (obj, target_field_name)</font>
<font color="black"> 971.                             )</font>
<font color="red"> 972.                         new_ids.add(fk_val)</font>
<font color="red"> 973.                     elif isinstance(obj, Model):</font>
<font color="red"> 974.                         raise TypeError(</font>
<font color="red"> 975.                             &quot;'%s' instance expected, got %r&quot; %</font>
<font color="red"> 976.                             (self.model._meta.object_name, obj)</font>
<font color="black"> 977.                         )</font>
<font color="black"> 978.                     else:</font>
<font color="red"> 979.                         new_ids.add(obj)</font>
<font color="black"> 980. </font>
<font color="red"> 981.                 db = router.db_for_write(self.through, instance=self.instance)</font>
<font color="red"> 982.                 vals = (self.through._default_manager.using(db)</font>
<font color="red"> 983.                         .values_list(target_field_name, flat=True)</font>
<font color="red"> 984.                         .filter(**{</font>
<font color="red"> 985.                             source_field_name: self.related_val[0],</font>
<font color="red"> 986.                             '%s__in' % target_field_name: new_ids,</font>
<font color="black"> 987.                         }))</font>
<font color="red"> 988.                 new_ids = new_ids - set(vals)</font>
<font color="black"> 989. </font>
<font color="red"> 990.                 with transaction.atomic(using=db, savepoint=False):</font>
<font color="red"> 991.                     if self.reverse or source_field_name == self.source_field_name:</font>
<font color="black"> 992.                         # Don't send the signal when we are inserting the</font>
<font color="black"> 993.                         # duplicate data row for symmetrical reverse entries.</font>
<font color="red"> 994.                         signals.m2m_changed.send(sender=self.through, action='pre_add',</font>
<font color="red"> 995.                             instance=self.instance, reverse=self.reverse,</font>
<font color="red"> 996.                             model=self.model, pk_set=new_ids, using=db)</font>
<font color="black"> 997. </font>
<font color="black"> 998.                     # Add the ones that aren't there already</font>
<font color="red"> 999.                     self.through._default_manager.using(db).bulk_create([</font>
<font color="red">1000.                         self.through(**{</font>
<font color="black">1001.                             '%s_id' % source_field_name: self.related_val[0],</font>
<font color="black">1002.                             '%s_id' % target_field_name: obj_id,</font>
<font color="black">1003.                         })</font>
<font color="red">1004.                         for obj_id in new_ids</font>
<font color="black">1005.                     ])</font>
<font color="black">1006. </font>
<font color="red">1007.                     if self.reverse or source_field_name == self.source_field_name:</font>
<font color="black">1008.                         # Don't send the signal when we are inserting the</font>
<font color="black">1009.                         # duplicate data row for symmetrical reverse entries.</font>
<font color="red">1010.                         signals.m2m_changed.send(sender=self.through, action='post_add',</font>
<font color="red">1011.                             instance=self.instance, reverse=self.reverse,</font>
<font color="red">1012.                             model=self.model, pk_set=new_ids, using=db)</font>
<font color="black">1013. </font>
<font color="red">1014.         def _remove_items(self, source_field_name, target_field_name, *objs):</font>
<font color="black">1015.             # source_field_name: the PK colname in join table for the source object</font>
<font color="black">1016.             # target_field_name: the PK colname in join table for the target object</font>
<font color="black">1017.             # *objs - objects to remove</font>
<font color="red">1018.             if not objs:</font>
<font color="red">1019.                 return</font>
<font color="black">1020. </font>
<font color="black">1021.             # Check that all the objects are of the right type</font>
<font color="red">1022.             old_ids = set()</font>
<font color="red">1023.             for obj in objs:</font>
<font color="red">1024.                 if isinstance(obj, self.model):</font>
<font color="red">1025.                     fk_val = self.target_field.get_foreign_related_value(obj)[0]</font>
<font color="red">1026.                     old_ids.add(fk_val)</font>
<font color="black">1027.                 else:</font>
<font color="red">1028.                     old_ids.add(obj)</font>
<font color="black">1029. </font>
<font color="red">1030.             db = router.db_for_write(self.through, instance=self.instance)</font>
<font color="red">1031.             with transaction.atomic(using=db, savepoint=False):</font>
<font color="black">1032.                 # Send a signal to the other end if need be.</font>
<font color="red">1033.                 signals.m2m_changed.send(sender=self.through, action=&quot;pre_remove&quot;,</font>
<font color="red">1034.                     instance=self.instance, reverse=self.reverse,</font>
<font color="red">1035.                     model=self.model, pk_set=old_ids, using=db)</font>
<font color="red">1036.                 target_model_qs = super(ManyRelatedManager, self).get_queryset()</font>
<font color="red">1037.                 if target_model_qs._has_filters():</font>
<font color="red">1038.                     old_vals = target_model_qs.using(db).filter(**{</font>
<font color="red">1039.                         '%s__in' % self.target_field.target_field.attname: old_ids})</font>
<font color="black">1040.                 else:</font>
<font color="red">1041.                     old_vals = old_ids</font>
<font color="red">1042.                 filters = self._build_remove_filters(old_vals)</font>
<font color="red">1043.                 self.through._default_manager.using(db).filter(filters).delete()</font>
<font color="black">1044. </font>
<font color="red">1045.                 signals.m2m_changed.send(sender=self.through, action=&quot;post_remove&quot;,</font>
<font color="red">1046.                     instance=self.instance, reverse=self.reverse,</font>
<font color="red">1047.                     model=self.model, pk_set=old_ids, using=db)</font>
<font color="black">1048. </font>
<font color="red">1049.     return ManyRelatedManager</font>
</pre>

