source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/module_loading.py</b><br>


file stats: <b>96 lines, 49 executed: 51.0% covered</b>
<pre>
<font color="green">   1. import copy</font>
<font color="green">   2. import os</font>
<font color="green">   3. import sys</font>
<font color="green">   4. from importlib import import_module</font>
<font color="black">   5. </font>
<font color="green">   6. from django.utils import six</font>
<font color="black">   7. </font>
<font color="black">   8. </font>
<font color="green">   9. def import_string(dotted_path):</font>
<font color="black">  10.     &quot;&quot;&quot;</font>
<font color="black">  11.     Import a dotted module path and return the attribute/class designated by the</font>
<font color="black">  12.     last name in the path. Raise ImportError if the import failed.</font>
<font color="black">  13.     &quot;&quot;&quot;</font>
<font color="green">  14.     try:</font>
<font color="green">  15.         module_path, class_name = dotted_path.rsplit('.', 1)</font>
<font color="red">  16.     except ValueError:</font>
<font color="red">  17.         msg = &quot;%s doesn't look like a module path&quot; % dotted_path</font>
<font color="red">  18.         six.reraise(ImportError, ImportError(msg), sys.exc_info()[2])</font>
<font color="black">  19. </font>
<font color="green">  20.     module = import_module(module_path)</font>
<font color="black">  21. </font>
<font color="green">  22.     try:</font>
<font color="green">  23.         return getattr(module, class_name)</font>
<font color="red">  24.     except AttributeError:</font>
<font color="red">  25.         msg = 'Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class' % (</font>
<font color="red">  26.             module_path, class_name)</font>
<font color="red">  27.         six.reraise(ImportError, ImportError(msg), sys.exc_info()[2])</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. def autodiscover_modules(*args, **kwargs):</font>
<font color="black">  31.     &quot;&quot;&quot;</font>
<font color="black">  32.     Auto-discover INSTALLED_APPS modules and fail silently when</font>
<font color="black">  33.     not present. This forces an import on them to register any admin bits they</font>
<font color="black">  34.     may want.</font>
<font color="black">  35. </font>
<font color="black">  36.     You may provide a register_to keyword parameter as a way to access a</font>
<font color="black">  37.     registry. This register_to object must have a _registry instance variable</font>
<font color="black">  38.     to access it.</font>
<font color="black">  39.     &quot;&quot;&quot;</font>
<font color="green">  40.     from django.apps import apps</font>
<font color="black">  41. </font>
<font color="green">  42.     register_to = kwargs.get('register_to')</font>
<font color="green">  43.     for app_config in apps.get_app_configs():</font>
<font color="green">  44.         for module_to_search in args:</font>
<font color="black">  45.             # Attempt to import the app's module.</font>
<font color="green">  46.             try:</font>
<font color="green">  47.                 if register_to:</font>
<font color="green">  48.                     before_import_registry = copy.copy(register_to._registry)</font>
<font color="black">  49. </font>
<font color="green">  50.                 import_module('%s.%s' % (app_config.name, module_to_search))</font>
<font color="green">  51.             except:</font>
<font color="black">  52.                 # Reset the registry to the state before the last import</font>
<font color="black">  53.                 # as this import will have to reoccur on the next request and</font>
<font color="black">  54.                 # this could raise NotRegistered and AlreadyRegistered</font>
<font color="black">  55.                 # exceptions (see #8245).</font>
<font color="green">  56.                 if register_to:</font>
<font color="green">  57.                     register_to._registry = before_import_registry</font>
<font color="black">  58. </font>
<font color="black">  59.                 # Decide whether to bubble up this error. If the app just</font>
<font color="black">  60.                 # doesn't have the module in question, we can ignore the error</font>
<font color="black">  61.                 # attempting to import it, otherwise we want it to bubble up.</font>
<font color="green">  62.                 if module_has_submodule(app_config.module, module_to_search):</font>
<font color="red">  63.                     raise</font>
<font color="black">  64. </font>
<font color="black">  65. </font>
<font color="green">  66. if six.PY3:</font>
<font color="red">  67.     from importlib.util import find_spec as importlib_find</font>
<font color="black">  68. </font>
<font color="red">  69.     def module_has_submodule(package, module_name):</font>
<font color="black">  70.         &quot;&quot;&quot;See if 'module' is in 'package'.&quot;&quot;&quot;</font>
<font color="red">  71.         try:</font>
<font color="red">  72.             package_name = package.__name__</font>
<font color="red">  73.             package_path = package.__path__</font>
<font color="red">  74.         except AttributeError:</font>
<font color="black">  75.             # package isn't a package.</font>
<font color="red">  76.             return False</font>
<font color="black">  77. </font>
<font color="red">  78.         full_module_name = package_name + '.' + module_name</font>
<font color="red">  79.         return importlib_find(full_module_name, package_path) is not None</font>
<font color="black">  80. </font>
<font color="black">  81. else:</font>
<font color="green">  82.     import imp</font>
<font color="black">  83. </font>
<font color="green">  84.     def module_has_submodule(package, module_name):</font>
<font color="black">  85.         &quot;&quot;&quot;See if 'module' is in 'package'.&quot;&quot;&quot;</font>
<font color="green">  86.         name = &quot;.&quot;.join([package.__name__, module_name])</font>
<font color="green">  87.         try:</font>
<font color="black">  88.             # None indicates a cached miss; see mark_miss() in Python/import.c.</font>
<font color="green">  89.             return sys.modules[name] is not None</font>
<font color="green">  90.         except KeyError:</font>
<font color="green">  91.             pass</font>
<font color="green">  92.         try:</font>
<font color="green">  93.             package_path = package.__path__   # No __path__, then not a package.</font>
<font color="red">  94.         except AttributeError:</font>
<font color="black">  95.             # Since the remainder of this function assumes that we're dealing with</font>
<font color="black">  96.             # a package (module with a __path__), so if it's not, then bail here.</font>
<font color="red">  97.             return False</font>
<font color="green">  98.         for finder in sys.meta_path:</font>
<font color="green">  99.             if finder.find_module(name, package_path):</font>
<font color="red"> 100.                 return True</font>
<font color="green"> 101.         for entry in package_path:</font>
<font color="green"> 102.             try:</font>
<font color="black"> 103.                 # Try the cached finder.</font>
<font color="green"> 104.                 finder = sys.path_importer_cache[entry]</font>
<font color="green"> 105.                 if finder is None:</font>
<font color="black"> 106.                     # Implicit import machinery should be used.</font>
<font color="green"> 107.                     try:</font>
<font color="green"> 108.                         file_, _, _ = imp.find_module(module_name, [entry])</font>
<font color="green"> 109.                         if file_:</font>
<font color="green"> 110.                             file_.close()</font>
<font color="green"> 111.                         return True</font>
<font color="green"> 112.                     except ImportError:</font>
<font color="green"> 113.                         continue</font>
<font color="black"> 114.                 # Else see if the finder knows of a loader.</font>
<font color="red"> 115.                 elif finder.find_module(name):</font>
<font color="red"> 116.                     return True</font>
<font color="black"> 117.                 else:</font>
<font color="red"> 118.                     continue</font>
<font color="red"> 119.             except KeyError:</font>
<font color="black"> 120.                 # No cached finder, so try and make one.</font>
<font color="red"> 121.                 for hook in sys.path_hooks:</font>
<font color="red"> 122.                     try:</font>
<font color="red"> 123.                         finder = hook(entry)</font>
<font color="black"> 124.                         # XXX Could cache in sys.path_importer_cache</font>
<font color="red"> 125.                         if finder.find_module(name):</font>
<font color="red"> 126.                             return True</font>
<font color="black"> 127.                         else:</font>
<font color="black"> 128.                             # Once a finder is found, stop the search.</font>
<font color="red"> 129.                             break</font>
<font color="red"> 130.                     except ImportError:</font>
<font color="black"> 131.                         # Continue the search for a finder.</font>
<font color="red"> 132.                         continue</font>
<font color="black"> 133.                 else:</font>
<font color="black"> 134.                     # No finder found.</font>
<font color="black"> 135.                     # Try the implicit import machinery if searching a directory.</font>
<font color="red"> 136.                     if os.path.isdir(entry):</font>
<font color="red"> 137.                         try:</font>
<font color="red"> 138.                             file_, _, _ = imp.find_module(module_name, [entry])</font>
<font color="red"> 139.                             if file_:</font>
<font color="red"> 140.                                 file_.close()</font>
<font color="red"> 141.                             return True</font>
<font color="red"> 142.                         except ImportError:</font>
<font color="red"> 143.                             pass</font>
<font color="black"> 144.                     # XXX Could insert None or NullImporter</font>
<font color="black"> 145.         else:</font>
<font color="black"> 146.             # Exhausted the search, so the module cannot be found.</font>
<font color="green"> 147.             return False</font>
<font color="black"> 148. </font>
<font color="black"> 149. </font>
<font color="green"> 150. def module_dir(module):</font>
<font color="black"> 151.     &quot;&quot;&quot;</font>
<font color="black"> 152.     Find the name of the directory that contains a module, if possible.</font>
<font color="black"> 153. </font>
<font color="black"> 154.     Raise ValueError otherwise, e.g. for namespace packages that are split</font>
<font color="black"> 155.     over several directories.</font>
<font color="black"> 156.     &quot;&quot;&quot;</font>
<font color="black"> 157.     # Convert to list because _NamespacePath does not support indexing on 3.3.</font>
<font color="red"> 158.     paths = list(getattr(module, '__path__', []))</font>
<font color="red"> 159.     if len(paths) == 1:</font>
<font color="red"> 160.         return paths[0]</font>
<font color="black"> 161.     else:</font>
<font color="red"> 162.         filename = getattr(module, '__file__', None)</font>
<font color="red"> 163.         if filename is not None:</font>
<font color="red"> 164.             return os.path.dirname(filename)</font>
<font color="red"> 165.     raise ValueError(&quot;Cannot determine directory containing %s&quot; % module)</font>
</pre>

