source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/files/base.py</b><br>


file stats: <b>120 lines, 40 executed: 33.3% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import os</font>
<font color="green">   4. from io import BytesIO, StringIO, UnsupportedOperation</font>
<font color="black">   5. </font>
<font color="green">   6. from django.core.files.utils import FileProxyMixin</font>
<font color="green">   7. from django.utils import six</font>
<font color="green">   8. from django.utils.encoding import (</font>
<font color="black">   9.     force_bytes, force_str, python_2_unicode_compatible, smart_text,</font>
<font color="black">  10. )</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. @python_2_unicode_compatible</font>
<font color="green">  14. class File(FileProxyMixin):</font>
<font color="green">  15.     DEFAULT_CHUNK_SIZE = 64 * 2 ** 10</font>
<font color="black">  16. </font>
<font color="green">  17.     def __init__(self, file, name=None):</font>
<font color="red">  18.         self.file = file</font>
<font color="red">  19.         if name is None:</font>
<font color="red">  20.             name = getattr(file, 'name', None)</font>
<font color="red">  21.         self.name = name</font>
<font color="red">  22.         if hasattr(file, 'mode'):</font>
<font color="red">  23.             self.mode = file.mode</font>
<font color="black">  24. </font>
<font color="green">  25.     def __str__(self):</font>
<font color="red">  26.         return smart_text(self.name or '')</font>
<font color="black">  27. </font>
<font color="green">  28.     def __repr__(self):</font>
<font color="red">  29.         return force_str(&quot;&lt;%s: %s&gt;&quot; % (self.__class__.__name__, self or &quot;None&quot;))</font>
<font color="black">  30. </font>
<font color="green">  31.     def __bool__(self):</font>
<font color="red">  32.         return bool(self.name)</font>
<font color="black">  33. </font>
<font color="green">  34.     def __nonzero__(self):      # Python 2 compatibility</font>
<font color="red">  35.         return type(self).__bool__(self)</font>
<font color="black">  36. </font>
<font color="green">  37.     def __len__(self):</font>
<font color="red">  38.         return self.size</font>
<font color="black">  39. </font>
<font color="green">  40.     def _get_size_from_underlying_file(self):</font>
<font color="red">  41.         if hasattr(self.file, 'size'):</font>
<font color="red">  42.             return self.file.size</font>
<font color="red">  43.         if hasattr(self.file, 'name'):</font>
<font color="red">  44.             try:</font>
<font color="red">  45.                 return os.path.getsize(self.file.name)</font>
<font color="red">  46.             except (OSError, TypeError):</font>
<font color="red">  47.                 pass</font>
<font color="red">  48.         if hasattr(self.file, 'tell') and hasattr(self.file, 'seek'):</font>
<font color="red">  49.             pos = self.file.tell()</font>
<font color="red">  50.             self.file.seek(0, os.SEEK_END)</font>
<font color="red">  51.             size = self.file.tell()</font>
<font color="red">  52.             self.file.seek(pos)</font>
<font color="red">  53.             return size</font>
<font color="red">  54.         raise AttributeError(&quot;Unable to determine the file's size.&quot;)</font>
<font color="black">  55. </font>
<font color="green">  56.     def _get_size(self):</font>
<font color="red">  57.         if hasattr(self, '_size'):</font>
<font color="red">  58.             return self._size</font>
<font color="red">  59.         self._size = self._get_size_from_underlying_file()</font>
<font color="red">  60.         return self._size</font>
<font color="black">  61. </font>
<font color="green">  62.     def _set_size(self, size):</font>
<font color="red">  63.         self._size = size</font>
<font color="black">  64. </font>
<font color="green">  65.     size = property(_get_size, _set_size)</font>
<font color="black">  66. </font>
<font color="green">  67.     def _get_closed(self):</font>
<font color="red">  68.         return not self.file or self.file.closed</font>
<font color="green">  69.     closed = property(_get_closed)</font>
<font color="black">  70. </font>
<font color="green">  71.     def chunks(self, chunk_size=None):</font>
<font color="black">  72.         &quot;&quot;&quot;</font>
<font color="black">  73.         Read the file and yield chunks of ``chunk_size`` bytes (defaults to</font>
<font color="black">  74.         ``UploadedFile.DEFAULT_CHUNK_SIZE``).</font>
<font color="black">  75.         &quot;&quot;&quot;</font>
<font color="red">  76.         if not chunk_size:</font>
<font color="red">  77.             chunk_size = self.DEFAULT_CHUNK_SIZE</font>
<font color="black">  78. </font>
<font color="red">  79.         try:</font>
<font color="red">  80.             self.seek(0)</font>
<font color="red">  81.         except (AttributeError, UnsupportedOperation):</font>
<font color="red">  82.             pass</font>
<font color="black">  83. </font>
<font color="red">  84.         while True:</font>
<font color="red">  85.             data = self.read(chunk_size)</font>
<font color="red">  86.             if not data:</font>
<font color="red">  87.                 break</font>
<font color="red">  88.             yield data</font>
<font color="black">  89. </font>
<font color="green">  90.     def multiple_chunks(self, chunk_size=None):</font>
<font color="black">  91.         &quot;&quot;&quot;</font>
<font color="black">  92.         Returns ``True`` if you can expect multiple chunks.</font>
<font color="black">  93. </font>
<font color="black">  94.         NB: If a particular file representation is in memory, subclasses should</font>
<font color="black">  95.         always return ``False`` -- there's no good reason to read from memory in</font>
<font color="black">  96.         chunks.</font>
<font color="black">  97.         &quot;&quot;&quot;</font>
<font color="red">  98.         if not chunk_size:</font>
<font color="red">  99.             chunk_size = self.DEFAULT_CHUNK_SIZE</font>
<font color="red"> 100.         return self.size &gt; chunk_size</font>
<font color="black"> 101. </font>
<font color="green"> 102.     def __iter__(self):</font>
<font color="black"> 103.         # Iterate over this file-like object by newlines</font>
<font color="red"> 104.         buffer_ = None</font>
<font color="red"> 105.         for chunk in self.chunks():</font>
<font color="red"> 106.             for line in chunk.splitlines(True):</font>
<font color="red"> 107.                 if buffer_:</font>
<font color="red"> 108.                     if endswith_cr(buffer_) and not equals_lf(line):</font>
<font color="black"> 109.                         # Line split after a \r newline; yield buffer_.</font>
<font color="red"> 110.                         yield buffer_</font>
<font color="black"> 111.                         # Continue with line.</font>
<font color="black"> 112.                     else:</font>
<font color="black"> 113.                         # Line either split without a newline (line</font>
<font color="black"> 114.                         # continues after buffer_) or with \r\n</font>
<font color="black"> 115.                         # newline (line == b'\n').</font>
<font color="red"> 116.                         line = buffer_ + line</font>
<font color="black"> 117.                     # buffer_ handled, clear it.</font>
<font color="red"> 118.                     buffer_ = None</font>
<font color="black"> 119. </font>
<font color="black"> 120.                 # If this is the end of a \n or \r\n line, yield.</font>
<font color="red"> 121.                 if endswith_lf(line):</font>
<font color="red"> 122.                     yield line</font>
<font color="black"> 123.                 else:</font>
<font color="red"> 124.                     buffer_ = line</font>
<font color="black"> 125. </font>
<font color="red"> 126.         if buffer_ is not None:</font>
<font color="red"> 127.             yield buffer_</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def __enter__(self):</font>
<font color="red"> 130.         return self</font>
<font color="black"> 131. </font>
<font color="green"> 132.     def __exit__(self, exc_type, exc_value, tb):</font>
<font color="red"> 133.         self.close()</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def open(self, mode=None):</font>
<font color="red"> 136.         if not self.closed:</font>
<font color="red"> 137.             self.seek(0)</font>
<font color="red"> 138.         elif self.name and os.path.exists(self.name):</font>
<font color="red"> 139.             self.file = open(self.name, mode or self.mode)</font>
<font color="black"> 140.         else:</font>
<font color="red"> 141.             raise ValueError(&quot;The file cannot be reopened.&quot;)</font>
<font color="black"> 142. </font>
<font color="green"> 143.     def close(self):</font>
<font color="red"> 144.         self.file.close()</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. @python_2_unicode_compatible</font>
<font color="green"> 148. class ContentFile(File):</font>
<font color="black"> 149.     &quot;&quot;&quot;</font>
<font color="black"> 150.     A File-like object that takes just raw content, rather than an actual file.</font>
<font color="green"> 151.     &quot;&quot;&quot;</font>
<font color="green"> 152.     def __init__(self, content, name=None):</font>
<font color="red"> 153.         if six.PY3:</font>
<font color="red"> 154.             stream_class = StringIO if isinstance(content, six.text_type) else BytesIO</font>
<font color="black"> 155.         else:</font>
<font color="red"> 156.             stream_class = BytesIO</font>
<font color="red"> 157.             content = force_bytes(content)</font>
<font color="red"> 158.         super(ContentFile, self).__init__(stream_class(content), name=name)</font>
<font color="red"> 159.         self.size = len(content)</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def __str__(self):</font>
<font color="red"> 162.         return 'Raw content'</font>
<font color="black"> 163. </font>
<font color="green"> 164.     def __bool__(self):</font>
<font color="red"> 165.         return True</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def __nonzero__(self):      # Python 2 compatibility</font>
<font color="red"> 168.         return type(self).__bool__(self)</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def open(self, mode=None):</font>
<font color="red"> 171.         self.seek(0)</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def close(self):</font>
<font color="red"> 174.         pass</font>
<font color="black"> 175. </font>
<font color="black"> 176. </font>
<font color="green"> 177. def endswith_cr(line):</font>
<font color="black"> 178.     &quot;&quot;&quot;</font>
<font color="black"> 179.     Return True if line (a text or byte string) ends with '\r'.</font>
<font color="black"> 180.     &quot;&quot;&quot;</font>
<font color="red"> 181.     return line.endswith('\r' if isinstance(line, six.text_type) else b'\r')</font>
<font color="black"> 182. </font>
<font color="black"> 183. </font>
<font color="green"> 184. def endswith_lf(line):</font>
<font color="black"> 185.     &quot;&quot;&quot;</font>
<font color="black"> 186.     Return True if line (a text or byte string) ends with '\n'.</font>
<font color="black"> 187.     &quot;&quot;&quot;</font>
<font color="red"> 188.     return line.endswith('\n' if isinstance(line, six.text_type) else b'\n')</font>
<font color="black"> 189. </font>
<font color="black"> 190. </font>
<font color="green"> 191. def equals_lf(line):</font>
<font color="black"> 192.     &quot;&quot;&quot;</font>
<font color="black"> 193.     Return True if line (a text or byte string) equals '\n'.</font>
<font color="black"> 194.     &quot;&quot;&quot;</font>
<font color="red"> 195.     return line == ('\n' if isinstance(line, six.text_type) else b'\n')</font>
</pre>

