source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/runtime.py</b><br>


file stats: <b>384 lines, 117 executed: 30.5% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.runtime</font>
<font color="black">   4.     ~~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Runtime helpers.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">   9.     :license: BSD.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. import sys</font>
<font color="black">  12. </font>
<font color="green">  13. from itertools import chain</font>
<font color="green">  14. from jinja2.nodes import EvalContext, _context_function_types</font>
<font color="green">  15. from jinja2.utils import Markup, soft_unicode, escape, missing, concat, \</font>
<font color="black">  16.      internalcode, object_type_repr</font>
<font color="green">  17. from jinja2.exceptions import UndefinedError, TemplateRuntimeError, \</font>
<font color="black">  18.      TemplateNotFound</font>
<font color="green">  19. from jinja2._compat import imap, text_type, iteritems, \</font>
<font color="black">  20.      implements_iterator, implements_to_string, string_types, PY2</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="black">  23. # these variables are exported to the template runtime</font>
<font color="green">  24. __all__ = ['LoopContext', 'TemplateReference', 'Macro', 'Markup',</font>
<font color="green">  25.            'TemplateRuntimeError', 'missing', 'concat', 'escape',</font>
<font color="green">  26.            'markup_join', 'unicode_join', 'to_string', 'identity',</font>
<font color="green">  27.            'TemplateNotFound', 'make_logging_undefined']</font>
<font color="black">  28. </font>
<font color="black">  29. #: the name of the function that is used to convert something into</font>
<font color="black">  30. #: a string.  We can just use the text type here.</font>
<font color="green">  31. to_string = text_type</font>
<font color="black">  32. </font>
<font color="black">  33. #: the identity function.  Useful for certain things in the environment</font>
<font color="green">  34. identity = lambda x: x</font>
<font color="black">  35. </font>
<font color="green">  36. _last_iteration = object()</font>
<font color="black">  37. </font>
<font color="black">  38. </font>
<font color="green">  39. def markup_join(seq):</font>
<font color="black">  40.     &quot;&quot;&quot;Concatenation that escapes if necessary and converts to unicode.&quot;&quot;&quot;</font>
<font color="red">  41.     buf = []</font>
<font color="red">  42.     iterator = imap(soft_unicode, seq)</font>
<font color="red">  43.     for arg in iterator:</font>
<font color="red">  44.         buf.append(arg)</font>
<font color="red">  45.         if hasattr(arg, '__html__'):</font>
<font color="red">  46.             return Markup(u'').join(chain(buf, iterator))</font>
<font color="red">  47.     return concat(buf)</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="green">  50. def unicode_join(seq):</font>
<font color="black">  51.     &quot;&quot;&quot;Simple args to unicode conversion and concatenation.&quot;&quot;&quot;</font>
<font color="red">  52.     return concat(imap(text_type, seq))</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. def new_context(environment, template_name, blocks, vars=None,</font>
<font color="green">  56.                 shared=None, globals=None, locals=None):</font>
<font color="black">  57.     &quot;&quot;&quot;Internal helper to for context creation.&quot;&quot;&quot;</font>
<font color="red">  58.     if vars is None:</font>
<font color="red">  59.         vars = {}</font>
<font color="red">  60.     if shared:</font>
<font color="red">  61.         parent = vars</font>
<font color="black">  62.     else:</font>
<font color="red">  63.         parent = dict(globals or (), **vars)</font>
<font color="red">  64.     if locals:</font>
<font color="black">  65.         # if the parent is shared a copy should be created because</font>
<font color="black">  66.         # we don't want to modify the dict passed</font>
<font color="red">  67.         if shared:</font>
<font color="red">  68.             parent = dict(parent)</font>
<font color="red">  69.         for key, value in iteritems(locals):</font>
<font color="red">  70.             if key[:2] == 'l_' and value is not missing:</font>
<font color="red">  71.                 parent[key[2:]] = value</font>
<font color="red">  72.     return environment.context_class(environment, parent, template_name,</font>
<font color="red">  73.                                      blocks)</font>
<font color="black">  74. </font>
<font color="black">  75. </font>
<font color="green">  76. class TemplateReference(object):</font>
<font color="green">  77.     &quot;&quot;&quot;The `self` in templates.&quot;&quot;&quot;</font>
<font color="black">  78. </font>
<font color="green">  79.     def __init__(self, context):</font>
<font color="red">  80.         self.__context = context</font>
<font color="black">  81. </font>
<font color="green">  82.     def __getitem__(self, name):</font>
<font color="red">  83.         blocks = self.__context.blocks[name]</font>
<font color="red">  84.         return BlockReference(name, self.__context, blocks, 0)</font>
<font color="black">  85. </font>
<font color="green">  86.     def __repr__(self):</font>
<font color="red">  87.         return '&lt;%s %r&gt;' % (</font>
<font color="red">  88.             self.__class__.__name__,</font>
<font color="red">  89.             self.__context.name</font>
<font color="black">  90.         )</font>
<font color="black">  91. </font>
<font color="black">  92. </font>
<font color="green">  93. class Context(object):</font>
<font color="black">  94.     &quot;&quot;&quot;The template context holds the variables of a template.  It stores the</font>
<font color="black">  95.     values passed to the template and also the names the template exports.</font>
<font color="black">  96.     Creating instances is neither supported nor useful as it's created</font>
<font color="black">  97.     automatically at various stages of the template evaluation and should not</font>
<font color="black">  98.     be created by hand.</font>
<font color="black">  99. </font>
<font color="black"> 100.     The context is immutable.  Modifications on :attr:`parent` **must not**</font>
<font color="black"> 101.     happen and modifications on :attr:`vars` are allowed from generated</font>
<font color="black"> 102.     template code only.  Template filters and global functions marked as</font>
<font color="black"> 103.     :func:`contextfunction`\s get the active context passed as first argument</font>
<font color="black"> 104.     and are allowed to access the context read-only.</font>
<font color="black"> 105. </font>
<font color="black"> 106.     The template context supports read only dict operations (`get`,</font>
<font color="black"> 107.     `keys`, `values`, `items`, `iterkeys`, `itervalues`, `iteritems`,</font>
<font color="black"> 108.     `__getitem__`, `__contains__`).  Additionally there is a :meth:`resolve`</font>
<font color="black"> 109.     method that doesn't fail with a `KeyError` but returns an</font>
<font color="black"> 110.     :class:`Undefined` object for missing variables.</font>
<font color="green"> 111.     &quot;&quot;&quot;</font>
<font color="black"> 112.     __slots__ = ('parent', 'vars', 'environment', 'eval_ctx', 'exported_vars',</font>
<font color="green"> 113.                  'name', 'blocks', '__weakref__')</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def __init__(self, environment, parent, name, blocks):</font>
<font color="red"> 116.         self.parent = parent</font>
<font color="red"> 117.         self.vars = {}</font>
<font color="red"> 118.         self.environment = environment</font>
<font color="red"> 119.         self.eval_ctx = EvalContext(self.environment, name)</font>
<font color="red"> 120.         self.exported_vars = set()</font>
<font color="red"> 121.         self.name = name</font>
<font color="black"> 122. </font>
<font color="black"> 123.         # create the initial mapping of blocks.  Whenever template inheritance</font>
<font color="black"> 124.         # takes place the runtime will update this mapping with the new blocks</font>
<font color="black"> 125.         # from the template.</font>
<font color="red"> 126.         self.blocks = dict((k, [v]) for k, v in iteritems(blocks))</font>
<font color="black"> 127. </font>
<font color="green"> 128.     def super(self, name, current):</font>
<font color="black"> 129.         &quot;&quot;&quot;Render a parent block.&quot;&quot;&quot;</font>
<font color="red"> 130.         try:</font>
<font color="red"> 131.             blocks = self.blocks[name]</font>
<font color="red"> 132.             index = blocks.index(current) + 1</font>
<font color="red"> 133.             blocks[index]</font>
<font color="red"> 134.         except LookupError:</font>
<font color="red"> 135.             return self.environment.undefined('there is no parent block '</font>
<font color="red"> 136.                                               'called %r.' % name,</font>
<font color="red"> 137.                                               name='super')</font>
<font color="red"> 138.         return BlockReference(name, self, blocks, index)</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def get(self, key, default=None):</font>
<font color="black"> 141.         &quot;&quot;&quot;Returns an item from the template context, if it doesn't exist</font>
<font color="black"> 142.         `default` is returned.</font>
<font color="black"> 143.         &quot;&quot;&quot;</font>
<font color="red"> 144.         try:</font>
<font color="red"> 145.             return self[key]</font>
<font color="red"> 146.         except KeyError:</font>
<font color="red"> 147.             return default</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def resolve(self, key):</font>
<font color="black"> 150.         &quot;&quot;&quot;Looks up a variable like `__getitem__` or `get` but returns an</font>
<font color="black"> 151.         :class:`Undefined` object with the name of the name looked up.</font>
<font color="black"> 152.         &quot;&quot;&quot;</font>
<font color="red"> 153.         if key in self.vars:</font>
<font color="red"> 154.             return self.vars[key]</font>
<font color="red"> 155.         if key in self.parent:</font>
<font color="red"> 156.             return self.parent[key]</font>
<font color="red"> 157.         return self.environment.undefined(name=key)</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def get_exported(self):</font>
<font color="black"> 160.         &quot;&quot;&quot;Get a new dict with the exported variables.&quot;&quot;&quot;</font>
<font color="red"> 161.         return dict((k, self.vars[k]) for k in self.exported_vars)</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def get_all(self):</font>
<font color="black"> 164.         &quot;&quot;&quot;Return a copy of the complete context as dict including the</font>
<font color="black"> 165.         exported variables.</font>
<font color="black"> 166.         &quot;&quot;&quot;</font>
<font color="red"> 167.         return dict(self.parent, **self.vars)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     @internalcode</font>
<font color="black"> 170.     def call(__self, __obj, *args, **kwargs):</font>
<font color="black"> 171.         &quot;&quot;&quot;Call the callable with the arguments and keyword arguments</font>
<font color="black"> 172.         provided but inject the active context or environment as first</font>
<font color="black"> 173.         argument if the callable is a :func:`contextfunction` or</font>
<font color="black"> 174.         :func:`environmentfunction`.</font>
<font color="black"> 175.         &quot;&quot;&quot;</font>
<font color="black"> 176.         if __debug__:</font>
<font color="red"> 177.             __traceback_hide__ = True  # noqa</font>
<font color="black"> 178. </font>
<font color="black"> 179.         # Allow callable classes to take a context</font>
<font color="red"> 180.         fn = __obj.__call__</font>
<font color="red"> 181.         for fn_type in ('contextfunction',</font>
<font color="black"> 182.                         'evalcontextfunction',</font>
<font color="red"> 183.                         'environmentfunction'):</font>
<font color="red"> 184.             if hasattr(fn, fn_type):</font>
<font color="red"> 185.                 __obj = fn</font>
<font color="red"> 186.                 break</font>
<font color="black"> 187. </font>
<font color="red"> 188.         if isinstance(__obj, _context_function_types):</font>
<font color="red"> 189.             if getattr(__obj, 'contextfunction', 0):</font>
<font color="red"> 190.                 args = (__self,) + args</font>
<font color="red"> 191.             elif getattr(__obj, 'evalcontextfunction', 0):</font>
<font color="red"> 192.                 args = (__self.eval_ctx,) + args</font>
<font color="red"> 193.             elif getattr(__obj, 'environmentfunction', 0):</font>
<font color="red"> 194.                 args = (__self.environment,) + args</font>
<font color="red"> 195.         try:</font>
<font color="red"> 196.             return __obj(*args, **kwargs)</font>
<font color="red"> 197.         except StopIteration:</font>
<font color="red"> 198.             return __self.environment.undefined('value was undefined because '</font>
<font color="black"> 199.                                                 'a callable raised a '</font>
<font color="black"> 200.                                                 'StopIteration exception')</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def derived(self, locals=None):</font>
<font color="black"> 203.         &quot;&quot;&quot;Internal helper function to create a derived context.&quot;&quot;&quot;</font>
<font color="red"> 204.         context = new_context(self.environment, self.name, {},</font>
<font color="red"> 205.                               self.parent, True, None, locals)</font>
<font color="red"> 206.         context.vars.update(self.vars)</font>
<font color="red"> 207.         context.eval_ctx = self.eval_ctx</font>
<font color="red"> 208.         context.blocks.update((k, list(v)) for k, v in iteritems(self.blocks))</font>
<font color="red"> 209.         return context</font>
<font color="black"> 210. </font>
<font color="green"> 211.     def _all(meth):</font>
<font color="green"> 212.         proxy = lambda self: getattr(self.get_all(), meth)()</font>
<font color="green"> 213.         proxy.__doc__ = getattr(dict, meth).__doc__</font>
<font color="green"> 214.         proxy.__name__ = meth</font>
<font color="green"> 215.         return proxy</font>
<font color="black"> 216. </font>
<font color="green"> 217.     keys = _all('keys')</font>
<font color="green"> 218.     values = _all('values')</font>
<font color="green"> 219.     items = _all('items')</font>
<font color="black"> 220. </font>
<font color="black"> 221.     # not available on python 3</font>
<font color="green"> 222.     if PY2:</font>
<font color="green"> 223.         iterkeys = _all('iterkeys')</font>
<font color="green"> 224.         itervalues = _all('itervalues')</font>
<font color="green"> 225.         iteritems = _all('iteritems')</font>
<font color="green"> 226.     del _all</font>
<font color="black"> 227. </font>
<font color="green"> 228.     def __contains__(self, name):</font>
<font color="red"> 229.         return name in self.vars or name in self.parent</font>
<font color="black"> 230. </font>
<font color="green"> 231.     def __getitem__(self, key):</font>
<font color="black"> 232.         &quot;&quot;&quot;Lookup a variable or raise `KeyError` if the variable is</font>
<font color="black"> 233.         undefined.</font>
<font color="black"> 234.         &quot;&quot;&quot;</font>
<font color="red"> 235.         item = self.resolve(key)</font>
<font color="red"> 236.         if isinstance(item, Undefined):</font>
<font color="red"> 237.             raise KeyError(key)</font>
<font color="red"> 238.         return item</font>
<font color="black"> 239. </font>
<font color="green"> 240.     def __repr__(self):</font>
<font color="red"> 241.         return '&lt;%s %s of %r&gt;' % (</font>
<font color="red"> 242.             self.__class__.__name__,</font>
<font color="red"> 243.             repr(self.get_all()),</font>
<font color="red"> 244.             self.name</font>
<font color="black"> 245.         )</font>
<font color="black"> 246. </font>
<font color="black"> 247. </font>
<font color="black"> 248. # register the context as mapping if possible</font>
<font color="green"> 249. try:</font>
<font color="green"> 250.     from collections import Mapping</font>
<font color="green"> 251.     Mapping.register(Context)</font>
<font color="red"> 252. except ImportError:</font>
<font color="red"> 253.     pass</font>
<font color="black"> 254. </font>
<font color="black"> 255. </font>
<font color="green"> 256. class BlockReference(object):</font>
<font color="green"> 257.     &quot;&quot;&quot;One block on a template reference.&quot;&quot;&quot;</font>
<font color="black"> 258. </font>
<font color="green"> 259.     def __init__(self, name, context, stack, depth):</font>
<font color="red"> 260.         self.name = name</font>
<font color="red"> 261.         self._context = context</font>
<font color="red"> 262.         self._stack = stack</font>
<font color="red"> 263.         self._depth = depth</font>
<font color="black"> 264. </font>
<font color="green"> 265.     @property</font>
<font color="black"> 266.     def super(self):</font>
<font color="black"> 267.         &quot;&quot;&quot;Super the block.&quot;&quot;&quot;</font>
<font color="red"> 268.         if self._depth + 1 &gt;= len(self._stack):</font>
<font color="red"> 269.             return self._context.environment. \</font>
<font color="red"> 270.                 undefined('there is no parent block called %r.' %</font>
<font color="red"> 271.                           self.name, name='super')</font>
<font color="red"> 272.         return BlockReference(self.name, self._context, self._stack,</font>
<font color="red"> 273.                               self._depth + 1)</font>
<font color="black"> 274. </font>
<font color="green"> 275.     @internalcode</font>
<font color="black"> 276.     def __call__(self):</font>
<font color="red"> 277.         rv = concat(self._stack[self._depth](self._context))</font>
<font color="red"> 278.         if self._context.eval_ctx.autoescape:</font>
<font color="red"> 279.             rv = Markup(rv)</font>
<font color="red"> 280.         return rv</font>
<font color="black"> 281. </font>
<font color="black"> 282. </font>
<font color="green"> 283. class LoopContext(object):</font>
<font color="green"> 284.     &quot;&quot;&quot;A loop context for dynamic iteration.&quot;&quot;&quot;</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def __init__(self, iterable, recurse=None, depth0=0):</font>
<font color="red"> 287.         self._iterator = iter(iterable)</font>
<font color="red"> 288.         self._recurse = recurse</font>
<font color="red"> 289.         self._after = self._safe_next()</font>
<font color="red"> 290.         self.index0 = -1</font>
<font color="red"> 291.         self.depth0 = depth0</font>
<font color="black"> 292. </font>
<font color="black"> 293.         # try to get the length of the iterable early.  This must be done</font>
<font color="black"> 294.         # here because there are some broken iterators around where there</font>
<font color="black"> 295.         # __len__ is the number of iterations left (i'm looking at your</font>
<font color="black"> 296.         # listreverseiterator!).</font>
<font color="red"> 297.         try:</font>
<font color="red"> 298.             self._length = len(iterable)</font>
<font color="red"> 299.         except (TypeError, AttributeError):</font>
<font color="red"> 300.             self._length = None</font>
<font color="black"> 301. </font>
<font color="green"> 302.     def cycle(self, *args):</font>
<font color="black"> 303.         &quot;&quot;&quot;Cycles among the arguments with the current loop index.&quot;&quot;&quot;</font>
<font color="red"> 304.         if not args:</font>
<font color="red"> 305.             raise TypeError('no items for cycling given')</font>
<font color="red"> 306.         return args[self.index0 % len(args)]</font>
<font color="black"> 307. </font>
<font color="green"> 308.     first = property(lambda x: x.index0 == 0)</font>
<font color="green"> 309.     last = property(lambda x: x._after is _last_iteration)</font>
<font color="green"> 310.     index = property(lambda x: x.index0 + 1)</font>
<font color="green"> 311.     revindex = property(lambda x: x.length - x.index0)</font>
<font color="green"> 312.     revindex0 = property(lambda x: x.length - x.index)</font>
<font color="green"> 313.     depth = property(lambda x: x.depth0 + 1)</font>
<font color="black"> 314. </font>
<font color="green"> 315.     def __len__(self):</font>
<font color="red"> 316.         return self.length</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def __iter__(self):</font>
<font color="red"> 319.         return LoopContextIterator(self)</font>
<font color="black"> 320. </font>
<font color="green"> 321.     def _safe_next(self):</font>
<font color="red"> 322.         try:</font>
<font color="red"> 323.             return next(self._iterator)</font>
<font color="red"> 324.         except StopIteration:</font>
<font color="red"> 325.             return _last_iteration</font>
<font color="black"> 326. </font>
<font color="green"> 327.     @internalcode</font>
<font color="black"> 328.     def loop(self, iterable):</font>
<font color="red"> 329.         if self._recurse is None:</font>
<font color="red"> 330.             raise TypeError('Tried to call non recursive loop.  Maybe you '</font>
<font color="black"> 331.                             &quot;forgot the 'recursive' modifier.&quot;)</font>
<font color="red"> 332.         return self._recurse(iterable, self._recurse, self.depth0 + 1)</font>
<font color="black"> 333. </font>
<font color="black"> 334.     # a nifty trick to enhance the error message if someone tried to call</font>
<font color="black"> 335.     # the the loop without or with too many arguments.</font>
<font color="green"> 336.     __call__ = loop</font>
<font color="green"> 337.     del loop</font>
<font color="black"> 338. </font>
<font color="green"> 339.     @property</font>
<font color="black"> 340.     def length(self):</font>
<font color="red"> 341.         if self._length is None:</font>
<font color="black"> 342.             # if was not possible to get the length of the iterator when</font>
<font color="black"> 343.             # the loop context was created (ie: iterating over a generator)</font>
<font color="black"> 344.             # we have to convert the iterable into a sequence and use the</font>
<font color="black"> 345.             # length of that + the number of iterations so far.</font>
<font color="red"> 346.             iterable = tuple(self._iterator)</font>
<font color="red"> 347.             self._iterator = iter(iterable)</font>
<font color="red"> 348.             iterations_done = self.index0 + 2</font>
<font color="red"> 349.             self._length = len(iterable) + iterations_done</font>
<font color="red"> 350.         return self._length</font>
<font color="black"> 351. </font>
<font color="green"> 352.     def __repr__(self):</font>
<font color="red"> 353.         return '&lt;%s %r/%r&gt;' % (</font>
<font color="red"> 354.             self.__class__.__name__,</font>
<font color="red"> 355.             self.index,</font>
<font color="red"> 356.             self.length</font>
<font color="black"> 357.         )</font>
<font color="black"> 358. </font>
<font color="black"> 359. </font>
<font color="green"> 360. @implements_iterator</font>
<font color="green"> 361. class LoopContextIterator(object):</font>
<font color="green"> 362.     &quot;&quot;&quot;The iterator for a loop context.&quot;&quot;&quot;</font>
<font color="green"> 363.     __slots__ = ('context',)</font>
<font color="black"> 364. </font>
<font color="green"> 365.     def __init__(self, context):</font>
<font color="red"> 366.         self.context = context</font>
<font color="black"> 367. </font>
<font color="green"> 368.     def __iter__(self):</font>
<font color="red"> 369.         return self</font>
<font color="black"> 370. </font>
<font color="green"> 371.     def __next__(self):</font>
<font color="red"> 372.         ctx = self.context</font>
<font color="red"> 373.         ctx.index0 += 1</font>
<font color="red"> 374.         if ctx._after is _last_iteration:</font>
<font color="red"> 375.             raise StopIteration()</font>
<font color="red"> 376.         next_elem = ctx._after</font>
<font color="red"> 377.         ctx._after = ctx._safe_next()</font>
<font color="red"> 378.         return next_elem, ctx</font>
<font color="black"> 379. </font>
<font color="black"> 380. </font>
<font color="green"> 381. class Macro(object):</font>
<font color="green"> 382.     &quot;&quot;&quot;Wraps a macro function.&quot;&quot;&quot;</font>
<font color="black"> 383. </font>
<font color="green"> 384.     def __init__(self, environment, func, name, arguments, defaults,</font>
<font color="black"> 385.                  catch_kwargs, catch_varargs, caller):</font>
<font color="red"> 386.         self._environment = environment</font>
<font color="red"> 387.         self._func = func</font>
<font color="red"> 388.         self._argument_count = len(arguments)</font>
<font color="red"> 389.         self.name = name</font>
<font color="red"> 390.         self.arguments = arguments</font>
<font color="red"> 391.         self.defaults = defaults</font>
<font color="red"> 392.         self.catch_kwargs = catch_kwargs</font>
<font color="red"> 393.         self.catch_varargs = catch_varargs</font>
<font color="red"> 394.         self.caller = caller</font>
<font color="black"> 395. </font>
<font color="green"> 396.     @internalcode</font>
<font color="black"> 397.     def __call__(self, *args, **kwargs):</font>
<font color="black"> 398.         # try to consume the positional arguments</font>
<font color="red"> 399.         arguments = list(args[:self._argument_count])</font>
<font color="red"> 400.         off = len(arguments)</font>
<font color="black"> 401. </font>
<font color="black"> 402.         # if the number of arguments consumed is not the number of</font>
<font color="black"> 403.         # arguments expected we start filling in keyword arguments</font>
<font color="black"> 404.         # and defaults.</font>
<font color="red"> 405.         if off != self._argument_count:</font>
<font color="red"> 406.             for idx, name in enumerate(self.arguments[len(arguments):]):</font>
<font color="red"> 407.                 try:</font>
<font color="red"> 408.                     value = kwargs.pop(name)</font>
<font color="red"> 409.                 except KeyError:</font>
<font color="red"> 410.                     try:</font>
<font color="red"> 411.                         value = self.defaults[idx - self._argument_count + off]</font>
<font color="red"> 412.                     except IndexError:</font>
<font color="red"> 413.                         value = self._environment.undefined(</font>
<font color="red"> 414.                             'parameter %r was not provided' % name, name=name)</font>
<font color="red"> 415.                 arguments.append(value)</font>
<font color="black"> 416. </font>
<font color="black"> 417.         # it's important that the order of these arguments does not change</font>
<font color="black"> 418.         # if not also changed in the compiler's `function_scoping` method.</font>
<font color="black"> 419.         # the order is caller, keyword arguments, positional arguments!</font>
<font color="red"> 420.         if self.caller:</font>
<font color="red"> 421.             caller = kwargs.pop('caller', None)</font>
<font color="red"> 422.             if caller is None:</font>
<font color="red"> 423.                 caller = self._environment.undefined('No caller defined',</font>
<font color="red"> 424.                                                      name='caller')</font>
<font color="red"> 425.             arguments.append(caller)</font>
<font color="red"> 426.         if self.catch_kwargs:</font>
<font color="red"> 427.             arguments.append(kwargs)</font>
<font color="red"> 428.         elif kwargs:</font>
<font color="red"> 429.             raise TypeError('macro %r takes no keyword argument %r' %</font>
<font color="red"> 430.                             (self.name, next(iter(kwargs))))</font>
<font color="red"> 431.         if self.catch_varargs:</font>
<font color="red"> 432.             arguments.append(args[self._argument_count:])</font>
<font color="red"> 433.         elif len(args) &gt; self._argument_count:</font>
<font color="red"> 434.             raise TypeError('macro %r takes not more than %d argument(s)' %</font>
<font color="red"> 435.                             (self.name, len(self.arguments)))</font>
<font color="red"> 436.         return self._func(*arguments)</font>
<font color="black"> 437. </font>
<font color="green"> 438.     def __repr__(self):</font>
<font color="red"> 439.         return '&lt;%s %s&gt;' % (</font>
<font color="red"> 440.             self.__class__.__name__,</font>
<font color="red"> 441.             self.name is None and 'anonymous' or repr(self.name)</font>
<font color="black"> 442.         )</font>
<font color="black"> 443. </font>
<font color="black"> 444. </font>
<font color="green"> 445. @implements_to_string</font>
<font color="green"> 446. class Undefined(object):</font>
<font color="black"> 447.     &quot;&quot;&quot;The default undefined type.  This undefined type can be printed and</font>
<font color="black"> 448.     iterated over, but every other access will raise an :exc:`jinja2.exceptions.UndefinedError`:</font>
<font color="black"> 449. </font>
<font color="black"> 450.     &gt;&gt;&gt; foo = Undefined(name='foo')</font>
<font color="black"> 451.     &gt;&gt;&gt; str(foo)</font>
<font color="black"> 452.     ''</font>
<font color="black"> 453.     &gt;&gt;&gt; not foo</font>
<font color="black"> 454.     True</font>
<font color="black"> 455.     &gt;&gt;&gt; foo + 42</font>
<font color="black"> 456.     Traceback (most recent call last):</font>
<font color="black"> 457.       ...</font>
<font color="black"> 458.     jinja2.exceptions.UndefinedError: 'foo' is undefined</font>
<font color="green"> 459.     &quot;&quot;&quot;</font>
<font color="black"> 460.     __slots__ = ('_undefined_hint', '_undefined_obj', '_undefined_name',</font>
<font color="green"> 461.                  '_undefined_exception')</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def __init__(self, hint=None, obj=missing, name=None, exc=UndefinedError):</font>
<font color="red"> 464.         self._undefined_hint = hint</font>
<font color="red"> 465.         self._undefined_obj = obj</font>
<font color="red"> 466.         self._undefined_name = name</font>
<font color="red"> 467.         self._undefined_exception = exc</font>
<font color="black"> 468. </font>
<font color="green"> 469.     @internalcode</font>
<font color="black"> 470.     def _fail_with_undefined_error(self, *args, **kwargs):</font>
<font color="black"> 471.         &quot;&quot;&quot;Regular callback function for undefined objects that raises an</font>
<font color="black"> 472.         `jinja2.exceptions.UndefinedError` on call.</font>
<font color="black"> 473.         &quot;&quot;&quot;</font>
<font color="red"> 474.         if self._undefined_hint is None:</font>
<font color="red"> 475.             if self._undefined_obj is missing:</font>
<font color="red"> 476.                 hint = '%r is undefined' % self._undefined_name</font>
<font color="red"> 477.             elif not isinstance(self._undefined_name, string_types):</font>
<font color="red"> 478.                 hint = '%s has no element %r' % (</font>
<font color="red"> 479.                     object_type_repr(self._undefined_obj),</font>
<font color="red"> 480.                     self._undefined_name</font>
<font color="black"> 481.                 )</font>
<font color="black"> 482.             else:</font>
<font color="red"> 483.                 hint = '%r has no attribute %r' % (</font>
<font color="red"> 484.                     object_type_repr(self._undefined_obj),</font>
<font color="red"> 485.                     self._undefined_name</font>
<font color="black"> 486.                 )</font>
<font color="black"> 487.         else:</font>
<font color="red"> 488.             hint = self._undefined_hint</font>
<font color="red"> 489.         raise self._undefined_exception(hint)</font>
<font color="black"> 490. </font>
<font color="green"> 491.     @internalcode</font>
<font color="black"> 492.     def __getattr__(self, name):</font>
<font color="red"> 493.         if name[:2] == '__':</font>
<font color="red"> 494.             raise AttributeError(name)</font>
<font color="red"> 495.         return self._fail_with_undefined_error()</font>
<font color="black"> 496. </font>
<font color="black"> 497.     __add__ = __radd__ = __mul__ = __rmul__ = __div__ = __rdiv__ = \</font>
<font color="black"> 498.         __truediv__ = __rtruediv__ = __floordiv__ = __rfloordiv__ = \</font>
<font color="black"> 499.         __mod__ = __rmod__ = __pos__ = __neg__ = __call__ = \</font>
<font color="black"> 500.         __getitem__ = __lt__ = __le__ = __gt__ = __ge__ = __int__ = \</font>
<font color="black"> 501.         __float__ = __complex__ = __pow__ = __rpow__ = \</font>
<font color="green"> 502.         _fail_with_undefined_error</font>
<font color="black"> 503. </font>
<font color="green"> 504.     def __eq__(self, other):</font>
<font color="red"> 505.         return type(self) is type(other)</font>
<font color="black"> 506. </font>
<font color="green"> 507.     def __ne__(self, other):</font>
<font color="red"> 508.         return not self.__eq__(other)</font>
<font color="black"> 509. </font>
<font color="green"> 510.     def __hash__(self):</font>
<font color="red"> 511.         return id(type(self))</font>
<font color="black"> 512. </font>
<font color="green"> 513.     def __str__(self):</font>
<font color="red"> 514.         return u''</font>
<font color="black"> 515. </font>
<font color="green"> 516.     def __len__(self):</font>
<font color="red"> 517.         return 0</font>
<font color="black"> 518. </font>
<font color="green"> 519.     def __iter__(self):</font>
<font color="red"> 520.         if 0:</font>
<font color="black"> 521.             yield None</font>
<font color="black"> 522. </font>
<font color="green"> 523.     def __nonzero__(self):</font>
<font color="red"> 524.         return False</font>
<font color="green"> 525.     __bool__ = __nonzero__</font>
<font color="black"> 526. </font>
<font color="green"> 527.     def __repr__(self):</font>
<font color="red"> 528.         return 'Undefined'</font>
<font color="black"> 529. </font>
<font color="black"> 530. </font>
<font color="green"> 531. def make_logging_undefined(logger=None, base=None):</font>
<font color="black"> 532.     &quot;&quot;&quot;Given a logger object this returns a new undefined class that will</font>
<font color="black"> 533.     log certain failures.  It will log iterations and printing.  If no</font>
<font color="black"> 534.     logger is given a default logger is created.</font>
<font color="black"> 535. </font>
<font color="black"> 536.     Example::</font>
<font color="black"> 537. </font>
<font color="black"> 538.         logger = logging.getLogger(__name__)</font>
<font color="black"> 539.         LoggingUndefined = make_logging_undefined(</font>
<font color="black"> 540.             logger=logger,</font>
<font color="black"> 541.             base=Undefined</font>
<font color="black"> 542.         )</font>
<font color="black"> 543. </font>
<font color="black"> 544.     .. versionadded:: 2.8</font>
<font color="black"> 545. </font>
<font color="black"> 546.     :param logger: the logger to use.  If not provided, a default logger</font>
<font color="black"> 547.                    is created.</font>
<font color="black"> 548.     :param base: the base class to add logging functionality to.  This</font>
<font color="black"> 549.                  defaults to :class:`Undefined`.</font>
<font color="black"> 550.     &quot;&quot;&quot;</font>
<font color="red"> 551.     if logger is None:</font>
<font color="red"> 552.         import logging</font>
<font color="red"> 553.         logger = logging.getLogger(__name__)</font>
<font color="red"> 554.         logger.addHandler(logging.StreamHandler(sys.stderr))</font>
<font color="red"> 555.     if base is None:</font>
<font color="red"> 556.         base = Undefined</font>
<font color="black"> 557. </font>
<font color="red"> 558.     def _log_message(undef):</font>
<font color="red"> 559.         if undef._undefined_hint is None:</font>
<font color="red"> 560.             if undef._undefined_obj is missing:</font>
<font color="red"> 561.                 hint = '%s is undefined' % undef._undefined_name</font>
<font color="red"> 562.             elif not isinstance(undef._undefined_name, string_types):</font>
<font color="red"> 563.                 hint = '%s has no element %s' % (</font>
<font color="red"> 564.                     object_type_repr(undef._undefined_obj),</font>
<font color="red"> 565.                     undef._undefined_name)</font>
<font color="black"> 566.             else:</font>
<font color="red"> 567.                 hint = '%s has no attribute %s' % (</font>
<font color="red"> 568.                     object_type_repr(undef._undefined_obj),</font>
<font color="red"> 569.                     undef._undefined_name)</font>
<font color="black"> 570.         else:</font>
<font color="red"> 571.             hint = undef._undefined_hint</font>
<font color="red"> 572.         logger.warning('Template variable warning: %s', hint)</font>
<font color="black"> 573. </font>
<font color="red"> 574.     class LoggingUndefined(base):</font>
<font color="black"> 575. </font>
<font color="red"> 576.         def _fail_with_undefined_error(self, *args, **kwargs):</font>
<font color="red"> 577.             try:</font>
<font color="red"> 578.                 return base._fail_with_undefined_error(self, *args, **kwargs)</font>
<font color="red"> 579.             except self._undefined_exception as e:</font>
<font color="red"> 580.                 logger.error('Template variable error: %s', str(e))</font>
<font color="red"> 581.                 raise e</font>
<font color="black"> 582. </font>
<font color="red"> 583.         def __str__(self):</font>
<font color="red"> 584.             rv = base.__str__(self)</font>
<font color="red"> 585.             _log_message(self)</font>
<font color="red"> 586.             return rv</font>
<font color="black"> 587. </font>
<font color="red"> 588.         def __iter__(self):</font>
<font color="red"> 589.             rv = base.__iter__(self)</font>
<font color="red"> 590.             _log_message(self)</font>
<font color="red"> 591.             return rv</font>
<font color="black"> 592. </font>
<font color="red"> 593.         if PY2:</font>
<font color="red"> 594.             def __nonzero__(self):</font>
<font color="red"> 595.                 rv = base.__nonzero__(self)</font>
<font color="red"> 596.                 _log_message(self)</font>
<font color="red"> 597.                 return rv</font>
<font color="black"> 598. </font>
<font color="red"> 599.             def __unicode__(self):</font>
<font color="red"> 600.                 rv = base.__unicode__(self)</font>
<font color="red"> 601.                 _log_message(self)</font>
<font color="red"> 602.                 return rv</font>
<font color="black"> 603.         else:</font>
<font color="red"> 604.             def __bool__(self):</font>
<font color="red"> 605.                 rv = base.__bool__(self)</font>
<font color="red"> 606.                 _log_message(self)</font>
<font color="red"> 607.                 return rv</font>
<font color="black"> 608. </font>
<font color="red"> 609.     return LoggingUndefined</font>
<font color="black"> 610. </font>
<font color="black"> 611. </font>
<font color="green"> 612. @implements_to_string</font>
<font color="green"> 613. class DebugUndefined(Undefined):</font>
<font color="black"> 614.     &quot;&quot;&quot;An undefined that returns the debug info when printed.</font>
<font color="black"> 615. </font>
<font color="black"> 616.     &gt;&gt;&gt; foo = DebugUndefined(name='foo')</font>
<font color="black"> 617.     &gt;&gt;&gt; str(foo)</font>
<font color="black"> 618.     '{{ foo }}'</font>
<font color="black"> 619.     &gt;&gt;&gt; not foo</font>
<font color="black"> 620.     True</font>
<font color="black"> 621.     &gt;&gt;&gt; foo + 42</font>
<font color="black"> 622.     Traceback (most recent call last):</font>
<font color="black"> 623.       ...</font>
<font color="black"> 624.     jinja2.exceptions.UndefinedError: 'foo' is undefined</font>
<font color="green"> 625.     &quot;&quot;&quot;</font>
<font color="green"> 626.     __slots__ = ()</font>
<font color="black"> 627. </font>
<font color="green"> 628.     def __str__(self):</font>
<font color="red"> 629.         if self._undefined_hint is None:</font>
<font color="red"> 630.             if self._undefined_obj is missing:</font>
<font color="red"> 631.                 return u'{{ %s }}' % self._undefined_name</font>
<font color="red"> 632.             return '{{ no such element: %s[%r] }}' % (</font>
<font color="red"> 633.                 object_type_repr(self._undefined_obj),</font>
<font color="red"> 634.                 self._undefined_name</font>
<font color="black"> 635.             )</font>
<font color="red"> 636.         return u'{{ undefined value printed: %s }}' % self._undefined_hint</font>
<font color="black"> 637. </font>
<font color="black"> 638. </font>
<font color="green"> 639. @implements_to_string</font>
<font color="green"> 640. class StrictUndefined(Undefined):</font>
<font color="black"> 641.     &quot;&quot;&quot;An undefined that barks on print and iteration as well as boolean</font>
<font color="black"> 642.     tests and all kinds of comparisons.  In other words: you can do nothing</font>
<font color="black"> 643.     with it except checking if it's defined using the `defined` test.</font>
<font color="black"> 644. </font>
<font color="black"> 645.     &gt;&gt;&gt; foo = StrictUndefined(name='foo')</font>
<font color="black"> 646.     &gt;&gt;&gt; str(foo)</font>
<font color="black"> 647.     Traceback (most recent call last):</font>
<font color="black"> 648.       ...</font>
<font color="black"> 649.     jinja2.exceptions.UndefinedError: 'foo' is undefined</font>
<font color="black"> 650.     &gt;&gt;&gt; not foo</font>
<font color="black"> 651.     Traceback (most recent call last):</font>
<font color="black"> 652.       ...</font>
<font color="black"> 653.     jinja2.exceptions.UndefinedError: 'foo' is undefined</font>
<font color="black"> 654.     &gt;&gt;&gt; foo + 42</font>
<font color="black"> 655.     Traceback (most recent call last):</font>
<font color="black"> 656.       ...</font>
<font color="black"> 657.     jinja2.exceptions.UndefinedError: 'foo' is undefined</font>
<font color="green"> 658.     &quot;&quot;&quot;</font>
<font color="green"> 659.     __slots__ = ()</font>
<font color="black"> 660.     __iter__ = __str__ = __len__ = __nonzero__ = __eq__ = \</font>
<font color="black"> 661.         __ne__ = __bool__ = __hash__ = \</font>
<font color="green"> 662.         Undefined._fail_with_undefined_error</font>
<font color="black"> 663. </font>
<font color="black"> 664. </font>
<font color="black"> 665. # remove remaining slots attributes, after the metaclass did the magic they</font>
<font color="black"> 666. # are unneeded and irritating as they contain wrong data for the subclasses.</font>
<font color="green"> 667. del Undefined.__slots__, DebugUndefined.__slots__, StrictUndefined.__slots__</font>
</pre>

