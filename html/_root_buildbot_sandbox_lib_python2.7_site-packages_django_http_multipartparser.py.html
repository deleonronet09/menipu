source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/http/multipartparser.py</b><br>


file stats: <b>386 lines, 64 executed: 16.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Multi-part parsing for file uploads.</font>
<font color="black">   3. </font>
<font color="black">   4. Exposes one class, ``MultiPartParser``, which feeds chunks of uploaded data to</font>
<font color="black">   5. file upload handlers for processing.</font>
<font color="green">   6. &quot;&quot;&quot;</font>
<font color="green">   7. from __future__ import unicode_literals</font>
<font color="black">   8. </font>
<font color="green">   9. import base64</font>
<font color="green">  10. import binascii</font>
<font color="green">  11. import cgi</font>
<font color="green">  12. import sys</font>
<font color="black">  13. </font>
<font color="green">  14. from django.conf import settings</font>
<font color="green">  15. from django.core.exceptions import SuspiciousMultipartForm</font>
<font color="green">  16. from django.core.files.uploadhandler import (</font>
<font color="black">  17.     SkipFile, StopFutureHandlers, StopUpload,</font>
<font color="black">  18. )</font>
<font color="green">  19. from django.utils import six</font>
<font color="green">  20. from django.utils.datastructures import MultiValueDict</font>
<font color="green">  21. from django.utils.encoding import force_text</font>
<font color="green">  22. from django.utils.six.moves.urllib.parse import unquote</font>
<font color="green">  23. from django.utils.text import unescape_entities</font>
<font color="black">  24. </font>
<font color="green">  25. __all__ = ('MultiPartParser', 'MultiPartParserError', 'InputStreamExhausted')</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="green">  28. class MultiPartParserError(Exception):</font>
<font color="green">  29.     pass</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. class InputStreamExhausted(Exception):</font>
<font color="black">  33.     &quot;&quot;&quot;</font>
<font color="black">  34.     No more reads are allowed from this device.</font>
<font color="green">  35.     &quot;&quot;&quot;</font>
<font color="green">  36.     pass</font>
<font color="black">  37. </font>
<font color="green">  38. RAW = &quot;raw&quot;</font>
<font color="green">  39. FILE = &quot;file&quot;</font>
<font color="green">  40. FIELD = &quot;field&quot;</font>
<font color="black">  41. </font>
<font color="green">  42. _BASE64_DECODE_ERROR = TypeError if six.PY2 else binascii.Error</font>
<font color="black">  43. </font>
<font color="black">  44. </font>
<font color="green">  45. class MultiPartParser(object):</font>
<font color="black">  46.     &quot;&quot;&quot;</font>
<font color="black">  47.     A rfc2388 multipart/form-data parser.</font>
<font color="black">  48. </font>
<font color="black">  49.     ``MultiValueDict.parse()`` reads the input stream in ``chunk_size`` chunks</font>
<font color="black">  50.     and returns a tuple of ``(MultiValueDict(POST), MultiValueDict(FILES))``.</font>
<font color="green">  51.     &quot;&quot;&quot;</font>
<font color="green">  52.     def __init__(self, META, input_data, upload_handlers, encoding=None):</font>
<font color="black">  53.         &quot;&quot;&quot;</font>
<font color="black">  54.         Initialize the MultiPartParser object.</font>
<font color="black">  55. </font>
<font color="black">  56.         :META:</font>
<font color="black">  57.             The standard ``META`` dictionary in Django request objects.</font>
<font color="black">  58.         :input_data:</font>
<font color="black">  59.             The raw post data, as a file-like object.</font>
<font color="black">  60.         :upload_handlers:</font>
<font color="black">  61.             A list of UploadHandler instances that perform operations on the uploaded</font>
<font color="black">  62.             data.</font>
<font color="black">  63.         :encoding:</font>
<font color="black">  64.             The encoding with which to treat the incoming data.</font>
<font color="black">  65.         &quot;&quot;&quot;</font>
<font color="black">  66. </font>
<font color="black">  67.         #</font>
<font color="black">  68.         # Content-Type should contain multipart and the boundary information.</font>
<font color="black">  69.         #</font>
<font color="black">  70. </font>
<font color="red">  71.         content_type = META.get('HTTP_CONTENT_TYPE', META.get('CONTENT_TYPE', ''))</font>
<font color="red">  72.         if not content_type.startswith('multipart/'):</font>
<font color="red">  73.             raise MultiPartParserError('Invalid Content-Type: %s' % content_type)</font>
<font color="black">  74. </font>
<font color="black">  75.         # Parse the header to get the boundary to split the parts.</font>
<font color="red">  76.         ctypes, opts = parse_header(content_type.encode('ascii'))</font>
<font color="red">  77.         boundary = opts.get('boundary')</font>
<font color="red">  78.         if not boundary or not cgi.valid_boundary(boundary):</font>
<font color="red">  79.             raise MultiPartParserError('Invalid boundary in multipart: %s' % boundary)</font>
<font color="black">  80. </font>
<font color="black">  81.         # Content-Length should contain the length of the body we are about</font>
<font color="black">  82.         # to receive.</font>
<font color="red">  83.         try:</font>
<font color="red">  84.             content_length = int(META.get('HTTP_CONTENT_LENGTH', META.get('CONTENT_LENGTH', 0)))</font>
<font color="red">  85.         except (ValueError, TypeError):</font>
<font color="red">  86.             content_length = 0</font>
<font color="black">  87. </font>
<font color="red">  88.         if content_length &lt; 0:</font>
<font color="black">  89.             # This means we shouldn't continue...raise an error.</font>
<font color="red">  90.             raise MultiPartParserError(&quot;Invalid content length: %r&quot; % content_length)</font>
<font color="black">  91. </font>
<font color="red">  92.         if isinstance(boundary, six.text_type):</font>
<font color="red">  93.             boundary = boundary.encode('ascii')</font>
<font color="red">  94.         self._boundary = boundary</font>
<font color="red">  95.         self._input_data = input_data</font>
<font color="black">  96. </font>
<font color="black">  97.         # For compatibility with low-level network APIs (with 32-bit integers),</font>
<font color="black">  98.         # the chunk size should be &lt; 2^31, but still divisible by 4.</font>
<font color="red">  99.         possible_sizes = [x.chunk_size for x in upload_handlers if x.chunk_size]</font>
<font color="red"> 100.         self._chunk_size = min([2 ** 31 - 4] + possible_sizes)</font>
<font color="black"> 101. </font>
<font color="red"> 102.         self._meta = META</font>
<font color="red"> 103.         self._encoding = encoding or settings.DEFAULT_CHARSET</font>
<font color="red"> 104.         self._content_length = content_length</font>
<font color="red"> 105.         self._upload_handlers = upload_handlers</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def parse(self):</font>
<font color="black"> 108.         &quot;&quot;&quot;</font>
<font color="black"> 109.         Parse the POST data and break it into a FILES MultiValueDict and a POST</font>
<font color="black"> 110.         MultiValueDict.</font>
<font color="black"> 111. </font>
<font color="black"> 112.         Returns a tuple containing the POST and FILES dictionary, respectively.</font>
<font color="black"> 113.         &quot;&quot;&quot;</font>
<font color="black"> 114.         # We have to import QueryDict down here to avoid a circular import.</font>
<font color="red"> 115.         from django.http import QueryDict</font>
<font color="black"> 116. </font>
<font color="red"> 117.         encoding = self._encoding</font>
<font color="red"> 118.         handlers = self._upload_handlers</font>
<font color="black"> 119. </font>
<font color="black"> 120.         # HTTP spec says that Content-Length &gt;= 0 is valid</font>
<font color="black"> 121.         # handling content-length == 0 before continuing</font>
<font color="red"> 122.         if self._content_length == 0:</font>
<font color="red"> 123.             return QueryDict('', encoding=self._encoding), MultiValueDict()</font>
<font color="black"> 124. </font>
<font color="black"> 125.         # See if any of the handlers take care of the parsing.</font>
<font color="black"> 126.         # This allows overriding everything if need be.</font>
<font color="red"> 127.         for handler in handlers:</font>
<font color="red"> 128.             result = handler.handle_raw_input(self._input_data,</font>
<font color="red"> 129.                                               self._meta,</font>
<font color="red"> 130.                                               self._content_length,</font>
<font color="red"> 131.                                               self._boundary,</font>
<font color="red"> 132.                                               encoding)</font>
<font color="black"> 133.             # Check to see if it was handled</font>
<font color="red"> 134.             if result is not None:</font>
<font color="red"> 135.                 return result[0], result[1]</font>
<font color="black"> 136. </font>
<font color="black"> 137.         # Create the data structures to be used later.</font>
<font color="red"> 138.         self._post = QueryDict('', mutable=True)</font>
<font color="red"> 139.         self._files = MultiValueDict()</font>
<font color="black"> 140. </font>
<font color="black"> 141.         # Instantiate the parser and stream:</font>
<font color="red"> 142.         stream = LazyStream(ChunkIter(self._input_data, self._chunk_size))</font>
<font color="black"> 143. </font>
<font color="black"> 144.         # Whether or not to signal a file-completion at the beginning of the loop.</font>
<font color="red"> 145.         old_field_name = None</font>
<font color="red"> 146.         counters = [0] * len(handlers)</font>
<font color="black"> 147. </font>
<font color="red"> 148.         try:</font>
<font color="red"> 149.             for item_type, meta_data, field_stream in Parser(stream, self._boundary):</font>
<font color="red"> 150.                 if old_field_name:</font>
<font color="black"> 151.                     # We run this at the beginning of the next loop</font>
<font color="black"> 152.                     # since we cannot be sure a file is complete until</font>
<font color="black"> 153.                     # we hit the next boundary/part of the multipart content.</font>
<font color="red"> 154.                     self.handle_file_complete(old_field_name, counters)</font>
<font color="red"> 155.                     old_field_name = None</font>
<font color="black"> 156. </font>
<font color="red"> 157.                 try:</font>
<font color="red"> 158.                     disposition = meta_data['content-disposition'][1]</font>
<font color="red"> 159.                     field_name = disposition['name'].strip()</font>
<font color="red"> 160.                 except (KeyError, IndexError, AttributeError):</font>
<font color="red"> 161.                     continue</font>
<font color="black"> 162. </font>
<font color="red"> 163.                 transfer_encoding = meta_data.get('content-transfer-encoding')</font>
<font color="red"> 164.                 if transfer_encoding is not None:</font>
<font color="red"> 165.                     transfer_encoding = transfer_encoding[0].strip()</font>
<font color="red"> 166.                 field_name = force_text(field_name, encoding, errors='replace')</font>
<font color="black"> 167. </font>
<font color="red"> 168.                 if item_type == FIELD:</font>
<font color="black"> 169.                     # This is a post field, we can just set it in the post</font>
<font color="red"> 170.                     if transfer_encoding == 'base64':</font>
<font color="red"> 171.                         raw_data = field_stream.read()</font>
<font color="red"> 172.                         try:</font>
<font color="red"> 173.                             data = base64.b64decode(raw_data)</font>
<font color="red"> 174.                         except _BASE64_DECODE_ERROR:</font>
<font color="red"> 175.                             data = raw_data</font>
<font color="black"> 176.                     else:</font>
<font color="red"> 177.                         data = field_stream.read()</font>
<font color="black"> 178. </font>
<font color="red"> 179.                     self._post.appendlist(field_name,</font>
<font color="red"> 180.                                           force_text(data, encoding, errors='replace'))</font>
<font color="red"> 181.                 elif item_type == FILE:</font>
<font color="black"> 182.                     # This is a file, use the handler...</font>
<font color="red"> 183.                     file_name = disposition.get('filename')</font>
<font color="red"> 184.                     if not file_name:</font>
<font color="red"> 185.                         continue</font>
<font color="red"> 186.                     file_name = force_text(file_name, encoding, errors='replace')</font>
<font color="red"> 187.                     file_name = self.IE_sanitize(unescape_entities(file_name))</font>
<font color="black"> 188. </font>
<font color="red"> 189.                     content_type, content_type_extra = meta_data.get('content-type', ('', {}))</font>
<font color="red"> 190.                     content_type = content_type.strip()</font>
<font color="red"> 191.                     charset = content_type_extra.get('charset')</font>
<font color="black"> 192. </font>
<font color="red"> 193.                     try:</font>
<font color="red"> 194.                         content_length = int(meta_data.get('content-length')[0])</font>
<font color="red"> 195.                     except (IndexError, TypeError, ValueError):</font>
<font color="red"> 196.                         content_length = None</font>
<font color="black"> 197. </font>
<font color="red"> 198.                     counters = [0] * len(handlers)</font>
<font color="red"> 199.                     try:</font>
<font color="red"> 200.                         for handler in handlers:</font>
<font color="red"> 201.                             try:</font>
<font color="red"> 202.                                 handler.new_file(field_name, file_name,</font>
<font color="red"> 203.                                                  content_type, content_length,</font>
<font color="red"> 204.                                                  charset, content_type_extra)</font>
<font color="red"> 205.                             except StopFutureHandlers:</font>
<font color="red"> 206.                                 break</font>
<font color="black"> 207. </font>
<font color="red"> 208.                         for chunk in field_stream:</font>
<font color="red"> 209.                             if transfer_encoding == 'base64':</font>
<font color="black"> 210.                                 # We only special-case base64 transfer encoding</font>
<font color="black"> 211.                                 # We should always decode base64 chunks by multiple of 4,</font>
<font color="black"> 212.                                 # ignoring whitespace.</font>
<font color="black"> 213. </font>
<font color="red"> 214.                                 stripped_chunk = b&quot;&quot;.join(chunk.split())</font>
<font color="black"> 215. </font>
<font color="red"> 216.                                 remaining = len(stripped_chunk) % 4</font>
<font color="red"> 217.                                 while remaining != 0:</font>
<font color="red"> 218.                                     over_chunk = field_stream.read(4 - remaining)</font>
<font color="red"> 219.                                     stripped_chunk += b&quot;&quot;.join(over_chunk.split())</font>
<font color="red"> 220.                                     remaining = len(stripped_chunk) % 4</font>
<font color="black"> 221. </font>
<font color="red"> 222.                                 try:</font>
<font color="red"> 223.                                     chunk = base64.b64decode(stripped_chunk)</font>
<font color="red"> 224.                                 except Exception as e:</font>
<font color="black"> 225.                                     # Since this is only a chunk, any error is an unfixable error.</font>
<font color="red"> 226.                                     msg = &quot;Could not decode base64 data: %r&quot; % e</font>
<font color="red"> 227.                                     six.reraise(MultiPartParserError, MultiPartParserError(msg), sys.exc_info()[2])</font>
<font color="black"> 228. </font>
<font color="red"> 229.                             for i, handler in enumerate(handlers):</font>
<font color="red"> 230.                                 chunk_length = len(chunk)</font>
<font color="red"> 231.                                 chunk = handler.receive_data_chunk(chunk,</font>
<font color="red"> 232.                                                                    counters[i])</font>
<font color="red"> 233.                                 counters[i] += chunk_length</font>
<font color="red"> 234.                                 if chunk is None:</font>
<font color="black"> 235.                                     # If the chunk received by the handler is None, then don't continue.</font>
<font color="red"> 236.                                     break</font>
<font color="black"> 237. </font>
<font color="red"> 238.                     except SkipFile:</font>
<font color="red"> 239.                         self._close_files()</font>
<font color="black"> 240.                         # Just use up the rest of this file...</font>
<font color="red"> 241.                         exhaust(field_stream)</font>
<font color="black"> 242.                     else:</font>
<font color="black"> 243.                         # Handle file upload completions on next iteration.</font>
<font color="red"> 244.                         old_field_name = field_name</font>
<font color="black"> 245.                 else:</font>
<font color="black"> 246.                     # If this is neither a FIELD or a FILE, just exhaust the stream.</font>
<font color="red"> 247.                     exhaust(stream)</font>
<font color="red"> 248.         except StopUpload as e:</font>
<font color="red"> 249.             self._close_files()</font>
<font color="red"> 250.             if not e.connection_reset:</font>
<font color="red"> 251.                 exhaust(self._input_data)</font>
<font color="black"> 252.         else:</font>
<font color="black"> 253.             # Make sure that the request data is all fed</font>
<font color="red"> 254.             exhaust(self._input_data)</font>
<font color="black"> 255. </font>
<font color="black"> 256.         # Signal that the upload has completed.</font>
<font color="red"> 257.         for handler in handlers:</font>
<font color="red"> 258.             retval = handler.upload_complete()</font>
<font color="red"> 259.             if retval:</font>
<font color="red"> 260.                 break</font>
<font color="black"> 261. </font>
<font color="red"> 262.         return self._post, self._files</font>
<font color="black"> 263. </font>
<font color="green"> 264.     def handle_file_complete(self, old_field_name, counters):</font>
<font color="black"> 265.         &quot;&quot;&quot;</font>
<font color="black"> 266.         Handle all the signaling that takes place when a file is complete.</font>
<font color="black"> 267.         &quot;&quot;&quot;</font>
<font color="red"> 268.         for i, handler in enumerate(self._upload_handlers):</font>
<font color="red"> 269.             file_obj = handler.file_complete(counters[i])</font>
<font color="red"> 270.             if file_obj:</font>
<font color="black"> 271.                 # If it returns a file object, then set the files dict.</font>
<font color="red"> 272.                 self._files.appendlist(</font>
<font color="red"> 273.                     force_text(old_field_name, self._encoding, errors='replace'),</font>
<font color="red"> 274.                     file_obj)</font>
<font color="red"> 275.                 break</font>
<font color="black"> 276. </font>
<font color="green"> 277.     def IE_sanitize(self, filename):</font>
<font color="black"> 278.         &quot;&quot;&quot;Cleanup filename from Internet Explorer full paths.&quot;&quot;&quot;</font>
<font color="red"> 279.         return filename and filename[filename.rfind(&quot;\\&quot;) + 1:].strip()</font>
<font color="black"> 280. </font>
<font color="green"> 281.     def _close_files(self):</font>
<font color="black"> 282.         # Free up all file handles.</font>
<font color="black"> 283.         # FIXME: this currently assumes that upload handlers store the file as 'file'</font>
<font color="black"> 284.         # We should document that... (Maybe add handler.free_file to complement new_file)</font>
<font color="red"> 285.         for handler in self._upload_handlers:</font>
<font color="red"> 286.             if hasattr(handler, 'file'):</font>
<font color="red"> 287.                 handler.file.close()</font>
<font color="black"> 288. </font>
<font color="black"> 289. </font>
<font color="green"> 290. class LazyStream(six.Iterator):</font>
<font color="black"> 291.     &quot;&quot;&quot;</font>
<font color="black"> 292.     The LazyStream wrapper allows one to get and &quot;unget&quot; bytes from a stream.</font>
<font color="black"> 293. </font>
<font color="black"> 294.     Given a producer object (an iterator that yields bytestrings), the</font>
<font color="black"> 295.     LazyStream object will support iteration, reading, and keeping a &quot;look-back&quot;</font>
<font color="black"> 296.     variable in case you need to &quot;unget&quot; some bytes.</font>
<font color="green"> 297.     &quot;&quot;&quot;</font>
<font color="green"> 298.     def __init__(self, producer, length=None):</font>
<font color="black"> 299.         &quot;&quot;&quot;</font>
<font color="black"> 300.         Every LazyStream must have a producer when instantiated.</font>
<font color="black"> 301. </font>
<font color="black"> 302.         A producer is an iterable that returns a string each time it</font>
<font color="black"> 303.         is called.</font>
<font color="black"> 304.         &quot;&quot;&quot;</font>
<font color="red"> 305.         self._producer = producer</font>
<font color="red"> 306.         self._empty = False</font>
<font color="red"> 307.         self._leftover = b''</font>
<font color="red"> 308.         self.length = length</font>
<font color="red"> 309.         self.position = 0</font>
<font color="red"> 310.         self._remaining = length</font>
<font color="red"> 311.         self._unget_history = []</font>
<font color="black"> 312. </font>
<font color="green"> 313.     def tell(self):</font>
<font color="red"> 314.         return self.position</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def read(self, size=None):</font>
<font color="red"> 317.         def parts():</font>
<font color="red"> 318.             remaining = self._remaining if size is None else size</font>
<font color="black"> 319.             # do the whole thing in one shot if no limit was provided.</font>
<font color="red"> 320.             if remaining is None:</font>
<font color="red"> 321.                 yield b''.join(self)</font>
<font color="red"> 322.                 return</font>
<font color="black"> 323. </font>
<font color="black"> 324.             # otherwise do some bookkeeping to return exactly enough</font>
<font color="black"> 325.             # of the stream and stashing any extra content we get from</font>
<font color="black"> 326.             # the producer</font>
<font color="red"> 327.             while remaining != 0:</font>
<font color="red"> 328.                 assert remaining &gt; 0, 'remaining bytes to read should never go negative'</font>
<font color="black"> 329. </font>
<font color="red"> 330.                 try:</font>
<font color="red"> 331.                     chunk = next(self)</font>
<font color="red"> 332.                 except StopIteration:</font>
<font color="red"> 333.                     return</font>
<font color="black"> 334.                 else:</font>
<font color="red"> 335.                     emitting = chunk[:remaining]</font>
<font color="red"> 336.                     self.unget(chunk[remaining:])</font>
<font color="red"> 337.                     remaining -= len(emitting)</font>
<font color="red"> 338.                     yield emitting</font>
<font color="black"> 339. </font>
<font color="red"> 340.         out = b''.join(parts())</font>
<font color="red"> 341.         return out</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def __next__(self):</font>
<font color="black"> 344.         &quot;&quot;&quot;</font>
<font color="black"> 345.         Used when the exact number of bytes to read is unimportant.</font>
<font color="black"> 346. </font>
<font color="black"> 347.         This procedure just returns whatever is chunk is conveniently returned</font>
<font color="black"> 348.         from the iterator instead. Useful to avoid unnecessary bookkeeping if</font>
<font color="black"> 349.         performance is an issue.</font>
<font color="black"> 350.         &quot;&quot;&quot;</font>
<font color="red"> 351.         if self._leftover:</font>
<font color="red"> 352.             output = self._leftover</font>
<font color="red"> 353.             self._leftover = b''</font>
<font color="black"> 354.         else:</font>
<font color="red"> 355.             output = next(self._producer)</font>
<font color="red"> 356.             self._unget_history = []</font>
<font color="red"> 357.         self.position += len(output)</font>
<font color="red"> 358.         return output</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def close(self):</font>
<font color="black"> 361.         &quot;&quot;&quot;</font>
<font color="black"> 362.         Used to invalidate/disable this lazy stream.</font>
<font color="black"> 363. </font>
<font color="black"> 364.         Replaces the producer with an empty list. Any leftover bytes that have</font>
<font color="black"> 365.         already been read will still be reported upon read() and/or next().</font>
<font color="black"> 366.         &quot;&quot;&quot;</font>
<font color="red"> 367.         self._producer = []</font>
<font color="black"> 368. </font>
<font color="green"> 369.     def __iter__(self):</font>
<font color="red"> 370.         return self</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def unget(self, bytes):</font>
<font color="black"> 373.         &quot;&quot;&quot;</font>
<font color="black"> 374.         Places bytes back onto the front of the lazy stream.</font>
<font color="black"> 375. </font>
<font color="black"> 376.         Future calls to read() will return those bytes first. The</font>
<font color="black"> 377.         stream position and thus tell() will be rewound.</font>
<font color="black"> 378.         &quot;&quot;&quot;</font>
<font color="red"> 379.         if not bytes:</font>
<font color="red"> 380.             return</font>
<font color="red"> 381.         self._update_unget_history(len(bytes))</font>
<font color="red"> 382.         self.position -= len(bytes)</font>
<font color="red"> 383.         self._leftover = b''.join([bytes, self._leftover])</font>
<font color="black"> 384. </font>
<font color="green"> 385.     def _update_unget_history(self, num_bytes):</font>
<font color="black"> 386.         &quot;&quot;&quot;</font>
<font color="black"> 387.         Updates the unget history as a sanity check to see if we've pushed</font>
<font color="black"> 388.         back the same number of bytes in one chunk. If we keep ungetting the</font>
<font color="black"> 389.         same number of bytes many times (here, 50), we're mostly likely in an</font>
<font color="black"> 390.         infinite loop of some sort. This is usually caused by a</font>
<font color="black"> 391.         maliciously-malformed MIME request.</font>
<font color="black"> 392.         &quot;&quot;&quot;</font>
<font color="red"> 393.         self._unget_history = [num_bytes] + self._unget_history[:49]</font>
<font color="red"> 394.         number_equal = len([current_number for current_number in self._unget_history</font>
<font color="red"> 395.                             if current_number == num_bytes])</font>
<font color="black"> 396. </font>
<font color="red"> 397.         if number_equal &gt; 40:</font>
<font color="red"> 398.             raise SuspiciousMultipartForm(</font>
<font color="red"> 399.                 &quot;The multipart parser got stuck, which shouldn't happen with&quot;</font>
<font color="black"> 400.                 &quot; normal uploaded files. Check for malicious upload activity;&quot;</font>
<font color="black"> 401.                 &quot; if there is none, report this to the Django developers.&quot;</font>
<font color="black"> 402.             )</font>
<font color="black"> 403. </font>
<font color="black"> 404. </font>
<font color="green"> 405. class ChunkIter(six.Iterator):</font>
<font color="black"> 406.     &quot;&quot;&quot;</font>
<font color="black"> 407.     An iterable that will yield chunks of data. Given a file-like object as the</font>
<font color="black"> 408.     constructor, this object will yield chunks of read operations from that</font>
<font color="black"> 409.     object.</font>
<font color="green"> 410.     &quot;&quot;&quot;</font>
<font color="green"> 411.     def __init__(self, flo, chunk_size=64 * 1024):</font>
<font color="red"> 412.         self.flo = flo</font>
<font color="red"> 413.         self.chunk_size = chunk_size</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def __next__(self):</font>
<font color="red"> 416.         try:</font>
<font color="red"> 417.             data = self.flo.read(self.chunk_size)</font>
<font color="red"> 418.         except InputStreamExhausted:</font>
<font color="red"> 419.             raise StopIteration()</font>
<font color="red"> 420.         if data:</font>
<font color="red"> 421.             return data</font>
<font color="black"> 422.         else:</font>
<font color="red"> 423.             raise StopIteration()</font>
<font color="black"> 424. </font>
<font color="green"> 425.     def __iter__(self):</font>
<font color="red"> 426.         return self</font>
<font color="black"> 427. </font>
<font color="black"> 428. </font>
<font color="green"> 429. class InterBoundaryIter(six.Iterator):</font>
<font color="black"> 430.     &quot;&quot;&quot;</font>
<font color="black"> 431.     A Producer that will iterate over boundaries.</font>
<font color="green"> 432.     &quot;&quot;&quot;</font>
<font color="green"> 433.     def __init__(self, stream, boundary):</font>
<font color="red"> 434.         self._stream = stream</font>
<font color="red"> 435.         self._boundary = boundary</font>
<font color="black"> 436. </font>
<font color="green"> 437.     def __iter__(self):</font>
<font color="red"> 438.         return self</font>
<font color="black"> 439. </font>
<font color="green"> 440.     def __next__(self):</font>
<font color="red"> 441.         try:</font>
<font color="red"> 442.             return LazyStream(BoundaryIter(self._stream, self._boundary))</font>
<font color="red"> 443.         except InputStreamExhausted:</font>
<font color="red"> 444.             raise StopIteration()</font>
<font color="black"> 445. </font>
<font color="black"> 446. </font>
<font color="green"> 447. class BoundaryIter(six.Iterator):</font>
<font color="black"> 448.     &quot;&quot;&quot;</font>
<font color="black"> 449.     A Producer that is sensitive to boundaries.</font>
<font color="black"> 450. </font>
<font color="black"> 451.     Will happily yield bytes until a boundary is found. Will yield the bytes</font>
<font color="black"> 452.     before the boundary, throw away the boundary bytes themselves, and push the</font>
<font color="black"> 453.     post-boundary bytes back on the stream.</font>
<font color="black"> 454. </font>
<font color="black"> 455.     The future calls to next() after locating the boundary will raise a</font>
<font color="black"> 456.     StopIteration exception.</font>
<font color="green"> 457.     &quot;&quot;&quot;</font>
<font color="black"> 458. </font>
<font color="green"> 459.     def __init__(self, stream, boundary):</font>
<font color="red"> 460.         self._stream = stream</font>
<font color="red"> 461.         self._boundary = boundary</font>
<font color="red"> 462.         self._done = False</font>
<font color="black"> 463.         # rollback an additional six bytes because the format is like</font>
<font color="black"> 464.         # this: CRLF&lt;boundary&gt;[--CRLF]</font>
<font color="red"> 465.         self._rollback = len(boundary) + 6</font>
<font color="black"> 466. </font>
<font color="black"> 467.         # Try to use mx fast string search if available. Otherwise</font>
<font color="black"> 468.         # use Python find. Wrap the latter for consistency.</font>
<font color="red"> 469.         unused_char = self._stream.read(1)</font>
<font color="red"> 470.         if not unused_char:</font>
<font color="red"> 471.             raise InputStreamExhausted()</font>
<font color="red"> 472.         self._stream.unget(unused_char)</font>
<font color="black"> 473. </font>
<font color="green"> 474.     def __iter__(self):</font>
<font color="red"> 475.         return self</font>
<font color="black"> 476. </font>
<font color="green"> 477.     def __next__(self):</font>
<font color="red"> 478.         if self._done:</font>
<font color="red"> 479.             raise StopIteration()</font>
<font color="black"> 480. </font>
<font color="red"> 481.         stream = self._stream</font>
<font color="red"> 482.         rollback = self._rollback</font>
<font color="black"> 483. </font>
<font color="red"> 484.         bytes_read = 0</font>
<font color="red"> 485.         chunks = []</font>
<font color="red"> 486.         for bytes in stream:</font>
<font color="red"> 487.             bytes_read += len(bytes)</font>
<font color="red"> 488.             chunks.append(bytes)</font>
<font color="red"> 489.             if bytes_read &gt; rollback:</font>
<font color="red"> 490.                 break</font>
<font color="red"> 491.             if not bytes:</font>
<font color="red"> 492.                 break</font>
<font color="black"> 493.         else:</font>
<font color="red"> 494.             self._done = True</font>
<font color="black"> 495. </font>
<font color="red"> 496.         if not chunks:</font>
<font color="red"> 497.             raise StopIteration()</font>
<font color="black"> 498. </font>
<font color="red"> 499.         chunk = b''.join(chunks)</font>
<font color="red"> 500.         boundary = self._find_boundary(chunk, len(chunk) &lt; self._rollback)</font>
<font color="black"> 501. </font>
<font color="red"> 502.         if boundary:</font>
<font color="red"> 503.             end, next = boundary</font>
<font color="red"> 504.             stream.unget(chunk[next:])</font>
<font color="red"> 505.             self._done = True</font>
<font color="red"> 506.             return chunk[:end]</font>
<font color="black"> 507.         else:</font>
<font color="black"> 508.             # make sure we don't treat a partial boundary (and</font>
<font color="black"> 509.             # its separators) as data</font>
<font color="red"> 510.             if not chunk[:-rollback]:  # and len(chunk) &gt;= (len(self._boundary) + 6):</font>
<font color="black"> 511.                 # There's nothing left, we should just return and mark as done.</font>
<font color="red"> 512.                 self._done = True</font>
<font color="red"> 513.                 return chunk</font>
<font color="black"> 514.             else:</font>
<font color="red"> 515.                 stream.unget(chunk[-rollback:])</font>
<font color="red"> 516.                 return chunk[:-rollback]</font>
<font color="black"> 517. </font>
<font color="green"> 518.     def _find_boundary(self, data, eof=False):</font>
<font color="black"> 519.         &quot;&quot;&quot;</font>
<font color="black"> 520.         Finds a multipart boundary in data.</font>
<font color="black"> 521. </font>
<font color="black"> 522.         Should no boundary exist in the data None is returned instead. Otherwise</font>
<font color="black"> 523.         a tuple containing the indices of the following are returned:</font>
<font color="black"> 524. </font>
<font color="black"> 525.          * the end of current encapsulation</font>
<font color="black"> 526.          * the start of the next encapsulation</font>
<font color="black"> 527.         &quot;&quot;&quot;</font>
<font color="red"> 528.         index = data.find(self._boundary)</font>
<font color="red"> 529.         if index &lt; 0:</font>
<font color="red"> 530.             return None</font>
<font color="black"> 531.         else:</font>
<font color="red"> 532.             end = index</font>
<font color="red"> 533.             next = index + len(self._boundary)</font>
<font color="black"> 534.             # backup over CRLF</font>
<font color="red"> 535.             last = max(0, end - 1)</font>
<font color="red"> 536.             if data[last:last + 1] == b'\n':</font>
<font color="red"> 537.                 end -= 1</font>
<font color="red"> 538.             last = max(0, end - 1)</font>
<font color="red"> 539.             if data[last:last + 1] == b'\r':</font>
<font color="red"> 540.                 end -= 1</font>
<font color="red"> 541.             return end, next</font>
<font color="black"> 542. </font>
<font color="black"> 543. </font>
<font color="green"> 544. def exhaust(stream_or_iterable):</font>
<font color="black"> 545.     &quot;&quot;&quot;</font>
<font color="black"> 546.     Completely exhausts an iterator or stream.</font>
<font color="black"> 547. </font>
<font color="black"> 548.     Raise a MultiPartParserError if the argument is not a stream or an iterable.</font>
<font color="black"> 549.     &quot;&quot;&quot;</font>
<font color="red"> 550.     iterator = None</font>
<font color="red"> 551.     try:</font>
<font color="red"> 552.         iterator = iter(stream_or_iterable)</font>
<font color="red"> 553.     except TypeError:</font>
<font color="red"> 554.         iterator = ChunkIter(stream_or_iterable, 16384)</font>
<font color="black"> 555. </font>
<font color="red"> 556.     if iterator is None:</font>
<font color="red"> 557.         raise MultiPartParserError('multipartparser.exhaust() was passed a non-iterable or stream parameter')</font>
<font color="black"> 558. </font>
<font color="red"> 559.     for __ in iterator:</font>
<font color="red"> 560.         pass</font>
<font color="black"> 561. </font>
<font color="black"> 562. </font>
<font color="green"> 563. def parse_boundary_stream(stream, max_header_size):</font>
<font color="black"> 564.     &quot;&quot;&quot;</font>
<font color="black"> 565.     Parses one and exactly one stream that encapsulates a boundary.</font>
<font color="black"> 566.     &quot;&quot;&quot;</font>
<font color="black"> 567.     # Stream at beginning of header, look for end of header</font>
<font color="black"> 568.     # and parse it if found. The header must fit within one</font>
<font color="black"> 569.     # chunk.</font>
<font color="red"> 570.     chunk = stream.read(max_header_size)</font>
<font color="black"> 571. </font>
<font color="black"> 572.     # 'find' returns the top of these four bytes, so we'll</font>
<font color="black"> 573.     # need to munch them later to prevent them from polluting</font>
<font color="black"> 574.     # the payload.</font>
<font color="red"> 575.     header_end = chunk.find(b'\r\n\r\n')</font>
<font color="black"> 576. </font>
<font color="red"> 577.     def _parse_header(line):</font>
<font color="red"> 578.         main_value_pair, params = parse_header(line)</font>
<font color="red"> 579.         try:</font>
<font color="red"> 580.             name, value = main_value_pair.split(':', 1)</font>
<font color="red"> 581.         except ValueError:</font>
<font color="red"> 582.             raise ValueError(&quot;Invalid header: %r&quot; % line)</font>
<font color="red"> 583.         return name, (value, params)</font>
<font color="black"> 584. </font>
<font color="red"> 585.     if header_end == -1:</font>
<font color="black"> 586.         # we find no header, so we just mark this fact and pass on</font>
<font color="black"> 587.         # the stream verbatim</font>
<font color="red"> 588.         stream.unget(chunk)</font>
<font color="red"> 589.         return (RAW, {}, stream)</font>
<font color="black"> 590. </font>
<font color="red"> 591.     header = chunk[:header_end]</font>
<font color="black"> 592. </font>
<font color="black"> 593.     # here we place any excess chunk back onto the stream, as</font>
<font color="black"> 594.     # well as throwing away the CRLFCRLF bytes from above.</font>
<font color="red"> 595.     stream.unget(chunk[header_end + 4:])</font>
<font color="black"> 596. </font>
<font color="red"> 597.     TYPE = RAW</font>
<font color="red"> 598.     outdict = {}</font>
<font color="black"> 599. </font>
<font color="black"> 600.     # Eliminate blank lines</font>
<font color="red"> 601.     for line in header.split(b'\r\n'):</font>
<font color="black"> 602.         # This terminology (&quot;main value&quot; and &quot;dictionary of</font>
<font color="black"> 603.         # parameters&quot;) is from the Python docs.</font>
<font color="red"> 604.         try:</font>
<font color="red"> 605.             name, (value, params) = _parse_header(line)</font>
<font color="red"> 606.         except ValueError:</font>
<font color="red"> 607.             continue</font>
<font color="black"> 608. </font>
<font color="red"> 609.         if name == 'content-disposition':</font>
<font color="red"> 610.             TYPE = FIELD</font>
<font color="red"> 611.             if params.get('filename'):</font>
<font color="red"> 612.                 TYPE = FILE</font>
<font color="black"> 613. </font>
<font color="red"> 614.         outdict[name] = value, params</font>
<font color="black"> 615. </font>
<font color="red"> 616.     if TYPE == RAW:</font>
<font color="red"> 617.         stream.unget(chunk)</font>
<font color="black"> 618. </font>
<font color="red"> 619.     return (TYPE, outdict, stream)</font>
<font color="black"> 620. </font>
<font color="black"> 621. </font>
<font color="green"> 622. class Parser(object):</font>
<font color="green"> 623.     def __init__(self, stream, boundary):</font>
<font color="red"> 624.         self._stream = stream</font>
<font color="red"> 625.         self._separator = b'--' + boundary</font>
<font color="black"> 626. </font>
<font color="green"> 627.     def __iter__(self):</font>
<font color="red"> 628.         boundarystream = InterBoundaryIter(self._stream, self._separator)</font>
<font color="red"> 629.         for sub_stream in boundarystream:</font>
<font color="black"> 630.             # Iterate over each part</font>
<font color="red"> 631.             yield parse_boundary_stream(sub_stream, 1024)</font>
<font color="black"> 632. </font>
<font color="black"> 633. </font>
<font color="green"> 634. def parse_header(line):</font>
<font color="black"> 635.     &quot;&quot;&quot; Parse the header into a key-value.</font>
<font color="black"> 636.         Input (line): bytes, output: unicode for key/name, bytes for value which</font>
<font color="black"> 637.         will be decoded later</font>
<font color="black"> 638.     &quot;&quot;&quot;</font>
<font color="red"> 639.     plist = _parse_header_params(b';' + line)</font>
<font color="red"> 640.     key = plist.pop(0).lower().decode('ascii')</font>
<font color="red"> 641.     pdict = {}</font>
<font color="red"> 642.     for p in plist:</font>
<font color="red"> 643.         i = p.find(b'=')</font>
<font color="red"> 644.         if i &gt;= 0:</font>
<font color="red"> 645.             has_encoding = False</font>
<font color="red"> 646.             name = p[:i].strip().lower().decode('ascii')</font>
<font color="red"> 647.             if name.endswith('*'):</font>
<font color="black"> 648.                 # Lang/encoding embedded in the value (like &quot;filename*=UTF-8''file.ext&quot;)</font>
<font color="black"> 649.                 # http://tools.ietf.org/html/rfc2231#section-4</font>
<font color="red"> 650.                 name = name[:-1]</font>
<font color="red"> 651.                 if p.count(b&quot;'&quot;) == 2:</font>
<font color="red"> 652.                     has_encoding = True</font>
<font color="red"> 653.             value = p[i + 1:].strip()</font>
<font color="red"> 654.             if has_encoding:</font>
<font color="red"> 655.                 encoding, lang, value = value.split(b&quot;'&quot;)</font>
<font color="red"> 656.                 if six.PY3:</font>
<font color="red"> 657.                     value = unquote(value.decode(), encoding=encoding.decode())</font>
<font color="black"> 658.                 else:</font>
<font color="red"> 659.                     value = unquote(value).decode(encoding)</font>
<font color="red"> 660.             if len(value) &gt;= 2 and value[:1] == value[-1:] == b'&quot;':</font>
<font color="red"> 661.                 value = value[1:-1]</font>
<font color="red"> 662.                 value = value.replace(b'\\\\', b'\\').replace(b'\\&quot;', b'&quot;')</font>
<font color="red"> 663.             pdict[name] = value</font>
<font color="red"> 664.     return key, pdict</font>
<font color="black"> 665. </font>
<font color="black"> 666. </font>
<font color="green"> 667. def _parse_header_params(s):</font>
<font color="red"> 668.     plist = []</font>
<font color="red"> 669.     while s[:1] == b';':</font>
<font color="red"> 670.         s = s[1:]</font>
<font color="red"> 671.         end = s.find(b';')</font>
<font color="red"> 672.         while end &gt; 0 and s.count(b'&quot;', 0, end) % 2:</font>
<font color="red"> 673.             end = s.find(b';', end + 1)</font>
<font color="red"> 674.         if end &lt; 0:</font>
<font color="red"> 675.             end = len(s)</font>
<font color="red"> 676.         f = s[:end]</font>
<font color="red"> 677.         plist.append(f.strip())</font>
<font color="red"> 678.         s = s[end:]</font>
<font color="red"> 679.     return plist</font>
</pre>

