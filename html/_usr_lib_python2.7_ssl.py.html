source file: <b>/usr/lib/python2.7/ssl.py</b><br>


file stats: <b>318 lines, 69 executed: 21.7% covered</b>
<pre>
<font color="black">   1. # Wrapper module for _ssl, providing some additional facilities</font>
<font color="black">   2. # implemented in Python.  Written by Bill Janssen.</font>
<font color="black">   3. </font>
<font color="black">   4. &quot;&quot;&quot;\</font>
<font color="black">   5. This module provides some more Pythonic support for SSL.</font>
<font color="black">   6. </font>
<font color="black">   7. Object types:</font>
<font color="black">   8. </font>
<font color="black">   9.   SSLSocket -- subtype of socket.socket which does SSL over the socket</font>
<font color="black">  10. </font>
<font color="black">  11. Exceptions:</font>
<font color="black">  12. </font>
<font color="black">  13.   SSLError -- exception raised for I/O errors</font>
<font color="black">  14. </font>
<font color="black">  15. Functions:</font>
<font color="black">  16. </font>
<font color="black">  17.   cert_time_to_seconds -- convert time string used for certificate</font>
<font color="black">  18.                           notBefore and notAfter functions to integer</font>
<font color="black">  19.                           seconds past the Epoch (the time values</font>
<font color="black">  20.                           returned from time.time())</font>
<font color="black">  21. </font>
<font color="black">  22.   fetch_server_certificate (HOST, PORT) -- fetch the certificate provided</font>
<font color="black">  23.                           by the server running on HOST at port PORT.  No</font>
<font color="black">  24.                           validation of the certificate is performed.</font>
<font color="black">  25. </font>
<font color="black">  26. Integer constants:</font>
<font color="black">  27. </font>
<font color="black">  28. SSL_ERROR_ZERO_RETURN</font>
<font color="black">  29. SSL_ERROR_WANT_READ</font>
<font color="black">  30. SSL_ERROR_WANT_WRITE</font>
<font color="black">  31. SSL_ERROR_WANT_X509_LOOKUP</font>
<font color="black">  32. SSL_ERROR_SYSCALL</font>
<font color="black">  33. SSL_ERROR_SSL</font>
<font color="black">  34. SSL_ERROR_WANT_CONNECT</font>
<font color="black">  35. </font>
<font color="black">  36. SSL_ERROR_EOF</font>
<font color="black">  37. SSL_ERROR_INVALID_ERROR_CODE</font>
<font color="black">  38. </font>
<font color="black">  39. The following group define certificate requirements that one side is</font>
<font color="black">  40. allowing/requiring from the other side:</font>
<font color="black">  41. </font>
<font color="black">  42. CERT_NONE - no certificates from the other side are required (or will</font>
<font color="black">  43.             be looked at if provided)</font>
<font color="black">  44. CERT_OPTIONAL - certificates are not required, but if provided will be</font>
<font color="black">  45.                 validated, and if validation fails, the connection will</font>
<font color="black">  46.                 also fail</font>
<font color="black">  47. CERT_REQUIRED - certificates are required, and will be validated, and</font>
<font color="black">  48.                 if validation fails, the connection will also fail</font>
<font color="black">  49. </font>
<font color="black">  50. The following constants identify various SSL protocol variants:</font>
<font color="black">  51. </font>
<font color="black">  52. PROTOCOL_SSLv2</font>
<font color="black">  53. PROTOCOL_SSLv3</font>
<font color="black">  54. PROTOCOL_SSLv23</font>
<font color="black">  55. PROTOCOL_TLSv1</font>
<font color="green">  56. &quot;&quot;&quot;</font>
<font color="black">  57. </font>
<font color="green">  58. import textwrap</font>
<font color="green">  59. import re</font>
<font color="black">  60. </font>
<font color="green">  61. import _ssl             # if we can't import it, let the error propagate</font>
<font color="black">  62. </font>
<font color="green">  63. from _ssl import OPENSSL_VERSION_NUMBER, OPENSSL_VERSION_INFO, OPENSSL_VERSION</font>
<font color="green">  64. from _ssl import SSLError</font>
<font color="green">  65. from _ssl import CERT_NONE, CERT_OPTIONAL, CERT_REQUIRED</font>
<font color="green">  66. from _ssl import RAND_status, RAND_egd, RAND_add</font>
<font color="green">  67. from _ssl import \</font>
<font color="black">  68.      SSL_ERROR_ZERO_RETURN, \</font>
<font color="black">  69.      SSL_ERROR_WANT_READ, \</font>
<font color="black">  70.      SSL_ERROR_WANT_WRITE, \</font>
<font color="black">  71.      SSL_ERROR_WANT_X509_LOOKUP, \</font>
<font color="black">  72.      SSL_ERROR_SYSCALL, \</font>
<font color="black">  73.      SSL_ERROR_SSL, \</font>
<font color="black">  74.      SSL_ERROR_WANT_CONNECT, \</font>
<font color="black">  75.      SSL_ERROR_EOF, \</font>
<font color="black">  76.      SSL_ERROR_INVALID_ERROR_CODE</font>
<font color="green">  77. from _ssl import PROTOCOL_SSLv3, PROTOCOL_SSLv23, PROTOCOL_TLSv1</font>
<font color="green">  78. _PROTOCOL_NAMES = {</font>
<font color="green">  79.     PROTOCOL_TLSv1: &quot;TLSv1&quot;,</font>
<font color="green">  80.     PROTOCOL_SSLv23: &quot;SSLv23&quot;,</font>
<font color="green">  81.     PROTOCOL_SSLv3: &quot;SSLv3&quot;,</font>
<font color="black">  82. }</font>
<font color="green">  83. try:</font>
<font color="green">  84.     from _ssl import PROTOCOL_SSLv2</font>
<font color="red">  85.     _SSLv2_IF_EXISTS = PROTOCOL_SSLv2</font>
<font color="green">  86. except ImportError:</font>
<font color="green">  87.     _SSLv2_IF_EXISTS = None</font>
<font color="black">  88. else:</font>
<font color="red">  89.     _PROTOCOL_NAMES[PROTOCOL_SSLv2] = &quot;SSLv2&quot;</font>
<font color="black">  90. </font>
<font color="green">  91. from socket import socket, _fileobject, _delegate_methods, error as socket_error</font>
<font color="green">  92. from socket import getnameinfo as _getnameinfo</font>
<font color="green">  93. from socket import SOL_SOCKET, SO_TYPE, SOCK_STREAM</font>
<font color="green">  94. import base64        # for DER-to-PEM translation</font>
<font color="green">  95. import errno</font>
<font color="black">  96. </font>
<font color="black">  97. # Disable weak or insecure ciphers by default</font>
<font color="black">  98. # (OpenSSL's default setting is 'DEFAULT:!aNULL:!eNULL')</font>
<font color="green">  99. _DEFAULT_CIPHERS = 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2'</font>
<font color="black"> 100. </font>
<font color="green"> 101. class CertificateError(ValueError):</font>
<font color="green"> 102.     pass</font>
<font color="black"> 103. </font>
<font color="black"> 104. </font>
<font color="green"> 105. def _dnsname_match(dn, hostname, max_wildcards=1):</font>
<font color="black"> 106.     &quot;&quot;&quot;Matching according to RFC 6125, section 6.4.3</font>
<font color="black"> 107. </font>
<font color="black"> 108.     http://tools.ietf.org/html/rfc6125#section-6.4.3</font>
<font color="black"> 109.     &quot;&quot;&quot;</font>
<font color="red"> 110.     pats = []</font>
<font color="red"> 111.     if not dn:</font>
<font color="red"> 112.         return False</font>
<font color="black"> 113. </font>
<font color="red"> 114.     dn_split = dn.split(r'.')</font>
<font color="red"> 115.     leftmost = dn_split[0]</font>
<font color="red"> 116.     remainder = dn_split[1:]</font>
<font color="black"> 117. </font>
<font color="red"> 118.     wildcards = leftmost.count('*')</font>
<font color="red"> 119.     if wildcards &gt; max_wildcards:</font>
<font color="black"> 120.         # Issue #17980: avoid denials of service by refusing more</font>
<font color="black"> 121.         # than one wildcard per fragment.  A survery of established</font>
<font color="black"> 122.         # policy among SSL implementations showed it to be a</font>
<font color="black"> 123.         # reasonable choice.</font>
<font color="red"> 124.         raise CertificateError(</font>
<font color="red"> 125.             &quot;too many wildcards in certificate DNS name: &quot; + repr(dn))</font>
<font color="black"> 126. </font>
<font color="black"> 127.     # speed up common case w/o wildcards</font>
<font color="red"> 128.     if not wildcards:</font>
<font color="red"> 129.         return dn.lower() == hostname.lower()</font>
<font color="black"> 130. </font>
<font color="black"> 131.     # RFC 6125, section 6.4.3, subitem 1.</font>
<font color="black"> 132.     # The client SHOULD NOT attempt to match a presented identifier in which</font>
<font color="black"> 133.     # the wildcard character comprises a label other than the left-most label.</font>
<font color="red"> 134.     if leftmost == '*':</font>
<font color="black"> 135.         # When '*' is a fragment by itself, it matches a non-empty dotless</font>
<font color="black"> 136.         # fragment.</font>
<font color="red"> 137.         pats.append('[^.]+')</font>
<font color="red"> 138.     elif leftmost.startswith('xn--') or hostname.startswith('xn--'):</font>
<font color="black"> 139.         # RFC 6125, section 6.4.3, subitem 3.</font>
<font color="black"> 140.         # The client SHOULD NOT attempt to match a presented identifier</font>
<font color="black"> 141.         # where the wildcard character is embedded within an A-label or</font>
<font color="black"> 142.         # U-label of an internationalized domain name.</font>
<font color="red"> 143.         pats.append(re.escape(leftmost))</font>
<font color="black"> 144.     else:</font>
<font color="black"> 145.         # Otherwise, '*' matches any dotless string, e.g. www*</font>
<font color="red"> 146.         pats.append(re.escape(leftmost).replace(r'\*', '[^.]*'))</font>
<font color="black"> 147. </font>
<font color="black"> 148.     # add the remaining fragments, ignore any wildcards</font>
<font color="red"> 149.     for frag in remainder:</font>
<font color="red"> 150.         pats.append(re.escape(frag))</font>
<font color="black"> 151. </font>
<font color="red"> 152.     pat = re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)</font>
<font color="red"> 153.     return pat.match(hostname)</font>
<font color="black"> 154. </font>
<font color="black"> 155. </font>
<font color="green"> 156. def match_hostname(cert, hostname):</font>
<font color="black"> 157.     &quot;&quot;&quot;Verify that *cert* (in decoded format as returned by</font>
<font color="black"> 158.     SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125</font>
<font color="black"> 159.     rules are followed, but IP addresses are not accepted for *hostname*.</font>
<font color="black"> 160. </font>
<font color="black"> 161.     CertificateError is raised on failure. On success, the function</font>
<font color="black"> 162.     returns nothing.</font>
<font color="black"> 163.     &quot;&quot;&quot;</font>
<font color="red"> 164.     if not cert:</font>
<font color="red"> 165.         raise ValueError(&quot;empty or no certificate&quot;)</font>
<font color="red"> 166.     dnsnames = []</font>
<font color="red"> 167.     san = cert.get('subjectAltName', ())</font>
<font color="red"> 168.     for key, value in san:</font>
<font color="red"> 169.         if key == 'DNS':</font>
<font color="red"> 170.             if _dnsname_match(value, hostname):</font>
<font color="red"> 171.                 return</font>
<font color="red"> 172.             dnsnames.append(value)</font>
<font color="red"> 173.     if not dnsnames:</font>
<font color="black"> 174.         # The subject is only checked when there is no dNSName entry</font>
<font color="black"> 175.         # in subjectAltName</font>
<font color="red"> 176.         for sub in cert.get('subject', ()):</font>
<font color="red"> 177.             for key, value in sub:</font>
<font color="black"> 178.                 # XXX according to RFC 2818, the most specific Common Name</font>
<font color="black"> 179.                 # must be used.</font>
<font color="red"> 180.                 if key == 'commonName':</font>
<font color="red"> 181.                     if _dnsname_match(value, hostname):</font>
<font color="red"> 182.                         return</font>
<font color="red"> 183.                     dnsnames.append(value)</font>
<font color="red"> 184.     if len(dnsnames) &gt; 1:</font>
<font color="red"> 185.         raise CertificateError(&quot;hostname %r &quot;</font>
<font color="black"> 186.             &quot;doesn't match either of %s&quot;</font>
<font color="red"> 187.             % (hostname, ', '.join(map(repr, dnsnames))))</font>
<font color="red"> 188.     elif len(dnsnames) == 1:</font>
<font color="red"> 189.         raise CertificateError(&quot;hostname %r &quot;</font>
<font color="black"> 190.             &quot;doesn't match %r&quot;</font>
<font color="red"> 191.             % (hostname, dnsnames[0]))</font>
<font color="black"> 192.     else:</font>
<font color="red"> 193.         raise CertificateError(&quot;no appropriate commonName or &quot;</font>
<font color="black"> 194.             &quot;subjectAltName fields were found&quot;)</font>
<font color="black"> 195. </font>
<font color="green"> 196. class SSLSocket(socket):</font>
<font color="black"> 197. </font>
<font color="black"> 198.     &quot;&quot;&quot;This class implements a subtype of socket.socket that wraps</font>
<font color="black"> 199.     the underlying OS socket in an SSL context when necessary, and</font>
<font color="green"> 200.     provides read and write methods over that channel.&quot;&quot;&quot;</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def __init__(self, sock, keyfile=None, certfile=None,</font>
<font color="green"> 203.                  server_side=False, cert_reqs=CERT_NONE,</font>
<font color="green"> 204.                  ssl_version=PROTOCOL_SSLv23, ca_certs=None,</font>
<font color="green"> 205.                  do_handshake_on_connect=True,</font>
<font color="green"> 206.                  suppress_ragged_eofs=True, ciphers=None):</font>
<font color="black"> 207.         # Can't use sock.type as other flags (such as SOCK_NONBLOCK) get</font>
<font color="black"> 208.         # mixed in.</font>
<font color="red"> 209.         if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:</font>
<font color="red"> 210.             raise NotImplementedError(&quot;only stream sockets are supported&quot;)</font>
<font color="red"> 211.         socket.__init__(self, _sock=sock._sock)</font>
<font color="black"> 212.         # The initializer for socket overrides the methods send(), recv(), etc.</font>
<font color="black"> 213.         # in the instancce, which we don't need -- but we want to provide the</font>
<font color="black"> 214.         # methods defined in SSLSocket.</font>
<font color="red"> 215.         for attr in _delegate_methods:</font>
<font color="red"> 216.             try:</font>
<font color="red"> 217.                 delattr(self, attr)</font>
<font color="red"> 218.             except AttributeError:</font>
<font color="red"> 219.                 pass</font>
<font color="black"> 220. </font>
<font color="red"> 221.         if ciphers is None and ssl_version != _SSLv2_IF_EXISTS:</font>
<font color="red"> 222.             ciphers = _DEFAULT_CIPHERS</font>
<font color="black"> 223. </font>
<font color="red"> 224.         if certfile and not keyfile:</font>
<font color="red"> 225.             keyfile = certfile</font>
<font color="black"> 226.         # see if it's connected</font>
<font color="red"> 227.         try:</font>
<font color="red"> 228.             socket.getpeername(self)</font>
<font color="red"> 229.         except socket_error, e:</font>
<font color="red"> 230.             if e.errno != errno.ENOTCONN:</font>
<font color="red"> 231.                 raise</font>
<font color="black"> 232.             # no, no connection yet</font>
<font color="red"> 233.             self._connected = False</font>
<font color="red"> 234.             self._sslobj = None</font>
<font color="black"> 235.         else:</font>
<font color="black"> 236.             # yes, create the SSL object</font>
<font color="red"> 237.             self._connected = True</font>
<font color="red"> 238.             self._sslobj = _ssl.sslwrap(self._sock, server_side,</font>
<font color="red"> 239.                                         keyfile, certfile,</font>
<font color="red"> 240.                                         cert_reqs, ssl_version, ca_certs,</font>
<font color="red"> 241.                                         ciphers)</font>
<font color="red"> 242.             if do_handshake_on_connect:</font>
<font color="red"> 243.                 self.do_handshake()</font>
<font color="red"> 244.         self.keyfile = keyfile</font>
<font color="red"> 245.         self.certfile = certfile</font>
<font color="red"> 246.         self.cert_reqs = cert_reqs</font>
<font color="red"> 247.         self.ssl_version = ssl_version</font>
<font color="red"> 248.         self.ca_certs = ca_certs</font>
<font color="red"> 249.         self.ciphers = ciphers</font>
<font color="red"> 250.         self.do_handshake_on_connect = do_handshake_on_connect</font>
<font color="red"> 251.         self.suppress_ragged_eofs = suppress_ragged_eofs</font>
<font color="red"> 252.         self._makefile_refs = 0</font>
<font color="black"> 253. </font>
<font color="green"> 254.     def read(self, len=1024):</font>
<font color="black"> 255. </font>
<font color="black"> 256.         &quot;&quot;&quot;Read up to LEN bytes and return them.</font>
<font color="black"> 257.         Return zero-length string on EOF.&quot;&quot;&quot;</font>
<font color="black"> 258. </font>
<font color="red"> 259.         try:</font>
<font color="red"> 260.             return self._sslobj.read(len)</font>
<font color="red"> 261.         except SSLError, x:</font>
<font color="red"> 262.             if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs:</font>
<font color="red"> 263.                 return ''</font>
<font color="black"> 264.             else:</font>
<font color="red"> 265.                 raise</font>
<font color="black"> 266. </font>
<font color="green"> 267.     def write(self, data):</font>
<font color="black"> 268. </font>
<font color="black"> 269.         &quot;&quot;&quot;Write DATA to the underlying SSL channel.  Returns</font>
<font color="black"> 270.         number of bytes of DATA actually transmitted.&quot;&quot;&quot;</font>
<font color="black"> 271. </font>
<font color="red"> 272.         return self._sslobj.write(data)</font>
<font color="black"> 273. </font>
<font color="green"> 274.     def getpeercert(self, binary_form=False):</font>
<font color="black"> 275. </font>
<font color="black"> 276.         &quot;&quot;&quot;Returns a formatted version of the data in the</font>
<font color="black"> 277.         certificate provided by the other end of the SSL channel.</font>
<font color="black"> 278.         Return None if no certificate was provided, {} if a</font>
<font color="black"> 279.         certificate was provided, but not validated.&quot;&quot;&quot;</font>
<font color="black"> 280. </font>
<font color="red"> 281.         return self._sslobj.peer_certificate(binary_form)</font>
<font color="black"> 282. </font>
<font color="green"> 283.     def cipher(self):</font>
<font color="black"> 284. </font>
<font color="red"> 285.         if not self._sslobj:</font>
<font color="red"> 286.             return None</font>
<font color="black"> 287.         else:</font>
<font color="red"> 288.             return self._sslobj.cipher()</font>
<font color="black"> 289. </font>
<font color="green"> 290.     def send(self, data, flags=0):</font>
<font color="red"> 291.         if self._sslobj:</font>
<font color="red"> 292.             if flags != 0:</font>
<font color="red"> 293.                 raise ValueError(</font>
<font color="red"> 294.                     &quot;non-zero flags not allowed in calls to send() on %s&quot; %</font>
<font color="red"> 295.                     self.__class__)</font>
<font color="red"> 296.             while True:</font>
<font color="red"> 297.                 try:</font>
<font color="red"> 298.                     v = self._sslobj.write(data)</font>
<font color="red"> 299.                 except SSLError, x:</font>
<font color="red"> 300.                     if x.args[0] == SSL_ERROR_WANT_READ:</font>
<font color="red"> 301.                         return 0</font>
<font color="red"> 302.                     elif x.args[0] == SSL_ERROR_WANT_WRITE:</font>
<font color="red"> 303.                         return 0</font>
<font color="black"> 304.                     else:</font>
<font color="red"> 305.                         raise</font>
<font color="black"> 306.                 else:</font>
<font color="red"> 307.                     return v</font>
<font color="black"> 308.         else:</font>
<font color="red"> 309.             return self._sock.send(data, flags)</font>
<font color="black"> 310. </font>
<font color="green"> 311.     def sendto(self, data, flags_or_addr, addr=None):</font>
<font color="red"> 312.         if self._sslobj:</font>
<font color="red"> 313.             raise ValueError(&quot;sendto not allowed on instances of %s&quot; %</font>
<font color="red"> 314.                              self.__class__)</font>
<font color="red"> 315.         elif addr is None:</font>
<font color="red"> 316.             return self._sock.sendto(data, flags_or_addr)</font>
<font color="black"> 317.         else:</font>
<font color="red"> 318.             return self._sock.sendto(data, flags_or_addr, addr)</font>
<font color="black"> 319. </font>
<font color="green"> 320.     def sendall(self, data, flags=0):</font>
<font color="red"> 321.         if self._sslobj:</font>
<font color="red"> 322.             if flags != 0:</font>
<font color="red"> 323.                 raise ValueError(</font>
<font color="red"> 324.                     &quot;non-zero flags not allowed in calls to sendall() on %s&quot; %</font>
<font color="red"> 325.                     self.__class__)</font>
<font color="red"> 326.             amount = len(data)</font>
<font color="red"> 327.             count = 0</font>
<font color="red"> 328.             while (count &lt; amount):</font>
<font color="red"> 329.                 v = self.send(data[count:])</font>
<font color="red"> 330.                 count += v</font>
<font color="red"> 331.             return amount</font>
<font color="black"> 332.         else:</font>
<font color="red"> 333.             return socket.sendall(self, data, flags)</font>
<font color="black"> 334. </font>
<font color="green"> 335.     def recv(self, buflen=1024, flags=0):</font>
<font color="red"> 336.         if self._sslobj:</font>
<font color="red"> 337.             if flags != 0:</font>
<font color="red"> 338.                 raise ValueError(</font>
<font color="red"> 339.                     &quot;non-zero flags not allowed in calls to recv() on %s&quot; %</font>
<font color="red"> 340.                     self.__class__)</font>
<font color="red"> 341.             return self.read(buflen)</font>
<font color="black"> 342.         else:</font>
<font color="red"> 343.             return self._sock.recv(buflen, flags)</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def recv_into(self, buffer, nbytes=None, flags=0):</font>
<font color="red"> 346.         if buffer and (nbytes is None):</font>
<font color="red"> 347.             nbytes = len(buffer)</font>
<font color="red"> 348.         elif nbytes is None:</font>
<font color="red"> 349.             nbytes = 1024</font>
<font color="red"> 350.         if self._sslobj:</font>
<font color="red"> 351.             if flags != 0:</font>
<font color="red"> 352.                 raise ValueError(</font>
<font color="red"> 353.                   &quot;non-zero flags not allowed in calls to recv_into() on %s&quot; %</font>
<font color="red"> 354.                   self.__class__)</font>
<font color="red"> 355.             tmp_buffer = self.read(nbytes)</font>
<font color="red"> 356.             v = len(tmp_buffer)</font>
<font color="red"> 357.             buffer[:v] = tmp_buffer</font>
<font color="red"> 358.             return v</font>
<font color="black"> 359.         else:</font>
<font color="red"> 360.             return self._sock.recv_into(buffer, nbytes, flags)</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def recvfrom(self, buflen=1024, flags=0):</font>
<font color="red"> 363.         if self._sslobj:</font>
<font color="red"> 364.             raise ValueError(&quot;recvfrom not allowed on instances of %s&quot; %</font>
<font color="red"> 365.                              self.__class__)</font>
<font color="black"> 366.         else:</font>
<font color="red"> 367.             return self._sock.recvfrom(buflen, flags)</font>
<font color="black"> 368. </font>
<font color="green"> 369.     def recvfrom_into(self, buffer, nbytes=None, flags=0):</font>
<font color="red"> 370.         if self._sslobj:</font>
<font color="red"> 371.             raise ValueError(&quot;recvfrom_into not allowed on instances of %s&quot; %</font>
<font color="red"> 372.                              self.__class__)</font>
<font color="black"> 373.         else:</font>
<font color="red"> 374.             return self._sock.recvfrom_into(buffer, nbytes, flags)</font>
<font color="black"> 375. </font>
<font color="green"> 376.     def pending(self):</font>
<font color="red"> 377.         if self._sslobj:</font>
<font color="red"> 378.             return self._sslobj.pending()</font>
<font color="black"> 379.         else:</font>
<font color="red"> 380.             return 0</font>
<font color="black"> 381. </font>
<font color="green"> 382.     def unwrap(self):</font>
<font color="red"> 383.         if self._sslobj:</font>
<font color="red"> 384.             s = self._sslobj.shutdown()</font>
<font color="red"> 385.             self._sslobj = None</font>
<font color="red"> 386.             return s</font>
<font color="black"> 387.         else:</font>
<font color="red"> 388.             raise ValueError(&quot;No SSL wrapper around &quot; + str(self))</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def shutdown(self, how):</font>
<font color="red"> 391.         self._sslobj = None</font>
<font color="red"> 392.         socket.shutdown(self, how)</font>
<font color="black"> 393. </font>
<font color="green"> 394.     def close(self):</font>
<font color="red"> 395.         if self._makefile_refs &lt; 1:</font>
<font color="red"> 396.             self._sslobj = None</font>
<font color="red"> 397.             socket.close(self)</font>
<font color="black"> 398.         else:</font>
<font color="red"> 399.             self._makefile_refs -= 1</font>
<font color="black"> 400. </font>
<font color="green"> 401.     def do_handshake(self):</font>
<font color="black"> 402. </font>
<font color="black"> 403.         &quot;&quot;&quot;Perform a TLS/SSL handshake.&quot;&quot;&quot;</font>
<font color="black"> 404. </font>
<font color="red"> 405.         self._sslobj.do_handshake()</font>
<font color="black"> 406. </font>
<font color="green"> 407.     def _real_connect(self, addr, return_errno):</font>
<font color="black"> 408.         # Here we assume that the socket is client-side, and not</font>
<font color="black"> 409.         # connected at the time of the call.  We connect it, then wrap it.</font>
<font color="red"> 410.         if self._connected:</font>
<font color="red"> 411.             raise ValueError(&quot;attempt to connect already-connected SSLSocket!&quot;)</font>
<font color="red"> 412.         self._sslobj = _ssl.sslwrap(self._sock, False, self.keyfile, self.certfile,</font>
<font color="red"> 413.                                     self.cert_reqs, self.ssl_version,</font>
<font color="red"> 414.                                     self.ca_certs, self.ciphers)</font>
<font color="red"> 415.         try:</font>
<font color="red"> 416.             if return_errno:</font>
<font color="red"> 417.                 rc = socket.connect_ex(self, addr)</font>
<font color="black"> 418.             else:</font>
<font color="red"> 419.                 rc = None</font>
<font color="red"> 420.                 socket.connect(self, addr)</font>
<font color="red"> 421.             if not rc:</font>
<font color="red"> 422.                 if self.do_handshake_on_connect:</font>
<font color="red"> 423.                     self.do_handshake()</font>
<font color="red"> 424.                 self._connected = True</font>
<font color="red"> 425.             return rc</font>
<font color="red"> 426.         except socket_error:</font>
<font color="red"> 427.             self._sslobj = None</font>
<font color="red"> 428.             raise</font>
<font color="black"> 429. </font>
<font color="green"> 430.     def connect(self, addr):</font>
<font color="black"> 431.         &quot;&quot;&quot;Connects to remote ADDR, and then wraps the connection in</font>
<font color="black"> 432.         an SSL channel.&quot;&quot;&quot;</font>
<font color="red"> 433.         self._real_connect(addr, False)</font>
<font color="black"> 434. </font>
<font color="green"> 435.     def connect_ex(self, addr):</font>
<font color="black"> 436.         &quot;&quot;&quot;Connects to remote ADDR, and then wraps the connection in</font>
<font color="black"> 437.         an SSL channel.&quot;&quot;&quot;</font>
<font color="red"> 438.         return self._real_connect(addr, True)</font>
<font color="black"> 439. </font>
<font color="green"> 440.     def accept(self):</font>
<font color="black"> 441. </font>
<font color="black"> 442.         &quot;&quot;&quot;Accepts a new connection from a remote client, and returns</font>
<font color="black"> 443.         a tuple containing that new connection wrapped with a server-side</font>
<font color="black"> 444.         SSL channel, and the address of the remote client.&quot;&quot;&quot;</font>
<font color="black"> 445. </font>
<font color="red"> 446.         newsock, addr = socket.accept(self)</font>
<font color="red"> 447.         try:</font>
<font color="red"> 448.             return (SSLSocket(newsock,</font>
<font color="red"> 449.                               keyfile=self.keyfile,</font>
<font color="red"> 450.                               certfile=self.certfile,</font>
<font color="red"> 451.                               server_side=True,</font>
<font color="red"> 452.                               cert_reqs=self.cert_reqs,</font>
<font color="red"> 453.                               ssl_version=self.ssl_version,</font>
<font color="red"> 454.                               ca_certs=self.ca_certs,</font>
<font color="red"> 455.                               ciphers=self.ciphers,</font>
<font color="red"> 456.                               do_handshake_on_connect=self.do_handshake_on_connect,</font>
<font color="red"> 457.                               suppress_ragged_eofs=self.suppress_ragged_eofs),</font>
<font color="red"> 458.                     addr)</font>
<font color="red"> 459.         except socket_error as e:</font>
<font color="red"> 460.             newsock.close()</font>
<font color="red"> 461.             raise e</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def makefile(self, mode='r', bufsize=-1):</font>
<font color="black"> 464. </font>
<font color="black"> 465.         &quot;&quot;&quot;Make and return a file-like object that</font>
<font color="black"> 466.         works with the SSL connection.  Just use the code</font>
<font color="black"> 467.         from the socket module.&quot;&quot;&quot;</font>
<font color="black"> 468. </font>
<font color="red"> 469.         self._makefile_refs += 1</font>
<font color="black"> 470.         # close=True so as to decrement the reference count when done with</font>
<font color="black"> 471.         # the file-like object.</font>
<font color="red"> 472.         return _fileobject(self, mode, bufsize, close=True)</font>
<font color="black"> 473. </font>
<font color="black"> 474. </font>
<font color="black"> 475. </font>
<font color="green"> 476. def wrap_socket(sock, keyfile=None, certfile=None,</font>
<font color="green"> 477.                 server_side=False, cert_reqs=CERT_NONE,</font>
<font color="green"> 478.                 ssl_version=PROTOCOL_SSLv23, ca_certs=None,</font>
<font color="green"> 479.                 do_handshake_on_connect=True,</font>
<font color="green"> 480.                 suppress_ragged_eofs=True, ciphers=None):</font>
<font color="black"> 481. </font>
<font color="red"> 482.     return SSLSocket(sock, keyfile=keyfile, certfile=certfile,</font>
<font color="red"> 483.                      server_side=server_side, cert_reqs=cert_reqs,</font>
<font color="red"> 484.                      ssl_version=ssl_version, ca_certs=ca_certs,</font>
<font color="red"> 485.                      do_handshake_on_connect=do_handshake_on_connect,</font>
<font color="red"> 486.                      suppress_ragged_eofs=suppress_ragged_eofs,</font>
<font color="red"> 487.                      ciphers=ciphers)</font>
<font color="black"> 488. </font>
<font color="black"> 489. </font>
<font color="black"> 490. # some utility functions</font>
<font color="black"> 491. </font>
<font color="green"> 492. def cert_time_to_seconds(cert_time):</font>
<font color="black"> 493. </font>
<font color="black"> 494.     &quot;&quot;&quot;Takes a date-time string in standard ASN1_print form</font>
<font color="black"> 495.     (&quot;MON DAY 24HOUR:MINUTE:SEC YEAR TIMEZONE&quot;) and return</font>
<font color="black"> 496.     a Python time value in seconds past the epoch.&quot;&quot;&quot;</font>
<font color="black"> 497. </font>
<font color="red"> 498.     import time</font>
<font color="red"> 499.     return time.mktime(time.strptime(cert_time, &quot;%b %d %H:%M:%S %Y GMT&quot;))</font>
<font color="black"> 500. </font>
<font color="green"> 501. PEM_HEADER = &quot;-----BEGIN CERTIFICATE-----&quot;</font>
<font color="green"> 502. PEM_FOOTER = &quot;-----END CERTIFICATE-----&quot;</font>
<font color="black"> 503. </font>
<font color="green"> 504. def DER_cert_to_PEM_cert(der_cert_bytes):</font>
<font color="black"> 505. </font>
<font color="black"> 506.     &quot;&quot;&quot;Takes a certificate in binary DER format and returns the</font>
<font color="black"> 507.     PEM version of it as a string.&quot;&quot;&quot;</font>
<font color="black"> 508. </font>
<font color="red"> 509.     if hasattr(base64, 'standard_b64encode'):</font>
<font color="black"> 510.         # preferred because older API gets line-length wrong</font>
<font color="red"> 511.         f = base64.standard_b64encode(der_cert_bytes)</font>
<font color="black"> 512.         return (PEM_HEADER + '\n' +</font>
<font color="black"> 513.                 textwrap.fill(f, 64) + '\n' +</font>
<font color="red"> 514.                 PEM_FOOTER + '\n')</font>
<font color="black"> 515.     else:</font>
<font color="black"> 516.         return (PEM_HEADER + '\n' +</font>
<font color="black"> 517.                 base64.encodestring(der_cert_bytes) +</font>
<font color="red"> 518.                 PEM_FOOTER + '\n')</font>
<font color="black"> 519. </font>
<font color="green"> 520. def PEM_cert_to_DER_cert(pem_cert_string):</font>
<font color="black"> 521. </font>
<font color="black"> 522.     &quot;&quot;&quot;Takes a certificate in ASCII PEM format and returns the</font>
<font color="black"> 523.     DER-encoded version of it as a byte sequence&quot;&quot;&quot;</font>
<font color="black"> 524. </font>
<font color="red"> 525.     if not pem_cert_string.startswith(PEM_HEADER):</font>
<font color="red"> 526.         raise ValueError(&quot;Invalid PEM encoding; must start with %s&quot;</font>
<font color="red"> 527.                          % PEM_HEADER)</font>
<font color="red"> 528.     if not pem_cert_string.strip().endswith(PEM_FOOTER):</font>
<font color="red"> 529.         raise ValueError(&quot;Invalid PEM encoding; must end with %s&quot;</font>
<font color="red"> 530.                          % PEM_FOOTER)</font>
<font color="red"> 531.     d = pem_cert_string.strip()[len(PEM_HEADER):-len(PEM_FOOTER)]</font>
<font color="red"> 532.     return base64.decodestring(d)</font>
<font color="black"> 533. </font>
<font color="green"> 534. def get_server_certificate(addr, ssl_version=PROTOCOL_SSLv3, ca_certs=None):</font>
<font color="black"> 535. </font>
<font color="black"> 536.     &quot;&quot;&quot;Retrieve the certificate from the server at the specified address,</font>
<font color="black"> 537.     and return it as a PEM-encoded string.</font>
<font color="black"> 538.     If 'ca_certs' is specified, validate the server cert against it.</font>
<font color="black"> 539.     If 'ssl_version' is specified, use it in the connection attempt.&quot;&quot;&quot;</font>
<font color="black"> 540. </font>
<font color="red"> 541.     host, port = addr</font>
<font color="red"> 542.     if (ca_certs is not None):</font>
<font color="red"> 543.         cert_reqs = CERT_REQUIRED</font>
<font color="black"> 544.     else:</font>
<font color="red"> 545.         cert_reqs = CERT_NONE</font>
<font color="red"> 546.     s = wrap_socket(socket(), ssl_version=ssl_version,</font>
<font color="red"> 547.                     cert_reqs=cert_reqs, ca_certs=ca_certs)</font>
<font color="red"> 548.     s.connect(addr)</font>
<font color="red"> 549.     dercert = s.getpeercert(True)</font>
<font color="red"> 550.     s.close()</font>
<font color="red"> 551.     return DER_cert_to_PEM_cert(dercert)</font>
<font color="black"> 552. </font>
<font color="green"> 553. def get_protocol_name(protocol_code):</font>
<font color="red"> 554.     return _PROTOCOL_NAMES.get(protocol_code, '&lt;unknown&gt;')</font>
<font color="black"> 555. </font>
<font color="black"> 556. </font>
<font color="black"> 557. # a replacement for the old socket.ssl function</font>
<font color="black"> 558. </font>
<font color="green"> 559. def sslwrap_simple(sock, keyfile=None, certfile=None):</font>
<font color="black"> 560. </font>
<font color="black"> 561.     &quot;&quot;&quot;A replacement for the old socket.ssl function.  Designed</font>
<font color="black"> 562.     for compability with Python 2.5 and earlier.  Will disappear in</font>
<font color="black"> 563.     Python 3.0.&quot;&quot;&quot;</font>
<font color="black"> 564. </font>
<font color="red"> 565.     if hasattr(sock, &quot;_sock&quot;):</font>
<font color="red"> 566.         sock = sock._sock</font>
<font color="black"> 567. </font>
<font color="red"> 568.     ssl_sock = _ssl.sslwrap(sock, 0, keyfile, certfile, CERT_NONE,</font>
<font color="red"> 569.                             PROTOCOL_SSLv23, None)</font>
<font color="red"> 570.     try:</font>
<font color="red"> 571.         sock.getpeername()</font>
<font color="red"> 572.     except socket_error:</font>
<font color="black"> 573.         # no, no connection yet</font>
<font color="red"> 574.         pass</font>
<font color="black"> 575.     else:</font>
<font color="black"> 576.         # yes, do the handshake</font>
<font color="red"> 577.         ssl_sock.do_handshake()</font>
<font color="black"> 578. </font>
<font color="red"> 579.     return ssl_sock</font>
</pre>

