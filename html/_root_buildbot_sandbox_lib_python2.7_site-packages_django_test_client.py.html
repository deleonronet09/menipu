source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/test/client.py</b><br>


file stats: <b>412 lines, 103 executed: 25.0% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import json</font>
<font color="green">   4. import mimetypes</font>
<font color="green">   5. import os</font>
<font color="green">   6. import re</font>
<font color="green">   7. import sys</font>
<font color="green">   8. from copy import copy</font>
<font color="green">   9. from importlib import import_module</font>
<font color="green">  10. from io import BytesIO</font>
<font color="black">  11. </font>
<font color="green">  12. from django.apps import apps</font>
<font color="green">  13. from django.conf import settings</font>
<font color="green">  14. from django.core import urlresolvers</font>
<font color="green">  15. from django.core.handlers.base import BaseHandler</font>
<font color="green">  16. from django.core.handlers.wsgi import ISO_8859_1, UTF_8, WSGIRequest</font>
<font color="green">  17. from django.core.signals import (</font>
<font color="black">  18.     got_request_exception, request_finished, request_started,</font>
<font color="black">  19. )</font>
<font color="green">  20. from django.db import close_old_connections</font>
<font color="green">  21. from django.http import HttpRequest, QueryDict, SimpleCookie</font>
<font color="green">  22. from django.template import TemplateDoesNotExist</font>
<font color="green">  23. from django.test import signals</font>
<font color="green">  24. from django.test.utils import ContextList</font>
<font color="green">  25. from django.utils import six</font>
<font color="green">  26. from django.utils.encoding import force_bytes, force_str, uri_to_iri</font>
<font color="green">  27. from django.utils.functional import SimpleLazyObject, curry</font>
<font color="green">  28. from django.utils.http import urlencode</font>
<font color="green">  29. from django.utils.itercompat import is_iterable</font>
<font color="green">  30. from django.utils.six.moves.urllib.parse import urlparse, urlsplit</font>
<font color="black">  31. </font>
<font color="green">  32. __all__ = ('Client', 'RedirectCycleError', 'RequestFactory', 'encode_file', 'encode_multipart')</font>
<font color="black">  33. </font>
<font color="black">  34. </font>
<font color="green">  35. BOUNDARY = 'BoUnDaRyStRiNg'</font>
<font color="green">  36. MULTIPART_CONTENT = 'multipart/form-data; boundary=%s' % BOUNDARY</font>
<font color="green">  37. CONTENT_TYPE_RE = re.compile('.*; charset=([\w\d-]+);?')</font>
<font color="black">  38. </font>
<font color="black">  39. </font>
<font color="green">  40. class RedirectCycleError(Exception):</font>
<font color="black">  41.     &quot;&quot;&quot;</font>
<font color="black">  42.     The test client has been asked to follow a redirect loop.</font>
<font color="green">  43.     &quot;&quot;&quot;</font>
<font color="green">  44.     def __init__(self, message, last_response):</font>
<font color="red">  45.         super(RedirectCycleError, self).__init__(message)</font>
<font color="red">  46.         self.last_response = last_response</font>
<font color="red">  47.         self.redirect_chain = last_response.redirect_chain</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="green">  50. class FakePayload(object):</font>
<font color="black">  51.     &quot;&quot;&quot;</font>
<font color="black">  52.     A wrapper around BytesIO that restricts what can be read since data from</font>
<font color="black">  53.     the network can't be seeked and cannot be read outside of its content</font>
<font color="black">  54.     length. This makes sure that views can't do anything under the test client</font>
<font color="black">  55.     that wouldn't work in Real Life.</font>
<font color="green">  56.     &quot;&quot;&quot;</font>
<font color="green">  57.     def __init__(self, content=None):</font>
<font color="red">  58.         self.__content = BytesIO()</font>
<font color="red">  59.         self.__len = 0</font>
<font color="red">  60.         self.read_started = False</font>
<font color="red">  61.         if content is not None:</font>
<font color="red">  62.             self.write(content)</font>
<font color="black">  63. </font>
<font color="green">  64.     def __len__(self):</font>
<font color="red">  65.         return self.__len</font>
<font color="black">  66. </font>
<font color="green">  67.     def read(self, num_bytes=None):</font>
<font color="red">  68.         if not self.read_started:</font>
<font color="red">  69.             self.__content.seek(0)</font>
<font color="red">  70.             self.read_started = True</font>
<font color="red">  71.         if num_bytes is None:</font>
<font color="red">  72.             num_bytes = self.__len or 0</font>
<font color="red">  73.         assert self.__len &gt;= num_bytes, &quot;Cannot read more than the available bytes from the HTTP incoming data.&quot;</font>
<font color="red">  74.         content = self.__content.read(num_bytes)</font>
<font color="red">  75.         self.__len -= num_bytes</font>
<font color="red">  76.         return content</font>
<font color="black">  77. </font>
<font color="green">  78.     def write(self, content):</font>
<font color="red">  79.         if self.read_started:</font>
<font color="red">  80.             raise ValueError(&quot;Unable to write a payload after he's been read&quot;)</font>
<font color="red">  81.         content = force_bytes(content)</font>
<font color="red">  82.         self.__content.write(content)</font>
<font color="red">  83.         self.__len += len(content)</font>
<font color="black">  84. </font>
<font color="black">  85. </font>
<font color="green">  86. def closing_iterator_wrapper(iterable, close):</font>
<font color="red">  87.     try:</font>
<font color="red">  88.         for item in iterable:</font>
<font color="red">  89.             yield item</font>
<font color="black">  90.     finally:</font>
<font color="red">  91.         request_finished.disconnect(close_old_connections)</font>
<font color="red">  92.         close()                                 # will fire request_finished</font>
<font color="red">  93.         request_finished.connect(close_old_connections)</font>
<font color="black">  94. </font>
<font color="black">  95. </font>
<font color="green">  96. class ClientHandler(BaseHandler):</font>
<font color="black">  97.     &quot;&quot;&quot;</font>
<font color="black">  98.     A HTTP Handler that can be used for testing purposes. Uses the WSGI</font>
<font color="black">  99.     interface to compose requests, but returns the raw HttpResponse object with</font>
<font color="black"> 100.     the originating WSGIRequest attached to its ``wsgi_request`` attribute.</font>
<font color="green"> 101.     &quot;&quot;&quot;</font>
<font color="green"> 102.     def __init__(self, enforce_csrf_checks=True, *args, **kwargs):</font>
<font color="green"> 103.         self.enforce_csrf_checks = enforce_csrf_checks</font>
<font color="green"> 104.         super(ClientHandler, self).__init__(*args, **kwargs)</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def __call__(self, environ):</font>
<font color="black"> 107.         # Set up middleware if needed. We couldn't do this earlier, because</font>
<font color="black"> 108.         # settings weren't available.</font>
<font color="red"> 109.         if self._request_middleware is None:</font>
<font color="red"> 110.             self.load_middleware()</font>
<font color="black"> 111. </font>
<font color="red"> 112.         request_started.disconnect(close_old_connections)</font>
<font color="red"> 113.         request_started.send(sender=self.__class__, environ=environ)</font>
<font color="red"> 114.         request_started.connect(close_old_connections)</font>
<font color="red"> 115.         request = WSGIRequest(environ)</font>
<font color="black"> 116.         # sneaky little hack so that we can easily get round</font>
<font color="black"> 117.         # CsrfViewMiddleware.  This makes life easier, and is probably</font>
<font color="black"> 118.         # required for backwards compatibility with external tests against</font>
<font color="black"> 119.         # admin views.</font>
<font color="red"> 120.         request._dont_enforce_csrf_checks = not self.enforce_csrf_checks</font>
<font color="black"> 121. </font>
<font color="black"> 122.         # Request goes through middleware.</font>
<font color="red"> 123.         response = self.get_response(request)</font>
<font color="black"> 124.         # Attach the originating request to the response so that it could be</font>
<font color="black"> 125.         # later retrieved.</font>
<font color="red"> 126.         response.wsgi_request = request</font>
<font color="black"> 127. </font>
<font color="black"> 128.         # We're emulating a WSGI server; we must call the close method</font>
<font color="black"> 129.         # on completion.</font>
<font color="red"> 130.         if response.streaming:</font>
<font color="red"> 131.             response.streaming_content = closing_iterator_wrapper(</font>
<font color="red"> 132.                 response.streaming_content, response.close)</font>
<font color="black"> 133.         else:</font>
<font color="red"> 134.             request_finished.disconnect(close_old_connections)</font>
<font color="red"> 135.             response.close()                    # will fire request_finished</font>
<font color="red"> 136.             request_finished.connect(close_old_connections)</font>
<font color="black"> 137. </font>
<font color="red"> 138.         return response</font>
<font color="black"> 139. </font>
<font color="black"> 140. </font>
<font color="green"> 141. def store_rendered_templates(store, signal, sender, template, context, **kwargs):</font>
<font color="black"> 142.     &quot;&quot;&quot;</font>
<font color="black"> 143.     Stores templates and contexts that are rendered.</font>
<font color="black"> 144. </font>
<font color="black"> 145.     The context is copied so that it is an accurate representation at the time</font>
<font color="black"> 146.     of rendering.</font>
<font color="black"> 147.     &quot;&quot;&quot;</font>
<font color="red"> 148.     store.setdefault('templates', []).append(template)</font>
<font color="red"> 149.     store.setdefault('context', ContextList()).append(copy(context))</font>
<font color="black"> 150. </font>
<font color="black"> 151. </font>
<font color="green"> 152. def encode_multipart(boundary, data):</font>
<font color="black"> 153.     &quot;&quot;&quot;</font>
<font color="black"> 154.     Encodes multipart POST data from a dictionary of form values.</font>
<font color="black"> 155. </font>
<font color="black"> 156.     The key will be used as the form data name; the value will be transmitted</font>
<font color="black"> 157.     as content. If the value is a file, the contents of the file will be sent</font>
<font color="black"> 158.     as an application/octet-stream; otherwise, str(value) will be sent.</font>
<font color="black"> 159.     &quot;&quot;&quot;</font>
<font color="red"> 160.     lines = []</font>
<font color="red"> 161.     to_bytes = lambda s: force_bytes(s, settings.DEFAULT_CHARSET)</font>
<font color="black"> 162. </font>
<font color="black"> 163.     # Not by any means perfect, but good enough for our purposes.</font>
<font color="red"> 164.     is_file = lambda thing: hasattr(thing, &quot;read&quot;) and callable(thing.read)</font>
<font color="black"> 165. </font>
<font color="black"> 166.     # Each bit of the multipart form data could be either a form value or a</font>
<font color="black"> 167.     # file, or a *list* of form values and/or files. Remember that HTTP field</font>
<font color="black"> 168.     # names can be duplicated!</font>
<font color="red"> 169.     for (key, value) in data.items():</font>
<font color="red"> 170.         if is_file(value):</font>
<font color="red"> 171.             lines.extend(encode_file(boundary, key, value))</font>
<font color="red"> 172.         elif not isinstance(value, six.string_types) and is_iterable(value):</font>
<font color="red"> 173.             for item in value:</font>
<font color="red"> 174.                 if is_file(item):</font>
<font color="red"> 175.                     lines.extend(encode_file(boundary, key, item))</font>
<font color="black"> 176.                 else:</font>
<font color="red"> 177.                     lines.extend(to_bytes(val) for val in [</font>
<font color="red"> 178.                         '--%s' % boundary,</font>
<font color="red"> 179.                         'Content-Disposition: form-data; name=&quot;%s&quot;' % key,</font>
<font color="red"> 180.                         '',</font>
<font color="red"> 181.                         item</font>
<font color="black"> 182.                     ])</font>
<font color="black"> 183.         else:</font>
<font color="red"> 184.             lines.extend(to_bytes(val) for val in [</font>
<font color="red"> 185.                 '--%s' % boundary,</font>
<font color="red"> 186.                 'Content-Disposition: form-data; name=&quot;%s&quot;' % key,</font>
<font color="red"> 187.                 '',</font>
<font color="red"> 188.                 value</font>
<font color="black"> 189.             ])</font>
<font color="black"> 190. </font>
<font color="red"> 191.     lines.extend([</font>
<font color="red"> 192.         to_bytes('--%s--' % boundary),</font>
<font color="red"> 193.         b'',</font>
<font color="black"> 194.     ])</font>
<font color="red"> 195.     return b'\r\n'.join(lines)</font>
<font color="black"> 196. </font>
<font color="black"> 197. </font>
<font color="green"> 198. def encode_file(boundary, key, file):</font>
<font color="red"> 199.     to_bytes = lambda s: force_bytes(s, settings.DEFAULT_CHARSET)</font>
<font color="red"> 200.     filename = os.path.basename(file.name) if hasattr(file, 'name') else ''</font>
<font color="red"> 201.     if hasattr(file, 'content_type'):</font>
<font color="red"> 202.         content_type = file.content_type</font>
<font color="red"> 203.     elif filename:</font>
<font color="red"> 204.         content_type = mimetypes.guess_type(filename)[0]</font>
<font color="black"> 205.     else:</font>
<font color="red"> 206.         content_type = None</font>
<font color="black"> 207. </font>
<font color="red"> 208.     if content_type is None:</font>
<font color="red"> 209.         content_type = 'application/octet-stream'</font>
<font color="red"> 210.     if not filename:</font>
<font color="red"> 211.         filename = key</font>
<font color="black"> 212.     return [</font>
<font color="red"> 213.         to_bytes('--%s' % boundary),</font>
<font color="red"> 214.         to_bytes('Content-Disposition: form-data; name=&quot;%s&quot;; filename=&quot;%s&quot;'</font>
<font color="red"> 215.                  % (key, filename)),</font>
<font color="red"> 216.         to_bytes('Content-Type: %s' % content_type),</font>
<font color="red"> 217.         b'',</font>
<font color="red"> 218.         to_bytes(file.read())</font>
<font color="black"> 219.     ]</font>
<font color="black"> 220. </font>
<font color="black"> 221. </font>
<font color="green"> 222. class RequestFactory(object):</font>
<font color="black"> 223.     &quot;&quot;&quot;</font>
<font color="black"> 224.     Class that lets you create mock Request objects for use in testing.</font>
<font color="black"> 225. </font>
<font color="black"> 226.     Usage:</font>
<font color="black"> 227. </font>
<font color="black"> 228.     rf = RequestFactory()</font>
<font color="black"> 229.     get_request = rf.get('/hello/')</font>
<font color="black"> 230.     post_request = rf.post('/submit/', {'foo': 'bar'})</font>
<font color="black"> 231. </font>
<font color="black"> 232.     Once you have a request object you can pass it to any view function,</font>
<font color="black"> 233.     just as if that view had been hooked up using a URLconf.</font>
<font color="green"> 234.     &quot;&quot;&quot;</font>
<font color="green"> 235.     def __init__(self, **defaults):</font>
<font color="green"> 236.         self.defaults = defaults</font>
<font color="green"> 237.         self.cookies = SimpleCookie()</font>
<font color="green"> 238.         self.errors = BytesIO()</font>
<font color="black"> 239. </font>
<font color="green"> 240.     def _base_environ(self, **request):</font>
<font color="black"> 241.         &quot;&quot;&quot;</font>
<font color="black"> 242.         The base environment for a request.</font>
<font color="black"> 243.         &quot;&quot;&quot;</font>
<font color="black"> 244.         # This is a minimal valid WSGI environ dictionary, plus:</font>
<font color="black"> 245.         # - HTTP_COOKIE: for cookie support,</font>
<font color="black"> 246.         # - REMOTE_ADDR: often useful, see #8551.</font>
<font color="black"> 247.         # See http://www.python.org/dev/peps/pep-3333/#environ-variables</font>
<font color="red"> 248.         environ = {</font>
<font color="red"> 249.             'HTTP_COOKIE': self.cookies.output(header='', sep='; '),</font>
<font color="red"> 250.             'PATH_INFO': str('/'),</font>
<font color="red"> 251.             'REMOTE_ADDR': str('127.0.0.1'),</font>
<font color="red"> 252.             'REQUEST_METHOD': str('GET'),</font>
<font color="red"> 253.             'SCRIPT_NAME': str(''),</font>
<font color="red"> 254.             'SERVER_NAME': str('testserver'),</font>
<font color="red"> 255.             'SERVER_PORT': str('80'),</font>
<font color="red"> 256.             'SERVER_PROTOCOL': str('HTTP/1.1'),</font>
<font color="red"> 257.             'wsgi.version': (1, 0),</font>
<font color="red"> 258.             'wsgi.url_scheme': str('http'),</font>
<font color="red"> 259.             'wsgi.input': FakePayload(b''),</font>
<font color="red"> 260.             'wsgi.errors': self.errors,</font>
<font color="red"> 261.             'wsgi.multiprocess': True,</font>
<font color="red"> 262.             'wsgi.multithread': False,</font>
<font color="red"> 263.             'wsgi.run_once': False,</font>
<font color="black"> 264.         }</font>
<font color="red"> 265.         environ.update(self.defaults)</font>
<font color="red"> 266.         environ.update(request)</font>
<font color="red"> 267.         return environ</font>
<font color="black"> 268. </font>
<font color="green"> 269.     def request(self, **request):</font>
<font color="black"> 270.         &quot;Construct a generic request object.&quot;</font>
<font color="red"> 271.         return WSGIRequest(self._base_environ(**request))</font>
<font color="black"> 272. </font>
<font color="green"> 273.     def _encode_data(self, data, content_type):</font>
<font color="red"> 274.         if content_type is MULTIPART_CONTENT:</font>
<font color="red"> 275.             return encode_multipart(BOUNDARY, data)</font>
<font color="black"> 276.         else:</font>
<font color="black"> 277.             # Encode the content so that the byte representation is correct.</font>
<font color="red"> 278.             match = CONTENT_TYPE_RE.match(content_type)</font>
<font color="red"> 279.             if match:</font>
<font color="red"> 280.                 charset = match.group(1)</font>
<font color="black"> 281.             else:</font>
<font color="red"> 282.                 charset = settings.DEFAULT_CHARSET</font>
<font color="red"> 283.             return force_bytes(data, encoding=charset)</font>
<font color="black"> 284. </font>
<font color="green"> 285.     def _get_path(self, parsed):</font>
<font color="red"> 286.         path = force_str(parsed[2])</font>
<font color="black"> 287.         # If there are parameters, add them</font>
<font color="red"> 288.         if parsed[3]:</font>
<font color="red"> 289.             path += str(&quot;;&quot;) + force_str(parsed[3])</font>
<font color="red"> 290.         path = uri_to_iri(path).encode(UTF_8)</font>
<font color="black"> 291.         # Under Python 3, non-ASCII values in the WSGI environ are arbitrarily</font>
<font color="black"> 292.         # decoded with ISO-8859-1. We replicate this behavior here.</font>
<font color="black"> 293.         # Refs comment in `get_bytes_from_wsgi()`.</font>
<font color="red"> 294.         return path.decode(ISO_8859_1) if six.PY3 else path</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def get(self, path, data=None, secure=False, **extra):</font>
<font color="black"> 297.         &quot;Construct a GET request.&quot;</font>
<font color="black"> 298. </font>
<font color="red"> 299.         data = {} if data is None else data</font>
<font color="red"> 300.         r = {</font>
<font color="red"> 301.             'QUERY_STRING': urlencode(data, doseq=True),</font>
<font color="black"> 302.         }</font>
<font color="red"> 303.         r.update(extra)</font>
<font color="red"> 304.         return self.generic('GET', path, secure=secure, **r)</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def post(self, path, data=None, content_type=MULTIPART_CONTENT,</font>
<font color="green"> 307.              secure=False, **extra):</font>
<font color="black"> 308.         &quot;Construct a POST request.&quot;</font>
<font color="black"> 309. </font>
<font color="red"> 310.         data = {} if data is None else data</font>
<font color="red"> 311.         post_data = self._encode_data(data, content_type)</font>
<font color="black"> 312. </font>
<font color="red"> 313.         return self.generic('POST', path, post_data, content_type,</font>
<font color="red"> 314.                             secure=secure, **extra)</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def head(self, path, data=None, secure=False, **extra):</font>
<font color="black"> 317.         &quot;Construct a HEAD request.&quot;</font>
<font color="black"> 318. </font>
<font color="red"> 319.         data = {} if data is None else data</font>
<font color="red"> 320.         r = {</font>
<font color="red"> 321.             'QUERY_STRING': urlencode(data, doseq=True),</font>
<font color="black"> 322.         }</font>
<font color="red"> 323.         r.update(extra)</font>
<font color="red"> 324.         return self.generic('HEAD', path, secure=secure, **r)</font>
<font color="black"> 325. </font>
<font color="green"> 326.     def trace(self, path, secure=False, **extra):</font>
<font color="black"> 327.         &quot;Construct a TRACE request.&quot;</font>
<font color="red"> 328.         return self.generic('TRACE', path, secure=secure, **extra)</font>
<font color="black"> 329. </font>
<font color="green"> 330.     def options(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 331.                 secure=False, **extra):</font>
<font color="black"> 332.         &quot;Construct an OPTIONS request.&quot;</font>
<font color="red"> 333.         return self.generic('OPTIONS', path, data, content_type,</font>
<font color="red"> 334.                             secure=secure, **extra)</font>
<font color="black"> 335. </font>
<font color="green"> 336.     def put(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 337.             secure=False, **extra):</font>
<font color="black"> 338.         &quot;Construct a PUT request.&quot;</font>
<font color="red"> 339.         return self.generic('PUT', path, data, content_type,</font>
<font color="red"> 340.                             secure=secure, **extra)</font>
<font color="black"> 341. </font>
<font color="green"> 342.     def patch(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 343.               secure=False, **extra):</font>
<font color="black"> 344.         &quot;Construct a PATCH request.&quot;</font>
<font color="red"> 345.         return self.generic('PATCH', path, data, content_type,</font>
<font color="red"> 346.                             secure=secure, **extra)</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def delete(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 349.                secure=False, **extra):</font>
<font color="black"> 350.         &quot;Construct a DELETE request.&quot;</font>
<font color="red"> 351.         return self.generic('DELETE', path, data, content_type,</font>
<font color="red"> 352.                             secure=secure, **extra)</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def generic(self, method, path, data='',</font>
<font color="green"> 355.                 content_type='application/octet-stream', secure=False,</font>
<font color="black"> 356.                 **extra):</font>
<font color="black"> 357.         &quot;&quot;&quot;Constructs an arbitrary HTTP request.&quot;&quot;&quot;</font>
<font color="red"> 358.         parsed = urlparse(force_str(path))</font>
<font color="red"> 359.         data = force_bytes(data, settings.DEFAULT_CHARSET)</font>
<font color="red"> 360.         r = {</font>
<font color="red"> 361.             'PATH_INFO': self._get_path(parsed),</font>
<font color="red"> 362.             'REQUEST_METHOD': str(method),</font>
<font color="red"> 363.             'SERVER_PORT': str('443') if secure else str('80'),</font>
<font color="red"> 364.             'wsgi.url_scheme': str('https') if secure else str('http'),</font>
<font color="black"> 365.         }</font>
<font color="red"> 366.         if data:</font>
<font color="red"> 367.             r.update({</font>
<font color="red"> 368.                 'CONTENT_LENGTH': len(data),</font>
<font color="red"> 369.                 'CONTENT_TYPE': str(content_type),</font>
<font color="red"> 370.                 'wsgi.input': FakePayload(data),</font>
<font color="black"> 371.             })</font>
<font color="red"> 372.         r.update(extra)</font>
<font color="black"> 373.         # If QUERY_STRING is absent or empty, we want to extract it from the URL.</font>
<font color="red"> 374.         if not r.get('QUERY_STRING'):</font>
<font color="red"> 375.             query_string = force_bytes(parsed[4])</font>
<font color="black"> 376.             # WSGI requires latin-1 encoded strings. See get_path_info().</font>
<font color="red"> 377.             if six.PY3:</font>
<font color="red"> 378.                 query_string = query_string.decode('iso-8859-1')</font>
<font color="red"> 379.             r['QUERY_STRING'] = query_string</font>
<font color="red"> 380.         return self.request(**r)</font>
<font color="black"> 381. </font>
<font color="black"> 382. </font>
<font color="green"> 383. class Client(RequestFactory):</font>
<font color="black"> 384.     &quot;&quot;&quot;</font>
<font color="black"> 385.     A class that can act as a client for testing purposes.</font>
<font color="black"> 386. </font>
<font color="black"> 387.     It allows the user to compose GET and POST requests, and</font>
<font color="black"> 388.     obtain the response that the server gave to those requests.</font>
<font color="black"> 389.     The server Response objects are annotated with the details</font>
<font color="black"> 390.     of the contexts and templates that were rendered during the</font>
<font color="black"> 391.     process of serving the request.</font>
<font color="black"> 392. </font>
<font color="black"> 393.     Client objects are stateful - they will retain cookie (and</font>
<font color="black"> 394.     thus session) details for the lifetime of the Client instance.</font>
<font color="black"> 395. </font>
<font color="black"> 396.     This is not intended as a replacement for Twill/Selenium or</font>
<font color="black"> 397.     the like - it is here to allow testing against the</font>
<font color="black"> 398.     contexts and templates produced by a view, rather than the</font>
<font color="black"> 399.     HTML rendered to the end-user.</font>
<font color="green"> 400.     &quot;&quot;&quot;</font>
<font color="green"> 401.     def __init__(self, enforce_csrf_checks=False, **defaults):</font>
<font color="green"> 402.         super(Client, self).__init__(**defaults)</font>
<font color="green"> 403.         self.handler = ClientHandler(enforce_csrf_checks)</font>
<font color="green"> 404.         self.exc_info = None</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def store_exc_info(self, **kwargs):</font>
<font color="black"> 407.         &quot;&quot;&quot;</font>
<font color="black"> 408.         Stores exceptions when they are generated by a view.</font>
<font color="black"> 409.         &quot;&quot;&quot;</font>
<font color="red"> 410.         self.exc_info = sys.exc_info()</font>
<font color="black"> 411. </font>
<font color="green"> 412.     def _session(self):</font>
<font color="black"> 413.         &quot;&quot;&quot;</font>
<font color="black"> 414.         Obtains the current session variables.</font>
<font color="black"> 415.         &quot;&quot;&quot;</font>
<font color="red"> 416.         if apps.is_installed('django.contrib.sessions'):</font>
<font color="red"> 417.             engine = import_module(settings.SESSION_ENGINE)</font>
<font color="red"> 418.             cookie = self.cookies.get(settings.SESSION_COOKIE_NAME)</font>
<font color="red"> 419.             if cookie:</font>
<font color="red"> 420.                 return engine.SessionStore(cookie.value)</font>
<font color="black"> 421.             else:</font>
<font color="red"> 422.                 s = engine.SessionStore()</font>
<font color="red"> 423.                 s.save()</font>
<font color="red"> 424.                 self.cookies[settings.SESSION_COOKIE_NAME] = s.session_key</font>
<font color="red"> 425.                 return s</font>
<font color="red"> 426.         return {}</font>
<font color="green"> 427.     session = property(_session)</font>
<font color="black"> 428. </font>
<font color="green"> 429.     def request(self, **request):</font>
<font color="black"> 430.         &quot;&quot;&quot;</font>
<font color="black"> 431.         The master request method. Composes the environment dictionary</font>
<font color="black"> 432.         and passes to the handler, returning the result of the handler.</font>
<font color="black"> 433.         Assumes defaults for the query environment, which can be overridden</font>
<font color="black"> 434.         using the arguments to the request.</font>
<font color="black"> 435.         &quot;&quot;&quot;</font>
<font color="red"> 436.         environ = self._base_environ(**request)</font>
<font color="black"> 437. </font>
<font color="black"> 438.         # Curry a data dictionary into an instance of the template renderer</font>
<font color="black"> 439.         # callback function.</font>
<font color="red"> 440.         data = {}</font>
<font color="red"> 441.         on_template_render = curry(store_rendered_templates, data)</font>
<font color="red"> 442.         signal_uid = &quot;template-render-%s&quot; % id(request)</font>
<font color="red"> 443.         signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)</font>
<font color="black"> 444.         # Capture exceptions created by the handler.</font>
<font color="red"> 445.         exception_uid = &quot;request-exception-%s&quot; % id(request)</font>
<font color="red"> 446.         got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)</font>
<font color="red"> 447.         try:</font>
<font color="red"> 448.             try:</font>
<font color="red"> 449.                 response = self.handler(environ)</font>
<font color="red"> 450.             except TemplateDoesNotExist as e:</font>
<font color="black"> 451.                 # If the view raises an exception, Django will attempt to show</font>
<font color="black"> 452.                 # the 500.html template. If that template is not available,</font>
<font color="black"> 453.                 # we should ignore the error in favor of re-raising the</font>
<font color="black"> 454.                 # underlying exception that caused the 500 error. Any other</font>
<font color="black"> 455.                 # template found to be missing during view error handling</font>
<font color="black"> 456.                 # should be reported as-is.</font>
<font color="red"> 457.                 if e.args != ('500.html',):</font>
<font color="red"> 458.                     raise</font>
<font color="black"> 459. </font>
<font color="black"> 460.             # Look for a signalled exception, clear the current context</font>
<font color="black"> 461.             # exception data, then re-raise the signalled exception.</font>
<font color="black"> 462.             # Also make sure that the signalled exception is cleared from</font>
<font color="black"> 463.             # the local cache!</font>
<font color="red"> 464.             if self.exc_info:</font>
<font color="red"> 465.                 exc_info = self.exc_info</font>
<font color="red"> 466.                 self.exc_info = None</font>
<font color="red"> 467.                 six.reraise(*exc_info)</font>
<font color="black"> 468. </font>
<font color="black"> 469.             # Save the client and request that stimulated the response.</font>
<font color="red"> 470.             response.client = self</font>
<font color="red"> 471.             response.request = request</font>
<font color="black"> 472. </font>
<font color="black"> 473.             # Add any rendered template detail to the response.</font>
<font color="red"> 474.             response.templates = data.get(&quot;templates&quot;, [])</font>
<font color="red"> 475.             response.context = data.get(&quot;context&quot;)</font>
<font color="black"> 476. </font>
<font color="red"> 477.             response.json = curry(self._parse_json, response)</font>
<font color="black"> 478. </font>
<font color="black"> 479.             # Attach the ResolverMatch instance to the response</font>
<font color="red"> 480.             response.resolver_match = SimpleLazyObject(</font>
<font color="red"> 481.                 lambda: urlresolvers.resolve(request['PATH_INFO']))</font>
<font color="black"> 482. </font>
<font color="black"> 483.             # Flatten a single context. Not really necessary anymore thanks to</font>
<font color="black"> 484.             # the __getattr__ flattening in ContextList, but has some edge-case</font>
<font color="black"> 485.             # backwards-compatibility implications.</font>
<font color="red"> 486.             if response.context and len(response.context) == 1:</font>
<font color="red"> 487.                 response.context = response.context[0]</font>
<font color="black"> 488. </font>
<font color="black"> 489.             # Update persistent cookie data.</font>
<font color="red"> 490.             if response.cookies:</font>
<font color="red"> 491.                 self.cookies.update(response.cookies)</font>
<font color="black"> 492. </font>
<font color="red"> 493.             return response</font>
<font color="black"> 494.         finally:</font>
<font color="red"> 495.             signals.template_rendered.disconnect(dispatch_uid=signal_uid)</font>
<font color="red"> 496.             got_request_exception.disconnect(dispatch_uid=exception_uid)</font>
<font color="black"> 497. </font>
<font color="green"> 498.     def get(self, path, data=None, follow=False, secure=False, **extra):</font>
<font color="black"> 499.         &quot;&quot;&quot;</font>
<font color="black"> 500.         Requests a response from the server using GET.</font>
<font color="black"> 501.         &quot;&quot;&quot;</font>
<font color="red"> 502.         response = super(Client, self).get(path, data=data, secure=secure,</font>
<font color="red"> 503.                                            **extra)</font>
<font color="red"> 504.         if follow:</font>
<font color="red"> 505.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 506.         return response</font>
<font color="black"> 507. </font>
<font color="green"> 508.     def post(self, path, data=None, content_type=MULTIPART_CONTENT,</font>
<font color="green"> 509.              follow=False, secure=False, **extra):</font>
<font color="black"> 510.         &quot;&quot;&quot;</font>
<font color="black"> 511.         Requests a response from the server using POST.</font>
<font color="black"> 512.         &quot;&quot;&quot;</font>
<font color="red"> 513.         response = super(Client, self).post(path, data=data,</font>
<font color="red"> 514.                                             content_type=content_type,</font>
<font color="red"> 515.                                             secure=secure, **extra)</font>
<font color="red"> 516.         if follow:</font>
<font color="red"> 517.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 518.         return response</font>
<font color="black"> 519. </font>
<font color="green"> 520.     def head(self, path, data=None, follow=False, secure=False, **extra):</font>
<font color="black"> 521.         &quot;&quot;&quot;</font>
<font color="black"> 522.         Request a response from the server using HEAD.</font>
<font color="black"> 523.         &quot;&quot;&quot;</font>
<font color="red"> 524.         response = super(Client, self).head(path, data=data, secure=secure,</font>
<font color="red"> 525.                                             **extra)</font>
<font color="red"> 526.         if follow:</font>
<font color="red"> 527.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 528.         return response</font>
<font color="black"> 529. </font>
<font color="green"> 530.     def options(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 531.                 follow=False, secure=False, **extra):</font>
<font color="black"> 532.         &quot;&quot;&quot;</font>
<font color="black"> 533.         Request a response from the server using OPTIONS.</font>
<font color="black"> 534.         &quot;&quot;&quot;</font>
<font color="red"> 535.         response = super(Client, self).options(path, data=data,</font>
<font color="red"> 536.                                                content_type=content_type,</font>
<font color="red"> 537.                                                secure=secure, **extra)</font>
<font color="red"> 538.         if follow:</font>
<font color="red"> 539.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 540.         return response</font>
<font color="black"> 541. </font>
<font color="green"> 542.     def put(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 543.             follow=False, secure=False, **extra):</font>
<font color="black"> 544.         &quot;&quot;&quot;</font>
<font color="black"> 545.         Send a resource to the server using PUT.</font>
<font color="black"> 546.         &quot;&quot;&quot;</font>
<font color="red"> 547.         response = super(Client, self).put(path, data=data,</font>
<font color="red"> 548.                                            content_type=content_type,</font>
<font color="red"> 549.                                            secure=secure, **extra)</font>
<font color="red"> 550.         if follow:</font>
<font color="red"> 551.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 552.         return response</font>
<font color="black"> 553. </font>
<font color="green"> 554.     def patch(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 555.               follow=False, secure=False, **extra):</font>
<font color="black"> 556.         &quot;&quot;&quot;</font>
<font color="black"> 557.         Send a resource to the server using PATCH.</font>
<font color="black"> 558.         &quot;&quot;&quot;</font>
<font color="red"> 559.         response = super(Client, self).patch(path, data=data,</font>
<font color="red"> 560.                                              content_type=content_type,</font>
<font color="red"> 561.                                              secure=secure, **extra)</font>
<font color="red"> 562.         if follow:</font>
<font color="red"> 563.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 564.         return response</font>
<font color="black"> 565. </font>
<font color="green"> 566.     def delete(self, path, data='', content_type='application/octet-stream',</font>
<font color="green"> 567.                follow=False, secure=False, **extra):</font>
<font color="black"> 568.         &quot;&quot;&quot;</font>
<font color="black"> 569.         Send a DELETE request to the server.</font>
<font color="black"> 570.         &quot;&quot;&quot;</font>
<font color="red"> 571.         response = super(Client, self).delete(path, data=data,</font>
<font color="red"> 572.                                               content_type=content_type,</font>
<font color="red"> 573.                                               secure=secure, **extra)</font>
<font color="red"> 574.         if follow:</font>
<font color="red"> 575.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 576.         return response</font>
<font color="black"> 577. </font>
<font color="green"> 578.     def trace(self, path, data='', follow=False, secure=False, **extra):</font>
<font color="black"> 579.         &quot;&quot;&quot;</font>
<font color="black"> 580.         Send a TRACE request to the server.</font>
<font color="black"> 581.         &quot;&quot;&quot;</font>
<font color="red"> 582.         response = super(Client, self).trace(path, data=data, secure=secure, **extra)</font>
<font color="red"> 583.         if follow:</font>
<font color="red"> 584.             response = self._handle_redirects(response, **extra)</font>
<font color="red"> 585.         return response</font>
<font color="black"> 586. </font>
<font color="green"> 587.     def login(self, **credentials):</font>
<font color="black"> 588.         &quot;&quot;&quot;</font>
<font color="black"> 589.         Sets the Factory to appear as if it has successfully logged into a site.</font>
<font color="black"> 590. </font>
<font color="black"> 591.         Returns True if login is possible; False if the provided credentials</font>
<font color="black"> 592.         are incorrect, or the user is inactive, or if the sessions framework is</font>
<font color="black"> 593.         not available.</font>
<font color="black"> 594.         &quot;&quot;&quot;</font>
<font color="red"> 595.         from django.contrib.auth import authenticate</font>
<font color="red"> 596.         user = authenticate(**credentials)</font>
<font color="red"> 597.         if (user and user.is_active and</font>
<font color="red"> 598.                 apps.is_installed('django.contrib.sessions')):</font>
<font color="red"> 599.             self._login(user)</font>
<font color="red"> 600.             return True</font>
<font color="black"> 601.         else:</font>
<font color="red"> 602.             return False</font>
<font color="black"> 603. </font>
<font color="green"> 604.     def force_login(self, user, backend=None):</font>
<font color="red"> 605.         if backend is None:</font>
<font color="red"> 606.             backend = settings.AUTHENTICATION_BACKENDS[0]</font>
<font color="red"> 607.         user.backend = backend</font>
<font color="red"> 608.         self._login(user)</font>
<font color="black"> 609. </font>
<font color="green"> 610.     def _login(self, user):</font>
<font color="red"> 611.         from django.contrib.auth import login</font>
<font color="red"> 612.         engine = import_module(settings.SESSION_ENGINE)</font>
<font color="black"> 613. </font>
<font color="black"> 614.         # Create a fake request to store login details.</font>
<font color="red"> 615.         request = HttpRequest()</font>
<font color="black"> 616. </font>
<font color="red"> 617.         if self.session:</font>
<font color="red"> 618.             request.session = self.session</font>
<font color="black"> 619.         else:</font>
<font color="red"> 620.             request.session = engine.SessionStore()</font>
<font color="red"> 621.         login(request, user)</font>
<font color="black"> 622. </font>
<font color="black"> 623.         # Save the session values.</font>
<font color="red"> 624.         request.session.save()</font>
<font color="black"> 625. </font>
<font color="black"> 626.         # Set the cookie to represent the session.</font>
<font color="red"> 627.         session_cookie = settings.SESSION_COOKIE_NAME</font>
<font color="red"> 628.         self.cookies[session_cookie] = request.session.session_key</font>
<font color="red"> 629.         cookie_data = {</font>
<font color="red"> 630.             'max-age': None,</font>
<font color="red"> 631.             'path': '/',</font>
<font color="red"> 632.             'domain': settings.SESSION_COOKIE_DOMAIN,</font>
<font color="red"> 633.             'secure': settings.SESSION_COOKIE_SECURE or None,</font>
<font color="red"> 634.             'expires': None,</font>
<font color="black"> 635.         }</font>
<font color="red"> 636.         self.cookies[session_cookie].update(cookie_data)</font>
<font color="black"> 637. </font>
<font color="green"> 638.     def logout(self):</font>
<font color="black"> 639.         &quot;&quot;&quot;</font>
<font color="black"> 640.         Removes the authenticated user's cookies and session object.</font>
<font color="black"> 641. </font>
<font color="black"> 642.         Causes the authenticated user to be logged out.</font>
<font color="black"> 643.         &quot;&quot;&quot;</font>
<font color="red"> 644.         from django.contrib.auth import get_user, logout</font>
<font color="black"> 645. </font>
<font color="red"> 646.         request = HttpRequest()</font>
<font color="red"> 647.         engine = import_module(settings.SESSION_ENGINE)</font>
<font color="red"> 648.         if self.session:</font>
<font color="red"> 649.             request.session = self.session</font>
<font color="red"> 650.             request.user = get_user(request)</font>
<font color="black"> 651.         else:</font>
<font color="red"> 652.             request.session = engine.SessionStore()</font>
<font color="red"> 653.         logout(request)</font>
<font color="red"> 654.         self.cookies = SimpleCookie()</font>
<font color="black"> 655. </font>
<font color="green"> 656.     def _parse_json(self, response, **extra):</font>
<font color="red"> 657.         if 'application/json' not in response.get('Content-Type'):</font>
<font color="red"> 658.             raise ValueError(</font>
<font color="red"> 659.                 'Content-Type header is &quot;{0}&quot;, not &quot;application/json&quot;'</font>
<font color="red"> 660.                 .format(response.get('Content-Type'))</font>
<font color="black"> 661.             )</font>
<font color="red"> 662.         return json.loads(response.content.decode(), **extra)</font>
<font color="black"> 663. </font>
<font color="green"> 664.     def _handle_redirects(self, response, **extra):</font>
<font color="black"> 665.         &quot;Follows any redirects by requesting responses from the server using GET.&quot;</font>
<font color="black"> 666. </font>
<font color="red"> 667.         response.redirect_chain = []</font>
<font color="red"> 668.         while response.status_code in (301, 302, 303, 307):</font>
<font color="red"> 669.             response_url = response.url</font>
<font color="red"> 670.             redirect_chain = response.redirect_chain</font>
<font color="red"> 671.             redirect_chain.append((response_url, response.status_code))</font>
<font color="black"> 672. </font>
<font color="red"> 673.             url = urlsplit(response_url)</font>
<font color="red"> 674.             if url.scheme:</font>
<font color="red"> 675.                 extra['wsgi.url_scheme'] = url.scheme</font>
<font color="red"> 676.             if url.hostname:</font>
<font color="red"> 677.                 extra['SERVER_NAME'] = url.hostname</font>
<font color="red"> 678.             if url.port:</font>
<font color="red"> 679.                 extra['SERVER_PORT'] = str(url.port)</font>
<font color="black"> 680. </font>
<font color="red"> 681.             response = self.get(url.path, QueryDict(url.query), follow=False, **extra)</font>
<font color="red"> 682.             response.redirect_chain = redirect_chain</font>
<font color="black"> 683. </font>
<font color="red"> 684.             if redirect_chain[-1] in redirect_chain[:-1]:</font>
<font color="black"> 685.                 # Check that we're not redirecting to somewhere we've already</font>
<font color="black"> 686.                 # been to, to prevent loops.</font>
<font color="red"> 687.                 raise RedirectCycleError(&quot;Redirect loop detected.&quot;, last_response=response)</font>
<font color="red"> 688.             if len(redirect_chain) &gt; 20:</font>
<font color="black"> 689.                 # Such a lengthy chain likely also means a loop, but one with</font>
<font color="black"> 690.                 # a growing path, changing view, or changing query argument;</font>
<font color="black"> 691.                 # 20 is the value of &quot;network.http.redirection-limit&quot; from Firefox.</font>
<font color="red"> 692.                 raise RedirectCycleError(&quot;Too many redirects.&quot;, last_response=response)</font>
<font color="black"> 693. </font>
<font color="red"> 694.         return response</font>
</pre>

