source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/template/library.py</b><br>


file stats: <b>206 lines, 84 executed: 40.8% covered</b>
<pre>
<font color="green">   1. import functools</font>
<font color="green">   2. import warnings</font>
<font color="green">   3. from importlib import import_module</font>
<font color="black">   4. </font>
<font color="green">   5. from django.utils import six</font>
<font color="green">   6. from django.utils.deprecation import RemovedInDjango20Warning</font>
<font color="green">   7. from django.utils.html import conditional_escape</font>
<font color="green">   8. from django.utils.inspect import getargspec</font>
<font color="green">   9. from django.utils.itercompat import is_iterable</font>
<font color="black">  10. </font>
<font color="green">  11. from .base import Node, Template, token_kwargs</font>
<font color="green">  12. from .exceptions import TemplateSyntaxError</font>
<font color="black">  13. </font>
<font color="black">  14. </font>
<font color="green">  15. class InvalidTemplateLibrary(Exception):</font>
<font color="green">  16.     pass</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. class Library(object):</font>
<font color="black">  20.     &quot;&quot;&quot;</font>
<font color="black">  21.     A class for registering template tags and filters. Compiled filter and</font>
<font color="black">  22.     template tag functions are stored in the filters and tags attributes.</font>
<font color="black">  23.     The filter, simple_tag, and inclusion_tag methods provide a convenient</font>
<font color="black">  24.     way to register callables as tags.</font>
<font color="green">  25.     &quot;&quot;&quot;</font>
<font color="green">  26.     def __init__(self):</font>
<font color="green">  27.         self.filters = {}</font>
<font color="green">  28.         self.tags = {}</font>
<font color="black">  29. </font>
<font color="green">  30.     def tag(self, name=None, compile_function=None):</font>
<font color="green">  31.         if name is None and compile_function is None:</font>
<font color="black">  32.             # @register.tag()</font>
<font color="red">  33.             return self.tag_function</font>
<font color="green">  34.         elif name is not None and compile_function is None:</font>
<font color="green">  35.             if callable(name):</font>
<font color="black">  36.                 # @register.tag</font>
<font color="green">  37.                 return self.tag_function(name)</font>
<font color="black">  38.             else:</font>
<font color="black">  39.                 # @register.tag('somename') or @register.tag(name='somename')</font>
<font color="green">  40.                 def dec(func):</font>
<font color="green">  41.                     return self.tag(name, func)</font>
<font color="green">  42.                 return dec</font>
<font color="green">  43.         elif name is not None and compile_function is not None:</font>
<font color="black">  44.             # register.tag('somename', somefunc)</font>
<font color="green">  45.             self.tags[name] = compile_function</font>
<font color="green">  46.             return compile_function</font>
<font color="black">  47.         else:</font>
<font color="red">  48.             raise ValueError(</font>
<font color="red">  49.                 &quot;Unsupported arguments to Library.tag: (%r, %r)&quot; %</font>
<font color="red">  50.                 (name, compile_function),</font>
<font color="black">  51.             )</font>
<font color="black">  52. </font>
<font color="green">  53.     def tag_function(self, func):</font>
<font color="green">  54.         self.tags[getattr(func, &quot;_decorated_function&quot;, func).__name__] = func</font>
<font color="green">  55.         return func</font>
<font color="black">  56. </font>
<font color="green">  57.     def filter(self, name=None, filter_func=None, **flags):</font>
<font color="black">  58.         &quot;&quot;&quot;</font>
<font color="black">  59.         Register a callable as a template filter. Example:</font>
<font color="black">  60. </font>
<font color="black">  61.         @register.filter</font>
<font color="black">  62.         def lower(value):</font>
<font color="black">  63.             return value.lower()</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="green">  65.         if name is None and filter_func is None:</font>
<font color="black">  66.             # @register.filter()</font>
<font color="green">  67.             def dec(func):</font>
<font color="green">  68.                 return self.filter_function(func, **flags)</font>
<font color="green">  69.             return dec</font>
<font color="green">  70.         elif name is not None and filter_func is None:</font>
<font color="green">  71.             if callable(name):</font>
<font color="black">  72.                 # @register.filter</font>
<font color="green">  73.                 return self.filter_function(name, **flags)</font>
<font color="black">  74.             else:</font>
<font color="black">  75.                 # @register.filter('somename') or @register.filter(name='somename')</font>
<font color="green">  76.                 def dec(func):</font>
<font color="green">  77.                     return self.filter(name, func, **flags)</font>
<font color="green">  78.                 return dec</font>
<font color="green">  79.         elif name is not None and filter_func is not None:</font>
<font color="black">  80.             # register.filter('somename', somefunc)</font>
<font color="green">  81.             self.filters[name] = filter_func</font>
<font color="green">  82.             for attr in ('expects_localtime', 'is_safe', 'needs_autoescape'):</font>
<font color="green">  83.                 if attr in flags:</font>
<font color="green">  84.                     value = flags[attr]</font>
<font color="black">  85.                     # set the flag on the filter for FilterExpression.resolve</font>
<font color="green">  86.                     setattr(filter_func, attr, value)</font>
<font color="black">  87.                     # set the flag on the innermost decorated function</font>
<font color="black">  88.                     # for decorators that need it, e.g. stringfilter</font>
<font color="green">  89.                     if hasattr(filter_func, &quot;_decorated_function&quot;):</font>
<font color="green">  90.                         setattr(filter_func._decorated_function, attr, value)</font>
<font color="green">  91.             filter_func._filter_name = name</font>
<font color="green">  92.             return filter_func</font>
<font color="black">  93.         else:</font>
<font color="red">  94.             raise ValueError(</font>
<font color="red">  95.                 &quot;Unsupported arguments to Library.filter: (%r, %r)&quot; %</font>
<font color="red">  96.                 (name, filter_func),</font>
<font color="black">  97.             )</font>
<font color="black">  98. </font>
<font color="green">  99.     def filter_function(self, func, **flags):</font>
<font color="green"> 100.         name = getattr(func, &quot;_decorated_function&quot;, func).__name__</font>
<font color="green"> 101.         return self.filter(name, func, **flags)</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def simple_tag(self, func=None, takes_context=None, name=None):</font>
<font color="black"> 104.         &quot;&quot;&quot;</font>
<font color="black"> 105.         Register a callable as a compiled template tag. Example:</font>
<font color="black"> 106. </font>
<font color="black"> 107.         @register.simple_tag</font>
<font color="black"> 108.         def hello(*args, **kwargs):</font>
<font color="black"> 109.             return 'world'</font>
<font color="black"> 110.         &quot;&quot;&quot;</font>
<font color="green"> 111.         def dec(func):</font>
<font color="green"> 112.             params, varargs, varkw, defaults = getargspec(func)</font>
<font color="green"> 113.             function_name = (name or getattr(func, '_decorated_function', func).__name__)</font>
<font color="black"> 114. </font>
<font color="green"> 115.             @functools.wraps(func)</font>
<font color="black"> 116.             def compile_func(parser, token):</font>
<font color="red"> 117.                 bits = token.split_contents()[1:]</font>
<font color="red"> 118.                 target_var = None</font>
<font color="red"> 119.                 if len(bits) &gt;= 2 and bits[-2] == 'as':</font>
<font color="red"> 120.                     target_var = bits[-1]</font>
<font color="red"> 121.                     bits = bits[:-2]</font>
<font color="red"> 122.                 args, kwargs = parse_bits(parser, bits, params,</font>
<font color="red"> 123.                     varargs, varkw, defaults, takes_context, function_name)</font>
<font color="red"> 124.                 return SimpleNode(func, takes_context, args, kwargs, target_var)</font>
<font color="green"> 125.             self.tag(function_name, compile_func)</font>
<font color="green"> 126.             return func</font>
<font color="black"> 127. </font>
<font color="green"> 128.         if func is None:</font>
<font color="black"> 129.             # @register.simple_tag(...)</font>
<font color="green"> 130.             return dec</font>
<font color="green"> 131.         elif callable(func):</font>
<font color="black"> 132.             # @register.simple_tag</font>
<font color="green"> 133.             return dec(func)</font>
<font color="black"> 134.         else:</font>
<font color="red"> 135.             raise ValueError(&quot;Invalid arguments provided to simple_tag&quot;)</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def assignment_tag(self, func=None, takes_context=None, name=None):</font>
<font color="red"> 138.         warnings.warn(</font>
<font color="red"> 139.             &quot;assignment_tag() is deprecated. Use simple_tag() instead&quot;,</font>
<font color="red"> 140.             RemovedInDjango20Warning,</font>
<font color="red"> 141.             stacklevel=2,</font>
<font color="black"> 142.         )</font>
<font color="red"> 143.         return self.simple_tag(func, takes_context, name)</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def inclusion_tag(self, filename, func=None, takes_context=None, name=None):</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="black"> 147.         Register a callable as an inclusion tag:</font>
<font color="black"> 148. </font>
<font color="black"> 149.         @register.inclusion_tag('results.html')</font>
<font color="black"> 150.         def show_results(poll):</font>
<font color="black"> 151.             choices = poll.choice_set.all()</font>
<font color="black"> 152.             return {'choices': choices}</font>
<font color="black"> 153.         &quot;&quot;&quot;</font>
<font color="red"> 154.         def dec(func):</font>
<font color="red"> 155.             params, varargs, varkw, defaults = getargspec(func)</font>
<font color="red"> 156.             function_name = (name or getattr(func, '_decorated_function', func).__name__)</font>
<font color="black"> 157. </font>
<font color="red"> 158.             @functools.wraps(func)</font>
<font color="black"> 159.             def compile_func(parser, token):</font>
<font color="red"> 160.                 bits = token.split_contents()[1:]</font>
<font color="red"> 161.                 args, kwargs = parse_bits(</font>
<font color="red"> 162.                     parser, bits, params, varargs, varkw, defaults,</font>
<font color="red"> 163.                     takes_context, function_name,</font>
<font color="black"> 164.                 )</font>
<font color="red"> 165.                 return InclusionNode(</font>
<font color="red"> 166.                     func, takes_context, args, kwargs, filename,</font>
<font color="black"> 167.                 )</font>
<font color="red"> 168.             self.tag(function_name, compile_func)</font>
<font color="red"> 169.             return func</font>
<font color="red"> 170.         return dec</font>
<font color="black"> 171. </font>
<font color="black"> 172. </font>
<font color="green"> 173. class TagHelperNode(Node):</font>
<font color="black"> 174.     &quot;&quot;&quot;</font>
<font color="black"> 175.     Base class for tag helper nodes such as SimpleNode and InclusionNode.</font>
<font color="black"> 176.     Manages the positional and keyword arguments to be passed to the decorated</font>
<font color="black"> 177.     function.</font>
<font color="green"> 178.     &quot;&quot;&quot;</font>
<font color="green"> 179.     def __init__(self, func, takes_context, args, kwargs):</font>
<font color="red"> 180.         self.func = func</font>
<font color="red"> 181.         self.takes_context = takes_context</font>
<font color="red"> 182.         self.args = args</font>
<font color="red"> 183.         self.kwargs = kwargs</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def get_resolved_arguments(self, context):</font>
<font color="red"> 186.         resolved_args = [var.resolve(context) for var in self.args]</font>
<font color="red"> 187.         if self.takes_context:</font>
<font color="red"> 188.             resolved_args = [context] + resolved_args</font>
<font color="red"> 189.         resolved_kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}</font>
<font color="red"> 190.         return resolved_args, resolved_kwargs</font>
<font color="black"> 191. </font>
<font color="black"> 192. </font>
<font color="green"> 193. class SimpleNode(TagHelperNode):</font>
<font color="black"> 194. </font>
<font color="green"> 195.     def __init__(self, func, takes_context, args, kwargs, target_var):</font>
<font color="red"> 196.         super(SimpleNode, self).__init__(func, takes_context, args, kwargs)</font>
<font color="red"> 197.         self.target_var = target_var</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def render(self, context):</font>
<font color="red"> 200.         resolved_args, resolved_kwargs = self.get_resolved_arguments(context)</font>
<font color="red"> 201.         output = self.func(*resolved_args, **resolved_kwargs)</font>
<font color="red"> 202.         if self.target_var is not None:</font>
<font color="red"> 203.             context[self.target_var] = output</font>
<font color="red"> 204.             return ''</font>
<font color="red"> 205.         if context.autoescape:</font>
<font color="red"> 206.             output = conditional_escape(output)</font>
<font color="red"> 207.         return output</font>
<font color="black"> 208. </font>
<font color="black"> 209. </font>
<font color="green"> 210. class InclusionNode(TagHelperNode):</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def __init__(self, func, takes_context, args, kwargs, filename):</font>
<font color="red"> 213.         super(InclusionNode, self).__init__(func, takes_context, args, kwargs)</font>
<font color="red"> 214.         self.filename = filename</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def render(self, context):</font>
<font color="black"> 217.         &quot;&quot;&quot;</font>
<font color="black"> 218.         Render the specified template and context. Cache the template object</font>
<font color="black"> 219.         in render_context to avoid reparsing and loading when used in a for</font>
<font color="black"> 220.         loop.</font>
<font color="black"> 221.         &quot;&quot;&quot;</font>
<font color="red"> 222.         resolved_args, resolved_kwargs = self.get_resolved_arguments(context)</font>
<font color="red"> 223.         _dict = self.func(*resolved_args, **resolved_kwargs)</font>
<font color="black"> 224. </font>
<font color="red"> 225.         t = context.render_context.get(self)</font>
<font color="red"> 226.         if t is None:</font>
<font color="red"> 227.             if isinstance(self.filename, Template):</font>
<font color="red"> 228.                 t = self.filename</font>
<font color="red"> 229.             elif isinstance(getattr(self.filename, 'template', None), Template):</font>
<font color="red"> 230.                 t = self.filename.template</font>
<font color="red"> 231.             elif not isinstance(self.filename, six.string_types) and is_iterable(self.filename):</font>
<font color="red"> 232.                 t = context.template.engine.select_template(self.filename)</font>
<font color="black"> 233.             else:</font>
<font color="red"> 234.                 t = context.template.engine.get_template(self.filename)</font>
<font color="red"> 235.             context.render_context[self] = t</font>
<font color="red"> 236.         new_context = context.new(_dict)</font>
<font color="black"> 237.         # Copy across the CSRF token, if present, because inclusion tags are</font>
<font color="black"> 238.         # often used for forms, and we need instructions for using CSRF</font>
<font color="black"> 239.         # protection to be as simple as possible.</font>
<font color="red"> 240.         csrf_token = context.get('csrf_token')</font>
<font color="red"> 241.         if csrf_token is not None:</font>
<font color="red"> 242.             new_context['csrf_token'] = csrf_token</font>
<font color="red"> 243.         return t.render(new_context)</font>
<font color="black"> 244. </font>
<font color="black"> 245. </font>
<font color="green"> 246. def parse_bits(parser, bits, params, varargs, varkw, defaults,</font>
<font color="black"> 247.                takes_context, name):</font>
<font color="black"> 248.     &quot;&quot;&quot;</font>
<font color="black"> 249.     Parse bits for template tag helpers simple_tag and inclusion_tag, in</font>
<font color="black"> 250.     particular by detecting syntax errors and by extracting positional and</font>
<font color="black"> 251.     keyword arguments.</font>
<font color="black"> 252.     &quot;&quot;&quot;</font>
<font color="red"> 253.     if takes_context:</font>
<font color="red"> 254.         if params[0] == 'context':</font>
<font color="red"> 255.             params = params[1:]</font>
<font color="black"> 256.         else:</font>
<font color="red"> 257.             raise TemplateSyntaxError(</font>
<font color="red"> 258.                 &quot;'%s' is decorated with takes_context=True so it must &quot;</font>
<font color="red"> 259.                 &quot;have a first argument of 'context'&quot; % name)</font>
<font color="red"> 260.     args = []</font>
<font color="red"> 261.     kwargs = {}</font>
<font color="red"> 262.     unhandled_params = list(params)</font>
<font color="red"> 263.     for bit in bits:</font>
<font color="black"> 264.         # First we try to extract a potential kwarg from the bit</font>
<font color="red"> 265.         kwarg = token_kwargs([bit], parser)</font>
<font color="red"> 266.         if kwarg:</font>
<font color="black"> 267.             # The kwarg was successfully extracted</font>
<font color="red"> 268.             param, value = kwarg.popitem()</font>
<font color="red"> 269.             if param not in params and varkw is None:</font>
<font color="black"> 270.                 # An unexpected keyword argument was supplied</font>
<font color="red"> 271.                 raise TemplateSyntaxError(</font>
<font color="red"> 272.                     &quot;'%s' received unexpected keyword argument '%s'&quot; %</font>
<font color="red"> 273.                     (name, param))</font>
<font color="red"> 274.             elif param in kwargs:</font>
<font color="black"> 275.                 # The keyword argument has already been supplied once</font>
<font color="red"> 276.                 raise TemplateSyntaxError(</font>
<font color="red"> 277.                     &quot;'%s' received multiple values for keyword argument '%s'&quot; %</font>
<font color="red"> 278.                     (name, param))</font>
<font color="black"> 279.             else:</font>
<font color="black"> 280.                 # All good, record the keyword argument</font>
<font color="red"> 281.                 kwargs[str(param)] = value</font>
<font color="red"> 282.                 if param in unhandled_params:</font>
<font color="black"> 283.                     # If using the keyword syntax for a positional arg, then</font>
<font color="black"> 284.                     # consume it.</font>
<font color="red"> 285.                     unhandled_params.remove(param)</font>
<font color="black"> 286.         else:</font>
<font color="red"> 287.             if kwargs:</font>
<font color="red"> 288.                 raise TemplateSyntaxError(</font>
<font color="red"> 289.                     &quot;'%s' received some positional argument(s) after some &quot;</font>
<font color="red"> 290.                     &quot;keyword argument(s)&quot; % name)</font>
<font color="black"> 291.             else:</font>
<font color="black"> 292.                 # Record the positional argument</font>
<font color="red"> 293.                 args.append(parser.compile_filter(bit))</font>
<font color="red"> 294.                 try:</font>
<font color="black"> 295.                     # Consume from the list of expected positional arguments</font>
<font color="red"> 296.                     unhandled_params.pop(0)</font>
<font color="red"> 297.                 except IndexError:</font>
<font color="red"> 298.                     if varargs is None:</font>
<font color="red"> 299.                         raise TemplateSyntaxError(</font>
<font color="red"> 300.                             &quot;'%s' received too many positional arguments&quot; %</font>
<font color="red"> 301.                             name)</font>
<font color="red"> 302.     if defaults is not None:</font>
<font color="black"> 303.         # Consider the last n params handled, where n is the</font>
<font color="black"> 304.         # number of defaults.</font>
<font color="red"> 305.         unhandled_params = unhandled_params[:-len(defaults)]</font>
<font color="red"> 306.     if unhandled_params:</font>
<font color="black"> 307.         # Some positional arguments were not supplied</font>
<font color="red"> 308.         raise TemplateSyntaxError(</font>
<font color="red"> 309.             &quot;'%s' did not receive value(s) for the argument(s): %s&quot; %</font>
<font color="red"> 310.             (name, &quot;, &quot;.join(&quot;'%s'&quot; % p for p in unhandled_params)))</font>
<font color="red"> 311.     return args, kwargs</font>
<font color="black"> 312. </font>
<font color="black"> 313. </font>
<font color="green"> 314. def import_library(name):</font>
<font color="black"> 315.     &quot;&quot;&quot;</font>
<font color="black"> 316.     Load a Library object from a template tag module.</font>
<font color="black"> 317.     &quot;&quot;&quot;</font>
<font color="green"> 318.     try:</font>
<font color="green"> 319.         module = import_module(name)</font>
<font color="red"> 320.     except ImportError as e:</font>
<font color="red"> 321.         raise InvalidTemplateLibrary(</font>
<font color="red"> 322.             &quot;Invalid template library specified. ImportError raised when &quot;</font>
<font color="red"> 323.             &quot;trying to load '%s': %s&quot; % (name, e)</font>
<font color="black"> 324.         )</font>
<font color="green"> 325.     try:</font>
<font color="green"> 326.         return module.register</font>
<font color="red"> 327.     except AttributeError:</font>
<font color="red"> 328.         raise InvalidTemplateLibrary(</font>
<font color="red"> 329.             &quot;Module  %s does not have a variable named 'register'&quot; % name,</font>
<font color="black"> 330.         )</font>
</pre>

