source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/forms/utils.py</b><br>


file stats: <b>117 lines, 43 executed: 36.8% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import json</font>
<font color="green">   4. import sys</font>
<font color="black">   5. </font>
<font color="green">   6. from django.conf import settings</font>
<font color="green">   7. from django.core.exceptions import ValidationError  # backwards compatibility</font>
<font color="green">   8. from django.utils import six, timezone</font>
<font color="green">   9. from django.utils.encoding import force_text, python_2_unicode_compatible</font>
<font color="green">  10. from django.utils.html import escape, format_html, format_html_join, html_safe</font>
<font color="green">  11. from django.utils.translation import ugettext_lazy as _</font>
<font color="black">  12. </font>
<font color="green">  13. try:</font>
<font color="green">  14.     from collections import UserList</font>
<font color="green">  15. except ImportError:  # Python 2</font>
<font color="green">  16.     from UserList import UserList</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. def pretty_name(name):</font>
<font color="black">  20.     &quot;&quot;&quot;Converts 'first_name' to 'First name'&quot;&quot;&quot;</font>
<font color="red">  21.     if not name:</font>
<font color="red">  22.         return ''</font>
<font color="red">  23.     return name.replace('_', ' ').capitalize()</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. def flatatt(attrs):</font>
<font color="black">  27.     &quot;&quot;&quot;</font>
<font color="black">  28.     Convert a dictionary of attributes to a single string.</font>
<font color="black">  29.     The returned string will contain a leading space followed by key=&quot;value&quot;,</font>
<font color="black">  30.     XML-style pairs. In the case of a boolean value, the key will appear</font>
<font color="black">  31.     without a value. It is assumed that the keys do not need to be</font>
<font color="black">  32.     XML-escaped. If the passed dictionary is empty, then return an empty</font>
<font color="black">  33.     string.</font>
<font color="black">  34. </font>
<font color="black">  35.     The result is passed through 'mark_safe' (by way of 'format_html_join').</font>
<font color="black">  36.     &quot;&quot;&quot;</font>
<font color="red">  37.     key_value_attrs = []</font>
<font color="red">  38.     boolean_attrs = []</font>
<font color="red">  39.     for attr, value in attrs.items():</font>
<font color="red">  40.         if isinstance(value, bool):</font>
<font color="red">  41.             if value:</font>
<font color="red">  42.                 boolean_attrs.append((attr,))</font>
<font color="black">  43.         else:</font>
<font color="red">  44.             key_value_attrs.append((attr, value))</font>
<font color="black">  45. </font>
<font color="black">  46.     return (</font>
<font color="red">  47.         format_html_join('', ' {}=&quot;{}&quot;', sorted(key_value_attrs)) +</font>
<font color="red">  48.         format_html_join('', ' {}', sorted(boolean_attrs))</font>
<font color="black">  49.     )</font>
<font color="black">  50. </font>
<font color="black">  51. </font>
<font color="green">  52. @html_safe</font>
<font color="green">  53. @python_2_unicode_compatible</font>
<font color="green">  54. class ErrorDict(dict):</font>
<font color="black">  55.     &quot;&quot;&quot;</font>
<font color="black">  56.     A collection of errors that knows how to display itself in various formats.</font>
<font color="black">  57. </font>
<font color="black">  58.     The dictionary keys are the field names, and the values are the errors.</font>
<font color="green">  59.     &quot;&quot;&quot;</font>
<font color="green">  60.     def as_data(self):</font>
<font color="red">  61.         return {f: e.as_data() for f, e in self.items()}</font>
<font color="black">  62. </font>
<font color="green">  63.     def as_json(self, escape_html=False):</font>
<font color="red">  64.         return json.dumps({f: e.get_json_data(escape_html) for f, e in self.items()})</font>
<font color="black">  65. </font>
<font color="green">  66.     def as_ul(self):</font>
<font color="red">  67.         if not self:</font>
<font color="red">  68.             return ''</font>
<font color="red">  69.         return format_html(</font>
<font color="red">  70.             '&lt;ul class=&quot;errorlist&quot;&gt;{}&lt;/ul&gt;',</font>
<font color="red">  71.             format_html_join('', '&lt;li&gt;{}{}&lt;/li&gt;', ((k, force_text(v)) for k, v in self.items()))</font>
<font color="black">  72.         )</font>
<font color="black">  73. </font>
<font color="green">  74.     def as_text(self):</font>
<font color="red">  75.         output = []</font>
<font color="red">  76.         for field, errors in self.items():</font>
<font color="red">  77.             output.append('* %s' % field)</font>
<font color="red">  78.             output.append('\n'.join('  * %s' % e for e in errors))</font>
<font color="red">  79.         return '\n'.join(output)</font>
<font color="black">  80. </font>
<font color="green">  81.     def __str__(self):</font>
<font color="red">  82.         return self.as_ul()</font>
<font color="black">  83. </font>
<font color="black">  84. </font>
<font color="green">  85. @html_safe</font>
<font color="green">  86. @python_2_unicode_compatible</font>
<font color="green">  87. class ErrorList(UserList, list):</font>
<font color="black">  88.     &quot;&quot;&quot;</font>
<font color="black">  89.     A collection of errors that knows how to display itself in various formats.</font>
<font color="green">  90.     &quot;&quot;&quot;</font>
<font color="green">  91.     def __init__(self, initlist=None, error_class=None):</font>
<font color="red">  92.         super(ErrorList, self).__init__(initlist)</font>
<font color="black">  93. </font>
<font color="red">  94.         if error_class is None:</font>
<font color="red">  95.             self.error_class = 'errorlist'</font>
<font color="black">  96.         else:</font>
<font color="red">  97.             self.error_class = 'errorlist {}'.format(error_class)</font>
<font color="black">  98. </font>
<font color="green">  99.     def as_data(self):</font>
<font color="red"> 100.         return ValidationError(self.data).error_list</font>
<font color="black"> 101. </font>
<font color="green"> 102.     def get_json_data(self, escape_html=False):</font>
<font color="red"> 103.         errors = []</font>
<font color="red"> 104.         for error in self.as_data():</font>
<font color="red"> 105.             message = list(error)[0]</font>
<font color="red"> 106.             errors.append({</font>
<font color="red"> 107.                 'message': escape(message) if escape_html else message,</font>
<font color="red"> 108.                 'code': error.code or '',</font>
<font color="black"> 109.             })</font>
<font color="red"> 110.         return errors</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def as_json(self, escape_html=False):</font>
<font color="red"> 113.         return json.dumps(self.get_json_data(escape_html))</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def as_ul(self):</font>
<font color="red"> 116.         if not self.data:</font>
<font color="red"> 117.             return ''</font>
<font color="black"> 118. </font>
<font color="red"> 119.         return format_html(</font>
<font color="red"> 120.             '&lt;ul class=&quot;{}&quot;&gt;{}&lt;/ul&gt;',</font>
<font color="red"> 121.             self.error_class,</font>
<font color="red"> 122.             format_html_join('', '&lt;li&gt;{}&lt;/li&gt;', ((force_text(e),) for e in self))</font>
<font color="black"> 123.         )</font>
<font color="black"> 124. </font>
<font color="green"> 125.     def as_text(self):</font>
<font color="red"> 126.         return '\n'.join('* %s' % e for e in self)</font>
<font color="black"> 127. </font>
<font color="green"> 128.     def __str__(self):</font>
<font color="red"> 129.         return self.as_ul()</font>
<font color="black"> 130. </font>
<font color="green"> 131.     def __repr__(self):</font>
<font color="red"> 132.         return repr(list(self))</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def __contains__(self, item):</font>
<font color="red"> 135.         return item in list(self)</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def __eq__(self, other):</font>
<font color="red"> 138.         return list(self) == other</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def __ne__(self, other):</font>
<font color="red"> 141.         return list(self) != other</font>
<font color="black"> 142. </font>
<font color="green"> 143.     def __getitem__(self, i):</font>
<font color="red"> 144.         error = self.data[i]</font>
<font color="red"> 145.         if isinstance(error, ValidationError):</font>
<font color="red"> 146.             return list(error)[0]</font>
<font color="red"> 147.         return force_text(error)</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def __reduce_ex__(self, *args, **kwargs):</font>
<font color="black"> 150.         # The `list` reduce function returns an iterator as the fourth element</font>
<font color="black"> 151.         # that is normally used for repopulating. Since we only inherit from</font>
<font color="black"> 152.         # `list` for `isinstance` backward compatibility (Refs #17413) we</font>
<font color="black"> 153.         # nullify this iterator as it would otherwise result in duplicate</font>
<font color="black"> 154.         # entries. (Refs #23594)</font>
<font color="red"> 155.         info = super(UserList, self).__reduce_ex__(*args, **kwargs)</font>
<font color="red"> 156.         return info[:3] + (None, None)</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="black"> 159. # Utilities for time zone support in DateTimeField et al.</font>
<font color="black"> 160. </font>
<font color="green"> 161. def from_current_timezone(value):</font>
<font color="black"> 162.     &quot;&quot;&quot;</font>
<font color="black"> 163.     When time zone support is enabled, convert naive datetimes</font>
<font color="black"> 164.     entered in the current time zone to aware datetimes.</font>
<font color="black"> 165.     &quot;&quot;&quot;</font>
<font color="red"> 166.     if settings.USE_TZ and value is not None and timezone.is_naive(value):</font>
<font color="red"> 167.         current_timezone = timezone.get_current_timezone()</font>
<font color="red"> 168.         try:</font>
<font color="red"> 169.             return timezone.make_aware(value, current_timezone)</font>
<font color="red"> 170.         except Exception:</font>
<font color="red"> 171.             message = _(</font>
<font color="red"> 172.                 '%(datetime)s couldn\'t be interpreted '</font>
<font color="black"> 173.                 'in time zone %(current_timezone)s; it '</font>
<font color="black"> 174.                 'may be ambiguous or it may not exist.'</font>
<font color="black"> 175.             )</font>
<font color="red"> 176.             params = {'datetime': value, 'current_timezone': current_timezone}</font>
<font color="red"> 177.             six.reraise(ValidationError, ValidationError(</font>
<font color="red"> 178.                 message,</font>
<font color="red"> 179.                 code='ambiguous_timezone',</font>
<font color="red"> 180.                 params=params,</font>
<font color="red"> 181.             ), sys.exc_info()[2])</font>
<font color="red"> 182.     return value</font>
<font color="black"> 183. </font>
<font color="black"> 184. </font>
<font color="green"> 185. def to_current_timezone(value):</font>
<font color="black"> 186.     &quot;&quot;&quot;</font>
<font color="black"> 187.     When time zone support is enabled, convert aware datetimes</font>
<font color="black"> 188.     to naive datetimes in the current time zone for display.</font>
<font color="black"> 189.     &quot;&quot;&quot;</font>
<font color="red"> 190.     if settings.USE_TZ and value is not None and timezone.is_aware(value):</font>
<font color="red"> 191.         current_timezone = timezone.get_current_timezone()</font>
<font color="red"> 192.         return timezone.make_naive(value, current_timezone)</font>
<font color="red"> 193.     return value</font>
</pre>

