source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/sql/compiler.py</b><br>


file stats: <b>749 lines, 332 executed: 44.3% covered</b>
<pre>
<font color="green">   1. import re</font>
<font color="green">   2. import warnings</font>
<font color="green">   3. from itertools import chain</font>
<font color="black">   4. </font>
<font color="green">   5. from django.core.exceptions import FieldError</font>
<font color="green">   6. from django.db.models.constants import LOOKUP_SEP</font>
<font color="green">   7. from django.db.models.expressions import OrderBy, Random, RawSQL, Ref</font>
<font color="green">   8. from django.db.models.query_utils import QueryWrapper, select_related_descend</font>
<font color="green">   9. from django.db.models.sql.constants import (</font>
<font color="black">  10.     CURSOR, GET_ITERATOR_CHUNK_SIZE, MULTI, NO_RESULTS, ORDER_DIR, SINGLE,</font>
<font color="black">  11. )</font>
<font color="green">  12. from django.db.models.sql.datastructures import EmptyResultSet</font>
<font color="green">  13. from django.db.models.sql.query import Query, get_order_dir</font>
<font color="green">  14. from django.db.transaction import TransactionManagementError</font>
<font color="green">  15. from django.db.utils import DatabaseError</font>
<font color="green">  16. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  17. from django.utils.six.moves import zip</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. class SQLCompiler(object):</font>
<font color="green">  21.     def __init__(self, query, connection, using):</font>
<font color="green">  22.         self.query = query</font>
<font color="green">  23.         self.connection = connection</font>
<font color="green">  24.         self.using = using</font>
<font color="green">  25.         self.quote_cache = {'*': '*'}</font>
<font color="black">  26.         # The select, klass_info, and annotations are needed by QuerySet.iterator()</font>
<font color="black">  27.         # these are set as a side-effect of executing the query. Note that we calculate</font>
<font color="black">  28.         # separately a list of extra select columns needed for grammatical correctness</font>
<font color="black">  29.         # of the query, but these columns are not included in self.select.</font>
<font color="green">  30.         self.select = None</font>
<font color="green">  31.         self.annotation_col_map = None</font>
<font color="green">  32.         self.klass_info = None</font>
<font color="green">  33.         self.ordering_parts = re.compile(r'(.*)\s(ASC|DESC)(.*)')</font>
<font color="green">  34.         self.subquery = False</font>
<font color="black">  35. </font>
<font color="green">  36.     def setup_query(self):</font>
<font color="green">  37.         if all(self.query.alias_refcount[a] == 0 for a in self.query.tables):</font>
<font color="green">  38.             self.query.get_initial_alias()</font>
<font color="green">  39.         self.select, self.klass_info, self.annotation_col_map = self.get_select()</font>
<font color="green">  40.         self.col_count = len(self.select)</font>
<font color="black">  41. </font>
<font color="green">  42.     def pre_sql_setup(self):</font>
<font color="black">  43.         &quot;&quot;&quot;</font>
<font color="black">  44.         Does any necessary class setup immediately prior to producing SQL. This</font>
<font color="black">  45.         is for things that can't necessarily be done in __init__ because we</font>
<font color="black">  46.         might not have all the pieces in place at that time.</font>
<font color="black">  47.         &quot;&quot;&quot;</font>
<font color="green">  48.         self.setup_query()</font>
<font color="green">  49.         order_by = self.get_order_by()</font>
<font color="green">  50.         self.where, self.having = self.query.where.split_having()</font>
<font color="green">  51.         extra_select = self.get_extra_select(order_by, self.select)</font>
<font color="green">  52.         group_by = self.get_group_by(self.select + extra_select, order_by)</font>
<font color="green">  53.         return extra_select, order_by, group_by</font>
<font color="black">  54. </font>
<font color="green">  55.     def get_group_by(self, select, order_by):</font>
<font color="black">  56.         &quot;&quot;&quot;</font>
<font color="black">  57.         Returns a list of 2-tuples of form (sql, params).</font>
<font color="black">  58. </font>
<font color="black">  59.         The logic of what exactly the GROUP BY clause contains is hard</font>
<font color="black">  60.         to describe in other words than &quot;if it passes the test suite,</font>
<font color="black">  61.         then it is correct&quot;.</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="black">  63.         # Some examples:</font>
<font color="black">  64.         #     SomeModel.objects.annotate(Count('somecol'))</font>
<font color="black">  65.         #     GROUP BY: all fields of the model</font>
<font color="black">  66.         #</font>
<font color="black">  67.         #    SomeModel.objects.values('name').annotate(Count('somecol'))</font>
<font color="black">  68.         #    GROUP BY: name</font>
<font color="black">  69.         #</font>
<font color="black">  70.         #    SomeModel.objects.annotate(Count('somecol')).values('name')</font>
<font color="black">  71.         #    GROUP BY: all cols of the model</font>
<font color="black">  72.         #</font>
<font color="black">  73.         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')</font>
<font color="black">  74.         #    GROUP BY: name, pk</font>
<font color="black">  75.         #</font>
<font color="black">  76.         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')</font>
<font color="black">  77.         #    GROUP BY: name, pk</font>
<font color="black">  78.         #</font>
<font color="black">  79.         # In fact, the self.query.group_by is the minimal set to GROUP BY. It</font>
<font color="black">  80.         # can't be ever restricted to a smaller set, but additional columns in</font>
<font color="black">  81.         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately</font>
<font color="black">  82.         # the end result is that it is impossible to force the query to have</font>
<font color="black">  83.         # a chosen GROUP BY clause - you can almost do this by using the form:</font>
<font color="black">  84.         #     .values(*wanted_cols).annotate(AnAggregate())</font>
<font color="black">  85.         # but any later annotations, extra selects, values calls that</font>
<font color="black">  86.         # refer some column outside of the wanted_cols, order_by, or even</font>
<font color="black">  87.         # filter calls can alter the GROUP BY clause.</font>
<font color="black">  88. </font>
<font color="black">  89.         # The query.group_by is either None (no GROUP BY at all), True</font>
<font color="black">  90.         # (group by select fields), or a list of expressions to be added</font>
<font color="black">  91.         # to the group by.</font>
<font color="green">  92.         if self.query.group_by is None:</font>
<font color="green">  93.             return []</font>
<font color="red">  94.         expressions = []</font>
<font color="red">  95.         if self.query.group_by is not True:</font>
<font color="black">  96.             # If the group by is set to a list (by .values() call most likely),</font>
<font color="black">  97.             # then we need to add everything in it to the GROUP BY clause.</font>
<font color="black">  98.             # Backwards compatibility hack for setting query.group_by. Remove</font>
<font color="black">  99.             # when  we have public API way of forcing the GROUP BY clause.</font>
<font color="black"> 100.             # Converts string references to expressions.</font>
<font color="red"> 101.             for expr in self.query.group_by:</font>
<font color="red"> 102.                 if not hasattr(expr, 'as_sql'):</font>
<font color="red"> 103.                     expressions.append(self.query.resolve_ref(expr))</font>
<font color="black"> 104.                 else:</font>
<font color="red"> 105.                     expressions.append(expr)</font>
<font color="black"> 106.         # Note that even if the group_by is set, it is only the minimal</font>
<font color="black"> 107.         # set to group by. So, we need to add cols in select, order_by, and</font>
<font color="black"> 108.         # having into the select in any case.</font>
<font color="red"> 109.         for expr, _, _ in select:</font>
<font color="red"> 110.             cols = expr.get_group_by_cols()</font>
<font color="red"> 111.             for col in cols:</font>
<font color="red"> 112.                 expressions.append(col)</font>
<font color="red"> 113.         for expr, (sql, params, is_ref) in order_by:</font>
<font color="red"> 114.             if expr.contains_aggregate:</font>
<font color="red"> 115.                 continue</font>
<font color="black"> 116.             # We can skip References to select clause, as all expressions in</font>
<font color="black"> 117.             # the select clause are already part of the group by.</font>
<font color="red"> 118.             if is_ref:</font>
<font color="red"> 119.                 continue</font>
<font color="red"> 120.             expressions.extend(expr.get_source_expressions())</font>
<font color="red"> 121.         having_group_by = self.having.get_group_by_cols() if self.having else ()</font>
<font color="red"> 122.         for expr in having_group_by:</font>
<font color="red"> 123.             expressions.append(expr)</font>
<font color="red"> 124.         result = []</font>
<font color="red"> 125.         seen = set()</font>
<font color="red"> 126.         expressions = self.collapse_group_by(expressions, having_group_by)</font>
<font color="black"> 127. </font>
<font color="red"> 128.         for expr in expressions:</font>
<font color="red"> 129.             sql, params = self.compile(expr)</font>
<font color="red"> 130.             if (sql, tuple(params)) not in seen:</font>
<font color="red"> 131.                 result.append((sql, params))</font>
<font color="red"> 132.                 seen.add((sql, tuple(params)))</font>
<font color="red"> 133.         return result</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def collapse_group_by(self, expressions, having):</font>
<font color="black"> 136.         # If the DB can group by primary key, then group by the primary key of</font>
<font color="black"> 137.         # query's main model. Note that for PostgreSQL the GROUP BY clause must</font>
<font color="black"> 138.         # include the primary key of every table, but for MySQL it is enough to</font>
<font color="black"> 139.         # have the main table's primary key.</font>
<font color="red"> 140.         if self.connection.features.allows_group_by_pk:</font>
<font color="black"> 141.             # The logic here is: if the main model's primary key is in the</font>
<font color="black"> 142.             # query, then set new_expressions to that field. If that happens,</font>
<font color="black"> 143.             # then also add having expressions to group by.</font>
<font color="red"> 144.             pk = None</font>
<font color="red"> 145.             for expr in expressions:</font>
<font color="black"> 146.                 # Is this a reference to query's base table primary key? If the</font>
<font color="black"> 147.                 # expression isn't a Col-like, then skip the expression.</font>
<font color="red"> 148.                 if (getattr(expr, 'target', None) == self.query.model._meta.pk and</font>
<font color="red"> 149.                         getattr(expr, 'alias', None) == self.query.tables[0]):</font>
<font color="red"> 150.                     pk = expr</font>
<font color="red"> 151.                     break</font>
<font color="red"> 152.             if pk:</font>
<font color="black"> 153.                 # MySQLism: Columns in HAVING clause must be added to the GROUP BY.</font>
<font color="red"> 154.                 expressions = [pk] + [expr for expr in expressions if expr in having]</font>
<font color="red"> 155.         elif self.connection.features.allows_group_by_selected_pks:</font>
<font color="black"> 156.             # Filter out all expressions associated with a table's primary key</font>
<font color="black"> 157.             # present in the grouped columns. This is done by identifying all</font>
<font color="black"> 158.             # tables that have their primary key included in the grouped</font>
<font color="black"> 159.             # columns and removing non-primary key columns referring to them.</font>
<font color="red"> 160.             pks = {expr for expr in expressions if hasattr(expr, 'target') and expr.target.primary_key}</font>
<font color="red"> 161.             aliases = {expr.alias for expr in pks}</font>
<font color="black"> 162.             expressions = [</font>
<font color="red"> 163.                 expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases</font>
<font color="black"> 164.             ]</font>
<font color="red"> 165.         return expressions</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def get_select(self):</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="black"> 169.         Returns three values:</font>
<font color="black"> 170.         - a list of 3-tuples of (expression, (sql, params), alias)</font>
<font color="black"> 171.         - a klass_info structure,</font>
<font color="black"> 172.         - a dictionary of annotations</font>
<font color="black"> 173. </font>
<font color="black"> 174.         The (sql, params) is what the expression will produce, and alias is the</font>
<font color="black"> 175.         &quot;AS alias&quot; for the column (possibly None).</font>
<font color="black"> 176. </font>
<font color="black"> 177.         The klass_info structure contains the following information:</font>
<font color="black"> 178.         - Which model to instantiate</font>
<font color="black"> 179.         - Which columns for that model are present in the query (by</font>
<font color="black"> 180.           position of the select clause).</font>
<font color="black"> 181.         - related_klass_infos: [f, klass_info] to descent into</font>
<font color="black"> 182. </font>
<font color="black"> 183.         The annotations is a dictionary of {'attname': column position} values.</font>
<font color="black"> 184.         &quot;&quot;&quot;</font>
<font color="green"> 185.         select = []</font>
<font color="green"> 186.         klass_info = None</font>
<font color="green"> 187.         annotations = {}</font>
<font color="green"> 188.         select_idx = 0</font>
<font color="green"> 189.         for alias, (sql, params) in self.query.extra_select.items():</font>
<font color="red"> 190.             annotations[alias] = select_idx</font>
<font color="red"> 191.             select.append((RawSQL(sql, params), alias))</font>
<font color="red"> 192.             select_idx += 1</font>
<font color="green"> 193.         assert not (self.query.select and self.query.default_cols)</font>
<font color="green"> 194.         if self.query.default_cols:</font>
<font color="green"> 195.             select_list = []</font>
<font color="green"> 196.             for c in self.get_default_columns():</font>
<font color="green"> 197.                 select_list.append(select_idx)</font>
<font color="green"> 198.                 select.append((c, None))</font>
<font color="green"> 199.                 select_idx += 1</font>
<font color="green"> 200.             klass_info = {</font>
<font color="green"> 201.                 'model': self.query.model,</font>
<font color="green"> 202.                 'select_fields': select_list,</font>
<font color="black"> 203.             }</font>
<font color="black"> 204.         # self.query.select is a special case. These columns never go to</font>
<font color="black"> 205.         # any model.</font>
<font color="green"> 206.         for col in self.query.select:</font>
<font color="green"> 207.             select.append((col, None))</font>
<font color="green"> 208.             select_idx += 1</font>
<font color="green"> 209.         for alias, annotation in self.query.annotation_select.items():</font>
<font color="red"> 210.             annotations[alias] = select_idx</font>
<font color="red"> 211.             select.append((annotation, alias))</font>
<font color="red"> 212.             select_idx += 1</font>
<font color="black"> 213. </font>
<font color="green"> 214.         if self.query.select_related:</font>
<font color="red"> 215.             related_klass_infos = self.get_related_selections(select)</font>
<font color="red"> 216.             klass_info['related_klass_infos'] = related_klass_infos</font>
<font color="black"> 217. </font>
<font color="red"> 218.             def get_select_from_parent(klass_info):</font>
<font color="red"> 219.                 for ki in klass_info['related_klass_infos']:</font>
<font color="red"> 220.                     if ki['from_parent']:</font>
<font color="red"> 221.                         ki['select_fields'] = (klass_info['select_fields'] +</font>
<font color="red"> 222.                                                ki['select_fields'])</font>
<font color="red"> 223.                     get_select_from_parent(ki)</font>
<font color="red"> 224.             get_select_from_parent(klass_info)</font>
<font color="black"> 225. </font>
<font color="green"> 226.         ret = []</font>
<font color="green"> 227.         for col, alias in select:</font>
<font color="green"> 228.             ret.append((col, self.compile(col, select_format=True), alias))</font>
<font color="green"> 229.         return ret, klass_info, annotations</font>
<font color="black"> 230. </font>
<font color="green"> 231.     def get_order_by(self):</font>
<font color="black"> 232.         &quot;&quot;&quot;</font>
<font color="black"> 233.         Returns a list of 2-tuples of form (expr, (sql, params, is_ref)) for the</font>
<font color="black"> 234.         ORDER BY clause.</font>
<font color="black"> 235. </font>
<font color="black"> 236.         The order_by clause can alter the select clause (for example it</font>
<font color="black"> 237.         can add aliases to clauses that do not yet have one, or it can</font>
<font color="black"> 238.         add totally new select clauses).</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="green"> 240.         if self.query.extra_order_by:</font>
<font color="red"> 241.             ordering = self.query.extra_order_by</font>
<font color="green"> 242.         elif not self.query.default_ordering:</font>
<font color="green"> 243.             ordering = self.query.order_by</font>
<font color="black"> 244.         else:</font>
<font color="green"> 245.             ordering = (self.query.order_by or self.query.get_meta().ordering or [])</font>
<font color="green"> 246.         if self.query.standard_ordering:</font>
<font color="green"> 247.             asc, desc = ORDER_DIR['ASC']</font>
<font color="black"> 248.         else:</font>
<font color="red"> 249.             asc, desc = ORDER_DIR['DESC']</font>
<font color="black"> 250. </font>
<font color="green"> 251.         order_by = []</font>
<font color="green"> 252.         for pos, field in enumerate(ordering):</font>
<font color="green"> 253.             if hasattr(field, 'resolve_expression'):</font>
<font color="red"> 254.                 if not isinstance(field, OrderBy):</font>
<font color="red"> 255.                     field = field.asc()</font>
<font color="red"> 256.                 if not self.query.standard_ordering:</font>
<font color="red"> 257.                     field.reverse_ordering()</font>
<font color="red"> 258.                 order_by.append((field, False))</font>
<font color="red"> 259.                 continue</font>
<font color="green"> 260.             if field == '?':  # random</font>
<font color="red"> 261.                 order_by.append((OrderBy(Random()), False))</font>
<font color="red"> 262.                 continue</font>
<font color="black"> 263. </font>
<font color="green"> 264.             col, order = get_order_dir(field, asc)</font>
<font color="green"> 265.             descending = True if order == 'DESC' else False</font>
<font color="black"> 266. </font>
<font color="green"> 267.             if col in self.query.annotation_select:</font>
<font color="black"> 268.                 # Reference to expression in SELECT clause</font>
<font color="red"> 269.                 order_by.append((</font>
<font color="red"> 270.                     OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),</font>
<font color="red"> 271.                     True))</font>
<font color="red"> 272.                 continue</font>
<font color="green"> 273.             if col in self.query.annotations:</font>
<font color="black"> 274.                 # References to an expression which is masked out of the SELECT clause</font>
<font color="red"> 275.                 order_by.append((</font>
<font color="red"> 276.                     OrderBy(self.query.annotations[col], descending=descending),</font>
<font color="red"> 277.                     False))</font>
<font color="red"> 278.                 continue</font>
<font color="black"> 279. </font>
<font color="green"> 280.             if '.' in field:</font>
<font color="black"> 281.                 # This came in through an extra(order_by=...) addition. Pass it</font>
<font color="black"> 282.                 # on verbatim.</font>
<font color="red"> 283.                 table, col = col.split('.', 1)</font>
<font color="red"> 284.                 order_by.append((</font>
<font color="red"> 285.                     OrderBy(</font>
<font color="red"> 286.                         RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),</font>
<font color="red"> 287.                         descending=descending</font>
<font color="red"> 288.                     ), False))</font>
<font color="red"> 289.                 continue</font>
<font color="black"> 290. </font>
<font color="green"> 291.             if not self.query._extra or col not in self.query._extra:</font>
<font color="black"> 292.                 # 'col' is of the form 'field' or 'field1__field2' or</font>
<font color="black"> 293.                 # '-field1__field2__field', etc.</font>
<font color="green"> 294.                 order_by.extend(self.find_ordering_name(</font>
<font color="green"> 295.                     field, self.query.get_meta(), default_order=asc))</font>
<font color="black"> 296.             else:</font>
<font color="red"> 297.                 if col not in self.query.extra_select:</font>
<font color="red"> 298.                     order_by.append((</font>
<font color="red"> 299.                         OrderBy(RawSQL(*self.query.extra[col]), descending=descending),</font>
<font color="red"> 300.                         False))</font>
<font color="black"> 301.                 else:</font>
<font color="red"> 302.                     order_by.append((</font>
<font color="red"> 303.                         OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),</font>
<font color="red"> 304.                         True))</font>
<font color="green"> 305.         result = []</font>
<font color="green"> 306.         seen = set()</font>
<font color="black"> 307. </font>
<font color="green"> 308.         for expr, is_ref in order_by:</font>
<font color="green"> 309.             resolved = expr.resolve_expression(</font>
<font color="green"> 310.                 self.query, allow_joins=True, reuse=None)</font>
<font color="green"> 311.             sql, params = self.compile(resolved)</font>
<font color="black"> 312.             # Don't add the same column twice, but the order direction is</font>
<font color="black"> 313.             # not taken into account so we strip it. When this entire method</font>
<font color="black"> 314.             # is refactored into expressions, then we can check each part as we</font>
<font color="black"> 315.             # generate it.</font>
<font color="green"> 316.             without_ordering = self.ordering_parts.search(sql).group(1)</font>
<font color="green"> 317.             if (without_ordering, tuple(params)) in seen:</font>
<font color="red"> 318.                 continue</font>
<font color="green"> 319.             seen.add((without_ordering, tuple(params)))</font>
<font color="green"> 320.             result.append((resolved, (sql, params, is_ref)))</font>
<font color="green"> 321.         return result</font>
<font color="black"> 322. </font>
<font color="green"> 323.     def get_extra_select(self, order_by, select):</font>
<font color="green"> 324.         extra_select = []</font>
<font color="green"> 325.         select_sql = [t[1] for t in select]</font>
<font color="green"> 326.         if self.query.distinct and not self.query.distinct_fields:</font>
<font color="red"> 327.             for expr, (sql, params, is_ref) in order_by:</font>
<font color="red"> 328.                 without_ordering = self.ordering_parts.search(sql).group(1)</font>
<font color="red"> 329.                 if not is_ref and (without_ordering, params) not in select_sql:</font>
<font color="red"> 330.                     extra_select.append((expr, (without_ordering, params), None))</font>
<font color="green"> 331.         return extra_select</font>
<font color="black"> 332. </font>
<font color="green"> 333.     def __call__(self, name):</font>
<font color="black"> 334.         &quot;&quot;&quot;</font>
<font color="black"> 335.         Backwards-compatibility shim so that calling a SQLCompiler is equivalent to</font>
<font color="black"> 336.         calling its quote_name_unless_alias method.</font>
<font color="black"> 337.         &quot;&quot;&quot;</font>
<font color="red"> 338.         warnings.warn(</font>
<font color="red"> 339.             &quot;Calling a SQLCompiler directly is deprecated. &quot;</font>
<font color="black"> 340.             &quot;Call compiler.quote_name_unless_alias instead.&quot;,</font>
<font color="red"> 341.             RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 342.         return self.quote_name_unless_alias(name)</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def quote_name_unless_alias(self, name):</font>
<font color="black"> 345.         &quot;&quot;&quot;</font>
<font color="black"> 346.         A wrapper around connection.ops.quote_name that doesn't quote aliases</font>
<font color="black"> 347.         for table names. This avoids problems with some SQL dialects that treat</font>
<font color="black"> 348.         quoted strings specially (e.g. PostgreSQL).</font>
<font color="black"> 349.         &quot;&quot;&quot;</font>
<font color="green"> 350.         if name in self.quote_cache:</font>
<font color="green"> 351.             return self.quote_cache[name]</font>
<font color="green"> 352.         if ((name in self.query.alias_map and name not in self.query.table_map) or</font>
<font color="green"> 353.                 name in self.query.extra_select or (</font>
<font color="green"> 354.                     name in self.query.external_aliases and name not in self.query.table_map)):</font>
<font color="red"> 355.             self.quote_cache[name] = name</font>
<font color="red"> 356.             return name</font>
<font color="green"> 357.         r = self.connection.ops.quote_name(name)</font>
<font color="green"> 358.         self.quote_cache[name] = r</font>
<font color="green"> 359.         return r</font>
<font color="black"> 360. </font>
<font color="green"> 361.     def compile(self, node, select_format=False):</font>
<font color="green"> 362.         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)</font>
<font color="green"> 363.         if vendor_impl:</font>
<font color="red"> 364.             sql, params = vendor_impl(self, self.connection)</font>
<font color="black"> 365.         else:</font>
<font color="green"> 366.             sql, params = node.as_sql(self, self.connection)</font>
<font color="green"> 367.         if select_format and not self.subquery:</font>
<font color="green"> 368.             return node.output_field.select_format(self, sql, params)</font>
<font color="green"> 369.         return sql, params</font>
<font color="black"> 370. </font>
<font color="green"> 371.     def as_sql(self, with_limits=True, with_col_aliases=False, subquery=False):</font>
<font color="black"> 372.         &quot;&quot;&quot;</font>
<font color="black"> 373.         Creates the SQL for this query. Returns the SQL string and list of</font>
<font color="black"> 374.         parameters.</font>
<font color="black"> 375. </font>
<font color="black"> 376.         If 'with_limits' is False, any limit/offset information is not included</font>
<font color="black"> 377.         in the query.</font>
<font color="black"> 378.         &quot;&quot;&quot;</font>
<font color="green"> 379.         if with_limits and self.query.low_mark == self.query.high_mark:</font>
<font color="red"> 380.             return '', ()</font>
<font color="green"> 381.         self.subquery = subquery</font>
<font color="green"> 382.         refcounts_before = self.query.alias_refcount.copy()</font>
<font color="green"> 383.         try:</font>
<font color="green"> 384.             extra_select, order_by, group_by = self.pre_sql_setup()</font>
<font color="green"> 385.             if with_limits and self.query.low_mark == self.query.high_mark:</font>
<font color="red"> 386.                 return '', ()</font>
<font color="green"> 387.             distinct_fields = self.get_distinct()</font>
<font color="black"> 388. </font>
<font color="black"> 389.             # This must come after 'select', 'ordering', and 'distinct' -- see</font>
<font color="black"> 390.             # docstring of get_from_clause() for details.</font>
<font color="green"> 391.             from_, f_params = self.get_from_clause()</font>
<font color="black"> 392. </font>
<font color="green"> 393.             where, w_params = self.compile(self.where) if self.where is not None else (&quot;&quot;, [])</font>
<font color="green"> 394.             having, h_params = self.compile(self.having) if self.having is not None else (&quot;&quot;, [])</font>
<font color="green"> 395.             params = []</font>
<font color="green"> 396.             result = ['SELECT']</font>
<font color="black"> 397. </font>
<font color="green"> 398.             if self.query.distinct:</font>
<font color="red"> 399.                 result.append(self.connection.ops.distinct_sql(distinct_fields))</font>
<font color="black"> 400. </font>
<font color="green"> 401.             out_cols = []</font>
<font color="green"> 402.             col_idx = 1</font>
<font color="green"> 403.             for _, (s_sql, s_params), alias in self.select + extra_select:</font>
<font color="green"> 404.                 if alias:</font>
<font color="red"> 405.                     s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))</font>
<font color="green"> 406.                 elif with_col_aliases:</font>
<font color="red"> 407.                     s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)</font>
<font color="red"> 408.                     col_idx += 1</font>
<font color="green"> 409.                 params.extend(s_params)</font>
<font color="green"> 410.                 out_cols.append(s_sql)</font>
<font color="black"> 411. </font>
<font color="green"> 412.             result.append(', '.join(out_cols))</font>
<font color="black"> 413. </font>
<font color="green"> 414.             result.append('FROM')</font>
<font color="green"> 415.             result.extend(from_)</font>
<font color="green"> 416.             params.extend(f_params)</font>
<font color="black"> 417. </font>
<font color="green"> 418.             if where:</font>
<font color="green"> 419.                 result.append('WHERE %s' % where)</font>
<font color="green"> 420.                 params.extend(w_params)</font>
<font color="black"> 421. </font>
<font color="green"> 422.             grouping = []</font>
<font color="green"> 423.             for g_sql, g_params in group_by:</font>
<font color="red"> 424.                 grouping.append(g_sql)</font>
<font color="red"> 425.                 params.extend(g_params)</font>
<font color="green"> 426.             if grouping:</font>
<font color="red"> 427.                 if distinct_fields:</font>
<font color="red"> 428.                     raise NotImplementedError(</font>
<font color="red"> 429.                         &quot;annotate() + distinct(fields) is not implemented.&quot;)</font>
<font color="red"> 430.                 if not order_by:</font>
<font color="red"> 431.                     order_by = self.connection.ops.force_no_ordering()</font>
<font color="red"> 432.                 result.append('GROUP BY %s' % ', '.join(grouping))</font>
<font color="black"> 433. </font>
<font color="green"> 434.             if having:</font>
<font color="red"> 435.                 result.append('HAVING %s' % having)</font>
<font color="red"> 436.                 params.extend(h_params)</font>
<font color="black"> 437. </font>
<font color="green"> 438.             if order_by:</font>
<font color="green"> 439.                 ordering = []</font>
<font color="green"> 440.                 for _, (o_sql, o_params, _) in order_by:</font>
<font color="green"> 441.                     ordering.append(o_sql)</font>
<font color="green"> 442.                     params.extend(o_params)</font>
<font color="green"> 443.                 result.append('ORDER BY %s' % ', '.join(ordering))</font>
<font color="black"> 444. </font>
<font color="green"> 445.             if with_limits:</font>
<font color="green"> 446.                 if self.query.high_mark is not None:</font>
<font color="red"> 447.                     result.append('LIMIT %d' % (self.query.high_mark - self.query.low_mark))</font>
<font color="green"> 448.                 if self.query.low_mark:</font>
<font color="red"> 449.                     if self.query.high_mark is None:</font>
<font color="red"> 450.                         val = self.connection.ops.no_limit_value()</font>
<font color="red"> 451.                         if val:</font>
<font color="red"> 452.                             result.append('LIMIT %d' % val)</font>
<font color="red"> 453.                     result.append('OFFSET %d' % self.query.low_mark)</font>
<font color="black"> 454. </font>
<font color="green"> 455.             if self.query.select_for_update and self.connection.features.has_select_for_update:</font>
<font color="red"> 456.                 if self.connection.get_autocommit():</font>
<font color="red"> 457.                     raise TransactionManagementError(</font>
<font color="red"> 458.                         &quot;select_for_update cannot be used outside of a transaction.&quot;</font>
<font color="black"> 459.                     )</font>
<font color="black"> 460. </font>
<font color="black"> 461.                 # If we've been asked for a NOWAIT query but the backend does</font>
<font color="black"> 462.                 # not support it, raise a DatabaseError otherwise we could get</font>
<font color="black"> 463.                 # an unexpected deadlock.</font>
<font color="red"> 464.                 nowait = self.query.select_for_update_nowait</font>
<font color="red"> 465.                 if nowait and not self.connection.features.has_select_for_update_nowait:</font>
<font color="red"> 466.                     raise DatabaseError('NOWAIT is not supported on this database backend.')</font>
<font color="red"> 467.                 result.append(self.connection.ops.for_update_sql(nowait=nowait))</font>
<font color="black"> 468. </font>
<font color="green"> 469.             return ' '.join(result), tuple(params)</font>
<font color="black"> 470.         finally:</font>
<font color="black"> 471.             # Finally do cleanup - get rid of the joins we created above.</font>
<font color="green"> 472.             self.query.reset_refcounts(refcounts_before)</font>
<font color="black"> 473. </font>
<font color="green"> 474.     def as_nested_sql(self):</font>
<font color="black"> 475.         &quot;&quot;&quot;</font>
<font color="black"> 476.         Perform the same functionality as the as_sql() method, returning an</font>
<font color="black"> 477.         SQL string and parameters. However, the alias prefixes are bumped</font>
<font color="black"> 478.         beforehand (in a copy -- the current query isn't changed), and any</font>
<font color="black"> 479.         ordering is removed if the query is unsliced.</font>
<font color="black"> 480. </font>
<font color="black"> 481.         Used when nesting this query inside another.</font>
<font color="black"> 482.         &quot;&quot;&quot;</font>
<font color="red"> 483.         obj = self.query.clone()</font>
<font color="red"> 484.         if obj.low_mark == 0 and obj.high_mark is None and not self.query.distinct_fields:</font>
<font color="black"> 485.             # If there is no slicing in use, then we can safely drop all ordering</font>
<font color="red"> 486.             obj.clear_ordering(True)</font>
<font color="red"> 487.         nested_sql = obj.get_compiler(connection=self.connection).as_sql(subquery=True)</font>
<font color="red"> 488.         if nested_sql == ('', ()):</font>
<font color="red"> 489.             raise EmptyResultSet</font>
<font color="red"> 490.         return nested_sql</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):</font>
<font color="black"> 493.         &quot;&quot;&quot;</font>
<font color="black"> 494.         Computes the default columns for selecting every field in the base</font>
<font color="black"> 495.         model. Will sometimes be called to pull in related models (e.g. via</font>
<font color="black"> 496.         select_related), in which case &quot;opts&quot; and &quot;start_alias&quot; will be given</font>
<font color="black"> 497.         to provide a starting point for the traversal.</font>
<font color="black"> 498. </font>
<font color="black"> 499.         Returns a list of strings, quoted appropriately for use in SQL</font>
<font color="black"> 500.         directly, as well as a set of aliases used in the select statement (if</font>
<font color="black"> 501.         'as_pairs' is True, returns a list of (alias, col_name) pairs instead</font>
<font color="black"> 502.         of strings as the first component and None as the second component).</font>
<font color="black"> 503.         &quot;&quot;&quot;</font>
<font color="green"> 504.         result = []</font>
<font color="green"> 505.         if opts is None:</font>
<font color="green"> 506.             opts = self.query.get_meta()</font>
<font color="green"> 507.         only_load = self.deferred_to_columns()</font>
<font color="green"> 508.         if not start_alias:</font>
<font color="green"> 509.             start_alias = self.query.get_initial_alias()</font>
<font color="black"> 510.         # The 'seen_models' is used to optimize checking the needed parent</font>
<font color="black"> 511.         # alias for a given field. This also includes None -&gt; start_alias to</font>
<font color="black"> 512.         # be used by local fields.</font>
<font color="green"> 513.         seen_models = {None: start_alias}</font>
<font color="black"> 514. </font>
<font color="green"> 515.         for field in opts.concrete_fields:</font>
<font color="green"> 516.             model = field.model._meta.concrete_model</font>
<font color="black"> 517.             # A proxy model will have a different model and concrete_model. We</font>
<font color="black"> 518.             # will assign None if the field belongs to this model.</font>
<font color="green"> 519.             if model == opts.model:</font>
<font color="green"> 520.                 model = None</font>
<font color="green"> 521.             if from_parent and model is not None and issubclass(</font>
<font color="red"> 522.                     from_parent._meta.concrete_model, model._meta.concrete_model):</font>
<font color="black"> 523.                 # Avoid loading data for already loaded parents.</font>
<font color="black"> 524.                 # We end up here in the case select_related() resolution</font>
<font color="black"> 525.                 # proceeds from parent model to child model. In that case the</font>
<font color="black"> 526.                 # parent model data is already present in the SELECT clause,</font>
<font color="black"> 527.                 # and we want to avoid reloading the same data again.</font>
<font color="red"> 528.                 continue</font>
<font color="green"> 529.             if field.model in only_load and field.attname not in only_load[field.model]:</font>
<font color="red"> 530.                 continue</font>
<font color="green"> 531.             alias = self.query.join_parent_model(opts, model, start_alias,</font>
<font color="green"> 532.                                                  seen_models)</font>
<font color="green"> 533.             column = field.get_col(alias)</font>
<font color="green"> 534.             result.append(column)</font>
<font color="green"> 535.         return result</font>
<font color="black"> 536. </font>
<font color="green"> 537.     def get_distinct(self):</font>
<font color="black"> 538.         &quot;&quot;&quot;</font>
<font color="black"> 539.         Returns a quoted list of fields to use in DISTINCT ON part of the query.</font>
<font color="black"> 540. </font>
<font color="black"> 541.         Note that this method can alter the tables in the query, and thus it</font>
<font color="black"> 542.         must be called before get_from_clause().</font>
<font color="black"> 543.         &quot;&quot;&quot;</font>
<font color="green"> 544.         qn = self.quote_name_unless_alias</font>
<font color="green"> 545.         qn2 = self.connection.ops.quote_name</font>
<font color="green"> 546.         result = []</font>
<font color="green"> 547.         opts = self.query.get_meta()</font>
<font color="black"> 548. </font>
<font color="green"> 549.         for name in self.query.distinct_fields:</font>
<font color="red"> 550.             parts = name.split(LOOKUP_SEP)</font>
<font color="red"> 551.             _, targets, alias, joins, path, _ = self._setup_joins(parts, opts, None)</font>
<font color="red"> 552.             targets, alias, _ = self.query.trim_joins(targets, joins, path)</font>
<font color="red"> 553.             for target in targets:</font>
<font color="red"> 554.                 if name in self.query.annotation_select:</font>
<font color="red"> 555.                     result.append(name)</font>
<font color="black"> 556.                 else:</font>
<font color="red"> 557.                     result.append(&quot;%s.%s&quot; % (qn(alias), qn2(target.column)))</font>
<font color="green"> 558.         return result</font>
<font color="black"> 559. </font>
<font color="green"> 560.     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',</font>
<font color="green"> 561.                            already_seen=None):</font>
<font color="black"> 562.         &quot;&quot;&quot;</font>
<font color="black"> 563.         Returns the table alias (the name might be ambiguous, the alias will</font>
<font color="black"> 564.         not be) and column name for ordering by the given 'name' parameter.</font>
<font color="black"> 565.         The 'name' is of the form 'field1__field2__...__fieldN'.</font>
<font color="black"> 566.         &quot;&quot;&quot;</font>
<font color="green"> 567.         name, order = get_order_dir(name, default_order)</font>
<font color="green"> 568.         descending = True if order == 'DESC' else False</font>
<font color="green"> 569.         pieces = name.split(LOOKUP_SEP)</font>
<font color="green"> 570.         field, targets, alias, joins, path, opts = self._setup_joins(pieces, opts, alias)</font>
<font color="black"> 571. </font>
<font color="black"> 572.         # If we get to this point and the field is a relation to another model,</font>
<font color="black"> 573.         # append the default ordering for that model unless the attribute name</font>
<font color="black"> 574.         # of the field is specified.</font>
<font color="green"> 575.         if field.is_relation and path and opts.ordering and name != field.attname:</font>
<font color="black"> 576.             # Firstly, avoid infinite loops.</font>
<font color="red"> 577.             if not already_seen:</font>
<font color="red"> 578.                 already_seen = set()</font>
<font color="red"> 579.             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)</font>
<font color="red"> 580.             if join_tuple in already_seen:</font>
<font color="red"> 581.                 raise FieldError('Infinite loop caused by ordering.')</font>
<font color="red"> 582.             already_seen.add(join_tuple)</font>
<font color="black"> 583. </font>
<font color="red"> 584.             results = []</font>
<font color="red"> 585.             for item in opts.ordering:</font>
<font color="red"> 586.                 results.extend(self.find_ordering_name(item, opts, alias,</font>
<font color="red"> 587.                                                        order, already_seen))</font>
<font color="red"> 588.             return results</font>
<font color="green"> 589.         targets, alias, _ = self.query.trim_joins(targets, joins, path)</font>
<font color="green"> 590.         return [(OrderBy(t.get_col(alias), descending=descending), False) for t in targets]</font>
<font color="black"> 591. </font>
<font color="green"> 592.     def _setup_joins(self, pieces, opts, alias):</font>
<font color="black"> 593.         &quot;&quot;&quot;</font>
<font color="black"> 594.         A helper method for get_order_by and get_distinct.</font>
<font color="black"> 595. </font>
<font color="black"> 596.         Note that get_ordering and get_distinct must produce same target</font>
<font color="black"> 597.         columns on same input, as the prefixes of get_ordering and get_distinct</font>
<font color="black"> 598.         must match. Executing SQL where this is not true is an error.</font>
<font color="black"> 599.         &quot;&quot;&quot;</font>
<font color="green"> 600.         if not alias:</font>
<font color="green"> 601.             alias = self.query.get_initial_alias()</font>
<font color="green"> 602.         field, targets, opts, joins, path = self.query.setup_joins(</font>
<font color="green"> 603.             pieces, opts, alias)</font>
<font color="green"> 604.         alias = joins[-1]</font>
<font color="green"> 605.         return field, targets, alias, joins, path, opts</font>
<font color="black"> 606. </font>
<font color="green"> 607.     def get_from_clause(self):</font>
<font color="black"> 608.         &quot;&quot;&quot;</font>
<font color="black"> 609.         Returns a list of strings that are joined together to go after the</font>
<font color="black"> 610.         &quot;FROM&quot; part of the query, as well as a list any extra parameters that</font>
<font color="black"> 611.         need to be included. Sub-classes, can override this to create a</font>
<font color="black"> 612.         from-clause via a &quot;select&quot;.</font>
<font color="black"> 613. </font>
<font color="black"> 614.         This should only be called after any SQL construction methods that</font>
<font color="black"> 615.         might change the tables we need. This means the select columns,</font>
<font color="black"> 616.         ordering and distinct must be done first.</font>
<font color="black"> 617.         &quot;&quot;&quot;</font>
<font color="green"> 618.         result = []</font>
<font color="green"> 619.         params = []</font>
<font color="green"> 620.         for alias in self.query.tables:</font>
<font color="green"> 621.             if not self.query.alias_refcount[alias]:</font>
<font color="red"> 622.                 continue</font>
<font color="green"> 623.             try:</font>
<font color="green"> 624.                 from_clause = self.query.alias_map[alias]</font>
<font color="red"> 625.             except KeyError:</font>
<font color="black"> 626.                 # Extra tables can end up in self.tables, but not in the</font>
<font color="black"> 627.                 # alias_map if they aren't in a join. That's OK. We skip them.</font>
<font color="red"> 628.                 continue</font>
<font color="green"> 629.             clause_sql, clause_params = self.compile(from_clause)</font>
<font color="green"> 630.             result.append(clause_sql)</font>
<font color="green"> 631.             params.extend(clause_params)</font>
<font color="green"> 632.         for t in self.query.extra_tables:</font>
<font color="red"> 633.             alias, _ = self.query.table_alias(t)</font>
<font color="black"> 634.             # Only add the alias if it's not already present (the table_alias()</font>
<font color="black"> 635.             # call increments the refcount, so an alias refcount of one means</font>
<font color="black"> 636.             # this is the only reference).</font>
<font color="red"> 637.             if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:</font>
<font color="red"> 638.                 result.append(', %s' % self.quote_name_unless_alias(alias))</font>
<font color="green"> 639.         return result, params</font>
<font color="black"> 640. </font>
<font color="green"> 641.     def get_related_selections(self, select, opts=None, root_alias=None, cur_depth=1,</font>
<font color="green"> 642.                                requested=None, restricted=None):</font>
<font color="black"> 643.         &quot;&quot;&quot;</font>
<font color="black"> 644.         Fill in the information needed for a select_related query. The current</font>
<font color="black"> 645.         depth is measured as the number of connections away from the root model</font>
<font color="black"> 646.         (for example, cur_depth=1 means we are looking at models with direct</font>
<font color="black"> 647.         connections to the root model).</font>
<font color="black"> 648.         &quot;&quot;&quot;</font>
<font color="red"> 649.         def _get_field_choices():</font>
<font color="red"> 650.             direct_choices = (f.name for f in opts.fields if f.is_relation)</font>
<font color="black"> 651.             reverse_choices = (</font>
<font color="red"> 652.                 f.field.related_query_name()</font>
<font color="red"> 653.                 for f in opts.related_objects if f.field.unique</font>
<font color="black"> 654.             )</font>
<font color="red"> 655.             return chain(direct_choices, reverse_choices)</font>
<font color="black"> 656. </font>
<font color="red"> 657.         related_klass_infos = []</font>
<font color="red"> 658.         if not restricted and self.query.max_depth and cur_depth &gt; self.query.max_depth:</font>
<font color="black"> 659.             # We've recursed far enough; bail out.</font>
<font color="red"> 660.             return related_klass_infos</font>
<font color="black"> 661. </font>
<font color="red"> 662.         if not opts:</font>
<font color="red"> 663.             opts = self.query.get_meta()</font>
<font color="red"> 664.             root_alias = self.query.get_initial_alias()</font>
<font color="red"> 665.         only_load = self.query.get_loaded_field_names()</font>
<font color="black"> 666. </font>
<font color="black"> 667.         # Setup for the case when only particular related fields should be</font>
<font color="black"> 668.         # included in the related selection.</font>
<font color="red"> 669.         fields_found = set()</font>
<font color="red"> 670.         if requested is None:</font>
<font color="red"> 671.             if isinstance(self.query.select_related, dict):</font>
<font color="red"> 672.                 requested = self.query.select_related</font>
<font color="red"> 673.                 restricted = True</font>
<font color="black"> 674.             else:</font>
<font color="red"> 675.                 restricted = False</font>
<font color="black"> 676. </font>
<font color="red"> 677.         def get_related_klass_infos(klass_info, related_klass_infos):</font>
<font color="red"> 678.             klass_info['related_klass_infos'] = related_klass_infos</font>
<font color="black"> 679. </font>
<font color="red"> 680.         for f in opts.fields:</font>
<font color="red"> 681.             field_model = f.model._meta.concrete_model</font>
<font color="red"> 682.             fields_found.add(f.name)</font>
<font color="black"> 683. </font>
<font color="red"> 684.             if restricted:</font>
<font color="red"> 685.                 next = requested.get(f.name, {})</font>
<font color="red"> 686.                 if not f.is_relation:</font>
<font color="black"> 687.                     # If a non-related field is used like a relation,</font>
<font color="black"> 688.                     # or if a single non-relational field is given.</font>
<font color="red"> 689.                     if next or (cur_depth == 1 and f.name in requested):</font>
<font color="red"> 690.                         raise FieldError(</font>
<font color="red"> 691.                             &quot;Non-relational field given in select_related: '%s'. &quot;</font>
<font color="black"> 692.                             &quot;Choices are: %s&quot; % (</font>
<font color="red"> 693.                                 f.name,</font>
<font color="red"> 694.                                 &quot;, &quot;.join(_get_field_choices()) or '(none)',</font>
<font color="black"> 695.                             )</font>
<font color="black"> 696.                         )</font>
<font color="black"> 697.             else:</font>
<font color="red"> 698.                 next = False</font>
<font color="black"> 699. </font>
<font color="red"> 700.             if not select_related_descend(f, restricted, requested,</font>
<font color="red"> 701.                                           only_load.get(field_model)):</font>
<font color="red"> 702.                 continue</font>
<font color="red"> 703.             klass_info = {</font>
<font color="red"> 704.                 'model': f.remote_field.model,</font>
<font color="red"> 705.                 'field': f,</font>
<font color="red"> 706.                 'reverse': False,</font>
<font color="red"> 707.                 'from_parent': False,</font>
<font color="black"> 708.             }</font>
<font color="red"> 709.             related_klass_infos.append(klass_info)</font>
<font color="red"> 710.             select_fields = []</font>
<font color="red"> 711.             _, _, _, joins, _ = self.query.setup_joins(</font>
<font color="red"> 712.                 [f.name], opts, root_alias)</font>
<font color="red"> 713.             alias = joins[-1]</font>
<font color="red"> 714.             columns = self.get_default_columns(start_alias=alias, opts=f.remote_field.model._meta)</font>
<font color="red"> 715.             for col in columns:</font>
<font color="red"> 716.                 select_fields.append(len(select))</font>
<font color="red"> 717.                 select.append((col, None))</font>
<font color="red"> 718.             klass_info['select_fields'] = select_fields</font>
<font color="red"> 719.             next_klass_infos = self.get_related_selections(</font>
<font color="red"> 720.                 select, f.remote_field.model._meta, alias, cur_depth + 1, next, restricted)</font>
<font color="red"> 721.             get_related_klass_infos(klass_info, next_klass_infos)</font>
<font color="black"> 722. </font>
<font color="red"> 723.         if restricted:</font>
<font color="black"> 724.             related_fields = [</font>
<font color="red"> 725.                 (o.field, o.related_model)</font>
<font color="red"> 726.                 for o in opts.related_objects</font>
<font color="red"> 727.                 if o.field.unique and not o.many_to_many</font>
<font color="black"> 728.             ]</font>
<font color="red"> 729.             for f, model in related_fields:</font>
<font color="red"> 730.                 if not select_related_descend(f, restricted, requested,</font>
<font color="red"> 731.                                               only_load.get(model), reverse=True):</font>
<font color="red"> 732.                     continue</font>
<font color="black"> 733. </font>
<font color="red"> 734.                 related_field_name = f.related_query_name()</font>
<font color="red"> 735.                 fields_found.add(related_field_name)</font>
<font color="black"> 736. </font>
<font color="red"> 737.                 _, _, _, joins, _ = self.query.setup_joins([related_field_name], opts, root_alias)</font>
<font color="red"> 738.                 alias = joins[-1]</font>
<font color="red"> 739.                 from_parent = issubclass(model, opts.model)</font>
<font color="red"> 740.                 klass_info = {</font>
<font color="red"> 741.                     'model': model,</font>
<font color="red"> 742.                     'field': f,</font>
<font color="red"> 743.                     'reverse': True,</font>
<font color="red"> 744.                     'from_parent': from_parent,</font>
<font color="black"> 745.                 }</font>
<font color="red"> 746.                 related_klass_infos.append(klass_info)</font>
<font color="red"> 747.                 select_fields = []</font>
<font color="red"> 748.                 columns = self.get_default_columns(</font>
<font color="red"> 749.                     start_alias=alias, opts=model._meta, from_parent=opts.model)</font>
<font color="red"> 750.                 for col in columns:</font>
<font color="red"> 751.                     select_fields.append(len(select))</font>
<font color="red"> 752.                     select.append((col, None))</font>
<font color="red"> 753.                 klass_info['select_fields'] = select_fields</font>
<font color="red"> 754.                 next = requested.get(f.related_query_name(), {})</font>
<font color="red"> 755.                 next_klass_infos = self.get_related_selections(</font>
<font color="red"> 756.                     select, model._meta, alias, cur_depth + 1,</font>
<font color="red"> 757.                     next, restricted)</font>
<font color="red"> 758.                 get_related_klass_infos(klass_info, next_klass_infos)</font>
<font color="red"> 759.             fields_not_found = set(requested.keys()).difference(fields_found)</font>
<font color="red"> 760.             if fields_not_found:</font>
<font color="red"> 761.                 invalid_fields = (&quot;'%s'&quot; % s for s in fields_not_found)</font>
<font color="red"> 762.                 raise FieldError(</font>
<font color="red"> 763.                     'Invalid field name(s) given in select_related: %s. '</font>
<font color="black"> 764.                     'Choices are: %s' % (</font>
<font color="red"> 765.                         ', '.join(invalid_fields),</font>
<font color="red"> 766.                         ', '.join(_get_field_choices()) or '(none)',</font>
<font color="black"> 767.                     )</font>
<font color="black"> 768.                 )</font>
<font color="red"> 769.         return related_klass_infos</font>
<font color="black"> 770. </font>
<font color="green"> 771.     def deferred_to_columns(self):</font>
<font color="black"> 772.         &quot;&quot;&quot;</font>
<font color="black"> 773.         Converts the self.deferred_loading data structure to mapping of table</font>
<font color="black"> 774.         names to sets of column names which are to be loaded. Returns the</font>
<font color="black"> 775.         dictionary.</font>
<font color="black"> 776.         &quot;&quot;&quot;</font>
<font color="green"> 777.         columns = {}</font>
<font color="green"> 778.         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)</font>
<font color="green"> 779.         return columns</font>
<font color="black"> 780. </font>
<font color="green"> 781.     def get_converters(self, expressions):</font>
<font color="green"> 782.         converters = {}</font>
<font color="green"> 783.         for i, expression in enumerate(expressions):</font>
<font color="green"> 784.             if expression:</font>
<font color="green"> 785.                 backend_converters = self.connection.ops.get_db_converters(expression)</font>
<font color="green"> 786.                 field_converters = expression.get_db_converters(self.connection)</font>
<font color="green"> 787.                 if backend_converters or field_converters:</font>
<font color="green"> 788.                     converters[i] = (backend_converters + field_converters, expression)</font>
<font color="green"> 789.         return converters</font>
<font color="black"> 790. </font>
<font color="green"> 791.     def apply_converters(self, row, converters):</font>
<font color="red"> 792.         row = list(row)</font>
<font color="red"> 793.         for pos, (convs, expression) in converters.items():</font>
<font color="red"> 794.             value = row[pos]</font>
<font color="red"> 795.             for converter in convs:</font>
<font color="red"> 796.                 value = converter(value, expression, self.connection, self.query.context)</font>
<font color="red"> 797.             row[pos] = value</font>
<font color="red"> 798.         return tuple(row)</font>
<font color="black"> 799. </font>
<font color="green"> 800.     def results_iter(self, results=None):</font>
<font color="black"> 801.         &quot;&quot;&quot;</font>
<font color="black"> 802.         Returns an iterator over the results from executing this query.</font>
<font color="black"> 803.         &quot;&quot;&quot;</font>
<font color="green"> 804.         converters = None</font>
<font color="green"> 805.         if results is None:</font>
<font color="green"> 806.             results = self.execute_sql(MULTI)</font>
<font color="green"> 807.         fields = [s[0] for s in self.select[0:self.col_count]]</font>
<font color="green"> 808.         converters = self.get_converters(fields)</font>
<font color="green"> 809.         for rows in results:</font>
<font color="green"> 810.             for row in rows:</font>
<font color="green"> 811.                 if converters:</font>
<font color="red"> 812.                     row = self.apply_converters(row, converters)</font>
<font color="green"> 813.                 yield row</font>
<font color="black"> 814. </font>
<font color="green"> 815.     def has_results(self):</font>
<font color="black"> 816.         &quot;&quot;&quot;</font>
<font color="black"> 817.         Backends (e.g. NoSQL) can override this in order to use optimized</font>
<font color="black"> 818.         versions of &quot;query has any results.&quot;</font>
<font color="black"> 819.         &quot;&quot;&quot;</font>
<font color="black"> 820.         # This is always executed on a query clone, so we can modify self.query</font>
<font color="red"> 821.         self.query.add_extra({'a': 1}, None, None, None, None, None)</font>
<font color="red"> 822.         self.query.set_extra_mask(['a'])</font>
<font color="red"> 823.         return bool(self.execute_sql(SINGLE))</font>
<font color="black"> 824. </font>
<font color="green"> 825.     def execute_sql(self, result_type=MULTI):</font>
<font color="black"> 826.         &quot;&quot;&quot;</font>
<font color="black"> 827.         Run the query against the database and returns the result(s). The</font>
<font color="black"> 828.         return value is a single data item if result_type is SINGLE, or an</font>
<font color="black"> 829.         iterator over the results if the result_type is MULTI.</font>
<font color="black"> 830. </font>
<font color="black"> 831.         result_type is either MULTI (use fetchmany() to retrieve all rows),</font>
<font color="black"> 832.         SINGLE (only retrieve a single row), or None. In this last case, the</font>
<font color="black"> 833.         cursor is returned if any query is executed, since it's used by</font>
<font color="black"> 834.         subclasses such as InsertQuery). It's possible, however, that no query</font>
<font color="black"> 835.         is needed, as the filters describe an empty set. In that case, None is</font>
<font color="black"> 836.         returned, to avoid any unnecessary database interaction.</font>
<font color="black"> 837.         &quot;&quot;&quot;</font>
<font color="green"> 838.         if not result_type:</font>
<font color="red"> 839.             result_type = NO_RESULTS</font>
<font color="green"> 840.         try:</font>
<font color="green"> 841.             sql, params = self.as_sql()</font>
<font color="green"> 842.             if not sql:</font>
<font color="red"> 843.                 raise EmptyResultSet</font>
<font color="red"> 844.         except EmptyResultSet:</font>
<font color="red"> 845.             if result_type == MULTI:</font>
<font color="red"> 846.                 return iter([])</font>
<font color="black"> 847.             else:</font>
<font color="red"> 848.                 return</font>
<font color="black"> 849. </font>
<font color="green"> 850.         cursor = self.connection.cursor()</font>
<font color="green"> 851.         try:</font>
<font color="green"> 852.             cursor.execute(sql, params)</font>
<font color="red"> 853.         except Exception:</font>
<font color="red"> 854.             cursor.close()</font>
<font color="red"> 855.             raise</font>
<font color="black"> 856. </font>
<font color="green"> 857.         if result_type == CURSOR:</font>
<font color="black"> 858.             # Caller didn't specify a result_type, so just give them back the</font>
<font color="black"> 859.             # cursor to process (and close).</font>
<font color="red"> 860.             return cursor</font>
<font color="green"> 861.         if result_type == SINGLE:</font>
<font color="red"> 862.             try:</font>
<font color="red"> 863.                 val = cursor.fetchone()</font>
<font color="red"> 864.                 if val:</font>
<font color="red"> 865.                     return val[0:self.col_count]</font>
<font color="red"> 866.                 return val</font>
<font color="black"> 867.             finally:</font>
<font color="black"> 868.                 # done with the cursor</font>
<font color="red"> 869.                 cursor.close()</font>
<font color="green"> 870.         if result_type == NO_RESULTS:</font>
<font color="red"> 871.             cursor.close()</font>
<font color="red"> 872.             return</font>
<font color="black"> 873. </font>
<font color="green"> 874.         result = cursor_iter(</font>
<font color="green"> 875.             cursor, self.connection.features.empty_fetchmany_value,</font>
<font color="green"> 876.             self.col_count</font>
<font color="black"> 877.         )</font>
<font color="green"> 878.         if not self.connection.features.can_use_chunked_reads:</font>
<font color="green"> 879.             try:</font>
<font color="black"> 880.                 # If we are using non-chunked reads, we return the same data</font>
<font color="black"> 881.                 # structure as normally, but ensure it is all read into memory</font>
<font color="black"> 882.                 # before going any further.</font>
<font color="green"> 883.                 return list(result)</font>
<font color="black"> 884.             finally:</font>
<font color="black"> 885.                 # done with the cursor</font>
<font color="green"> 886.                 cursor.close()</font>
<font color="red"> 887.         return result</font>
<font color="black"> 888. </font>
<font color="green"> 889.     def as_subquery_condition(self, alias, columns, compiler):</font>
<font color="red"> 890.         qn = compiler.quote_name_unless_alias</font>
<font color="red"> 891.         qn2 = self.connection.ops.quote_name</font>
<font color="red"> 892.         if len(columns) == 1:</font>
<font color="red"> 893.             sql, params = self.as_sql()</font>
<font color="red"> 894.             return '%s.%s IN (%s)' % (qn(alias), qn2(columns[0]), sql), params</font>
<font color="black"> 895. </font>
<font color="red"> 896.         for index, select_col in enumerate(self.query.select):</font>
<font color="red"> 897.             lhs_sql, lhs_params = self.compile(select_col)</font>
<font color="red"> 898.             rhs = '%s.%s' % (qn(alias), qn2(columns[index]))</font>
<font color="red"> 899.             self.query.where.add(</font>
<font color="red"> 900.                 QueryWrapper('%s = %s' % (lhs_sql, rhs), lhs_params), 'AND')</font>
<font color="black"> 901. </font>
<font color="red"> 902.         sql, params = self.as_sql()</font>
<font color="red"> 903.         return 'EXISTS (%s)' % sql, params</font>
<font color="black"> 904. </font>
<font color="black"> 905. </font>
<font color="green"> 906. class SQLInsertCompiler(SQLCompiler):</font>
<font color="black"> 907. </font>
<font color="green"> 908.     def __init__(self, *args, **kwargs):</font>
<font color="green"> 909.         self.return_id = False</font>
<font color="green"> 910.         super(SQLInsertCompiler, self).__init__(*args, **kwargs)</font>
<font color="black"> 911. </font>
<font color="green"> 912.     def field_as_sql(self, field, val):</font>
<font color="black"> 913.         &quot;&quot;&quot;</font>
<font color="black"> 914.         Take a field and a value intended to be saved on that field, and</font>
<font color="black"> 915.         return placeholder SQL and accompanying params. Checks for raw values,</font>
<font color="black"> 916.         expressions and fields with get_placeholder() defined in that order.</font>
<font color="black"> 917. </font>
<font color="black"> 918.         When field is None, the value is considered raw and is used as the</font>
<font color="black"> 919.         placeholder, with no corresponding parameters returned.</font>
<font color="black"> 920.         &quot;&quot;&quot;</font>
<font color="green"> 921.         if field is None:</font>
<font color="black"> 922.             # A field value of None means the value is raw.</font>
<font color="red"> 923.             sql, params = val, []</font>
<font color="green"> 924.         elif hasattr(val, 'as_sql'):</font>
<font color="black"> 925.             # This is an expression, let's compile it.</font>
<font color="red"> 926.             sql, params = self.compile(val)</font>
<font color="green"> 927.         elif hasattr(field, 'get_placeholder'):</font>
<font color="black"> 928.             # Some fields (e.g. geo fields) need special munging before</font>
<font color="black"> 929.             # they can be inserted.</font>
<font color="red"> 930.             sql, params = field.get_placeholder(val, self, self.connection), [val]</font>
<font color="black"> 931.         else:</font>
<font color="black"> 932.             # Return the common case for the placeholder</font>
<font color="green"> 933.             sql, params = '%s', [val]</font>
<font color="black"> 934. </font>
<font color="black"> 935.         # The following hook is only used by Oracle Spatial, which sometimes</font>
<font color="black"> 936.         # needs to yield 'NULL' and [] as its placeholder and params instead</font>
<font color="black"> 937.         # of '%s' and [None]. The 'NULL' placeholder is produced earlier by</font>
<font color="black"> 938.         # OracleOperations.get_geom_placeholder(). The following line removes</font>
<font color="black"> 939.         # the corresponding None parameter. See ticket #10888.</font>
<font color="green"> 940.         params = self.connection.ops.modify_insert_params(sql, params)</font>
<font color="black"> 941. </font>
<font color="green"> 942.         return sql, params</font>
<font color="black"> 943. </font>
<font color="green"> 944.     def prepare_value(self, field, value):</font>
<font color="black"> 945.         &quot;&quot;&quot;</font>
<font color="black"> 946.         Prepare a value to be used in a query by resolving it if it is an</font>
<font color="black"> 947.         expression and otherwise calling the field's get_db_prep_save().</font>
<font color="black"> 948.         &quot;&quot;&quot;</font>
<font color="green"> 949.         if hasattr(value, 'resolve_expression'):</font>
<font color="red"> 950.             value = value.resolve_expression(self.query, allow_joins=False, for_save=True)</font>
<font color="black"> 951.             # Don't allow values containing Col expressions. They refer to</font>
<font color="black"> 952.             # existing columns on a row, but in the case of insert the row</font>
<font color="black"> 953.             # doesn't exist yet.</font>
<font color="red"> 954.             if value.contains_column_references:</font>
<font color="red"> 955.                 raise ValueError(</font>
<font color="red"> 956.                     'Failed to insert expression &quot;%s&quot; on %s. F() expressions '</font>
<font color="red"> 957.                     'can only be used to update, not to insert.' % (value, field)</font>
<font color="black"> 958.                 )</font>
<font color="red"> 959.             if value.contains_aggregate:</font>
<font color="red"> 960.                 raise FieldError(&quot;Aggregate functions are not allowed in this query&quot;)</font>
<font color="black"> 961.         else:</font>
<font color="green"> 962.             value = field.get_db_prep_save(value, connection=self.connection)</font>
<font color="green"> 963.         return value</font>
<font color="black"> 964. </font>
<font color="green"> 965.     def pre_save_val(self, field, obj):</font>
<font color="black"> 966.         &quot;&quot;&quot;</font>
<font color="black"> 967.         Get the given field's value off the given obj. pre_save() is used for</font>
<font color="black"> 968.         things like auto_now on DateTimeField. Skip it if this is a raw query.</font>
<font color="black"> 969.         &quot;&quot;&quot;</font>
<font color="green"> 970.         if self.query.raw:</font>
<font color="red"> 971.             return getattr(obj, field.attname)</font>
<font color="green"> 972.         return field.pre_save(obj, add=True)</font>
<font color="black"> 973. </font>
<font color="green"> 974.     def assemble_as_sql(self, fields, value_rows):</font>
<font color="black"> 975.         &quot;&quot;&quot;</font>
<font color="black"> 976.         Take a sequence of N fields and a sequence of M rows of values,</font>
<font color="black"> 977.         generate placeholder SQL and parameters for each field and value, and</font>
<font color="black"> 978.         return a pair containing:</font>
<font color="black"> 979.          * a sequence of M rows of N SQL placeholder strings, and</font>
<font color="black"> 980.          * a sequence of M rows of corresponding parameter values.</font>
<font color="black"> 981. </font>
<font color="black"> 982.         Each placeholder string may contain any number of '%s' interpolation</font>
<font color="black"> 983.         strings, and each parameter row will contain exactly as many params</font>
<font color="black"> 984.         as the total number of '%s's in the corresponding placeholder row.</font>
<font color="black"> 985.         &quot;&quot;&quot;</font>
<font color="green"> 986.         if not value_rows:</font>
<font color="red"> 987.             return [], []</font>
<font color="black"> 988. </font>
<font color="black"> 989.         # list of (sql, [params]) tuples for each object to be saved</font>
<font color="black"> 990.         # Shape: [n_objs][n_fields][2]</font>
<font color="black"> 991.         rows_of_fields_as_sql = (</font>
<font color="green"> 992.             (self.field_as_sql(field, v) for field, v in zip(fields, row))</font>
<font color="green"> 993.             for row in value_rows</font>
<font color="black"> 994.         )</font>
<font color="black"> 995. </font>
<font color="black"> 996.         # tuple like ([sqls], [[params]s]) for each object to be saved</font>
<font color="black"> 997.         # Shape: [n_objs][2][n_fields]</font>
<font color="green"> 998.         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)</font>
<font color="black"> 999. </font>
<font color="black">1000.         # Extract separate lists for placeholders and params.</font>
<font color="black">1001.         # Each of these has shape [n_objs][n_fields]</font>
<font color="green">1002.         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)</font>
<font color="black">1003. </font>
<font color="black">1004.         # Params for each field are still lists, and need to be flattened.</font>
<font color="green">1005.         param_rows = [[p for ps in row for p in ps] for row in param_rows]</font>
<font color="black">1006. </font>
<font color="green">1007.         return placeholder_rows, param_rows</font>
<font color="black">1008. </font>
<font color="green">1009.     def as_sql(self):</font>
<font color="black">1010.         # We don't need quote_name_unless_alias() here, since these are all</font>
<font color="black">1011.         # going to be column names (so we can avoid the extra overhead).</font>
<font color="green">1012.         qn = self.connection.ops.quote_name</font>
<font color="green">1013.         opts = self.query.get_meta()</font>
<font color="green">1014.         result = ['INSERT INTO %s' % qn(opts.db_table)]</font>
<font color="black">1015. </font>
<font color="green">1016.         has_fields = bool(self.query.fields)</font>
<font color="green">1017.         fields = self.query.fields if has_fields else [opts.pk]</font>
<font color="green">1018.         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))</font>
<font color="black">1019. </font>
<font color="green">1020.         if has_fields:</font>
<font color="black">1021.             value_rows = [</font>
<font color="green">1022.                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]</font>
<font color="green">1023.                 for obj in self.query.objs</font>
<font color="black">1024.             ]</font>
<font color="black">1025.         else:</font>
<font color="black">1026.             # An empty object.</font>
<font color="red">1027.             value_rows = [[self.connection.ops.pk_default_value()] for _ in self.query.objs]</font>
<font color="red">1028.             fields = [None]</font>
<font color="black">1029. </font>
<font color="black">1030.         # Currently the backends just accept values when generating bulk</font>
<font color="black">1031.         # queries and generate their own placeholders. Doing that isn't</font>
<font color="black">1032.         # necessary and it should be possible to use placeholders and</font>
<font color="black">1033.         # expressions in bulk inserts too.</font>
<font color="green">1034.         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)</font>
<font color="black">1035. </font>
<font color="green">1036.         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)</font>
<font color="black">1037. </font>
<font color="green">1038.         if self.return_id and self.connection.features.can_return_id_from_insert:</font>
<font color="red">1039.             params = param_rows[0]</font>
<font color="red">1040.             col = &quot;%s.%s&quot; % (qn(opts.db_table), qn(opts.pk.column))</font>
<font color="red">1041.             result.append(&quot;VALUES (%s)&quot; % &quot;, &quot;.join(placeholder_rows[0]))</font>
<font color="red">1042.             r_fmt, r_params = self.connection.ops.return_insert_id()</font>
<font color="black">1043.             # Skip empty r_fmt to allow subclasses to customize behavior for</font>
<font color="black">1044.             # 3rd party backends. Refs #19096.</font>
<font color="red">1045.             if r_fmt:</font>
<font color="red">1046.                 result.append(r_fmt % col)</font>
<font color="red">1047.                 params += r_params</font>
<font color="red">1048.             return [(&quot; &quot;.join(result), tuple(params))]</font>
<font color="black">1049. </font>
<font color="green">1050.         if can_bulk:</font>
<font color="green">1051.             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))</font>
<font color="green">1052.             return [(&quot; &quot;.join(result), tuple(p for ps in param_rows for p in ps))]</font>
<font color="black">1053.         else:</font>
<font color="black">1054.             return [</font>
<font color="green">1055.                 (&quot; &quot;.join(result + [&quot;VALUES (%s)&quot; % &quot;, &quot;.join(p)]), vals)</font>
<font color="green">1056.                 for p, vals in zip(placeholder_rows, param_rows)</font>
<font color="black">1057.             ]</font>
<font color="black">1058. </font>
<font color="green">1059.     def execute_sql(self, return_id=False):</font>
<font color="green">1060.         assert not (return_id and len(self.query.objs) != 1)</font>
<font color="green">1061.         self.return_id = return_id</font>
<font color="green">1062.         with self.connection.cursor() as cursor:</font>
<font color="green">1063.             for sql, params in self.as_sql():</font>
<font color="green">1064.                 cursor.execute(sql, params)</font>
<font color="green">1065.             if not (return_id and cursor):</font>
<font color="green">1066.                 return</font>
<font color="green">1067.             if self.connection.features.can_return_id_from_insert:</font>
<font color="red">1068.                 return self.connection.ops.fetch_returned_insert_id(cursor)</font>
<font color="green">1069.             return self.connection.ops.last_insert_id(cursor,</font>
<font color="green">1070.                     self.query.get_meta().db_table, self.query.get_meta().pk.column)</font>
<font color="black">1071. </font>
<font color="black">1072. </font>
<font color="green">1073. class SQLDeleteCompiler(SQLCompiler):</font>
<font color="green">1074.     def as_sql(self):</font>
<font color="black">1075.         &quot;&quot;&quot;</font>
<font color="black">1076.         Creates the SQL for this query. Returns the SQL string and list of</font>
<font color="black">1077.         parameters.</font>
<font color="black">1078.         &quot;&quot;&quot;</font>
<font color="red">1079.         assert len([t for t in self.query.tables if self.query.alias_refcount[t] &gt; 0]) == 1, \</font>
<font color="red">1080.             &quot;Can only delete from one table at a time.&quot;</font>
<font color="red">1081.         qn = self.quote_name_unless_alias</font>
<font color="red">1082.         result = ['DELETE FROM %s' % qn(self.query.tables[0])]</font>
<font color="red">1083.         where, params = self.compile(self.query.where)</font>
<font color="red">1084.         if where:</font>
<font color="red">1085.             result.append('WHERE %s' % where)</font>
<font color="red">1086.         return ' '.join(result), tuple(params)</font>
<font color="black">1087. </font>
<font color="black">1088. </font>
<font color="green">1089. class SQLUpdateCompiler(SQLCompiler):</font>
<font color="green">1090.     def as_sql(self):</font>
<font color="black">1091.         &quot;&quot;&quot;</font>
<font color="black">1092.         Creates the SQL for this query. Returns the SQL string and list of</font>
<font color="black">1093.         parameters.</font>
<font color="black">1094.         &quot;&quot;&quot;</font>
<font color="red">1095.         self.pre_sql_setup()</font>
<font color="red">1096.         if not self.query.values:</font>
<font color="red">1097.             return '', ()</font>
<font color="red">1098.         table = self.query.tables[0]</font>
<font color="red">1099.         qn = self.quote_name_unless_alias</font>
<font color="red">1100.         result = ['UPDATE %s' % qn(table)]</font>
<font color="red">1101.         result.append('SET')</font>
<font color="red">1102.         values, update_params = [], []</font>
<font color="red">1103.         for field, model, val in self.query.values:</font>
<font color="red">1104.             if hasattr(val, 'resolve_expression'):</font>
<font color="red">1105.                 val = val.resolve_expression(self.query, allow_joins=False, for_save=True)</font>
<font color="red">1106.                 if val.contains_aggregate:</font>
<font color="red">1107.                     raise FieldError(&quot;Aggregate functions are not allowed in this query&quot;)</font>
<font color="red">1108.             elif hasattr(val, 'prepare_database_save'):</font>
<font color="red">1109.                 if field.remote_field:</font>
<font color="red">1110.                     val = field.get_db_prep_save(</font>
<font color="red">1111.                         val.prepare_database_save(field),</font>
<font color="red">1112.                         connection=self.connection,</font>
<font color="black">1113.                     )</font>
<font color="black">1114.                 else:</font>
<font color="red">1115.                     raise TypeError(</font>
<font color="red">1116.                         &quot;Tried to update field %s with a model instance, %r. &quot;</font>
<font color="black">1117.                         &quot;Use a value compatible with %s.&quot;</font>
<font color="red">1118.                         % (field, val, field.__class__.__name__)</font>
<font color="black">1119.                     )</font>
<font color="black">1120.             else:</font>
<font color="red">1121.                 val = field.get_db_prep_save(val, connection=self.connection)</font>
<font color="black">1122. </font>
<font color="black">1123.             # Getting the placeholder for the field.</font>
<font color="red">1124.             if hasattr(field, 'get_placeholder'):</font>
<font color="red">1125.                 placeholder = field.get_placeholder(val, self, self.connection)</font>
<font color="black">1126.             else:</font>
<font color="red">1127.                 placeholder = '%s'</font>
<font color="red">1128.             name = field.column</font>
<font color="red">1129.             if hasattr(val, 'as_sql'):</font>
<font color="red">1130.                 sql, params = self.compile(val)</font>
<font color="red">1131.                 values.append('%s = %s' % (qn(name), sql))</font>
<font color="red">1132.                 update_params.extend(params)</font>
<font color="red">1133.             elif val is not None:</font>
<font color="red">1134.                 values.append('%s = %s' % (qn(name), placeholder))</font>
<font color="red">1135.                 update_params.append(val)</font>
<font color="black">1136.             else:</font>
<font color="red">1137.                 values.append('%s = NULL' % qn(name))</font>
<font color="red">1138.         if not values:</font>
<font color="red">1139.             return '', ()</font>
<font color="red">1140.         result.append(', '.join(values))</font>
<font color="red">1141.         where, params = self.compile(self.query.where)</font>
<font color="red">1142.         if where:</font>
<font color="red">1143.             result.append('WHERE %s' % where)</font>
<font color="red">1144.         return ' '.join(result), tuple(update_params + params)</font>
<font color="black">1145. </font>
<font color="green">1146.     def execute_sql(self, result_type):</font>
<font color="black">1147.         &quot;&quot;&quot;</font>
<font color="black">1148.         Execute the specified update. Returns the number of rows affected by</font>
<font color="black">1149.         the primary update query. The &quot;primary update query&quot; is the first</font>
<font color="black">1150.         non-empty query that is executed. Row counts for any subsequent,</font>
<font color="black">1151.         related queries are not available.</font>
<font color="black">1152.         &quot;&quot;&quot;</font>
<font color="red">1153.         cursor = super(SQLUpdateCompiler, self).execute_sql(result_type)</font>
<font color="red">1154.         try:</font>
<font color="red">1155.             rows = cursor.rowcount if cursor else 0</font>
<font color="red">1156.             is_empty = cursor is None</font>
<font color="black">1157.         finally:</font>
<font color="red">1158.             if cursor:</font>
<font color="red">1159.                 cursor.close()</font>
<font color="red">1160.         for query in self.query.get_related_updates():</font>
<font color="red">1161.             aux_rows = query.get_compiler(self.using).execute_sql(result_type)</font>
<font color="red">1162.             if is_empty and aux_rows:</font>
<font color="red">1163.                 rows = aux_rows</font>
<font color="red">1164.                 is_empty = False</font>
<font color="red">1165.         return rows</font>
<font color="black">1166. </font>
<font color="green">1167.     def pre_sql_setup(self):</font>
<font color="black">1168.         &quot;&quot;&quot;</font>
<font color="black">1169.         If the update depends on results from other tables, we need to do some</font>
<font color="black">1170.         munging of the &quot;where&quot; conditions to match the format required for</font>
<font color="black">1171.         (portable) SQL updates. That is done here.</font>
<font color="black">1172. </font>
<font color="black">1173.         Further, if we are going to be running multiple updates, we pull out</font>
<font color="black">1174.         the id values to update at this point so that they don't change as a</font>
<font color="black">1175.         result of the progressive updates.</font>
<font color="black">1176.         &quot;&quot;&quot;</font>
<font color="red">1177.         refcounts_before = self.query.alias_refcount.copy()</font>
<font color="black">1178.         # Ensure base table is in the query</font>
<font color="red">1179.         self.query.get_initial_alias()</font>
<font color="red">1180.         count = self.query.count_active_tables()</font>
<font color="red">1181.         if not self.query.related_updates and count == 1:</font>
<font color="red">1182.             return</font>
<font color="red">1183.         query = self.query.clone(klass=Query)</font>
<font color="red">1184.         query.select_related = False</font>
<font color="red">1185.         query.clear_ordering(True)</font>
<font color="red">1186.         query._extra = {}</font>
<font color="red">1187.         query.select = []</font>
<font color="red">1188.         query.add_fields([query.get_meta().pk.name])</font>
<font color="red">1189.         super(SQLUpdateCompiler, self).pre_sql_setup()</font>
<font color="black">1190. </font>
<font color="red">1191.         must_pre_select = count &gt; 1 and not self.connection.features.update_can_self_select</font>
<font color="black">1192. </font>
<font color="black">1193.         # Now we adjust the current query: reset the where clause and get rid</font>
<font color="black">1194.         # of all the tables we don't need (since they're in the sub-select).</font>
<font color="red">1195.         self.query.where = self.query.where_class()</font>
<font color="red">1196.         if self.query.related_updates or must_pre_select:</font>
<font color="black">1197.             # Either we're using the idents in multiple update queries (so</font>
<font color="black">1198.             # don't want them to change), or the db backend doesn't support</font>
<font color="black">1199.             # selecting from the updating table (e.g. MySQL).</font>
<font color="red">1200.             idents = []</font>
<font color="red">1201.             for rows in query.get_compiler(self.using).execute_sql(MULTI):</font>
<font color="red">1202.                 idents.extend(r[0] for r in rows)</font>
<font color="red">1203.             self.query.add_filter(('pk__in', idents))</font>
<font color="red">1204.             self.query.related_ids = idents</font>
<font color="black">1205.         else:</font>
<font color="black">1206.             # The fast path. Filters and updates in one query.</font>
<font color="red">1207.             self.query.add_filter(('pk__in', query))</font>
<font color="red">1208.         self.query.reset_refcounts(refcounts_before)</font>
<font color="black">1209. </font>
<font color="black">1210. </font>
<font color="green">1211. class SQLAggregateCompiler(SQLCompiler):</font>
<font color="green">1212.     def as_sql(self):</font>
<font color="black">1213.         &quot;&quot;&quot;</font>
<font color="black">1214.         Creates the SQL for this query. Returns the SQL string and list of</font>
<font color="black">1215.         parameters.</font>
<font color="black">1216.         &quot;&quot;&quot;</font>
<font color="black">1217.         # Empty SQL for the inner query is a marker that the inner query</font>
<font color="black">1218.         # isn't going to produce any results. This can happen when doing</font>
<font color="black">1219.         # LIMIT 0 queries (generated by qs[:0]) for example.</font>
<font color="red">1220.         if not self.query.subquery:</font>
<font color="red">1221.             raise EmptyResultSet</font>
<font color="red">1222.         sql, params = [], []</font>
<font color="red">1223.         for annotation in self.query.annotation_select.values():</font>
<font color="red">1224.             ann_sql, ann_params = self.compile(annotation, select_format=True)</font>
<font color="red">1225.             sql.append(ann_sql)</font>
<font color="red">1226.             params.extend(ann_params)</font>
<font color="red">1227.         self.col_count = len(self.query.annotation_select)</font>
<font color="red">1228.         sql = ', '.join(sql)</font>
<font color="red">1229.         params = tuple(params)</font>
<font color="black">1230. </font>
<font color="red">1231.         sql = 'SELECT %s FROM (%s) subquery' % (sql, self.query.subquery)</font>
<font color="red">1232.         params = params + self.query.sub_params</font>
<font color="red">1233.         return sql, params</font>
<font color="black">1234. </font>
<font color="black">1235. </font>
<font color="green">1236. def cursor_iter(cursor, sentinel, col_count):</font>
<font color="black">1237.     &quot;&quot;&quot;</font>
<font color="black">1238.     Yields blocks of rows from a cursor and ensures the cursor is closed when</font>
<font color="black">1239.     done.</font>
<font color="black">1240.     &quot;&quot;&quot;</font>
<font color="green">1241.     try:</font>
<font color="green">1242.         for rows in iter((lambda: cursor.fetchmany(GET_ITERATOR_CHUNK_SIZE)),</font>
<font color="green">1243.                          sentinel):</font>
<font color="green">1244.             yield [r[0:col_count] for r in rows]</font>
<font color="black">1245.     finally:</font>
<font color="green">1246.         cursor.close()</font>
</pre>

