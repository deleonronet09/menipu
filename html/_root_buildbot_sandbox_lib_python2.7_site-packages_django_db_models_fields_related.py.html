source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/fields/related.py</b><br>


file stats: <b>995 lines, 402 executed: 40.4% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import warnings</font>
<font color="green">   4. from functools import partial</font>
<font color="black">   5. </font>
<font color="green">   6. from django import forms</font>
<font color="green">   7. from django.apps import apps</font>
<font color="green">   8. from django.core import checks, exceptions</font>
<font color="green">   9. from django.db import connection, router</font>
<font color="green">  10. from django.db.backends import utils</font>
<font color="green">  11. from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL</font>
<font color="green">  12. from django.db.models.query_utils import PathInfo</font>
<font color="green">  13. from django.db.models.utils import make_model_tuple</font>
<font color="green">  14. from django.utils import six</font>
<font color="green">  15. from django.utils.deprecation import (</font>
<font color="black">  16.     RemovedInDjango20Warning, RemovedInDjango110Warning,</font>
<font color="black">  17. )</font>
<font color="green">  18. from django.utils.encoding import force_text, smart_text</font>
<font color="green">  19. from django.utils.functional import cached_property, curry</font>
<font color="green">  20. from django.utils.translation import ugettext_lazy as _</font>
<font color="green">  21. from django.utils.version import get_docs_version</font>
<font color="black">  22. </font>
<font color="green">  23. from . import (</font>
<font color="black">  24.     AutoField, Field, IntegerField, PositiveIntegerField,</font>
<font color="black">  25.     PositiveSmallIntegerField,</font>
<font color="black">  26. )</font>
<font color="green">  27. from .related_descriptors import (</font>
<font color="black">  28.     ForwardManyToOneDescriptor, ManyToManyDescriptor,</font>
<font color="black">  29.     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,</font>
<font color="black">  30. )</font>
<font color="green">  31. from .related_lookups import (</font>
<font color="black">  32.     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,</font>
<font color="black">  33.     RelatedLessThan, RelatedLessThanOrEqual,</font>
<font color="black">  34. )</font>
<font color="green">  35. from .reverse_related import (</font>
<font color="black">  36.     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,</font>
<font color="black">  37. )</font>
<font color="black">  38. </font>
<font color="green">  39. RECURSIVE_RELATIONSHIP_CONSTANT = 'self'</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. def resolve_relation(scope_model, relation):</font>
<font color="black">  43.     &quot;&quot;&quot;</font>
<font color="black">  44.     Transform relation into a model or fully-qualified model string of the form</font>
<font color="black">  45.     &quot;app_label.ModelName&quot;, relative to scope_model.</font>
<font color="black">  46. </font>
<font color="black">  47.     The relation argument can be:</font>
<font color="black">  48.       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string &quot;self&quot;, in which case</font>
<font color="black">  49.         the model argument will be returned.</font>
<font color="black">  50.       * A bare model name without an app_label, in which case scope_model's</font>
<font color="black">  51.         app_label will be prepended.</font>
<font color="black">  52.       * An &quot;app_label.ModelName&quot; string.</font>
<font color="black">  53.       * A model class, which will be returned unchanged.</font>
<font color="black">  54.     &quot;&quot;&quot;</font>
<font color="black">  55.     # Check for recursive relations</font>
<font color="green">  56.     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:</font>
<font color="red">  57.         relation = scope_model</font>
<font color="black">  58. </font>
<font color="black">  59.     # Look for an &quot;app.Model&quot; relation</font>
<font color="green">  60.     if isinstance(relation, six.string_types):</font>
<font color="green">  61.         if &quot;.&quot; not in relation:</font>
<font color="green">  62.             relation = &quot;%s.%s&quot; % (scope_model._meta.app_label, relation)</font>
<font color="black">  63. </font>
<font color="green">  64.     return relation</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="green">  67. def lazy_related_operation(function, model, *related_models, **kwargs):</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="black">  69.     Schedule `function` to be called once `model` and all `related_models`</font>
<font color="black">  70.     have been imported and registered with the app registry. `function` will</font>
<font color="black">  71.     be called with the newly-loaded model classes as its positional arguments,</font>
<font color="black">  72.     plus any optional keyword arguments.</font>
<font color="black">  73. </font>
<font color="black">  74.     The `model` argument must be a model class. Each subsequent positional</font>
<font color="black">  75.     argument is another model, or a reference to another model - see</font>
<font color="black">  76.     `resolve_relation()` for the various forms these may take. Any relative</font>
<font color="black">  77.     references will be resolved relative to `model`.</font>
<font color="black">  78. </font>
<font color="black">  79.     This is a convenience wrapper for `Apps.lazy_model_operation` - the app</font>
<font color="black">  80.     registry model used is the one found in `model._meta.apps`.</font>
<font color="black">  81.     &quot;&quot;&quot;</font>
<font color="green">  82.     models = [model] + [resolve_relation(model, rel) for rel in related_models]</font>
<font color="green">  83.     model_keys = (make_model_tuple(m) for m in models)</font>
<font color="green">  84.     apps = model._meta.apps</font>
<font color="green">  85.     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)</font>
<font color="black">  86. </font>
<font color="black">  87. </font>
<font color="green">  88. def add_lazy_relation(cls, field, relation, operation):</font>
<font color="red">  89.     warnings.warn(</font>
<font color="red">  90.         &quot;add_lazy_relation() has been superseded by lazy_related_operation() &quot;</font>
<font color="black">  91.         &quot;and related methods on the Apps class.&quot;,</font>
<font color="red">  92.         RemovedInDjango20Warning, stacklevel=2)</font>
<font color="black">  93.     # Rearrange args for new Apps.lazy_model_operation</font>
<font color="red">  94.     function = lambda local, related, field: operation(field, related, local)</font>
<font color="red">  95.     lazy_related_operation(function, cls, relation, field=field)</font>
<font color="black">  96. </font>
<font color="black">  97. </font>
<font color="green">  98. class RelatedField(Field):</font>
<font color="black">  99.     &quot;&quot;&quot;</font>
<font color="black"> 100.     Base class that all relational fields inherit from.</font>
<font color="green"> 101.     &quot;&quot;&quot;</font>
<font color="black"> 102. </font>
<font color="black"> 103.     # Field flags</font>
<font color="green"> 104.     one_to_many = False</font>
<font color="green"> 105.     one_to_one = False</font>
<font color="green"> 106.     many_to_many = False</font>
<font color="green"> 107.     many_to_one = False</font>
<font color="black"> 108. </font>
<font color="green"> 109.     @cached_property</font>
<font color="black"> 110.     def related_model(self):</font>
<font color="black"> 111.         # Can't cache this property until all the models are loaded.</font>
<font color="green"> 112.         apps.check_models_ready()</font>
<font color="green"> 113.         return self.remote_field.model</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def check(self, **kwargs):</font>
<font color="red"> 116.         errors = super(RelatedField, self).check(**kwargs)</font>
<font color="red"> 117.         errors.extend(self._check_related_name_is_valid())</font>
<font color="red"> 118.         errors.extend(self._check_relation_model_exists())</font>
<font color="red"> 119.         errors.extend(self._check_referencing_to_swapped_model())</font>
<font color="red"> 120.         errors.extend(self._check_clashes())</font>
<font color="red"> 121.         return errors</font>
<font color="black"> 122. </font>
<font color="green"> 123.     def _check_related_name_is_valid(self):</font>
<font color="red"> 124.         import re</font>
<font color="red"> 125.         import keyword</font>
<font color="red"> 126.         related_name = self.remote_field.related_name</font>
<font color="red"> 127.         if related_name is None:</font>
<font color="red"> 128.             return []</font>
<font color="red"> 129.         is_valid_id = True</font>
<font color="red"> 130.         if keyword.iskeyword(related_name):</font>
<font color="red"> 131.             is_valid_id = False</font>
<font color="red"> 132.         if six.PY3:</font>
<font color="red"> 133.             if not related_name.isidentifier():</font>
<font color="red"> 134.                 is_valid_id = False</font>
<font color="black"> 135.         else:</font>
<font color="red"> 136.             if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*\Z', related_name):</font>
<font color="red"> 137.                 is_valid_id = False</font>
<font color="red"> 138.         if not (is_valid_id or related_name.endswith('+')):</font>
<font color="black"> 139.             return [</font>
<font color="red"> 140.                 checks.Error(</font>
<font color="red"> 141.                     &quot;The name '%s' is invalid related_name for field %s.%s&quot; %</font>
<font color="red"> 142.                     (self.remote_field.related_name, self.model._meta.object_name,</font>
<font color="red"> 143.                      self.name),</font>
<font color="red"> 144.                     hint=&quot;Related name must be a valid Python identifier or end with a '+'&quot;,</font>
<font color="red"> 145.                     obj=self,</font>
<font color="red"> 146.                     id='fields.E306',</font>
<font color="black"> 147.                 )</font>
<font color="black"> 148.             ]</font>
<font color="red"> 149.         return []</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def _check_relation_model_exists(self):</font>
<font color="red"> 152.         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()</font>
<font color="red"> 153.         rel_is_string = isinstance(self.remote_field.model, six.string_types)</font>
<font color="red"> 154.         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name</font>
<font color="red"> 155.         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):</font>
<font color="black"> 156.             return [</font>
<font color="red"> 157.                 checks.Error(</font>
<font color="red"> 158.                     (&quot;Field defines a relation with model '%s', which &quot;</font>
<font color="red"> 159.                      &quot;is either not installed, or is abstract.&quot;) % model_name,</font>
<font color="red"> 160.                     hint=None,</font>
<font color="red"> 161.                     obj=self,</font>
<font color="red"> 162.                     id='fields.E300',</font>
<font color="black"> 163.                 )</font>
<font color="black"> 164.             ]</font>
<font color="red"> 165.         return []</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def _check_referencing_to_swapped_model(self):</font>
<font color="red"> 168.         if (self.remote_field.model not in self.opts.apps.get_models() and</font>
<font color="red"> 169.                 not isinstance(self.remote_field.model, six.string_types) and</font>
<font color="red"> 170.                 self.remote_field.model._meta.swapped):</font>
<font color="red"> 171.             model = &quot;%s.%s&quot; % (</font>
<font color="red"> 172.                 self.remote_field.model._meta.app_label,</font>
<font color="red"> 173.                 self.remote_field.model._meta.object_name</font>
<font color="black"> 174.             )</font>
<font color="black"> 175.             return [</font>
<font color="red"> 176.                 checks.Error(</font>
<font color="red"> 177.                     (&quot;Field defines a relation with the model '%s', &quot;</font>
<font color="red"> 178.                      &quot;which has been swapped out.&quot;) % model,</font>
<font color="red"> 179.                     hint=&quot;Update the relation to point at 'settings.%s'.&quot; % self.remote_field.model._meta.swappable,</font>
<font color="red"> 180.                     obj=self,</font>
<font color="red"> 181.                     id='fields.E301',</font>
<font color="black"> 182.                 )</font>
<font color="black"> 183.             ]</font>
<font color="red"> 184.         return []</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def _check_clashes(self):</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="black"> 188.         Check accessor and reverse query name clashes.</font>
<font color="black"> 189.         &quot;&quot;&quot;</font>
<font color="red"> 190.         from django.db.models.base import ModelBase</font>
<font color="black"> 191. </font>
<font color="red"> 192.         errors = []</font>
<font color="red"> 193.         opts = self.model._meta</font>
<font color="black"> 194. </font>
<font color="black"> 195.         # `f.remote_field.model` may be a string instead of a model. Skip if model name is</font>
<font color="black"> 196.         # not resolved.</font>
<font color="red"> 197.         if not isinstance(self.remote_field.model, ModelBase):</font>
<font color="red"> 198.             return []</font>
<font color="black"> 199. </font>
<font color="black"> 200.         # If the field doesn't install backward relation on the target model (so</font>
<font color="black"> 201.         # `is_hidden` returns True), then there are no clashes to check and we</font>
<font color="black"> 202.         # can skip these fields.</font>
<font color="red"> 203.         if self.remote_field.is_hidden():</font>
<font color="red"> 204.             return []</font>
<font color="black"> 205. </font>
<font color="black"> 206.         # Consider that we are checking field `Model.foreign` and the models</font>
<font color="black"> 207.         # are:</font>
<font color="black"> 208.         #</font>
<font color="black"> 209.         #     class Target(models.Model):</font>
<font color="black"> 210.         #         model = models.IntegerField()</font>
<font color="black"> 211.         #         model_set = models.IntegerField()</font>
<font color="black"> 212.         #</font>
<font color="black"> 213.         #     class Model(models.Model):</font>
<font color="black"> 214.         #         foreign = models.ForeignKey(Target)</font>
<font color="black"> 215.         #         m2m = models.ManyToManyField(Target)</font>
<font color="black"> 216. </font>
<font color="red"> 217.         rel_opts = self.remote_field.model._meta</font>
<font color="black"> 218.         # rel_opts.object_name == &quot;Target&quot;</font>
<font color="red"> 219.         rel_name = self.remote_field.get_accessor_name()  # i. e. &quot;model_set&quot;</font>
<font color="red"> 220.         rel_query_name = self.related_query_name()  # i. e. &quot;model&quot;</font>
<font color="red"> 221.         field_name = &quot;%s.%s&quot; % (opts.object_name,</font>
<font color="red"> 222.             self.name)  # i. e. &quot;Model.field&quot;</font>
<font color="black"> 223. </font>
<font color="black"> 224.         # Check clashes between accessor or reverse query name of `field`</font>
<font color="black"> 225.         # and any other field name -- i.e. accessor for Model.foreign is</font>
<font color="black"> 226.         # model_set and it clashes with Target.model_set.</font>
<font color="red"> 227.         potential_clashes = rel_opts.fields + rel_opts.many_to_many</font>
<font color="red"> 228.         for clash_field in potential_clashes:</font>
<font color="red"> 229.             clash_name = &quot;%s.%s&quot; % (rel_opts.object_name,</font>
<font color="red"> 230.                 clash_field.name)  # i. e. &quot;Target.model_set&quot;</font>
<font color="red"> 231.             if clash_field.name == rel_name:</font>
<font color="red"> 232.                 errors.append(</font>
<font color="red"> 233.                     checks.Error(</font>
<font color="red"> 234.                         &quot;Reverse accessor for '%s' clashes with field name '%s'.&quot; % (field_name, clash_name),</font>
<font color="red"> 235.                         hint=(&quot;Rename field '%s', or add/change a related_name &quot;</font>
<font color="red"> 236.                               &quot;argument to the definition for field '%s'.&quot;) % (clash_name, field_name),</font>
<font color="red"> 237.                         obj=self,</font>
<font color="red"> 238.                         id='fields.E302',</font>
<font color="black"> 239.                     )</font>
<font color="black"> 240.                 )</font>
<font color="black"> 241. </font>
<font color="red"> 242.             if clash_field.name == rel_query_name:</font>
<font color="red"> 243.                 errors.append(</font>
<font color="red"> 244.                     checks.Error(</font>
<font color="red"> 245.                         &quot;Reverse query name for '%s' clashes with field name '%s'.&quot; % (field_name, clash_name),</font>
<font color="red"> 246.                         hint=(&quot;Rename field '%s', or add/change a related_name &quot;</font>
<font color="red"> 247.                               &quot;argument to the definition for field '%s'.&quot;) % (clash_name, field_name),</font>
<font color="red"> 248.                         obj=self,</font>
<font color="red"> 249.                         id='fields.E303',</font>
<font color="black"> 250.                     )</font>
<font color="black"> 251.                 )</font>
<font color="black"> 252. </font>
<font color="black"> 253.         # Check clashes between accessors/reverse query names of `field` and</font>
<font color="black"> 254.         # any other field accessor -- i. e. Model.foreign accessor clashes with</font>
<font color="black"> 255.         # Model.m2m accessor.</font>
<font color="red"> 256.         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)</font>
<font color="red"> 257.         for clash_field in potential_clashes:</font>
<font color="red"> 258.             clash_name = &quot;%s.%s&quot; % (  # i. e. &quot;Model.m2m&quot;</font>
<font color="red"> 259.                 clash_field.related_model._meta.object_name,</font>
<font color="red"> 260.                 clash_field.field.name)</font>
<font color="red"> 261.             if clash_field.get_accessor_name() == rel_name:</font>
<font color="red"> 262.                 errors.append(</font>
<font color="red"> 263.                     checks.Error(</font>
<font color="red"> 264.                         &quot;Reverse accessor for '%s' clashes with reverse accessor for '%s'.&quot; % (field_name, clash_name),</font>
<font color="red"> 265.                         hint=(&quot;Add or change a related_name argument &quot;</font>
<font color="red"> 266.                               &quot;to the definition for '%s' or '%s'.&quot;) % (field_name, clash_name),</font>
<font color="red"> 267.                         obj=self,</font>
<font color="red"> 268.                         id='fields.E304',</font>
<font color="black"> 269.                     )</font>
<font color="black"> 270.                 )</font>
<font color="black"> 271. </font>
<font color="red"> 272.             if clash_field.get_accessor_name() == rel_query_name:</font>
<font color="red"> 273.                 errors.append(</font>
<font color="red"> 274.                     checks.Error(</font>
<font color="red"> 275.                         &quot;Reverse query name for '%s' clashes with reverse query name for '%s'.&quot;</font>
<font color="red"> 276.                         % (field_name, clash_name),</font>
<font color="red"> 277.                         hint=(&quot;Add or change a related_name argument &quot;</font>
<font color="red"> 278.                               &quot;to the definition for '%s' or '%s'.&quot;) % (field_name, clash_name),</font>
<font color="red"> 279.                         obj=self,</font>
<font color="red"> 280.                         id='fields.E305',</font>
<font color="black"> 281.                     )</font>
<font color="black"> 282.                 )</font>
<font color="black"> 283. </font>
<font color="red"> 284.         return errors</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def db_type(self, connection):</font>
<font color="black"> 287.         # By default related field will not have a column as it relates to</font>
<font color="black"> 288.         # columns from another table.</font>
<font color="red"> 289.         return None</font>
<font color="black"> 290. </font>
<font color="green"> 291.     def contribute_to_class(self, cls, name, virtual_only=False):</font>
<font color="black"> 292. </font>
<font color="green"> 293.         super(RelatedField, self).contribute_to_class(cls, name, virtual_only=virtual_only)</font>
<font color="black"> 294. </font>
<font color="green"> 295.         self.opts = cls._meta</font>
<font color="black"> 296. </font>
<font color="green"> 297.         if not cls._meta.abstract:</font>
<font color="green"> 298.             if self.remote_field.related_name:</font>
<font color="green"> 299.                 related_name = force_text(self.remote_field.related_name) % {</font>
<font color="green"> 300.                     'class': cls.__name__.lower(),</font>
<font color="green"> 301.                     'app_label': cls._meta.app_label.lower()</font>
<font color="black"> 302.                 }</font>
<font color="green"> 303.                 self.remote_field.related_name = related_name</font>
<font color="black"> 304. </font>
<font color="green"> 305.             def resolve_related_class(model, related, field):</font>
<font color="green"> 306.                 field.remote_field.model = related</font>
<font color="green"> 307.                 field.do_related_class(related, model)</font>
<font color="green"> 308.             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def get_forward_related_filter(self, obj):</font>
<font color="black"> 311.         &quot;&quot;&quot;</font>
<font color="black"> 312.         Return the keyword arguments that when supplied to</font>
<font color="black"> 313.         self.model.object.filter(), would select all instances related through</font>
<font color="black"> 314.         this field to the remote obj. This is used to build the querysets</font>
<font color="black"> 315.         returned by related descriptors. obj is an instance of</font>
<font color="black"> 316.         self.related_field.model.</font>
<font color="black"> 317.         &quot;&quot;&quot;</font>
<font color="black"> 318.         return {</font>
<font color="red"> 319.             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)</font>
<font color="red"> 320.             for _, rh_field in self.related_fields</font>
<font color="black"> 321.         }</font>
<font color="black"> 322. </font>
<font color="green"> 323.     def get_reverse_related_filter(self, obj):</font>
<font color="black"> 324.         &quot;&quot;&quot;</font>
<font color="black"> 325.         Complement to get_forward_related_filter(). Return the keyword</font>
<font color="black"> 326.         arguments that when passed to self.related_field.model.object.filter()</font>
<font color="black"> 327.         select all instances of self.related_field.model related through</font>
<font color="black"> 328.         this field to obj. obj is an instance of self.model.</font>
<font color="black"> 329.         &quot;&quot;&quot;</font>
<font color="black"> 330.         base_filter = {</font>
<font color="red"> 331.             rh_field.attname: getattr(obj, lh_field.attname)</font>
<font color="red"> 332.             for lh_field, rh_field in self.related_fields</font>
<font color="black"> 333.         }</font>
<font color="red"> 334.         base_filter.update(self.get_extra_descriptor_filter(obj) or {})</font>
<font color="red"> 335.         return base_filter</font>
<font color="black"> 336. </font>
<font color="green"> 337.     @property</font>
<font color="black"> 338.     def swappable_setting(self):</font>
<font color="black"> 339.         &quot;&quot;&quot;</font>
<font color="black"> 340.         Get the setting that this is powered from for swapping, or None</font>
<font color="black"> 341.         if it's not swapped in / marked with swappable=False.</font>
<font color="black"> 342.         &quot;&quot;&quot;</font>
<font color="green"> 343.         if self.swappable:</font>
<font color="black"> 344.             # Work out string form of &quot;to&quot;</font>
<font color="green"> 345.             if isinstance(self.remote_field.model, six.string_types):</font>
<font color="green"> 346.                 to_string = self.remote_field.model</font>
<font color="black"> 347.             else:</font>
<font color="red"> 348.                 to_string = self.remote_field.model._meta.label</font>
<font color="green"> 349.             return apps.get_swappable_settings_name(to_string)</font>
<font color="red"> 350.         return None</font>
<font color="black"> 351. </font>
<font color="green"> 352.     def set_attributes_from_rel(self):</font>
<font color="black"> 353.         self.name = (</font>
<font color="green"> 354.             self.name or</font>
<font color="red"> 355.             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)</font>
<font color="black"> 356.         )</font>
<font color="green"> 357.         if self.verbose_name is None:</font>
<font color="red"> 358.             self.verbose_name = self.remote_field.model._meta.verbose_name</font>
<font color="green"> 359.         self.remote_field.set_field_name()</font>
<font color="black"> 360. </font>
<font color="green"> 361.     @property</font>
<font color="black"> 362.     def related(self):</font>
<font color="red"> 363.         warnings.warn(</font>
<font color="red"> 364.             &quot;Usage of field.related has been deprecated. Use field.remote_field instead.&quot;,</font>
<font color="red"> 365.             RemovedInDjango110Warning, 2)</font>
<font color="red"> 366.         return self.remote_field</font>
<font color="black"> 367. </font>
<font color="green"> 368.     def do_related_class(self, other, cls):</font>
<font color="green"> 369.         self.set_attributes_from_rel()</font>
<font color="green"> 370.         self.contribute_to_related_class(other, self.remote_field)</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def get_limit_choices_to(self):</font>
<font color="black"> 373.         &quot;&quot;&quot;</font>
<font color="black"> 374.         Return ``limit_choices_to`` for this model field.</font>
<font color="black"> 375. </font>
<font color="black"> 376.         If it is a callable, it will be invoked and the result will be</font>
<font color="black"> 377.         returned.</font>
<font color="black"> 378.         &quot;&quot;&quot;</font>
<font color="red"> 379.         if callable(self.remote_field.limit_choices_to):</font>
<font color="red"> 380.             return self.remote_field.limit_choices_to()</font>
<font color="red"> 381.         return self.remote_field.limit_choices_to</font>
<font color="black"> 382. </font>
<font color="green"> 383.     def formfield(self, **kwargs):</font>
<font color="black"> 384.         &quot;&quot;&quot;</font>
<font color="black"> 385.         Pass ``limit_choices_to`` to the field being constructed.</font>
<font color="black"> 386. </font>
<font color="black"> 387.         Only passes it if there is a type that supports related fields.</font>
<font color="black"> 388.         This is a similar strategy used to pass the ``queryset`` to the field</font>
<font color="black"> 389.         being constructed.</font>
<font color="black"> 390.         &quot;&quot;&quot;</font>
<font color="green"> 391.         defaults = {}</font>
<font color="green"> 392.         if hasattr(self.remote_field, 'get_related_field'):</font>
<font color="black"> 393.             # If this is a callable, do not invoke it here. Just pass</font>
<font color="black"> 394.             # it in the defaults for when the form class will later be</font>
<font color="black"> 395.             # instantiated.</font>
<font color="green"> 396.             limit_choices_to = self.remote_field.limit_choices_to</font>
<font color="green"> 397.             defaults.update({</font>
<font color="green"> 398.                 'limit_choices_to': limit_choices_to,</font>
<font color="black"> 399.             })</font>
<font color="green"> 400.         defaults.update(kwargs)</font>
<font color="green"> 401.         return super(RelatedField, self).formfield(**defaults)</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def related_query_name(self):</font>
<font color="black"> 404.         &quot;&quot;&quot;</font>
<font color="black"> 405.         Define the name that can be used to identify this related object in a</font>
<font color="black"> 406.         table-spanning query.</font>
<font color="black"> 407.         &quot;&quot;&quot;</font>
<font color="green"> 408.         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name</font>
<font color="black"> 409. </font>
<font color="green"> 410.     @property</font>
<font color="black"> 411.     def target_field(self):</font>
<font color="black"> 412.         &quot;&quot;&quot;</font>
<font color="black"> 413.         When filtering against this relation, returns the field on the remote</font>
<font color="black"> 414.         model against which the filtering should happen.</font>
<font color="black"> 415.         &quot;&quot;&quot;</font>
<font color="red"> 416.         target_fields = self.get_path_info()[-1].target_fields</font>
<font color="red"> 417.         if len(target_fields) &gt; 1:</font>
<font color="red"> 418.             raise exceptions.FieldError(</font>
<font color="red"> 419.                 &quot;The relation has multiple target fields, but only single target field was asked for&quot;)</font>
<font color="red"> 420.         return target_fields[0]</font>
<font color="black"> 421. </font>
<font color="black"> 422. </font>
<font color="green"> 423. class ForeignObject(RelatedField):</font>
<font color="black"> 424.     &quot;&quot;&quot;</font>
<font color="black"> 425.     Abstraction of the ForeignKey relation, supports multi-column relations.</font>
<font color="green"> 426.     &quot;&quot;&quot;</font>
<font color="black"> 427. </font>
<font color="black"> 428.     # Field flags</font>
<font color="green"> 429.     many_to_many = False</font>
<font color="green"> 430.     many_to_one = True</font>
<font color="green"> 431.     one_to_many = False</font>
<font color="green"> 432.     one_to_one = False</font>
<font color="black"> 433. </font>
<font color="green"> 434.     requires_unique_target = True</font>
<font color="green"> 435.     related_accessor_class = ReverseManyToOneDescriptor</font>
<font color="green"> 436.     rel_class = ForeignObjectRel</font>
<font color="black"> 437. </font>
<font color="green"> 438.     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,</font>
<font color="green"> 439.             related_query_name=None, limit_choices_to=None, parent_link=False,</font>
<font color="green"> 440.             swappable=True, **kwargs):</font>
<font color="black"> 441. </font>
<font color="green"> 442.         if rel is None:</font>
<font color="red"> 443.             rel = self.rel_class(</font>
<font color="red"> 444.                 self, to,</font>
<font color="red"> 445.                 related_name=related_name,</font>
<font color="red"> 446.                 related_query_name=related_query_name,</font>
<font color="red"> 447.                 limit_choices_to=limit_choices_to,</font>
<font color="red"> 448.                 parent_link=parent_link,</font>
<font color="red"> 449.                 on_delete=on_delete,</font>
<font color="black"> 450.             )</font>
<font color="black"> 451. </font>
<font color="green"> 452.         super(ForeignObject, self).__init__(rel=rel, **kwargs)</font>
<font color="black"> 453. </font>
<font color="green"> 454.         self.from_fields = from_fields</font>
<font color="green"> 455.         self.to_fields = to_fields</font>
<font color="green"> 456.         self.swappable = swappable</font>
<font color="black"> 457. </font>
<font color="green"> 458.     def check(self, **kwargs):</font>
<font color="red"> 459.         errors = super(ForeignObject, self).check(**kwargs)</font>
<font color="red"> 460.         errors.extend(self._check_unique_target())</font>
<font color="red"> 461.         return errors</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def _check_unique_target(self):</font>
<font color="red"> 464.         rel_is_string = isinstance(self.remote_field.model, six.string_types)</font>
<font color="red"> 465.         if rel_is_string or not self.requires_unique_target:</font>
<font color="red"> 466.             return []</font>
<font color="black"> 467. </font>
<font color="red"> 468.         try:</font>
<font color="red"> 469.             self.foreign_related_fields</font>
<font color="red"> 470.         except exceptions.FieldDoesNotExist:</font>
<font color="red"> 471.             return []</font>
<font color="black"> 472. </font>
<font color="red"> 473.         if not self.foreign_related_fields:</font>
<font color="red"> 474.             return []</font>
<font color="black"> 475. </font>
<font color="black"> 476.         unique_foreign_fields = {</font>
<font color="red"> 477.             frozenset([f.name])</font>
<font color="red"> 478.             for f in self.remote_field.model._meta.get_fields()</font>
<font color="red"> 479.             if getattr(f, 'unique', False)</font>
<font color="black"> 480.         }</font>
<font color="red"> 481.         unique_foreign_fields.update({</font>
<font color="red"> 482.             frozenset(ut)</font>
<font color="red"> 483.             for ut in self.remote_field.model._meta.unique_together</font>
<font color="black"> 484.         })</font>
<font color="red"> 485.         foreign_fields = {f.name for f in self.foreign_related_fields}</font>
<font color="red"> 486.         has_unique_constraint = any(u &lt;= foreign_fields for u in unique_foreign_fields)</font>
<font color="black"> 487. </font>
<font color="red"> 488.         if not has_unique_constraint and len(self.foreign_related_fields) &gt; 1:</font>
<font color="red"> 489.             field_combination = ', '.join(&quot;'%s'&quot; % rel_field.name</font>
<font color="red"> 490.                 for rel_field in self.foreign_related_fields)</font>
<font color="red"> 491.             model_name = self.remote_field.model.__name__</font>
<font color="black"> 492.             return [</font>
<font color="red"> 493.                 checks.Error(</font>
<font color="red"> 494.                     &quot;No subset of the fields %s on model '%s' is unique.&quot;</font>
<font color="red"> 495.                     % (field_combination, model_name),</font>
<font color="black"> 496.                     hint=(</font>
<font color="red"> 497.                         &quot;Add unique=True on any of those fields or add at &quot;</font>
<font color="black"> 498.                         &quot;least a subset of them to a unique_together constraint.&quot;</font>
<font color="black"> 499.                     ),</font>
<font color="red"> 500.                     obj=self,</font>
<font color="red"> 501.                     id='fields.E310',</font>
<font color="black"> 502.                 )</font>
<font color="black"> 503.             ]</font>
<font color="red"> 504.         elif not has_unique_constraint:</font>
<font color="red"> 505.             field_name = self.foreign_related_fields[0].name</font>
<font color="red"> 506.             model_name = self.remote_field.model.__name__</font>
<font color="black"> 507.             return [</font>
<font color="red"> 508.                 checks.Error(</font>
<font color="red"> 509.                     (&quot;'%s.%s' must set unique=True &quot;</font>
<font color="red"> 510.                      &quot;because it is referenced by a foreign key.&quot;) % (model_name, field_name),</font>
<font color="red"> 511.                     hint=None,</font>
<font color="red"> 512.                     obj=self,</font>
<font color="red"> 513.                     id='fields.E311',</font>
<font color="black"> 514.                 )</font>
<font color="black"> 515.             ]</font>
<font color="black"> 516.         else:</font>
<font color="red"> 517.             return []</font>
<font color="black"> 518. </font>
<font color="green"> 519.     def deconstruct(self):</font>
<font color="green"> 520.         name, path, args, kwargs = super(ForeignObject, self).deconstruct()</font>
<font color="green"> 521.         kwargs['on_delete'] = self.remote_field.on_delete</font>
<font color="green"> 522.         kwargs['from_fields'] = self.from_fields</font>
<font color="green"> 523.         kwargs['to_fields'] = self.to_fields</font>
<font color="black"> 524. </font>
<font color="green"> 525.         if self.remote_field.related_name is not None:</font>
<font color="red"> 526.             kwargs['related_name'] = self.remote_field.related_name</font>
<font color="green"> 527.         if self.remote_field.related_query_name is not None:</font>
<font color="red"> 528.             kwargs['related_query_name'] = self.remote_field.related_query_name</font>
<font color="green"> 529.         if self.remote_field.parent_link:</font>
<font color="red"> 530.             kwargs['parent_link'] = self.remote_field.parent_link</font>
<font color="black"> 531.         # Work out string form of &quot;to&quot;</font>
<font color="green"> 532.         if isinstance(self.remote_field.model, six.string_types):</font>
<font color="green"> 533.             kwargs['to'] = self.remote_field.model</font>
<font color="black"> 534.         else:</font>
<font color="red"> 535.             kwargs['to'] = &quot;%s.%s&quot; % (</font>
<font color="red"> 536.                 self.remote_field.model._meta.app_label,</font>
<font color="red"> 537.                 self.remote_field.model._meta.object_name,</font>
<font color="black"> 538.             )</font>
<font color="black"> 539.         # If swappable is True, then see if we're actually pointing to the target</font>
<font color="black"> 540.         # of a swap.</font>
<font color="green"> 541.         swappable_setting = self.swappable_setting</font>
<font color="green"> 542.         if swappable_setting is not None:</font>
<font color="black"> 543.             # If it's already a settings reference, error</font>
<font color="green"> 544.             if hasattr(kwargs['to'], &quot;setting_name&quot;):</font>
<font color="red"> 545.                 if kwargs['to'].setting_name != swappable_setting:</font>
<font color="red"> 546.                     raise ValueError(</font>
<font color="red"> 547.                         &quot;Cannot deconstruct a ForeignKey pointing to a model &quot;</font>
<font color="black"> 548.                         &quot;that is swapped in place of more than one model (%s and %s)&quot;</font>
<font color="red"> 549.                         % (kwargs['to'].setting_name, swappable_setting)</font>
<font color="black"> 550.                     )</font>
<font color="black"> 551.             # Set it</font>
<font color="green"> 552.             from django.db.migrations.writer import SettingsReference</font>
<font color="green"> 553.             kwargs['to'] = SettingsReference(</font>
<font color="green"> 554.                 kwargs['to'],</font>
<font color="green"> 555.                 swappable_setting,</font>
<font color="black"> 556.             )</font>
<font color="green"> 557.         return name, path, args, kwargs</font>
<font color="black"> 558. </font>
<font color="green"> 559.     def resolve_related_fields(self):</font>
<font color="green"> 560.         if len(self.from_fields) &lt; 1 or len(self.from_fields) != len(self.to_fields):</font>
<font color="red"> 561.             raise ValueError('Foreign Object from and to fields must be the same non-zero length')</font>
<font color="green"> 562.         if isinstance(self.remote_field.model, six.string_types):</font>
<font color="red"> 563.             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)</font>
<font color="green"> 564.         related_fields = []</font>
<font color="green"> 565.         for index in range(len(self.from_fields)):</font>
<font color="green"> 566.             from_field_name = self.from_fields[index]</font>
<font color="green"> 567.             to_field_name = self.to_fields[index]</font>
<font color="green"> 568.             from_field = (self if from_field_name == 'self'</font>
<font color="red"> 569.                           else self.opts.get_field(from_field_name))</font>
<font color="green"> 570.             to_field = (self.remote_field.model._meta.pk if to_field_name is None</font>
<font color="green"> 571.                         else self.remote_field.model._meta.get_field(to_field_name))</font>
<font color="green"> 572.             related_fields.append((from_field, to_field))</font>
<font color="green"> 573.         return related_fields</font>
<font color="black"> 574. </font>
<font color="green"> 575.     @property</font>
<font color="black"> 576.     def related_fields(self):</font>
<font color="green"> 577.         if not hasattr(self, '_related_fields'):</font>
<font color="green"> 578.             self._related_fields = self.resolve_related_fields()</font>
<font color="green"> 579.         return self._related_fields</font>
<font color="black"> 580. </font>
<font color="green"> 581.     @property</font>
<font color="black"> 582.     def reverse_related_fields(self):</font>
<font color="red"> 583.         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]</font>
<font color="black"> 584. </font>
<font color="green"> 585.     @property</font>
<font color="black"> 586.     def local_related_fields(self):</font>
<font color="red"> 587.         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)</font>
<font color="black"> 588. </font>
<font color="green"> 589.     @property</font>
<font color="black"> 590.     def foreign_related_fields(self):</font>
<font color="green"> 591.         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)</font>
<font color="black"> 592. </font>
<font color="green"> 593.     def get_local_related_value(self, instance):</font>
<font color="red"> 594.         return self.get_instance_value_for_fields(instance, self.local_related_fields)</font>
<font color="black"> 595. </font>
<font color="green"> 596.     def get_foreign_related_value(self, instance):</font>
<font color="red"> 597.         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)</font>
<font color="black"> 598. </font>
<font color="green"> 599.     @staticmethod</font>
<font color="black"> 600.     def get_instance_value_for_fields(instance, fields):</font>
<font color="red"> 601.         ret = []</font>
<font color="red"> 602.         opts = instance._meta</font>
<font color="red"> 603.         for field in fields:</font>
<font color="black"> 604.             # Gotcha: in some cases (like fixture loading) a model can have</font>
<font color="black"> 605.             # different values in parent_ptr_id and parent's id. So, use</font>
<font color="black"> 606.             # instance.pk (that is, parent_ptr_id) when asked for instance.id.</font>
<font color="red"> 607.             if field.primary_key:</font>
<font color="red"> 608.                 possible_parent_link = opts.get_ancestor_link(field.model)</font>
<font color="red"> 609.                 if (not possible_parent_link or</font>
<font color="red"> 610.                         possible_parent_link.primary_key or</font>
<font color="red"> 611.                         possible_parent_link.model._meta.abstract):</font>
<font color="red"> 612.                     ret.append(instance.pk)</font>
<font color="red"> 613.                     continue</font>
<font color="red"> 614.             ret.append(getattr(instance, field.attname))</font>
<font color="red"> 615.         return tuple(ret)</font>
<font color="black"> 616. </font>
<font color="green"> 617.     def get_attname_column(self):</font>
<font color="red"> 618.         attname, column = super(ForeignObject, self).get_attname_column()</font>
<font color="red"> 619.         return attname, None</font>
<font color="black"> 620. </font>
<font color="green"> 621.     def get_joining_columns(self, reverse_join=False):</font>
<font color="green"> 622.         source = self.reverse_related_fields if reverse_join else self.related_fields</font>
<font color="green"> 623.         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)</font>
<font color="black"> 624. </font>
<font color="green"> 625.     def get_reverse_joining_columns(self):</font>
<font color="red"> 626.         return self.get_joining_columns(reverse_join=True)</font>
<font color="black"> 627. </font>
<font color="green"> 628.     def get_extra_descriptor_filter(self, instance):</font>
<font color="black"> 629.         &quot;&quot;&quot;</font>
<font color="black"> 630.         Return an extra filter condition for related object fetching when</font>
<font color="black"> 631.         user does 'instance.fieldname', that is the extra filter is used in</font>
<font color="black"> 632.         the descriptor of the field.</font>
<font color="black"> 633. </font>
<font color="black"> 634.         The filter should be either a dict usable in .filter(**kwargs) call or</font>
<font color="black"> 635.         a Q-object. The condition will be ANDed together with the relation's</font>
<font color="black"> 636.         joining columns.</font>
<font color="black"> 637. </font>
<font color="black"> 638.         A parallel method is get_extra_restriction() which is used in</font>
<font color="black"> 639.         JOIN and subquery conditions.</font>
<font color="black"> 640.         &quot;&quot;&quot;</font>
<font color="red"> 641.         return {}</font>
<font color="black"> 642. </font>
<font color="green"> 643.     def get_extra_restriction(self, where_class, alias, related_alias):</font>
<font color="black"> 644.         &quot;&quot;&quot;</font>
<font color="black"> 645.         Return a pair condition used for joining and subquery pushdown. The</font>
<font color="black"> 646.         condition is something that responds to as_sql(compiler, connection)</font>
<font color="black"> 647.         method.</font>
<font color="black"> 648. </font>
<font color="black"> 649.         Note that currently referring both the 'alias' and 'related_alias'</font>
<font color="black"> 650.         will not work in some conditions, like subquery pushdown.</font>
<font color="black"> 651. </font>
<font color="black"> 652.         A parallel method is get_extra_descriptor_filter() which is used in</font>
<font color="black"> 653.         instance.fieldname related object fetching.</font>
<font color="black"> 654.         &quot;&quot;&quot;</font>
<font color="green"> 655.         return None</font>
<font color="black"> 656. </font>
<font color="green"> 657.     def get_path_info(self):</font>
<font color="black"> 658.         &quot;&quot;&quot;</font>
<font color="black"> 659.         Get path from this field to the related model.</font>
<font color="black"> 660.         &quot;&quot;&quot;</font>
<font color="green"> 661.         opts = self.remote_field.model._meta</font>
<font color="green"> 662.         from_opts = self.model._meta</font>
<font color="green"> 663.         return [PathInfo(from_opts, opts, self.foreign_related_fields, self, False, True)]</font>
<font color="black"> 664. </font>
<font color="green"> 665.     def get_reverse_path_info(self):</font>
<font color="black"> 666.         &quot;&quot;&quot;</font>
<font color="black"> 667.         Get path from the related model to this field's model.</font>
<font color="black"> 668.         &quot;&quot;&quot;</font>
<font color="red"> 669.         opts = self.model._meta</font>
<font color="red"> 670.         from_opts = self.remote_field.model._meta</font>
<font color="red"> 671.         pathinfos = [PathInfo(from_opts, opts, (opts.pk,), self.remote_field, not self.unique, False)]</font>
<font color="red"> 672.         return pathinfos</font>
<font color="black"> 673. </font>
<font color="green"> 674.     def get_lookup(self, lookup_name):</font>
<font color="green"> 675.         if lookup_name == 'in':</font>
<font color="green"> 676.             return RelatedIn</font>
<font color="red"> 677.         elif lookup_name == 'exact':</font>
<font color="red"> 678.             return RelatedExact</font>
<font color="red"> 679.         elif lookup_name == 'gt':</font>
<font color="red"> 680.             return RelatedGreaterThan</font>
<font color="red"> 681.         elif lookup_name == 'gte':</font>
<font color="red"> 682.             return RelatedGreaterThanOrEqual</font>
<font color="red"> 683.         elif lookup_name == 'lt':</font>
<font color="red"> 684.             return RelatedLessThan</font>
<font color="red"> 685.         elif lookup_name == 'lte':</font>
<font color="red"> 686.             return RelatedLessThanOrEqual</font>
<font color="red"> 687.         elif lookup_name != 'isnull':</font>
<font color="red"> 688.             raise TypeError('Related Field got invalid lookup: %s' % lookup_name)</font>
<font color="red"> 689.         return super(ForeignObject, self).get_lookup(lookup_name)</font>
<font color="black"> 690. </font>
<font color="green"> 691.     def get_transform(self, *args, **kwargs):</font>
<font color="red"> 692.         raise NotImplementedError('Relational fields do not support transforms.')</font>
<font color="black"> 693. </font>
<font color="green"> 694.     @property</font>
<font color="black"> 695.     def attnames(self):</font>
<font color="red"> 696.         return tuple(field.attname for field in self.local_related_fields)</font>
<font color="black"> 697. </font>
<font color="green"> 698.     def get_defaults(self):</font>
<font color="red"> 699.         return tuple(field.get_default() for field in self.local_related_fields)</font>
<font color="black"> 700. </font>
<font color="green"> 701.     def contribute_to_class(self, cls, name, virtual_only=False):</font>
<font color="green"> 702.         super(ForeignObject, self).contribute_to_class(cls, name, virtual_only=virtual_only)</font>
<font color="green"> 703.         setattr(cls, self.name, ForwardManyToOneDescriptor(self))</font>
<font color="black"> 704. </font>
<font color="green"> 705.     def contribute_to_related_class(self, cls, related):</font>
<font color="black"> 706.         # Internal FK's - i.e., those with a related name ending with '+' -</font>
<font color="black"> 707.         # and swapped models don't get a related descriptor.</font>
<font color="green"> 708.         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:</font>
<font color="green"> 709.             setattr(cls, related.get_accessor_name(), self.related_accessor_class(related))</font>
<font color="black"> 710.             # While 'limit_choices_to' might be a callable, simply pass</font>
<font color="black"> 711.             # it along for later - this is too early because it's still</font>
<font color="black"> 712.             # model load time.</font>
<font color="green"> 713.             if self.remote_field.limit_choices_to:</font>
<font color="red"> 714.                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)</font>
<font color="black"> 715. </font>
<font color="black"> 716. </font>
<font color="green"> 717. class ForeignKey(ForeignObject):</font>
<font color="black"> 718.     &quot;&quot;&quot;</font>
<font color="black"> 719.     Provide a many-to-one relation by adding a column to the local model</font>
<font color="black"> 720.     to hold the remote value.</font>
<font color="black"> 721. </font>
<font color="black"> 722.     By default ForeignKey will target the pk of the remote model but this</font>
<font color="black"> 723.     behavior can be changed by using the ``to_field`` argument.</font>
<font color="green"> 724.     &quot;&quot;&quot;</font>
<font color="black"> 725. </font>
<font color="black"> 726.     # Field flags</font>
<font color="green"> 727.     many_to_many = False</font>
<font color="green"> 728.     many_to_one = True</font>
<font color="green"> 729.     one_to_many = False</font>
<font color="green"> 730.     one_to_one = False</font>
<font color="black"> 731. </font>
<font color="green"> 732.     rel_class = ManyToOneRel</font>
<font color="black"> 733. </font>
<font color="green"> 734.     empty_strings_allowed = False</font>
<font color="green"> 735.     default_error_messages = {</font>
<font color="green"> 736.         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')</font>
<font color="black"> 737.     }</font>
<font color="green"> 738.     description = _(&quot;Foreign Key (type determined by related field)&quot;)</font>
<font color="black"> 739. </font>
<font color="green"> 740.     def __init__(self, to, on_delete=None, related_name=None, related_query_name=None,</font>
<font color="green"> 741.             limit_choices_to=None, parent_link=False, to_field=None,</font>
<font color="green"> 742.             db_constraint=True, **kwargs):</font>
<font color="green"> 743.         try:</font>
<font color="green"> 744.             to._meta.model_name</font>
<font color="green"> 745.         except AttributeError:</font>
<font color="green"> 746.             assert isinstance(to, six.string_types), (</font>
<font color="red"> 747.                 &quot;%s(%r) is invalid. First parameter to ForeignKey must be &quot;</font>
<font color="black"> 748.                 &quot;either a model, a model name, or the string %r&quot; % (</font>
<font color="red"> 749.                     self.__class__.__name__, to,</font>
<font color="red"> 750.                     RECURSIVE_RELATIONSHIP_CONSTANT,</font>
<font color="black"> 751.                 )</font>
<font color="black"> 752.             )</font>
<font color="black"> 753.         else:</font>
<font color="black"> 754.             # For backwards compatibility purposes, we need to *try* and set</font>
<font color="black"> 755.             # the to_field during FK construction. It won't be guaranteed to</font>
<font color="black"> 756.             # be correct until contribute_to_class is called. Refs #12190.</font>
<font color="green"> 757.             to_field = to_field or (to._meta.pk and to._meta.pk.name)</font>
<font color="black"> 758. </font>
<font color="green"> 759.         if on_delete is None:</font>
<font color="red"> 760.             warnings.warn(</font>
<font color="red"> 761.                 &quot;on_delete will be a required arg for %s in Django 2.0. &quot;</font>
<font color="black"> 762.                 &quot;Set it to models.CASCADE if you want to maintain the current default behavior. &quot;</font>
<font color="black"> 763.                 &quot;See https://docs.djangoproject.com/en/%s/ref/models/fields/&quot;</font>
<font color="black"> 764.                 &quot;#django.db.models.ForeignKey.on_delete&quot; % (</font>
<font color="red"> 765.                     self.__class__.__name__,</font>
<font color="red"> 766.                     get_docs_version(),</font>
<font color="black"> 767.                 ),</font>
<font color="red"> 768.                 RemovedInDjango20Warning, 2)</font>
<font color="red"> 769.             on_delete = CASCADE</font>
<font color="black"> 770. </font>
<font color="green"> 771.         elif not callable(on_delete):</font>
<font color="red"> 772.             warnings.warn(</font>
<font color="red"> 773.                 &quot;The signature for {0} will change in Django 2.0. &quot;</font>
<font color="black"> 774.                 &quot;Pass to_field='{1}' as a kwarg instead of as an arg.&quot;.format(</font>
<font color="red"> 775.                     self.__class__.__name__,</font>
<font color="red"> 776.                     on_delete,</font>
<font color="black"> 777.                 ),</font>
<font color="red"> 778.                 RemovedInDjango20Warning, 2)</font>
<font color="red"> 779.             on_delete, to_field = to_field, on_delete</font>
<font color="black"> 780. </font>
<font color="green"> 781.         kwargs['rel'] = self.rel_class(</font>
<font color="green"> 782.             self, to, to_field,</font>
<font color="green"> 783.             related_name=related_name,</font>
<font color="green"> 784.             related_query_name=related_query_name,</font>
<font color="green"> 785.             limit_choices_to=limit_choices_to,</font>
<font color="green"> 786.             parent_link=parent_link,</font>
<font color="green"> 787.             on_delete=on_delete,</font>
<font color="black"> 788.         )</font>
<font color="black"> 789. </font>
<font color="green"> 790.         kwargs['db_index'] = kwargs.get('db_index', True)</font>
<font color="black"> 791. </font>
<font color="green"> 792.         super(ForeignKey, self).__init__(</font>
<font color="green"> 793.             to, on_delete, from_fields=['self'], to_fields=[to_field], **kwargs)</font>
<font color="black"> 794. </font>
<font color="green"> 795.         self.db_constraint = db_constraint</font>
<font color="black"> 796. </font>
<font color="green"> 797.     def check(self, **kwargs):</font>
<font color="red"> 798.         errors = super(ForeignKey, self).check(**kwargs)</font>
<font color="red"> 799.         errors.extend(self._check_on_delete())</font>
<font color="red"> 800.         errors.extend(self._check_unique())</font>
<font color="red"> 801.         return errors</font>
<font color="black"> 802. </font>
<font color="green"> 803.     def _check_on_delete(self):</font>
<font color="red"> 804.         on_delete = getattr(self.remote_field, 'on_delete', None)</font>
<font color="red"> 805.         if on_delete == SET_NULL and not self.null:</font>
<font color="black"> 806.             return [</font>
<font color="red"> 807.                 checks.Error(</font>
<font color="red"> 808.                     'Field specifies on_delete=SET_NULL, but cannot be null.',</font>
<font color="red"> 809.                     hint='Set null=True argument on the field, or change the on_delete rule.',</font>
<font color="red"> 810.                     obj=self,</font>
<font color="red"> 811.                     id='fields.E320',</font>
<font color="black"> 812.                 )</font>
<font color="black"> 813.             ]</font>
<font color="red"> 814.         elif on_delete == SET_DEFAULT and not self.has_default():</font>
<font color="black"> 815.             return [</font>
<font color="red"> 816.                 checks.Error(</font>
<font color="red"> 817.                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',</font>
<font color="red"> 818.                     hint='Set a default value, or change the on_delete rule.',</font>
<font color="red"> 819.                     obj=self,</font>
<font color="red"> 820.                     id='fields.E321',</font>
<font color="black"> 821.                 )</font>
<font color="black"> 822.             ]</font>
<font color="black"> 823.         else:</font>
<font color="red"> 824.             return []</font>
<font color="black"> 825. </font>
<font color="green"> 826.     def _check_unique(self, **kwargs):</font>
<font color="black"> 827.         return [</font>
<font color="black"> 828.             checks.Warning(</font>
<font color="black"> 829.                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',</font>
<font color="black"> 830.                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',</font>
<font color="black"> 831.                 obj=self,</font>
<font color="black"> 832.                 id='fields.W342',</font>
<font color="black"> 833.             )</font>
<font color="red"> 834.         ] if self.unique else []</font>
<font color="black"> 835. </font>
<font color="green"> 836.     def deconstruct(self):</font>
<font color="green"> 837.         name, path, args, kwargs = super(ForeignKey, self).deconstruct()</font>
<font color="green"> 838.         del kwargs['to_fields']</font>
<font color="green"> 839.         del kwargs['from_fields']</font>
<font color="black"> 840.         # Handle the simpler arguments</font>
<font color="green"> 841.         if self.db_index:</font>
<font color="green"> 842.             del kwargs['db_index']</font>
<font color="black"> 843.         else:</font>
<font color="red"> 844.             kwargs['db_index'] = False</font>
<font color="green"> 845.         if self.db_constraint is not True:</font>
<font color="red"> 846.             kwargs['db_constraint'] = self.db_constraint</font>
<font color="black"> 847.         # Rel needs more work.</font>
<font color="green"> 848.         to_meta = getattr(self.remote_field.model, &quot;_meta&quot;, None)</font>
<font color="green"> 849.         if self.remote_field.field_name and (</font>
<font color="green"> 850.                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):</font>
<font color="green"> 851.             kwargs['to_field'] = self.remote_field.field_name</font>
<font color="green"> 852.         return name, path, args, kwargs</font>
<font color="black"> 853. </font>
<font color="green"> 854.     @property</font>
<font color="black"> 855.     def target_field(self):</font>
<font color="green"> 856.         return self.foreign_related_fields[0]</font>
<font color="black"> 857. </font>
<font color="green"> 858.     def get_reverse_path_info(self):</font>
<font color="black"> 859.         &quot;&quot;&quot;</font>
<font color="black"> 860.         Get path from the related model to this field's model.</font>
<font color="black"> 861.         &quot;&quot;&quot;</font>
<font color="red"> 862.         opts = self.model._meta</font>
<font color="red"> 863.         from_opts = self.remote_field.model._meta</font>
<font color="red"> 864.         pathinfos = [PathInfo(from_opts, opts, (opts.pk,), self.remote_field, not self.unique, False)]</font>
<font color="red"> 865.         return pathinfos</font>
<font color="black"> 866. </font>
<font color="green"> 867.     def validate(self, value, model_instance):</font>
<font color="red"> 868.         if self.remote_field.parent_link:</font>
<font color="red"> 869.             return</font>
<font color="red"> 870.         super(ForeignKey, self).validate(value, model_instance)</font>
<font color="red"> 871.         if value is None:</font>
<font color="red"> 872.             return</font>
<font color="black"> 873. </font>
<font color="red"> 874.         using = router.db_for_read(model_instance.__class__, instance=model_instance)</font>
<font color="red"> 875.         qs = self.remote_field.model._default_manager.using(using).filter(</font>
<font color="red"> 876.             **{self.remote_field.field_name: value}</font>
<font color="black"> 877.         )</font>
<font color="red"> 878.         qs = qs.complex_filter(self.get_limit_choices_to())</font>
<font color="red"> 879.         if not qs.exists():</font>
<font color="red"> 880.             raise exceptions.ValidationError(</font>
<font color="red"> 881.                 self.error_messages['invalid'],</font>
<font color="red"> 882.                 code='invalid',</font>
<font color="red"> 883.                 params={</font>
<font color="red"> 884.                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,</font>
<font color="red"> 885.                     'field': self.remote_field.field_name, 'value': value,</font>
<font color="black"> 886.                 },  # 'pk' is included for backwards compatibility</font>
<font color="black"> 887.             )</font>
<font color="black"> 888. </font>
<font color="green"> 889.     def get_attname(self):</font>
<font color="green"> 890.         return '%s_id' % self.name</font>
<font color="black"> 891. </font>
<font color="green"> 892.     def get_attname_column(self):</font>
<font color="green"> 893.         attname = self.get_attname()</font>
<font color="green"> 894.         column = self.db_column or attname</font>
<font color="green"> 895.         return attname, column</font>
<font color="black"> 896. </font>
<font color="green"> 897.     def get_default(self):</font>
<font color="black"> 898.         &quot;Here we check if the default value is an object and return the to_field if so.&quot;</font>
<font color="red"> 899.         field_default = super(ForeignKey, self).get_default()</font>
<font color="red"> 900.         if isinstance(field_default, self.remote_field.model):</font>
<font color="red"> 901.             return getattr(field_default, self.target_field.attname)</font>
<font color="red"> 902.         return field_default</font>
<font color="black"> 903. </font>
<font color="green"> 904.     def get_db_prep_save(self, value, connection):</font>
<font color="green"> 905.         if value is None or (value == '' and</font>
<font color="red"> 906.                              (not self.target_field.empty_strings_allowed or</font>
<font color="red"> 907.                               connection.features.interprets_empty_strings_as_nulls)):</font>
<font color="red"> 908.             return None</font>
<font color="black"> 909.         else:</font>
<font color="green"> 910.             return self.target_field.get_db_prep_save(value, connection=connection)</font>
<font color="black"> 911. </font>
<font color="green"> 912.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="green"> 913.         return self.target_field.get_db_prep_value(value, connection, prepared)</font>
<font color="black"> 914. </font>
<font color="green"> 915.     def value_to_string(self, obj):</font>
<font color="red"> 916.         if not obj:</font>
<font color="black"> 917.             # In required many-to-one fields with only one available choice,</font>
<font color="black"> 918.             # select that one available choice. Note: For SelectFields</font>
<font color="black"> 919.             # we have to check that the length of choices is *2*, not 1,</font>
<font color="black"> 920.             # because SelectFields always have an initial &quot;blank&quot; value.</font>
<font color="red"> 921.             if not self.blank and self.choices:</font>
<font color="red"> 922.                 choice_list = self.get_choices_default()</font>
<font color="red"> 923.                 if len(choice_list) == 2:</font>
<font color="red"> 924.                     return smart_text(choice_list[1][0])</font>
<font color="red"> 925.         return super(ForeignKey, self).value_to_string(obj)</font>
<font color="black"> 926. </font>
<font color="green"> 927.     def contribute_to_related_class(self, cls, related):</font>
<font color="green"> 928.         super(ForeignKey, self).contribute_to_related_class(cls, related)</font>
<font color="green"> 929.         if self.remote_field.field_name is None:</font>
<font color="red"> 930.             self.remote_field.field_name = cls._meta.pk.name</font>
<font color="black"> 931. </font>
<font color="green"> 932.     def formfield(self, **kwargs):</font>
<font color="red"> 933.         db = kwargs.pop('using', None)</font>
<font color="red"> 934.         if isinstance(self.remote_field.model, six.string_types):</font>
<font color="red"> 935.             raise ValueError(&quot;Cannot create form field for %r yet, because &quot;</font>
<font color="black"> 936.                              &quot;its related model %r has not been loaded yet&quot; %</font>
<font color="red"> 937.                              (self.name, self.remote_field.model))</font>
<font color="red"> 938.         defaults = {</font>
<font color="red"> 939.             'form_class': forms.ModelChoiceField,</font>
<font color="red"> 940.             'queryset': self.remote_field.model._default_manager.using(db),</font>
<font color="red"> 941.             'to_field_name': self.remote_field.field_name,</font>
<font color="black"> 942.         }</font>
<font color="red"> 943.         defaults.update(kwargs)</font>
<font color="red"> 944.         return super(ForeignKey, self).formfield(**defaults)</font>
<font color="black"> 945. </font>
<font color="green"> 946.     def db_type(self, connection):</font>
<font color="black"> 947.         # The database column type of a ForeignKey is the column type</font>
<font color="black"> 948.         # of the field to which it points. An exception is if the ForeignKey</font>
<font color="black"> 949.         # points to an AutoField/PositiveIntegerField/PositiveSmallIntegerField,</font>
<font color="black"> 950.         # in which case the column type is simply that of an IntegerField.</font>
<font color="black"> 951.         # If the database needs similar types for key fields however, the only</font>
<font color="black"> 952.         # thing we can do is making AutoField an IntegerField.</font>
<font color="green"> 953.         rel_field = self.target_field</font>
<font color="green"> 954.         if (isinstance(rel_field, AutoField) or</font>
<font color="red"> 955.                 (not connection.features.related_fields_match_type and</font>
<font color="red"> 956.                 isinstance(rel_field, (PositiveIntegerField,</font>
<font color="red"> 957.                                        PositiveSmallIntegerField)))):</font>
<font color="green"> 958.             return IntegerField().db_type(connection=connection)</font>
<font color="red"> 959.         return rel_field.db_type(connection=connection)</font>
<font color="black"> 960. </font>
<font color="green"> 961.     def db_parameters(self, connection):</font>
<font color="green"> 962.         return {&quot;type&quot;: self.db_type(connection), &quot;check&quot;: []}</font>
<font color="black"> 963. </font>
<font color="green"> 964.     def convert_empty_strings(self, value, expression, connection, context):</font>
<font color="red"> 965.         if (not value) and isinstance(value, six.string_types):</font>
<font color="red"> 966.             return None</font>
<font color="red"> 967.         return value</font>
<font color="black"> 968. </font>
<font color="green"> 969.     def get_db_converters(self, connection):</font>
<font color="green"> 970.         converters = super(ForeignKey, self).get_db_converters(connection)</font>
<font color="green"> 971.         if connection.features.interprets_empty_strings_as_nulls:</font>
<font color="red"> 972.             converters += [self.convert_empty_strings]</font>
<font color="green"> 973.         return converters</font>
<font color="black"> 974. </font>
<font color="green"> 975.     def get_col(self, alias, output_field=None):</font>
<font color="green"> 976.         return super(ForeignKey, self).get_col(alias, output_field or self.target_field)</font>
<font color="black"> 977. </font>
<font color="black"> 978. </font>
<font color="green"> 979. class OneToOneField(ForeignKey):</font>
<font color="black"> 980.     &quot;&quot;&quot;</font>
<font color="black"> 981.     A OneToOneField is essentially the same as a ForeignKey, with the exception</font>
<font color="black"> 982.     that it always carries a &quot;unique&quot; constraint with it and the reverse</font>
<font color="black"> 983.     relation always returns the object pointed to (since there will only ever</font>
<font color="black"> 984.     be one), rather than returning a list.</font>
<font color="green"> 985.     &quot;&quot;&quot;</font>
<font color="black"> 986. </font>
<font color="black"> 987.     # Field flags</font>
<font color="green"> 988.     many_to_many = False</font>
<font color="green"> 989.     many_to_one = False</font>
<font color="green"> 990.     one_to_many = False</font>
<font color="green"> 991.     one_to_one = True</font>
<font color="black"> 992. </font>
<font color="green"> 993.     related_accessor_class = ReverseOneToOneDescriptor</font>
<font color="green"> 994.     rel_class = OneToOneRel</font>
<font color="black"> 995. </font>
<font color="green"> 996.     description = _(&quot;One-to-one relationship&quot;)</font>
<font color="black"> 997. </font>
<font color="green"> 998.     def __init__(self, to, on_delete=None, to_field=None, **kwargs):</font>
<font color="red"> 999.         kwargs['unique'] = True</font>
<font color="black">1000. </font>
<font color="red">1001.         if on_delete is None:</font>
<font color="red">1002.             warnings.warn(</font>
<font color="red">1003.                 &quot;on_delete will be a required arg for %s in Django 2.0. &quot;</font>
<font color="black">1004.                 &quot;Set it to models.CASCADE if you want to maintain the current default behavior. &quot;</font>
<font color="black">1005.                 &quot;See https://docs.djangoproject.com/en/%s/ref/models/fields/&quot;</font>
<font color="black">1006.                 &quot;#django.db.models.ForeignKey.on_delete&quot; % (</font>
<font color="red">1007.                     self.__class__.__name__,</font>
<font color="red">1008.                     get_docs_version(),</font>
<font color="black">1009.                 ),</font>
<font color="red">1010.                 RemovedInDjango20Warning, 2)</font>
<font color="red">1011.             on_delete = CASCADE</font>
<font color="black">1012. </font>
<font color="red">1013.         elif not callable(on_delete):</font>
<font color="red">1014.             warnings.warn(</font>
<font color="red">1015.                 &quot;The signature for {0} will change in Django 2.0. &quot;</font>
<font color="black">1016.                 &quot;Pass to_field='{1}' as a kwarg instead of as an arg.&quot;.format(</font>
<font color="red">1017.                     self.__class__.__name__,</font>
<font color="red">1018.                     on_delete,</font>
<font color="black">1019.                 ),</font>
<font color="red">1020.                 RemovedInDjango20Warning, 2)</font>
<font color="red">1021.             to_field = on_delete</font>
<font color="red">1022.             on_delete = CASCADE  # Avoid warning in superclass</font>
<font color="black">1023. </font>
<font color="red">1024.         super(OneToOneField, self).__init__(to, on_delete, to_field=to_field, **kwargs)</font>
<font color="black">1025. </font>
<font color="green">1026.     def deconstruct(self):</font>
<font color="red">1027.         name, path, args, kwargs = super(OneToOneField, self).deconstruct()</font>
<font color="red">1028.         if &quot;unique&quot; in kwargs:</font>
<font color="red">1029.             del kwargs['unique']</font>
<font color="red">1030.         return name, path, args, kwargs</font>
<font color="black">1031. </font>
<font color="green">1032.     def formfield(self, **kwargs):</font>
<font color="red">1033.         if self.remote_field.parent_link:</font>
<font color="red">1034.             return None</font>
<font color="red">1035.         return super(OneToOneField, self).formfield(**kwargs)</font>
<font color="black">1036. </font>
<font color="green">1037.     def save_form_data(self, instance, data):</font>
<font color="red">1038.         if isinstance(data, self.remote_field.model):</font>
<font color="red">1039.             setattr(instance, self.name, data)</font>
<font color="black">1040.         else:</font>
<font color="red">1041.             setattr(instance, self.attname, data)</font>
<font color="black">1042. </font>
<font color="green">1043.     def _check_unique(self, **kwargs):</font>
<font color="black">1044.         # Override ForeignKey since check isn't applicable here.</font>
<font color="red">1045.         return []</font>
<font color="black">1046. </font>
<font color="black">1047. </font>
<font color="green">1048. def create_many_to_many_intermediary_model(field, klass):</font>
<font color="green">1049.     from django.db import models</font>
<font color="black">1050. </font>
<font color="green">1051.     def set_managed(model, related, through):</font>
<font color="green">1052.         through._meta.managed = model._meta.managed or related._meta.managed</font>
<font color="black">1053. </font>
<font color="green">1054.     to_model = resolve_relation(klass, field.remote_field.model)</font>
<font color="green">1055.     name = '%s_%s' % (klass._meta.object_name, field.name)</font>
<font color="green">1056.     lazy_related_operation(set_managed, klass, to_model, name)</font>
<font color="black">1057. </font>
<font color="green">1058.     to = make_model_tuple(to_model)[1]</font>
<font color="green">1059.     from_ = klass._meta.model_name</font>
<font color="green">1060.     if to == from_:</font>
<font color="red">1061.         to = 'to_%s' % to</font>
<font color="red">1062.         from_ = 'from_%s' % from_</font>
<font color="black">1063. </font>
<font color="green">1064.     meta = type(str('Meta'), (object,), {</font>
<font color="green">1065.         'db_table': field._get_m2m_db_table(klass._meta),</font>
<font color="green">1066.         'auto_created': klass,</font>
<font color="green">1067.         'app_label': klass._meta.app_label,</font>
<font color="green">1068.         'db_tablespace': klass._meta.db_tablespace,</font>
<font color="green">1069.         'unique_together': (from_, to),</font>
<font color="green">1070.         'verbose_name': '%(from)s-%(to)s relationship' % {'from': from_, 'to': to},</font>
<font color="green">1071.         'verbose_name_plural': '%(from)s-%(to)s relationships' % {'from': from_, 'to': to},</font>
<font color="green">1072.         'apps': field.model._meta.apps,</font>
<font color="black">1073.     })</font>
<font color="black">1074.     # Construct and return the new class.</font>
<font color="green">1075.     return type(str(name), (models.Model,), {</font>
<font color="green">1076.         'Meta': meta,</font>
<font color="green">1077.         '__module__': klass.__module__,</font>
<font color="green">1078.         from_: models.ForeignKey(</font>
<font color="green">1079.             klass,</font>
<font color="green">1080.             related_name='%s+' % name,</font>
<font color="green">1081.             db_tablespace=field.db_tablespace,</font>
<font color="green">1082.             db_constraint=field.remote_field.db_constraint,</font>
<font color="green">1083.             on_delete=CASCADE,</font>
<font color="black">1084.         ),</font>
<font color="green">1085.         to: models.ForeignKey(</font>
<font color="green">1086.             to_model,</font>
<font color="green">1087.             related_name='%s+' % name,</font>
<font color="green">1088.             db_tablespace=field.db_tablespace,</font>
<font color="green">1089.             db_constraint=field.remote_field.db_constraint,</font>
<font color="green">1090.             on_delete=CASCADE,</font>
<font color="black">1091.         )</font>
<font color="black">1092.     })</font>
<font color="black">1093. </font>
<font color="black">1094. </font>
<font color="green">1095. class ManyToManyField(RelatedField):</font>
<font color="black">1096.     &quot;&quot;&quot;</font>
<font color="black">1097.     Provide a many-to-many relation by using an intermediary model that</font>
<font color="black">1098.     holds two ForeignKey fields pointed at the two sides of the relation.</font>
<font color="black">1099. </font>
<font color="black">1100.     Unless a ``through`` model was provided, ManyToManyField will use the</font>
<font color="black">1101.     create_many_to_many_intermediary_model factory to automatically generate</font>
<font color="black">1102.     the intermediary model.</font>
<font color="green">1103.     &quot;&quot;&quot;</font>
<font color="black">1104. </font>
<font color="black">1105.     # Field flags</font>
<font color="green">1106.     many_to_many = True</font>
<font color="green">1107.     many_to_one = False</font>
<font color="green">1108.     one_to_many = False</font>
<font color="green">1109.     one_to_one = False</font>
<font color="black">1110. </font>
<font color="green">1111.     rel_class = ManyToManyRel</font>
<font color="black">1112. </font>
<font color="green">1113.     description = _(&quot;Many-to-many relationship&quot;)</font>
<font color="black">1114. </font>
<font color="green">1115.     def __init__(self, to, related_name=None, related_query_name=None,</font>
<font color="green">1116.             limit_choices_to=None, symmetrical=None, through=None,</font>
<font color="green">1117.             through_fields=None, db_constraint=True, db_table=None,</font>
<font color="green">1118.             swappable=True, **kwargs):</font>
<font color="green">1119.         try:</font>
<font color="green">1120.             to._meta</font>
<font color="green">1121.         except AttributeError:</font>
<font color="green">1122.             assert isinstance(to, six.string_types), (</font>
<font color="red">1123.                 &quot;%s(%r) is invalid. First parameter to ManyToManyField must be &quot;</font>
<font color="black">1124.                 &quot;either a model, a model name, or the string %r&quot; %</font>
<font color="red">1125.                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)</font>
<font color="black">1126.             )</font>
<font color="black">1127.             # Class names must be ASCII in Python 2.x, so we forcibly coerce it</font>
<font color="black">1128.             # here to break early if there's a problem.</font>
<font color="green">1129.             to = str(to)</font>
<font color="black">1130. </font>
<font color="green">1131.         if symmetrical is None:</font>
<font color="green">1132.             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)</font>
<font color="black">1133. </font>
<font color="green">1134.         if through is not None:</font>
<font color="red">1135.             assert db_table is None, (</font>
<font color="red">1136.                 &quot;Cannot specify a db_table if an intermediary model is used.&quot;</font>
<font color="black">1137.             )</font>
<font color="black">1138. </font>
<font color="green">1139.         kwargs['rel'] = self.rel_class(</font>
<font color="green">1140.             self, to,</font>
<font color="green">1141.             related_name=related_name,</font>
<font color="green">1142.             related_query_name=related_query_name,</font>
<font color="green">1143.             limit_choices_to=limit_choices_to,</font>
<font color="green">1144.             symmetrical=symmetrical,</font>
<font color="green">1145.             through=through,</font>
<font color="green">1146.             through_fields=through_fields,</font>
<font color="green">1147.             db_constraint=db_constraint,</font>
<font color="black">1148.         )</font>
<font color="green">1149.         self.has_null_arg = 'null' in kwargs</font>
<font color="black">1150. </font>
<font color="green">1151.         super(ManyToManyField, self).__init__(**kwargs)</font>
<font color="black">1152. </font>
<font color="green">1153.         self.db_table = db_table</font>
<font color="green">1154.         self.swappable = swappable</font>
<font color="black">1155. </font>
<font color="green">1156.     def check(self, **kwargs):</font>
<font color="red">1157.         errors = super(ManyToManyField, self).check(**kwargs)</font>
<font color="red">1158.         errors.extend(self._check_unique(**kwargs))</font>
<font color="red">1159.         errors.extend(self._check_relationship_model(**kwargs))</font>
<font color="red">1160.         errors.extend(self._check_ignored_options(**kwargs))</font>
<font color="red">1161.         return errors</font>
<font color="black">1162. </font>
<font color="green">1163.     def _check_unique(self, **kwargs):</font>
<font color="red">1164.         if self.unique:</font>
<font color="black">1165.             return [</font>
<font color="red">1166.                 checks.Error(</font>
<font color="red">1167.                     'ManyToManyFields cannot be unique.',</font>
<font color="red">1168.                     hint=None,</font>
<font color="red">1169.                     obj=self,</font>
<font color="red">1170.                     id='fields.E330',</font>
<font color="black">1171.                 )</font>
<font color="black">1172.             ]</font>
<font color="red">1173.         return []</font>
<font color="black">1174. </font>
<font color="green">1175.     def _check_ignored_options(self, **kwargs):</font>
<font color="red">1176.         warnings = []</font>
<font color="black">1177. </font>
<font color="red">1178.         if self.has_null_arg:</font>
<font color="red">1179.             warnings.append(</font>
<font color="red">1180.                 checks.Warning(</font>
<font color="red">1181.                     'null has no effect on ManyToManyField.',</font>
<font color="red">1182.                     hint=None,</font>
<font color="red">1183.                     obj=self,</font>
<font color="red">1184.                     id='fields.W340',</font>
<font color="black">1185.                 )</font>
<font color="black">1186.             )</font>
<font color="black">1187. </font>
<font color="red">1188.         if len(self._validators) &gt; 0:</font>
<font color="red">1189.             warnings.append(</font>
<font color="red">1190.                 checks.Warning(</font>
<font color="red">1191.                     'ManyToManyField does not support validators.',</font>
<font color="red">1192.                     hint=None,</font>
<font color="red">1193.                     obj=self,</font>
<font color="red">1194.                     id='fields.W341',</font>
<font color="black">1195.                 )</font>
<font color="black">1196.             )</font>
<font color="black">1197. </font>
<font color="red">1198.         return warnings</font>
<font color="black">1199. </font>
<font color="green">1200.     def _check_relationship_model(self, from_model=None, **kwargs):</font>
<font color="red">1201.         if hasattr(self.remote_field.through, '_meta'):</font>
<font color="red">1202.             qualified_model_name = &quot;%s.%s&quot; % (</font>
<font color="red">1203.                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)</font>
<font color="black">1204.         else:</font>
<font color="red">1205.             qualified_model_name = self.remote_field.through</font>
<font color="black">1206. </font>
<font color="red">1207.         errors = []</font>
<font color="black">1208. </font>
<font color="red">1209.         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):</font>
<font color="black">1210.             # The relationship model is not installed.</font>
<font color="red">1211.             errors.append(</font>
<font color="red">1212.                 checks.Error(</font>
<font color="red">1213.                     (&quot;Field specifies a many-to-many relation through model &quot;</font>
<font color="black">1214.                      &quot;'%s', which has not been installed.&quot;) %</font>
<font color="red">1215.                     qualified_model_name,</font>
<font color="red">1216.                     hint=None,</font>
<font color="red">1217.                     obj=self,</font>
<font color="red">1218.                     id='fields.E331',</font>
<font color="black">1219.                 )</font>
<font color="black">1220.             )</font>
<font color="black">1221. </font>
<font color="black">1222.         else:</font>
<font color="black">1223. </font>
<font color="red">1224.             assert from_model is not None, (</font>
<font color="red">1225.                 &quot;ManyToManyField with intermediate &quot;</font>
<font color="black">1226.                 &quot;tables cannot be checked if you don't pass the model &quot;</font>
<font color="black">1227.                 &quot;where the field is attached to.&quot;</font>
<font color="black">1228.             )</font>
<font color="black">1229. </font>
<font color="black">1230.             # Set some useful local variables</font>
<font color="red">1231.             to_model = resolve_relation(from_model, self.remote_field.model)</font>
<font color="red">1232.             from_model_name = from_model._meta.object_name</font>
<font color="red">1233.             if isinstance(to_model, six.string_types):</font>
<font color="red">1234.                 to_model_name = to_model</font>
<font color="black">1235.             else:</font>
<font color="red">1236.                 to_model_name = to_model._meta.object_name</font>
<font color="red">1237.             relationship_model_name = self.remote_field.through._meta.object_name</font>
<font color="red">1238.             self_referential = from_model == to_model</font>
<font color="black">1239. </font>
<font color="black">1240.             # Check symmetrical attribute.</font>
<font color="red">1241.             if (self_referential and self.remote_field.symmetrical and</font>
<font color="red">1242.                     not self.remote_field.through._meta.auto_created):</font>
<font color="red">1243.                 errors.append(</font>
<font color="red">1244.                     checks.Error(</font>
<font color="red">1245.                         'Many-to-many fields with intermediate tables must not be symmetrical.',</font>
<font color="red">1246.                         hint=None,</font>
<font color="red">1247.                         obj=self,</font>
<font color="red">1248.                         id='fields.E332',</font>
<font color="black">1249.                     )</font>
<font color="black">1250.                 )</font>
<font color="black">1251. </font>
<font color="black">1252.             # Count foreign keys in intermediate model</font>
<font color="red">1253.             if self_referential:</font>
<font color="red">1254.                 seen_self = sum(from_model == getattr(field.remote_field, 'model', None)</font>
<font color="red">1255.                     for field in self.remote_field.through._meta.fields)</font>
<font color="black">1256. </font>
<font color="red">1257.                 if seen_self &gt; 2 and not self.remote_field.through_fields:</font>
<font color="red">1258.                     errors.append(</font>
<font color="red">1259.                         checks.Error(</font>
<font color="red">1260.                             (&quot;The model is used as an intermediate model by &quot;</font>
<font color="black">1261.                              &quot;'%s', but it has more than two foreign keys &quot;</font>
<font color="black">1262.                              &quot;to '%s', which is ambiguous. You must specify &quot;</font>
<font color="black">1263.                              &quot;which two foreign keys Django should use via the &quot;</font>
<font color="red">1264.                              &quot;through_fields keyword argument.&quot;) % (self, from_model_name),</font>
<font color="red">1265.                             hint=(&quot;Use through_fields to specify which two &quot;</font>
<font color="black">1266.                                   &quot;foreign keys Django should use.&quot;),</font>
<font color="red">1267.                             obj=self.remote_field.through,</font>
<font color="red">1268.                             id='fields.E333',</font>
<font color="black">1269.                         )</font>
<font color="black">1270.                     )</font>
<font color="black">1271. </font>
<font color="black">1272.             else:</font>
<font color="black">1273.                 # Count foreign keys in relationship model</font>
<font color="red">1274.                 seen_from = sum(from_model == getattr(field.remote_field, 'model', None)</font>
<font color="red">1275.                     for field in self.remote_field.through._meta.fields)</font>
<font color="red">1276.                 seen_to = sum(to_model == getattr(field.remote_field, 'model', None)</font>
<font color="red">1277.                     for field in self.remote_field.through._meta.fields)</font>
<font color="black">1278. </font>
<font color="red">1279.                 if seen_from &gt; 1 and not self.remote_field.through_fields:</font>
<font color="red">1280.                     errors.append(</font>
<font color="red">1281.                         checks.Error(</font>
<font color="red">1282.                             (&quot;The model is used as an intermediate model by &quot;</font>
<font color="black">1283.                              &quot;'%s', but it has more than one foreign key &quot;</font>
<font color="black">1284.                              &quot;from '%s', which is ambiguous. You must specify &quot;</font>
<font color="black">1285.                              &quot;which foreign key Django should use via the &quot;</font>
<font color="red">1286.                              &quot;through_fields keyword argument.&quot;) % (self, from_model_name),</font>
<font color="red">1287.                             hint=('If you want to create a recursive relationship, '</font>
<font color="black">1288.                                   'use ForeignKey(&quot;self&quot;, symmetrical=False, '</font>
<font color="red">1289.                                   'through=&quot;%s&quot;).') % relationship_model_name,</font>
<font color="red">1290.                             obj=self,</font>
<font color="red">1291.                             id='fields.E334',</font>
<font color="black">1292.                         )</font>
<font color="black">1293.                     )</font>
<font color="black">1294. </font>
<font color="red">1295.                 if seen_to &gt; 1 and not self.remote_field.through_fields:</font>
<font color="red">1296.                     errors.append(</font>
<font color="red">1297.                         checks.Error(</font>
<font color="red">1298.                             (&quot;The model is used as an intermediate model by &quot;</font>
<font color="black">1299.                              &quot;'%s', but it has more than one foreign key &quot;</font>
<font color="black">1300.                              &quot;to '%s', which is ambiguous. You must specify &quot;</font>
<font color="black">1301.                              &quot;which foreign key Django should use via the &quot;</font>
<font color="red">1302.                              &quot;through_fields keyword argument.&quot;) % (self, to_model_name),</font>
<font color="red">1303.                             hint=('If you want to create a recursive '</font>
<font color="black">1304.                                   'relationship, use ForeignKey(&quot;self&quot;, '</font>
<font color="red">1305.                                   'symmetrical=False, through=&quot;%s&quot;).') % relationship_model_name,</font>
<font color="red">1306.                             obj=self,</font>
<font color="red">1307.                             id='fields.E335',</font>
<font color="black">1308.                         )</font>
<font color="black">1309.                     )</font>
<font color="black">1310. </font>
<font color="red">1311.                 if seen_from == 0 or seen_to == 0:</font>
<font color="red">1312.                     errors.append(</font>
<font color="red">1313.                         checks.Error(</font>
<font color="red">1314.                             (&quot;The model is used as an intermediate model by &quot;</font>
<font color="black">1315.                              &quot;'%s', but it does not have a foreign key to '%s' or '%s'.&quot;) % (</font>
<font color="red">1316.                                 self, from_model_name, to_model_name</font>
<font color="black">1317.                             ),</font>
<font color="red">1318.                             hint=None,</font>
<font color="red">1319.                             obj=self.remote_field.through,</font>
<font color="red">1320.                             id='fields.E336',</font>
<font color="black">1321.                         )</font>
<font color="black">1322.                     )</font>
<font color="black">1323. </font>
<font color="black">1324.         # Validate `through_fields`.</font>
<font color="red">1325.         if self.remote_field.through_fields is not None:</font>
<font color="black">1326.             # Validate that we're given an iterable of at least two items</font>
<font color="black">1327.             # and that none of them is &quot;falsy&quot;.</font>
<font color="red">1328.             if not (len(self.remote_field.through_fields) &gt;= 2 and</font>
<font color="red">1329.                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):</font>
<font color="red">1330.                 errors.append(</font>
<font color="red">1331.                     checks.Error(</font>
<font color="red">1332.                         (&quot;Field specifies 'through_fields' but does not &quot;</font>
<font color="black">1333.                          &quot;provide the names of the two link fields that should be &quot;</font>
<font color="black">1334.                          &quot;used for the relation through model &quot;</font>
<font color="red">1335.                          &quot;'%s'.&quot;) % qualified_model_name,</font>
<font color="red">1336.                         hint=(&quot;Make sure you specify 'through_fields' as &quot;</font>
<font color="black">1337.                               &quot;through_fields=('field1', 'field2')&quot;),</font>
<font color="red">1338.                         obj=self,</font>
<font color="red">1339.                         id='fields.E337',</font>
<font color="black">1340.                     )</font>
<font color="black">1341.                 )</font>
<font color="black">1342. </font>
<font color="black">1343.             # Validate the given through fields -- they should be actual</font>
<font color="black">1344.             # fields on the through model, and also be foreign keys to the</font>
<font color="black">1345.             # expected models.</font>
<font color="black">1346.             else:</font>
<font color="red">1347.                 assert from_model is not None, (</font>
<font color="red">1348.                     &quot;ManyToManyField with intermediate &quot;</font>
<font color="black">1349.                     &quot;tables cannot be checked if you don't pass the model &quot;</font>
<font color="black">1350.                     &quot;where the field is attached to.&quot;</font>
<font color="black">1351.                 )</font>
<font color="black">1352. </font>
<font color="red">1353.                 source, through, target = from_model, self.remote_field.through, self.remote_field.model</font>
<font color="red">1354.                 source_field_name, target_field_name = self.remote_field.through_fields[:2]</font>
<font color="black">1355. </font>
<font color="red">1356.                 for field_name, related_model in ((source_field_name, source),</font>
<font color="red">1357.                                                   (target_field_name, target)):</font>
<font color="black">1358. </font>
<font color="red">1359.                     possible_field_names = []</font>
<font color="red">1360.                     for f in through._meta.fields:</font>
<font color="red">1361.                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:</font>
<font color="red">1362.                             possible_field_names.append(f.name)</font>
<font color="red">1363.                     if possible_field_names:</font>
<font color="red">1364.                         hint = (&quot;Did you mean one of the following foreign &quot;</font>
<font color="red">1365.                                 &quot;keys to '%s': %s?&quot;) % (related_model._meta.object_name,</font>
<font color="red">1366.                                                         ', '.join(possible_field_names))</font>
<font color="black">1367.                     else:</font>
<font color="red">1368.                         hint = None</font>
<font color="black">1369. </font>
<font color="red">1370.                     try:</font>
<font color="red">1371.                         field = through._meta.get_field(field_name)</font>
<font color="red">1372.                     except exceptions.FieldDoesNotExist:</font>
<font color="red">1373.                         errors.append(</font>
<font color="red">1374.                             checks.Error(</font>
<font color="red">1375.                                 (&quot;The intermediary model '%s' has no field '%s'.&quot;) % (</font>
<font color="red">1376.                                     qualified_model_name, field_name),</font>
<font color="red">1377.                                 hint=hint,</font>
<font color="red">1378.                                 obj=self,</font>
<font color="red">1379.                                 id='fields.E338',</font>
<font color="black">1380.                             )</font>
<font color="black">1381.                         )</font>
<font color="black">1382.                     else:</font>
<font color="red">1383.                         if not (hasattr(field, 'remote_field') and</font>
<font color="red">1384.                                 getattr(field.remote_field, 'model', None) == related_model):</font>
<font color="red">1385.                             errors.append(</font>
<font color="red">1386.                                 checks.Error(</font>
<font color="red">1387.                                     &quot;'%s.%s' is not a foreign key to '%s'.&quot; % (</font>
<font color="red">1388.                                         through._meta.object_name, field_name,</font>
<font color="red">1389.                                         related_model._meta.object_name),</font>
<font color="red">1390.                                     hint=hint,</font>
<font color="red">1391.                                     obj=self,</font>
<font color="red">1392.                                     id='fields.E339',</font>
<font color="black">1393.                                 )</font>
<font color="black">1394.                             )</font>
<font color="black">1395. </font>
<font color="red">1396.         return errors</font>
<font color="black">1397. </font>
<font color="green">1398.     def deconstruct(self):</font>
<font color="green">1399.         name, path, args, kwargs = super(ManyToManyField, self).deconstruct()</font>
<font color="black">1400.         # Handle the simpler arguments.</font>
<font color="green">1401.         if self.db_table is not None:</font>
<font color="red">1402.             kwargs['db_table'] = self.db_table</font>
<font color="green">1403.         if self.remote_field.db_constraint is not True:</font>
<font color="red">1404.             kwargs['db_constraint'] = self.remote_field.db_constraint</font>
<font color="green">1405.         if self.remote_field.related_name is not None:</font>
<font color="green">1406.             kwargs['related_name'] = self.remote_field.related_name</font>
<font color="green">1407.         if self.remote_field.related_query_name is not None:</font>
<font color="green">1408.             kwargs['related_query_name'] = self.remote_field.related_query_name</font>
<font color="black">1409.         # Rel needs more work.</font>
<font color="green">1410.         if isinstance(self.remote_field.model, six.string_types):</font>
<font color="green">1411.             kwargs['to'] = self.remote_field.model</font>
<font color="black">1412.         else:</font>
<font color="red">1413.             kwargs['to'] = &quot;%s.%s&quot; % (</font>
<font color="red">1414.                 self.remote_field.model._meta.app_label,</font>
<font color="red">1415.                 self.remote_field.model._meta.object_name,</font>
<font color="black">1416.             )</font>
<font color="green">1417.         if getattr(self.remote_field, 'through', None) is not None:</font>
<font color="red">1418.             if isinstance(self.remote_field.through, six.string_types):</font>
<font color="red">1419.                 kwargs['through'] = self.remote_field.through</font>
<font color="red">1420.             elif not self.remote_field.through._meta.auto_created:</font>
<font color="red">1421.                 kwargs['through'] = &quot;%s.%s&quot; % (</font>
<font color="red">1422.                     self.remote_field.through._meta.app_label,</font>
<font color="red">1423.                     self.remote_field.through._meta.object_name,</font>
<font color="black">1424.                 )</font>
<font color="black">1425.         # If swappable is True, then see if we're actually pointing to the target</font>
<font color="black">1426.         # of a swap.</font>
<font color="green">1427.         swappable_setting = self.swappable_setting</font>
<font color="green">1428.         if swappable_setting is not None:</font>
<font color="black">1429.             # If it's already a settings reference, error.</font>
<font color="red">1430.             if hasattr(kwargs['to'], &quot;setting_name&quot;):</font>
<font color="red">1431.                 if kwargs['to'].setting_name != swappable_setting:</font>
<font color="red">1432.                     raise ValueError(</font>
<font color="red">1433.                         &quot;Cannot deconstruct a ManyToManyField pointing to a &quot;</font>
<font color="black">1434.                         &quot;model that is swapped in place of more than one model &quot;</font>
<font color="red">1435.                         &quot;(%s and %s)&quot; % (kwargs['to'].setting_name, swappable_setting)</font>
<font color="black">1436.                     )</font>
<font color="black">1437. </font>
<font color="red">1438.             from django.db.migrations.writer import SettingsReference</font>
<font color="red">1439.             kwargs['to'] = SettingsReference(</font>
<font color="red">1440.                 kwargs['to'],</font>
<font color="red">1441.                 swappable_setting,</font>
<font color="black">1442.             )</font>
<font color="green">1443.         return name, path, args, kwargs</font>
<font color="black">1444. </font>
<font color="green">1445.     def _get_path_info(self, direct=False):</font>
<font color="black">1446.         &quot;&quot;&quot;</font>
<font color="black">1447.         Called by both direct and indirect m2m traversal.</font>
<font color="black">1448.         &quot;&quot;&quot;</font>
<font color="red">1449.         pathinfos = []</font>
<font color="red">1450.         int_model = self.remote_field.through</font>
<font color="red">1451.         linkfield1 = int_model._meta.get_field(self.m2m_field_name())</font>
<font color="red">1452.         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())</font>
<font color="red">1453.         if direct:</font>
<font color="red">1454.             join1infos = linkfield1.get_reverse_path_info()</font>
<font color="red">1455.             join2infos = linkfield2.get_path_info()</font>
<font color="black">1456.         else:</font>
<font color="red">1457.             join1infos = linkfield2.get_reverse_path_info()</font>
<font color="red">1458.             join2infos = linkfield1.get_path_info()</font>
<font color="red">1459.         pathinfos.extend(join1infos)</font>
<font color="red">1460.         pathinfos.extend(join2infos)</font>
<font color="red">1461.         return pathinfos</font>
<font color="black">1462. </font>
<font color="green">1463.     def get_path_info(self):</font>
<font color="red">1464.         return self._get_path_info(direct=True)</font>
<font color="black">1465. </font>
<font color="green">1466.     def get_reverse_path_info(self):</font>
<font color="red">1467.         return self._get_path_info(direct=False)</font>
<font color="black">1468. </font>
<font color="green">1469.     def get_choices_default(self):</font>
<font color="red">1470.         return Field.get_choices(self, include_blank=False)</font>
<font color="black">1471. </font>
<font color="green">1472.     def _get_m2m_db_table(self, opts):</font>
<font color="black">1473.         &quot;&quot;&quot;</font>
<font color="black">1474.         Function that can be curried to provide the m2m table name for this</font>
<font color="black">1475.         relation.</font>
<font color="black">1476.         &quot;&quot;&quot;</font>
<font color="green">1477.         if self.remote_field.through is not None:</font>
<font color="red">1478.             return self.remote_field.through._meta.db_table</font>
<font color="green">1479.         elif self.db_table:</font>
<font color="red">1480.             return self.db_table</font>
<font color="black">1481.         else:</font>
<font color="green">1482.             return utils.truncate_name('%s_%s' % (opts.db_table, self.name),</font>
<font color="green">1483.                                       connection.ops.max_name_length())</font>
<font color="black">1484. </font>
<font color="green">1485.     def _get_m2m_attr(self, related, attr):</font>
<font color="black">1486.         &quot;&quot;&quot;</font>
<font color="black">1487.         Function that can be curried to provide the source accessor or DB</font>
<font color="black">1488.         column name for the m2m table.</font>
<font color="black">1489.         &quot;&quot;&quot;</font>
<font color="red">1490.         cache_attr = '_m2m_%s_cache' % attr</font>
<font color="red">1491.         if hasattr(self, cache_attr):</font>
<font color="red">1492.             return getattr(self, cache_attr)</font>
<font color="red">1493.         if self.remote_field.through_fields is not None:</font>
<font color="red">1494.             link_field_name = self.remote_field.through_fields[0]</font>
<font color="black">1495.         else:</font>
<font color="red">1496.             link_field_name = None</font>
<font color="red">1497.         for f in self.remote_field.through._meta.fields:</font>
<font color="red">1498.             if (f.is_relation and f.remote_field.model == related.related_model and</font>
<font color="red">1499.                     (link_field_name is None or link_field_name == f.name)):</font>
<font color="red">1500.                 setattr(self, cache_attr, getattr(f, attr))</font>
<font color="red">1501.                 return getattr(self, cache_attr)</font>
<font color="black">1502. </font>
<font color="green">1503.     def _get_m2m_reverse_attr(self, related, attr):</font>
<font color="black">1504.         &quot;&quot;&quot;</font>
<font color="black">1505.         Function that can be curried to provide the related accessor or DB</font>
<font color="black">1506.         column name for the m2m table.</font>
<font color="black">1507.         &quot;&quot;&quot;</font>
<font color="red">1508.         cache_attr = '_m2m_reverse_%s_cache' % attr</font>
<font color="red">1509.         if hasattr(self, cache_attr):</font>
<font color="red">1510.             return getattr(self, cache_attr)</font>
<font color="red">1511.         found = False</font>
<font color="red">1512.         if self.remote_field.through_fields is not None:</font>
<font color="red">1513.             link_field_name = self.remote_field.through_fields[1]</font>
<font color="black">1514.         else:</font>
<font color="red">1515.             link_field_name = None</font>
<font color="red">1516.         for f in self.remote_field.through._meta.fields:</font>
<font color="red">1517.             if f.is_relation and f.remote_field.model == related.model:</font>
<font color="red">1518.                 if link_field_name is None and related.related_model == related.model:</font>
<font color="black">1519.                     # If this is an m2m-intermediate to self,</font>
<font color="black">1520.                     # the first foreign key you find will be</font>
<font color="black">1521.                     # the source column. Keep searching for</font>
<font color="black">1522.                     # the second foreign key.</font>
<font color="red">1523.                     if found:</font>
<font color="red">1524.                         setattr(self, cache_attr, getattr(f, attr))</font>
<font color="red">1525.                         break</font>
<font color="black">1526.                     else:</font>
<font color="red">1527.                         found = True</font>
<font color="red">1528.                 elif link_field_name is None or link_field_name == f.name:</font>
<font color="red">1529.                     setattr(self, cache_attr, getattr(f, attr))</font>
<font color="red">1530.                     break</font>
<font color="red">1531.         return getattr(self, cache_attr)</font>
<font color="black">1532. </font>
<font color="green">1533.     def value_to_string(self, obj):</font>
<font color="red">1534.         data = ''</font>
<font color="red">1535.         if obj:</font>
<font color="red">1536.             qs = getattr(obj, self.name).all()</font>
<font color="red">1537.             data = [instance._get_pk_val() for instance in qs]</font>
<font color="black">1538.         else:</font>
<font color="black">1539.             # In required many-to-many fields with only one available choice,</font>
<font color="black">1540.             # select that one available choice.</font>
<font color="red">1541.             if not self.blank:</font>
<font color="red">1542.                 choices_list = self.get_choices_default()</font>
<font color="red">1543.                 if len(choices_list) == 1:</font>
<font color="red">1544.                     data = [choices_list[0][0]]</font>
<font color="red">1545.         return smart_text(data)</font>
<font color="black">1546. </font>
<font color="green">1547.     def contribute_to_class(self, cls, name, **kwargs):</font>
<font color="black">1548.         # To support multiple relations to self, it's useful to have a non-None</font>
<font color="black">1549.         # related name on symmetrical relations for internal reasons. The</font>
<font color="black">1550.         # concept doesn't make a lot of sense externally (&quot;you want me to</font>
<font color="black">1551.         # specify *what* on my non-reversible relation?!&quot;), so we set it up</font>
<font color="black">1552.         # automatically. The funky name reduces the chance of an accidental</font>
<font color="black">1553.         # clash.</font>
<font color="green">1554.         if self.remote_field.symmetrical and (</font>
<font color="red">1555.                 self.remote_field.model == &quot;self&quot; or self.remote_field.model == cls._meta.object_name):</font>
<font color="red">1556.             self.remote_field.related_name = &quot;%s_rel_+&quot; % name</font>
<font color="green">1557.         elif self.remote_field.is_hidden():</font>
<font color="black">1558.             # If the backwards relation is disabled, replace the original</font>
<font color="black">1559.             # related_name with one generated from the m2m field name. Django</font>
<font color="black">1560.             # still uses backwards relations internally and we need to avoid</font>
<font color="black">1561.             # clashes between multiple m2m fields with related_name == '+'.</font>
<font color="red">1562.             self.remote_field.related_name = &quot;_%s_%s_+&quot; % (cls.__name__.lower(), name)</font>
<font color="black">1563. </font>
<font color="green">1564.         super(ManyToManyField, self).contribute_to_class(cls, name, **kwargs)</font>
<font color="black">1565. </font>
<font color="black">1566.         # The intermediate m2m model is not auto created if:</font>
<font color="black">1567.         #  1) There is a manually specified intermediate, or</font>
<font color="black">1568.         #  2) The class owning the m2m field is abstract.</font>
<font color="black">1569.         #  3) The class owning the m2m field has been swapped out.</font>
<font color="green">1570.         if not cls._meta.abstract:</font>
<font color="green">1571.             if self.remote_field.through:</font>
<font color="red">1572.                 def resolve_through_model(_, model, field):</font>
<font color="red">1573.                     field.remote_field.through = model</font>
<font color="red">1574.                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)</font>
<font color="green">1575.             elif not cls._meta.swapped:</font>
<font color="green">1576.                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)</font>
<font color="black">1577. </font>
<font color="black">1578.         # Add the descriptor for the m2m relation.</font>
<font color="green">1579.         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))</font>
<font color="black">1580. </font>
<font color="black">1581.         # Set up the accessor for the m2m table name for the relation.</font>
<font color="green">1582.         self.m2m_db_table = curry(self._get_m2m_db_table, cls._meta)</font>
<font color="black">1583. </font>
<font color="green">1584.     def contribute_to_related_class(self, cls, related):</font>
<font color="black">1585.         # Internal M2Ms (i.e., those with a related name ending with '+')</font>
<font color="black">1586.         # and swapped models don't get a related descriptor.</font>
<font color="green">1587.         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:</font>
<font color="green">1588.             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))</font>
<font color="black">1589. </font>
<font color="black">1590.         # Set up the accessors for the column names on the m2m table.</font>
<font color="green">1591.         self.m2m_column_name = curry(self._get_m2m_attr, related, 'column')</font>
<font color="green">1592.         self.m2m_reverse_name = curry(self._get_m2m_reverse_attr, related, 'column')</font>
<font color="black">1593. </font>
<font color="green">1594.         self.m2m_field_name = curry(self._get_m2m_attr, related, 'name')</font>
<font color="green">1595.         self.m2m_reverse_field_name = curry(self._get_m2m_reverse_attr, related, 'name')</font>
<font color="black">1596. </font>
<font color="green">1597.         get_m2m_rel = curry(self._get_m2m_attr, related, 'remote_field')</font>
<font color="green">1598.         self.m2m_target_field_name = lambda: get_m2m_rel().field_name</font>
<font color="green">1599.         get_m2m_reverse_rel = curry(self._get_m2m_reverse_attr, related, 'remote_field')</font>
<font color="green">1600.         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name</font>
<font color="black">1601. </font>
<font color="green">1602.     def set_attributes_from_rel(self):</font>
<font color="green">1603.         pass</font>
<font color="black">1604. </font>
<font color="green">1605.     def value_from_object(self, obj):</font>
<font color="black">1606.         &quot;&quot;&quot;</font>
<font color="black">1607.         Return the value of this field in the given model instance.</font>
<font color="black">1608.         &quot;&quot;&quot;</font>
<font color="red">1609.         return getattr(obj, self.attname).all()</font>
<font color="black">1610. </font>
<font color="green">1611.     def save_form_data(self, instance, data):</font>
<font color="red">1612.         setattr(instance, self.attname, data)</font>
<font color="black">1613. </font>
<font color="green">1614.     def formfield(self, **kwargs):</font>
<font color="green">1615.         db = kwargs.pop('using', None)</font>
<font color="green">1616.         defaults = {</font>
<font color="green">1617.             'form_class': forms.ModelMultipleChoiceField,</font>
<font color="green">1618.             'queryset': self.remote_field.model._default_manager.using(db),</font>
<font color="black">1619.         }</font>
<font color="green">1620.         defaults.update(kwargs)</font>
<font color="black">1621.         # If initial is passed in, it's a list of related objects, but the</font>
<font color="black">1622.         # MultipleChoiceField takes a list of IDs.</font>
<font color="green">1623.         if defaults.get('initial') is not None:</font>
<font color="red">1624.             initial = defaults['initial']</font>
<font color="red">1625.             if callable(initial):</font>
<font color="red">1626.                 initial = initial()</font>
<font color="red">1627.             defaults['initial'] = [i._get_pk_val() for i in initial]</font>
<font color="green">1628.         return super(ManyToManyField, self).formfield(**defaults)</font>
<font color="black">1629. </font>
<font color="green">1630.     def db_type(self, connection):</font>
<font color="black">1631.         # A ManyToManyField is not represented by a single column,</font>
<font color="black">1632.         # so return None.</font>
<font color="red">1633.         return None</font>
<font color="black">1634. </font>
<font color="green">1635.     def db_parameters(self, connection):</font>
<font color="red">1636.         return {&quot;type&quot;: None, &quot;check&quot;: None}</font>
</pre>

