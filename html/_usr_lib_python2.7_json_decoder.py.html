source file: <b>/usr/lib/python2.7/json/decoder.py</b><br>


file stats: <b>236 lines, 53 executed: 22.5% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Implementation of JSONDecoder</font>
<font color="green">   2. &quot;&quot;&quot;</font>
<font color="green">   3. import re</font>
<font color="green">   4. import sys</font>
<font color="green">   5. import struct</font>
<font color="black">   6. </font>
<font color="green">   7. from json import scanner</font>
<font color="green">   8. try:</font>
<font color="green">   9.     from _json import scanstring as c_scanstring</font>
<font color="red">  10. except ImportError:</font>
<font color="red">  11.     c_scanstring = None</font>
<font color="black">  12. </font>
<font color="green">  13. __all__ = ['JSONDecoder']</font>
<font color="black">  14. </font>
<font color="green">  15. FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL</font>
<font color="black">  16. </font>
<font color="green">  17. def _floatconstants():</font>
<font color="green">  18.     _BYTES = '7FF80000000000007FF0000000000000'.decode('hex')</font>
<font color="green">  19.     if sys.byteorder != 'big':</font>
<font color="green">  20.         _BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]</font>
<font color="green">  21.     nan, inf = struct.unpack('dd', _BYTES)</font>
<font color="green">  22.     return nan, inf, -inf</font>
<font color="black">  23. </font>
<font color="green">  24. NaN, PosInf, NegInf = _floatconstants()</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. def linecol(doc, pos):</font>
<font color="red">  28.     lineno = doc.count('\n', 0, pos) + 1</font>
<font color="red">  29.     if lineno == 1:</font>
<font color="red">  30.         colno = pos + 1</font>
<font color="black">  31.     else:</font>
<font color="red">  32.         colno = pos - doc.rindex('\n', 0, pos)</font>
<font color="red">  33.     return lineno, colno</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. def errmsg(msg, doc, pos, end=None):</font>
<font color="black">  37.     # Note that this function is called from _json</font>
<font color="red">  38.     lineno, colno = linecol(doc, pos)</font>
<font color="red">  39.     if end is None:</font>
<font color="red">  40.         fmt = '{0}: line {1} column {2} (char {3})'</font>
<font color="red">  41.         return fmt.format(msg, lineno, colno, pos)</font>
<font color="black">  42.         #fmt = '%s: line %d column %d (char %d)'</font>
<font color="black">  43.         #return fmt % (msg, lineno, colno, pos)</font>
<font color="red">  44.     endlineno, endcolno = linecol(doc, end)</font>
<font color="red">  45.     fmt = '{0}: line {1} column {2} - line {3} column {4} (char {5} - {6})'</font>
<font color="red">  46.     return fmt.format(msg, lineno, colno, endlineno, endcolno, pos, end)</font>
<font color="black">  47.     #fmt = '%s: line %d column %d - line %d column %d (char %d - %d)'</font>
<font color="black">  48.     #return fmt % (msg, lineno, colno, endlineno, endcolno, pos, end)</font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="green">  51. _CONSTANTS = {</font>
<font color="green">  52.     '-Infinity': NegInf,</font>
<font color="green">  53.     'Infinity': PosInf,</font>
<font color="green">  54.     'NaN': NaN,</font>
<font color="black">  55. }</font>
<font color="black">  56. </font>
<font color="green">  57. STRINGCHUNK = re.compile(r'(.*?)([&quot;\\\x00-\x1f])', FLAGS)</font>
<font color="green">  58. BACKSLASH = {</font>
<font color="green">  59.     '&quot;': u'&quot;', '\\': u'\\', '/': u'/',</font>
<font color="green">  60.     'b': u'\b', 'f': u'\f', 'n': u'\n', 'r': u'\r', 't': u'\t',</font>
<font color="black">  61. }</font>
<font color="black">  62. </font>
<font color="green">  63. DEFAULT_ENCODING = &quot;utf-8&quot;</font>
<font color="black">  64. </font>
<font color="green">  65. def _decode_uXXXX(s, pos):</font>
<font color="red">  66.     esc = s[pos + 1:pos + 5]</font>
<font color="red">  67.     if len(esc) == 4 and esc[1] not in 'xX':</font>
<font color="red">  68.         try:</font>
<font color="red">  69.             return int(esc, 16)</font>
<font color="red">  70.         except ValueError:</font>
<font color="red">  71.             pass</font>
<font color="red">  72.     msg = &quot;Invalid \\uXXXX escape&quot;</font>
<font color="red">  73.     raise ValueError(errmsg(msg, s, pos))</font>
<font color="black">  74. </font>
<font color="green">  75. def py_scanstring(s, end, encoding=None, strict=True,</font>
<font color="green">  76.         _b=BACKSLASH, _m=STRINGCHUNK.match):</font>
<font color="black">  77.     &quot;&quot;&quot;Scan the string s for a JSON string. End is the index of the</font>
<font color="black">  78.     character in s after the quote that started the JSON string.</font>
<font color="black">  79.     Unescapes all valid JSON string escape sequences and raises ValueError</font>
<font color="black">  80.     on attempt to decode an invalid string. If strict is False then literal</font>
<font color="black">  81.     control characters are allowed in the string.</font>
<font color="black">  82. </font>
<font color="black">  83.     Returns a tuple of the decoded string and the index of the character in s</font>
<font color="black">  84.     after the end quote.&quot;&quot;&quot;</font>
<font color="red">  85.     if encoding is None:</font>
<font color="red">  86.         encoding = DEFAULT_ENCODING</font>
<font color="red">  87.     chunks = []</font>
<font color="red">  88.     _append = chunks.append</font>
<font color="red">  89.     begin = end - 1</font>
<font color="red">  90.     while 1:</font>
<font color="red">  91.         chunk = _m(s, end)</font>
<font color="red">  92.         if chunk is None:</font>
<font color="red">  93.             raise ValueError(</font>
<font color="red">  94.                 errmsg(&quot;Unterminated string starting at&quot;, s, begin))</font>
<font color="red">  95.         end = chunk.end()</font>
<font color="red">  96.         content, terminator = chunk.groups()</font>
<font color="black">  97.         # Content is contains zero or more unescaped string characters</font>
<font color="red">  98.         if content:</font>
<font color="red">  99.             if not isinstance(content, unicode):</font>
<font color="red"> 100.                 content = unicode(content, encoding)</font>
<font color="red"> 101.             _append(content)</font>
<font color="black"> 102.         # Terminator is the end of string, a literal control character,</font>
<font color="black"> 103.         # or a backslash denoting that an escape sequence follows</font>
<font color="red"> 104.         if terminator == '&quot;':</font>
<font color="red"> 105.             break</font>
<font color="red"> 106.         elif terminator != '\\':</font>
<font color="red"> 107.             if strict:</font>
<font color="black"> 108.                 #msg = &quot;Invalid control character %r at&quot; % (terminator,)</font>
<font color="red"> 109.                 msg = &quot;Invalid control character {0!r} at&quot;.format(terminator)</font>
<font color="red"> 110.                 raise ValueError(errmsg(msg, s, end))</font>
<font color="black"> 111.             else:</font>
<font color="red"> 112.                 _append(terminator)</font>
<font color="red"> 113.                 continue</font>
<font color="red"> 114.         try:</font>
<font color="red"> 115.             esc = s[end]</font>
<font color="red"> 116.         except IndexError:</font>
<font color="red"> 117.             raise ValueError(</font>
<font color="red"> 118.                 errmsg(&quot;Unterminated string starting at&quot;, s, begin))</font>
<font color="black"> 119.         # If not a unicode escape sequence, must be in the lookup table</font>
<font color="red"> 120.         if esc != 'u':</font>
<font color="red"> 121.             try:</font>
<font color="red"> 122.                 char = _b[esc]</font>
<font color="red"> 123.             except KeyError:</font>
<font color="red"> 124.                 msg = &quot;Invalid \\escape: &quot; + repr(esc)</font>
<font color="red"> 125.                 raise ValueError(errmsg(msg, s, end))</font>
<font color="red"> 126.             end += 1</font>
<font color="black"> 127.         else:</font>
<font color="black"> 128.             # Unicode escape sequence</font>
<font color="red"> 129.             uni = _decode_uXXXX(s, end)</font>
<font color="red"> 130.             end += 5</font>
<font color="black"> 131.             # Check for surrogate pair on UCS-4 systems</font>
<font color="red"> 132.             if sys.maxunicode &gt; 65535 and \</font>
<font color="red"> 133.                0xd800 &lt;= uni &lt;= 0xdbff and s[end:end + 2] == '\\u':</font>
<font color="red"> 134.                 uni2 = _decode_uXXXX(s, end + 1)</font>
<font color="red"> 135.                 if 0xdc00 &lt;= uni2 &lt;= 0xdfff:</font>
<font color="red"> 136.                     uni = 0x10000 + (((uni - 0xd800) &lt;&lt; 10) | (uni2 - 0xdc00))</font>
<font color="red"> 137.                     end += 6</font>
<font color="red"> 138.             char = unichr(uni)</font>
<font color="black"> 139.         # Append the unescaped character</font>
<font color="red"> 140.         _append(char)</font>
<font color="red"> 141.     return u''.join(chunks), end</font>
<font color="black"> 142. </font>
<font color="black"> 143. </font>
<font color="black"> 144. # Use speedup if available</font>
<font color="green"> 145. scanstring = c_scanstring or py_scanstring</font>
<font color="black"> 146. </font>
<font color="green"> 147. WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)</font>
<font color="green"> 148. WHITESPACE_STR = ' \t\n\r'</font>
<font color="black"> 149. </font>
<font color="black"> 150. def JSONObject(s_and_end, encoding, strict, scan_once, object_hook,</font>
<font color="green"> 151.                object_pairs_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):</font>
<font color="red"> 152.     s, end = s_and_end</font>
<font color="red"> 153.     pairs = []</font>
<font color="red"> 154.     pairs_append = pairs.append</font>
<font color="black"> 155.     # Use a slice to prevent IndexError from being raised, the following</font>
<font color="black"> 156.     # check will raise a more specific ValueError if the string is empty</font>
<font color="red"> 157.     nextchar = s[end:end + 1]</font>
<font color="black"> 158.     # Normally we expect nextchar == '&quot;'</font>
<font color="red"> 159.     if nextchar != '&quot;':</font>
<font color="red"> 160.         if nextchar in _ws:</font>
<font color="red"> 161.             end = _w(s, end).end()</font>
<font color="red"> 162.             nextchar = s[end:end + 1]</font>
<font color="black"> 163.         # Trivial empty object</font>
<font color="red"> 164.         if nextchar == '}':</font>
<font color="red"> 165.             if object_pairs_hook is not None:</font>
<font color="red"> 166.                 result = object_pairs_hook(pairs)</font>
<font color="red"> 167.                 return result, end + 1</font>
<font color="red"> 168.             pairs = {}</font>
<font color="red"> 169.             if object_hook is not None:</font>
<font color="red"> 170.                 pairs = object_hook(pairs)</font>
<font color="red"> 171.             return pairs, end + 1</font>
<font color="red"> 172.         elif nextchar != '&quot;':</font>
<font color="red"> 173.             raise ValueError(errmsg(</font>
<font color="red"> 174.                 &quot;Expecting property name enclosed in double quotes&quot;, s, end))</font>
<font color="red"> 175.     end += 1</font>
<font color="red"> 176.     while True:</font>
<font color="red"> 177.         key, end = scanstring(s, end, encoding, strict)</font>
<font color="black"> 178. </font>
<font color="black"> 179.         # To skip some function call overhead we optimize the fast paths where</font>
<font color="black"> 180.         # the JSON key separator is &quot;: &quot; or just &quot;:&quot;.</font>
<font color="red"> 181.         if s[end:end + 1] != ':':</font>
<font color="red"> 182.             end = _w(s, end).end()</font>
<font color="red"> 183.             if s[end:end + 1] != ':':</font>
<font color="red"> 184.                 raise ValueError(errmsg(&quot;Expecting ':' delimiter&quot;, s, end))</font>
<font color="red"> 185.         end += 1</font>
<font color="black"> 186. </font>
<font color="red"> 187.         try:</font>
<font color="red"> 188.             if s[end] in _ws:</font>
<font color="red"> 189.                 end += 1</font>
<font color="red"> 190.                 if s[end] in _ws:</font>
<font color="red"> 191.                     end = _w(s, end + 1).end()</font>
<font color="red"> 192.         except IndexError:</font>
<font color="red"> 193.             pass</font>
<font color="black"> 194. </font>
<font color="red"> 195.         try:</font>
<font color="red"> 196.             value, end = scan_once(s, end)</font>
<font color="red"> 197.         except StopIteration:</font>
<font color="red"> 198.             raise ValueError(errmsg(&quot;Expecting object&quot;, s, end))</font>
<font color="red"> 199.         pairs_append((key, value))</font>
<font color="black"> 200. </font>
<font color="red"> 201.         try:</font>
<font color="red"> 202.             nextchar = s[end]</font>
<font color="red"> 203.             if nextchar in _ws:</font>
<font color="red"> 204.                 end = _w(s, end + 1).end()</font>
<font color="red"> 205.                 nextchar = s[end]</font>
<font color="red"> 206.         except IndexError:</font>
<font color="red"> 207.             nextchar = ''</font>
<font color="red"> 208.         end += 1</font>
<font color="black"> 209. </font>
<font color="red"> 210.         if nextchar == '}':</font>
<font color="red"> 211.             break</font>
<font color="red"> 212.         elif nextchar != ',':</font>
<font color="red"> 213.             raise ValueError(errmsg(&quot;Expecting ',' delimiter&quot;, s, end - 1))</font>
<font color="black"> 214. </font>
<font color="red"> 215.         try:</font>
<font color="red"> 216.             nextchar = s[end]</font>
<font color="red"> 217.             if nextchar in _ws:</font>
<font color="red"> 218.                 end += 1</font>
<font color="red"> 219.                 nextchar = s[end]</font>
<font color="red"> 220.                 if nextchar in _ws:</font>
<font color="red"> 221.                     end = _w(s, end + 1).end()</font>
<font color="red"> 222.                     nextchar = s[end]</font>
<font color="red"> 223.         except IndexError:</font>
<font color="red"> 224.             nextchar = ''</font>
<font color="black"> 225. </font>
<font color="red"> 226.         end += 1</font>
<font color="red"> 227.         if nextchar != '&quot;':</font>
<font color="red"> 228.             raise ValueError(errmsg(</font>
<font color="red"> 229.                 &quot;Expecting property name enclosed in double quotes&quot;, s, end - 1))</font>
<font color="red"> 230.     if object_pairs_hook is not None:</font>
<font color="red"> 231.         result = object_pairs_hook(pairs)</font>
<font color="red"> 232.         return result, end</font>
<font color="red"> 233.     pairs = dict(pairs)</font>
<font color="red"> 234.     if object_hook is not None:</font>
<font color="red"> 235.         pairs = object_hook(pairs)</font>
<font color="red"> 236.     return pairs, end</font>
<font color="black"> 237. </font>
<font color="green"> 238. def JSONArray(s_and_end, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):</font>
<font color="red"> 239.     s, end = s_and_end</font>
<font color="red"> 240.     values = []</font>
<font color="red"> 241.     nextchar = s[end:end + 1]</font>
<font color="red"> 242.     if nextchar in _ws:</font>
<font color="red"> 243.         end = _w(s, end + 1).end()</font>
<font color="red"> 244.         nextchar = s[end:end + 1]</font>
<font color="black"> 245.     # Look-ahead for trivial empty array</font>
<font color="red"> 246.     if nextchar == ']':</font>
<font color="red"> 247.         return values, end + 1</font>
<font color="red"> 248.     _append = values.append</font>
<font color="red"> 249.     while True:</font>
<font color="red"> 250.         try:</font>
<font color="red"> 251.             value, end = scan_once(s, end)</font>
<font color="red"> 252.         except StopIteration:</font>
<font color="red"> 253.             raise ValueError(errmsg(&quot;Expecting object&quot;, s, end))</font>
<font color="red"> 254.         _append(value)</font>
<font color="red"> 255.         nextchar = s[end:end + 1]</font>
<font color="red"> 256.         if nextchar in _ws:</font>
<font color="red"> 257.             end = _w(s, end + 1).end()</font>
<font color="red"> 258.             nextchar = s[end:end + 1]</font>
<font color="red"> 259.         end += 1</font>
<font color="red"> 260.         if nextchar == ']':</font>
<font color="red"> 261.             break</font>
<font color="red"> 262.         elif nextchar != ',':</font>
<font color="red"> 263.             raise ValueError(errmsg(&quot;Expecting ',' delimiter&quot;, s, end))</font>
<font color="red"> 264.         try:</font>
<font color="red"> 265.             if s[end] in _ws:</font>
<font color="red"> 266.                 end += 1</font>
<font color="red"> 267.                 if s[end] in _ws:</font>
<font color="red"> 268.                     end = _w(s, end + 1).end()</font>
<font color="red"> 269.         except IndexError:</font>
<font color="red"> 270.             pass</font>
<font color="black"> 271. </font>
<font color="red"> 272.     return values, end</font>
<font color="black"> 273. </font>
<font color="green"> 274. class JSONDecoder(object):</font>
<font color="black"> 275.     &quot;&quot;&quot;Simple JSON &lt;http://json.org&gt; decoder</font>
<font color="black"> 276. </font>
<font color="black"> 277.     Performs the following translations in decoding by default:</font>
<font color="black"> 278. </font>
<font color="black"> 279.     +---------------+-------------------+</font>
<font color="black"> 280.     | JSON          | Python            |</font>
<font color="black"> 281.     +===============+===================+</font>
<font color="black"> 282.     | object        | dict              |</font>
<font color="black"> 283.     +---------------+-------------------+</font>
<font color="black"> 284.     | array         | list              |</font>
<font color="black"> 285.     +---------------+-------------------+</font>
<font color="black"> 286.     | string        | unicode           |</font>
<font color="black"> 287.     +---------------+-------------------+</font>
<font color="black"> 288.     | number (int)  | int, long         |</font>
<font color="black"> 289.     +---------------+-------------------+</font>
<font color="black"> 290.     | number (real) | float             |</font>
<font color="black"> 291.     +---------------+-------------------+</font>
<font color="black"> 292.     | true          | True              |</font>
<font color="black"> 293.     +---------------+-------------------+</font>
<font color="black"> 294.     | false         | False             |</font>
<font color="black"> 295.     +---------------+-------------------+</font>
<font color="black"> 296.     | null          | None              |</font>
<font color="black"> 297.     +---------------+-------------------+</font>
<font color="black"> 298. </font>
<font color="black"> 299.     It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as</font>
<font color="black"> 300.     their corresponding ``float`` values, which is outside the JSON spec.</font>
<font color="black"> 301. </font>
<font color="green"> 302.     &quot;&quot;&quot;</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def __init__(self, encoding=None, object_hook=None, parse_float=None,</font>
<font color="green"> 305.             parse_int=None, parse_constant=None, strict=True,</font>
<font color="green"> 306.             object_pairs_hook=None):</font>
<font color="black"> 307.         &quot;&quot;&quot;``encoding`` determines the encoding used to interpret any ``str``</font>
<font color="black"> 308.         objects decoded by this instance (utf-8 by default).  It has no</font>
<font color="black"> 309.         effect when decoding ``unicode`` objects.</font>
<font color="black"> 310. </font>
<font color="black"> 311.         Note that currently only encodings that are a superset of ASCII work,</font>
<font color="black"> 312.         strings of other encodings should be passed in as ``unicode``.</font>
<font color="black"> 313. </font>
<font color="black"> 314.         ``object_hook``, if specified, will be called with the result</font>
<font color="black"> 315.         of every JSON object decoded and its return value will be used in</font>
<font color="black"> 316.         place of the given ``dict``.  This can be used to provide custom</font>
<font color="black"> 317.         deserializations (e.g. to support JSON-RPC class hinting).</font>
<font color="black"> 318. </font>
<font color="black"> 319.         ``object_pairs_hook``, if specified will be called with the result of</font>
<font color="black"> 320.         every JSON object decoded with an ordered list of pairs.  The return</font>
<font color="black"> 321.         value of ``object_pairs_hook`` will be used instead of the ``dict``.</font>
<font color="black"> 322.         This feature can be used to implement custom decoders that rely on the</font>
<font color="black"> 323.         order that the key and value pairs are decoded (for example,</font>
<font color="black"> 324.         collections.OrderedDict will remember the order of insertion). If</font>
<font color="black"> 325.         ``object_hook`` is also defined, the ``object_pairs_hook`` takes</font>
<font color="black"> 326.         priority.</font>
<font color="black"> 327. </font>
<font color="black"> 328.         ``parse_float``, if specified, will be called with the string</font>
<font color="black"> 329.         of every JSON float to be decoded. By default this is equivalent to</font>
<font color="black"> 330.         float(num_str). This can be used to use another datatype or parser</font>
<font color="black"> 331.         for JSON floats (e.g. decimal.Decimal).</font>
<font color="black"> 332. </font>
<font color="black"> 333.         ``parse_int``, if specified, will be called with the string</font>
<font color="black"> 334.         of every JSON int to be decoded. By default this is equivalent to</font>
<font color="black"> 335.         int(num_str). This can be used to use another datatype or parser</font>
<font color="black"> 336.         for JSON integers (e.g. float).</font>
<font color="black"> 337. </font>
<font color="black"> 338.         ``parse_constant``, if specified, will be called with one of the</font>
<font color="black"> 339.         following strings: -Infinity, Infinity, NaN.</font>
<font color="black"> 340.         This can be used to raise an exception if invalid JSON numbers</font>
<font color="black"> 341.         are encountered.</font>
<font color="black"> 342. </font>
<font color="black"> 343.         If ``strict`` is false (true is the default), then control</font>
<font color="black"> 344.         characters will be allowed inside strings.  Control characters in</font>
<font color="black"> 345.         this context are those with character codes in the 0-31 range,</font>
<font color="black"> 346.         including ``'\\t'`` (tab), ``'\\n'``, ``'\\r'`` and ``'\\0'``.</font>
<font color="black"> 347. </font>
<font color="black"> 348.         &quot;&quot;&quot;</font>
<font color="green"> 349.         self.encoding = encoding</font>
<font color="green"> 350.         self.object_hook = object_hook</font>
<font color="green"> 351.         self.object_pairs_hook = object_pairs_hook</font>
<font color="green"> 352.         self.parse_float = parse_float or float</font>
<font color="green"> 353.         self.parse_int = parse_int or int</font>
<font color="green"> 354.         self.parse_constant = parse_constant or _CONSTANTS.__getitem__</font>
<font color="green"> 355.         self.strict = strict</font>
<font color="green"> 356.         self.parse_object = JSONObject</font>
<font color="green"> 357.         self.parse_array = JSONArray</font>
<font color="green"> 358.         self.parse_string = scanstring</font>
<font color="green"> 359.         self.scan_once = scanner.make_scanner(self)</font>
<font color="black"> 360. </font>
<font color="green"> 361.     def decode(self, s, _w=WHITESPACE.match):</font>
<font color="black"> 362.         &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` or ``unicode``</font>
<font color="black"> 363.         instance containing a JSON document)</font>
<font color="black"> 364. </font>
<font color="black"> 365.         &quot;&quot;&quot;</font>
<font color="red"> 366.         obj, end = self.raw_decode(s, idx=_w(s, 0).end())</font>
<font color="red"> 367.         end = _w(s, end).end()</font>
<font color="red"> 368.         if end != len(s):</font>
<font color="red"> 369.             raise ValueError(errmsg(&quot;Extra data&quot;, s, end, len(s)))</font>
<font color="red"> 370.         return obj</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def raw_decode(self, s, idx=0):</font>
<font color="black"> 373.         &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` or ``unicode``</font>
<font color="black"> 374.         beginning with a JSON document) and return a 2-tuple of the Python</font>
<font color="black"> 375.         representation and the index in ``s`` where the document ended.</font>
<font color="black"> 376. </font>
<font color="black"> 377.         This can be used to decode a JSON document from a string that may</font>
<font color="black"> 378.         have extraneous data at the end.</font>
<font color="black"> 379. </font>
<font color="black"> 380.         &quot;&quot;&quot;</font>
<font color="red"> 381.         try:</font>
<font color="red"> 382.             obj, end = self.scan_once(s, idx)</font>
<font color="red"> 383.         except StopIteration:</font>
<font color="red"> 384.             raise ValueError(&quot;No JSON object could be decoded&quot;)</font>
<font color="red"> 385.         return obj, end</font>
</pre>

