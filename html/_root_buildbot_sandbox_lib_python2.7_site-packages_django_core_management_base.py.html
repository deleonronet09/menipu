source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/management/base.py</b><br>


file stats: <b>281 lines, 140 executed: 49.8% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3. Base classes for writing management commands (named commands which can</font>
<font color="black">   4. be executed through ``django-admin`` or ``manage.py``).</font>
<font color="green">   5. &quot;&quot;&quot;</font>
<font color="green">   6. from __future__ import unicode_literals</font>
<font color="black">   7. </font>
<font color="green">   8. import os</font>
<font color="green">   9. import sys</font>
<font color="green">  10. import warnings</font>
<font color="green">  11. from argparse import ArgumentParser</font>
<font color="green">  12. from optparse import OptionParser</font>
<font color="black">  13. </font>
<font color="green">  14. import django</font>
<font color="green">  15. from django.core import checks</font>
<font color="green">  16. from django.core.management.color import color_style, no_style</font>
<font color="green">  17. from django.db import connections</font>
<font color="green">  18. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  19. from django.utils.encoding import force_str</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class CommandError(Exception):</font>
<font color="black">  23.     &quot;&quot;&quot;</font>
<font color="black">  24.     Exception class indicating a problem while executing a management</font>
<font color="black">  25.     command.</font>
<font color="black">  26. </font>
<font color="black">  27.     If this exception is raised during the execution of a management</font>
<font color="black">  28.     command, it will be caught and turned into a nicely-printed error</font>
<font color="black">  29.     message to the appropriate output stream (i.e., stderr); as a</font>
<font color="black">  30.     result, raising this exception (with a sensible description of the</font>
<font color="black">  31.     error) is the preferred way to indicate that something has gone</font>
<font color="black">  32.     wrong in the execution of a command.</font>
<font color="green">  33.     &quot;&quot;&quot;</font>
<font color="green">  34.     pass</font>
<font color="black">  35. </font>
<font color="black">  36. </font>
<font color="green">  37. class SystemCheckError(CommandError):</font>
<font color="black">  38.     &quot;&quot;&quot;</font>
<font color="black">  39.     The system check framework detected unrecoverable errors.</font>
<font color="green">  40.     &quot;&quot;&quot;</font>
<font color="green">  41.     pass</font>
<font color="black">  42. </font>
<font color="black">  43. </font>
<font color="green">  44. class CommandParser(ArgumentParser):</font>
<font color="black">  45.     &quot;&quot;&quot;</font>
<font color="black">  46.     Customized ArgumentParser class to improve some error messages and prevent</font>
<font color="black">  47.     SystemExit in several occasions, as SystemExit is unacceptable when a</font>
<font color="black">  48.     command is called programmatically.</font>
<font color="green">  49.     &quot;&quot;&quot;</font>
<font color="green">  50.     def __init__(self, cmd, **kwargs):</font>
<font color="green">  51.         self.cmd = cmd</font>
<font color="green">  52.         super(CommandParser, self).__init__(**kwargs)</font>
<font color="black">  53. </font>
<font color="green">  54.     def parse_args(self, args=None, namespace=None):</font>
<font color="black">  55.         # Catch missing argument for a better error message</font>
<font color="green">  56.         if (hasattr(self.cmd, 'missing_args_message') and</font>
<font color="red">  57.                 not (args or any(not arg.startswith('-') for arg in args))):</font>
<font color="red">  58.             self.error(self.cmd.missing_args_message)</font>
<font color="green">  59.         return super(CommandParser, self).parse_args(args, namespace)</font>
<font color="black">  60. </font>
<font color="green">  61.     def error(self, message):</font>
<font color="red">  62.         if self.cmd._called_from_command_line:</font>
<font color="red">  63.             super(CommandParser, self).error(message)</font>
<font color="black">  64.         else:</font>
<font color="red">  65.             raise CommandError(&quot;Error: %s&quot; % message)</font>
<font color="black">  66. </font>
<font color="black">  67. </font>
<font color="green">  68. def handle_default_options(options):</font>
<font color="black">  69.     &quot;&quot;&quot;</font>
<font color="black">  70.     Include any default options that all commands should accept here</font>
<font color="black">  71.     so that ManagementUtility can handle them before searching for</font>
<font color="black">  72.     user commands.</font>
<font color="black">  73.     &quot;&quot;&quot;</font>
<font color="green">  74.     if options.settings:</font>
<font color="red">  75.         os.environ['DJANGO_SETTINGS_MODULE'] = options.settings</font>
<font color="green">  76.     if options.pythonpath:</font>
<font color="red">  77.         sys.path.insert(0, options.pythonpath)</font>
<font color="black">  78. </font>
<font color="black">  79. </font>
<font color="green">  80. class OutputWrapper(object):</font>
<font color="black">  81.     &quot;&quot;&quot;</font>
<font color="black">  82.     Wrapper around stdout/stderr</font>
<font color="green">  83.     &quot;&quot;&quot;</font>
<font color="green">  84.     @property</font>
<font color="black">  85.     def style_func(self):</font>
<font color="red">  86.         return self._style_func</font>
<font color="black">  87. </font>
<font color="green">  88.     @style_func.setter</font>
<font color="black">  89.     def style_func(self, style_func):</font>
<font color="green">  90.         if style_func and self.isatty():</font>
<font color="green">  91.             self._style_func = style_func</font>
<font color="black">  92.         else:</font>
<font color="green">  93.             self._style_func = lambda x: x</font>
<font color="black">  94. </font>
<font color="green">  95.     def __init__(self, out, style_func=None, ending='\n'):</font>
<font color="green">  96.         self._out = out</font>
<font color="green">  97.         self.style_func = None</font>
<font color="green">  98.         self.ending = ending</font>
<font color="black">  99. </font>
<font color="green"> 100.     def __getattr__(self, name):</font>
<font color="red"> 101.         return getattr(self._out, name)</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def isatty(self):</font>
<font color="green"> 104.         return hasattr(self._out, 'isatty') and self._out.isatty()</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def write(self, msg, style_func=None, ending=None):</font>
<font color="red"> 107.         ending = self.ending if ending is None else ending</font>
<font color="red"> 108.         if ending and not msg.endswith(ending):</font>
<font color="red"> 109.             msg += ending</font>
<font color="red"> 110.         style_func = style_func or self.style_func</font>
<font color="red"> 111.         self._out.write(force_str(style_func(msg)))</font>
<font color="black"> 112. </font>
<font color="black"> 113. </font>
<font color="green"> 114. class BaseCommand(object):</font>
<font color="black"> 115.     &quot;&quot;&quot;</font>
<font color="black"> 116.     The base class from which all management commands ultimately</font>
<font color="black"> 117.     derive.</font>
<font color="black"> 118. </font>
<font color="black"> 119.     Use this class if you want access to all of the mechanisms which</font>
<font color="black"> 120.     parse the command-line arguments and work out what code to call in</font>
<font color="black"> 121.     response; if you don't need to change any of that behavior,</font>
<font color="black"> 122.     consider using one of the subclasses defined in this file.</font>
<font color="black"> 123. </font>
<font color="black"> 124.     If you are interested in overriding/customizing various aspects of</font>
<font color="black"> 125.     the command-parsing and -execution behavior, the normal flow works</font>
<font color="black"> 126.     as follows:</font>
<font color="black"> 127. </font>
<font color="black"> 128.     1. ``django-admin`` or ``manage.py`` loads the command class</font>
<font color="black"> 129.        and calls its ``run_from_argv()`` method.</font>
<font color="black"> 130. </font>
<font color="black"> 131.     2. The ``run_from_argv()`` method calls ``create_parser()`` to get</font>
<font color="black"> 132.        an ``ArgumentParser`` for the arguments, parses them, performs</font>
<font color="black"> 133.        any environment changes requested by options like</font>
<font color="black"> 134.        ``pythonpath``, and then calls the ``execute()`` method,</font>
<font color="black"> 135.        passing the parsed arguments.</font>
<font color="black"> 136. </font>
<font color="black"> 137.     3. The ``execute()`` method attempts to carry out the command by</font>
<font color="black"> 138.        calling the ``handle()`` method with the parsed arguments; any</font>
<font color="black"> 139.        output produced by ``handle()`` will be printed to standard</font>
<font color="black"> 140.        output and, if the command is intended to produce a block of</font>
<font color="black"> 141.        SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.</font>
<font color="black"> 142. </font>
<font color="black"> 143.     4. If ``handle()`` or ``execute()`` raised any exception (e.g.</font>
<font color="black"> 144.        ``CommandError``), ``run_from_argv()`` will  instead print an error</font>
<font color="black"> 145.        message to ``stderr``.</font>
<font color="black"> 146. </font>
<font color="black"> 147.     Thus, the ``handle()`` method is typically the starting point for</font>
<font color="black"> 148.     subclasses; many built-in commands and command types either place</font>
<font color="black"> 149.     all of their logic in ``handle()``, or perform some additional</font>
<font color="black"> 150.     parsing work in ``handle()`` and then delegate from it to more</font>
<font color="black"> 151.     specialized methods as needed.</font>
<font color="black"> 152. </font>
<font color="black"> 153.     Several attributes affect behavior at various steps along the way:</font>
<font color="black"> 154. </font>
<font color="black"> 155.     ``args``</font>
<font color="black"> 156.         A string listing the arguments accepted by the command,</font>
<font color="black"> 157.         suitable for use in help messages; e.g., a command which takes</font>
<font color="black"> 158.         a list of application names might set this to '&lt;app_label</font>
<font color="black"> 159.         app_label ...&gt;'.</font>
<font color="black"> 160. </font>
<font color="black"> 161.     ``can_import_settings``</font>
<font color="black"> 162.         A boolean indicating whether the command needs to be able to</font>
<font color="black"> 163.         import Django settings; if ``True``, ``execute()`` will verify</font>
<font color="black"> 164.         that this is possible before proceeding. Default value is</font>
<font color="black"> 165.         ``True``.</font>
<font color="black"> 166. </font>
<font color="black"> 167.     ``help``</font>
<font color="black"> 168.         A short description of the command, which will be printed in</font>
<font color="black"> 169.         help messages.</font>
<font color="black"> 170. </font>
<font color="black"> 171.     ``option_list``</font>
<font color="black"> 172.         This is the list of ``optparse`` options which will be fed</font>
<font color="black"> 173.         into the command's ``OptionParser`` for parsing arguments.</font>
<font color="black"> 174.         Deprecated and will be removed in Django 1.10.</font>
<font color="black"> 175.         Use ``add_arguments`` instead.</font>
<font color="black"> 176. </font>
<font color="black"> 177.     ``output_transaction``</font>
<font color="black"> 178.         A boolean indicating whether the command outputs SQL</font>
<font color="black"> 179.         statements; if ``True``, the output will automatically be</font>
<font color="black"> 180.         wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is</font>
<font color="black"> 181.         ``False``.</font>
<font color="black"> 182. </font>
<font color="black"> 183.     ``requires_system_checks``</font>
<font color="black"> 184.         A boolean; if ``True``, entire Django project will be checked for errors</font>
<font color="black"> 185.         prior to executing the command. Default value is ``True``.</font>
<font color="black"> 186.         To validate an individual application's models</font>
<font color="black"> 187.         rather than all applications' models, call</font>
<font color="black"> 188.         ``self.check(app_configs)`` from ``handle()``, where ``app_configs``</font>
<font color="black"> 189.         is the list of application's configuration provided by the</font>
<font color="black"> 190.         app registry.</font>
<font color="black"> 191. </font>
<font color="black"> 192.     ``leave_locale_alone``</font>
<font color="black"> 193.         A boolean indicating whether the locale set in settings should be</font>
<font color="black"> 194.         preserved during the execution of the command instead of translations</font>
<font color="black"> 195.         being deactivated.</font>
<font color="black"> 196. </font>
<font color="black"> 197.         Default value is ``False``.</font>
<font color="black"> 198. </font>
<font color="black"> 199.         Make sure you know what you are doing if you decide to change the value</font>
<font color="black"> 200.         of this option in your custom command if it creates database content</font>
<font color="black"> 201.         that is locale-sensitive and such content shouldn't contain any</font>
<font color="black"> 202.         translations (like it happens e.g. with django.contrib.auth</font>
<font color="black"> 203.         permissions) as activating any locale might cause unintended effects.</font>
<font color="black"> 204. </font>
<font color="black"> 205.         This option can't be False when the can_import_settings option is set</font>
<font color="black"> 206.         to False too because attempting to deactivate translations needs access</font>
<font color="black"> 207.         to settings. This condition will generate a CommandError.</font>
<font color="green"> 208.     &quot;&quot;&quot;</font>
<font color="black"> 209.     # Metadata about this command.</font>
<font color="green"> 210.     option_list = ()</font>
<font color="green"> 211.     help = ''</font>
<font color="green"> 212.     args = ''</font>
<font color="black"> 213. </font>
<font color="black"> 214.     # Configuration shortcuts that alter various logic.</font>
<font color="green"> 215.     _called_from_command_line = False</font>
<font color="green"> 216.     can_import_settings = True</font>
<font color="green"> 217.     output_transaction = False  # Whether to wrap the output in a &quot;BEGIN; COMMIT;&quot;</font>
<font color="green"> 218.     leave_locale_alone = False</font>
<font color="green"> 219.     requires_system_checks = True</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def __init__(self, stdout=None, stderr=None, no_color=False):</font>
<font color="green"> 222.         self.stdout = OutputWrapper(stdout or sys.stdout)</font>
<font color="green"> 223.         self.stderr = OutputWrapper(stderr or sys.stderr)</font>
<font color="green"> 224.         if no_color:</font>
<font color="red"> 225.             self.style = no_style()</font>
<font color="black"> 226.         else:</font>
<font color="green"> 227.             self.style = color_style()</font>
<font color="green"> 228.             self.stderr.style_func = self.style.ERROR</font>
<font color="black"> 229. </font>
<font color="green"> 230.     @property</font>
<font color="black"> 231.     def use_argparse(self):</font>
<font color="green"> 232.         return not bool(self.option_list)</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def get_version(self):</font>
<font color="black"> 235.         &quot;&quot;&quot;</font>
<font color="black"> 236.         Return the Django version, which should be correct for all built-in</font>
<font color="black"> 237.         Django commands. User-supplied commands can override this method to</font>
<font color="black"> 238.         return their own version.</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="green"> 240.         return django.get_version()</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def usage(self, subcommand):</font>
<font color="black"> 243.         &quot;&quot;&quot;</font>
<font color="black"> 244.         Return a brief description of how to use this command, by</font>
<font color="black"> 245.         default from the attribute ``self.help``.</font>
<font color="black"> 246.         &quot;&quot;&quot;</font>
<font color="red"> 247.         usage = '%%prog %s [options] %s' % (subcommand, self.args)</font>
<font color="red"> 248.         if self.help:</font>
<font color="red"> 249.             return '%s\n\n%s' % (usage, self.help)</font>
<font color="black"> 250.         else:</font>
<font color="red"> 251.             return usage</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def create_parser(self, prog_name, subcommand):</font>
<font color="black"> 254.         &quot;&quot;&quot;</font>
<font color="black"> 255.         Create and return the ``ArgumentParser`` which will be used to</font>
<font color="black"> 256.         parse the arguments to this command.</font>
<font color="black"> 257.         &quot;&quot;&quot;</font>
<font color="green"> 258.         if not self.use_argparse:</font>
<font color="red"> 259.             def store_as_int(option, opt_str, value, parser):</font>
<font color="red"> 260.                 setattr(parser.values, option.dest, int(value))</font>
<font color="black"> 261. </font>
<font color="black"> 262.             # Backwards compatibility: use deprecated optparse module</font>
<font color="red"> 263.             warnings.warn(&quot;OptionParser usage for Django management commands &quot;</font>
<font color="black"> 264.                           &quot;is deprecated, use ArgumentParser instead&quot;,</font>
<font color="red"> 265.                           RemovedInDjango110Warning)</font>
<font color="red"> 266.             parser = OptionParser(prog=prog_name,</font>
<font color="red"> 267.                                 usage=self.usage(subcommand),</font>
<font color="red"> 268.                                 version=self.get_version())</font>
<font color="red"> 269.             parser.add_option('-v', '--verbosity', action='callback', dest='verbosity', default=1,</font>
<font color="red"> 270.                 type='choice', choices=['0', '1', '2', '3'], callback=store_as_int,</font>
<font color="red"> 271.                 help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output')</font>
<font color="red"> 272.             parser.add_option('--settings',</font>
<font color="black"> 273.                 help=(</font>
<font color="red"> 274.                     'The Python path to a settings module, e.g. '</font>
<font color="black"> 275.                     '&quot;myproject.settings.main&quot;. If this isn\'t provided, the '</font>
<font color="black"> 276.                     'DJANGO_SETTINGS_MODULE environment variable will be used.'</font>
<font color="black"> 277.                 ),</font>
<font color="black"> 278.             )</font>
<font color="red"> 279.             parser.add_option('--pythonpath',</font>
<font color="red"> 280.                 help='A directory to add to the Python path, e.g. &quot;/home/djangoprojects/myproject&quot;.'),</font>
<font color="red"> 281.             parser.add_option('--traceback', action='store_true',</font>
<font color="red"> 282.                 help='Raise on CommandError exceptions')</font>
<font color="red"> 283.             parser.add_option('--no-color', action='store_true', dest='no_color', default=False,</font>
<font color="red"> 284.                 help=&quot;Don't colorize the command output.&quot;)</font>
<font color="red"> 285.             for opt in self.option_list:</font>
<font color="red"> 286.                 parser.add_option(opt)</font>
<font color="black"> 287.         else:</font>
<font color="green"> 288.             parser = CommandParser(self, prog=&quot;%s %s&quot; % (os.path.basename(prog_name), subcommand),</font>
<font color="green"> 289.                 description=self.help or None)</font>
<font color="green"> 290.             parser.add_argument('--version', action='version', version=self.get_version())</font>
<font color="green"> 291.             parser.add_argument('-v', '--verbosity', action='store', dest='verbosity', default='1',</font>
<font color="green"> 292.                 type=int, choices=[0, 1, 2, 3],</font>
<font color="green"> 293.                 help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output')</font>
<font color="green"> 294.             parser.add_argument('--settings',</font>
<font color="black"> 295.                 help=(</font>
<font color="green"> 296.                     'The Python path to a settings module, e.g. '</font>
<font color="black"> 297.                     '&quot;myproject.settings.main&quot;. If this isn\'t provided, the '</font>
<font color="black"> 298.                     'DJANGO_SETTINGS_MODULE environment variable will be used.'</font>
<font color="black"> 299.                 ),</font>
<font color="black"> 300.             )</font>
<font color="green"> 301.             parser.add_argument('--pythonpath',</font>
<font color="green"> 302.                 help='A directory to add to the Python path, e.g. &quot;/home/djangoprojects/myproject&quot;.')</font>
<font color="green"> 303.             parser.add_argument('--traceback', action='store_true',</font>
<font color="green"> 304.                 help='Raise on CommandError exceptions')</font>
<font color="green"> 305.             parser.add_argument('--no-color', action='store_true', dest='no_color', default=False,</font>
<font color="green"> 306.                 help=&quot;Don't colorize the command output.&quot;)</font>
<font color="green"> 307.             if self.args:</font>
<font color="black"> 308.                 # Keep compatibility and always accept positional arguments, like optparse when args is set</font>
<font color="red"> 309.                 parser.add_argument('args', nargs='*')</font>
<font color="green"> 310.             self.add_arguments(parser)</font>
<font color="green"> 311.         return parser</font>
<font color="black"> 312. </font>
<font color="green"> 313.     def add_arguments(self, parser):</font>
<font color="black"> 314.         &quot;&quot;&quot;</font>
<font color="black"> 315.         Entry point for subclassed commands to add custom arguments.</font>
<font color="black"> 316.         &quot;&quot;&quot;</font>
<font color="red"> 317.         pass</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def print_help(self, prog_name, subcommand):</font>
<font color="black"> 320.         &quot;&quot;&quot;</font>
<font color="black"> 321.         Print the help message for this command, derived from</font>
<font color="black"> 322.         ``self.usage()``.</font>
<font color="black"> 323.         &quot;&quot;&quot;</font>
<font color="red"> 324.         parser = self.create_parser(prog_name, subcommand)</font>
<font color="red"> 325.         parser.print_help()</font>
<font color="black"> 326. </font>
<font color="green"> 327.     def run_from_argv(self, argv):</font>
<font color="black"> 328.         &quot;&quot;&quot;</font>
<font color="black"> 329.         Set up any environment changes requested (e.g., Python path</font>
<font color="black"> 330.         and Django settings), then run this command. If the</font>
<font color="black"> 331.         command raises a ``CommandError``, intercept it and print it sensibly</font>
<font color="black"> 332.         to stderr. If the ``--traceback`` option is present or the raised</font>
<font color="black"> 333.         ``Exception`` is not ``CommandError``, raise it.</font>
<font color="black"> 334.         &quot;&quot;&quot;</font>
<font color="green"> 335.         self._called_from_command_line = True</font>
<font color="green"> 336.         parser = self.create_parser(argv[0], argv[1])</font>
<font color="black"> 337. </font>
<font color="green"> 338.         if self.use_argparse:</font>
<font color="green"> 339.             options = parser.parse_args(argv[2:])</font>
<font color="green"> 340.             cmd_options = vars(options)</font>
<font color="black"> 341.             # Move positional args out of options to mimic legacy optparse</font>
<font color="green"> 342.             args = cmd_options.pop('args', ())</font>
<font color="black"> 343.         else:</font>
<font color="red"> 344.             options, args = parser.parse_args(argv[2:])</font>
<font color="red"> 345.             cmd_options = vars(options)</font>
<font color="green"> 346.         handle_default_options(options)</font>
<font color="green"> 347.         try:</font>
<font color="green"> 348.             self.execute(*args, **cmd_options)</font>
<font color="green"> 349.         except Exception as e:</font>
<font color="red"> 350.             if options.traceback or not isinstance(e, CommandError):</font>
<font color="red"> 351.                 raise</font>
<font color="black"> 352. </font>
<font color="black"> 353.             # SystemCheckError takes care of its own formatting.</font>
<font color="red"> 354.             if isinstance(e, SystemCheckError):</font>
<font color="red"> 355.                 self.stderr.write(str(e), lambda x: x)</font>
<font color="black"> 356.             else:</font>
<font color="red"> 357.                 self.stderr.write('%s: %s' % (e.__class__.__name__, e))</font>
<font color="red"> 358.             sys.exit(1)</font>
<font color="black"> 359.         finally:</font>
<font color="green"> 360.             connections.close_all()</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def execute(self, *args, **options):</font>
<font color="black"> 363.         &quot;&quot;&quot;</font>
<font color="black"> 364.         Try to execute this command, performing system checks if needed (as</font>
<font color="black"> 365.         controlled by the ``requires_system_checks`` attribute, except if</font>
<font color="black"> 366.         force-skipped).</font>
<font color="black"> 367.         &quot;&quot;&quot;</font>
<font color="green"> 368.         if options.get('no_color'):</font>
<font color="red"> 369.             self.style = no_style()</font>
<font color="red"> 370.             self.stderr.style_func = None</font>
<font color="green"> 371.         if options.get('stdout'):</font>
<font color="red"> 372.             self.stdout = OutputWrapper(options['stdout'])</font>
<font color="green"> 373.         if options.get('stderr'):</font>
<font color="red"> 374.             self.stderr = OutputWrapper(options.get('stderr'), self.stderr.style_func)</font>
<font color="black"> 375. </font>
<font color="green"> 376.         saved_locale = None</font>
<font color="green"> 377.         if not self.leave_locale_alone:</font>
<font color="black"> 378.             # Only mess with locales if we can assume we have a working</font>
<font color="black"> 379.             # settings file, because django.utils.translation requires settings</font>
<font color="black"> 380.             # (The final saying about whether the i18n machinery is active will be</font>
<font color="black"> 381.             # found in the value of the USE_I18N setting)</font>
<font color="green"> 382.             if not self.can_import_settings:</font>
<font color="red"> 383.                 raise CommandError(&quot;Incompatible values of 'leave_locale_alone' &quot;</font>
<font color="black"> 384.                                    &quot;(%s) and 'can_import_settings' (%s) command &quot;</font>
<font color="red"> 385.                                    &quot;options.&quot; % (self.leave_locale_alone,</font>
<font color="red"> 386.                                                  self.can_import_settings))</font>
<font color="black"> 387.             # Deactivate translations, because django-admin creates database</font>
<font color="black"> 388.             # content like permissions, and those shouldn't contain any</font>
<font color="black"> 389.             # translations.</font>
<font color="green"> 390.             from django.utils import translation</font>
<font color="green"> 391.             saved_locale = translation.get_language()</font>
<font color="green"> 392.             translation.deactivate_all()</font>
<font color="black"> 393. </font>
<font color="green"> 394.         try:</font>
<font color="green"> 395.             if (self.requires_system_checks and</font>
<font color="green"> 396.                     not options.get('skip_validation') and  # Remove at the end of deprecation for `skip_validation`.</font>
<font color="green"> 397.                     not options.get('skip_checks')):</font>
<font color="red"> 398.                 self.check()</font>
<font color="green"> 399.             output = self.handle(*args, **options)</font>
<font color="green"> 400.             if output:</font>
<font color="red"> 401.                 if self.output_transaction:</font>
<font color="black"> 402.                     # This needs to be imported here, because it relies on</font>
<font color="black"> 403.                     # settings.</font>
<font color="red"> 404.                     from django.db import connections, DEFAULT_DB_ALIAS</font>
<font color="red"> 405.                     connection = connections[options.get('database', DEFAULT_DB_ALIAS)]</font>
<font color="red"> 406.                     if connection.ops.start_transaction_sql():</font>
<font color="red"> 407.                         self.stdout.write(self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()))</font>
<font color="red"> 408.                 self.stdout.write(output)</font>
<font color="red"> 409.                 if self.output_transaction:</font>
<font color="red"> 410.                     self.stdout.write('\n' + self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()))</font>
<font color="black"> 411.         finally:</font>
<font color="green"> 412.             if saved_locale is not None:</font>
<font color="green"> 413.                 translation.activate(saved_locale)</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def check(self, app_configs=None, tags=None, display_num_errors=False,</font>
<font color="green"> 416.               include_deployment_checks=False):</font>
<font color="black"> 417.         &quot;&quot;&quot;</font>
<font color="black"> 418.         Uses the system check framework to validate entire Django project.</font>
<font color="black"> 419.         Raises CommandError for any serious message (error or critical errors).</font>
<font color="black"> 420.         If there are only light messages (like warnings), they are printed to</font>
<font color="black"> 421.         stderr and no exception is raised.</font>
<font color="black"> 422.         &quot;&quot;&quot;</font>
<font color="red"> 423.         all_issues = checks.run_checks(</font>
<font color="red"> 424.             app_configs=app_configs,</font>
<font color="red"> 425.             tags=tags,</font>
<font color="red"> 426.             include_deployment_checks=include_deployment_checks,</font>
<font color="black"> 427.         )</font>
<font color="black"> 428. </font>
<font color="red"> 429.         header, body, footer = &quot;&quot;, &quot;&quot;, &quot;&quot;</font>
<font color="red"> 430.         visible_issue_count = 0  # excludes silenced warnings</font>
<font color="black"> 431. </font>
<font color="red"> 432.         if all_issues:</font>
<font color="red"> 433.             debugs = [e for e in all_issues if e.level &lt; checks.INFO and not e.is_silenced()]</font>
<font color="red"> 434.             infos = [e for e in all_issues if checks.INFO &lt;= e.level &lt; checks.WARNING and not e.is_silenced()]</font>
<font color="red"> 435.             warnings = [e for e in all_issues if checks.WARNING &lt;= e.level &lt; checks.ERROR and not e.is_silenced()]</font>
<font color="red"> 436.             errors = [e for e in all_issues if checks.ERROR &lt;= e.level &lt; checks.CRITICAL and not e.is_silenced()]</font>
<font color="red"> 437.             criticals = [e for e in all_issues if checks.CRITICAL &lt;= e.level and not e.is_silenced()]</font>
<font color="black"> 438.             sorted_issues = [</font>
<font color="red"> 439.                 (criticals, 'CRITICALS'),</font>
<font color="red"> 440.                 (errors, 'ERRORS'),</font>
<font color="red"> 441.                 (warnings, 'WARNINGS'),</font>
<font color="red"> 442.                 (infos, 'INFOS'),</font>
<font color="red"> 443.                 (debugs, 'DEBUGS'),</font>
<font color="black"> 444.             ]</font>
<font color="black"> 445. </font>
<font color="red"> 446.             for issues, group_name in sorted_issues:</font>
<font color="red"> 447.                 if issues:</font>
<font color="red"> 448.                     visible_issue_count += len(issues)</font>
<font color="black"> 449.                     formatted = (</font>
<font color="red"> 450.                         self.style.ERROR(force_str(e))</font>
<font color="black"> 451.                         if e.is_serious()</font>
<font color="black"> 452.                         else self.style.WARNING(force_str(e))</font>
<font color="red"> 453.                         for e in issues)</font>
<font color="red"> 454.                     formatted = &quot;\n&quot;.join(sorted(formatted))</font>
<font color="red"> 455.                     body += '\n%s:\n%s\n' % (group_name, formatted)</font>
<font color="black"> 456. </font>
<font color="red"> 457.         if visible_issue_count:</font>
<font color="red"> 458.             header = &quot;System check identified some issues:\n&quot;</font>
<font color="black"> 459. </font>
<font color="red"> 460.         if display_num_errors:</font>
<font color="red"> 461.             if visible_issue_count:</font>
<font color="red"> 462.                 footer += '\n'</font>
<font color="red"> 463.             footer += &quot;System check identified %s (%s silenced).&quot; % (</font>
<font color="red"> 464.                 &quot;no issues&quot; if visible_issue_count == 0 else</font>
<font color="red"> 465.                 &quot;1 issue&quot; if visible_issue_count == 1 else</font>
<font color="red"> 466.                 &quot;%s issues&quot; % visible_issue_count,</font>
<font color="red"> 467.                 len(all_issues) - visible_issue_count,</font>
<font color="black"> 468.             )</font>
<font color="black"> 469. </font>
<font color="red"> 470.         if any(e.is_serious() and not e.is_silenced() for e in all_issues):</font>
<font color="red"> 471.             msg = self.style.ERROR(&quot;SystemCheckError: %s&quot; % header) + body + footer</font>
<font color="red"> 472.             raise SystemCheckError(msg)</font>
<font color="black"> 473.         else:</font>
<font color="red"> 474.             msg = header + body + footer</font>
<font color="black"> 475. </font>
<font color="red"> 476.         if msg:</font>
<font color="red"> 477.             if visible_issue_count:</font>
<font color="red"> 478.                 self.stderr.write(msg, lambda x: x)</font>
<font color="black"> 479.             else:</font>
<font color="red"> 480.                 self.stdout.write(msg)</font>
<font color="black"> 481. </font>
<font color="green"> 482.     def handle(self, *args, **options):</font>
<font color="black"> 483.         &quot;&quot;&quot;</font>
<font color="black"> 484.         The actual logic of the command. Subclasses must implement</font>
<font color="black"> 485.         this method.</font>
<font color="black"> 486.         &quot;&quot;&quot;</font>
<font color="red"> 487.         raise NotImplementedError('subclasses of BaseCommand must provide a handle() method')</font>
<font color="black"> 488. </font>
<font color="black"> 489. </font>
<font color="green"> 490. class AppCommand(BaseCommand):</font>
<font color="black"> 491.     &quot;&quot;&quot;</font>
<font color="black"> 492.     A management command which takes one or more installed application labels</font>
<font color="black"> 493.     as arguments, and does something with each of them.</font>
<font color="black"> 494. </font>
<font color="black"> 495.     Rather than implementing ``handle()``, subclasses must implement</font>
<font color="black"> 496.     ``handle_app_config()``, which will be called once for each application.</font>
<font color="green"> 497.     &quot;&quot;&quot;</font>
<font color="green"> 498.     missing_args_message = &quot;Enter at least one application label.&quot;</font>
<font color="black"> 499. </font>
<font color="green"> 500.     def add_arguments(self, parser):</font>
<font color="red"> 501.         parser.add_argument('args', metavar='app_label', nargs='+',</font>
<font color="red"> 502.             help='One or more application label.')</font>
<font color="black"> 503. </font>
<font color="green"> 504.     def handle(self, *app_labels, **options):</font>
<font color="red"> 505.         from django.apps import apps</font>
<font color="red"> 506.         try:</font>
<font color="red"> 507.             app_configs = [apps.get_app_config(app_label) for app_label in app_labels]</font>
<font color="red"> 508.         except (LookupError, ImportError) as e:</font>
<font color="red"> 509.             raise CommandError(&quot;%s. Are you sure your INSTALLED_APPS setting is correct?&quot; % e)</font>
<font color="red"> 510.         output = []</font>
<font color="red"> 511.         for app_config in app_configs:</font>
<font color="red"> 512.             app_output = self.handle_app_config(app_config, **options)</font>
<font color="red"> 513.             if app_output:</font>
<font color="red"> 514.                 output.append(app_output)</font>
<font color="red"> 515.         return '\n'.join(output)</font>
<font color="black"> 516. </font>
<font color="green"> 517.     def handle_app_config(self, app_config, **options):</font>
<font color="black"> 518.         &quot;&quot;&quot;</font>
<font color="black"> 519.         Perform the command's actions for app_config, an AppConfig instance</font>
<font color="black"> 520.         corresponding to an application label given on the command line.</font>
<font color="black"> 521.         &quot;&quot;&quot;</font>
<font color="red"> 522.         raise NotImplementedError(</font>
<font color="red"> 523.             &quot;Subclasses of AppCommand must provide&quot;</font>
<font color="black"> 524.             &quot;a handle_app_config() method.&quot;)</font>
<font color="black"> 525. </font>
<font color="black"> 526. </font>
<font color="green"> 527. class LabelCommand(BaseCommand):</font>
<font color="black"> 528.     &quot;&quot;&quot;</font>
<font color="black"> 529.     A management command which takes one or more arbitrary arguments</font>
<font color="black"> 530.     (labels) on the command line, and does something with each of</font>
<font color="black"> 531.     them.</font>
<font color="black"> 532. </font>
<font color="black"> 533.     Rather than implementing ``handle()``, subclasses must implement</font>
<font color="black"> 534.     ``handle_label()``, which will be called once for each label.</font>
<font color="black"> 535. </font>
<font color="black"> 536.     If the arguments should be names of installed applications, use</font>
<font color="black"> 537.     ``AppCommand`` instead.</font>
<font color="green"> 538.     &quot;&quot;&quot;</font>
<font color="green"> 539.     label = 'label'</font>
<font color="green"> 540.     missing_args_message = &quot;Enter at least one %s.&quot; % label</font>
<font color="black"> 541. </font>
<font color="green"> 542.     def add_arguments(self, parser):</font>
<font color="red"> 543.         parser.add_argument('args', metavar=self.label, nargs='+')</font>
<font color="black"> 544. </font>
<font color="green"> 545.     def handle(self, *labels, **options):</font>
<font color="red"> 546.         output = []</font>
<font color="red"> 547.         for label in labels:</font>
<font color="red"> 548.             label_output = self.handle_label(label, **options)</font>
<font color="red"> 549.             if label_output:</font>
<font color="red"> 550.                 output.append(label_output)</font>
<font color="red"> 551.         return '\n'.join(output)</font>
<font color="black"> 552. </font>
<font color="green"> 553.     def handle_label(self, label, **options):</font>
<font color="black"> 554.         &quot;&quot;&quot;</font>
<font color="black"> 555.         Perform the command's actions for ``label``, which will be the</font>
<font color="black"> 556.         string as given on the command line.</font>
<font color="black"> 557.         &quot;&quot;&quot;</font>
<font color="red"> 558.         raise NotImplementedError('subclasses of LabelCommand must provide a handle_label() method')</font>
<font color="black"> 559. </font>
<font color="black"> 560. </font>
<font color="green"> 561. class NoArgsCommand(BaseCommand):</font>
<font color="black"> 562.     &quot;&quot;&quot;</font>
<font color="black"> 563.     A command which takes no arguments on the command line.</font>
<font color="black"> 564. </font>
<font color="black"> 565.     Rather than implementing ``handle()``, subclasses must implement</font>
<font color="black"> 566.     ``handle_noargs()``; ``handle()`` itself is overridden to ensure</font>
<font color="black"> 567.     no arguments are passed to the command.</font>
<font color="black"> 568. </font>
<font color="black"> 569.     Attempting to pass arguments will raise ``CommandError``.</font>
<font color="green"> 570.     &quot;&quot;&quot;</font>
<font color="green"> 571.     args = ''</font>
<font color="black"> 572. </font>
<font color="green"> 573.     def __init__(self):</font>
<font color="red"> 574.         warnings.warn(</font>
<font color="red"> 575.             &quot;NoArgsCommand class is deprecated and will be removed in Django 1.10. &quot;</font>
<font color="black"> 576.             &quot;Use BaseCommand instead, which takes no arguments by default.&quot;,</font>
<font color="red"> 577.             RemovedInDjango110Warning</font>
<font color="black"> 578.         )</font>
<font color="red"> 579.         super(NoArgsCommand, self).__init__()</font>
<font color="black"> 580. </font>
<font color="green"> 581.     def handle(self, *args, **options):</font>
<font color="red"> 582.         if args:</font>
<font color="red"> 583.             raise CommandError(&quot;Command doesn't accept any arguments&quot;)</font>
<font color="red"> 584.         return self.handle_noargs(**options)</font>
<font color="black"> 585. </font>
<font color="green"> 586.     def handle_noargs(self, **options):</font>
<font color="black"> 587.         &quot;&quot;&quot;</font>
<font color="black"> 588.         Perform this command's actions.</font>
<font color="black"> 589.         &quot;&quot;&quot;</font>
<font color="red"> 590.         raise NotImplementedError('subclasses of NoArgsCommand must provide a handle_noargs() method')</font>
</pre>

