source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/migrations/loader.py</b><br>


file stats: <b>193 lines, 111 executed: 57.5% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import os</font>
<font color="green">   4. import sys</font>
<font color="green">   5. from importlib import import_module</font>
<font color="black">   6. </font>
<font color="green">   7. from django.apps import apps</font>
<font color="green">   8. from django.conf import settings</font>
<font color="green">   9. from django.db.migrations.graph import MigrationGraph</font>
<font color="green">  10. from django.db.migrations.recorder import MigrationRecorder</font>
<font color="green">  11. from django.utils import six</font>
<font color="black">  12. </font>
<font color="green">  13. from .exceptions import AmbiguityError, BadMigrationError, NodeNotFoundError</font>
<font color="black">  14. </font>
<font color="green">  15. MIGRATIONS_MODULE_NAME = 'migrations'</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. class MigrationLoader(object):</font>
<font color="black">  19.     &quot;&quot;&quot;</font>
<font color="black">  20.     Loads migration files from disk, and their status from the database.</font>
<font color="black">  21. </font>
<font color="black">  22.     Migration files are expected to live in the &quot;migrations&quot; directory of</font>
<font color="black">  23.     an app. Their names are entirely unimportant from a code perspective,</font>
<font color="black">  24.     but will probably follow the 1234_name.py convention.</font>
<font color="black">  25. </font>
<font color="black">  26.     On initialization, this class will scan those directories, and open and</font>
<font color="black">  27.     read the python files, looking for a class called Migration, which should</font>
<font color="black">  28.     inherit from django.db.migrations.Migration. See</font>
<font color="black">  29.     django.db.migrations.migration for what that looks like.</font>
<font color="black">  30. </font>
<font color="black">  31.     Some migrations will be marked as &quot;replacing&quot; another set of migrations.</font>
<font color="black">  32.     These are loaded into a separate set of migrations away from the main ones.</font>
<font color="black">  33.     If all the migrations they replace are either unapplied or missing from</font>
<font color="black">  34.     disk, then they are injected into the main set, replacing the named migrations.</font>
<font color="black">  35.     Any dependency pointers to the replaced migrations are re-pointed to the</font>
<font color="black">  36.     new migration.</font>
<font color="black">  37. </font>
<font color="black">  38.     This does mean that this class MUST also talk to the database as well as</font>
<font color="black">  39.     to disk, but this is probably fine. We're already not just operating</font>
<font color="black">  40.     in memory.</font>
<font color="green">  41.     &quot;&quot;&quot;</font>
<font color="black">  42. </font>
<font color="green">  43.     def __init__(self, connection, load=True, ignore_no_migrations=False):</font>
<font color="green">  44.         self.connection = connection</font>
<font color="green">  45.         self.disk_migrations = None</font>
<font color="green">  46.         self.applied_migrations = None</font>
<font color="green">  47.         self.ignore_no_migrations = ignore_no_migrations</font>
<font color="green">  48.         if load:</font>
<font color="green">  49.             self.build_graph()</font>
<font color="black">  50. </font>
<font color="green">  51.     @classmethod</font>
<font color="black">  52.     def migrations_module(cls, app_label):</font>
<font color="green">  53.         if app_label in settings.MIGRATION_MODULES:</font>
<font color="red">  54.             return settings.MIGRATION_MODULES[app_label]</font>
<font color="black">  55.         else:</font>
<font color="green">  56.             app_package_name = apps.get_app_config(app_label).name</font>
<font color="green">  57.             return '%s.%s' % (app_package_name, MIGRATIONS_MODULE_NAME)</font>
<font color="black">  58. </font>
<font color="green">  59.     def load_disk(self):</font>
<font color="black">  60.         &quot;&quot;&quot;</font>
<font color="black">  61.         Loads the migrations from all INSTALLED_APPS from disk.</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="green">  63.         self.disk_migrations = {}</font>
<font color="green">  64.         self.unmigrated_apps = set()</font>
<font color="green">  65.         self.migrated_apps = set()</font>
<font color="green">  66.         for app_config in apps.get_app_configs():</font>
<font color="black">  67.             # Get the migrations module directory</font>
<font color="green">  68.             module_name = self.migrations_module(app_config.label)</font>
<font color="green">  69.             if module_name is None:</font>
<font color="red">  70.                 self.unmigrated_apps.add(app_config.label)</font>
<font color="red">  71.                 continue</font>
<font color="green">  72.             was_loaded = module_name in sys.modules</font>
<font color="green">  73.             try:</font>
<font color="green">  74.                 module = import_module(module_name)</font>
<font color="green">  75.             except ImportError as e:</font>
<font color="black">  76.                 # I hate doing this, but I don't want to squash other import errors.</font>
<font color="black">  77.                 # Might be better to try a directory check directly.</font>
<font color="green">  78.                 if &quot;No module named&quot; in str(e) and MIGRATIONS_MODULE_NAME in str(e):</font>
<font color="green">  79.                     self.unmigrated_apps.add(app_config.label)</font>
<font color="green">  80.                     continue</font>
<font color="red">  81.                 raise</font>
<font color="black">  82.             else:</font>
<font color="black">  83.                 # PY3 will happily import empty dirs as namespaces.</font>
<font color="green">  84.                 if not hasattr(module, '__file__'):</font>
<font color="red">  85.                     self.unmigrated_apps.add(app_config.label)</font>
<font color="red">  86.                     continue</font>
<font color="black">  87.                 # Module is not a package (e.g. migrations.py).</font>
<font color="green">  88.                 if not hasattr(module, '__path__'):</font>
<font color="red">  89.                     self.unmigrated_apps.add(app_config.label)</font>
<font color="red">  90.                     continue</font>
<font color="black">  91.                 # Force a reload if it's already loaded (tests need this)</font>
<font color="green">  92.                 if was_loaded:</font>
<font color="green">  93.                     six.moves.reload_module(module)</font>
<font color="green">  94.             self.migrated_apps.add(app_config.label)</font>
<font color="green">  95.             directory = os.path.dirname(module.__file__)</font>
<font color="black">  96.             # Scan for .py files</font>
<font color="green">  97.             migration_names = set()</font>
<font color="green">  98.             for name in os.listdir(directory):</font>
<font color="green">  99.                 if name.endswith(&quot;.py&quot;):</font>
<font color="green"> 100.                     import_name = name.rsplit(&quot;.&quot;, 1)[0]</font>
<font color="green"> 101.                     if import_name[0] not in &quot;_.~&quot;:</font>
<font color="green"> 102.                         migration_names.add(import_name)</font>
<font color="black"> 103.             # Load them</font>
<font color="green"> 104.             for migration_name in migration_names:</font>
<font color="green"> 105.                 migration_module = import_module(&quot;%s.%s&quot; % (module_name, migration_name))</font>
<font color="green"> 106.                 if not hasattr(migration_module, &quot;Migration&quot;):</font>
<font color="red"> 107.                     raise BadMigrationError(</font>
<font color="red"> 108.                         &quot;Migration %s in app %s has no Migration class&quot; % (migration_name, app_config.label)</font>
<font color="black"> 109.                     )</font>
<font color="green"> 110.                 self.disk_migrations[app_config.label, migration_name] = migration_module.Migration(</font>
<font color="green"> 111.                     migration_name,</font>
<font color="green"> 112.                     app_config.label,</font>
<font color="black"> 113.                 )</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def get_migration(self, app_label, name_prefix):</font>
<font color="black"> 116.         &quot;Gets the migration exactly named, or raises `graph.NodeNotFoundError`&quot;</font>
<font color="red"> 117.         return self.graph.nodes[app_label, name_prefix]</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def get_migration_by_prefix(self, app_label, name_prefix):</font>
<font color="black"> 120.         &quot;Returns the migration(s) which match the given app label and name _prefix_&quot;</font>
<font color="black"> 121.         # Do the search</font>
<font color="red"> 122.         results = []</font>
<font color="red"> 123.         for l, n in self.disk_migrations:</font>
<font color="red"> 124.             if l == app_label and n.startswith(name_prefix):</font>
<font color="red"> 125.                 results.append((l, n))</font>
<font color="red"> 126.         if len(results) &gt; 1:</font>
<font color="red"> 127.             raise AmbiguityError(</font>
<font color="red"> 128.                 &quot;There is more than one migration for '%s' with the prefix '%s'&quot; % (app_label, name_prefix)</font>
<font color="black"> 129.             )</font>
<font color="red"> 130.         elif len(results) == 0:</font>
<font color="red"> 131.             raise KeyError(&quot;There no migrations for '%s' with the prefix '%s'&quot; % (app_label, name_prefix))</font>
<font color="black"> 132.         else:</font>
<font color="red"> 133.             return self.disk_migrations[results[0]]</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def check_key(self, key, current_app):</font>
<font color="green"> 136.         if (key[1] != &quot;__first__&quot; and key[1] != &quot;__latest__&quot;) or key in self.graph:</font>
<font color="green"> 137.             return key</font>
<font color="black"> 138.         # Special-case __first__, which means &quot;the first migration&quot; for</font>
<font color="black"> 139.         # migrated apps, and is ignored for unmigrated apps. It allows</font>
<font color="black"> 140.         # makemigrations to declare dependencies on apps before they even have</font>
<font color="black"> 141.         # migrations.</font>
<font color="green"> 142.         if key[0] == current_app:</font>
<font color="black"> 143.             # Ignore __first__ references to the same app (#22325)</font>
<font color="red"> 144.             return</font>
<font color="green"> 145.         if key[0] in self.unmigrated_apps:</font>
<font color="black"> 146.             # This app isn't migrated, but something depends on it.</font>
<font color="black"> 147.             # The models will get auto-added into the state, though</font>
<font color="black"> 148.             # so we're fine.</font>
<font color="red"> 149.             return</font>
<font color="green"> 150.         if key[0] in self.migrated_apps:</font>
<font color="green"> 151.             try:</font>
<font color="green"> 152.                 if key[1] == &quot;__first__&quot;:</font>
<font color="green"> 153.                     return list(self.graph.root_nodes(key[0]))[0]</font>
<font color="black"> 154.                 else:  # &quot;__latest__&quot;</font>
<font color="red"> 155.                     return list(self.graph.leaf_nodes(key[0]))[0]</font>
<font color="red"> 156.             except IndexError:</font>
<font color="red"> 157.                 if self.ignore_no_migrations:</font>
<font color="red"> 158.                     return None</font>
<font color="black"> 159.                 else:</font>
<font color="red"> 160.                     raise ValueError(&quot;Dependency on app with no migrations: %s&quot; % key[0])</font>
<font color="red"> 161.         raise ValueError(&quot;Dependency on unknown app: %s&quot; % key[0])</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def build_graph(self):</font>
<font color="black"> 164.         &quot;&quot;&quot;</font>
<font color="black"> 165.         Builds a migration dependency graph using both the disk and database.</font>
<font color="black"> 166.         You'll need to rebuild the graph if you apply migrations. This isn't</font>
<font color="black"> 167.         usually a problem as generally migration stuff runs in a one-shot process.</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="black"> 169.         # Load disk data</font>
<font color="green"> 170.         self.load_disk()</font>
<font color="black"> 171.         # Load database data</font>
<font color="green"> 172.         if self.connection is None:</font>
<font color="red"> 173.             self.applied_migrations = set()</font>
<font color="black"> 174.         else:</font>
<font color="green"> 175.             recorder = MigrationRecorder(self.connection)</font>
<font color="green"> 176.             self.applied_migrations = recorder.applied_migrations()</font>
<font color="black"> 177.         # Do a first pass to separate out replacing and non-replacing migrations</font>
<font color="green"> 178.         normal = {}</font>
<font color="green"> 179.         replacing = {}</font>
<font color="green"> 180.         for key, migration in self.disk_migrations.items():</font>
<font color="green"> 181.             if migration.replaces:</font>
<font color="red"> 182.                 replacing[key] = migration</font>
<font color="black"> 183.             else:</font>
<font color="green"> 184.                 normal[key] = migration</font>
<font color="black"> 185.         # Calculate reverse dependencies - i.e., for each migration, what depends on it?</font>
<font color="black"> 186.         # This is just for dependency re-pointing when applying replacements,</font>
<font color="black"> 187.         # so we ignore run_before here.</font>
<font color="green"> 188.         reverse_dependencies = {}</font>
<font color="green"> 189.         for key, migration in normal.items():</font>
<font color="green"> 190.             for parent in migration.dependencies:</font>
<font color="green"> 191.                 reverse_dependencies.setdefault(parent, set()).add(key)</font>
<font color="black"> 192.         # Remember the possible replacements to generate more meaningful error</font>
<font color="black"> 193.         # messages</font>
<font color="green"> 194.         reverse_replacements = {}</font>
<font color="green"> 195.         for key, migration in replacing.items():</font>
<font color="red"> 196.             for replaced in migration.replaces:</font>
<font color="red"> 197.                 reverse_replacements.setdefault(replaced, set()).add(key)</font>
<font color="black"> 198.         # Carry out replacements if we can - that is, if all replaced migrations</font>
<font color="black"> 199.         # are either unapplied or missing.</font>
<font color="green"> 200.         for key, migration in replacing.items():</font>
<font color="black"> 201.             # Ensure this replacement migration is not in applied_migrations</font>
<font color="red"> 202.             self.applied_migrations.discard(key)</font>
<font color="black"> 203.             # Do the check. We can replace if all our replace targets are</font>
<font color="black"> 204.             # applied, or if all of them are unapplied.</font>
<font color="red"> 205.             applied_statuses = [(target in self.applied_migrations) for target in migration.replaces]</font>
<font color="red"> 206.             can_replace = all(applied_statuses) or (not any(applied_statuses))</font>
<font color="red"> 207.             if not can_replace:</font>
<font color="red"> 208.                 continue</font>
<font color="black"> 209.             # Alright, time to replace. Step through the replaced migrations</font>
<font color="black"> 210.             # and remove, repointing dependencies if needs be.</font>
<font color="red"> 211.             for replaced in migration.replaces:</font>
<font color="red"> 212.                 if replaced in normal:</font>
<font color="black"> 213.                     # We don't care if the replaced migration doesn't exist;</font>
<font color="black"> 214.                     # the usage pattern here is to delete things after a while.</font>
<font color="red"> 215.                     del normal[replaced]</font>
<font color="red"> 216.                 for child_key in reverse_dependencies.get(replaced, set()):</font>
<font color="red"> 217.                     if child_key in migration.replaces:</font>
<font color="red"> 218.                         continue</font>
<font color="black"> 219.                     # List of migrations whose dependency on `replaced` needs</font>
<font color="black"> 220.                     # to be updated to a dependency on `key`.</font>
<font color="red"> 221.                     to_update = []</font>
<font color="black"> 222.                     # Child key may itself be replaced, in which case it might</font>
<font color="black"> 223.                     # not be in `normal` anymore (depending on whether we've</font>
<font color="black"> 224.                     # processed its replacement yet). If it's present, we go</font>
<font color="black"> 225.                     # ahead and update it; it may be deleted later on if it is</font>
<font color="black"> 226.                     # replaced, but there's no harm in updating it regardless.</font>
<font color="red"> 227.                     if child_key in normal:</font>
<font color="red"> 228.                         to_update.append(normal[child_key])</font>
<font color="black"> 229.                     # If the child key is replaced, we update its replacement's</font>
<font color="black"> 230.                     # dependencies too, if necessary. (We don't know if this</font>
<font color="black"> 231.                     # replacement will actually take effect or not, but either</font>
<font color="black"> 232.                     # way it's OK to update the replacing migration).</font>
<font color="red"> 233.                     if child_key in reverse_replacements:</font>
<font color="red"> 234.                         for replaces_child_key in reverse_replacements[child_key]:</font>
<font color="red"> 235.                             if replaced in replacing[replaces_child_key].dependencies:</font>
<font color="red"> 236.                                 to_update.append(replacing[replaces_child_key])</font>
<font color="black"> 237.                     # Actually perform the dependency update on all migrations</font>
<font color="black"> 238.                     # that require it.</font>
<font color="red"> 239.                     for migration_needing_update in to_update:</font>
<font color="red"> 240.                         migration_needing_update.dependencies.remove(replaced)</font>
<font color="red"> 241.                         migration_needing_update.dependencies.append(key)</font>
<font color="red"> 242.             normal[key] = migration</font>
<font color="black"> 243.             # Mark the replacement as applied if all its replaced ones are</font>
<font color="red"> 244.             if all(applied_statuses):</font>
<font color="red"> 245.                 self.applied_migrations.add(key)</font>
<font color="black"> 246.         # Store the replacement migrations for later checks</font>
<font color="green"> 247.         self.replacements = replacing</font>
<font color="black"> 248.         # Finally, make a graph and load everything into it</font>
<font color="green"> 249.         self.graph = MigrationGraph()</font>
<font color="green"> 250.         for key, migration in normal.items():</font>
<font color="green"> 251.             self.graph.add_node(key, migration)</font>
<font color="black"> 252. </font>
<font color="green"> 253.         def _reraise_missing_dependency(migration, missing, exc):</font>
<font color="black"> 254.             &quot;&quot;&quot;</font>
<font color="black"> 255.             Checks if ``missing`` could have been replaced by any squash</font>
<font color="black"> 256.             migration but wasn't because the the squash migration was partially</font>
<font color="black"> 257.             applied before. In that case raise a more understandable exception.</font>
<font color="black"> 258. </font>
<font color="black"> 259.             #23556</font>
<font color="black"> 260.             &quot;&quot;&quot;</font>
<font color="red"> 261.             if missing in reverse_replacements:</font>
<font color="red"> 262.                 candidates = reverse_replacements.get(missing, set())</font>
<font color="red"> 263.                 is_replaced = any(candidate in self.graph.nodes for candidate in candidates)</font>
<font color="red"> 264.                 if not is_replaced:</font>
<font color="red"> 265.                     tries = ', '.join('%s.%s' % c for c in candidates)</font>
<font color="red"> 266.                     exc_value = NodeNotFoundError(</font>
<font color="red"> 267.                         &quot;Migration {0} depends on nonexistent node ('{1}', '{2}'). &quot;</font>
<font color="black"> 268.                         &quot;Django tried to replace migration {1}.{2} with any of [{3}] &quot;</font>
<font color="black"> 269.                         &quot;but wasn't able to because some of the replaced migrations &quot;</font>
<font color="black"> 270.                         &quot;are already applied.&quot;.format(</font>
<font color="red"> 271.                             migration, missing[0], missing[1], tries</font>
<font color="black"> 272.                         ),</font>
<font color="red"> 273.                         missing)</font>
<font color="red"> 274.                     exc_value.__cause__ = exc</font>
<font color="red"> 275.                     six.reraise(NodeNotFoundError, exc_value, sys.exc_info()[2])</font>
<font color="red"> 276.             raise exc</font>
<font color="black"> 277. </font>
<font color="black"> 278.         # Add all internal dependencies first to ensure __first__ dependencies</font>
<font color="black"> 279.         # find the correct root node.</font>
<font color="green"> 280.         for key, migration in normal.items():</font>
<font color="green"> 281.             for parent in migration.dependencies:</font>
<font color="green"> 282.                 if parent[0] != key[0] or parent[1] == '__first__':</font>
<font color="black"> 283.                     # Ignore __first__ references to the same app (#22325)</font>
<font color="red"> 284.                     continue</font>
<font color="green"> 285.                 try:</font>
<font color="green"> 286.                     self.graph.add_dependency(migration, key, parent)</font>
<font color="red"> 287.                 except NodeNotFoundError as e:</font>
<font color="black"> 288.                     # Since we added &quot;key&quot; to the nodes before this implies</font>
<font color="black"> 289.                     # &quot;parent&quot; is not in there. To make the raised exception</font>
<font color="black"> 290.                     # more understandable we check if parent could have been</font>
<font color="black"> 291.                     # replaced but hasn't (eg partially applied squashed</font>
<font color="black"> 292.                     # migration)</font>
<font color="red"> 293.                     _reraise_missing_dependency(migration, parent, e)</font>
<font color="green"> 294.         for key, migration in normal.items():</font>
<font color="green"> 295.             for parent in migration.dependencies:</font>
<font color="green"> 296.                 if parent[0] == key[0]:</font>
<font color="black"> 297.                     # Internal dependencies already added.</font>
<font color="green"> 298.                     continue</font>
<font color="green"> 299.                 parent = self.check_key(parent, key[0])</font>
<font color="green"> 300.                 if parent is not None:</font>
<font color="green"> 301.                     try:</font>
<font color="green"> 302.                         self.graph.add_dependency(migration, key, parent)</font>
<font color="red"> 303.                     except NodeNotFoundError as e:</font>
<font color="black"> 304.                         # Since we added &quot;key&quot; to the nodes before this implies</font>
<font color="black"> 305.                         # &quot;parent&quot; is not in there.</font>
<font color="red"> 306.                         _reraise_missing_dependency(migration, parent, e)</font>
<font color="green"> 307.             for child in migration.run_before:</font>
<font color="red"> 308.                 child = self.check_key(child, key[0])</font>
<font color="red"> 309.                 if child is not None:</font>
<font color="red"> 310.                     try:</font>
<font color="red"> 311.                         self.graph.add_dependency(migration, child, key)</font>
<font color="red"> 312.                     except NodeNotFoundError as e:</font>
<font color="black"> 313.                         # Since we added &quot;key&quot; to the nodes before this implies</font>
<font color="black"> 314.                         # &quot;child&quot; is not in there.</font>
<font color="red"> 315.                         _reraise_missing_dependency(migration, child, e)</font>
<font color="black"> 316. </font>
<font color="green"> 317.     def detect_conflicts(self):</font>
<font color="black"> 318.         &quot;&quot;&quot;</font>
<font color="black"> 319.         Looks through the loaded graph and detects any conflicts - apps</font>
<font color="black"> 320.         with more than one leaf migration. Returns a dict of the app labels</font>
<font color="black"> 321.         that conflict with the migration names that conflict.</font>
<font color="black"> 322.         &quot;&quot;&quot;</font>
<font color="green"> 323.         seen_apps = {}</font>
<font color="green"> 324.         conflicting_apps = set()</font>
<font color="green"> 325.         for app_label, migration_name in self.graph.leaf_nodes():</font>
<font color="green"> 326.             if app_label in seen_apps:</font>
<font color="red"> 327.                 conflicting_apps.add(app_label)</font>
<font color="green"> 328.             seen_apps.setdefault(app_label, set()).add(migration_name)</font>
<font color="green"> 329.         return {app_label: seen_apps[app_label] for app_label in conflicting_apps}</font>
<font color="black"> 330. </font>
<font color="green"> 331.     def project_state(self, nodes=None, at_end=True):</font>
<font color="black"> 332.         &quot;&quot;&quot;</font>
<font color="black"> 333.         Returns a ProjectState object representing the most recent state</font>
<font color="black"> 334.         that the migrations we loaded represent.</font>
<font color="black"> 335. </font>
<font color="black"> 336.         See graph.make_state for the meaning of &quot;nodes&quot; and &quot;at_end&quot;</font>
<font color="black"> 337.         &quot;&quot;&quot;</font>
<font color="red"> 338.         return self.graph.make_state(nodes=nodes, at_end=at_end, real_apps=list(self.unmigrated_apps))</font>
</pre>

