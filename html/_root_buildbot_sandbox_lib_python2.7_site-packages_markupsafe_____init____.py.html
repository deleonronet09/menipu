source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/markupsafe/__init__.py</b><br>


file stats: <b>164 lines, 70 executed: 42.7% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     markupsafe</font>
<font color="black">   4.     ~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Implements a Markup string.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by Armin Ronacher.</font>
<font color="black">   9.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. import re</font>
<font color="green">  12. import string</font>
<font color="green">  13. from collections import Mapping</font>
<font color="green">  14. from markupsafe._compat import text_type, string_types, int_types, \</font>
<font color="black">  15.      unichr, iteritems, PY2</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. __all__ = ['Markup', 'soft_unicode', 'escape', 'escape_silent']</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. _striptags_re = re.compile(r'(&lt;!--.*?--&gt;|&lt;[^&gt;]*&gt;)')</font>
<font color="green">  22. _entity_re = re.compile(r'&amp;([^;]+);')</font>
<font color="black">  23. </font>
<font color="black">  24. </font>
<font color="green">  25. class Markup(text_type):</font>
<font color="black">  26.     r&quot;&quot;&quot;Marks a string as being safe for inclusion in HTML/XML output without</font>
<font color="black">  27.     needing to be escaped.  This implements the `__html__` interface a couple</font>
<font color="black">  28.     of frameworks and web applications use.  :class:`Markup` is a direct</font>
<font color="black">  29.     subclass of `unicode` and provides all the methods of `unicode` just that</font>
<font color="black">  30.     it escapes arguments passed and always returns `Markup`.</font>
<font color="black">  31. </font>
<font color="black">  32.     The `escape` function returns markup objects so that double escaping can't</font>
<font color="black">  33.     happen.</font>
<font color="black">  34. </font>
<font color="black">  35.     The constructor of the :class:`Markup` class can be used for three</font>
<font color="black">  36.     different things:  When passed an unicode object it's assumed to be safe,</font>
<font color="black">  37.     when passed an object with an HTML representation (has an `__html__`</font>
<font color="black">  38.     method) that representation is used, otherwise the object passed is</font>
<font color="black">  39.     converted into a unicode string and then assumed to be safe:</font>
<font color="black">  40. </font>
<font color="black">  41.     &gt;&gt;&gt; Markup(&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;)</font>
<font color="black">  42.     Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!')</font>
<font color="black">  43.     &gt;&gt;&gt; class Foo(object):</font>
<font color="black">  44.     ...  def __html__(self):</font>
<font color="black">  45.     ...   return '&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;'</font>
<font color="black">  46.     ...</font>
<font color="black">  47.     &gt;&gt;&gt; Markup(Foo())</font>
<font color="black">  48.     Markup(u'&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;')</font>
<font color="black">  49. </font>
<font color="black">  50.     If you want object passed being always treated as unsafe you can use the</font>
<font color="black">  51.     :meth:`escape` classmethod to create a :class:`Markup` object:</font>
<font color="black">  52. </font>
<font color="black">  53.     &gt;&gt;&gt; Markup.escape(&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;)</font>
<font color="black">  54.     Markup(u'Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!')</font>
<font color="black">  55. </font>
<font color="black">  56.     Operations on a markup string are markup aware which means that all</font>
<font color="black">  57.     arguments are passed through the :func:`escape` function:</font>
<font color="black">  58. </font>
<font color="black">  59.     &gt;&gt;&gt; em = Markup(&quot;&lt;em&gt;%s&lt;/em&gt;&quot;)</font>
<font color="black">  60.     &gt;&gt;&gt; em % &quot;foo &amp; bar&quot;</font>
<font color="black">  61.     Markup(u'&lt;em&gt;foo &amp;amp; bar&lt;/em&gt;')</font>
<font color="black">  62.     &gt;&gt;&gt; strong = Markup(&quot;&lt;strong&gt;%(text)s&lt;/strong&gt;&quot;)</font>
<font color="black">  63.     &gt;&gt;&gt; strong % {'text': '&lt;blink&gt;hacker here&lt;/blink&gt;'}</font>
<font color="black">  64.     Markup(u'&lt;strong&gt;&amp;lt;blink&amp;gt;hacker here&amp;lt;/blink&amp;gt;&lt;/strong&gt;')</font>
<font color="black">  65.     &gt;&gt;&gt; Markup(&quot;&lt;em&gt;Hello&lt;/em&gt; &quot;) + &quot;&lt;foo&gt;&quot;</font>
<font color="black">  66.     Markup(u'&lt;em&gt;Hello&lt;/em&gt; &amp;lt;foo&amp;gt;')</font>
<font color="green">  67.     &quot;&quot;&quot;</font>
<font color="green">  68.     __slots__ = ()</font>
<font color="black">  69. </font>
<font color="green">  70.     def __new__(cls, base=u'', encoding=None, errors='strict'):</font>
<font color="red">  71.         if hasattr(base, '__html__'):</font>
<font color="red">  72.             base = base.__html__()</font>
<font color="red">  73.         if encoding is None:</font>
<font color="red">  74.             return text_type.__new__(cls, base)</font>
<font color="red">  75.         return text_type.__new__(cls, base, encoding, errors)</font>
<font color="black">  76. </font>
<font color="green">  77.     def __html__(self):</font>
<font color="red">  78.         return self</font>
<font color="black">  79. </font>
<font color="green">  80.     def __add__(self, other):</font>
<font color="red">  81.         if isinstance(other, string_types) or hasattr(other, '__html__'):</font>
<font color="red">  82.             return self.__class__(super(Markup, self).__add__(self.escape(other)))</font>
<font color="red">  83.         return NotImplemented</font>
<font color="black">  84. </font>
<font color="green">  85.     def __radd__(self, other):</font>
<font color="red">  86.         if hasattr(other, '__html__') or isinstance(other, string_types):</font>
<font color="red">  87.             return self.escape(other).__add__(self)</font>
<font color="red">  88.         return NotImplemented</font>
<font color="black">  89. </font>
<font color="green">  90.     def __mul__(self, num):</font>
<font color="red">  91.         if isinstance(num, int_types):</font>
<font color="red">  92.             return self.__class__(text_type.__mul__(self, num))</font>
<font color="red">  93.         return NotImplemented</font>
<font color="green">  94.     __rmul__ = __mul__</font>
<font color="black">  95. </font>
<font color="green">  96.     def __mod__(self, arg):</font>
<font color="red">  97.         if isinstance(arg, tuple):</font>
<font color="red">  98.             arg = tuple(_MarkupEscapeHelper(x, self.escape) for x in arg)</font>
<font color="black">  99.         else:</font>
<font color="red"> 100.             arg = _MarkupEscapeHelper(arg, self.escape)</font>
<font color="red"> 101.         return self.__class__(text_type.__mod__(self, arg))</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def __repr__(self):</font>
<font color="red"> 104.         return '%s(%s)' % (</font>
<font color="red"> 105.             self.__class__.__name__,</font>
<font color="red"> 106.             text_type.__repr__(self)</font>
<font color="black"> 107.         )</font>
<font color="black"> 108. </font>
<font color="green"> 109.     def join(self, seq):</font>
<font color="red"> 110.         return self.__class__(text_type.join(self, map(self.escape, seq)))</font>
<font color="green"> 111.     join.__doc__ = text_type.join.__doc__</font>
<font color="black"> 112. </font>
<font color="green"> 113.     def split(self, *args, **kwargs):</font>
<font color="red"> 114.         return list(map(self.__class__, text_type.split(self, *args, **kwargs)))</font>
<font color="green"> 115.     split.__doc__ = text_type.split.__doc__</font>
<font color="black"> 116. </font>
<font color="green"> 117.     def rsplit(self, *args, **kwargs):</font>
<font color="red"> 118.         return list(map(self.__class__, text_type.rsplit(self, *args, **kwargs)))</font>
<font color="green"> 119.     rsplit.__doc__ = text_type.rsplit.__doc__</font>
<font color="black"> 120. </font>
<font color="green"> 121.     def splitlines(self, *args, **kwargs):</font>
<font color="red"> 122.         return list(map(self.__class__, text_type.splitlines(</font>
<font color="red"> 123.             self, *args, **kwargs)))</font>
<font color="green"> 124.     splitlines.__doc__ = text_type.splitlines.__doc__</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def unescape(self):</font>
<font color="black"> 127.         r&quot;&quot;&quot;Unescape markup again into an text_type string.  This also resolves</font>
<font color="black"> 128.         known HTML4 and XHTML entities:</font>
<font color="black"> 129. </font>
<font color="black"> 130.         &gt;&gt;&gt; Markup(&quot;Main &amp;raquo; &lt;em&gt;About&lt;/em&gt;&quot;).unescape()</font>
<font color="black"> 131.         u'Main \xbb &lt;em&gt;About&lt;/em&gt;'</font>
<font color="black"> 132.         &quot;&quot;&quot;</font>
<font color="red"> 133.         from markupsafe._constants import HTML_ENTITIES</font>
<font color="red"> 134.         def handle_match(m):</font>
<font color="red"> 135.             name = m.group(1)</font>
<font color="red"> 136.             if name in HTML_ENTITIES:</font>
<font color="red"> 137.                 return unichr(HTML_ENTITIES[name])</font>
<font color="red"> 138.             try:</font>
<font color="red"> 139.                 if name[:2] in ('#x', '#X'):</font>
<font color="red"> 140.                     return unichr(int(name[2:], 16))</font>
<font color="red"> 141.                 elif name.startswith('#'):</font>
<font color="red"> 142.                     return unichr(int(name[1:]))</font>
<font color="red"> 143.             except ValueError:</font>
<font color="red"> 144.                 pass</font>
<font color="red"> 145.             return u''</font>
<font color="red"> 146.         return _entity_re.sub(handle_match, text_type(self))</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def striptags(self):</font>
<font color="black"> 149.         r&quot;&quot;&quot;Unescape markup into an text_type string and strip all tags.  This</font>
<font color="black"> 150.         also resolves known HTML4 and XHTML entities.  Whitespace is</font>
<font color="black"> 151.         normalized to one:</font>
<font color="black"> 152. </font>
<font color="black"> 153.         &gt;&gt;&gt; Markup(&quot;Main &amp;raquo;  &lt;em&gt;About&lt;/em&gt;&quot;).striptags()</font>
<font color="black"> 154.         u'Main \xbb About'</font>
<font color="black"> 155.         &quot;&quot;&quot;</font>
<font color="red"> 156.         stripped = u' '.join(_striptags_re.sub('', self).split())</font>
<font color="red"> 157.         return Markup(stripped).unescape()</font>
<font color="black"> 158. </font>
<font color="green"> 159.     @classmethod</font>
<font color="black"> 160.     def escape(cls, s):</font>
<font color="black"> 161.         &quot;&quot;&quot;Escape the string.  Works like :func:`escape` with the difference</font>
<font color="black"> 162.         that for subclasses of :class:`Markup` this function would return the</font>
<font color="black"> 163.         correct subclass.</font>
<font color="black"> 164.         &quot;&quot;&quot;</font>
<font color="red"> 165.         rv = escape(s)</font>
<font color="red"> 166.         if rv.__class__ is not cls:</font>
<font color="red"> 167.             return cls(rv)</font>
<font color="red"> 168.         return rv</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def make_simple_escaping_wrapper(name):</font>
<font color="green"> 171.         orig = getattr(text_type, name)</font>
<font color="green"> 172.         def func(self, *args, **kwargs):</font>
<font color="red"> 173.             args = _escape_argspec(list(args), enumerate(args), self.escape)</font>
<font color="red"> 174.             _escape_argspec(kwargs, iteritems(kwargs), self.escape)</font>
<font color="red"> 175.             return self.__class__(orig(self, *args, **kwargs))</font>
<font color="green"> 176.         func.__name__ = orig.__name__</font>
<font color="green"> 177.         func.__doc__ = orig.__doc__</font>
<font color="green"> 178.         return func</font>
<font color="black"> 179. </font>
<font color="green"> 180.     for method in '__getitem__', 'capitalize', \</font>
<font color="black"> 181.                   'title', 'lower', 'upper', 'replace', 'ljust', \</font>
<font color="black"> 182.                   'rjust', 'lstrip', 'rstrip', 'center', 'strip', \</font>
<font color="green"> 183.                   'translate', 'expandtabs', 'swapcase', 'zfill':</font>
<font color="green"> 184.         locals()[method] = make_simple_escaping_wrapper(method)</font>
<font color="black"> 185. </font>
<font color="black"> 186.     # new in python 2.5</font>
<font color="green"> 187.     if hasattr(text_type, 'partition'):</font>
<font color="green"> 188.         def partition(self, sep):</font>
<font color="red"> 189.             return tuple(map(self.__class__,</font>
<font color="red"> 190.                              text_type.partition(self, self.escape(sep))))</font>
<font color="green"> 191.         def rpartition(self, sep):</font>
<font color="red"> 192.             return tuple(map(self.__class__,</font>
<font color="red"> 193.                              text_type.rpartition(self, self.escape(sep))))</font>
<font color="black"> 194. </font>
<font color="black"> 195.     # new in python 2.6</font>
<font color="green"> 196.     if hasattr(text_type, 'format'):</font>
<font color="green"> 197.         def format(*args, **kwargs):</font>
<font color="red"> 198.             self, args = args[0], args[1:]</font>
<font color="red"> 199.             formatter = EscapeFormatter(self.escape)</font>
<font color="red"> 200.             kwargs = _MagicFormatMapping(args, kwargs)</font>
<font color="red"> 201.             return self.__class__(formatter.vformat(self, args, kwargs))</font>
<font color="black"> 202. </font>
<font color="green"> 203.         def __html_format__(self, format_spec):</font>
<font color="red"> 204.             if format_spec:</font>
<font color="red"> 205.                 raise ValueError('Unsupported format specification '</font>
<font color="black"> 206.                                  'for Markup.')</font>
<font color="red"> 207.             return self</font>
<font color="black"> 208. </font>
<font color="black"> 209.     # not in python 3</font>
<font color="green"> 210.     if hasattr(text_type, '__getslice__'):</font>
<font color="green"> 211.         __getslice__ = make_simple_escaping_wrapper('__getslice__')</font>
<font color="black"> 212. </font>
<font color="green"> 213.     del method, make_simple_escaping_wrapper</font>
<font color="black"> 214. </font>
<font color="black"> 215. </font>
<font color="green"> 216. class _MagicFormatMapping(Mapping):</font>
<font color="black"> 217.     &quot;&quot;&quot;This class implements a dummy wrapper to fix a bug in the Python</font>
<font color="black"> 218.     standard library for string formatting.</font>
<font color="black"> 219. </font>
<font color="black"> 220.     See http://bugs.python.org/issue13598 for information about why</font>
<font color="black"> 221.     this is necessary.</font>
<font color="green"> 222.     &quot;&quot;&quot;</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def __init__(self, args, kwargs):</font>
<font color="red"> 225.         self._args = args</font>
<font color="red"> 226.         self._kwargs = kwargs</font>
<font color="red"> 227.         self._last_index = 0</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def __getitem__(self, key):</font>
<font color="red"> 230.         if key == '':</font>
<font color="red"> 231.             idx = self._last_index</font>
<font color="red"> 232.             self._last_index += 1</font>
<font color="red"> 233.             try:</font>
<font color="red"> 234.                 return self._args[idx]</font>
<font color="red"> 235.             except LookupError:</font>
<font color="red"> 236.                 pass</font>
<font color="red"> 237.             key = str(idx)</font>
<font color="red"> 238.         return self._kwargs[key]</font>
<font color="black"> 239. </font>
<font color="green"> 240.     def __iter__(self):</font>
<font color="red"> 241.         return iter(self._kwargs)</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def __len__(self):</font>
<font color="red"> 244.         return len(self._kwargs)</font>
<font color="black"> 245. </font>
<font color="black"> 246. </font>
<font color="green"> 247. if hasattr(text_type, 'format'):</font>
<font color="green"> 248.     class EscapeFormatter(string.Formatter):</font>
<font color="black"> 249. </font>
<font color="green"> 250.         def __init__(self, escape):</font>
<font color="red"> 251.             self.escape = escape</font>
<font color="black"> 252. </font>
<font color="green"> 253.         def format_field(self, value, format_spec):</font>
<font color="red"> 254.             if hasattr(value, '__html_format__'):</font>
<font color="red"> 255.                 rv = value.__html_format__(format_spec)</font>
<font color="red"> 256.             elif hasattr(value, '__html__'):</font>
<font color="red"> 257.                 if format_spec:</font>
<font color="red"> 258.                     raise ValueError('No format specification allowed '</font>
<font color="black"> 259.                                      'when formatting an object with '</font>
<font color="black"> 260.                                      'its __html__ method.')</font>
<font color="red"> 261.                 rv = value.__html__()</font>
<font color="black"> 262.             else:</font>
<font color="red"> 263.                 rv = string.Formatter.format_field(self, value, format_spec)</font>
<font color="red"> 264.             return text_type(self.escape(rv))</font>
<font color="black"> 265. </font>
<font color="black"> 266. </font>
<font color="green"> 267. def _escape_argspec(obj, iterable, escape):</font>
<font color="black"> 268.     &quot;&quot;&quot;Helper for various string-wrapped functions.&quot;&quot;&quot;</font>
<font color="red"> 269.     for key, value in iterable:</font>
<font color="red"> 270.         if hasattr(value, '__html__') or isinstance(value, string_types):</font>
<font color="red"> 271.             obj[key] = escape(value)</font>
<font color="red"> 272.     return obj</font>
<font color="black"> 273. </font>
<font color="black"> 274. </font>
<font color="green"> 275. class _MarkupEscapeHelper(object):</font>
<font color="green"> 276.     &quot;&quot;&quot;Helper for Markup.__mod__&quot;&quot;&quot;</font>
<font color="black"> 277. </font>
<font color="green"> 278.     def __init__(self, obj, escape):</font>
<font color="red"> 279.         self.obj = obj</font>
<font color="red"> 280.         self.escape = escape</font>
<font color="black"> 281. </font>
<font color="green"> 282.     __getitem__ = lambda s, x: _MarkupEscapeHelper(s.obj[x], s.escape)</font>
<font color="green"> 283.     __unicode__ = __str__ = lambda s: text_type(s.escape(s.obj))</font>
<font color="green"> 284.     __repr__ = lambda s: str(s.escape(repr(s.obj)))</font>
<font color="green"> 285.     __int__ = lambda s: int(s.obj)</font>
<font color="green"> 286.     __float__ = lambda s: float(s.obj)</font>
<font color="black"> 287. </font>
<font color="black"> 288. </font>
<font color="black"> 289. # we have to import it down here as the speedups and native</font>
<font color="black"> 290. # modules imports the markup type which is define above.</font>
<font color="green"> 291. try:</font>
<font color="green"> 292.     from markupsafe._speedups import escape, escape_silent, soft_unicode</font>
<font color="red"> 293. except ImportError:</font>
<font color="red"> 294.     from markupsafe._native import escape, escape_silent, soft_unicode</font>
<font color="black"> 295. </font>
<font color="green"> 296. if not PY2:</font>
<font color="red"> 297.     soft_str = soft_unicode</font>
<font color="red"> 298.     __all__.append('soft_str')</font>
</pre>

