source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/validators.py</b><br>


file stats: <b>291 lines, 162 executed: 55.7% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import re</font>
<font color="black">   4. </font>
<font color="green">   5. from django.core.exceptions import ValidationError</font>
<font color="green">   6. from django.utils import six</font>
<font color="green">   7. from django.utils.deconstruct import deconstructible</font>
<font color="green">   8. from django.utils.encoding import force_text</font>
<font color="green">   9. from django.utils.functional import SimpleLazyObject</font>
<font color="green">  10. from django.utils.ipv6 import is_valid_ipv6_address</font>
<font color="green">  11. from django.utils.six.moves.urllib.parse import urlsplit, urlunsplit</font>
<font color="green">  12. from django.utils.translation import ugettext_lazy as _, ungettext_lazy</font>
<font color="black">  13. </font>
<font color="black">  14. # These values, if given to validate(), will trigger the self.required check.</font>
<font color="green">  15. EMPTY_VALUES = (None, '', [], (), {})</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. def _lazy_re_compile(regex, flags=0):</font>
<font color="black">  19.     &quot;&quot;&quot;Lazily compile a regex with flags.&quot;&quot;&quot;</font>
<font color="green">  20.     def _compile():</font>
<font color="black">  21.         # Compile the regex if it was not passed pre-compiled.</font>
<font color="red">  22.         if isinstance(regex, six.string_types):</font>
<font color="red">  23.             return re.compile(regex, flags)</font>
<font color="black">  24.         else:</font>
<font color="red">  25.             assert not flags, &quot;flags must be empty if regex is passed pre-compiled&quot;</font>
<font color="red">  26.             return regex</font>
<font color="green">  27.     return SimpleLazyObject(_compile)</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. @deconstructible</font>
<font color="green">  31. class RegexValidator(object):</font>
<font color="green">  32.     regex = ''</font>
<font color="green">  33.     message = _('Enter a valid value.')</font>
<font color="green">  34.     code = 'invalid'</font>
<font color="green">  35.     inverse_match = False</font>
<font color="green">  36.     flags = 0</font>
<font color="black">  37. </font>
<font color="green">  38.     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):</font>
<font color="green">  39.         if regex is not None:</font>
<font color="green">  40.             self.regex = regex</font>
<font color="green">  41.         if message is not None:</font>
<font color="green">  42.             self.message = message</font>
<font color="green">  43.         if code is not None:</font>
<font color="green">  44.             self.code = code</font>
<font color="green">  45.         if inverse_match is not None:</font>
<font color="red">  46.             self.inverse_match = inverse_match</font>
<font color="green">  47.         if flags is not None:</font>
<font color="red">  48.             self.flags = flags</font>
<font color="green">  49.         if self.flags and not isinstance(self.regex, six.string_types):</font>
<font color="red">  50.             raise TypeError(&quot;If the flags are set, regex must be a regular expression string.&quot;)</font>
<font color="black">  51. </font>
<font color="green">  52.         self.regex = _lazy_re_compile(self.regex, self.flags)</font>
<font color="black">  53. </font>
<font color="green">  54.     def __call__(self, value):</font>
<font color="black">  55.         &quot;&quot;&quot;</font>
<font color="black">  56.         Validates that the input matches the regular expression</font>
<font color="black">  57.         if inverse_match is False, otherwise raises ValidationError.</font>
<font color="black">  58.         &quot;&quot;&quot;</font>
<font color="red">  59.         if not (self.inverse_match is not bool(self.regex.search(</font>
<font color="red">  60.                 force_text(value)))):</font>
<font color="red">  61.             raise ValidationError(self.message, code=self.code)</font>
<font color="black">  62. </font>
<font color="green">  63.     def __eq__(self, other):</font>
<font color="black">  64.         return (</font>
<font color="red">  65.             isinstance(other, RegexValidator) and</font>
<font color="red">  66.             self.regex.pattern == other.regex.pattern and</font>
<font color="red">  67.             self.regex.flags == other.regex.flags and</font>
<font color="red">  68.             (self.message == other.message) and</font>
<font color="red">  69.             (self.code == other.code) and</font>
<font color="red">  70.             (self.inverse_match == other.inverse_match)</font>
<font color="black">  71.         )</font>
<font color="black">  72. </font>
<font color="green">  73.     def __ne__(self, other):</font>
<font color="red">  74.         return not (self == other)</font>
<font color="black">  75. </font>
<font color="black">  76. </font>
<font color="green">  77. @deconstructible</font>
<font color="green">  78. class URLValidator(RegexValidator):</font>
<font color="green">  79.     ul = '\u00a1-\uffff'  # unicode letters range (must be a unicode string, not a raw string)</font>
<font color="black">  80. </font>
<font color="black">  81.     # IP patterns</font>
<font color="green">  82.     ipv4_re = r'(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}'</font>
<font color="green">  83.     ipv6_re = r'\[[0-9a-f:\.]+\]'  # (simple regex, validated later)</font>
<font color="black">  84. </font>
<font color="black">  85.     # Host patterns</font>
<font color="green">  86.     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]*[a-z' + ul + r'0-9])?'</font>
<font color="green">  87.     domain_re = r'(?:\.(?!-)[a-z' + ul + r'0-9-]+(?&lt;!-))*'</font>
<font color="green">  88.     tld_re = r'\.(?:[a-z' + ul + r']{2,}|xn--[a-z0-9]+)\.?'</font>
<font color="green">  89.     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'</font>
<font color="black">  90. </font>
<font color="green">  91.     regex = _lazy_re_compile(</font>
<font color="black">  92.         r'^(?:[a-z0-9\.\-]*)://'  # scheme is validated separately</font>
<font color="black">  93.         r'(?:\S+(?::\S*)?@)?'  # user:pass authentication</font>
<font color="green">  94.         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'</font>
<font color="black">  95.         r'(?::\d{2,5})?'  # port</font>
<font color="black">  96.         r'(?:[/?#][^\s]*)?'  # resource path</font>
<font color="green">  97.         r'\Z', re.IGNORECASE)</font>
<font color="green">  98.     message = _('Enter a valid URL.')</font>
<font color="green">  99.     schemes = ['http', 'https', 'ftp', 'ftps']</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def __init__(self, schemes=None, **kwargs):</font>
<font color="green"> 102.         super(URLValidator, self).__init__(**kwargs)</font>
<font color="green"> 103.         if schemes is not None:</font>
<font color="red"> 104.             self.schemes = schemes</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def __call__(self, value):</font>
<font color="red"> 107.         value = force_text(value)</font>
<font color="black"> 108.         # Check first if the scheme is valid</font>
<font color="red"> 109.         scheme = value.split('://')[0].lower()</font>
<font color="red"> 110.         if scheme not in self.schemes:</font>
<font color="red"> 111.             raise ValidationError(self.message, code=self.code)</font>
<font color="black"> 112. </font>
<font color="black"> 113.         # Then check full URL</font>
<font color="red"> 114.         try:</font>
<font color="red"> 115.             super(URLValidator, self).__call__(value)</font>
<font color="red"> 116.         except ValidationError as e:</font>
<font color="black"> 117.             # Trivial case failed. Try for possible IDN domain</font>
<font color="red"> 118.             if value:</font>
<font color="red"> 119.                 scheme, netloc, path, query, fragment = urlsplit(value)</font>
<font color="red"> 120.                 try:</font>
<font color="red"> 121.                     netloc = netloc.encode('idna').decode('ascii')  # IDN -&gt; ACE</font>
<font color="red"> 122.                 except UnicodeError:  # invalid domain part</font>
<font color="red"> 123.                     raise e</font>
<font color="red"> 124.                 url = urlunsplit((scheme, netloc, path, query, fragment))</font>
<font color="red"> 125.                 super(URLValidator, self).__call__(url)</font>
<font color="black"> 126.             else:</font>
<font color="red"> 127.                 raise</font>
<font color="black"> 128.         else:</font>
<font color="black"> 129.             # Now verify IPv6 in the netloc part</font>
<font color="red"> 130.             host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(value).netloc)</font>
<font color="red"> 131.             if host_match:</font>
<font color="red"> 132.                 potential_ip = host_match.groups()[0]</font>
<font color="red"> 133.                 try:</font>
<font color="red"> 134.                     validate_ipv6_address(potential_ip)</font>
<font color="red"> 135.                 except ValidationError:</font>
<font color="red"> 136.                     raise ValidationError(self.message, code=self.code)</font>
<font color="red"> 137.             url = value</font>
<font color="black"> 138. </font>
<font color="green"> 139. integer_validator = RegexValidator(</font>
<font color="green"> 140.     _lazy_re_compile('^-?\d+\Z'),</font>
<font color="green"> 141.     message=_('Enter a valid integer.'),</font>
<font color="green"> 142.     code='invalid',</font>
<font color="black"> 143. )</font>
<font color="black"> 144. </font>
<font color="black"> 145. </font>
<font color="green"> 146. def validate_integer(value):</font>
<font color="red"> 147.     return integer_validator(value)</font>
<font color="black"> 148. </font>
<font color="black"> 149. </font>
<font color="green"> 150. @deconstructible</font>
<font color="green"> 151. class EmailValidator(object):</font>
<font color="green"> 152.     message = _('Enter a valid email address.')</font>
<font color="green"> 153.     code = 'invalid'</font>
<font color="green"> 154.     user_regex = _lazy_re_compile(</font>
<font color="green"> 155.         r&quot;(^[-!#$%&amp;'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&amp;'*+/=?^_`{}|~0-9A-Z]+)*\Z&quot;  # dot-atom</font>
<font color="black"> 156.         r'|^&quot;([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*&quot;\Z)',  # quoted-string</font>
<font color="green"> 157.         re.IGNORECASE)</font>
<font color="green"> 158.     domain_regex = _lazy_re_compile(</font>
<font color="black"> 159.         # max length for domain name labels is 63 characters per RFC 1034</font>
<font color="green"> 160.         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+)(?:[A-Z0-9-]{2,63}(?&lt;!-))\Z',</font>
<font color="green"> 161.         re.IGNORECASE)</font>
<font color="green"> 162.     literal_regex = _lazy_re_compile(</font>
<font color="black"> 163.         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)</font>
<font color="green"> 164.         r'\[([A-f0-9:\.]+)\]\Z',</font>
<font color="green"> 165.         re.IGNORECASE)</font>
<font color="green"> 166.     domain_whitelist = ['localhost']</font>
<font color="black"> 167. </font>
<font color="green"> 168.     def __init__(self, message=None, code=None, whitelist=None):</font>
<font color="green"> 169.         if message is not None:</font>
<font color="red"> 170.             self.message = message</font>
<font color="green"> 171.         if code is not None:</font>
<font color="red"> 172.             self.code = code</font>
<font color="green"> 173.         if whitelist is not None:</font>
<font color="red"> 174.             self.domain_whitelist = whitelist</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def __call__(self, value):</font>
<font color="red"> 177.         value = force_text(value)</font>
<font color="black"> 178. </font>
<font color="red"> 179.         if not value or '@' not in value:</font>
<font color="red"> 180.             raise ValidationError(self.message, code=self.code)</font>
<font color="black"> 181. </font>
<font color="red"> 182.         user_part, domain_part = value.rsplit('@', 1)</font>
<font color="black"> 183. </font>
<font color="red"> 184.         if not self.user_regex.match(user_part):</font>
<font color="red"> 185.             raise ValidationError(self.message, code=self.code)</font>
<font color="black"> 186. </font>
<font color="red"> 187.         if (domain_part not in self.domain_whitelist and</font>
<font color="red"> 188.                 not self.validate_domain_part(domain_part)):</font>
<font color="black"> 189.             # Try for possible IDN domain-part</font>
<font color="red"> 190.             try:</font>
<font color="red"> 191.                 domain_part = domain_part.encode('idna').decode('ascii')</font>
<font color="red"> 192.                 if self.validate_domain_part(domain_part):</font>
<font color="red"> 193.                     return</font>
<font color="red"> 194.             except UnicodeError:</font>
<font color="red"> 195.                 pass</font>
<font color="red"> 196.             raise ValidationError(self.message, code=self.code)</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def validate_domain_part(self, domain_part):</font>
<font color="red"> 199.         if self.domain_regex.match(domain_part):</font>
<font color="red"> 200.             return True</font>
<font color="black"> 201. </font>
<font color="red"> 202.         literal_match = self.literal_regex.match(domain_part)</font>
<font color="red"> 203.         if literal_match:</font>
<font color="red"> 204.             ip_address = literal_match.group(1)</font>
<font color="red"> 205.             try:</font>
<font color="red"> 206.                 validate_ipv46_address(ip_address)</font>
<font color="red"> 207.                 return True</font>
<font color="red"> 208.             except ValidationError:</font>
<font color="red"> 209.                 pass</font>
<font color="red"> 210.         return False</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def __eq__(self, other):</font>
<font color="black"> 213.         return (</font>
<font color="red"> 214.             isinstance(other, EmailValidator) and</font>
<font color="red"> 215.             (self.domain_whitelist == other.domain_whitelist) and</font>
<font color="red"> 216.             (self.message == other.message) and</font>
<font color="red"> 217.             (self.code == other.code)</font>
<font color="black"> 218.         )</font>
<font color="black"> 219. </font>
<font color="green"> 220. validate_email = EmailValidator()</font>
<font color="black"> 221. </font>
<font color="green"> 222. slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\Z')</font>
<font color="green"> 223. validate_slug = RegexValidator(</font>
<font color="green"> 224.     slug_re,</font>
<font color="green"> 225.     _(&quot;Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.&quot;),</font>
<font color="green"> 226.     'invalid'</font>
<font color="black"> 227. )</font>
<font color="black"> 228. </font>
<font color="green"> 229. slug_unicode_re = _lazy_re_compile(r'^[-\w]+\Z', re.U)</font>
<font color="green"> 230. validate_unicode_slug = RegexValidator(</font>
<font color="green"> 231.     slug_unicode_re,</font>
<font color="green"> 232.     _(&quot;Enter a valid 'slug' consisting of Unicode letters, numbers, underscores, or hyphens.&quot;),</font>
<font color="green"> 233.     'invalid'</font>
<font color="black"> 234. )</font>
<font color="black"> 235. </font>
<font color="green"> 236. ipv4_re = _lazy_re_compile(r'^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\Z')</font>
<font color="green"> 237. validate_ipv4_address = RegexValidator(ipv4_re, _('Enter a valid IPv4 address.'), 'invalid')</font>
<font color="black"> 238. </font>
<font color="black"> 239. </font>
<font color="green"> 240. def validate_ipv6_address(value):</font>
<font color="red"> 241.     if not is_valid_ipv6_address(value):</font>
<font color="red"> 242.         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')</font>
<font color="black"> 243. </font>
<font color="black"> 244. </font>
<font color="green"> 245. def validate_ipv46_address(value):</font>
<font color="red"> 246.     try:</font>
<font color="red"> 247.         validate_ipv4_address(value)</font>
<font color="red"> 248.     except ValidationError:</font>
<font color="red"> 249.         try:</font>
<font color="red"> 250.             validate_ipv6_address(value)</font>
<font color="red"> 251.         except ValidationError:</font>
<font color="red"> 252.             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')</font>
<font color="black"> 253. </font>
<font color="green"> 254. ip_address_validator_map = {</font>
<font color="green"> 255.     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),</font>
<font color="green"> 256.     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),</font>
<font color="green"> 257.     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),</font>
<font color="black"> 258. }</font>
<font color="black"> 259. </font>
<font color="black"> 260. </font>
<font color="green"> 261. def ip_address_validators(protocol, unpack_ipv4):</font>
<font color="black"> 262.     &quot;&quot;&quot;</font>
<font color="black"> 263.     Depending on the given parameters returns the appropriate validators for</font>
<font color="black"> 264.     the GenericIPAddressField.</font>
<font color="black"> 265. </font>
<font color="black"> 266.     This code is here, because it is exactly the same for the model and the form field.</font>
<font color="black"> 267.     &quot;&quot;&quot;</font>
<font color="red"> 268.     if protocol != 'both' and unpack_ipv4:</font>
<font color="red"> 269.         raise ValueError(</font>
<font color="red"> 270.             &quot;You can only use `unpack_ipv4` if `protocol` is set to 'both'&quot;)</font>
<font color="red"> 271.     try:</font>
<font color="red"> 272.         return ip_address_validator_map[protocol.lower()]</font>
<font color="red"> 273.     except KeyError:</font>
<font color="red"> 274.         raise ValueError(&quot;The protocol '%s' is unknown. Supported: %s&quot;</font>
<font color="red"> 275.                          % (protocol, list(ip_address_validator_map)))</font>
<font color="black"> 276. </font>
<font color="black"> 277. </font>
<font color="green"> 278. def int_list_validator(sep=',', message=None, code='invalid'):</font>
<font color="green"> 279.     regexp = _lazy_re_compile('^\d+(?:%s\d+)*\Z' % re.escape(sep))</font>
<font color="green"> 280.     return RegexValidator(regexp, message=message, code=code)</font>
<font color="black"> 281. </font>
<font color="black"> 282. </font>
<font color="green"> 283. validate_comma_separated_integer_list = int_list_validator(</font>
<font color="green"> 284.     message=_('Enter only digits separated by commas.'),</font>
<font color="black"> 285. )</font>
<font color="black"> 286. </font>
<font color="black"> 287. </font>
<font color="green"> 288. @deconstructible</font>
<font color="green"> 289. class BaseValidator(object):</font>
<font color="green"> 290.     compare = lambda self, a, b: a is not b</font>
<font color="green"> 291.     clean = lambda self, x: x</font>
<font color="green"> 292.     message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')</font>
<font color="green"> 293.     code = 'limit_value'</font>
<font color="black"> 294. </font>
<font color="green"> 295.     def __init__(self, limit_value, message=None):</font>
<font color="green"> 296.         self.limit_value = limit_value</font>
<font color="green"> 297.         if message:</font>
<font color="red"> 298.             self.message = message</font>
<font color="black"> 299. </font>
<font color="green"> 300.     def __call__(self, value):</font>
<font color="red"> 301.         cleaned = self.clean(value)</font>
<font color="red"> 302.         params = {'limit_value': self.limit_value, 'show_value': cleaned, 'value': value}</font>
<font color="red"> 303.         if self.compare(cleaned, self.limit_value):</font>
<font color="red"> 304.             raise ValidationError(self.message, code=self.code, params=params)</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def __eq__(self, other):</font>
<font color="black"> 307.         return (</font>
<font color="red"> 308.             isinstance(other, self.__class__) and</font>
<font color="red"> 309.             (self.limit_value == other.limit_value)</font>
<font color="red"> 310.             and (self.message == other.message)</font>
<font color="red"> 311.             and (self.code == other.code)</font>
<font color="black"> 312.         )</font>
<font color="black"> 313. </font>
<font color="black"> 314. </font>
<font color="green"> 315. @deconstructible</font>
<font color="green"> 316. class MaxValueValidator(BaseValidator):</font>
<font color="green"> 317.     compare = lambda self, a, b: a &gt; b</font>
<font color="green"> 318.     message = _('Ensure this value is less than or equal to %(limit_value)s.')</font>
<font color="green"> 319.     code = 'max_value'</font>
<font color="black"> 320. </font>
<font color="black"> 321. </font>
<font color="green"> 322. @deconstructible</font>
<font color="green"> 323. class MinValueValidator(BaseValidator):</font>
<font color="green"> 324.     compare = lambda self, a, b: a &lt; b</font>
<font color="green"> 325.     message = _('Ensure this value is greater than or equal to %(limit_value)s.')</font>
<font color="green"> 326.     code = 'min_value'</font>
<font color="black"> 327. </font>
<font color="black"> 328. </font>
<font color="green"> 329. @deconstructible</font>
<font color="green"> 330. class MinLengthValidator(BaseValidator):</font>
<font color="green"> 331.     compare = lambda self, a, b: a &lt; b</font>
<font color="green"> 332.     clean = lambda self, x: len(x)</font>
<font color="green"> 333.     message = ungettext_lazy(</font>
<font color="green"> 334.         'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',</font>
<font color="green"> 335.         'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',</font>
<font color="green"> 336.         'limit_value')</font>
<font color="green"> 337.     code = 'min_length'</font>
<font color="black"> 338. </font>
<font color="black"> 339. </font>
<font color="green"> 340. @deconstructible</font>
<font color="green"> 341. class MaxLengthValidator(BaseValidator):</font>
<font color="green"> 342.     compare = lambda self, a, b: a &gt; b</font>
<font color="green"> 343.     clean = lambda self, x: len(x)</font>
<font color="green"> 344.     message = ungettext_lazy(</font>
<font color="green"> 345.         'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',</font>
<font color="green"> 346.         'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',</font>
<font color="green"> 347.         'limit_value')</font>
<font color="green"> 348.     code = 'max_length'</font>
<font color="black"> 349. </font>
<font color="black"> 350. </font>
<font color="green"> 351. @deconstructible</font>
<font color="green"> 352. class DecimalValidator(object):</font>
<font color="black"> 353.     &quot;&quot;&quot;</font>
<font color="black"> 354.     Validate that the input does not exceed the maximum number of digits</font>
<font color="black"> 355.     expected, otherwise raise ValidationError.</font>
<font color="green"> 356.     &quot;&quot;&quot;</font>
<font color="green"> 357.     messages = {</font>
<font color="green"> 358.         'max_digits': ungettext_lazy(</font>
<font color="green"> 359.             'Ensure that there are no more than %(max)s digit in total.',</font>
<font color="green"> 360.             'Ensure that there are no more than %(max)s digits in total.',</font>
<font color="green"> 361.             'max'</font>
<font color="black"> 362.         ),</font>
<font color="green"> 363.         'max_decimal_places': ungettext_lazy(</font>
<font color="green"> 364.             'Ensure that there are no more than %(max)s decimal place.',</font>
<font color="green"> 365.             'Ensure that there are no more than %(max)s decimal places.',</font>
<font color="green"> 366.             'max'</font>
<font color="black"> 367.         ),</font>
<font color="green"> 368.         'max_whole_digits': ungettext_lazy(</font>
<font color="green"> 369.             'Ensure that there are no more than %(max)s digit before the decimal point.',</font>
<font color="green"> 370.             'Ensure that there are no more than %(max)s digits before the decimal point.',</font>
<font color="green"> 371.             'max'</font>
<font color="black"> 372.         ),</font>
<font color="black"> 373.     }</font>
<font color="black"> 374. </font>
<font color="green"> 375.     def __init__(self, max_digits, decimal_places):</font>
<font color="red"> 376.         self.max_digits = max_digits</font>
<font color="red"> 377.         self.decimal_places = decimal_places</font>
<font color="black"> 378. </font>
<font color="green"> 379.     def __call__(self, value):</font>
<font color="red"> 380.         digit_tuple, exponent = value.as_tuple()[1:]</font>
<font color="red"> 381.         decimals = abs(exponent)</font>
<font color="black"> 382.         # digit_tuple doesn't include any leading zeros.</font>
<font color="red"> 383.         digits = len(digit_tuple)</font>
<font color="red"> 384.         if decimals &gt; digits:</font>
<font color="black"> 385.             # We have leading zeros up to or past the decimal point. Count</font>
<font color="black"> 386.             # everything past the decimal point as a digit. We do not count</font>
<font color="black"> 387.             # 0 before the decimal point as a digit since that would mean</font>
<font color="black"> 388.             # we would not allow max_digits = decimal_places.</font>
<font color="red"> 389.             digits = decimals</font>
<font color="red"> 390.         whole_digits = digits - decimals</font>
<font color="black"> 391. </font>
<font color="red"> 392.         if self.max_digits is not None and digits &gt; self.max_digits:</font>
<font color="red"> 393.             raise ValidationError(</font>
<font color="red"> 394.                 self.messages['max_digits'],</font>
<font color="red"> 395.                 code='max_digits',</font>
<font color="red"> 396.                 params={'max': self.max_digits},</font>
<font color="black"> 397.             )</font>
<font color="red"> 398.         if self.decimal_places is not None and decimals &gt; self.decimal_places:</font>
<font color="red"> 399.             raise ValidationError(</font>
<font color="red"> 400.                 self.messages['max_decimal_places'],</font>
<font color="red"> 401.                 code='max_decimal_places',</font>
<font color="red"> 402.                 params={'max': self.decimal_places},</font>
<font color="black"> 403.             )</font>
<font color="red"> 404.         if (self.max_digits is not None and self.decimal_places is not None</font>
<font color="red"> 405.                 and whole_digits &gt; (self.max_digits - self.decimal_places)):</font>
<font color="red"> 406.             raise ValidationError(</font>
<font color="red"> 407.                 self.messages['max_whole_digits'],</font>
<font color="red"> 408.                 code='max_whole_digits',</font>
<font color="red"> 409.                 params={'max': (self.max_digits - self.decimal_places)},</font>
<font color="black"> 410.             )</font>
<font color="black"> 411. </font>
<font color="green"> 412.     def __eq__(self, other):</font>
<font color="black"> 413.         return (</font>
<font color="red"> 414.             isinstance(other, self.__class__) and</font>
<font color="red"> 415.             self.max_digits == other.max_digits and</font>
<font color="red"> 416.             self.decimal_places == other.decimal_places</font>
<font color="black"> 417.         )</font>
</pre>

