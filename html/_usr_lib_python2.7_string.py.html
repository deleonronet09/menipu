source file: <b>/usr/lib/python2.7/string.py</b><br>


file stats: <b>233 lines, 2 executed: 0.9% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;A collection of string operations (most are no longer used).</font>
<font color="black">   2. </font>
<font color="black">   3. Warning: most of the code you see here isn't normally used nowadays.</font>
<font color="black">   4. Beginning with Python 1.6, many of these functions are implemented as</font>
<font color="black">   5. methods on the standard string object. They used to be implemented by</font>
<font color="black">   6. a built-in module called strop, but strop is now obsolete itself.</font>
<font color="black">   7. </font>
<font color="black">   8. Public module variables:</font>
<font color="black">   9. </font>
<font color="black">  10. whitespace -- a string containing all characters considered whitespace</font>
<font color="black">  11. lowercase -- a string containing all characters considered lowercase letters</font>
<font color="black">  12. uppercase -- a string containing all characters considered uppercase letters</font>
<font color="black">  13. letters -- a string containing all characters considered letters</font>
<font color="black">  14. digits -- a string containing all characters considered decimal digits</font>
<font color="black">  15. hexdigits -- a string containing all characters considered hexadecimal digits</font>
<font color="black">  16. octdigits -- a string containing all characters considered octal digits</font>
<font color="black">  17. punctuation -- a string containing all characters considered punctuation</font>
<font color="black">  18. printable -- a string containing all characters considered printable</font>
<font color="black">  19. </font>
<font color="red">  20. &quot;&quot;&quot;</font>
<font color="black">  21. </font>
<font color="black">  22. # Some strings for ctype-style character classification</font>
<font color="red">  23. whitespace = ' \t\n\r\v\f'</font>
<font color="red">  24. lowercase = 'abcdefghijklmnopqrstuvwxyz'</font>
<font color="red">  25. uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</font>
<font color="red">  26. letters = lowercase + uppercase</font>
<font color="red">  27. ascii_lowercase = lowercase</font>
<font color="red">  28. ascii_uppercase = uppercase</font>
<font color="red">  29. ascii_letters = ascii_lowercase + ascii_uppercase</font>
<font color="red">  30. digits = '0123456789'</font>
<font color="red">  31. hexdigits = digits + 'abcdef' + 'ABCDEF'</font>
<font color="red">  32. octdigits = '01234567'</font>
<font color="red">  33. punctuation = &quot;&quot;&quot;!&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~&quot;&quot;&quot;</font>
<font color="red">  34. printable = digits + letters + punctuation + whitespace</font>
<font color="black">  35. </font>
<font color="black">  36. # Case conversion helpers</font>
<font color="black">  37. # Use str to convert Unicode literal in case of -U</font>
<font color="red">  38. l = map(chr, xrange(256))</font>
<font color="red">  39. _idmap = str('').join(l)</font>
<font color="red">  40. del l</font>
<font color="black">  41. </font>
<font color="black">  42. # Functions which aren't available as string methods.</font>
<font color="black">  43. </font>
<font color="black">  44. # Capitalize the words in a string, e.g. &quot; aBc  dEf &quot; -&gt; &quot;Abc Def&quot;.</font>
<font color="red">  45. def capwords(s, sep=None):</font>
<font color="black">  46.     &quot;&quot;&quot;capwords(s [,sep]) -&gt; string</font>
<font color="black">  47. </font>
<font color="black">  48.     Split the argument into words using split, capitalize each</font>
<font color="black">  49.     word using capitalize, and join the capitalized words using</font>
<font color="black">  50.     join.  If the optional second argument sep is absent or None,</font>
<font color="black">  51.     runs of whitespace characters are replaced by a single space</font>
<font color="black">  52.     and leading and trailing whitespace are removed, otherwise</font>
<font color="black">  53.     sep is used to split and join the words.</font>
<font color="black">  54. </font>
<font color="black">  55.     &quot;&quot;&quot;</font>
<font color="red">  56.     return (sep or ' ').join(x.capitalize() for x in s.split(sep))</font>
<font color="black">  57. </font>
<font color="black">  58. </font>
<font color="black">  59. # Construct a translation string</font>
<font color="red">  60. _idmapL = None</font>
<font color="red">  61. def maketrans(fromstr, tostr):</font>
<font color="black">  62.     &quot;&quot;&quot;maketrans(frm, to) -&gt; string</font>
<font color="black">  63. </font>
<font color="black">  64.     Return a translation table (a string of 256 bytes long)</font>
<font color="black">  65.     suitable for use in string.translate.  The strings frm and to</font>
<font color="black">  66.     must be of the same length.</font>
<font color="black">  67. </font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="red">  69.     if len(fromstr) != len(tostr):</font>
<font color="red">  70.         raise ValueError, &quot;maketrans arguments must have same length&quot;</font>
<font color="black">  71.     global _idmapL</font>
<font color="red">  72.     if not _idmapL:</font>
<font color="red">  73.         _idmapL = list(_idmap)</font>
<font color="red">  74.     L = _idmapL[:]</font>
<font color="red">  75.     fromstr = map(ord, fromstr)</font>
<font color="red">  76.     for i in range(len(fromstr)):</font>
<font color="red">  77.         L[fromstr[i]] = tostr[i]</font>
<font color="red">  78.     return ''.join(L)</font>
<font color="black">  79. </font>
<font color="black">  80. </font>
<font color="black">  81. </font>
<font color="black">  82. ####################################################################</font>
<font color="red">  83. import re as _re</font>
<font color="black">  84. </font>
<font color="red">  85. class _multimap:</font>
<font color="black">  86.     &quot;&quot;&quot;Helper class for combining multiple mappings.</font>
<font color="black">  87. </font>
<font color="black">  88.     Used by .{safe_,}substitute() to combine the mapping and keyword</font>
<font color="black">  89.     arguments.</font>
<font color="red">  90.     &quot;&quot;&quot;</font>
<font color="red">  91.     def __init__(self, primary, secondary):</font>
<font color="red">  92.         self._primary = primary</font>
<font color="red">  93.         self._secondary = secondary</font>
<font color="black">  94. </font>
<font color="red">  95.     def __getitem__(self, key):</font>
<font color="red">  96.         try:</font>
<font color="red">  97.             return self._primary[key]</font>
<font color="red">  98.         except KeyError:</font>
<font color="red">  99.             return self._secondary[key]</font>
<font color="black"> 100. </font>
<font color="black"> 101. </font>
<font color="red"> 102. class _TemplateMetaclass(type):</font>
<font color="black"> 103.     pattern = r&quot;&quot;&quot;</font>
<font color="black"> 104.     %(delim)s(?:</font>
<font color="black"> 105.       (?P&lt;escaped&gt;%(delim)s) |   # Escape sequence of two delimiters</font>
<font color="black"> 106.       (?P&lt;named&gt;%(id)s)      |   # delimiter and a Python identifier</font>
<font color="black"> 107.       {(?P&lt;braced&gt;%(id)s)}   |   # delimiter and a braced identifier</font>
<font color="black"> 108.       (?P&lt;invalid&gt;)              # Other ill-formed delimiter exprs</font>
<font color="black"> 109.     )</font>
<font color="red"> 110.     &quot;&quot;&quot;</font>
<font color="black"> 111. </font>
<font color="red"> 112.     def __init__(cls, name, bases, dct):</font>
<font color="red"> 113.         super(_TemplateMetaclass, cls).__init__(name, bases, dct)</font>
<font color="red"> 114.         if 'pattern' in dct:</font>
<font color="red"> 115.             pattern = cls.pattern</font>
<font color="black"> 116.         else:</font>
<font color="red"> 117.             pattern = _TemplateMetaclass.pattern % {</font>
<font color="red"> 118.                 'delim' : _re.escape(cls.delimiter),</font>
<font color="red"> 119.                 'id'    : cls.idpattern,</font>
<font color="black"> 120.                 }</font>
<font color="red"> 121.         cls.pattern = _re.compile(pattern, _re.IGNORECASE | _re.VERBOSE)</font>
<font color="black"> 122. </font>
<font color="black"> 123. </font>
<font color="red"> 124. class Template:</font>
<font color="red"> 125.     &quot;&quot;&quot;A string class for supporting $-substitutions.&quot;&quot;&quot;</font>
<font color="red"> 126.     __metaclass__ = _TemplateMetaclass</font>
<font color="black"> 127. </font>
<font color="red"> 128.     delimiter = '$'</font>
<font color="red"> 129.     idpattern = r'[_a-z][_a-z0-9]*'</font>
<font color="black"> 130. </font>
<font color="red"> 131.     def __init__(self, template):</font>
<font color="red"> 132.         self.template = template</font>
<font color="black"> 133. </font>
<font color="black"> 134.     # Search for $$, $identifier, ${identifier}, and any bare $'s</font>
<font color="black"> 135. </font>
<font color="red"> 136.     def _invalid(self, mo):</font>
<font color="red"> 137.         i = mo.start('invalid')</font>
<font color="red"> 138.         lines = self.template[:i].splitlines(True)</font>
<font color="red"> 139.         if not lines:</font>
<font color="red"> 140.             colno = 1</font>
<font color="red"> 141.             lineno = 1</font>
<font color="black"> 142.         else:</font>
<font color="red"> 143.             colno = i - len(''.join(lines[:-1]))</font>
<font color="red"> 144.             lineno = len(lines)</font>
<font color="red"> 145.         raise ValueError('Invalid placeholder in string: line %d, col %d' %</font>
<font color="red"> 146.                          (lineno, colno))</font>
<font color="black"> 147. </font>
<font color="red"> 148.     def substitute(self, *args, **kws):</font>
<font color="red"> 149.         if len(args) &gt; 1:</font>
<font color="red"> 150.             raise TypeError('Too many positional arguments')</font>
<font color="red"> 151.         if not args:</font>
<font color="red"> 152.             mapping = kws</font>
<font color="red"> 153.         elif kws:</font>
<font color="red"> 154.             mapping = _multimap(kws, args[0])</font>
<font color="black"> 155.         else:</font>
<font color="red"> 156.             mapping = args[0]</font>
<font color="black"> 157.         # Helper function for .sub()</font>
<font color="red"> 158.         def convert(mo):</font>
<font color="black"> 159.             # Check the most common path first.</font>
<font color="red"> 160.             named = mo.group('named') or mo.group('braced')</font>
<font color="red"> 161.             if named is not None:</font>
<font color="red"> 162.                 val = mapping[named]</font>
<font color="black"> 163.                 # We use this idiom instead of str() because the latter will</font>
<font color="black"> 164.                 # fail if val is a Unicode containing non-ASCII characters.</font>
<font color="red"> 165.                 return '%s' % (val,)</font>
<font color="red"> 166.             if mo.group('escaped') is not None:</font>
<font color="red"> 167.                 return self.delimiter</font>
<font color="red"> 168.             if mo.group('invalid') is not None:</font>
<font color="red"> 169.                 self._invalid(mo)</font>
<font color="red"> 170.             raise ValueError('Unrecognized named group in pattern',</font>
<font color="red"> 171.                              self.pattern)</font>
<font color="red"> 172.         return self.pattern.sub(convert, self.template)</font>
<font color="black"> 173. </font>
<font color="red"> 174.     def safe_substitute(self, *args, **kws):</font>
<font color="red"> 175.         if len(args) &gt; 1:</font>
<font color="red"> 176.             raise TypeError('Too many positional arguments')</font>
<font color="red"> 177.         if not args:</font>
<font color="red"> 178.             mapping = kws</font>
<font color="red"> 179.         elif kws:</font>
<font color="red"> 180.             mapping = _multimap(kws, args[0])</font>
<font color="black"> 181.         else:</font>
<font color="red"> 182.             mapping = args[0]</font>
<font color="black"> 183.         # Helper function for .sub()</font>
<font color="red"> 184.         def convert(mo):</font>
<font color="red"> 185.             named = mo.group('named')</font>
<font color="red"> 186.             if named is not None:</font>
<font color="red"> 187.                 try:</font>
<font color="black"> 188.                     # We use this idiom instead of str() because the latter</font>
<font color="black"> 189.                     # will fail if val is a Unicode containing non-ASCII</font>
<font color="red"> 190.                     return '%s' % (mapping[named],)</font>
<font color="red"> 191.                 except KeyError:</font>
<font color="red"> 192.                     return self.delimiter + named</font>
<font color="red"> 193.             braced = mo.group('braced')</font>
<font color="red"> 194.             if braced is not None:</font>
<font color="red"> 195.                 try:</font>
<font color="red"> 196.                     return '%s' % (mapping[braced],)</font>
<font color="red"> 197.                 except KeyError:</font>
<font color="red"> 198.                     return self.delimiter + '{' + braced + '}'</font>
<font color="red"> 199.             if mo.group('escaped') is not None:</font>
<font color="red"> 200.                 return self.delimiter</font>
<font color="red"> 201.             if mo.group('invalid') is not None:</font>
<font color="red"> 202.                 return self.delimiter</font>
<font color="red"> 203.             raise ValueError('Unrecognized named group in pattern',</font>
<font color="red"> 204.                              self.pattern)</font>
<font color="red"> 205.         return self.pattern.sub(convert, self.template)</font>
<font color="black"> 206. </font>
<font color="black"> 207. </font>
<font color="black"> 208. </font>
<font color="black"> 209. ####################################################################</font>
<font color="black"> 210. # NOTE: Everything below here is deprecated.  Use string methods instead.</font>
<font color="black"> 211. # This stuff will go away in Python 3.0.</font>
<font color="black"> 212. </font>
<font color="black"> 213. # Backward compatible names for exceptions</font>
<font color="red"> 214. index_error = ValueError</font>
<font color="red"> 215. atoi_error = ValueError</font>
<font color="red"> 216. atof_error = ValueError</font>
<font color="red"> 217. atol_error = ValueError</font>
<font color="black"> 218. </font>
<font color="black"> 219. # convert UPPER CASE letters to lower case</font>
<font color="red"> 220. def lower(s):</font>
<font color="black"> 221.     &quot;&quot;&quot;lower(s) -&gt; string</font>
<font color="black"> 222. </font>
<font color="black"> 223.     Return a copy of the string s converted to lowercase.</font>
<font color="black"> 224. </font>
<font color="black"> 225.     &quot;&quot;&quot;</font>
<font color="red"> 226.     return s.lower()</font>
<font color="black"> 227. </font>
<font color="black"> 228. # Convert lower case letters to UPPER CASE</font>
<font color="red"> 229. def upper(s):</font>
<font color="black"> 230.     &quot;&quot;&quot;upper(s) -&gt; string</font>
<font color="black"> 231. </font>
<font color="black"> 232.     Return a copy of the string s converted to uppercase.</font>
<font color="black"> 233. </font>
<font color="black"> 234.     &quot;&quot;&quot;</font>
<font color="red"> 235.     return s.upper()</font>
<font color="black"> 236. </font>
<font color="black"> 237. # Swap lower case letters and UPPER CASE</font>
<font color="red"> 238. def swapcase(s):</font>
<font color="black"> 239.     &quot;&quot;&quot;swapcase(s) -&gt; string</font>
<font color="black"> 240. </font>
<font color="black"> 241.     Return a copy of the string s with upper case characters</font>
<font color="black"> 242.     converted to lowercase and vice versa.</font>
<font color="black"> 243. </font>
<font color="black"> 244.     &quot;&quot;&quot;</font>
<font color="red"> 245.     return s.swapcase()</font>
<font color="black"> 246. </font>
<font color="black"> 247. # Strip leading and trailing tabs and spaces</font>
<font color="red"> 248. def strip(s, chars=None):</font>
<font color="black"> 249.     &quot;&quot;&quot;strip(s [,chars]) -&gt; string</font>
<font color="black"> 250. </font>
<font color="black"> 251.     Return a copy of the string s with leading and trailing</font>
<font color="black"> 252.     whitespace removed.</font>
<font color="black"> 253.     If chars is given and not None, remove characters in chars instead.</font>
<font color="black"> 254.     If chars is unicode, S will be converted to unicode before stripping.</font>
<font color="black"> 255. </font>
<font color="black"> 256.     &quot;&quot;&quot;</font>
<font color="red"> 257.     return s.strip(chars)</font>
<font color="black"> 258. </font>
<font color="black"> 259. # Strip leading tabs and spaces</font>
<font color="red"> 260. def lstrip(s, chars=None):</font>
<font color="black"> 261.     &quot;&quot;&quot;lstrip(s [,chars]) -&gt; string</font>
<font color="black"> 262. </font>
<font color="black"> 263.     Return a copy of the string s with leading whitespace removed.</font>
<font color="black"> 264.     If chars is given and not None, remove characters in chars instead.</font>
<font color="black"> 265. </font>
<font color="black"> 266.     &quot;&quot;&quot;</font>
<font color="red"> 267.     return s.lstrip(chars)</font>
<font color="black"> 268. </font>
<font color="black"> 269. # Strip trailing tabs and spaces</font>
<font color="red"> 270. def rstrip(s, chars=None):</font>
<font color="black"> 271.     &quot;&quot;&quot;rstrip(s [,chars]) -&gt; string</font>
<font color="black"> 272. </font>
<font color="black"> 273.     Return a copy of the string s with trailing whitespace removed.</font>
<font color="black"> 274.     If chars is given and not None, remove characters in chars instead.</font>
<font color="black"> 275. </font>
<font color="black"> 276.     &quot;&quot;&quot;</font>
<font color="red"> 277.     return s.rstrip(chars)</font>
<font color="black"> 278. </font>
<font color="black"> 279. </font>
<font color="black"> 280. # Split a string into a list of space/tab-separated words</font>
<font color="red"> 281. def split(s, sep=None, maxsplit=-1):</font>
<font color="black"> 282.     &quot;&quot;&quot;split(s [,sep [,maxsplit]]) -&gt; list of strings</font>
<font color="black"> 283. </font>
<font color="black"> 284.     Return a list of the words in the string s, using sep as the</font>
<font color="black"> 285.     delimiter string.  If maxsplit is given, splits at no more than</font>
<font color="black"> 286.     maxsplit places (resulting in at most maxsplit+1 words).  If sep</font>
<font color="black"> 287.     is not specified or is None, any whitespace string is a separator.</font>
<font color="black"> 288. </font>
<font color="black"> 289.     (split and splitfields are synonymous)</font>
<font color="black"> 290. </font>
<font color="black"> 291.     &quot;&quot;&quot;</font>
<font color="red"> 292.     return s.split(sep, maxsplit)</font>
<font color="red"> 293. splitfields = split</font>
<font color="black"> 294. </font>
<font color="black"> 295. # Split a string into a list of space/tab-separated words</font>
<font color="red"> 296. def rsplit(s, sep=None, maxsplit=-1):</font>
<font color="black"> 297.     &quot;&quot;&quot;rsplit(s [,sep [,maxsplit]]) -&gt; list of strings</font>
<font color="black"> 298. </font>
<font color="black"> 299.     Return a list of the words in the string s, using sep as the</font>
<font color="black"> 300.     delimiter string, starting at the end of the string and working</font>
<font color="black"> 301.     to the front.  If maxsplit is given, at most maxsplit splits are</font>
<font color="black"> 302.     done. If sep is not specified or is None, any whitespace string</font>
<font color="black"> 303.     is a separator.</font>
<font color="black"> 304.     &quot;&quot;&quot;</font>
<font color="red"> 305.     return s.rsplit(sep, maxsplit)</font>
<font color="black"> 306. </font>
<font color="black"> 307. # Join fields with optional separator</font>
<font color="red"> 308. def join(words, sep = ' '):</font>
<font color="black"> 309.     &quot;&quot;&quot;join(list [,sep]) -&gt; string</font>
<font color="black"> 310. </font>
<font color="black"> 311.     Return a string composed of the words in list, with</font>
<font color="black"> 312.     intervening occurrences of sep.  The default separator is a</font>
<font color="black"> 313.     single space.</font>
<font color="black"> 314. </font>
<font color="black"> 315.     (joinfields and join are synonymous)</font>
<font color="black"> 316. </font>
<font color="black"> 317.     &quot;&quot;&quot;</font>
<font color="red"> 318.     return sep.join(words)</font>
<font color="red"> 319. joinfields = join</font>
<font color="black"> 320. </font>
<font color="black"> 321. # Find substring, raise exception if not found</font>
<font color="red"> 322. def index(s, *args):</font>
<font color="black"> 323.     &quot;&quot;&quot;index(s, sub [,start [,end]]) -&gt; int</font>
<font color="black"> 324. </font>
<font color="black"> 325.     Like find but raises ValueError when the substring is not found.</font>
<font color="black"> 326. </font>
<font color="black"> 327.     &quot;&quot;&quot;</font>
<font color="red"> 328.     return s.index(*args)</font>
<font color="black"> 329. </font>
<font color="black"> 330. # Find last substring, raise exception if not found</font>
<font color="red"> 331. def rindex(s, *args):</font>
<font color="black"> 332.     &quot;&quot;&quot;rindex(s, sub [,start [,end]]) -&gt; int</font>
<font color="black"> 333. </font>
<font color="black"> 334.     Like rfind but raises ValueError when the substring is not found.</font>
<font color="black"> 335. </font>
<font color="black"> 336.     &quot;&quot;&quot;</font>
<font color="red"> 337.     return s.rindex(*args)</font>
<font color="black"> 338. </font>
<font color="black"> 339. # Count non-overlapping occurrences of substring</font>
<font color="red"> 340. def count(s, *args):</font>
<font color="black"> 341.     &quot;&quot;&quot;count(s, sub[, start[,end]]) -&gt; int</font>
<font color="black"> 342. </font>
<font color="black"> 343.     Return the number of occurrences of substring sub in string</font>
<font color="black"> 344.     s[start:end].  Optional arguments start and end are</font>
<font color="black"> 345.     interpreted as in slice notation.</font>
<font color="black"> 346. </font>
<font color="black"> 347.     &quot;&quot;&quot;</font>
<font color="red"> 348.     return s.count(*args)</font>
<font color="black"> 349. </font>
<font color="black"> 350. # Find substring, return -1 if not found</font>
<font color="red"> 351. def find(s, *args):</font>
<font color="black"> 352.     &quot;&quot;&quot;find(s, sub [,start [,end]]) -&gt; in</font>
<font color="black"> 353. </font>
<font color="black"> 354.     Return the lowest index in s where substring sub is found,</font>
<font color="black"> 355.     such that sub is contained within s[start,end].  Optional</font>
<font color="black"> 356.     arguments start and end are interpreted as in slice notation.</font>
<font color="black"> 357. </font>
<font color="black"> 358.     Return -1 on failure.</font>
<font color="black"> 359. </font>
<font color="black"> 360.     &quot;&quot;&quot;</font>
<font color="red"> 361.     return s.find(*args)</font>
<font color="black"> 362. </font>
<font color="black"> 363. # Find last substring, return -1 if not found</font>
<font color="red"> 364. def rfind(s, *args):</font>
<font color="black"> 365.     &quot;&quot;&quot;rfind(s, sub [,start [,end]]) -&gt; int</font>
<font color="black"> 366. </font>
<font color="black"> 367.     Return the highest index in s where substring sub is found,</font>
<font color="black"> 368.     such that sub is contained within s[start,end].  Optional</font>
<font color="black"> 369.     arguments start and end are interpreted as in slice notation.</font>
<font color="black"> 370. </font>
<font color="black"> 371.     Return -1 on failure.</font>
<font color="black"> 372. </font>
<font color="black"> 373.     &quot;&quot;&quot;</font>
<font color="red"> 374.     return s.rfind(*args)</font>
<font color="black"> 375. </font>
<font color="black"> 376. # for a bit of speed</font>
<font color="red"> 377. _float = float</font>
<font color="red"> 378. _int = int</font>
<font color="red"> 379. _long = long</font>
<font color="black"> 380. </font>
<font color="black"> 381. # Convert string to float</font>
<font color="red"> 382. def atof(s):</font>
<font color="black"> 383.     &quot;&quot;&quot;atof(s) -&gt; float</font>
<font color="black"> 384. </font>
<font color="black"> 385.     Return the floating point number represented by the string s.</font>
<font color="black"> 386. </font>
<font color="black"> 387.     &quot;&quot;&quot;</font>
<font color="red"> 388.     return _float(s)</font>
<font color="black"> 389. </font>
<font color="black"> 390. </font>
<font color="black"> 391. # Convert string to integer</font>
<font color="red"> 392. def atoi(s , base=10):</font>
<font color="black"> 393.     &quot;&quot;&quot;atoi(s [,base]) -&gt; int</font>
<font color="black"> 394. </font>
<font color="black"> 395.     Return the integer represented by the string s in the given</font>
<font color="black"> 396.     base, which defaults to 10.  The string s must consist of one</font>
<font color="black"> 397.     or more digits, possibly preceded by a sign.  If base is 0, it</font>
<font color="black"> 398.     is chosen from the leading characters of s, 0 for octal, 0x or</font>
<font color="black"> 399.     0X for hexadecimal.  If base is 16, a preceding 0x or 0X is</font>
<font color="black"> 400.     accepted.</font>
<font color="black"> 401. </font>
<font color="black"> 402.     &quot;&quot;&quot;</font>
<font color="red"> 403.     return _int(s, base)</font>
<font color="black"> 404. </font>
<font color="black"> 405. </font>
<font color="black"> 406. # Convert string to long integer</font>
<font color="red"> 407. def atol(s, base=10):</font>
<font color="black"> 408.     &quot;&quot;&quot;atol(s [,base]) -&gt; long</font>
<font color="black"> 409. </font>
<font color="black"> 410.     Return the long integer represented by the string s in the</font>
<font color="black"> 411.     given base, which defaults to 10.  The string s must consist</font>
<font color="black"> 412.     of one or more digits, possibly preceded by a sign.  If base</font>
<font color="black"> 413.     is 0, it is chosen from the leading characters of s, 0 for</font>
<font color="black"> 414.     octal, 0x or 0X for hexadecimal.  If base is 16, a preceding</font>
<font color="black"> 415.     0x or 0X is accepted.  A trailing L or l is not accepted,</font>
<font color="black"> 416.     unless base is 0.</font>
<font color="black"> 417. </font>
<font color="black"> 418.     &quot;&quot;&quot;</font>
<font color="red"> 419.     return _long(s, base)</font>
<font color="black"> 420. </font>
<font color="black"> 421. </font>
<font color="black"> 422. # Left-justify a string</font>
<font color="red"> 423. def ljust(s, width, *args):</font>
<font color="black"> 424.     &quot;&quot;&quot;ljust(s, width[, fillchar]) -&gt; string</font>
<font color="black"> 425. </font>
<font color="black"> 426.     Return a left-justified version of s, in a field of the</font>
<font color="black"> 427.     specified width, padded with spaces as needed.  The string is</font>
<font color="black"> 428.     never truncated.  If specified the fillchar is used instead of spaces.</font>
<font color="black"> 429. </font>
<font color="black"> 430.     &quot;&quot;&quot;</font>
<font color="red"> 431.     return s.ljust(width, *args)</font>
<font color="black"> 432. </font>
<font color="black"> 433. # Right-justify a string</font>
<font color="red"> 434. def rjust(s, width, *args):</font>
<font color="black"> 435.     &quot;&quot;&quot;rjust(s, width[, fillchar]) -&gt; string</font>
<font color="black"> 436. </font>
<font color="black"> 437.     Return a right-justified version of s, in a field of the</font>
<font color="black"> 438.     specified width, padded with spaces as needed.  The string is</font>
<font color="black"> 439.     never truncated.  If specified the fillchar is used instead of spaces.</font>
<font color="black"> 440. </font>
<font color="black"> 441.     &quot;&quot;&quot;</font>
<font color="red"> 442.     return s.rjust(width, *args)</font>
<font color="black"> 443. </font>
<font color="black"> 444. # Center a string</font>
<font color="red"> 445. def center(s, width, *args):</font>
<font color="black"> 446.     &quot;&quot;&quot;center(s, width[, fillchar]) -&gt; string</font>
<font color="black"> 447. </font>
<font color="black"> 448.     Return a center version of s, in a field of the specified</font>
<font color="black"> 449.     width. padded with spaces as needed.  The string is never</font>
<font color="black"> 450.     truncated.  If specified the fillchar is used instead of spaces.</font>
<font color="black"> 451. </font>
<font color="black"> 452.     &quot;&quot;&quot;</font>
<font color="red"> 453.     return s.center(width, *args)</font>
<font color="black"> 454. </font>
<font color="black"> 455. # Zero-fill a number, e.g., (12, 3) --&gt; '012' and (-3, 3) --&gt; '-03'</font>
<font color="black"> 456. # Decadent feature: the argument may be a string or a number</font>
<font color="black"> 457. # (Use of this is deprecated; it should be a string as with ljust c.s.)</font>
<font color="red"> 458. def zfill(x, width):</font>
<font color="black"> 459.     &quot;&quot;&quot;zfill(x, width) -&gt; string</font>
<font color="black"> 460. </font>
<font color="black"> 461.     Pad a numeric string x with zeros on the left, to fill a field</font>
<font color="black"> 462.     of the specified width.  The string x is never truncated.</font>
<font color="black"> 463. </font>
<font color="black"> 464.     &quot;&quot;&quot;</font>
<font color="red"> 465.     if not isinstance(x, basestring):</font>
<font color="red"> 466.         x = repr(x)</font>
<font color="red"> 467.     return x.zfill(width)</font>
<font color="black"> 468. </font>
<font color="black"> 469. # Expand tabs in a string.</font>
<font color="black"> 470. # Doesn't take non-printing chars into account, but does understand \n.</font>
<font color="red"> 471. def expandtabs(s, tabsize=8):</font>
<font color="black"> 472.     &quot;&quot;&quot;expandtabs(s [,tabsize]) -&gt; string</font>
<font color="black"> 473. </font>
<font color="black"> 474.     Return a copy of the string s with all tab characters replaced</font>
<font color="black"> 475.     by the appropriate number of spaces, depending on the current</font>
<font color="black"> 476.     column, and the tabsize (default 8).</font>
<font color="black"> 477. </font>
<font color="black"> 478.     &quot;&quot;&quot;</font>
<font color="red"> 479.     return s.expandtabs(tabsize)</font>
<font color="black"> 480. </font>
<font color="black"> 481. # Character translation through look-up table.</font>
<font color="red"> 482. def translate(s, table, deletions=&quot;&quot;):</font>
<font color="black"> 483.     &quot;&quot;&quot;translate(s,table [,deletions]) -&gt; string</font>
<font color="black"> 484. </font>
<font color="black"> 485.     Return a copy of the string s, where all characters occurring</font>
<font color="black"> 486.     in the optional argument deletions are removed, and the</font>
<font color="black"> 487.     remaining characters have been mapped through the given</font>
<font color="black"> 488.     translation table, which must be a string of length 256.  The</font>
<font color="black"> 489.     deletions argument is not allowed for Unicode strings.</font>
<font color="black"> 490. </font>
<font color="black"> 491.     &quot;&quot;&quot;</font>
<font color="green"> 492.     if deletions or table is None:</font>
<font color="green"> 493.         return s.translate(table, deletions)</font>
<font color="black"> 494.     else:</font>
<font color="black"> 495.         # Add s[:0] so that if s is Unicode and table is an 8-bit string,</font>
<font color="black"> 496.         # table is converted to Unicode.  This means that table *cannot*</font>
<font color="black"> 497.         # be a dictionary -- for that feature, use u.translate() directly.</font>
<font color="red"> 498.         return s.translate(table + s[:0])</font>
<font color="black"> 499. </font>
<font color="black"> 500. # Capitalize a string, e.g. &quot;aBc  dEf&quot; -&gt; &quot;Abc  def&quot;.</font>
<font color="red"> 501. def capitalize(s):</font>
<font color="black"> 502.     &quot;&quot;&quot;capitalize(s) -&gt; string</font>
<font color="black"> 503. </font>
<font color="black"> 504.     Return a copy of the string s with only its first character</font>
<font color="black"> 505.     capitalized.</font>
<font color="black"> 506. </font>
<font color="black"> 507.     &quot;&quot;&quot;</font>
<font color="red"> 508.     return s.capitalize()</font>
<font color="black"> 509. </font>
<font color="black"> 510. # Substring replacement (global)</font>
<font color="red"> 511. def replace(s, old, new, maxreplace=-1):</font>
<font color="black"> 512.     &quot;&quot;&quot;replace (str, old, new[, maxreplace]) -&gt; string</font>
<font color="black"> 513. </font>
<font color="black"> 514.     Return a copy of string str with all occurrences of substring</font>
<font color="black"> 515.     old replaced by new. If the optional argument maxreplace is</font>
<font color="black"> 516.     given, only the first maxreplace occurrences are replaced.</font>
<font color="black"> 517. </font>
<font color="black"> 518.     &quot;&quot;&quot;</font>
<font color="red"> 519.     return s.replace(old, new, maxreplace)</font>
<font color="black"> 520. </font>
<font color="black"> 521. </font>
<font color="black"> 522. # Try importing optional built-in module &quot;strop&quot; -- if it exists,</font>
<font color="black"> 523. # it redefines some string operations that are 100-1000 times faster.</font>
<font color="black"> 524. # It also defines values for whitespace, lowercase and uppercase</font>
<font color="black"> 525. # that match &lt;ctype.h&gt;'s definitions.</font>
<font color="black"> 526. </font>
<font color="red"> 527. try:</font>
<font color="red"> 528.     from strop import maketrans, lowercase, uppercase, whitespace</font>
<font color="red"> 529.     letters = lowercase + uppercase</font>
<font color="red"> 530. except ImportError:</font>
<font color="red"> 531.     pass                                          # Use the original versions</font>
<font color="black"> 532. </font>
<font color="black"> 533. ########################################################################</font>
<font color="black"> 534. # the Formatter class</font>
<font color="black"> 535. # see PEP 3101 for details and purpose of this class</font>
<font color="black"> 536. </font>
<font color="black"> 537. # The hard parts are reused from the C implementation.  They're exposed as &quot;_&quot;</font>
<font color="black"> 538. # prefixed methods of str and unicode.</font>
<font color="black"> 539. </font>
<font color="black"> 540. # The overall parser is implemented in str._formatter_parser.</font>
<font color="black"> 541. # The field name parser is implemented in str._formatter_field_name_split</font>
<font color="black"> 542. </font>
<font color="red"> 543. class Formatter(object):</font>
<font color="red"> 544.     def format(self, format_string, *args, **kwargs):</font>
<font color="red"> 545.         return self.vformat(format_string, args, kwargs)</font>
<font color="black"> 546. </font>
<font color="red"> 547.     def vformat(self, format_string, args, kwargs):</font>
<font color="red"> 548.         used_args = set()</font>
<font color="red"> 549.         result = self._vformat(format_string, args, kwargs, used_args, 2)</font>
<font color="red"> 550.         self.check_unused_args(used_args, args, kwargs)</font>
<font color="red"> 551.         return result</font>
<font color="black"> 552. </font>
<font color="red"> 553.     def _vformat(self, format_string, args, kwargs, used_args, recursion_depth):</font>
<font color="red"> 554.         if recursion_depth &lt; 0:</font>
<font color="red"> 555.             raise ValueError('Max string recursion exceeded')</font>
<font color="red"> 556.         result = []</font>
<font color="red"> 557.         for literal_text, field_name, format_spec, conversion in \</font>
<font color="red"> 558.                 self.parse(format_string):</font>
<font color="black"> 559. </font>
<font color="black"> 560.             # output the literal text</font>
<font color="red"> 561.             if literal_text:</font>
<font color="red"> 562.                 result.append(literal_text)</font>
<font color="black"> 563. </font>
<font color="black"> 564.             # if there's a field, output it</font>
<font color="red"> 565.             if field_name is not None:</font>
<font color="black"> 566.                 # this is some markup, find the object and do</font>
<font color="black"> 567.                 #  the formatting</font>
<font color="black"> 568. </font>
<font color="black"> 569.                 # given the field_name, find the object it references</font>
<font color="black"> 570.                 #  and the argument it came from</font>
<font color="red"> 571.                 obj, arg_used = self.get_field(field_name, args, kwargs)</font>
<font color="red"> 572.                 used_args.add(arg_used)</font>
<font color="black"> 573. </font>
<font color="black"> 574.                 # do any conversion on the resulting object</font>
<font color="red"> 575.                 obj = self.convert_field(obj, conversion)</font>
<font color="black"> 576. </font>
<font color="black"> 577.                 # expand the format spec, if needed</font>
<font color="red"> 578.                 format_spec = self._vformat(format_spec, args, kwargs,</font>
<font color="red"> 579.                                             used_args, recursion_depth-1)</font>
<font color="black"> 580. </font>
<font color="black"> 581.                 # format the object and append to the result</font>
<font color="red"> 582.                 result.append(self.format_field(obj, format_spec))</font>
<font color="black"> 583. </font>
<font color="red"> 584.         return ''.join(result)</font>
<font color="black"> 585. </font>
<font color="black"> 586. </font>
<font color="red"> 587.     def get_value(self, key, args, kwargs):</font>
<font color="red"> 588.         if isinstance(key, (int, long)):</font>
<font color="red"> 589.             return args[key]</font>
<font color="black"> 590.         else:</font>
<font color="red"> 591.             return kwargs[key]</font>
<font color="black"> 592. </font>
<font color="black"> 593. </font>
<font color="red"> 594.     def check_unused_args(self, used_args, args, kwargs):</font>
<font color="red"> 595.         pass</font>
<font color="black"> 596. </font>
<font color="black"> 597. </font>
<font color="red"> 598.     def format_field(self, value, format_spec):</font>
<font color="red"> 599.         return format(value, format_spec)</font>
<font color="black"> 600. </font>
<font color="black"> 601. </font>
<font color="red"> 602.     def convert_field(self, value, conversion):</font>
<font color="black"> 603.         # do any conversion on the resulting object</font>
<font color="red"> 604.         if conversion is None:</font>
<font color="red"> 605.             return value</font>
<font color="red"> 606.         elif conversion == 's':</font>
<font color="red"> 607.             return str(value)</font>
<font color="red"> 608.         elif conversion == 'r':</font>
<font color="red"> 609.             return repr(value)</font>
<font color="red"> 610.         raise ValueError(&quot;Unknown conversion specifier {0!s}&quot;.format(conversion))</font>
<font color="black"> 611. </font>
<font color="black"> 612. </font>
<font color="black"> 613.     # returns an iterable that contains tuples of the form:</font>
<font color="black"> 614.     # (literal_text, field_name, format_spec, conversion)</font>
<font color="black"> 615.     # literal_text can be zero length</font>
<font color="black"> 616.     # field_name can be None, in which case there's no</font>
<font color="black"> 617.     #  object to format and output</font>
<font color="black"> 618.     # if field_name is not None, it is looked up, formatted</font>
<font color="black"> 619.     #  with format_spec and conversion and then used</font>
<font color="red"> 620.     def parse(self, format_string):</font>
<font color="red"> 621.         return format_string._formatter_parser()</font>
<font color="black"> 622. </font>
<font color="black"> 623. </font>
<font color="black"> 624.     # given a field_name, find the object it references.</font>
<font color="black"> 625.     #  field_name:   the field being looked up, e.g. &quot;0.name&quot;</font>
<font color="black"> 626.     #                 or &quot;lookup[3]&quot;</font>
<font color="black"> 627.     #  used_args:    a set of which args have been used</font>
<font color="black"> 628.     #  args, kwargs: as passed in to vformat</font>
<font color="red"> 629.     def get_field(self, field_name, args, kwargs):</font>
<font color="red"> 630.         first, rest = field_name._formatter_field_name_split()</font>
<font color="black"> 631. </font>
<font color="red"> 632.         obj = self.get_value(first, args, kwargs)</font>
<font color="black"> 633. </font>
<font color="black"> 634.         # loop through the rest of the field_name, doing</font>
<font color="black"> 635.         #  getattr or getitem as needed</font>
<font color="red"> 636.         for is_attr, i in rest:</font>
<font color="red"> 637.             if is_attr:</font>
<font color="red"> 638.                 obj = getattr(obj, i)</font>
<font color="black"> 639.             else:</font>
<font color="red"> 640.                 obj = obj[i]</font>
<font color="black"> 641. </font>
<font color="red"> 642.         return obj, first</font>
</pre>

