source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/aggregates.py</b><br>


file stats: <b>111 lines, 44 executed: 39.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Classes to represent the definitions of aggregate functions.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="green">   4. from django.core.exceptions import FieldError</font>
<font color="green">   5. from django.db.models.expressions import Func, Star</font>
<font color="green">   6. from django.db.models.fields import FloatField, IntegerField</font>
<font color="black">   7. </font>
<font color="black">   8. __all__ = [</font>
<font color="green">   9.     'Aggregate', 'Avg', 'Count', 'Max', 'Min', 'StdDev', 'Sum', 'Variance',</font>
<font color="black">  10. ]</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class Aggregate(Func):</font>
<font color="green">  14.     contains_aggregate = True</font>
<font color="green">  15.     name = None</font>
<font color="black">  16. </font>
<font color="green">  17.     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):</font>
<font color="black">  18.         # Aggregates are not allowed in UPDATE queries, so ignore for_save</font>
<font color="red">  19.         c = super(Aggregate, self).resolve_expression(query, allow_joins, reuse, summarize)</font>
<font color="red">  20.         if not summarize:</font>
<font color="red">  21.             expressions = c.get_source_expressions()</font>
<font color="red">  22.             for index, expr in enumerate(expressions):</font>
<font color="red">  23.                 if expr.contains_aggregate:</font>
<font color="red">  24.                     before_resolved = self.get_source_expressions()[index]</font>
<font color="red">  25.                     name = before_resolved.name if hasattr(before_resolved, 'name') else repr(before_resolved)</font>
<font color="red">  26.                     raise FieldError(&quot;Cannot compute %s('%s'): '%s' is an aggregate&quot; % (c.name, name, name))</font>
<font color="red">  27.         c._patch_aggregate(query)  # backward-compatibility support</font>
<font color="red">  28.         return c</font>
<font color="black">  29. </font>
<font color="green">  30.     @property</font>
<font color="black">  31.     def default_alias(self):</font>
<font color="red">  32.         expressions = self.get_source_expressions()</font>
<font color="red">  33.         if len(expressions) == 1 and hasattr(expressions[0], 'name'):</font>
<font color="red">  34.             return '%s__%s' % (expressions[0].name, self.name.lower())</font>
<font color="red">  35.         raise TypeError(&quot;Complex expressions require an alias&quot;)</font>
<font color="black">  36. </font>
<font color="green">  37.     def get_group_by_cols(self):</font>
<font color="red">  38.         return []</font>
<font color="black">  39. </font>
<font color="green">  40.     def _patch_aggregate(self, query):</font>
<font color="black">  41.         &quot;&quot;&quot;</font>
<font color="black">  42.         Helper method for patching 3rd party aggregates that do not yet support</font>
<font color="black">  43.         the new way of subclassing. This method will be removed in Django 1.10.</font>
<font color="black">  44. </font>
<font color="black">  45.         add_to_query(query, alias, col, source, is_summary) will be defined on</font>
<font color="black">  46.         legacy aggregates which, in turn, instantiates the SQL implementation of</font>
<font color="black">  47.         the aggregate. In all the cases found, the general implementation of</font>
<font color="black">  48.         add_to_query looks like:</font>
<font color="black">  49. </font>
<font color="black">  50.         def add_to_query(self, query, alias, col, source, is_summary):</font>
<font color="black">  51.             klass = SQLImplementationAggregate</font>
<font color="black">  52.             aggregate = klass(col, source=source, is_summary=is_summary, **self.extra)</font>
<font color="black">  53.             query.aggregates[alias] = aggregate</font>
<font color="black">  54. </font>
<font color="black">  55.         By supplying a known alias, we can get the SQLAggregate out of the</font>
<font color="black">  56.         aggregates dict, and use the sql_function and sql_template attributes</font>
<font color="black">  57.         to patch *this* aggregate.</font>
<font color="black">  58.         &quot;&quot;&quot;</font>
<font color="red">  59.         if not hasattr(self, 'add_to_query') or self.function is not None:</font>
<font color="red">  60.             return</font>
<font color="black">  61. </font>
<font color="red">  62.         placeholder_alias = &quot;_XXXXXXXX_&quot;</font>
<font color="red">  63.         self.add_to_query(query, placeholder_alias, None, None, None)</font>
<font color="red">  64.         sql_aggregate = query.aggregates.pop(placeholder_alias)</font>
<font color="red">  65.         if 'sql_function' not in self.extra and hasattr(sql_aggregate, 'sql_function'):</font>
<font color="red">  66.             self.extra['function'] = sql_aggregate.sql_function</font>
<font color="black">  67. </font>
<font color="red">  68.         if hasattr(sql_aggregate, 'sql_template'):</font>
<font color="red">  69.             self.extra['template'] = sql_aggregate.sql_template</font>
<font color="black">  70. </font>
<font color="black">  71. </font>
<font color="green">  72. class Avg(Aggregate):</font>
<font color="green">  73.     function = 'AVG'</font>
<font color="green">  74.     name = 'Avg'</font>
<font color="black">  75. </font>
<font color="green">  76.     def __init__(self, expression, **extra):</font>
<font color="red">  77.         output_field = extra.pop('output_field', FloatField())</font>
<font color="red">  78.         super(Avg, self).__init__(expression, output_field=output_field, **extra)</font>
<font color="black">  79. </font>
<font color="green">  80.     def as_oracle(self, compiler, connection):</font>
<font color="red">  81.         if self.output_field.get_internal_type() == 'DurationField':</font>
<font color="red">  82.             expression = self.get_source_expressions()[0]</font>
<font color="red">  83.             from django.db.backends.oracle.functions import IntervalToSeconds, SecondsToInterval</font>
<font color="red">  84.             return compiler.compile(</font>
<font color="red">  85.                 SecondsToInterval(Avg(IntervalToSeconds(expression)))</font>
<font color="black">  86.             )</font>
<font color="red">  87.         return super(Avg, self).as_sql(compiler, connection)</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="green">  90. class Count(Aggregate):</font>
<font color="green">  91.     function = 'COUNT'</font>
<font color="green">  92.     name = 'Count'</font>
<font color="green">  93.     template = '%(function)s(%(distinct)s%(expressions)s)'</font>
<font color="black">  94. </font>
<font color="green">  95.     def __init__(self, expression, distinct=False, **extra):</font>
<font color="red">  96.         if expression == '*':</font>
<font color="red">  97.             expression = Star()</font>
<font color="red">  98.         super(Count, self).__init__(</font>
<font color="red">  99.             expression, distinct='DISTINCT ' if distinct else '', output_field=IntegerField(), **extra)</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def __repr__(self):</font>
<font color="red"> 102.         return &quot;{}({}, distinct={})&quot;.format(</font>
<font color="red"> 103.             self.__class__.__name__,</font>
<font color="red"> 104.             self.arg_joiner.join(str(arg) for arg in self.source_expressions),</font>
<font color="red"> 105.             'False' if self.extra['distinct'] == '' else 'True',</font>
<font color="black"> 106.         )</font>
<font color="black"> 107. </font>
<font color="green"> 108.     def convert_value(self, value, expression, connection, context):</font>
<font color="red"> 109.         if value is None:</font>
<font color="red"> 110.             return 0</font>
<font color="red"> 111.         return int(value)</font>
<font color="black"> 112. </font>
<font color="black"> 113. </font>
<font color="green"> 114. class Max(Aggregate):</font>
<font color="green"> 115.     function = 'MAX'</font>
<font color="green"> 116.     name = 'Max'</font>
<font color="black"> 117. </font>
<font color="black"> 118. </font>
<font color="green"> 119. class Min(Aggregate):</font>
<font color="green"> 120.     function = 'MIN'</font>
<font color="green"> 121.     name = 'Min'</font>
<font color="black"> 122. </font>
<font color="black"> 123. </font>
<font color="green"> 124. class StdDev(Aggregate):</font>
<font color="green"> 125.     name = 'StdDev'</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def __init__(self, expression, sample=False, **extra):</font>
<font color="red"> 128.         self.function = 'STDDEV_SAMP' if sample else 'STDDEV_POP'</font>
<font color="red"> 129.         super(StdDev, self).__init__(expression, output_field=FloatField(), **extra)</font>
<font color="black"> 130. </font>
<font color="green"> 131.     def __repr__(self):</font>
<font color="red"> 132.         return &quot;{}({}, sample={})&quot;.format(</font>
<font color="red"> 133.             self.__class__.__name__,</font>
<font color="red"> 134.             self.arg_joiner.join(str(arg) for arg in self.source_expressions),</font>
<font color="red"> 135.             'False' if self.function == 'STDDEV_POP' else 'True',</font>
<font color="black"> 136.         )</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def convert_value(self, value, expression, connection, context):</font>
<font color="red"> 139.         if value is None:</font>
<font color="red"> 140.             return value</font>
<font color="red"> 141.         return float(value)</font>
<font color="black"> 142. </font>
<font color="black"> 143. </font>
<font color="green"> 144. class Sum(Aggregate):</font>
<font color="green"> 145.     function = 'SUM'</font>
<font color="green"> 146.     name = 'Sum'</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def as_oracle(self, compiler, connection):</font>
<font color="red"> 149.         if self.output_field.get_internal_type() == 'DurationField':</font>
<font color="red"> 150.             expression = self.get_source_expressions()[0]</font>
<font color="red"> 151.             from django.db.backends.oracle.functions import IntervalToSeconds, SecondsToInterval</font>
<font color="red"> 152.             return compiler.compile(</font>
<font color="red"> 153.                 SecondsToInterval(Sum(IntervalToSeconds(expression)))</font>
<font color="black"> 154.             )</font>
<font color="red"> 155.         return super(Sum, self).as_sql(compiler, connection)</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="green"> 158. class Variance(Aggregate):</font>
<font color="green"> 159.     name = 'Variance'</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def __init__(self, expression, sample=False, **extra):</font>
<font color="red"> 162.         self.function = 'VAR_SAMP' if sample else 'VAR_POP'</font>
<font color="red"> 163.         super(Variance, self).__init__(expression, output_field=FloatField(), **extra)</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def __repr__(self):</font>
<font color="red"> 166.         return &quot;{}({}, sample={})&quot;.format(</font>
<font color="red"> 167.             self.__class__.__name__,</font>
<font color="red"> 168.             self.arg_joiner.join(str(arg) for arg in self.source_expressions),</font>
<font color="red"> 169.             'False' if self.function == 'VAR_POP' else 'True',</font>
<font color="black"> 170.         )</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def convert_value(self, value, expression, connection, context):</font>
<font color="red"> 173.         if value is None:</font>
<font color="red"> 174.             return value</font>
<font color="red"> 175.         return float(value)</font>
</pre>

