source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/management/__init__.py</b><br>


file stats: <b>176 lines, 87 executed: 49.4% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import collections</font>
<font color="green">   4. import os</font>
<font color="green">   5. import pkgutil</font>
<font color="green">   6. import sys</font>
<font color="green">   7. from importlib import import_module</font>
<font color="black">   8. </font>
<font color="green">   9. import django</font>
<font color="green">  10. from django.apps import apps</font>
<font color="green">  11. from django.conf import settings</font>
<font color="green">  12. from django.core.exceptions import ImproperlyConfigured</font>
<font color="green">  13. from django.core.management.base import (</font>
<font color="black">  14.     BaseCommand, CommandError, CommandParser, handle_default_options,</font>
<font color="black">  15. )</font>
<font color="green">  16. from django.core.management.color import color_style</font>
<font color="green">  17. from django.utils import autoreload, lru_cache, six</font>
<font color="green">  18. from django.utils._os import npath, upath</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. def find_commands(management_dir):</font>
<font color="black">  22.     &quot;&quot;&quot;</font>
<font color="black">  23.     Given a path to a management directory, returns a list of all the command</font>
<font color="black">  24.     names that are available.</font>
<font color="black">  25. </font>
<font color="black">  26.     Returns an empty list if no commands are defined.</font>
<font color="black">  27.     &quot;&quot;&quot;</font>
<font color="green">  28.     command_dir = os.path.join(management_dir, 'commands')</font>
<font color="green">  29.     return [name for _, name, is_pkg in pkgutil.iter_modules([npath(command_dir)])</font>
<font color="green">  30.             if not is_pkg and not name.startswith('_')]</font>
<font color="black">  31. </font>
<font color="black">  32. </font>
<font color="green">  33. def load_command_class(app_name, name):</font>
<font color="black">  34.     &quot;&quot;&quot;</font>
<font color="black">  35.     Given a command name and an application name, returns the Command</font>
<font color="black">  36.     class instance. All errors raised by the import process</font>
<font color="black">  37.     (ImportError, AttributeError) are allowed to propagate.</font>
<font color="black">  38.     &quot;&quot;&quot;</font>
<font color="green">  39.     module = import_module('%s.management.commands.%s' % (app_name, name))</font>
<font color="green">  40.     return module.Command()</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. @lru_cache.lru_cache(maxsize=None)</font>
<font color="black">  44. def get_commands():</font>
<font color="black">  45.     &quot;&quot;&quot;</font>
<font color="black">  46.     Returns a dictionary mapping command names to their callback applications.</font>
<font color="black">  47. </font>
<font color="black">  48.     This works by looking for a management.commands package in django.core, and</font>
<font color="black">  49.     in each installed application -- if a commands package exists, all commands</font>
<font color="black">  50.     in that package are registered.</font>
<font color="black">  51. </font>
<font color="black">  52.     Core commands are always included. If a settings module has been</font>
<font color="black">  53.     specified, user-defined commands will also be included.</font>
<font color="black">  54. </font>
<font color="black">  55.     The dictionary is in the format {command_name: app_name}. Key-value</font>
<font color="black">  56.     pairs from this dictionary can then be used in calls to</font>
<font color="black">  57.     load_command_class(app_name, command_name)</font>
<font color="black">  58. </font>
<font color="black">  59.     If a specific version of a command must be loaded (e.g., with the</font>
<font color="black">  60.     startapp command), the instantiated module can be placed in the</font>
<font color="black">  61.     dictionary in place of the application name.</font>
<font color="black">  62. </font>
<font color="black">  63.     The dictionary is cached on the first call and reused on subsequent</font>
<font color="black">  64.     calls.</font>
<font color="black">  65.     &quot;&quot;&quot;</font>
<font color="green">  66.     commands = {name: 'django.core' for name in find_commands(upath(__path__[0]))}</font>
<font color="black">  67. </font>
<font color="green">  68.     if not settings.configured:</font>
<font color="red">  69.         return commands</font>
<font color="black">  70. </font>
<font color="green">  71.     for app_config in reversed(list(apps.get_app_configs())):</font>
<font color="green">  72.         path = os.path.join(app_config.path, 'management')</font>
<font color="green">  73.         commands.update({name: app_config.name for name in find_commands(path)})</font>
<font color="black">  74. </font>
<font color="green">  75.     return commands</font>
<font color="black">  76. </font>
<font color="black">  77. </font>
<font color="green">  78. def call_command(name, *args, **options):</font>
<font color="black">  79.     &quot;&quot;&quot;</font>
<font color="black">  80.     Calls the given command, with the given options and args/kwargs.</font>
<font color="black">  81. </font>
<font color="black">  82.     This is the primary API you should use for calling specific commands.</font>
<font color="black">  83. </font>
<font color="black">  84.     Some examples:</font>
<font color="black">  85.         call_command('migrate')</font>
<font color="black">  86.         call_command('shell', plain=True)</font>
<font color="black">  87.         call_command('sqlmigrate', 'myapp')</font>
<font color="black">  88.     &quot;&quot;&quot;</font>
<font color="black">  89.     # Load the command object.</font>
<font color="green">  90.     try:</font>
<font color="green">  91.         app_name = get_commands()[name]</font>
<font color="red">  92.     except KeyError:</font>
<font color="red">  93.         raise CommandError(&quot;Unknown command: %r&quot; % name)</font>
<font color="black">  94. </font>
<font color="green">  95.     if isinstance(app_name, BaseCommand):</font>
<font color="black">  96.         # If the command is already loaded, use it directly.</font>
<font color="red">  97.         command = app_name</font>
<font color="black">  98.     else:</font>
<font color="green">  99.         command = load_command_class(app_name, name)</font>
<font color="black"> 100. </font>
<font color="black"> 101.     # Simulate argument parsing to get the option defaults (see #10080 for details).</font>
<font color="green"> 102.     parser = command.create_parser('', name)</font>
<font color="green"> 103.     if command.use_argparse:</font>
<font color="black"> 104.         # Use the `dest` option name from the parser option</font>
<font color="green"> 105.         opt_mapping = {sorted(s_opt.option_strings)[0].lstrip('-').replace('-', '_'): s_opt.dest</font>
<font color="green"> 106.                        for s_opt in parser._actions if s_opt.option_strings}</font>
<font color="green"> 107.         arg_options = {opt_mapping.get(key, key): value for key, value in options.items()}</font>
<font color="green"> 108.         defaults = parser.parse_args(args=args)</font>
<font color="green"> 109.         defaults = dict(defaults._get_kwargs(), **arg_options)</font>
<font color="black"> 110.         # Move positional args out of options to mimic legacy optparse</font>
<font color="green"> 111.         args = defaults.pop('args', ())</font>
<font color="black"> 112.     else:</font>
<font color="black"> 113.         # Legacy optparse method</font>
<font color="red"> 114.         defaults, _ = parser.parse_args(args=[])</font>
<font color="red"> 115.         defaults = dict(defaults.__dict__, **options)</font>
<font color="green"> 116.     if 'skip_checks' not in options:</font>
<font color="green"> 117.         defaults['skip_checks'] = True</font>
<font color="black"> 118. </font>
<font color="green"> 119.     return command.execute(*args, **defaults)</font>
<font color="black"> 120. </font>
<font color="black"> 121. </font>
<font color="green"> 122. class ManagementUtility(object):</font>
<font color="black"> 123.     &quot;&quot;&quot;</font>
<font color="black"> 124.     Encapsulates the logic of the django-admin and manage.py utilities.</font>
<font color="black"> 125. </font>
<font color="black"> 126.     A ManagementUtility has a number of commands, which can be manipulated</font>
<font color="black"> 127.     by editing the self.commands dictionary.</font>
<font color="green"> 128.     &quot;&quot;&quot;</font>
<font color="green"> 129.     def __init__(self, argv=None):</font>
<font color="green"> 130.         self.argv = argv or sys.argv[:]</font>
<font color="green"> 131.         self.prog_name = os.path.basename(self.argv[0])</font>
<font color="green"> 132.         self.settings_exception = None</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def main_help_text(self, commands_only=False):</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="black"> 136.         Returns the script's main help text, as a string.</font>
<font color="black"> 137.         &quot;&quot;&quot;</font>
<font color="red"> 138.         if commands_only:</font>
<font color="red"> 139.             usage = sorted(get_commands().keys())</font>
<font color="black"> 140.         else:</font>
<font color="black"> 141.             usage = [</font>
<font color="red"> 142.                 &quot;&quot;,</font>
<font color="red"> 143.                 &quot;Type '%s help &lt;subcommand&gt;' for help on a specific subcommand.&quot; % self.prog_name,</font>
<font color="red"> 144.                 &quot;&quot;,</font>
<font color="red"> 145.                 &quot;Available subcommands:&quot;,</font>
<font color="black"> 146.             ]</font>
<font color="red"> 147.             commands_dict = collections.defaultdict(lambda: [])</font>
<font color="red"> 148.             for name, app in six.iteritems(get_commands()):</font>
<font color="red"> 149.                 if app == 'django.core':</font>
<font color="red"> 150.                     app = 'django'</font>
<font color="black"> 151.                 else:</font>
<font color="red"> 152.                     app = app.rpartition('.')[-1]</font>
<font color="red"> 153.                 commands_dict[app].append(name)</font>
<font color="red"> 154.             style = color_style()</font>
<font color="red"> 155.             for app in sorted(commands_dict.keys()):</font>
<font color="red"> 156.                 usage.append(&quot;&quot;)</font>
<font color="red"> 157.                 usage.append(style.NOTICE(&quot;[%s]&quot; % app))</font>
<font color="red"> 158.                 for name in sorted(commands_dict[app]):</font>
<font color="red"> 159.                     usage.append(&quot;    %s&quot; % name)</font>
<font color="black"> 160.             # Output an extra note if settings are not properly configured</font>
<font color="red"> 161.             if self.settings_exception is not None:</font>
<font color="red"> 162.                 usage.append(style.NOTICE(</font>
<font color="red"> 163.                     &quot;Note that only Django core commands are listed &quot;</font>
<font color="black"> 164.                     &quot;as settings are not properly configured (error: %s).&quot;</font>
<font color="red"> 165.                     % self.settings_exception))</font>
<font color="black"> 166. </font>
<font color="red"> 167.         return '\n'.join(usage)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def fetch_command(self, subcommand):</font>
<font color="black"> 170.         &quot;&quot;&quot;</font>
<font color="black"> 171.         Tries to fetch the given subcommand, printing a message with the</font>
<font color="black"> 172.         appropriate command called from the command line (usually</font>
<font color="black"> 173.         &quot;django-admin&quot; or &quot;manage.py&quot;) if it can't be found.</font>
<font color="black"> 174.         &quot;&quot;&quot;</font>
<font color="black"> 175.         # Get commands outside of try block to prevent swallowing exceptions</font>
<font color="green"> 176.         commands = get_commands()</font>
<font color="green"> 177.         try:</font>
<font color="green"> 178.             app_name = commands[subcommand]</font>
<font color="red"> 179.         except KeyError:</font>
<font color="red"> 180.             if os.environ.get('DJANGO_SETTINGS_MODULE'):</font>
<font color="black"> 181.                 # If `subcommand` is missing due to misconfigured settings, the</font>
<font color="black"> 182.                 # following line will retrigger an ImproperlyConfigured exception</font>
<font color="black"> 183.                 # (get_commands() swallows the original one) so the user is</font>
<font color="black"> 184.                 # informed about it.</font>
<font color="red"> 185.                 settings.INSTALLED_APPS</font>
<font color="black"> 186.             else:</font>
<font color="red"> 187.                 sys.stderr.write(&quot;No Django settings specified.\n&quot;)</font>
<font color="red"> 188.             sys.stderr.write(&quot;Unknown command: %r\nType '%s help' for usage.\n&quot; %</font>
<font color="red"> 189.                 (subcommand, self.prog_name))</font>
<font color="red"> 190.             sys.exit(1)</font>
<font color="green"> 191.         if isinstance(app_name, BaseCommand):</font>
<font color="black"> 192.             # If the command is already loaded, use it directly.</font>
<font color="red"> 193.             klass = app_name</font>
<font color="black"> 194.         else:</font>
<font color="green"> 195.             klass = load_command_class(app_name, subcommand)</font>
<font color="green"> 196.         return klass</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def autocomplete(self):</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="black"> 200.         Output completion suggestions for BASH.</font>
<font color="black"> 201. </font>
<font color="black"> 202.         The output of this function is passed to BASH's `COMREPLY` variable and</font>
<font color="black"> 203.         treated as completion suggestions. `COMREPLY` expects a space</font>
<font color="black"> 204.         separated string as the result.</font>
<font color="black"> 205. </font>
<font color="black"> 206.         The `COMP_WORDS` and `COMP_CWORD` BASH environment variables are used</font>
<font color="black"> 207.         to get information about the cli input. Please refer to the BASH</font>
<font color="black"> 208.         man-page for more information about this variables.</font>
<font color="black"> 209. </font>
<font color="black"> 210.         Subcommand options are saved as pairs. A pair consists of</font>
<font color="black"> 211.         the long option string (e.g. '--exclude') and a boolean</font>
<font color="black"> 212.         value indicating if the option requires arguments. When printing to</font>
<font color="black"> 213.         stdout, an equal sign is appended to options which require arguments.</font>
<font color="black"> 214. </font>
<font color="black"> 215.         Note: If debugging this function, it is recommended to write the debug</font>
<font color="black"> 216.         output in a separate file. Otherwise the debug output will be treated</font>
<font color="black"> 217.         and formatted as potential completion suggestions.</font>
<font color="black"> 218.         &quot;&quot;&quot;</font>
<font color="black"> 219.         # Don't complete if user hasn't sourced bash_completion file.</font>
<font color="green"> 220.         if 'DJANGO_AUTO_COMPLETE' not in os.environ:</font>
<font color="green"> 221.             return</font>
<font color="black"> 222. </font>
<font color="red"> 223.         cwords = os.environ['COMP_WORDS'].split()[1:]</font>
<font color="red"> 224.         cword = int(os.environ['COMP_CWORD'])</font>
<font color="black"> 225. </font>
<font color="red"> 226.         try:</font>
<font color="red"> 227.             curr = cwords[cword - 1]</font>
<font color="red"> 228.         except IndexError:</font>
<font color="red"> 229.             curr = ''</font>
<font color="black"> 230. </font>
<font color="red"> 231.         subcommands = list(get_commands()) + ['help']</font>
<font color="red"> 232.         options = [('--help', False)]</font>
<font color="black"> 233. </font>
<font color="black"> 234.         # subcommand</font>
<font color="red"> 235.         if cword == 1:</font>
<font color="red"> 236.             print(' '.join(sorted(filter(lambda x: x.startswith(curr), subcommands))))</font>
<font color="black"> 237.         # subcommand options</font>
<font color="black"> 238.         # special case: the 'help' subcommand has no options</font>
<font color="red"> 239.         elif cwords[0] in subcommands and cwords[0] != 'help':</font>
<font color="red"> 240.             subcommand_cls = self.fetch_command(cwords[0])</font>
<font color="black"> 241.             # special case: add the names of installed apps to options</font>
<font color="red"> 242.             if cwords[0] in ('dumpdata', 'sqlmigrate', 'sqlsequencereset', 'test'):</font>
<font color="red"> 243.                 try:</font>
<font color="red"> 244.                     app_configs = apps.get_app_configs()</font>
<font color="black"> 245.                     # Get the last part of the dotted path as the app name.</font>
<font color="red"> 246.                     options.extend((app_config.label, 0) for app_config in app_configs)</font>
<font color="red"> 247.                 except ImportError:</font>
<font color="black"> 248.                     # Fail silently if DJANGO_SETTINGS_MODULE isn't set. The</font>
<font color="black"> 249.                     # user will find out once they execute the command.</font>
<font color="red"> 250.                     pass</font>
<font color="red"> 251.             parser = subcommand_cls.create_parser('', cwords[0])</font>
<font color="red"> 252.             if subcommand_cls.use_argparse:</font>
<font color="red"> 253.                 options.extend((sorted(s_opt.option_strings)[0], s_opt.nargs != 0) for s_opt in</font>
<font color="red"> 254.                                parser._actions if s_opt.option_strings)</font>
<font color="black"> 255.             else:</font>
<font color="red"> 256.                 options.extend((s_opt.get_opt_string(), s_opt.nargs != 0) for s_opt in</font>
<font color="red"> 257.                                parser.option_list)</font>
<font color="black"> 258.             # filter out previously specified options from available options</font>
<font color="red"> 259.             prev_opts = [x.split('=')[0] for x in cwords[1:cword - 1]]</font>
<font color="red"> 260.             options = [opt for opt in options if opt[0] not in prev_opts]</font>
<font color="black"> 261. </font>
<font color="black"> 262.             # filter options by current input</font>
<font color="red"> 263.             options = sorted((k, v) for k, v in options if k.startswith(curr))</font>
<font color="red"> 264.             for option in options:</font>
<font color="red"> 265.                 opt_label = option[0]</font>
<font color="black"> 266.                 # append '=' to options which require args</font>
<font color="red"> 267.                 if option[1]:</font>
<font color="red"> 268.                     opt_label += '='</font>
<font color="red"> 269.                 print(opt_label)</font>
<font color="red"> 270.         sys.exit(1)</font>
<font color="black"> 271. </font>
<font color="green"> 272.     def execute(self):</font>
<font color="black"> 273.         &quot;&quot;&quot;</font>
<font color="black"> 274.         Given the command-line arguments, this figures out which subcommand is</font>
<font color="black"> 275.         being run, creates a parser appropriate to that command, and runs it.</font>
<font color="black"> 276.         &quot;&quot;&quot;</font>
<font color="green"> 277.         try:</font>
<font color="green"> 278.             subcommand = self.argv[1]</font>
<font color="red"> 279.         except IndexError:</font>
<font color="red"> 280.             subcommand = 'help'  # Display help if no arguments were given.</font>
<font color="black"> 281. </font>
<font color="black"> 282.         # Preprocess options to extract --settings and --pythonpath.</font>
<font color="black"> 283.         # These options could affect the commands that are available, so they</font>
<font color="black"> 284.         # must be processed early.</font>
<font color="green"> 285.         parser = CommandParser(None, usage=&quot;%(prog)s subcommand [options] [args]&quot;, add_help=False)</font>
<font color="green"> 286.         parser.add_argument('--settings')</font>
<font color="green"> 287.         parser.add_argument('--pythonpath')</font>
<font color="green"> 288.         parser.add_argument('args', nargs='*')  # catch-all</font>
<font color="green"> 289.         try:</font>
<font color="green"> 290.             options, args = parser.parse_known_args(self.argv[2:])</font>
<font color="green"> 291.             handle_default_options(options)</font>
<font color="red"> 292.         except CommandError:</font>
<font color="red"> 293.             pass  # Ignore any option errors at this point.</font>
<font color="black"> 294. </font>
<font color="black"> 295.         no_settings_commands = [</font>
<font color="green"> 296.             'help', 'version', '--help', '--version', '-h',</font>
<font color="green"> 297.             'compilemessages', 'makemessages',</font>
<font color="green"> 298.             'startapp', 'startproject',</font>
<font color="black"> 299.         ]</font>
<font color="black"> 300. </font>
<font color="green"> 301.         try:</font>
<font color="green"> 302.             settings.INSTALLED_APPS</font>
<font color="red"> 303.         except ImproperlyConfigured as exc:</font>
<font color="red"> 304.             self.settings_exception = exc</font>
<font color="black"> 305.             # A handful of built-in management commands work without settings.</font>
<font color="black"> 306.             # Load the default settings -- where INSTALLED_APPS is empty.</font>
<font color="red"> 307.             if subcommand in no_settings_commands:</font>
<font color="red"> 308.                 settings.configure()</font>
<font color="black"> 309. </font>
<font color="green"> 310.         if settings.configured:</font>
<font color="black"> 311.             # Start the auto-reloading dev server even if the code is broken.</font>
<font color="black"> 312.             # The hardcoded condition is a code smell but we can't rely on a</font>
<font color="black"> 313.             # flag on the command class because we haven't located it yet.</font>
<font color="green"> 314.             if subcommand == 'runserver' and '--noreload' not in self.argv:</font>
<font color="red"> 315.                 try:</font>
<font color="red"> 316.                     autoreload.check_errors(django.setup)()</font>
<font color="red"> 317.                 except Exception:</font>
<font color="black"> 318.                     # The exception will be raised later in the child process</font>
<font color="black"> 319.                     # started by the autoreloader.</font>
<font color="red"> 320.                     pass</font>
<font color="black"> 321. </font>
<font color="black"> 322.             # In all other cases, django.setup() is required to succeed.</font>
<font color="black"> 323.             else:</font>
<font color="green"> 324.                 django.setup()</font>
<font color="black"> 325. </font>
<font color="green"> 326.         self.autocomplete()</font>
<font color="black"> 327. </font>
<font color="green"> 328.         if subcommand == 'help':</font>
<font color="red"> 329.             if '--commands' in args:</font>
<font color="red"> 330.                 sys.stdout.write(self.main_help_text(commands_only=True) + '\n')</font>
<font color="red"> 331.             elif len(options.args) &lt; 1:</font>
<font color="red"> 332.                 sys.stdout.write(self.main_help_text() + '\n')</font>
<font color="black"> 333.             else:</font>
<font color="red"> 334.                 self.fetch_command(options.args[0]).print_help(self.prog_name, options.args[0])</font>
<font color="black"> 335.         # Special-cases: We want 'django-admin --version' and</font>
<font color="black"> 336.         # 'django-admin --help' to work, for backwards compatibility.</font>
<font color="green"> 337.         elif subcommand == 'version' or self.argv[1:] == ['--version']:</font>
<font color="red"> 338.             sys.stdout.write(django.get_version() + '\n')</font>
<font color="green"> 339.         elif self.argv[1:] in (['--help'], ['-h']):</font>
<font color="red"> 340.             sys.stdout.write(self.main_help_text() + '\n')</font>
<font color="black"> 341.         else:</font>
<font color="green"> 342.             self.fetch_command(subcommand).run_from_argv(self.argv)</font>
<font color="black"> 343. </font>
<font color="black"> 344. </font>
<font color="green"> 345. def execute_from_command_line(argv=None):</font>
<font color="black"> 346.     &quot;&quot;&quot;</font>
<font color="black"> 347.     A simple method that runs a ManagementUtility.</font>
<font color="black"> 348.     &quot;&quot;&quot;</font>
<font color="green"> 349.     utility = ManagementUtility(argv)</font>
<font color="green"> 350.     utility.execute()</font>
</pre>

