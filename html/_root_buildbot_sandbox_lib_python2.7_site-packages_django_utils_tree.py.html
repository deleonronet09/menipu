source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/tree.py</b><br>


file stats: <b>55 lines, 34 executed: 61.8% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. A class for storing a tree graph. Primarily used for filter constructs in the</font>
<font color="black">   3. ORM.</font>
<font color="green">   4. &quot;&quot;&quot;</font>
<font color="black">   5. </font>
<font color="green">   6. import copy</font>
<font color="black">   7. </font>
<font color="black">   8. </font>
<font color="green">   9. class Node(object):</font>
<font color="black">  10.     &quot;&quot;&quot;</font>
<font color="black">  11.     A single internal node in the tree graph. A Node should be viewed as a</font>
<font color="black">  12.     connection (the root) with the children being either leaf nodes or other</font>
<font color="black">  13.     Node instances.</font>
<font color="green">  14.     &quot;&quot;&quot;</font>
<font color="black">  15.     # Standard connector type. Clients usually won't use this at all and</font>
<font color="black">  16.     # subclasses will usually override the value.</font>
<font color="green">  17.     default = 'DEFAULT'</font>
<font color="black">  18. </font>
<font color="green">  19.     def __init__(self, children=None, connector=None, negated=False):</font>
<font color="black">  20.         &quot;&quot;&quot;</font>
<font color="black">  21.         Constructs a new Node. If no connector is given, the default will be</font>
<font color="black">  22.         used.</font>
<font color="black">  23.         &quot;&quot;&quot;</font>
<font color="green">  24.         self.children = children[:] if children else []</font>
<font color="green">  25.         self.connector = connector or self.default</font>
<font color="green">  26.         self.negated = negated</font>
<font color="black">  27. </font>
<font color="black">  28.     # We need this because of django.db.models.query_utils.Q. Q. __init__() is</font>
<font color="black">  29.     # problematic, but it is a natural Node subclass in all other respects.</font>
<font color="green">  30.     @classmethod</font>
<font color="green">  31.     def _new_instance(cls, children=None, connector=None, negated=False):</font>
<font color="black">  32.         &quot;&quot;&quot;</font>
<font color="black">  33.         This is called to create a new instance of this class when we need new</font>
<font color="black">  34.         Nodes (or subclasses) in the internal code in this class. Normally, it</font>
<font color="black">  35.         just shadows __init__(). However, subclasses with an __init__ signature</font>
<font color="black">  36.         that is not an extension of Node.__init__ might need to implement this</font>
<font color="black">  37.         method to allow a Node to create a new instance of them (if they have</font>
<font color="black">  38.         any extra setting up to do).</font>
<font color="black">  39.         &quot;&quot;&quot;</font>
<font color="green">  40.         obj = Node(children, connector, negated)</font>
<font color="green">  41.         obj.__class__ = cls</font>
<font color="green">  42.         return obj</font>
<font color="black">  43. </font>
<font color="green">  44.     def __str__(self):</font>
<font color="red">  45.         if self.negated:</font>
<font color="red">  46.             return '(NOT (%s: %s))' % (self.connector, ', '.join(str(c) for c</font>
<font color="red">  47.                     in self.children))</font>
<font color="red">  48.         return '(%s: %s)' % (self.connector, ', '.join(str(c) for c in</font>
<font color="red">  49.                 self.children))</font>
<font color="black">  50. </font>
<font color="green">  51.     def __repr__(self):</font>
<font color="red">  52.         return &quot;&lt;%s: %s&gt;&quot; % (self.__class__.__name__, self)</font>
<font color="black">  53. </font>
<font color="green">  54.     def __deepcopy__(self, memodict):</font>
<font color="black">  55.         &quot;&quot;&quot;</font>
<font color="black">  56.         Utility method used by copy.deepcopy().</font>
<font color="black">  57.         &quot;&quot;&quot;</font>
<font color="red">  58.         obj = Node(connector=self.connector, negated=self.negated)</font>
<font color="red">  59.         obj.__class__ = self.__class__</font>
<font color="red">  60.         obj.children = copy.deepcopy(self.children, memodict)</font>
<font color="red">  61.         return obj</font>
<font color="black">  62. </font>
<font color="green">  63.     def __len__(self):</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="black">  65.         The size of a node if the number of children it has.</font>
<font color="black">  66.         &quot;&quot;&quot;</font>
<font color="red">  67.         return len(self.children)</font>
<font color="black">  68. </font>
<font color="green">  69.     def __bool__(self):</font>
<font color="black">  70.         &quot;&quot;&quot;</font>
<font color="black">  71.         For truth value testing.</font>
<font color="black">  72.         &quot;&quot;&quot;</font>
<font color="green">  73.         return bool(self.children)</font>
<font color="black">  74. </font>
<font color="green">  75.     def __nonzero__(self):      # Python 2 compatibility</font>
<font color="green">  76.         return type(self).__bool__(self)</font>
<font color="black">  77. </font>
<font color="green">  78.     def __contains__(self, other):</font>
<font color="black">  79.         &quot;&quot;&quot;</font>
<font color="black">  80.         Returns True is 'other' is a direct child of this instance.</font>
<font color="black">  81.         &quot;&quot;&quot;</font>
<font color="red">  82.         return other in self.children</font>
<font color="black">  83. </font>
<font color="green">  84.     def add(self, data, conn_type, squash=True):</font>
<font color="black">  85.         &quot;&quot;&quot;</font>
<font color="black">  86.         Combines this tree and the data represented by data using the</font>
<font color="black">  87.         connector conn_type. The combine is done by squashing the node other</font>
<font color="black">  88.         away if possible.</font>
<font color="black">  89. </font>
<font color="black">  90.         This tree (self) will never be pushed to a child node of the</font>
<font color="black">  91.         combined tree, nor will the connector or negated properties change.</font>
<font color="black">  92. </font>
<font color="black">  93.         The function returns a node which can be used in place of data</font>
<font color="black">  94.         regardless if the node other got squashed or not.</font>
<font color="black">  95. </font>
<font color="black">  96.         If `squash` is False the data is prepared and added as a child to</font>
<font color="black">  97.         this tree without further logic.</font>
<font color="black">  98.         &quot;&quot;&quot;</font>
<font color="green">  99.         if data in self.children:</font>
<font color="red"> 100.             return data</font>
<font color="green"> 101.         if not squash:</font>
<font color="red"> 102.             self.children.append(data)</font>
<font color="red"> 103.             return data</font>
<font color="green"> 104.         if self.connector == conn_type:</font>
<font color="black"> 105.             # We can reuse self.children to append or squash the node other.</font>
<font color="green"> 106.             if (isinstance(data, Node) and not data.negated</font>
<font color="green"> 107.                     and (data.connector == conn_type or len(data) == 1)):</font>
<font color="black"> 108.                 # We can squash the other node's children directly into this</font>
<font color="black"> 109.                 # node. We are just doing (AB)(CD) == (ABCD) here, with the</font>
<font color="black"> 110.                 # addition that if the length of the other node is 1 the</font>
<font color="black"> 111.                 # connector doesn't matter. However, for the len(self) == 1</font>
<font color="black"> 112.                 # case we don't want to do the squashing, as it would alter</font>
<font color="black"> 113.                 # self.connector.</font>
<font color="green"> 114.                 self.children.extend(data.children)</font>
<font color="green"> 115.                 return self</font>
<font color="black"> 116.             else:</font>
<font color="black"> 117.                 # We could use perhaps additional logic here to see if some</font>
<font color="black"> 118.                 # children could be used for pushdown here.</font>
<font color="green"> 119.                 self.children.append(data)</font>
<font color="green"> 120.                 return data</font>
<font color="black"> 121.         else:</font>
<font color="red"> 122.             obj = self._new_instance(self.children, self.connector,</font>
<font color="red"> 123.                                      self.negated)</font>
<font color="red"> 124.             self.connector = conn_type</font>
<font color="red"> 125.             self.children = [obj, data]</font>
<font color="red"> 126.             return data</font>
<font color="black"> 127. </font>
<font color="green"> 128.     def negate(self):</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="black"> 130.         Negate the sense of the root connector.</font>
<font color="black"> 131.         &quot;&quot;&quot;</font>
<font color="red"> 132.         self.negated = not self.negated</font>
</pre>

