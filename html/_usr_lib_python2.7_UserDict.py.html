source file: <b>/usr/lib/python2.7/UserDict.py</b><br>


file stats: <b>158 lines, 15 executed: 9.5% covered</b>
<pre>
<font color="red">   1. &quot;&quot;&quot;A more or less complete user-defined wrapper around dictionary objects.&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="red">   3. class UserDict:</font>
<font color="red">   4.     def __init__(self, dict=None, **kwargs):</font>
<font color="green">   5.         self.data = {}</font>
<font color="green">   6.         if dict is not None:</font>
<font color="red">   7.             self.update(dict)</font>
<font color="green">   8.         if len(kwargs):</font>
<font color="red">   9.             self.update(kwargs)</font>
<font color="red">  10.     def __repr__(self): return repr(self.data)</font>
<font color="red">  11.     def __cmp__(self, dict):</font>
<font color="red">  12.         if isinstance(dict, UserDict):</font>
<font color="red">  13.             return cmp(self.data, dict.data)</font>
<font color="black">  14.         else:</font>
<font color="red">  15.             return cmp(self.data, dict)</font>
<font color="red">  16.     __hash__ = None # Avoid Py3k warning</font>
<font color="red">  17.     def __len__(self): return len(self.data)</font>
<font color="red">  18.     def __getitem__(self, key):</font>
<font color="green">  19.         if key in self.data:</font>
<font color="green">  20.             return self.data[key]</font>
<font color="green">  21.         if hasattr(self.__class__, &quot;__missing__&quot;):</font>
<font color="red">  22.             return self.__class__.__missing__(self, key)</font>
<font color="green">  23.         raise KeyError(key)</font>
<font color="red">  24.     def __setitem__(self, key, item): self.data[key] = item</font>
<font color="red">  25.     def __delitem__(self, key): del self.data[key]</font>
<font color="red">  26.     def clear(self): self.data.clear()</font>
<font color="red">  27.     def copy(self):</font>
<font color="red">  28.         if self.__class__ is UserDict:</font>
<font color="red">  29.             return UserDict(self.data.copy())</font>
<font color="red">  30.         import copy</font>
<font color="red">  31.         data = self.data</font>
<font color="red">  32.         try:</font>
<font color="red">  33.             self.data = {}</font>
<font color="red">  34.             c = copy.copy(self)</font>
<font color="black">  35.         finally:</font>
<font color="red">  36.             self.data = data</font>
<font color="red">  37.         c.update(self)</font>
<font color="red">  38.         return c</font>
<font color="red">  39.     def keys(self): return self.data.keys()</font>
<font color="green">  40.     def items(self): return self.data.items()</font>
<font color="red">  41.     def iteritems(self): return self.data.iteritems()</font>
<font color="red">  42.     def iterkeys(self): return self.data.iterkeys()</font>
<font color="red">  43.     def itervalues(self): return self.data.itervalues()</font>
<font color="red">  44.     def values(self): return self.data.values()</font>
<font color="red">  45.     def has_key(self, key): return key in self.data</font>
<font color="red">  46.     def update(self, dict=None, **kwargs):</font>
<font color="red">  47.         if dict is None:</font>
<font color="red">  48.             pass</font>
<font color="red">  49.         elif isinstance(dict, UserDict):</font>
<font color="red">  50.             self.data.update(dict.data)</font>
<font color="red">  51.         elif isinstance(dict, type({})) or not hasattr(dict, 'items'):</font>
<font color="red">  52.             self.data.update(dict)</font>
<font color="black">  53.         else:</font>
<font color="red">  54.             for k, v in dict.items():</font>
<font color="red">  55.                 self[k] = v</font>
<font color="red">  56.         if len(kwargs):</font>
<font color="red">  57.             self.data.update(kwargs)</font>
<font color="red">  58.     def get(self, key, failobj=None):</font>
<font color="green">  59.         if key not in self:</font>
<font color="green">  60.             return failobj</font>
<font color="green">  61.         return self[key]</font>
<font color="red">  62.     def setdefault(self, key, failobj=None):</font>
<font color="green">  63.         if key not in self:</font>
<font color="green">  64.             self[key] = failobj</font>
<font color="green">  65.         return self[key]</font>
<font color="red">  66.     def pop(self, key, *args):</font>
<font color="red">  67.         return self.data.pop(key, *args)</font>
<font color="red">  68.     def popitem(self):</font>
<font color="red">  69.         return self.data.popitem()</font>
<font color="red">  70.     def __contains__(self, key):</font>
<font color="green">  71.         return key in self.data</font>
<font color="red">  72.     @classmethod</font>
<font color="red">  73.     def fromkeys(cls, iterable, value=None):</font>
<font color="red">  74.         d = cls()</font>
<font color="red">  75.         for key in iterable:</font>
<font color="red">  76.             d[key] = value</font>
<font color="red">  77.         return d</font>
<font color="black">  78. </font>
<font color="red">  79. class IterableUserDict(UserDict):</font>
<font color="red">  80.     def __iter__(self):</font>
<font color="red">  81.         return iter(self.data)</font>
<font color="black">  82. </font>
<font color="red">  83. import _abcoll</font>
<font color="red">  84. _abcoll.MutableMapping.register(IterableUserDict)</font>
<font color="black">  85. </font>
<font color="black">  86. </font>
<font color="red">  87. class DictMixin:</font>
<font color="black">  88.     # Mixin defining all dictionary methods for classes that already have</font>
<font color="black">  89.     # a minimum dictionary interface including getitem, setitem, delitem,</font>
<font color="black">  90.     # and keys. Without knowledge of the subclass constructor, the mixin</font>
<font color="black">  91.     # does not define __init__() or copy().  In addition to the four base</font>
<font color="black">  92.     # methods, progressively more efficiency comes with defining</font>
<font color="black">  93.     # __contains__(), __iter__(), and iteritems().</font>
<font color="black">  94. </font>
<font color="black">  95.     # second level definitions support higher levels</font>
<font color="red">  96.     def __iter__(self):</font>
<font color="red">  97.         for k in self.keys():</font>
<font color="red">  98.             yield k</font>
<font color="red">  99.     def has_key(self, key):</font>
<font color="red"> 100.         try:</font>
<font color="red"> 101.             self[key]</font>
<font color="red"> 102.         except KeyError:</font>
<font color="red"> 103.             return False</font>
<font color="red"> 104.         return True</font>
<font color="red"> 105.     def __contains__(self, key):</font>
<font color="red"> 106.         return self.has_key(key)</font>
<font color="black"> 107. </font>
<font color="black"> 108.     # third level takes advantage of second level definitions</font>
<font color="red"> 109.     def iteritems(self):</font>
<font color="red"> 110.         for k in self:</font>
<font color="red"> 111.             yield (k, self[k])</font>
<font color="red"> 112.     def iterkeys(self):</font>
<font color="red"> 113.         return self.__iter__()</font>
<font color="black"> 114. </font>
<font color="black"> 115.     # fourth level uses definitions from lower levels</font>
<font color="red"> 116.     def itervalues(self):</font>
<font color="red"> 117.         for _, v in self.iteritems():</font>
<font color="red"> 118.             yield v</font>
<font color="red"> 119.     def values(self):</font>
<font color="red"> 120.         return [v for _, v in self.iteritems()]</font>
<font color="red"> 121.     def items(self):</font>
<font color="red"> 122.         return list(self.iteritems())</font>
<font color="red"> 123.     def clear(self):</font>
<font color="red"> 124.         for key in self.keys():</font>
<font color="red"> 125.             del self[key]</font>
<font color="red"> 126.     def setdefault(self, key, default=None):</font>
<font color="red"> 127.         try:</font>
<font color="red"> 128.             return self[key]</font>
<font color="red"> 129.         except KeyError:</font>
<font color="red"> 130.             self[key] = default</font>
<font color="red"> 131.         return default</font>
<font color="red"> 132.     def pop(self, key, *args):</font>
<font color="red"> 133.         if len(args) &gt; 1:</font>
<font color="red"> 134.             raise TypeError, &quot;pop expected at most 2 arguments, got &quot;\</font>
<font color="red"> 135.                               + repr(1 + len(args))</font>
<font color="red"> 136.         try:</font>
<font color="red"> 137.             value = self[key]</font>
<font color="red"> 138.         except KeyError:</font>
<font color="red"> 139.             if args:</font>
<font color="red"> 140.                 return args[0]</font>
<font color="red"> 141.             raise</font>
<font color="red"> 142.         del self[key]</font>
<font color="red"> 143.         return value</font>
<font color="red"> 144.     def popitem(self):</font>
<font color="red"> 145.         try:</font>
<font color="red"> 146.             k, v = self.iteritems().next()</font>
<font color="red"> 147.         except StopIteration:</font>
<font color="red"> 148.             raise KeyError, 'container is empty'</font>
<font color="red"> 149.         del self[k]</font>
<font color="red"> 150.         return (k, v)</font>
<font color="red"> 151.     def update(self, other=None, **kwargs):</font>
<font color="black"> 152.         # Make progressively weaker assumptions about &quot;other&quot;</font>
<font color="red"> 153.         if other is None:</font>
<font color="red"> 154.             pass</font>
<font color="red"> 155.         elif hasattr(other, 'iteritems'):  # iteritems saves memory and lookups</font>
<font color="red"> 156.             for k, v in other.iteritems():</font>
<font color="red"> 157.                 self[k] = v</font>
<font color="red"> 158.         elif hasattr(other, 'keys'):</font>
<font color="red"> 159.             for k in other.keys():</font>
<font color="red"> 160.                 self[k] = other[k]</font>
<font color="black"> 161.         else:</font>
<font color="red"> 162.             for k, v in other:</font>
<font color="red"> 163.                 self[k] = v</font>
<font color="red"> 164.         if kwargs:</font>
<font color="red"> 165.             self.update(kwargs)</font>
<font color="red"> 166.     def get(self, key, default=None):</font>
<font color="red"> 167.         try:</font>
<font color="red"> 168.             return self[key]</font>
<font color="red"> 169.         except KeyError:</font>
<font color="red"> 170.             return default</font>
<font color="red"> 171.     def __repr__(self):</font>
<font color="red"> 172.         return repr(dict(self.iteritems()))</font>
<font color="red"> 173.     def __cmp__(self, other):</font>
<font color="red"> 174.         if other is None:</font>
<font color="red"> 175.             return 1</font>
<font color="red"> 176.         if isinstance(other, DictMixin):</font>
<font color="red"> 177.             other = dict(other.iteritems())</font>
<font color="red"> 178.         return cmp(dict(self.iteritems()), other)</font>
<font color="red"> 179.     def __len__(self):</font>
<font color="red"> 180.         return len(self.keys())</font>
</pre>

