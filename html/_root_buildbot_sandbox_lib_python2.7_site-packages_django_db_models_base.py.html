source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/base.py</b><br>


file stats: <b>1031 lines, 303 executed: 29.4% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import copy</font>
<font color="green">   4. import inspect</font>
<font color="green">   5. import warnings</font>
<font color="green">   6. from itertools import chain</font>
<font color="black">   7. </font>
<font color="green">   8. from django.apps import apps</font>
<font color="green">   9. from django.conf import settings</font>
<font color="green">  10. from django.core import checks</font>
<font color="green">  11. from django.core.exceptions import (</font>
<font color="black">  12.     NON_FIELD_ERRORS, FieldDoesNotExist, FieldError, MultipleObjectsReturned,</font>
<font color="black">  13.     ObjectDoesNotExist, ValidationError,</font>
<font color="black">  14. )</font>
<font color="green">  15. from django.db import (</font>
<font color="black">  16.     DEFAULT_DB_ALIAS, DJANGO_VERSION_PICKLE_KEY, DatabaseError, connections,</font>
<font color="black">  17.     router, transaction,</font>
<font color="black">  18. )</font>
<font color="green">  19. from django.db.models import signals</font>
<font color="green">  20. from django.db.models.constants import LOOKUP_SEP</font>
<font color="green">  21. from django.db.models.deletion import CASCADE, Collector</font>
<font color="green">  22. from django.db.models.fields import AutoField</font>
<font color="green">  23. from django.db.models.fields.related import (</font>
<font color="black">  24.     ForeignObjectRel, ManyToOneRel, OneToOneField, lazy_related_operation,</font>
<font color="black">  25.     resolve_relation,</font>
<font color="black">  26. )</font>
<font color="green">  27. from django.db.models.manager import ensure_default_manager</font>
<font color="green">  28. from django.db.models.options import Options</font>
<font color="green">  29. from django.db.models.query import Q</font>
<font color="green">  30. from django.db.models.query_utils import (</font>
<font color="black">  31.     DeferredAttribute, deferred_class_factory,</font>
<font color="black">  32. )</font>
<font color="green">  33. from django.db.models.utils import make_model_tuple</font>
<font color="green">  34. from django.utils import six</font>
<font color="green">  35. from django.utils.encoding import force_str, force_text</font>
<font color="green">  36. from django.utils.functional import curry</font>
<font color="green">  37. from django.utils.six.moves import zip</font>
<font color="green">  38. from django.utils.text import capfirst, get_text_list</font>
<font color="green">  39. from django.utils.translation import ugettext_lazy as _</font>
<font color="green">  40. from django.utils.version import get_version</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. def subclass_exception(name, parents, module, attached_to=None):</font>
<font color="black">  44.     &quot;&quot;&quot;</font>
<font color="black">  45.     Create exception subclass. Used by ModelBase below.</font>
<font color="black">  46. </font>
<font color="black">  47.     If 'attached_to' is supplied, the exception will be created in a way that</font>
<font color="black">  48.     allows it to be pickled, assuming the returned exception class will be added</font>
<font color="black">  49.     as an attribute to the 'attached_to' class.</font>
<font color="black">  50.     &quot;&quot;&quot;</font>
<font color="green">  51.     class_dict = {'__module__': module}</font>
<font color="green">  52.     if attached_to is not None:</font>
<font color="green">  53.         def __reduce__(self):</font>
<font color="black">  54.             # Exceptions are special - they've got state that isn't</font>
<font color="black">  55.             # in self.__dict__. We assume it is all in self.args.</font>
<font color="red">  56.             return (unpickle_inner_exception, (attached_to, name), self.args)</font>
<font color="black">  57. </font>
<font color="green">  58.         def __setstate__(self, args):</font>
<font color="red">  59.             self.args = args</font>
<font color="black">  60. </font>
<font color="green">  61.         class_dict['__reduce__'] = __reduce__</font>
<font color="green">  62.         class_dict['__setstate__'] = __setstate__</font>
<font color="black">  63. </font>
<font color="green">  64.     return type(name, parents, class_dict)</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="green">  67. class ModelBase(type):</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="black">  69.     Metaclass for all models.</font>
<font color="green">  70.     &quot;&quot;&quot;</font>
<font color="green">  71.     def __new__(cls, name, bases, attrs):</font>
<font color="green">  72.         super_new = super(ModelBase, cls).__new__</font>
<font color="black">  73. </font>
<font color="black">  74.         # Also ensure initialization is only performed for subclasses of Model</font>
<font color="black">  75.         # (excluding Model class itself).</font>
<font color="green">  76.         parents = [b for b in bases if isinstance(b, ModelBase)]</font>
<font color="green">  77.         if not parents:</font>
<font color="green">  78.             return super_new(cls, name, bases, attrs)</font>
<font color="black">  79. </font>
<font color="black">  80.         # Create the class.</font>
<font color="green">  81.         module = attrs.pop('__module__')</font>
<font color="green">  82.         new_class = super_new(cls, name, bases, {'__module__': module})</font>
<font color="green">  83.         attr_meta = attrs.pop('Meta', None)</font>
<font color="green">  84.         abstract = getattr(attr_meta, 'abstract', False)</font>
<font color="green">  85.         if not attr_meta:</font>
<font color="red">  86.             meta = getattr(new_class, 'Meta', None)</font>
<font color="black">  87.         else:</font>
<font color="green">  88.             meta = attr_meta</font>
<font color="green">  89.         base_meta = getattr(new_class, '_meta', None)</font>
<font color="black">  90. </font>
<font color="green">  91.         app_label = None</font>
<font color="black">  92. </font>
<font color="black">  93.         # Look for an application configuration to attach the model to.</font>
<font color="green">  94.         app_config = apps.get_containing_app_config(module)</font>
<font color="black">  95. </font>
<font color="green">  96.         if getattr(meta, 'app_label', None) is None:</font>
<font color="green">  97.             if app_config is None:</font>
<font color="red">  98.                 if not abstract:</font>
<font color="red">  99.                     raise RuntimeError(</font>
<font color="red"> 100.                         &quot;Model class %s.%s doesn't declare an explicit &quot;</font>
<font color="black"> 101.                         &quot;app_label and either isn't in an application in &quot;</font>
<font color="black"> 102.                         &quot;INSTALLED_APPS or else was imported before its &quot;</font>
<font color="red"> 103.                         &quot;application was loaded. &quot; % (module, name))</font>
<font color="black"> 104. </font>
<font color="black"> 105.             else:</font>
<font color="green"> 106.                 app_label = app_config.label</font>
<font color="black"> 107. </font>
<font color="green"> 108.         new_class.add_to_class('_meta', Options(meta, app_label))</font>
<font color="green"> 109.         if not abstract:</font>
<font color="green"> 110.             new_class.add_to_class(</font>
<font color="green"> 111.                 'DoesNotExist',</font>
<font color="green"> 112.                 subclass_exception(</font>
<font color="green"> 113.                     str('DoesNotExist'),</font>
<font color="green"> 114.                     tuple(</font>
<font color="green"> 115.                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract</font>
<font color="green"> 116.                     ) or (ObjectDoesNotExist,),</font>
<font color="green"> 117.                     module,</font>
<font color="green"> 118.                     attached_to=new_class))</font>
<font color="green"> 119.             new_class.add_to_class(</font>
<font color="green"> 120.                 'MultipleObjectsReturned',</font>
<font color="green"> 121.                 subclass_exception(</font>
<font color="green"> 122.                     str('MultipleObjectsReturned'),</font>
<font color="green"> 123.                     tuple(</font>
<font color="green"> 124.                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract</font>
<font color="green"> 125.                     ) or (MultipleObjectsReturned,),</font>
<font color="green"> 126.                     module,</font>
<font color="green"> 127.                     attached_to=new_class))</font>
<font color="green"> 128.             if base_meta and not base_meta.abstract:</font>
<font color="black"> 129.                 # Non-abstract child classes inherit some attributes from their</font>
<font color="black"> 130.                 # non-abstract parent (unless an ABC comes before it in the</font>
<font color="black"> 131.                 # method resolution order).</font>
<font color="red"> 132.                 if not hasattr(meta, 'ordering'):</font>
<font color="red"> 133.                     new_class._meta.ordering = base_meta.ordering</font>
<font color="red"> 134.                 if not hasattr(meta, 'get_latest_by'):</font>
<font color="red"> 135.                     new_class._meta.get_latest_by = base_meta.get_latest_by</font>
<font color="black"> 136. </font>
<font color="green"> 137.         is_proxy = new_class._meta.proxy</font>
<font color="black"> 138. </font>
<font color="black"> 139.         # If the model is a proxy, ensure that the base class</font>
<font color="black"> 140.         # hasn't been swapped out.</font>
<font color="green"> 141.         if is_proxy and base_meta and base_meta.swapped:</font>
<font color="red"> 142.             raise TypeError(&quot;%s cannot proxy the swapped model '%s'.&quot; % (name, base_meta.swapped))</font>
<font color="black"> 143. </font>
<font color="green"> 144.         if getattr(new_class, '_default_manager', None):</font>
<font color="green"> 145.             if not is_proxy:</font>
<font color="black"> 146.                 # Multi-table inheritance doesn't inherit default manager from</font>
<font color="black"> 147.                 # parents.</font>
<font color="green"> 148.                 new_class._default_manager = None</font>
<font color="green"> 149.                 new_class._base_manager = None</font>
<font color="black"> 150.             else:</font>
<font color="black"> 151.                 # Proxy classes do inherit parent's default manager, if none is</font>
<font color="black"> 152.                 # set explicitly.</font>
<font color="red"> 153.                 new_class._default_manager = new_class._default_manager._copy_to_model(new_class)</font>
<font color="red"> 154.                 new_class._base_manager = new_class._base_manager._copy_to_model(new_class)</font>
<font color="black"> 155. </font>
<font color="black"> 156.         # Add all attributes to the class.</font>
<font color="green"> 157.         for obj_name, obj in attrs.items():</font>
<font color="green"> 158.             new_class.add_to_class(obj_name, obj)</font>
<font color="black"> 159. </font>
<font color="black"> 160.         # All the fields of any type declared on this model</font>
<font color="green"> 161.         new_fields = chain(</font>
<font color="green"> 162.             new_class._meta.local_fields,</font>
<font color="green"> 163.             new_class._meta.local_many_to_many,</font>
<font color="green"> 164.             new_class._meta.virtual_fields</font>
<font color="black"> 165.         )</font>
<font color="green"> 166.         field_names = {f.name for f in new_fields}</font>
<font color="black"> 167. </font>
<font color="black"> 168.         # Basic setup for proxy models.</font>
<font color="green"> 169.         if is_proxy:</font>
<font color="red"> 170.             base = None</font>
<font color="red"> 171.             for parent in [kls for kls in parents if hasattr(kls, '_meta')]:</font>
<font color="red"> 172.                 if parent._meta.abstract:</font>
<font color="red"> 173.                     if parent._meta.fields:</font>
<font color="red"> 174.                         raise TypeError(</font>
<font color="red"> 175.                             &quot;Abstract base class containing model fields not &quot;</font>
<font color="red"> 176.                             &quot;permitted for proxy model '%s'.&quot; % name</font>
<font color="black"> 177.                         )</font>
<font color="black"> 178.                     else:</font>
<font color="red"> 179.                         continue</font>
<font color="red"> 180.                 if base is not None:</font>
<font color="red"> 181.                     raise TypeError(&quot;Proxy model '%s' has more than one non-abstract model base class.&quot; % name)</font>
<font color="black"> 182.                 else:</font>
<font color="red"> 183.                     base = parent</font>
<font color="red"> 184.             if base is None:</font>
<font color="red"> 185.                 raise TypeError(&quot;Proxy model '%s' has no non-abstract model base class.&quot; % name)</font>
<font color="red"> 186.             new_class._meta.setup_proxy(base)</font>
<font color="red"> 187.             new_class._meta.concrete_model = base._meta.concrete_model</font>
<font color="red"> 188.             base._meta.concrete_model._meta.proxied_children.append(new_class._meta)</font>
<font color="black"> 189.         else:</font>
<font color="green"> 190.             new_class._meta.concrete_model = new_class</font>
<font color="black"> 191. </font>
<font color="black"> 192.         # Collect the parent links for multi-table inheritance.</font>
<font color="green"> 193.         parent_links = {}</font>
<font color="green"> 194.         for base in reversed([new_class] + parents):</font>
<font color="black"> 195.             # Conceptually equivalent to `if base is Model`.</font>
<font color="green"> 196.             if not hasattr(base, '_meta'):</font>
<font color="green"> 197.                 continue</font>
<font color="black"> 198.             # Skip concrete parent classes.</font>
<font color="green"> 199.             if base != new_class and not base._meta.abstract:</font>
<font color="red"> 200.                 continue</font>
<font color="black"> 201.             # Locate OneToOneField instances.</font>
<font color="green"> 202.             for field in base._meta.local_fields:</font>
<font color="green"> 203.                 if isinstance(field, OneToOneField):</font>
<font color="red"> 204.                     related = resolve_relation(new_class, field.remote_field.model)</font>
<font color="red"> 205.                     parent_links[make_model_tuple(related)] = field</font>
<font color="black"> 206.         # Do the appropriate setup for any model parents.</font>
<font color="green"> 207.         for base in parents:</font>
<font color="green"> 208.             original_base = base</font>
<font color="green"> 209.             if not hasattr(base, '_meta'):</font>
<font color="black"> 210.                 # Things without _meta aren't functional models, so they're</font>
<font color="black"> 211.                 # uninteresting parents.</font>
<font color="green"> 212.                 continue</font>
<font color="black"> 213. </font>
<font color="green"> 214.             parent_fields = base._meta.local_fields + base._meta.local_many_to_many</font>
<font color="black"> 215.             # Check for clashes between locally declared fields and those</font>
<font color="black"> 216.             # on the base classes (we cannot handle shadowed fields at the</font>
<font color="black"> 217.             # moment).</font>
<font color="green"> 218.             for field in parent_fields:</font>
<font color="green"> 219.                 if field.name in field_names:</font>
<font color="red"> 220.                     raise FieldError(</font>
<font color="red"> 221.                         'Local field %r in class %r clashes '</font>
<font color="black"> 222.                         'with field of similar name from '</font>
<font color="red"> 223.                         'base class %r' % (field.name, name, base.__name__)</font>
<font color="black"> 224.                     )</font>
<font color="green"> 225.             if not base._meta.abstract:</font>
<font color="black"> 226.                 # Concrete classes...</font>
<font color="red"> 227.                 base = base._meta.concrete_model</font>
<font color="red"> 228.                 base_key = make_model_tuple(base)</font>
<font color="red"> 229.                 if base_key in parent_links:</font>
<font color="red"> 230.                     field = parent_links[base_key]</font>
<font color="red"> 231.                 elif not is_proxy:</font>
<font color="red"> 232.                     attr_name = '%s_ptr' % base._meta.model_name</font>
<font color="red"> 233.                     field = OneToOneField(</font>
<font color="red"> 234.                         base,</font>
<font color="red"> 235.                         on_delete=CASCADE,</font>
<font color="red"> 236.                         name=attr_name,</font>
<font color="red"> 237.                         auto_created=True,</font>
<font color="red"> 238.                         parent_link=True,</font>
<font color="black"> 239.                     )</font>
<font color="black"> 240.                     # Only add the ptr field if it's not already present;</font>
<font color="black"> 241.                     # e.g. migrations will already have it specified</font>
<font color="red"> 242.                     if not hasattr(new_class, attr_name):</font>
<font color="red"> 243.                         new_class.add_to_class(attr_name, field)</font>
<font color="black"> 244.                 else:</font>
<font color="red"> 245.                     field = None</font>
<font color="red"> 246.                 new_class._meta.parents[base] = field</font>
<font color="black"> 247.             else:</font>
<font color="black"> 248.                 # .. and abstract ones.</font>
<font color="green"> 249.                 for field in parent_fields:</font>
<font color="green"> 250.                     new_field = copy.deepcopy(field)</font>
<font color="green"> 251.                     new_class.add_to_class(field.name, new_field)</font>
<font color="black"> 252. </font>
<font color="black"> 253.                 # Pass any non-abstract parent classes onto child.</font>
<font color="green"> 254.                 new_class._meta.parents.update(base._meta.parents)</font>
<font color="black"> 255. </font>
<font color="black"> 256.             # Inherit managers from the abstract base classes.</font>
<font color="green"> 257.             new_class.copy_managers(base._meta.abstract_managers)</font>
<font color="black"> 258. </font>
<font color="black"> 259.             # Proxy models inherit the non-abstract managers from their base,</font>
<font color="black"> 260.             # unless they have redefined any of them.</font>
<font color="green"> 261.             if is_proxy:</font>
<font color="red"> 262.                 new_class.copy_managers(original_base._meta.concrete_managers)</font>
<font color="black"> 263. </font>
<font color="black"> 264.             # Inherit virtual fields (like GenericForeignKey) from the parent</font>
<font color="black"> 265.             # class</font>
<font color="green"> 266.             for field in base._meta.virtual_fields:</font>
<font color="red"> 267.                 if base._meta.abstract and field.name in field_names:</font>
<font color="red"> 268.                     raise FieldError(</font>
<font color="red"> 269.                         'Local field %r in class %r clashes '</font>
<font color="black"> 270.                         'with field of similar name from '</font>
<font color="red"> 271.                         'abstract base class %r' % (field.name, name, base.__name__)</font>
<font color="black"> 272.                     )</font>
<font color="red"> 273.                 new_class.add_to_class(field.name, copy.deepcopy(field))</font>
<font color="black"> 274. </font>
<font color="green"> 275.         if abstract:</font>
<font color="black"> 276.             # Abstract base models can't be instantiated and don't appear in</font>
<font color="black"> 277.             # the list of models for an app. We do the final setup for them a</font>
<font color="black"> 278.             # little differently from normal models.</font>
<font color="green"> 279.             attr_meta.abstract = False</font>
<font color="green"> 280.             new_class.Meta = attr_meta</font>
<font color="green"> 281.             return new_class</font>
<font color="black"> 282. </font>
<font color="green"> 283.         new_class._prepare()</font>
<font color="green"> 284.         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)</font>
<font color="green"> 285.         return new_class</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def copy_managers(cls, base_managers):</font>
<font color="black"> 288.         # This is in-place sorting of an Options attribute, but that's fine.</font>
<font color="green"> 289.         base_managers.sort()</font>
<font color="green"> 290.         for _, mgr_name, manager in base_managers:  # NOQA (redefinition of _)</font>
<font color="green"> 291.             val = getattr(cls, mgr_name, None)</font>
<font color="green"> 292.             if not val or val is manager:</font>
<font color="green"> 293.                 new_manager = manager._copy_to_model(cls)</font>
<font color="green"> 294.                 cls.add_to_class(mgr_name, new_manager)</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def add_to_class(cls, name, value):</font>
<font color="black"> 297.         # We should call the contribute_to_class method only if it's bound</font>
<font color="green"> 298.         if not inspect.isclass(value) and hasattr(value, 'contribute_to_class'):</font>
<font color="green"> 299.             value.contribute_to_class(cls, name)</font>
<font color="black"> 300.         else:</font>
<font color="green"> 301.             setattr(cls, name, value)</font>
<font color="black"> 302. </font>
<font color="green"> 303.     def _prepare(cls):</font>
<font color="black"> 304.         &quot;&quot;&quot;</font>
<font color="black"> 305.         Creates some methods once self._meta has been populated.</font>
<font color="black"> 306.         &quot;&quot;&quot;</font>
<font color="green"> 307.         opts = cls._meta</font>
<font color="green"> 308.         opts._prepare(cls)</font>
<font color="black"> 309. </font>
<font color="green"> 310.         if opts.order_with_respect_to:</font>
<font color="red"> 311.             cls.get_next_in_order = curry(cls._get_next_or_previous_in_order, is_next=True)</font>
<font color="red"> 312.             cls.get_previous_in_order = curry(cls._get_next_or_previous_in_order, is_next=False)</font>
<font color="black"> 313. </font>
<font color="black"> 314.             # Defer creating accessors on the foreign class until it has been</font>
<font color="black"> 315.             # created and registered. If remote_field is None, we're ordering</font>
<font color="black"> 316.             # with respect to a GenericForeignKey and don't know what the</font>
<font color="black"> 317.             # foreign class is - we'll add those accessors later in</font>
<font color="black"> 318.             # contribute_to_class().</font>
<font color="red"> 319.             if opts.order_with_respect_to.remote_field:</font>
<font color="red"> 320.                 wrt = opts.order_with_respect_to</font>
<font color="red"> 321.                 remote = wrt.remote_field.model</font>
<font color="red"> 322.                 lazy_related_operation(make_foreign_order_accessors, cls, remote)</font>
<font color="black"> 323. </font>
<font color="black"> 324.         # Give the class a docstring -- its definition.</font>
<font color="green"> 325.         if cls.__doc__ is None:</font>
<font color="green"> 326.             cls.__doc__ = &quot;%s(%s)&quot; % (cls.__name__, &quot;, &quot;.join(f.name for f in opts.fields))</font>
<font color="black"> 327. </font>
<font color="green"> 328.         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)</font>
<font color="green"> 329.         if get_absolute_url_override:</font>
<font color="red"> 330.             setattr(cls, 'get_absolute_url', get_absolute_url_override)</font>
<font color="black"> 331. </font>
<font color="green"> 332.         ensure_default_manager(cls)</font>
<font color="green"> 333.         signals.class_prepared.send(sender=cls)</font>
<font color="black"> 334. </font>
<font color="black"> 335. </font>
<font color="green"> 336. class ModelState(object):</font>
<font color="black"> 337.     &quot;&quot;&quot;</font>
<font color="black"> 338.     A class for storing instance state</font>
<font color="green"> 339.     &quot;&quot;&quot;</font>
<font color="green"> 340.     def __init__(self, db=None):</font>
<font color="green"> 341.         self.db = db</font>
<font color="black"> 342.         # If true, uniqueness validation checks will consider this a new, as-yet-unsaved object.</font>
<font color="black"> 343.         # Necessary for correct validation of new instances of objects with explicit (non-auto) PKs.</font>
<font color="black"> 344.         # This impacts validation only; it has no effect on the actual save.</font>
<font color="green"> 345.         self.adding = True</font>
<font color="black"> 346. </font>
<font color="black"> 347. </font>
<font color="green"> 348. class Model(six.with_metaclass(ModelBase)):</font>
<font color="green"> 349.     _deferred = False</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def __init__(self, *args, **kwargs):</font>
<font color="green"> 352.         signals.pre_init.send(sender=self.__class__, args=args, kwargs=kwargs)</font>
<font color="black"> 353. </font>
<font color="black"> 354.         # Set up the storage for instance state</font>
<font color="green"> 355.         self._state = ModelState()</font>
<font color="black"> 356. </font>
<font color="black"> 357.         # There is a rather weird disparity here; if kwargs, it's set, then args</font>
<font color="black"> 358.         # overrides it. It should be one or the other; don't duplicate the work</font>
<font color="black"> 359.         # The reason for the kwargs check is that standard iterator passes in by</font>
<font color="black"> 360.         # args, and instantiation for iteration is 33% faster.</font>
<font color="green"> 361.         args_len = len(args)</font>
<font color="green"> 362.         if args_len &gt; len(self._meta.concrete_fields):</font>
<font color="black"> 363.             # Daft, but matches old exception sans the err msg.</font>
<font color="red"> 364.             raise IndexError(&quot;Number of args exceeds number of fields&quot;)</font>
<font color="black"> 365. </font>
<font color="green"> 366.         if not kwargs:</font>
<font color="green"> 367.             fields_iter = iter(self._meta.concrete_fields)</font>
<font color="black"> 368.             # The ordering of the zip calls matter - zip throws StopIteration</font>
<font color="black"> 369.             # when an iter throws it. So if the first iter throws it, the second</font>
<font color="black"> 370.             # is *not* consumed. We rely on this, so don't change the order</font>
<font color="black"> 371.             # without changing the logic.</font>
<font color="green"> 372.             for val, field in zip(args, fields_iter):</font>
<font color="green"> 373.                 setattr(self, field.attname, val)</font>
<font color="black"> 374.         else:</font>
<font color="black"> 375.             # Slower, kwargs-ready version.</font>
<font color="green"> 376.             fields_iter = iter(self._meta.fields)</font>
<font color="green"> 377.             for val, field in zip(args, fields_iter):</font>
<font color="red"> 378.                 setattr(self, field.attname, val)</font>
<font color="red"> 379.                 kwargs.pop(field.name, None)</font>
<font color="black"> 380.                 # Maintain compatibility with existing calls.</font>
<font color="red"> 381.                 if isinstance(field.remote_field, ManyToOneRel):</font>
<font color="red"> 382.                     kwargs.pop(field.attname, None)</font>
<font color="black"> 383. </font>
<font color="black"> 384.         # Now we're left with the unprocessed fields that *must* come from</font>
<font color="black"> 385.         # keywords, or default.</font>
<font color="black"> 386. </font>
<font color="green"> 387.         for field in fields_iter:</font>
<font color="green"> 388.             is_related_object = False</font>
<font color="black"> 389.             # This slightly odd construct is so that we can access any</font>
<font color="black"> 390.             # data-descriptor object (DeferredAttribute) without triggering its</font>
<font color="black"> 391.             # __get__ method.</font>
<font color="green"> 392.             if (field.attname not in kwargs and</font>
<font color="green"> 393.                     (isinstance(self.__class__.__dict__.get(field.attname), DeferredAttribute)</font>
<font color="green"> 394.                      or field.column is None)):</font>
<font color="black"> 395.                 # This field will be populated on request.</font>
<font color="red"> 396.                 continue</font>
<font color="green"> 397.             if kwargs:</font>
<font color="green"> 398.                 if isinstance(field.remote_field, ForeignObjectRel):</font>
<font color="green"> 399.                     try:</font>
<font color="black"> 400.                         # Assume object instance was passed in.</font>
<font color="green"> 401.                         rel_obj = kwargs.pop(field.name)</font>
<font color="green"> 402.                         is_related_object = True</font>
<font color="red"> 403.                     except KeyError:</font>
<font color="red"> 404.                         try:</font>
<font color="black"> 405.                             # Object instance wasn't passed in -- must be an ID.</font>
<font color="red"> 406.                             val = kwargs.pop(field.attname)</font>
<font color="red"> 407.                         except KeyError:</font>
<font color="red"> 408.                             val = field.get_default()</font>
<font color="black"> 409.                     else:</font>
<font color="black"> 410.                         # Object instance was passed in. Special case: You can</font>
<font color="black"> 411.                         # pass in &quot;None&quot; for related objects if it's allowed.</font>
<font color="green"> 412.                         if rel_obj is None and field.null:</font>
<font color="red"> 413.                             val = None</font>
<font color="black"> 414.                 else:</font>
<font color="green"> 415.                     try:</font>
<font color="green"> 416.                         val = kwargs.pop(field.attname)</font>
<font color="green"> 417.                     except KeyError:</font>
<font color="black"> 418.                         # This is done with an exception rather than the</font>
<font color="black"> 419.                         # default argument on pop because we don't want</font>
<font color="black"> 420.                         # get_default() to be evaluated, and then not used.</font>
<font color="black"> 421.                         # Refs #12057.</font>
<font color="green"> 422.                         val = field.get_default()</font>
<font color="black"> 423.             else:</font>
<font color="green"> 424.                 val = field.get_default()</font>
<font color="black"> 425. </font>
<font color="green"> 426.             if is_related_object:</font>
<font color="black"> 427.                 # If we are passed a related instance, set it using the</font>
<font color="black"> 428.                 # field.name instead of field.attname (e.g. &quot;user&quot; instead of</font>
<font color="black"> 429.                 # &quot;user_id&quot;) so that the object gets properly cached (and type</font>
<font color="black"> 430.                 # checked) by the RelatedObjectDescriptor.</font>
<font color="green"> 431.                 setattr(self, field.name, rel_obj)</font>
<font color="black"> 432.             else:</font>
<font color="green"> 433.                 setattr(self, field.attname, val)</font>
<font color="black"> 434. </font>
<font color="green"> 435.         if kwargs:</font>
<font color="red"> 436.             for prop in list(kwargs):</font>
<font color="red"> 437.                 try:</font>
<font color="red"> 438.                     if isinstance(getattr(self.__class__, prop), property):</font>
<font color="red"> 439.                         setattr(self, prop, kwargs.pop(prop))</font>
<font color="red"> 440.                 except AttributeError:</font>
<font color="red"> 441.                     pass</font>
<font color="red"> 442.             if kwargs:</font>
<font color="red"> 443.                 raise TypeError(&quot;'%s' is an invalid keyword argument for this function&quot; % list(kwargs)[0])</font>
<font color="green"> 444.         super(Model, self).__init__()</font>
<font color="green"> 445.         signals.post_init.send(sender=self.__class__, instance=self)</font>
<font color="black"> 446. </font>
<font color="green"> 447.     @classmethod</font>
<font color="black"> 448.     def from_db(cls, db, field_names, values):</font>
<font color="green"> 449.         if cls._deferred:</font>
<font color="red"> 450.             new = cls(**dict(zip(field_names, values)))</font>
<font color="black"> 451.         else:</font>
<font color="green"> 452.             new = cls(*values)</font>
<font color="green"> 453.         new._state.adding = False</font>
<font color="green"> 454.         new._state.db = db</font>
<font color="green"> 455.         return new</font>
<font color="black"> 456. </font>
<font color="green"> 457.     def __repr__(self):</font>
<font color="red"> 458.         try:</font>
<font color="red"> 459.             u = six.text_type(self)</font>
<font color="red"> 460.         except (UnicodeEncodeError, UnicodeDecodeError):</font>
<font color="red"> 461.             u = '[Bad Unicode data]'</font>
<font color="red"> 462.         return force_str('&lt;%s: %s&gt;' % (self.__class__.__name__, u))</font>
<font color="black"> 463. </font>
<font color="green"> 464.     def __str__(self):</font>
<font color="red"> 465.         if six.PY2 and hasattr(self, '__unicode__'):</font>
<font color="red"> 466.             return force_text(self).encode('utf-8')</font>
<font color="red"> 467.         return str('%s object' % self.__class__.__name__)</font>
<font color="black"> 468. </font>
<font color="green"> 469.     def __eq__(self, other):</font>
<font color="red"> 470.         if not isinstance(other, Model):</font>
<font color="red"> 471.             return False</font>
<font color="red"> 472.         if self._meta.concrete_model != other._meta.concrete_model:</font>
<font color="red"> 473.             return False</font>
<font color="red"> 474.         my_pk = self._get_pk_val()</font>
<font color="red"> 475.         if my_pk is None:</font>
<font color="red"> 476.             return self is other</font>
<font color="red"> 477.         return my_pk == other._get_pk_val()</font>
<font color="black"> 478. </font>
<font color="green"> 479.     def __ne__(self, other):</font>
<font color="red"> 480.         return not self.__eq__(other)</font>
<font color="black"> 481. </font>
<font color="green"> 482.     def __hash__(self):</font>
<font color="green"> 483.         if self._get_pk_val() is None:</font>
<font color="red"> 484.             raise TypeError(&quot;Model instances without primary key value are unhashable&quot;)</font>
<font color="green"> 485.         return hash(self._get_pk_val())</font>
<font color="black"> 486. </font>
<font color="green"> 487.     def __reduce__(self):</font>
<font color="black"> 488.         &quot;&quot;&quot;</font>
<font color="black"> 489.         Provides pickling support. Normally, this just dispatches to Python's</font>
<font color="black"> 490.         standard handling. However, for models with deferred field loading, we</font>
<font color="black"> 491.         need to do things manually, as they're dynamically created classes and</font>
<font color="black"> 492.         only module-level classes can be pickled by the default path.</font>
<font color="black"> 493.         &quot;&quot;&quot;</font>
<font color="red"> 494.         data = self.__dict__</font>
<font color="red"> 495.         data[DJANGO_VERSION_PICKLE_KEY] = get_version()</font>
<font color="red"> 496.         if not self._deferred:</font>
<font color="red"> 497.             class_id = self._meta.app_label, self._meta.object_name</font>
<font color="red"> 498.             return model_unpickle, (class_id, [], simple_class_factory), data</font>
<font color="red"> 499.         defers = []</font>
<font color="red"> 500.         for field in self._meta.fields:</font>
<font color="red"> 501.             if isinstance(self.__class__.__dict__.get(field.attname),</font>
<font color="red"> 502.                           DeferredAttribute):</font>
<font color="red"> 503.                 defers.append(field.attname)</font>
<font color="red"> 504.         model = self._meta.proxy_for_model</font>
<font color="red"> 505.         class_id = model._meta.app_label, model._meta.object_name</font>
<font color="red"> 506.         return (model_unpickle, (class_id, defers, deferred_class_factory), data)</font>
<font color="black"> 507. </font>
<font color="green"> 508.     def __setstate__(self, state):</font>
<font color="red"> 509.         msg = None</font>
<font color="red"> 510.         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)</font>
<font color="red"> 511.         if pickled_version:</font>
<font color="red"> 512.             current_version = get_version()</font>
<font color="red"> 513.             if current_version != pickled_version:</font>
<font color="red"> 514.                 msg = (&quot;Pickled model instance's Django version %s does&quot;</font>
<font color="black"> 515.                     &quot; not match the current version %s.&quot;</font>
<font color="red"> 516.                     % (pickled_version, current_version))</font>
<font color="black"> 517.         else:</font>
<font color="red"> 518.             msg = &quot;Pickled model instance's Django version is not specified.&quot;</font>
<font color="black"> 519. </font>
<font color="red"> 520.         if msg:</font>
<font color="red"> 521.             warnings.warn(msg, RuntimeWarning, stacklevel=2)</font>
<font color="black"> 522. </font>
<font color="red"> 523.         self.__dict__.update(state)</font>
<font color="black"> 524. </font>
<font color="green"> 525.     def _get_pk_val(self, meta=None):</font>
<font color="green"> 526.         if not meta:</font>
<font color="green"> 527.             meta = self._meta</font>
<font color="green"> 528.         return getattr(self, meta.pk.attname)</font>
<font color="black"> 529. </font>
<font color="green"> 530.     def _set_pk_val(self, value):</font>
<font color="green"> 531.         return setattr(self, self._meta.pk.attname, value)</font>
<font color="black"> 532. </font>
<font color="green"> 533.     pk = property(_get_pk_val, _set_pk_val)</font>
<font color="black"> 534. </font>
<font color="green"> 535.     def get_deferred_fields(self):</font>
<font color="black"> 536.         &quot;&quot;&quot;</font>
<font color="black"> 537.         Returns a set containing names of deferred fields for this instance.</font>
<font color="black"> 538.         &quot;&quot;&quot;</font>
<font color="black"> 539.         return {</font>
<font color="red"> 540.             f.attname for f in self._meta.concrete_fields</font>
<font color="red"> 541.             if isinstance(self.__class__.__dict__.get(f.attname), DeferredAttribute)</font>
<font color="black"> 542.         }</font>
<font color="black"> 543. </font>
<font color="green"> 544.     def refresh_from_db(self, using=None, fields=None, **kwargs):</font>
<font color="black"> 545.         &quot;&quot;&quot;</font>
<font color="black"> 546.         Reloads field values from the database.</font>
<font color="black"> 547. </font>
<font color="black"> 548.         By default, the reloading happens from the database this instance was</font>
<font color="black"> 549.         loaded from, or by the read router if this instance wasn't loaded from</font>
<font color="black"> 550.         any database. The using parameter will override the default.</font>
<font color="black"> 551. </font>
<font color="black"> 552.         Fields can be used to specify which fields to reload. The fields</font>
<font color="black"> 553.         should be an iterable of field attnames. If fields is None, then</font>
<font color="black"> 554.         all non-deferred fields are reloaded.</font>
<font color="black"> 555. </font>
<font color="black"> 556.         When accessing deferred fields of an instance, the deferred loading</font>
<font color="black"> 557.         of the field will call this method.</font>
<font color="black"> 558.         &quot;&quot;&quot;</font>
<font color="red"> 559.         if fields is not None:</font>
<font color="red"> 560.             if len(fields) == 0:</font>
<font color="red"> 561.                 return</font>
<font color="red"> 562.             if any(LOOKUP_SEP in f for f in fields):</font>
<font color="red"> 563.                 raise ValueError(</font>
<font color="red"> 564.                     'Found &quot;%s&quot; in fields argument. Relations and transforms '</font>
<font color="red"> 565.                     'are not allowed in fields.' % LOOKUP_SEP)</font>
<font color="black"> 566. </font>
<font color="red"> 567.         db = using if using is not None else self._state.db</font>
<font color="red"> 568.         if self._deferred:</font>
<font color="red"> 569.             non_deferred_model = self._meta.proxy_for_model</font>
<font color="black"> 570.         else:</font>
<font color="red"> 571.             non_deferred_model = self.__class__</font>
<font color="red"> 572.         db_instance_qs = non_deferred_model._default_manager.using(db).filter(pk=self.pk)</font>
<font color="black"> 573. </font>
<font color="black"> 574.         # Use provided fields, if not set then reload all non-deferred fields.</font>
<font color="red"> 575.         if fields is not None:</font>
<font color="red"> 576.             fields = list(fields)</font>
<font color="red"> 577.             db_instance_qs = db_instance_qs.only(*fields)</font>
<font color="red"> 578.         elif self._deferred:</font>
<font color="red"> 579.             deferred_fields = self.get_deferred_fields()</font>
<font color="red"> 580.             fields = [f.attname for f in self._meta.concrete_fields</font>
<font color="red"> 581.                       if f.attname not in deferred_fields]</font>
<font color="red"> 582.             db_instance_qs = db_instance_qs.only(*fields)</font>
<font color="black"> 583. </font>
<font color="red"> 584.         db_instance = db_instance_qs.get()</font>
<font color="red"> 585.         non_loaded_fields = db_instance.get_deferred_fields()</font>
<font color="red"> 586.         for field in self._meta.concrete_fields:</font>
<font color="red"> 587.             if field.attname in non_loaded_fields:</font>
<font color="black"> 588.                 # This field wasn't refreshed - skip ahead.</font>
<font color="red"> 589.                 continue</font>
<font color="red"> 590.             setattr(self, field.attname, getattr(db_instance, field.attname))</font>
<font color="black"> 591.             # Throw away stale foreign key references.</font>
<font color="red"> 592.             if field.is_relation and field.get_cache_name() in self.__dict__:</font>
<font color="red"> 593.                 rel_instance = getattr(self, field.get_cache_name())</font>
<font color="red"> 594.                 local_val = getattr(db_instance, field.attname)</font>
<font color="red"> 595.                 related_val = None if rel_instance is None else getattr(rel_instance, field.target_field.attname)</font>
<font color="red"> 596.                 if local_val != related_val or (local_val is None and related_val is None):</font>
<font color="red"> 597.                     del self.__dict__[field.get_cache_name()]</font>
<font color="red"> 598.         self._state.db = db_instance._state.db</font>
<font color="black"> 599. </font>
<font color="green"> 600.     def serializable_value(self, field_name):</font>
<font color="black"> 601.         &quot;&quot;&quot;</font>
<font color="black"> 602.         Returns the value of the field name for this instance. If the field is</font>
<font color="black"> 603.         a foreign key, returns the id value, instead of the object. If there's</font>
<font color="black"> 604.         no Field object with this name on the model, the model attribute's</font>
<font color="black"> 605.         value is returned directly.</font>
<font color="black"> 606. </font>
<font color="black"> 607.         Used to serialize a field's value (in the serializer, or form output,</font>
<font color="black"> 608.         for example). Normally, you would just access the attribute directly</font>
<font color="black"> 609.         and not use this method.</font>
<font color="black"> 610.         &quot;&quot;&quot;</font>
<font color="red"> 611.         try:</font>
<font color="red"> 612.             field = self._meta.get_field(field_name)</font>
<font color="red"> 613.         except FieldDoesNotExist:</font>
<font color="red"> 614.             return getattr(self, field_name)</font>
<font color="red"> 615.         return getattr(self, field.attname)</font>
<font color="black"> 616. </font>
<font color="green"> 617.     def save(self, force_insert=False, force_update=False, using=None,</font>
<font color="green"> 618.              update_fields=None):</font>
<font color="black"> 619.         &quot;&quot;&quot;</font>
<font color="black"> 620.         Saves the current instance. Override this in a subclass if you want to</font>
<font color="black"> 621.         control the saving process.</font>
<font color="black"> 622. </font>
<font color="black"> 623.         The 'force_insert' and 'force_update' parameters can be used to insist</font>
<font color="black"> 624.         that the &quot;save&quot; must be an SQL insert or update (or equivalent for</font>
<font color="black"> 625.         non-SQL backends), respectively. Normally, they should not be set.</font>
<font color="black"> 626.         &quot;&quot;&quot;</font>
<font color="black"> 627.         # Ensure that a model instance without a PK hasn't been assigned to</font>
<font color="black"> 628.         # a ForeignKey or OneToOneField on this model. If the field is</font>
<font color="black"> 629.         # nullable, allowing the save() would result in silent data loss.</font>
<font color="green"> 630.         for field in self._meta.concrete_fields:</font>
<font color="green"> 631.             if field.is_relation:</font>
<font color="black"> 632.                 # If the related field isn't cached, then an instance hasn't</font>
<font color="black"> 633.                 # been assigned and there's no need to worry about this check.</font>
<font color="red"> 634.                 try:</font>
<font color="red"> 635.                     getattr(self, field.get_cache_name())</font>
<font color="red"> 636.                 except AttributeError:</font>
<font color="red"> 637.                     continue</font>
<font color="red"> 638.                 obj = getattr(self, field.name, None)</font>
<font color="black"> 639.                 # A pk may have been assigned manually to a model instance not</font>
<font color="black"> 640.                 # saved to the database (or auto-generated in a case like</font>
<font color="black"> 641.                 # UUIDField), but we allow the save to proceed and rely on the</font>
<font color="black"> 642.                 # database to raise an IntegrityError if applicable. If</font>
<font color="black"> 643.                 # constraints aren't supported by the database, there's the</font>
<font color="black"> 644.                 # unavoidable risk of data corruption.</font>
<font color="red"> 645.                 if obj and obj.pk is None:</font>
<font color="black"> 646.                     # Remove the object from a related instance cache.</font>
<font color="red"> 647.                     if not field.remote_field.multiple:</font>
<font color="red"> 648.                         delattr(obj, field.remote_field.get_cache_name())</font>
<font color="red"> 649.                     raise ValueError(</font>
<font color="red"> 650.                         &quot;save() prohibited to prevent data loss due to &quot;</font>
<font color="red"> 651.                         &quot;unsaved related object '%s'.&quot; % field.name</font>
<font color="black"> 652.                     )</font>
<font color="black"> 653. </font>
<font color="green"> 654.         using = using or router.db_for_write(self.__class__, instance=self)</font>
<font color="green"> 655.         if force_insert and (force_update or update_fields):</font>
<font color="red"> 656.             raise ValueError(&quot;Cannot force both insert and updating in model saving.&quot;)</font>
<font color="black"> 657. </font>
<font color="green"> 658.         if update_fields is not None:</font>
<font color="black"> 659.             # If update_fields is empty, skip the save. We do also check for</font>
<font color="black"> 660.             # no-op saves later on for inheritance cases. This bailout is</font>
<font color="black"> 661.             # still needed for skipping signal sending.</font>
<font color="red"> 662.             if len(update_fields) == 0:</font>
<font color="red"> 663.                 return</font>
<font color="black"> 664. </font>
<font color="red"> 665.             update_fields = frozenset(update_fields)</font>
<font color="red"> 666.             field_names = set()</font>
<font color="black"> 667. </font>
<font color="red"> 668.             for field in self._meta.fields:</font>
<font color="red"> 669.                 if not field.primary_key:</font>
<font color="red"> 670.                     field_names.add(field.name)</font>
<font color="black"> 671. </font>
<font color="red"> 672.                     if field.name != field.attname:</font>
<font color="red"> 673.                         field_names.add(field.attname)</font>
<font color="black"> 674. </font>
<font color="red"> 675.             non_model_fields = update_fields.difference(field_names)</font>
<font color="black"> 676. </font>
<font color="red"> 677.             if non_model_fields:</font>
<font color="red"> 678.                 raise ValueError(&quot;The following fields do not exist in this &quot;</font>
<font color="black"> 679.                                  &quot;model or are m2m fields: %s&quot;</font>
<font color="red"> 680.                                  % ', '.join(non_model_fields))</font>
<font color="black"> 681. </font>
<font color="black"> 682.         # If saving to the same database, and this model is deferred, then</font>
<font color="black"> 683.         # automatically do a &quot;update_fields&quot; save on the loaded fields.</font>
<font color="green"> 684.         elif not force_insert and self._deferred and using == self._state.db:</font>
<font color="red"> 685.             field_names = set()</font>
<font color="red"> 686.             for field in self._meta.concrete_fields:</font>
<font color="red"> 687.                 if not field.primary_key and not hasattr(field, 'through'):</font>
<font color="red"> 688.                     field_names.add(field.attname)</font>
<font color="black"> 689.             deferred_fields = [</font>
<font color="red"> 690.                 f.attname for f in self._meta.fields</font>
<font color="red"> 691.                 if (f.attname not in self.__dict__ and</font>
<font color="red"> 692.                     isinstance(self.__class__.__dict__[f.attname], DeferredAttribute))</font>
<font color="black"> 693.             ]</font>
<font color="black"> 694. </font>
<font color="red"> 695.             loaded_fields = field_names.difference(deferred_fields)</font>
<font color="red"> 696.             if loaded_fields:</font>
<font color="red"> 697.                 update_fields = frozenset(loaded_fields)</font>
<font color="black"> 698. </font>
<font color="green"> 699.         self.save_base(using=using, force_insert=force_insert,</font>
<font color="green"> 700.                        force_update=force_update, update_fields=update_fields)</font>
<font color="green"> 701.     save.alters_data = True</font>
<font color="black"> 702. </font>
<font color="green"> 703.     def save_base(self, raw=False, force_insert=False,</font>
<font color="green"> 704.                   force_update=False, using=None, update_fields=None):</font>
<font color="black"> 705.         &quot;&quot;&quot;</font>
<font color="black"> 706.         Handles the parts of saving which should be done only once per save,</font>
<font color="black"> 707.         yet need to be done in raw saves, too. This includes some sanity</font>
<font color="black"> 708.         checks and signal sending.</font>
<font color="black"> 709. </font>
<font color="black"> 710.         The 'raw' argument is telling save_base not to save any parent</font>
<font color="black"> 711.         models and not to do any changes to the values before save. This</font>
<font color="black"> 712.         is used by fixture loading.</font>
<font color="black"> 713.         &quot;&quot;&quot;</font>
<font color="green"> 714.         using = using or router.db_for_write(self.__class__, instance=self)</font>
<font color="green"> 715.         assert not (force_insert and (force_update or update_fields))</font>
<font color="green"> 716.         assert update_fields is None or len(update_fields) &gt; 0</font>
<font color="green"> 717.         cls = origin = self.__class__</font>
<font color="black"> 718.         # Skip proxies, but keep the origin as the proxy model.</font>
<font color="green"> 719.         if cls._meta.proxy:</font>
<font color="red"> 720.             cls = cls._meta.concrete_model</font>
<font color="green"> 721.         meta = cls._meta</font>
<font color="green"> 722.         if not meta.auto_created:</font>
<font color="green"> 723.             signals.pre_save.send(sender=origin, instance=self, raw=raw, using=using,</font>
<font color="green"> 724.                                   update_fields=update_fields)</font>
<font color="green"> 725.         with transaction.atomic(using=using, savepoint=False):</font>
<font color="green"> 726.             if not raw:</font>
<font color="green"> 727.                 self._save_parents(cls, using, update_fields)</font>
<font color="green"> 728.             updated = self._save_table(raw, cls, force_insert, force_update, using, update_fields)</font>
<font color="black"> 729.         # Store the database on which the object was saved</font>
<font color="green"> 730.         self._state.db = using</font>
<font color="black"> 731.         # Once saved, this is no longer a to-be-added instance.</font>
<font color="green"> 732.         self._state.adding = False</font>
<font color="black"> 733. </font>
<font color="black"> 734.         # Signal that the save is complete</font>
<font color="green"> 735.         if not meta.auto_created:</font>
<font color="green"> 736.             signals.post_save.send(sender=origin, instance=self, created=(not updated),</font>
<font color="green"> 737.                                    update_fields=update_fields, raw=raw, using=using)</font>
<font color="black"> 738. </font>
<font color="green"> 739.     save_base.alters_data = True</font>
<font color="black"> 740. </font>
<font color="green"> 741.     def _save_parents(self, cls, using, update_fields):</font>
<font color="black"> 742.         &quot;&quot;&quot;</font>
<font color="black"> 743.         Saves all the parents of cls using values from self.</font>
<font color="black"> 744.         &quot;&quot;&quot;</font>
<font color="green"> 745.         meta = cls._meta</font>
<font color="green"> 746.         for parent, field in meta.parents.items():</font>
<font color="black"> 747.             # Make sure the link fields are synced between parent and self.</font>
<font color="red"> 748.             if (field and getattr(self, parent._meta.pk.attname) is None</font>
<font color="red"> 749.                     and getattr(self, field.attname) is not None):</font>
<font color="red"> 750.                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))</font>
<font color="red"> 751.             self._save_parents(cls=parent, using=using, update_fields=update_fields)</font>
<font color="red"> 752.             self._save_table(cls=parent, using=using, update_fields=update_fields)</font>
<font color="black"> 753.             # Set the parent's PK value to self.</font>
<font color="red"> 754.             if field:</font>
<font color="red"> 755.                 setattr(self, field.attname, self._get_pk_val(parent._meta))</font>
<font color="black"> 756.                 # Since we didn't have an instance of the parent handy set</font>
<font color="black"> 757.                 # attname directly, bypassing the descriptor. Invalidate</font>
<font color="black"> 758.                 # the related object cache, in case it's been accidentally</font>
<font color="black"> 759.                 # populated. A fresh instance will be re-built from the</font>
<font color="black"> 760.                 # database if necessary.</font>
<font color="red"> 761.                 cache_name = field.get_cache_name()</font>
<font color="red"> 762.                 if hasattr(self, cache_name):</font>
<font color="red"> 763.                     delattr(self, cache_name)</font>
<font color="black"> 764. </font>
<font color="green"> 765.     def _save_table(self, raw=False, cls=None, force_insert=False,</font>
<font color="green"> 766.                     force_update=False, using=None, update_fields=None):</font>
<font color="black"> 767.         &quot;&quot;&quot;</font>
<font color="black"> 768.         Does the heavy-lifting involved in saving. Updates or inserts the data</font>
<font color="black"> 769.         for a single table.</font>
<font color="black"> 770.         &quot;&quot;&quot;</font>
<font color="green"> 771.         meta = cls._meta</font>
<font color="green"> 772.         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]</font>
<font color="black"> 773. </font>
<font color="green"> 774.         if update_fields:</font>
<font color="red"> 775.             non_pks = [f for f in non_pks</font>
<font color="red"> 776.                        if f.name in update_fields or f.attname in update_fields]</font>
<font color="black"> 777. </font>
<font color="green"> 778.         pk_val = self._get_pk_val(meta)</font>
<font color="green"> 779.         if pk_val is None:</font>
<font color="green"> 780.             pk_val = meta.pk.get_pk_value_on_save(self)</font>
<font color="green"> 781.             setattr(self, meta.pk.attname, pk_val)</font>
<font color="green"> 782.         pk_set = pk_val is not None</font>
<font color="green"> 783.         if not pk_set and (force_update or update_fields):</font>
<font color="red"> 784.             raise ValueError(&quot;Cannot force an update in save() with no primary key.&quot;)</font>
<font color="green"> 785.         updated = False</font>
<font color="black"> 786.         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.</font>
<font color="green"> 787.         if pk_set and not force_insert:</font>
<font color="red"> 788.             base_qs = cls._base_manager.using(using)</font>
<font color="red"> 789.             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))</font>
<font color="red"> 790.                       for f in non_pks]</font>
<font color="red"> 791.             forced_update = update_fields or force_update</font>
<font color="red"> 792.             updated = self._do_update(base_qs, using, pk_val, values, update_fields,</font>
<font color="red"> 793.                                       forced_update)</font>
<font color="red"> 794.             if force_update and not updated:</font>
<font color="red"> 795.                 raise DatabaseError(&quot;Forced update did not affect any rows.&quot;)</font>
<font color="red"> 796.             if update_fields and not updated:</font>
<font color="red"> 797.                 raise DatabaseError(&quot;Save with update_fields did not affect any rows.&quot;)</font>
<font color="green"> 798.         if not updated:</font>
<font color="green"> 799.             if meta.order_with_respect_to:</font>
<font color="black"> 800.                 # If this is a model with an order_with_respect_to</font>
<font color="black"> 801.                 # autopopulate the _order field</font>
<font color="red"> 802.                 field = meta.order_with_respect_to</font>
<font color="red"> 803.                 filter_args = field.get_filter_kwargs_for_object(self)</font>
<font color="red"> 804.                 order_value = cls._base_manager.using(using).filter(**filter_args).count()</font>
<font color="red"> 805.                 self._order = order_value</font>
<font color="black"> 806. </font>
<font color="green"> 807.             fields = meta.local_concrete_fields</font>
<font color="green"> 808.             if not pk_set:</font>
<font color="green"> 809.                 fields = [f for f in fields if not isinstance(f, AutoField)]</font>
<font color="black"> 810. </font>
<font color="green"> 811.             update_pk = bool(meta.has_auto_field and not pk_set)</font>
<font color="green"> 812.             result = self._do_insert(cls._base_manager, using, fields, update_pk, raw)</font>
<font color="green"> 813.             if update_pk:</font>
<font color="green"> 814.                 setattr(self, meta.pk.attname, result)</font>
<font color="green"> 815.         return updated</font>
<font color="black"> 816. </font>
<font color="green"> 817.     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):</font>
<font color="black"> 818.         &quot;&quot;&quot;</font>
<font color="black"> 819.         This method will try to update the model. If the model was updated (in</font>
<font color="black"> 820.         the sense that an update query was done and a matching row was found</font>
<font color="black"> 821.         from the DB) the method will return True.</font>
<font color="black"> 822.         &quot;&quot;&quot;</font>
<font color="red"> 823.         filtered = base_qs.filter(pk=pk_val)</font>
<font color="red"> 824.         if not values:</font>
<font color="black"> 825.             # We can end up here when saving a model in inheritance chain where</font>
<font color="black"> 826.             # update_fields doesn't target any field in current model. In that</font>
<font color="black"> 827.             # case we just say the update succeeded. Another case ending up here</font>
<font color="black"> 828.             # is a model with just PK - in that case check that the PK still</font>
<font color="black"> 829.             # exists.</font>
<font color="red"> 830.             return update_fields is not None or filtered.exists()</font>
<font color="red"> 831.         if self._meta.select_on_save and not forced_update:</font>
<font color="red"> 832.             if filtered.exists():</font>
<font color="black"> 833.                 # It may happen that the object is deleted from the DB right after</font>
<font color="black"> 834.                 # this check, causing the subsequent UPDATE to return zero matching</font>
<font color="black"> 835.                 # rows. The same result can occur in some rare cases when the</font>
<font color="black"> 836.                 # database returns zero despite the UPDATE being executed</font>
<font color="black"> 837.                 # successfully (a row is matched and updated). In order to</font>
<font color="black"> 838.                 # distinguish these two cases, the object's existence in the</font>
<font color="black"> 839.                 # database is again checked for if the UPDATE query returns 0.</font>
<font color="red"> 840.                 return filtered._update(values) &gt; 0 or filtered.exists()</font>
<font color="black"> 841.             else:</font>
<font color="red"> 842.                 return False</font>
<font color="red"> 843.         return filtered._update(values) &gt; 0</font>
<font color="black"> 844. </font>
<font color="green"> 845.     def _do_insert(self, manager, using, fields, update_pk, raw):</font>
<font color="black"> 846.         &quot;&quot;&quot;</font>
<font color="black"> 847.         Do an INSERT. If update_pk is defined then this method should return</font>
<font color="black"> 848.         the new pk for the model.</font>
<font color="black"> 849.         &quot;&quot;&quot;</font>
<font color="green"> 850.         return manager._insert([self], fields=fields, return_id=update_pk,</font>
<font color="green"> 851.                                using=using, raw=raw)</font>
<font color="black"> 852. </font>
<font color="green"> 853.     def delete(self, using=None, keep_parents=False):</font>
<font color="red"> 854.         using = using or router.db_for_write(self.__class__, instance=self)</font>
<font color="red"> 855.         assert self._get_pk_val() is not None, (</font>
<font color="red"> 856.             &quot;%s object can't be deleted because its %s attribute is set to None.&quot; %</font>
<font color="red"> 857.             (self._meta.object_name, self._meta.pk.attname)</font>
<font color="black"> 858.         )</font>
<font color="black"> 859. </font>
<font color="red"> 860.         collector = Collector(using=using)</font>
<font color="red"> 861.         collector.collect([self], keep_parents=keep_parents)</font>
<font color="red"> 862.         return collector.delete()</font>
<font color="black"> 863. </font>
<font color="green"> 864.     delete.alters_data = True</font>
<font color="black"> 865. </font>
<font color="green"> 866.     def _get_FIELD_display(self, field):</font>
<font color="red"> 867.         value = getattr(self, field.attname)</font>
<font color="red"> 868.         return force_text(dict(field.flatchoices).get(value, value), strings_only=True)</font>
<font color="black"> 869. </font>
<font color="green"> 870.     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):</font>
<font color="red"> 871.         if not self.pk:</font>
<font color="red"> 872.             raise ValueError(&quot;get_next/get_previous cannot be used on unsaved objects.&quot;)</font>
<font color="red"> 873.         op = 'gt' if is_next else 'lt'</font>
<font color="red"> 874.         order = '' if is_next else '-'</font>
<font color="red"> 875.         param = force_text(getattr(self, field.attname))</font>
<font color="red"> 876.         q = Q(**{'%s__%s' % (field.name, op): param})</font>
<font color="red"> 877.         q = q | Q(**{field.name: param, 'pk__%s' % op: self.pk})</font>
<font color="red"> 878.         qs = self.__class__._default_manager.using(self._state.db).filter(**kwargs).filter(q).order_by(</font>
<font color="red"> 879.             '%s%s' % (order, field.name), '%spk' % order</font>
<font color="black"> 880.         )</font>
<font color="red"> 881.         try:</font>
<font color="red"> 882.             return qs[0]</font>
<font color="red"> 883.         except IndexError:</font>
<font color="red"> 884.             raise self.DoesNotExist(&quot;%s matching query does not exist.&quot; % self.__class__._meta.object_name)</font>
<font color="black"> 885. </font>
<font color="green"> 886.     def _get_next_or_previous_in_order(self, is_next):</font>
<font color="red"> 887.         cachename = &quot;__%s_order_cache&quot; % is_next</font>
<font color="red"> 888.         if not hasattr(self, cachename):</font>
<font color="red"> 889.             op = 'gt' if is_next else 'lt'</font>
<font color="red"> 890.             order = '_order' if is_next else '-_order'</font>
<font color="red"> 891.             order_field = self._meta.order_with_respect_to</font>
<font color="red"> 892.             filter_args = order_field.get_filter_kwargs_for_object(self)</font>
<font color="red"> 893.             obj = self._default_manager.filter(**filter_args).filter(**{</font>
<font color="red"> 894.                 '_order__%s' % op: self._default_manager.values('_order').filter(**{</font>
<font color="red"> 895.                     self._meta.pk.name: self.pk</font>
<font color="black"> 896.                 })</font>
<font color="red"> 897.             }).order_by(order)[:1].get()</font>
<font color="red"> 898.             setattr(self, cachename, obj)</font>
<font color="red"> 899.         return getattr(self, cachename)</font>
<font color="black"> 900. </font>
<font color="green"> 901.     def prepare_database_save(self, field):</font>
<font color="red"> 902.         if self.pk is None:</font>
<font color="red"> 903.             raise ValueError(&quot;Unsaved model instance %r cannot be used in an ORM query.&quot; % self)</font>
<font color="red"> 904.         return getattr(self, field.remote_field.get_related_field().attname)</font>
<font color="black"> 905. </font>
<font color="green"> 906.     def clean(self):</font>
<font color="black"> 907.         &quot;&quot;&quot;</font>
<font color="black"> 908.         Hook for doing any extra model-wide validation after clean() has been</font>
<font color="black"> 909.         called on every field by self.clean_fields. Any ValidationError raised</font>
<font color="black"> 910.         by this method will not be associated with a particular field; it will</font>
<font color="black"> 911.         have a special-case association with the field defined by NON_FIELD_ERRORS.</font>
<font color="black"> 912.         &quot;&quot;&quot;</font>
<font color="red"> 913.         pass</font>
<font color="black"> 914. </font>
<font color="green"> 915.     def validate_unique(self, exclude=None):</font>
<font color="black"> 916.         &quot;&quot;&quot;</font>
<font color="black"> 917.         Checks unique constraints on the model and raises ``ValidationError``</font>
<font color="black"> 918.         if any failed.</font>
<font color="black"> 919.         &quot;&quot;&quot;</font>
<font color="red"> 920.         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)</font>
<font color="black"> 921. </font>
<font color="red"> 922.         errors = self._perform_unique_checks(unique_checks)</font>
<font color="red"> 923.         date_errors = self._perform_date_checks(date_checks)</font>
<font color="black"> 924. </font>
<font color="red"> 925.         for k, v in date_errors.items():</font>
<font color="red"> 926.             errors.setdefault(k, []).extend(v)</font>
<font color="black"> 927. </font>
<font color="red"> 928.         if errors:</font>
<font color="red"> 929.             raise ValidationError(errors)</font>
<font color="black"> 930. </font>
<font color="green"> 931.     def _get_unique_checks(self, exclude=None):</font>
<font color="black"> 932.         &quot;&quot;&quot;</font>
<font color="black"> 933.         Gather a list of checks to perform. Since validate_unique could be</font>
<font color="black"> 934.         called from a ModelForm, some fields may have been excluded; we can't</font>
<font color="black"> 935.         perform a unique check on a model that is missing fields involved</font>
<font color="black"> 936.         in that check.</font>
<font color="black"> 937.         Fields that did not validate should also be excluded, but they need</font>
<font color="black"> 938.         to be passed in via the exclude argument.</font>
<font color="black"> 939.         &quot;&quot;&quot;</font>
<font color="red"> 940.         if exclude is None:</font>
<font color="red"> 941.             exclude = []</font>
<font color="red"> 942.         unique_checks = []</font>
<font color="black"> 943. </font>
<font color="red"> 944.         unique_togethers = [(self.__class__, self._meta.unique_together)]</font>
<font color="red"> 945.         for parent_class in self._meta.get_parent_list():</font>
<font color="red"> 946.             if parent_class._meta.unique_together:</font>
<font color="red"> 947.                 unique_togethers.append((parent_class, parent_class._meta.unique_together))</font>
<font color="black"> 948. </font>
<font color="red"> 949.         for model_class, unique_together in unique_togethers:</font>
<font color="red"> 950.             for check in unique_together:</font>
<font color="red"> 951.                 for name in check:</font>
<font color="black"> 952.                     # If this is an excluded field, don't add this check.</font>
<font color="red"> 953.                     if name in exclude:</font>
<font color="red"> 954.                         break</font>
<font color="black"> 955.                 else:</font>
<font color="red"> 956.                     unique_checks.append((model_class, tuple(check)))</font>
<font color="black"> 957. </font>
<font color="black"> 958.         # These are checks for the unique_for_&lt;date/year/month&gt;.</font>
<font color="red"> 959.         date_checks = []</font>
<font color="black"> 960. </font>
<font color="black"> 961.         # Gather a list of checks for fields declared as unique and add them to</font>
<font color="black"> 962.         # the list of checks.</font>
<font color="black"> 963. </font>
<font color="red"> 964.         fields_with_class = [(self.__class__, self._meta.local_fields)]</font>
<font color="red"> 965.         for parent_class in self._meta.get_parent_list():</font>
<font color="red"> 966.             fields_with_class.append((parent_class, parent_class._meta.local_fields))</font>
<font color="black"> 967. </font>
<font color="red"> 968.         for model_class, fields in fields_with_class:</font>
<font color="red"> 969.             for f in fields:</font>
<font color="red"> 970.                 name = f.name</font>
<font color="red"> 971.                 if name in exclude:</font>
<font color="red"> 972.                     continue</font>
<font color="red"> 973.                 if f.unique:</font>
<font color="red"> 974.                     unique_checks.append((model_class, (name,)))</font>
<font color="red"> 975.                 if f.unique_for_date and f.unique_for_date not in exclude:</font>
<font color="red"> 976.                     date_checks.append((model_class, 'date', name, f.unique_for_date))</font>
<font color="red"> 977.                 if f.unique_for_year and f.unique_for_year not in exclude:</font>
<font color="red"> 978.                     date_checks.append((model_class, 'year', name, f.unique_for_year))</font>
<font color="red"> 979.                 if f.unique_for_month and f.unique_for_month not in exclude:</font>
<font color="red"> 980.                     date_checks.append((model_class, 'month', name, f.unique_for_month))</font>
<font color="red"> 981.         return unique_checks, date_checks</font>
<font color="black"> 982. </font>
<font color="green"> 983.     def _perform_unique_checks(self, unique_checks):</font>
<font color="red"> 984.         errors = {}</font>
<font color="black"> 985. </font>
<font color="red"> 986.         for model_class, unique_check in unique_checks:</font>
<font color="black"> 987.             # Try to look up an existing object with the same values as this</font>
<font color="black"> 988.             # object's values for all the unique field.</font>
<font color="black"> 989. </font>
<font color="red"> 990.             lookup_kwargs = {}</font>
<font color="red"> 991.             for field_name in unique_check:</font>
<font color="red"> 992.                 f = self._meta.get_field(field_name)</font>
<font color="red"> 993.                 lookup_value = getattr(self, f.attname)</font>
<font color="red"> 994.                 if lookup_value is None:</font>
<font color="black"> 995.                     # no value, skip the lookup</font>
<font color="red"> 996.                     continue</font>
<font color="red"> 997.                 if f.primary_key and not self._state.adding:</font>
<font color="black"> 998.                     # no need to check for unique primary key when editing</font>
<font color="red"> 999.                     continue</font>
<font color="red">1000.                 lookup_kwargs[str(field_name)] = lookup_value</font>
<font color="black">1001. </font>
<font color="black">1002.             # some fields were skipped, no reason to do the check</font>
<font color="red">1003.             if len(unique_check) != len(lookup_kwargs):</font>
<font color="red">1004.                 continue</font>
<font color="black">1005. </font>
<font color="red">1006.             qs = model_class._default_manager.filter(**lookup_kwargs)</font>
<font color="black">1007. </font>
<font color="black">1008.             # Exclude the current object from the query if we are editing an</font>
<font color="black">1009.             # instance (as opposed to creating a new one)</font>
<font color="black">1010.             # Note that we need to use the pk as defined by model_class, not</font>
<font color="black">1011.             # self.pk. These can be different fields because model inheritance</font>
<font color="black">1012.             # allows single model to have effectively multiple primary keys.</font>
<font color="black">1013.             # Refs #17615.</font>
<font color="red">1014.             model_class_pk = self._get_pk_val(model_class._meta)</font>
<font color="red">1015.             if not self._state.adding and model_class_pk is not None:</font>
<font color="red">1016.                 qs = qs.exclude(pk=model_class_pk)</font>
<font color="red">1017.             if qs.exists():</font>
<font color="red">1018.                 if len(unique_check) == 1:</font>
<font color="red">1019.                     key = unique_check[0]</font>
<font color="black">1020.                 else:</font>
<font color="red">1021.                     key = NON_FIELD_ERRORS</font>
<font color="red">1022.                 errors.setdefault(key, []).append(self.unique_error_message(model_class, unique_check))</font>
<font color="black">1023. </font>
<font color="red">1024.         return errors</font>
<font color="black">1025. </font>
<font color="green">1026.     def _perform_date_checks(self, date_checks):</font>
<font color="red">1027.         errors = {}</font>
<font color="red">1028.         for model_class, lookup_type, field, unique_for in date_checks:</font>
<font color="red">1029.             lookup_kwargs = {}</font>
<font color="black">1030.             # there's a ticket to add a date lookup, we can remove this special</font>
<font color="black">1031.             # case if that makes it's way in</font>
<font color="red">1032.             date = getattr(self, unique_for)</font>
<font color="red">1033.             if date is None:</font>
<font color="red">1034.                 continue</font>
<font color="red">1035.             if lookup_type == 'date':</font>
<font color="red">1036.                 lookup_kwargs['%s__day' % unique_for] = date.day</font>
<font color="red">1037.                 lookup_kwargs['%s__month' % unique_for] = date.month</font>
<font color="red">1038.                 lookup_kwargs['%s__year' % unique_for] = date.year</font>
<font color="black">1039.             else:</font>
<font color="red">1040.                 lookup_kwargs['%s__%s' % (unique_for, lookup_type)] = getattr(date, lookup_type)</font>
<font color="red">1041.             lookup_kwargs[field] = getattr(self, field)</font>
<font color="black">1042. </font>
<font color="red">1043.             qs = model_class._default_manager.filter(**lookup_kwargs)</font>
<font color="black">1044.             # Exclude the current object from the query if we are editing an</font>
<font color="black">1045.             # instance (as opposed to creating a new one)</font>
<font color="red">1046.             if not self._state.adding and self.pk is not None:</font>
<font color="red">1047.                 qs = qs.exclude(pk=self.pk)</font>
<font color="black">1048. </font>
<font color="red">1049.             if qs.exists():</font>
<font color="red">1050.                 errors.setdefault(field, []).append(</font>
<font color="red">1051.                     self.date_error_message(lookup_type, field, unique_for)</font>
<font color="black">1052.                 )</font>
<font color="red">1053.         return errors</font>
<font color="black">1054. </font>
<font color="green">1055.     def date_error_message(self, lookup_type, field_name, unique_for):</font>
<font color="red">1056.         opts = self._meta</font>
<font color="red">1057.         field = opts.get_field(field_name)</font>
<font color="red">1058.         return ValidationError(</font>
<font color="red">1059.             message=field.error_messages['unique_for_date'],</font>
<font color="red">1060.             code='unique_for_date',</font>
<font color="red">1061.             params={</font>
<font color="red">1062.                 'model': self,</font>
<font color="red">1063.                 'model_name': six.text_type(capfirst(opts.verbose_name)),</font>
<font color="red">1064.                 'lookup_type': lookup_type,</font>
<font color="red">1065.                 'field': field_name,</font>
<font color="red">1066.                 'field_label': six.text_type(capfirst(field.verbose_name)),</font>
<font color="red">1067.                 'date_field': unique_for,</font>
<font color="red">1068.                 'date_field_label': six.text_type(capfirst(opts.get_field(unique_for).verbose_name)),</font>
<font color="black">1069.             }</font>
<font color="black">1070.         )</font>
<font color="black">1071. </font>
<font color="green">1072.     def unique_error_message(self, model_class, unique_check):</font>
<font color="red">1073.         opts = model_class._meta</font>
<font color="black">1074. </font>
<font color="red">1075.         params = {</font>
<font color="red">1076.             'model': self,</font>
<font color="red">1077.             'model_class': model_class,</font>
<font color="red">1078.             'model_name': six.text_type(capfirst(opts.verbose_name)),</font>
<font color="red">1079.             'unique_check': unique_check,</font>
<font color="black">1080.         }</font>
<font color="black">1081. </font>
<font color="black">1082.         # A unique field</font>
<font color="red">1083.         if len(unique_check) == 1:</font>
<font color="red">1084.             field = opts.get_field(unique_check[0])</font>
<font color="red">1085.             params['field_label'] = six.text_type(capfirst(field.verbose_name))</font>
<font color="red">1086.             return ValidationError(</font>
<font color="red">1087.                 message=field.error_messages['unique'],</font>
<font color="red">1088.                 code='unique',</font>
<font color="red">1089.                 params=params,</font>
<font color="black">1090.             )</font>
<font color="black">1091. </font>
<font color="black">1092.         # unique_together</font>
<font color="black">1093.         else:</font>
<font color="red">1094.             field_labels = [capfirst(opts.get_field(f).verbose_name) for f in unique_check]</font>
<font color="red">1095.             params['field_labels'] = six.text_type(get_text_list(field_labels, _('and')))</font>
<font color="red">1096.             return ValidationError(</font>
<font color="red">1097.                 message=_(&quot;%(model_name)s with this %(field_labels)s already exists.&quot;),</font>
<font color="red">1098.                 code='unique_together',</font>
<font color="red">1099.                 params=params,</font>
<font color="black">1100.             )</font>
<font color="black">1101. </font>
<font color="green">1102.     def full_clean(self, exclude=None, validate_unique=True):</font>
<font color="black">1103.         &quot;&quot;&quot;</font>
<font color="black">1104.         Calls clean_fields, clean, and validate_unique, on the model,</font>
<font color="black">1105.         and raises a ``ValidationError`` for any errors that occurred.</font>
<font color="black">1106.         &quot;&quot;&quot;</font>
<font color="red">1107.         errors = {}</font>
<font color="red">1108.         if exclude is None:</font>
<font color="red">1109.             exclude = []</font>
<font color="black">1110.         else:</font>
<font color="red">1111.             exclude = list(exclude)</font>
<font color="black">1112. </font>
<font color="red">1113.         try:</font>
<font color="red">1114.             self.clean_fields(exclude=exclude)</font>
<font color="red">1115.         except ValidationError as e:</font>
<font color="red">1116.             errors = e.update_error_dict(errors)</font>
<font color="black">1117. </font>
<font color="black">1118.         # Form.clean() is run even if other validation fails, so do the</font>
<font color="black">1119.         # same with Model.clean() for consistency.</font>
<font color="red">1120.         try:</font>
<font color="red">1121.             self.clean()</font>
<font color="red">1122.         except ValidationError as e:</font>
<font color="red">1123.             errors = e.update_error_dict(errors)</font>
<font color="black">1124. </font>
<font color="black">1125.         # Run unique checks, but only for fields that passed validation.</font>
<font color="red">1126.         if validate_unique:</font>
<font color="red">1127.             for name in errors.keys():</font>
<font color="red">1128.                 if name != NON_FIELD_ERRORS and name not in exclude:</font>
<font color="red">1129.                     exclude.append(name)</font>
<font color="red">1130.             try:</font>
<font color="red">1131.                 self.validate_unique(exclude=exclude)</font>
<font color="red">1132.             except ValidationError as e:</font>
<font color="red">1133.                 errors = e.update_error_dict(errors)</font>
<font color="black">1134. </font>
<font color="red">1135.         if errors:</font>
<font color="red">1136.             raise ValidationError(errors)</font>
<font color="black">1137. </font>
<font color="green">1138.     def clean_fields(self, exclude=None):</font>
<font color="black">1139.         &quot;&quot;&quot;</font>
<font color="black">1140.         Cleans all fields and raises a ValidationError containing a dict</font>
<font color="black">1141.         of all validation errors if any occur.</font>
<font color="black">1142.         &quot;&quot;&quot;</font>
<font color="red">1143.         if exclude is None:</font>
<font color="red">1144.             exclude = []</font>
<font color="black">1145. </font>
<font color="red">1146.         errors = {}</font>
<font color="red">1147.         for f in self._meta.fields:</font>
<font color="red">1148.             if f.name in exclude:</font>
<font color="red">1149.                 continue</font>
<font color="black">1150.             # Skip validation for empty fields with blank=True. The developer</font>
<font color="black">1151.             # is responsible for making sure they have a valid value.</font>
<font color="red">1152.             raw_value = getattr(self, f.attname)</font>
<font color="red">1153.             if f.blank and raw_value in f.empty_values:</font>
<font color="red">1154.                 continue</font>
<font color="red">1155.             try:</font>
<font color="red">1156.                 setattr(self, f.attname, f.clean(raw_value, self))</font>
<font color="red">1157.             except ValidationError as e:</font>
<font color="red">1158.                 errors[f.name] = e.error_list</font>
<font color="black">1159. </font>
<font color="red">1160.         if errors:</font>
<font color="red">1161.             raise ValidationError(errors)</font>
<font color="black">1162. </font>
<font color="green">1163.     @classmethod</font>
<font color="black">1164.     def check(cls, **kwargs):</font>
<font color="red">1165.         errors = []</font>
<font color="red">1166.         errors.extend(cls._check_swappable())</font>
<font color="red">1167.         errors.extend(cls._check_model())</font>
<font color="red">1168.         errors.extend(cls._check_managers(**kwargs))</font>
<font color="red">1169.         if not cls._meta.swapped:</font>
<font color="red">1170.             errors.extend(cls._check_fields(**kwargs))</font>
<font color="red">1171.             errors.extend(cls._check_m2m_through_same_relationship())</font>
<font color="red">1172.             errors.extend(cls._check_long_column_names())</font>
<font color="red">1173.             clash_errors = cls._check_id_field() + cls._check_field_name_clashes()</font>
<font color="red">1174.             errors.extend(clash_errors)</font>
<font color="black">1175.             # If there are field name clashes, hide consequent column name</font>
<font color="black">1176.             # clashes.</font>
<font color="red">1177.             if not clash_errors:</font>
<font color="red">1178.                 errors.extend(cls._check_column_name_clashes())</font>
<font color="red">1179.             errors.extend(cls._check_index_together())</font>
<font color="red">1180.             errors.extend(cls._check_unique_together())</font>
<font color="red">1181.             errors.extend(cls._check_ordering())</font>
<font color="black">1182. </font>
<font color="red">1183.         return errors</font>
<font color="black">1184. </font>
<font color="green">1185.     @classmethod</font>
<font color="black">1186.     def _check_swappable(cls):</font>
<font color="black">1187.         &quot;&quot;&quot; Check if the swapped model exists. &quot;&quot;&quot;</font>
<font color="black">1188. </font>
<font color="red">1189.         errors = []</font>
<font color="red">1190.         if cls._meta.swapped:</font>
<font color="red">1191.             try:</font>
<font color="red">1192.                 apps.get_model(cls._meta.swapped)</font>
<font color="red">1193.             except ValueError:</font>
<font color="red">1194.                 errors.append(</font>
<font color="red">1195.                     checks.Error(</font>
<font color="red">1196.                         &quot;'%s' is not of the form 'app_label.app_name'.&quot; % cls._meta.swappable,</font>
<font color="red">1197.                         hint=None,</font>
<font color="red">1198.                         obj=None,</font>
<font color="red">1199.                         id='models.E001',</font>
<font color="black">1200.                     )</font>
<font color="black">1201.                 )</font>
<font color="red">1202.             except LookupError:</font>
<font color="red">1203.                 app_label, model_name = cls._meta.swapped.split('.')</font>
<font color="red">1204.                 errors.append(</font>
<font color="red">1205.                     checks.Error(</font>
<font color="red">1206.                         &quot;'%s' references '%s.%s', which has not been &quot;</font>
<font color="black">1207.                         &quot;installed, or is abstract.&quot; % (</font>
<font color="red">1208.                             cls._meta.swappable, app_label, model_name</font>
<font color="black">1209.                         ),</font>
<font color="red">1210.                         hint=None,</font>
<font color="red">1211.                         obj=None,</font>
<font color="red">1212.                         id='models.E002',</font>
<font color="black">1213.                     )</font>
<font color="black">1214.                 )</font>
<font color="red">1215.         return errors</font>
<font color="black">1216. </font>
<font color="green">1217.     @classmethod</font>
<font color="black">1218.     def _check_model(cls):</font>
<font color="red">1219.         errors = []</font>
<font color="red">1220.         if cls._meta.proxy:</font>
<font color="red">1221.             if cls._meta.local_fields or cls._meta.local_many_to_many:</font>
<font color="red">1222.                 errors.append(</font>
<font color="red">1223.                     checks.Error(</font>
<font color="red">1224.                         &quot;Proxy model '%s' contains model fields.&quot; % cls.__name__,</font>
<font color="red">1225.                         hint=None,</font>
<font color="red">1226.                         obj=None,</font>
<font color="red">1227.                         id='models.E017',</font>
<font color="black">1228.                     )</font>
<font color="black">1229.                 )</font>
<font color="red">1230.         return errors</font>
<font color="black">1231. </font>
<font color="green">1232.     @classmethod</font>
<font color="black">1233.     def _check_managers(cls, **kwargs):</font>
<font color="black">1234.         &quot;&quot;&quot; Perform all manager checks. &quot;&quot;&quot;</font>
<font color="black">1235. </font>
<font color="red">1236.         errors = []</font>
<font color="red">1237.         for __, manager, __ in cls._meta.managers:</font>
<font color="red">1238.             errors.extend(manager.check(**kwargs))</font>
<font color="red">1239.         return errors</font>
<font color="black">1240. </font>
<font color="green">1241.     @classmethod</font>
<font color="black">1242.     def _check_fields(cls, **kwargs):</font>
<font color="black">1243.         &quot;&quot;&quot; Perform all field checks. &quot;&quot;&quot;</font>
<font color="black">1244. </font>
<font color="red">1245.         errors = []</font>
<font color="red">1246.         for field in cls._meta.local_fields:</font>
<font color="red">1247.             errors.extend(field.check(**kwargs))</font>
<font color="red">1248.         for field in cls._meta.local_many_to_many:</font>
<font color="red">1249.             errors.extend(field.check(from_model=cls, **kwargs))</font>
<font color="red">1250.         return errors</font>
<font color="black">1251. </font>
<font color="green">1252.     @classmethod</font>
<font color="black">1253.     def _check_m2m_through_same_relationship(cls):</font>
<font color="black">1254.         &quot;&quot;&quot; Check if no relationship model is used by more than one m2m field.</font>
<font color="black">1255.         &quot;&quot;&quot;</font>
<font color="black">1256. </font>
<font color="red">1257.         errors = []</font>
<font color="red">1258.         seen_intermediary_signatures = []</font>
<font color="black">1259. </font>
<font color="red">1260.         fields = cls._meta.local_many_to_many</font>
<font color="black">1261. </font>
<font color="black">1262.         # Skip when the target model wasn't found.</font>
<font color="red">1263.         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))</font>
<font color="black">1264. </font>
<font color="black">1265.         # Skip when the relationship model wasn't found.</font>
<font color="red">1266.         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))</font>
<font color="black">1267. </font>
<font color="red">1268.         for f in fields:</font>
<font color="red">1269.             signature = (f.remote_field.model, cls, f.remote_field.through)</font>
<font color="red">1270.             if signature in seen_intermediary_signatures:</font>
<font color="red">1271.                 errors.append(</font>
<font color="red">1272.                     checks.Error(</font>
<font color="red">1273.                         &quot;The model has two many-to-many relations through &quot;</font>
<font color="red">1274.                         &quot;the intermediate model '%s'.&quot; % f.remote_field.through._meta.label,</font>
<font color="red">1275.                         hint=None,</font>
<font color="red">1276.                         obj=cls,</font>
<font color="red">1277.                         id='models.E003',</font>
<font color="black">1278.                     )</font>
<font color="black">1279.                 )</font>
<font color="black">1280.             else:</font>
<font color="red">1281.                 seen_intermediary_signatures.append(signature)</font>
<font color="red">1282.         return errors</font>
<font color="black">1283. </font>
<font color="green">1284.     @classmethod</font>
<font color="black">1285.     def _check_id_field(cls):</font>
<font color="black">1286.         &quot;&quot;&quot; Check if `id` field is a primary key. &quot;&quot;&quot;</font>
<font color="black">1287. </font>
<font color="red">1288.         fields = list(f for f in cls._meta.local_fields</font>
<font color="red">1289.             if f.name == 'id' and f != cls._meta.pk)</font>
<font color="black">1290.         # fields is empty or consists of the invalid &quot;id&quot; field</font>
<font color="red">1291.         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':</font>
<font color="black">1292.             return [</font>
<font color="red">1293.                 checks.Error(</font>
<font color="red">1294.                     &quot;'id' can only be used as a field name if the field also &quot;</font>
<font color="black">1295.                     &quot;sets 'primary_key=True'.&quot;,</font>
<font color="red">1296.                     hint=None,</font>
<font color="red">1297.                     obj=cls,</font>
<font color="red">1298.                     id='models.E004',</font>
<font color="black">1299.                 )</font>
<font color="black">1300.             ]</font>
<font color="black">1301.         else:</font>
<font color="red">1302.             return []</font>
<font color="black">1303. </font>
<font color="green">1304.     @classmethod</font>
<font color="black">1305.     def _check_field_name_clashes(cls):</font>
<font color="black">1306.         &quot;&quot;&quot; Ref #17673. &quot;&quot;&quot;</font>
<font color="black">1307. </font>
<font color="red">1308.         errors = []</font>
<font color="red">1309.         used_fields = {}  # name or attname -&gt; field</font>
<font color="black">1310. </font>
<font color="black">1311.         # Check that multi-inheritance doesn't cause field name shadowing.</font>
<font color="red">1312.         for parent in cls._meta.get_parent_list():</font>
<font color="red">1313.             for f in parent._meta.local_fields:</font>
<font color="red">1314.                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None</font>
<font color="red">1315.                 if clash:</font>
<font color="red">1316.                     errors.append(</font>
<font color="red">1317.                         checks.Error(</font>
<font color="red">1318.                             &quot;The field '%s' from parent model &quot;</font>
<font color="black">1319.                             &quot;'%s' clashes with the field '%s' &quot;</font>
<font color="black">1320.                             &quot;from parent model '%s'.&quot; % (</font>
<font color="red">1321.                                 clash.name, clash.model._meta,</font>
<font color="red">1322.                                 f.name, f.model._meta</font>
<font color="black">1323.                             ),</font>
<font color="red">1324.                             hint=None,</font>
<font color="red">1325.                             obj=cls,</font>
<font color="red">1326.                             id='models.E005',</font>
<font color="black">1327.                         )</font>
<font color="black">1328.                     )</font>
<font color="red">1329.                 used_fields[f.name] = f</font>
<font color="red">1330.                 used_fields[f.attname] = f</font>
<font color="black">1331. </font>
<font color="black">1332.         # Check that fields defined in the model don't clash with fields from</font>
<font color="black">1333.         # parents, including auto-generated fields like multi-table inheritance</font>
<font color="black">1334.         # child accessors.</font>
<font color="red">1335.         for parent in cls._meta.get_parent_list():</font>
<font color="red">1336.             for f in parent._meta.get_fields():</font>
<font color="red">1337.                 if f not in used_fields:</font>
<font color="red">1338.                     used_fields[f.name] = f</font>
<font color="black">1339. </font>
<font color="red">1340.         for f in cls._meta.local_fields:</font>
<font color="red">1341.             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None</font>
<font color="black">1342.             # Note that we may detect clash between user-defined non-unique</font>
<font color="black">1343.             # field &quot;id&quot; and automatically added unique field &quot;id&quot;, both</font>
<font color="black">1344.             # defined at the same model. This special case is considered in</font>
<font color="black">1345.             # _check_id_field and here we ignore it.</font>
<font color="red">1346.             id_conflict = (f.name == &quot;id&quot; and</font>
<font color="red">1347.                 clash and clash.name == &quot;id&quot; and clash.model == cls)</font>
<font color="red">1348.             if clash and not id_conflict:</font>
<font color="red">1349.                 errors.append(</font>
<font color="red">1350.                     checks.Error(</font>
<font color="red">1351.                         &quot;The field '%s' clashes with the field '%s' &quot;</font>
<font color="black">1352.                         &quot;from model '%s'.&quot; % (</font>
<font color="red">1353.                             f.name, clash.name, clash.model._meta</font>
<font color="black">1354.                         ),</font>
<font color="red">1355.                         hint=None,</font>
<font color="red">1356.                         obj=f,</font>
<font color="red">1357.                         id='models.E006',</font>
<font color="black">1358.                     )</font>
<font color="black">1359.                 )</font>
<font color="red">1360.             used_fields[f.name] = f</font>
<font color="red">1361.             used_fields[f.attname] = f</font>
<font color="black">1362. </font>
<font color="red">1363.         return errors</font>
<font color="black">1364. </font>
<font color="green">1365.     @classmethod</font>
<font color="black">1366.     def _check_column_name_clashes(cls):</font>
<font color="black">1367.         # Store a list of column names which have already been used by other fields.</font>
<font color="red">1368.         used_column_names = []</font>
<font color="red">1369.         errors = []</font>
<font color="black">1370. </font>
<font color="red">1371.         for f in cls._meta.local_fields:</font>
<font color="red">1372.             _, column_name = f.get_attname_column()</font>
<font color="black">1373. </font>
<font color="black">1374.             # Ensure the column name is not already in use.</font>
<font color="red">1375.             if column_name and column_name in used_column_names:</font>
<font color="red">1376.                 errors.append(</font>
<font color="red">1377.                     checks.Error(</font>
<font color="red">1378.                         &quot;Field '%s' has column name '%s' that is used by &quot;</font>
<font color="red">1379.                         &quot;another field.&quot; % (f.name, column_name),</font>
<font color="red">1380.                         hint=&quot;Specify a 'db_column' for the field.&quot;,</font>
<font color="red">1381.                         obj=cls,</font>
<font color="red">1382.                         id='models.E007'</font>
<font color="black">1383.                     )</font>
<font color="black">1384.                 )</font>
<font color="black">1385.             else:</font>
<font color="red">1386.                 used_column_names.append(column_name)</font>
<font color="black">1387. </font>
<font color="red">1388.         return errors</font>
<font color="black">1389. </font>
<font color="green">1390.     @classmethod</font>
<font color="black">1391.     def _check_index_together(cls):</font>
<font color="black">1392.         &quot;&quot;&quot; Check the value of &quot;index_together&quot; option. &quot;&quot;&quot;</font>
<font color="red">1393.         if not isinstance(cls._meta.index_together, (tuple, list)):</font>
<font color="black">1394.             return [</font>
<font color="red">1395.                 checks.Error(</font>
<font color="red">1396.                     &quot;'index_together' must be a list or tuple.&quot;,</font>
<font color="red">1397.                     hint=None,</font>
<font color="red">1398.                     obj=cls,</font>
<font color="red">1399.                     id='models.E008',</font>
<font color="black">1400.                 )</font>
<font color="black">1401.             ]</font>
<font color="black">1402. </font>
<font color="red">1403.         elif any(not isinstance(fields, (tuple, list))</font>
<font color="red">1404.                 for fields in cls._meta.index_together):</font>
<font color="black">1405.             return [</font>
<font color="red">1406.                 checks.Error(</font>
<font color="red">1407.                     &quot;All 'index_together' elements must be lists or tuples.&quot;,</font>
<font color="red">1408.                     hint=None,</font>
<font color="red">1409.                     obj=cls,</font>
<font color="red">1410.                     id='models.E009',</font>
<font color="black">1411.                 )</font>
<font color="black">1412.             ]</font>
<font color="black">1413. </font>
<font color="black">1414.         else:</font>
<font color="red">1415.             errors = []</font>
<font color="red">1416.             for fields in cls._meta.index_together:</font>
<font color="red">1417.                 errors.extend(cls._check_local_fields(fields, &quot;index_together&quot;))</font>
<font color="red">1418.             return errors</font>
<font color="black">1419. </font>
<font color="green">1420.     @classmethod</font>
<font color="black">1421.     def _check_unique_together(cls):</font>
<font color="black">1422.         &quot;&quot;&quot; Check the value of &quot;unique_together&quot; option. &quot;&quot;&quot;</font>
<font color="red">1423.         if not isinstance(cls._meta.unique_together, (tuple, list)):</font>
<font color="black">1424.             return [</font>
<font color="red">1425.                 checks.Error(</font>
<font color="red">1426.                     &quot;'unique_together' must be a list or tuple.&quot;,</font>
<font color="red">1427.                     hint=None,</font>
<font color="red">1428.                     obj=cls,</font>
<font color="red">1429.                     id='models.E010',</font>
<font color="black">1430.                 )</font>
<font color="black">1431.             ]</font>
<font color="black">1432. </font>
<font color="red">1433.         elif any(not isinstance(fields, (tuple, list))</font>
<font color="red">1434.                 for fields in cls._meta.unique_together):</font>
<font color="black">1435.             return [</font>
<font color="red">1436.                 checks.Error(</font>
<font color="red">1437.                     &quot;All 'unique_together' elements must be lists or tuples.&quot;,</font>
<font color="red">1438.                     hint=None,</font>
<font color="red">1439.                     obj=cls,</font>
<font color="red">1440.                     id='models.E011',</font>
<font color="black">1441.                 )</font>
<font color="black">1442.             ]</font>
<font color="black">1443. </font>
<font color="black">1444.         else:</font>
<font color="red">1445.             errors = []</font>
<font color="red">1446.             for fields in cls._meta.unique_together:</font>
<font color="red">1447.                 errors.extend(cls._check_local_fields(fields, &quot;unique_together&quot;))</font>
<font color="red">1448.             return errors</font>
<font color="black">1449. </font>
<font color="green">1450.     @classmethod</font>
<font color="black">1451.     def _check_local_fields(cls, fields, option):</font>
<font color="red">1452.         from django.db import models</font>
<font color="black">1453. </font>
<font color="black">1454.         # In order to avoid hitting the relation tree prematurely, we use our</font>
<font color="black">1455.         # own fields_map instead of using get_field()</font>
<font color="black">1456.         forward_fields_map = {</font>
<font color="red">1457.             field.name: field for field in cls._meta._get_fields(reverse=False)</font>
<font color="black">1458.         }</font>
<font color="black">1459. </font>
<font color="red">1460.         errors = []</font>
<font color="red">1461.         for field_name in fields:</font>
<font color="red">1462.             try:</font>
<font color="red">1463.                 field = forward_fields_map[field_name]</font>
<font color="red">1464.             except KeyError:</font>
<font color="red">1465.                 errors.append(</font>
<font color="red">1466.                     checks.Error(</font>
<font color="red">1467.                         &quot;'%s' refers to the non-existent field '%s'.&quot; % (</font>
<font color="red">1468.                             option, field_name,</font>
<font color="black">1469.                         ),</font>
<font color="red">1470.                         hint=None,</font>
<font color="red">1471.                         obj=cls,</font>
<font color="red">1472.                         id='models.E012',</font>
<font color="black">1473.                     )</font>
<font color="black">1474.                 )</font>
<font color="black">1475.             else:</font>
<font color="red">1476.                 if isinstance(field.remote_field, models.ManyToManyRel):</font>
<font color="red">1477.                     errors.append(</font>
<font color="red">1478.                         checks.Error(</font>
<font color="red">1479.                             &quot;'%s' refers to a ManyToManyField '%s', but &quot;</font>
<font color="black">1480.                             &quot;ManyToManyFields are not permitted in '%s'.&quot; % (</font>
<font color="red">1481.                                 option, field_name, option,</font>
<font color="black">1482.                             ),</font>
<font color="red">1483.                             hint=None,</font>
<font color="red">1484.                             obj=cls,</font>
<font color="red">1485.                             id='models.E013',</font>
<font color="black">1486.                         )</font>
<font color="black">1487.                     )</font>
<font color="red">1488.                 elif field not in cls._meta.local_fields:</font>
<font color="red">1489.                     errors.append(</font>
<font color="red">1490.                         checks.Error(</font>
<font color="red">1491.                             (&quot;'%s' refers to field '%s' which is not local &quot;</font>
<font color="black">1492.                              &quot;to model '%s'.&quot;) % (</font>
<font color="red">1493.                                 option, field_name, cls._meta.object_name,</font>
<font color="black">1494.                             ),</font>
<font color="red">1495.                             hint=(&quot;This issue may be caused by multi-table &quot;</font>
<font color="black">1496.                                   &quot;inheritance.&quot;),</font>
<font color="red">1497.                             obj=cls,</font>
<font color="red">1498.                             id='models.E016',</font>
<font color="black">1499.                         )</font>
<font color="black">1500.                     )</font>
<font color="red">1501.         return errors</font>
<font color="black">1502. </font>
<font color="green">1503.     @classmethod</font>
<font color="black">1504.     def _check_ordering(cls):</font>
<font color="black">1505.         &quot;&quot;&quot; Check &quot;ordering&quot; option -- is it a list of strings and do all fields</font>
<font color="black">1506.         exist? &quot;&quot;&quot;</font>
<font color="red">1507.         if cls._meta._ordering_clash:</font>
<font color="black">1508.             return [</font>
<font color="red">1509.                 checks.Error(</font>
<font color="red">1510.                     &quot;'ordering' and 'order_with_respect_to' cannot be used together.&quot;,</font>
<font color="red">1511.                     hint=None,</font>
<font color="red">1512.                     obj=cls,</font>
<font color="red">1513.                     id='models.E021',</font>
<font color="black">1514.                 ),</font>
<font color="black">1515.             ]</font>
<font color="black">1516. </font>
<font color="red">1517.         if cls._meta.order_with_respect_to or not cls._meta.ordering:</font>
<font color="red">1518.             return []</font>
<font color="black">1519. </font>
<font color="red">1520.         if not isinstance(cls._meta.ordering, (list, tuple)):</font>
<font color="black">1521.             return [</font>
<font color="red">1522.                 checks.Error(</font>
<font color="red">1523.                     (&quot;'ordering' must be a tuple or list &quot;</font>
<font color="black">1524.                      &quot;(even if you want to order by only one field).&quot;),</font>
<font color="red">1525.                     hint=None,</font>
<font color="red">1526.                     obj=cls,</font>
<font color="red">1527.                     id='models.E014',</font>
<font color="black">1528.                 )</font>
<font color="black">1529.             ]</font>
<font color="black">1530. </font>
<font color="red">1531.         errors = []</font>
<font color="red">1532.         fields = cls._meta.ordering</font>
<font color="black">1533. </font>
<font color="black">1534.         # Skip '?' fields.</font>
<font color="red">1535.         fields = (f for f in fields if f != '?')</font>
<font color="black">1536. </font>
<font color="black">1537.         # Convert &quot;-field&quot; to &quot;field&quot;.</font>
<font color="red">1538.         fields = ((f[1:] if f.startswith('-') else f) for f in fields)</font>
<font color="black">1539. </font>
<font color="black">1540.         # Skip ordering in the format field1__field2 (FIXME: checking</font>
<font color="black">1541.         # this format would be nice, but it's a little fiddly).</font>
<font color="red">1542.         fields = (f for f in fields if '__' not in f)</font>
<font color="black">1543. </font>
<font color="black">1544.         # Skip ordering on pk. This is always a valid order_by field</font>
<font color="black">1545.         # but is an alias and therefore won't be found by opts.get_field.</font>
<font color="red">1546.         fields = {f for f in fields if f != 'pk'}</font>
<font color="black">1547. </font>
<font color="black">1548.         # Check for invalid or non-existent fields in ordering.</font>
<font color="red">1549.         invalid_fields = []</font>
<font color="black">1550. </font>
<font color="black">1551.         # Any field name that is not present in field_names does not exist.</font>
<font color="black">1552.         # Also, ordering by m2m fields is not allowed.</font>
<font color="red">1553.         opts = cls._meta</font>
<font color="red">1554.         valid_fields = set(chain.from_iterable(</font>
<font color="red">1555.             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)</font>
<font color="red">1556.             for f in chain(opts.fields, opts.related_objects)</font>
<font color="black">1557.         ))</font>
<font color="black">1558. </font>
<font color="red">1559.         invalid_fields.extend(fields - valid_fields)</font>
<font color="black">1560. </font>
<font color="red">1561.         for invalid_field in invalid_fields:</font>
<font color="red">1562.             errors.append(</font>
<font color="red">1563.                 checks.Error(</font>
<font color="red">1564.                     &quot;'ordering' refers to the non-existent field '%s'.&quot; % invalid_field,</font>
<font color="red">1565.                     hint=None,</font>
<font color="red">1566.                     obj=cls,</font>
<font color="red">1567.                     id='models.E015',</font>
<font color="black">1568.                 )</font>
<font color="black">1569.             )</font>
<font color="red">1570.         return errors</font>
<font color="black">1571. </font>
<font color="green">1572.     @classmethod</font>
<font color="black">1573.     def _check_long_column_names(cls):</font>
<font color="black">1574.         &quot;&quot;&quot;</font>
<font color="black">1575.         Check that any auto-generated column names are shorter than the limits</font>
<font color="black">1576.         for each database in which the model will be created.</font>
<font color="black">1577.         &quot;&quot;&quot;</font>
<font color="red">1578.         errors = []</font>
<font color="red">1579.         allowed_len = None</font>
<font color="red">1580.         db_alias = None</font>
<font color="black">1581. </font>
<font color="black">1582.         # Find the minimum max allowed length among all specified db_aliases.</font>
<font color="red">1583.         for db in settings.DATABASES.keys():</font>
<font color="black">1584.             # skip databases where the model won't be created</font>
<font color="red">1585.             if not router.allow_migrate_model(db, cls):</font>
<font color="red">1586.                 continue</font>
<font color="red">1587.             connection = connections[db]</font>
<font color="red">1588.             max_name_length = connection.ops.max_name_length()</font>
<font color="red">1589.             if max_name_length is None or connection.features.truncates_names:</font>
<font color="red">1590.                 continue</font>
<font color="black">1591.             else:</font>
<font color="red">1592.                 if allowed_len is None:</font>
<font color="red">1593.                     allowed_len = max_name_length</font>
<font color="red">1594.                     db_alias = db</font>
<font color="red">1595.                 elif max_name_length &lt; allowed_len:</font>
<font color="red">1596.                     allowed_len = max_name_length</font>
<font color="red">1597.                     db_alias = db</font>
<font color="black">1598. </font>
<font color="red">1599.         if allowed_len is None:</font>
<font color="red">1600.             return errors</font>
<font color="black">1601. </font>
<font color="red">1602.         for f in cls._meta.local_fields:</font>
<font color="red">1603.             _, column_name = f.get_attname_column()</font>
<font color="black">1604. </font>
<font color="black">1605.             # Check if auto-generated name for the field is too long</font>
<font color="black">1606.             # for the database.</font>
<font color="red">1607.             if (f.db_column is None and column_name is not None</font>
<font color="red">1608.                     and len(column_name) &gt; allowed_len):</font>
<font color="red">1609.                 errors.append(</font>
<font color="red">1610.                     checks.Error(</font>
<font color="red">1611.                         'Autogenerated column name too long for field &quot;%s&quot;. '</font>
<font color="black">1612.                         'Maximum length is &quot;%s&quot; for database &quot;%s&quot;.'</font>
<font color="red">1613.                         % (column_name, allowed_len, db_alias),</font>
<font color="red">1614.                         hint=&quot;Set the column name manually using 'db_column'.&quot;,</font>
<font color="red">1615.                         obj=cls,</font>
<font color="red">1616.                         id='models.E018',</font>
<font color="black">1617.                     )</font>
<font color="black">1618.                 )</font>
<font color="black">1619. </font>
<font color="red">1620.         for f in cls._meta.local_many_to_many:</font>
<font color="black">1621.             # Check if auto-generated name for the M2M field is too long</font>
<font color="black">1622.             # for the database.</font>
<font color="red">1623.             for m2m in f.remote_field.through._meta.local_fields:</font>
<font color="red">1624.                 _, rel_name = m2m.get_attname_column()</font>
<font color="red">1625.                 if (m2m.db_column is None and rel_name is not None</font>
<font color="red">1626.                         and len(rel_name) &gt; allowed_len):</font>
<font color="red">1627.                     errors.append(</font>
<font color="red">1628.                         checks.Error(</font>
<font color="red">1629.                             'Autogenerated column name too long for M2M field '</font>
<font color="black">1630.                             '&quot;%s&quot;. Maximum length is &quot;%s&quot; for database &quot;%s&quot;.'</font>
<font color="red">1631.                             % (rel_name, allowed_len, db_alias),</font>
<font color="red">1632.                             hint=(&quot;Use 'through' to create a separate model &quot;</font>
<font color="black">1633.                                 &quot;for M2M and then set column_name using &quot;</font>
<font color="black">1634.                                 &quot;'db_column'.&quot;),</font>
<font color="red">1635.                             obj=cls,</font>
<font color="red">1636.                             id='models.E019',</font>
<font color="black">1637.                         )</font>
<font color="black">1638.                     )</font>
<font color="black">1639. </font>
<font color="red">1640.         return errors</font>
<font color="black">1641. </font>
<font color="black">1642. </font>
<font color="black">1643. ############################################</font>
<font color="black">1644. # HELPER FUNCTIONS (CURRIED MODEL METHODS) #</font>
<font color="black">1645. ############################################</font>
<font color="black">1646. </font>
<font color="black">1647. # ORDERING METHODS #########################</font>
<font color="black">1648. </font>
<font color="green">1649. def method_set_order(ordered_obj, self, id_list, using=None):</font>
<font color="red">1650.     if using is None:</font>
<font color="red">1651.         using = DEFAULT_DB_ALIAS</font>
<font color="red">1652.     order_wrt = ordered_obj._meta.order_with_respect_to</font>
<font color="red">1653.     filter_args = order_wrt.get_forward_related_filter(self)</font>
<font color="black">1654.     # FIXME: It would be nice if there was an &quot;update many&quot; version of update</font>
<font color="black">1655.     # for situations like this.</font>
<font color="red">1656.     with transaction.atomic(using=using, savepoint=False):</font>
<font color="red">1657.         for i, j in enumerate(id_list):</font>
<font color="red">1658.             ordered_obj.objects.filter(pk=j, **filter_args).update(_order=i)</font>
<font color="black">1659. </font>
<font color="black">1660. </font>
<font color="green">1661. def method_get_order(ordered_obj, self):</font>
<font color="red">1662.     order_wrt = ordered_obj._meta.order_with_respect_to</font>
<font color="red">1663.     filter_args = order_wrt.get_forward_related_filter(self)</font>
<font color="red">1664.     pk_name = ordered_obj._meta.pk.name</font>
<font color="red">1665.     return ordered_obj.objects.filter(**filter_args).values_list(pk_name, flat=True)</font>
<font color="black">1666. </font>
<font color="black">1667. </font>
<font color="green">1668. def make_foreign_order_accessors(model, related_model):</font>
<font color="red">1669.     setattr(</font>
<font color="red">1670.         related_model,</font>
<font color="red">1671.         'get_%s_order' % model.__name__.lower(),</font>
<font color="red">1672.         curry(method_get_order, model)</font>
<font color="black">1673.     )</font>
<font color="red">1674.     setattr(</font>
<font color="red">1675.         related_model,</font>
<font color="red">1676.         'set_%s_order' % model.__name__.lower(),</font>
<font color="red">1677.         curry(method_set_order, model)</font>
<font color="black">1678.     )</font>
<font color="black">1679. </font>
<font color="black">1680. ########</font>
<font color="black">1681. # MISC #</font>
<font color="black">1682. ########</font>
<font color="black">1683. </font>
<font color="black">1684. </font>
<font color="green">1685. def simple_class_factory(model, attrs):</font>
<font color="black">1686.     &quot;&quot;&quot;</font>
<font color="black">1687.     Needed for dynamic classes.</font>
<font color="black">1688.     &quot;&quot;&quot;</font>
<font color="red">1689.     return model</font>
<font color="black">1690. </font>
<font color="black">1691. </font>
<font color="green">1692. def model_unpickle(model_id, attrs, factory):</font>
<font color="black">1693.     &quot;&quot;&quot;</font>
<font color="black">1694.     Used to unpickle Model subclasses with deferred fields.</font>
<font color="black">1695.     &quot;&quot;&quot;</font>
<font color="red">1696.     if isinstance(model_id, tuple):</font>
<font color="red">1697.         if not apps.ready:</font>
<font color="red">1698.             apps.populate(settings.INSTALLED_APPS)</font>
<font color="red">1699.         model = apps.get_model(*model_id)</font>
<font color="black">1700.     else:</font>
<font color="black">1701.         # Backwards compat - the model was cached directly in earlier versions.</font>
<font color="red">1702.         model = model_id</font>
<font color="red">1703.     cls = factory(model, attrs)</font>
<font color="red">1704.     return cls.__new__(cls)</font>
<font color="green">1705. model_unpickle.__safe_for_unpickle__ = True</font>
<font color="black">1706. </font>
<font color="black">1707. </font>
<font color="green">1708. def unpickle_inner_exception(klass, exception_name):</font>
<font color="black">1709.     # Get the exception class from the class it is attached to:</font>
<font color="red">1710.     exception = getattr(klass, exception_name)</font>
<font color="red">1711.     return exception.__new__(exception)</font>
</pre>

