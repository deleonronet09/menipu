source file: <b>/usr/lib/python2.7/SocketServer.py</b><br>


file stats: <b>263 lines, 100 executed: 38.0% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Generic socket server classes.</font>
<font color="black">   2. </font>
<font color="black">   3. This module tries to capture the various aspects of defining a server:</font>
<font color="black">   4. </font>
<font color="black">   5. For socket-based servers:</font>
<font color="black">   6. </font>
<font color="black">   7. - address family:</font>
<font color="black">   8.         - AF_INET{,6}: IP (Internet Protocol) sockets (default)</font>
<font color="black">   9.         - AF_UNIX: Unix domain sockets</font>
<font color="black">  10.         - others, e.g. AF_DECNET are conceivable (see &lt;socket.h&gt;</font>
<font color="black">  11. - socket type:</font>
<font color="black">  12.         - SOCK_STREAM (reliable stream, e.g. TCP)</font>
<font color="black">  13.         - SOCK_DGRAM (datagrams, e.g. UDP)</font>
<font color="black">  14. </font>
<font color="black">  15. For request-based servers (including socket-based):</font>
<font color="black">  16. </font>
<font color="black">  17. - client address verification before further looking at the request</font>
<font color="black">  18.         (This is actually a hook for any processing that needs to look</font>
<font color="black">  19.          at the request before anything else, e.g. logging)</font>
<font color="black">  20. - how to handle multiple requests:</font>
<font color="black">  21.         - synchronous (one request is handled at a time)</font>
<font color="black">  22.         - forking (each request is handled by a new process)</font>
<font color="black">  23.         - threading (each request is handled by a new thread)</font>
<font color="black">  24. </font>
<font color="black">  25. The classes in this module favor the server type that is simplest to</font>
<font color="black">  26. write: a synchronous TCP/IP server.  This is bad class design, but</font>
<font color="black">  27. save some typing.  (There's also the issue that a deep class hierarchy</font>
<font color="black">  28. slows down method lookups.)</font>
<font color="black">  29. </font>
<font color="black">  30. There are five classes in an inheritance diagram, four of which represent</font>
<font color="black">  31. synchronous servers of four types:</font>
<font color="black">  32. </font>
<font color="black">  33.         +------------+</font>
<font color="black">  34.         | BaseServer |</font>
<font color="black">  35.         +------------+</font>
<font color="black">  36.               |</font>
<font color="black">  37.               v</font>
<font color="black">  38.         +-----------+        +------------------+</font>
<font color="black">  39.         | TCPServer |-------&gt;| UnixStreamServer |</font>
<font color="black">  40.         +-----------+        +------------------+</font>
<font color="black">  41.               |</font>
<font color="black">  42.               v</font>
<font color="black">  43.         +-----------+        +--------------------+</font>
<font color="black">  44.         | UDPServer |-------&gt;| UnixDatagramServer |</font>
<font color="black">  45.         +-----------+        +--------------------+</font>
<font color="black">  46. </font>
<font color="black">  47. Note that UnixDatagramServer derives from UDPServer, not from</font>
<font color="black">  48. UnixStreamServer -- the only difference between an IP and a Unix</font>
<font color="black">  49. stream server is the address family, which is simply repeated in both</font>
<font color="black">  50. unix server classes.</font>
<font color="black">  51. </font>
<font color="black">  52. Forking and threading versions of each type of server can be created</font>
<font color="black">  53. using the ForkingMixIn and ThreadingMixIn mix-in classes.  For</font>
<font color="black">  54. instance, a threading UDP server class is created as follows:</font>
<font color="black">  55. </font>
<font color="black">  56.         class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass</font>
<font color="black">  57. </font>
<font color="black">  58. The Mix-in class must come first, since it overrides a method defined</font>
<font color="black">  59. in UDPServer! Setting the various member variables also changes</font>
<font color="black">  60. the behavior of the underlying server mechanism.</font>
<font color="black">  61. </font>
<font color="black">  62. To implement a service, you must derive a class from</font>
<font color="black">  63. BaseRequestHandler and redefine its handle() method.  You can then run</font>
<font color="black">  64. various versions of the service by combining one of the server classes</font>
<font color="black">  65. with your request handler class.</font>
<font color="black">  66. </font>
<font color="black">  67. The request handler class must be different for datagram or stream</font>
<font color="black">  68. services.  This can be hidden by using the request handler</font>
<font color="black">  69. subclasses StreamRequestHandler or DatagramRequestHandler.</font>
<font color="black">  70. </font>
<font color="black">  71. Of course, you still have to use your head!</font>
<font color="black">  72. </font>
<font color="black">  73. For instance, it makes no sense to use a forking server if the service</font>
<font color="black">  74. contains state in memory that can be modified by requests (since the</font>
<font color="black">  75. modifications in the child process would never reach the initial state</font>
<font color="black">  76. kept in the parent process and passed to each child).  In this case,</font>
<font color="black">  77. you can use a threading server, but you will probably have to use</font>
<font color="black">  78. locks to avoid two requests that come in nearly simultaneous to apply</font>
<font color="black">  79. conflicting changes to the server state.</font>
<font color="black">  80. </font>
<font color="black">  81. On the other hand, if you are building e.g. an HTTP server, where all</font>
<font color="black">  82. data is stored externally (e.g. in the file system), a synchronous</font>
<font color="black">  83. class will essentially render the service &quot;deaf&quot; while one request is</font>
<font color="black">  84. being handled -- which may be for a very long time if a client is slow</font>
<font color="black">  85. to read all the data it has requested.  Here a threading or forking</font>
<font color="black">  86. server is appropriate.</font>
<font color="black">  87. </font>
<font color="black">  88. In some cases, it may be appropriate to process part of a request</font>
<font color="black">  89. synchronously, but to finish processing in a forked child depending on</font>
<font color="black">  90. the request data.  This can be implemented by using a synchronous</font>
<font color="black">  91. server and doing an explicit fork in the request handler class</font>
<font color="black">  92. handle() method.</font>
<font color="black">  93. </font>
<font color="black">  94. Another approach to handling multiple simultaneous requests in an</font>
<font color="black">  95. environment that supports neither threads nor fork (or where these are</font>
<font color="black">  96. too expensive or inappropriate for the service) is to maintain an</font>
<font color="black">  97. explicit table of partially finished requests and to use select() to</font>
<font color="black">  98. decide which request to work on next (or whether to handle a new</font>
<font color="black">  99. incoming request).  This is particularly important for stream services</font>
<font color="black"> 100. where each client can potentially be connected for a long time (if</font>
<font color="black"> 101. threads or subprocesses cannot be used).</font>
<font color="black"> 102. </font>
<font color="black"> 103. Future work:</font>
<font color="black"> 104. - Standard classes for Sun RPC (which uses either UDP or TCP)</font>
<font color="black"> 105. - Standard mix-in classes to implement various authentication</font>
<font color="black"> 106.   and encryption schemes</font>
<font color="black"> 107. - Standard framework for select-based multiplexing</font>
<font color="black"> 108. </font>
<font color="black"> 109. XXX Open problems:</font>
<font color="black"> 110. - What to do with out-of-band data?</font>
<font color="black"> 111. </font>
<font color="black"> 112. BaseServer:</font>
<font color="black"> 113. - split generic &quot;request&quot; functionality out into BaseServer class.</font>
<font color="black"> 114.   Copyright (C) 2000  Luke Kenneth Casson Leighton &lt;lkcl@samba.org&gt;</font>
<font color="black"> 115. </font>
<font color="black"> 116.   example: read entries from a SQL database (requires overriding</font>
<font color="black"> 117.   get_request() to return a table entry from the database).</font>
<font color="black"> 118.   entry is processed by a RequestHandlerClass.</font>
<font color="black"> 119. </font>
<font color="green"> 120. &quot;&quot;&quot;</font>
<font color="black"> 121. </font>
<font color="black"> 122. # Author of the BaseServer patch: Luke Kenneth Casson Leighton</font>
<font color="black"> 123. </font>
<font color="black"> 124. # XXX Warning!</font>
<font color="black"> 125. # There is a test suite for this module, but it cannot be run by the</font>
<font color="black"> 126. # standard regression test.</font>
<font color="black"> 127. # To run it manually, run Lib/test/test_socketserver.py.</font>
<font color="black"> 128. </font>
<font color="green"> 129. __version__ = &quot;0.4&quot;</font>
<font color="black"> 130. </font>
<font color="black"> 131. </font>
<font color="green"> 132. import socket</font>
<font color="green"> 133. import select</font>
<font color="green"> 134. import sys</font>
<font color="green"> 135. import os</font>
<font color="green"> 136. import errno</font>
<font color="green"> 137. try:</font>
<font color="green"> 138.     import threading</font>
<font color="red"> 139. except ImportError:</font>
<font color="red"> 140.     import dummy_threading as threading</font>
<font color="black"> 141. </font>
<font color="green"> 142. __all__ = [&quot;TCPServer&quot;,&quot;UDPServer&quot;,&quot;ForkingUDPServer&quot;,&quot;ForkingTCPServer&quot;,</font>
<font color="green"> 143.            &quot;ThreadingUDPServer&quot;,&quot;ThreadingTCPServer&quot;,&quot;BaseRequestHandler&quot;,</font>
<font color="green"> 144.            &quot;StreamRequestHandler&quot;,&quot;DatagramRequestHandler&quot;,</font>
<font color="green"> 145.            &quot;ThreadingMixIn&quot;, &quot;ForkingMixIn&quot;]</font>
<font color="green"> 146. if hasattr(socket, &quot;AF_UNIX&quot;):</font>
<font color="green"> 147.     __all__.extend([&quot;UnixStreamServer&quot;,&quot;UnixDatagramServer&quot;,</font>
<font color="green"> 148.                     &quot;ThreadingUnixStreamServer&quot;,</font>
<font color="green"> 149.                     &quot;ThreadingUnixDatagramServer&quot;])</font>
<font color="black"> 150. </font>
<font color="green"> 151. def _eintr_retry(func, *args):</font>
<font color="black"> 152.     &quot;&quot;&quot;restart a system call interrupted by EINTR&quot;&quot;&quot;</font>
<font color="red"> 153.     while True:</font>
<font color="red"> 154.         try:</font>
<font color="red"> 155.             return func(*args)</font>
<font color="red"> 156.         except (OSError, select.error) as e:</font>
<font color="red"> 157.             if e.args[0] != errno.EINTR:</font>
<font color="red"> 158.                 raise</font>
<font color="black"> 159. </font>
<font color="green"> 160. class BaseServer:</font>
<font color="black"> 161. </font>
<font color="black"> 162.     &quot;&quot;&quot;Base class for server classes.</font>
<font color="black"> 163. </font>
<font color="black"> 164.     Methods for the caller:</font>
<font color="black"> 165. </font>
<font color="black"> 166.     - __init__(server_address, RequestHandlerClass)</font>
<font color="black"> 167.     - serve_forever(poll_interval=0.5)</font>
<font color="black"> 168.     - shutdown()</font>
<font color="black"> 169.     - handle_request()  # if you do not use serve_forever()</font>
<font color="black"> 170.     - fileno() -&gt; int   # for select()</font>
<font color="black"> 171. </font>
<font color="black"> 172.     Methods that may be overridden:</font>
<font color="black"> 173. </font>
<font color="black"> 174.     - server_bind()</font>
<font color="black"> 175.     - server_activate()</font>
<font color="black"> 176.     - get_request() -&gt; request, client_address</font>
<font color="black"> 177.     - handle_timeout()</font>
<font color="black"> 178.     - verify_request(request, client_address)</font>
<font color="black"> 179.     - server_close()</font>
<font color="black"> 180.     - process_request(request, client_address)</font>
<font color="black"> 181.     - shutdown_request(request)</font>
<font color="black"> 182.     - close_request(request)</font>
<font color="black"> 183.     - handle_error()</font>
<font color="black"> 184. </font>
<font color="black"> 185.     Methods for derived classes:</font>
<font color="black"> 186. </font>
<font color="black"> 187.     - finish_request(request, client_address)</font>
<font color="black"> 188. </font>
<font color="black"> 189.     Class variables that may be overridden by derived classes or</font>
<font color="black"> 190.     instances:</font>
<font color="black"> 191. </font>
<font color="black"> 192.     - timeout</font>
<font color="black"> 193.     - address_family</font>
<font color="black"> 194.     - socket_type</font>
<font color="black"> 195.     - allow_reuse_address</font>
<font color="black"> 196. </font>
<font color="black"> 197.     Instance variables:</font>
<font color="black"> 198. </font>
<font color="black"> 199.     - RequestHandlerClass</font>
<font color="black"> 200.     - socket</font>
<font color="black"> 201. </font>
<font color="green"> 202.     &quot;&quot;&quot;</font>
<font color="black"> 203. </font>
<font color="green"> 204.     timeout = None</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def __init__(self, server_address, RequestHandlerClass):</font>
<font color="black"> 207.         &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</font>
<font color="red"> 208.         self.server_address = server_address</font>
<font color="red"> 209.         self.RequestHandlerClass = RequestHandlerClass</font>
<font color="red"> 210.         self.__is_shut_down = threading.Event()</font>
<font color="red"> 211.         self.__shutdown_request = False</font>
<font color="black"> 212. </font>
<font color="green"> 213.     def server_activate(self):</font>
<font color="black"> 214.         &quot;&quot;&quot;Called by constructor to activate the server.</font>
<font color="black"> 215. </font>
<font color="black"> 216.         May be overridden.</font>
<font color="black"> 217. </font>
<font color="black"> 218.         &quot;&quot;&quot;</font>
<font color="red"> 219.         pass</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def serve_forever(self, poll_interval=0.5):</font>
<font color="black"> 222.         &quot;&quot;&quot;Handle one request at a time until shutdown.</font>
<font color="black"> 223. </font>
<font color="black"> 224.         Polls for shutdown every poll_interval seconds. Ignores</font>
<font color="black"> 225.         self.timeout. If you need to do periodic tasks, do them in</font>
<font color="black"> 226.         another thread.</font>
<font color="black"> 227.         &quot;&quot;&quot;</font>
<font color="red"> 228.         self.__is_shut_down.clear()</font>
<font color="red"> 229.         try:</font>
<font color="red"> 230.             while not self.__shutdown_request:</font>
<font color="black"> 231.                 # XXX: Consider using another file descriptor or</font>
<font color="black"> 232.                 # connecting to the socket to wake this up instead of</font>
<font color="black"> 233.                 # polling. Polling reduces our responsiveness to a</font>
<font color="black"> 234.                 # shutdown request and wastes cpu at all other times.</font>
<font color="red"> 235.                 r, w, e = _eintr_retry(select.select, [self], [], [],</font>
<font color="red"> 236.                                        poll_interval)</font>
<font color="red"> 237.                 if self in r:</font>
<font color="red"> 238.                     self._handle_request_noblock()</font>
<font color="black"> 239.         finally:</font>
<font color="red"> 240.             self.__shutdown_request = False</font>
<font color="red"> 241.             self.__is_shut_down.set()</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def shutdown(self):</font>
<font color="black"> 244.         &quot;&quot;&quot;Stops the serve_forever loop.</font>
<font color="black"> 245. </font>
<font color="black"> 246.         Blocks until the loop has finished. This must be called while</font>
<font color="black"> 247.         serve_forever() is running in another thread, or it will</font>
<font color="black"> 248.         deadlock.</font>
<font color="black"> 249.         &quot;&quot;&quot;</font>
<font color="red"> 250.         self.__shutdown_request = True</font>
<font color="red"> 251.         self.__is_shut_down.wait()</font>
<font color="black"> 252. </font>
<font color="black"> 253.     # The distinction between handling, getting, processing and</font>
<font color="black"> 254.     # finishing a request is fairly arbitrary.  Remember:</font>
<font color="black"> 255.     #</font>
<font color="black"> 256.     # - handle_request() is the top-level call.  It calls</font>
<font color="black"> 257.     #   select, get_request(), verify_request() and process_request()</font>
<font color="black"> 258.     # - get_request() is different for stream or datagram sockets</font>
<font color="black"> 259.     # - process_request() is the place that may fork a new process</font>
<font color="black"> 260.     #   or create a new thread to finish the request</font>
<font color="black"> 261.     # - finish_request() instantiates the request handler class;</font>
<font color="black"> 262.     #   this constructor will handle the request all by itself</font>
<font color="black"> 263. </font>
<font color="green"> 264.     def handle_request(self):</font>
<font color="black"> 265.         &quot;&quot;&quot;Handle one request, possibly blocking.</font>
<font color="black"> 266. </font>
<font color="black"> 267.         Respects self.timeout.</font>
<font color="black"> 268.         &quot;&quot;&quot;</font>
<font color="black"> 269.         # Support people who used socket.settimeout() to escape</font>
<font color="black"> 270.         # handle_request before self.timeout was available.</font>
<font color="red"> 271.         timeout = self.socket.gettimeout()</font>
<font color="red"> 272.         if timeout is None:</font>
<font color="red"> 273.             timeout = self.timeout</font>
<font color="red"> 274.         elif self.timeout is not None:</font>
<font color="red"> 275.             timeout = min(timeout, self.timeout)</font>
<font color="red"> 276.         fd_sets = _eintr_retry(select.select, [self], [], [], timeout)</font>
<font color="red"> 277.         if not fd_sets[0]:</font>
<font color="red"> 278.             self.handle_timeout()</font>
<font color="red"> 279.             return</font>
<font color="red"> 280.         self._handle_request_noblock()</font>
<font color="black"> 281. </font>
<font color="green"> 282.     def _handle_request_noblock(self):</font>
<font color="black"> 283.         &quot;&quot;&quot;Handle one request, without blocking.</font>
<font color="black"> 284. </font>
<font color="black"> 285.         I assume that select.select has returned that the socket is</font>
<font color="black"> 286.         readable before this function was called, so there should be</font>
<font color="black"> 287.         no risk of blocking in get_request().</font>
<font color="black"> 288.         &quot;&quot;&quot;</font>
<font color="red"> 289.         try:</font>
<font color="red"> 290.             request, client_address = self.get_request()</font>
<font color="red"> 291.         except socket.error:</font>
<font color="red"> 292.             return</font>
<font color="red"> 293.         if self.verify_request(request, client_address):</font>
<font color="red"> 294.             try:</font>
<font color="red"> 295.                 self.process_request(request, client_address)</font>
<font color="red"> 296.             except:</font>
<font color="red"> 297.                 self.handle_error(request, client_address)</font>
<font color="red"> 298.                 self.shutdown_request(request)</font>
<font color="black"> 299. </font>
<font color="green"> 300.     def handle_timeout(self):</font>
<font color="black"> 301.         &quot;&quot;&quot;Called if no new request arrives within self.timeout.</font>
<font color="black"> 302. </font>
<font color="black"> 303.         Overridden by ForkingMixIn.</font>
<font color="black"> 304.         &quot;&quot;&quot;</font>
<font color="red"> 305.         pass</font>
<font color="black"> 306. </font>
<font color="green"> 307.     def verify_request(self, request, client_address):</font>
<font color="black"> 308.         &quot;&quot;&quot;Verify the request.  May be overridden.</font>
<font color="black"> 309. </font>
<font color="black"> 310.         Return True if we should proceed with this request.</font>
<font color="black"> 311. </font>
<font color="black"> 312.         &quot;&quot;&quot;</font>
<font color="red"> 313.         return True</font>
<font color="black"> 314. </font>
<font color="green"> 315.     def process_request(self, request, client_address):</font>
<font color="black"> 316.         &quot;&quot;&quot;Call finish_request.</font>
<font color="black"> 317. </font>
<font color="black"> 318.         Overridden by ForkingMixIn and ThreadingMixIn.</font>
<font color="black"> 319. </font>
<font color="black"> 320.         &quot;&quot;&quot;</font>
<font color="red"> 321.         self.finish_request(request, client_address)</font>
<font color="red"> 322.         self.shutdown_request(request)</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def server_close(self):</font>
<font color="black"> 325.         &quot;&quot;&quot;Called to clean-up the server.</font>
<font color="black"> 326. </font>
<font color="black"> 327.         May be overridden.</font>
<font color="black"> 328. </font>
<font color="black"> 329.         &quot;&quot;&quot;</font>
<font color="red"> 330.         pass</font>
<font color="black"> 331. </font>
<font color="green"> 332.     def finish_request(self, request, client_address):</font>
<font color="black"> 333.         &quot;&quot;&quot;Finish one request by instantiating RequestHandlerClass.&quot;&quot;&quot;</font>
<font color="red"> 334.         self.RequestHandlerClass(request, client_address, self)</font>
<font color="black"> 335. </font>
<font color="green"> 336.     def shutdown_request(self, request):</font>
<font color="black"> 337.         &quot;&quot;&quot;Called to shutdown and close an individual request.&quot;&quot;&quot;</font>
<font color="red"> 338.         self.close_request(request)</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def close_request(self, request):</font>
<font color="black"> 341.         &quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</font>
<font color="red"> 342.         pass</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def handle_error(self, request, client_address):</font>
<font color="black"> 345.         &quot;&quot;&quot;Handle an error gracefully.  May be overridden.</font>
<font color="black"> 346. </font>
<font color="black"> 347.         The default is to print a traceback and continue.</font>
<font color="black"> 348. </font>
<font color="black"> 349.         &quot;&quot;&quot;</font>
<font color="red"> 350.         print '-'*40</font>
<font color="red"> 351.         print 'Exception happened during processing of request from',</font>
<font color="red"> 352.         print client_address</font>
<font color="red"> 353.         import traceback</font>
<font color="red"> 354.         traceback.print_exc() # XXX But this goes to stderr!</font>
<font color="red"> 355.         print '-'*40</font>
<font color="black"> 356. </font>
<font color="black"> 357. </font>
<font color="green"> 358. class TCPServer(BaseServer):</font>
<font color="black"> 359. </font>
<font color="black"> 360.     &quot;&quot;&quot;Base class for various socket-based server classes.</font>
<font color="black"> 361. </font>
<font color="black"> 362.     Defaults to synchronous IP stream (i.e., TCP).</font>
<font color="black"> 363. </font>
<font color="black"> 364.     Methods for the caller:</font>
<font color="black"> 365. </font>
<font color="black"> 366.     - __init__(server_address, RequestHandlerClass, bind_and_activate=True)</font>
<font color="black"> 367.     - serve_forever(poll_interval=0.5)</font>
<font color="black"> 368.     - shutdown()</font>
<font color="black"> 369.     - handle_request()  # if you don't use serve_forever()</font>
<font color="black"> 370.     - fileno() -&gt; int   # for select()</font>
<font color="black"> 371. </font>
<font color="black"> 372.     Methods that may be overridden:</font>
<font color="black"> 373. </font>
<font color="black"> 374.     - server_bind()</font>
<font color="black"> 375.     - server_activate()</font>
<font color="black"> 376.     - get_request() -&gt; request, client_address</font>
<font color="black"> 377.     - handle_timeout()</font>
<font color="black"> 378.     - verify_request(request, client_address)</font>
<font color="black"> 379.     - process_request(request, client_address)</font>
<font color="black"> 380.     - shutdown_request(request)</font>
<font color="black"> 381.     - close_request(request)</font>
<font color="black"> 382.     - handle_error()</font>
<font color="black"> 383. </font>
<font color="black"> 384.     Methods for derived classes:</font>
<font color="black"> 385. </font>
<font color="black"> 386.     - finish_request(request, client_address)</font>
<font color="black"> 387. </font>
<font color="black"> 388.     Class variables that may be overridden by derived classes or</font>
<font color="black"> 389.     instances:</font>
<font color="black"> 390. </font>
<font color="black"> 391.     - timeout</font>
<font color="black"> 392.     - address_family</font>
<font color="black"> 393.     - socket_type</font>
<font color="black"> 394.     - request_queue_size (only for stream sockets)</font>
<font color="black"> 395.     - allow_reuse_address</font>
<font color="black"> 396. </font>
<font color="black"> 397.     Instance variables:</font>
<font color="black"> 398. </font>
<font color="black"> 399.     - server_address</font>
<font color="black"> 400.     - RequestHandlerClass</font>
<font color="black"> 401.     - socket</font>
<font color="black"> 402. </font>
<font color="green"> 403.     &quot;&quot;&quot;</font>
<font color="black"> 404. </font>
<font color="green"> 405.     address_family = socket.AF_INET</font>
<font color="black"> 406. </font>
<font color="green"> 407.     socket_type = socket.SOCK_STREAM</font>
<font color="black"> 408. </font>
<font color="green"> 409.     request_queue_size = 5</font>
<font color="black"> 410. </font>
<font color="green"> 411.     allow_reuse_address = False</font>
<font color="black"> 412. </font>
<font color="green"> 413.     def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):</font>
<font color="black"> 414.         &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</font>
<font color="red"> 415.         BaseServer.__init__(self, server_address, RequestHandlerClass)</font>
<font color="red"> 416.         self.socket = socket.socket(self.address_family,</font>
<font color="red"> 417.                                     self.socket_type)</font>
<font color="red"> 418.         if bind_and_activate:</font>
<font color="red"> 419.             self.server_bind()</font>
<font color="red"> 420.             self.server_activate()</font>
<font color="black"> 421. </font>
<font color="green"> 422.     def server_bind(self):</font>
<font color="black"> 423.         &quot;&quot;&quot;Called by constructor to bind the socket.</font>
<font color="black"> 424. </font>
<font color="black"> 425.         May be overridden.</font>
<font color="black"> 426. </font>
<font color="black"> 427.         &quot;&quot;&quot;</font>
<font color="red"> 428.         if self.allow_reuse_address:</font>
<font color="red"> 429.             self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</font>
<font color="red"> 430.         self.socket.bind(self.server_address)</font>
<font color="red"> 431.         self.server_address = self.socket.getsockname()</font>
<font color="black"> 432. </font>
<font color="green"> 433.     def server_activate(self):</font>
<font color="black"> 434.         &quot;&quot;&quot;Called by constructor to activate the server.</font>
<font color="black"> 435. </font>
<font color="black"> 436.         May be overridden.</font>
<font color="black"> 437. </font>
<font color="black"> 438.         &quot;&quot;&quot;</font>
<font color="red"> 439.         self.socket.listen(self.request_queue_size)</font>
<font color="black"> 440. </font>
<font color="green"> 441.     def server_close(self):</font>
<font color="black"> 442.         &quot;&quot;&quot;Called to clean-up the server.</font>
<font color="black"> 443. </font>
<font color="black"> 444.         May be overridden.</font>
<font color="black"> 445. </font>
<font color="black"> 446.         &quot;&quot;&quot;</font>
<font color="red"> 447.         self.socket.close()</font>
<font color="black"> 448. </font>
<font color="green"> 449.     def fileno(self):</font>
<font color="black"> 450.         &quot;&quot;&quot;Return socket file number.</font>
<font color="black"> 451. </font>
<font color="black"> 452.         Interface required by select().</font>
<font color="black"> 453. </font>
<font color="black"> 454.         &quot;&quot;&quot;</font>
<font color="red"> 455.         return self.socket.fileno()</font>
<font color="black"> 456. </font>
<font color="green"> 457.     def get_request(self):</font>
<font color="black"> 458.         &quot;&quot;&quot;Get the request and client address from the socket.</font>
<font color="black"> 459. </font>
<font color="black"> 460.         May be overridden.</font>
<font color="black"> 461. </font>
<font color="black"> 462.         &quot;&quot;&quot;</font>
<font color="red"> 463.         return self.socket.accept()</font>
<font color="black"> 464. </font>
<font color="green"> 465.     def shutdown_request(self, request):</font>
<font color="black"> 466.         &quot;&quot;&quot;Called to shutdown and close an individual request.&quot;&quot;&quot;</font>
<font color="red"> 467.         try:</font>
<font color="black"> 468.             #explicitly shutdown.  socket.close() merely releases</font>
<font color="black"> 469.             #the socket and waits for GC to perform the actual close.</font>
<font color="red"> 470.             request.shutdown(socket.SHUT_WR)</font>
<font color="red"> 471.         except socket.error:</font>
<font color="red"> 472.             pass #some platforms may raise ENOTCONN here</font>
<font color="red"> 473.         self.close_request(request)</font>
<font color="black"> 474. </font>
<font color="green"> 475.     def close_request(self, request):</font>
<font color="black"> 476.         &quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</font>
<font color="red"> 477.         request.close()</font>
<font color="black"> 478. </font>
<font color="black"> 479. </font>
<font color="green"> 480. class UDPServer(TCPServer):</font>
<font color="black"> 481. </font>
<font color="green"> 482.     &quot;&quot;&quot;UDP server class.&quot;&quot;&quot;</font>
<font color="black"> 483. </font>
<font color="green"> 484.     allow_reuse_address = False</font>
<font color="black"> 485. </font>
<font color="green"> 486.     socket_type = socket.SOCK_DGRAM</font>
<font color="black"> 487. </font>
<font color="green"> 488.     max_packet_size = 8192</font>
<font color="black"> 489. </font>
<font color="green"> 490.     def get_request(self):</font>
<font color="red"> 491.         data, client_addr = self.socket.recvfrom(self.max_packet_size)</font>
<font color="red"> 492.         return (data, self.socket), client_addr</font>
<font color="black"> 493. </font>
<font color="green"> 494.     def server_activate(self):</font>
<font color="black"> 495.         # No need to call listen() for UDP.</font>
<font color="red"> 496.         pass</font>
<font color="black"> 497. </font>
<font color="green"> 498.     def shutdown_request(self, request):</font>
<font color="black"> 499.         # No need to shutdown anything.</font>
<font color="red"> 500.         self.close_request(request)</font>
<font color="black"> 501. </font>
<font color="green"> 502.     def close_request(self, request):</font>
<font color="black"> 503.         # No need to close anything.</font>
<font color="red"> 504.         pass</font>
<font color="black"> 505. </font>
<font color="green"> 506. class ForkingMixIn:</font>
<font color="black"> 507. </font>
<font color="green"> 508.     &quot;&quot;&quot;Mix-in class to handle each request in a new process.&quot;&quot;&quot;</font>
<font color="black"> 509. </font>
<font color="green"> 510.     timeout = 300</font>
<font color="green"> 511.     active_children = None</font>
<font color="green"> 512.     max_children = 40</font>
<font color="black"> 513. </font>
<font color="green"> 514.     def collect_children(self):</font>
<font color="black"> 515.         &quot;&quot;&quot;Internal routine to wait for children that have exited.&quot;&quot;&quot;</font>
<font color="red"> 516.         if self.active_children is None: return</font>
<font color="red"> 517.         while len(self.active_children) &gt;= self.max_children:</font>
<font color="black"> 518.             # XXX: This will wait for any child process, not just ones</font>
<font color="black"> 519.             # spawned by this library. This could confuse other</font>
<font color="black"> 520.             # libraries that expect to be able to wait for their own</font>
<font color="black"> 521.             # children.</font>
<font color="red"> 522.             try:</font>
<font color="red"> 523.                 pid, status = os.waitpid(0, 0)</font>
<font color="red"> 524.             except os.error:</font>
<font color="red"> 525.                 pid = None</font>
<font color="red"> 526.             if pid not in self.active_children: continue</font>
<font color="red"> 527.             self.active_children.remove(pid)</font>
<font color="black"> 528. </font>
<font color="black"> 529.         # XXX: This loop runs more system calls than it ought</font>
<font color="black"> 530.         # to. There should be a way to put the active_children into a</font>
<font color="black"> 531.         # process group and then use os.waitpid(-pgid) to wait for any</font>
<font color="black"> 532.         # of that set, but I couldn't find a way to allocate pgids</font>
<font color="black"> 533.         # that couldn't collide.</font>
<font color="red"> 534.         for child in self.active_children:</font>
<font color="red"> 535.             try:</font>
<font color="red"> 536.                 pid, status = os.waitpid(child, os.WNOHANG)</font>
<font color="red"> 537.             except os.error:</font>
<font color="red"> 538.                 pid = None</font>
<font color="red"> 539.             if not pid: continue</font>
<font color="red"> 540.             try:</font>
<font color="red"> 541.                 self.active_children.remove(pid)</font>
<font color="red"> 542.             except ValueError, e:</font>
<font color="red"> 543.                 raise ValueError('%s. x=%d and list=%r' % (e.message, pid,</font>
<font color="red"> 544.                                                            self.active_children))</font>
<font color="black"> 545. </font>
<font color="green"> 546.     def handle_timeout(self):</font>
<font color="black"> 547.         &quot;&quot;&quot;Wait for zombies after self.timeout seconds of inactivity.</font>
<font color="black"> 548. </font>
<font color="black"> 549.         May be extended, do not override.</font>
<font color="black"> 550.         &quot;&quot;&quot;</font>
<font color="red"> 551.         self.collect_children()</font>
<font color="black"> 552. </font>
<font color="green"> 553.     def process_request(self, request, client_address):</font>
<font color="black"> 554.         &quot;&quot;&quot;Fork a new subprocess to process the request.&quot;&quot;&quot;</font>
<font color="red"> 555.         self.collect_children()</font>
<font color="red"> 556.         pid = os.fork()</font>
<font color="red"> 557.         if pid:</font>
<font color="black"> 558.             # Parent process</font>
<font color="red"> 559.             if self.active_children is None:</font>
<font color="red"> 560.                 self.active_children = []</font>
<font color="red"> 561.             self.active_children.append(pid)</font>
<font color="red"> 562.             self.close_request(request) #close handle in parent process</font>
<font color="red"> 563.             return</font>
<font color="black"> 564.         else:</font>
<font color="black"> 565.             # Child process.</font>
<font color="black"> 566.             # This must never return, hence os._exit()!</font>
<font color="red"> 567.             try:</font>
<font color="red"> 568.                 self.finish_request(request, client_address)</font>
<font color="red"> 569.                 self.shutdown_request(request)</font>
<font color="red"> 570.                 os._exit(0)</font>
<font color="red"> 571.             except:</font>
<font color="red"> 572.                 try:</font>
<font color="red"> 573.                     self.handle_error(request, client_address)</font>
<font color="red"> 574.                     self.shutdown_request(request)</font>
<font color="black"> 575.                 finally:</font>
<font color="red"> 576.                     os._exit(1)</font>
<font color="black"> 577. </font>
<font color="black"> 578. </font>
<font color="green"> 579. class ThreadingMixIn:</font>
<font color="green"> 580.     &quot;&quot;&quot;Mix-in class to handle each request in a new thread.&quot;&quot;&quot;</font>
<font color="black"> 581. </font>
<font color="black"> 582.     # Decides how threads will act upon termination of the</font>
<font color="black"> 583.     # main process</font>
<font color="green"> 584.     daemon_threads = False</font>
<font color="black"> 585. </font>
<font color="green"> 586.     def process_request_thread(self, request, client_address):</font>
<font color="black"> 587.         &quot;&quot;&quot;Same as in BaseServer but as a thread.</font>
<font color="black"> 588. </font>
<font color="black"> 589.         In addition, exception handling is done here.</font>
<font color="black"> 590. </font>
<font color="black"> 591.         &quot;&quot;&quot;</font>
<font color="red"> 592.         try:</font>
<font color="red"> 593.             self.finish_request(request, client_address)</font>
<font color="red"> 594.             self.shutdown_request(request)</font>
<font color="red"> 595.         except:</font>
<font color="red"> 596.             self.handle_error(request, client_address)</font>
<font color="red"> 597.             self.shutdown_request(request)</font>
<font color="black"> 598. </font>
<font color="green"> 599.     def process_request(self, request, client_address):</font>
<font color="black"> 600.         &quot;&quot;&quot;Start a new thread to process the request.&quot;&quot;&quot;</font>
<font color="red"> 601.         t = threading.Thread(target = self.process_request_thread,</font>
<font color="red"> 602.                              args = (request, client_address))</font>
<font color="red"> 603.         t.daemon = self.daemon_threads</font>
<font color="red"> 604.         t.start()</font>
<font color="black"> 605. </font>
<font color="black"> 606. </font>
<font color="green"> 607. class ForkingUDPServer(ForkingMixIn, UDPServer): pass</font>
<font color="green"> 608. class ForkingTCPServer(ForkingMixIn, TCPServer): pass</font>
<font color="black"> 609. </font>
<font color="green"> 610. class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass</font>
<font color="green"> 611. class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass</font>
<font color="black"> 612. </font>
<font color="green"> 613. if hasattr(socket, 'AF_UNIX'):</font>
<font color="black"> 614. </font>
<font color="green"> 615.     class UnixStreamServer(TCPServer):</font>
<font color="green"> 616.         address_family = socket.AF_UNIX</font>
<font color="black"> 617. </font>
<font color="green"> 618.     class UnixDatagramServer(UDPServer):</font>
<font color="green"> 619.         address_family = socket.AF_UNIX</font>
<font color="black"> 620. </font>
<font color="green"> 621.     class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer): pass</font>
<font color="black"> 622. </font>
<font color="green"> 623.     class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer): pass</font>
<font color="black"> 624. </font>
<font color="green"> 625. class BaseRequestHandler:</font>
<font color="black"> 626. </font>
<font color="black"> 627.     &quot;&quot;&quot;Base class for request handler classes.</font>
<font color="black"> 628. </font>
<font color="black"> 629.     This class is instantiated for each request to be handled.  The</font>
<font color="black"> 630.     constructor sets the instance variables request, client_address</font>
<font color="black"> 631.     and server, and then calls the handle() method.  To implement a</font>
<font color="black"> 632.     specific service, all you need to do is to derive a class which</font>
<font color="black"> 633.     defines a handle() method.</font>
<font color="black"> 634. </font>
<font color="black"> 635.     The handle() method can find the request as self.request, the</font>
<font color="black"> 636.     client address as self.client_address, and the server (in case it</font>
<font color="black"> 637.     needs access to per-server information) as self.server.  Since a</font>
<font color="black"> 638.     separate instance is created for each request, the handle() method</font>
<font color="black"> 639.     can define arbitrary other instance variariables.</font>
<font color="black"> 640. </font>
<font color="green"> 641.     &quot;&quot;&quot;</font>
<font color="black"> 642. </font>
<font color="green"> 643.     def __init__(self, request, client_address, server):</font>
<font color="red"> 644.         self.request = request</font>
<font color="red"> 645.         self.client_address = client_address</font>
<font color="red"> 646.         self.server = server</font>
<font color="red"> 647.         self.setup()</font>
<font color="red"> 648.         try:</font>
<font color="red"> 649.             self.handle()</font>
<font color="black"> 650.         finally:</font>
<font color="red"> 651.             self.finish()</font>
<font color="black"> 652. </font>
<font color="green"> 653.     def setup(self):</font>
<font color="red"> 654.         pass</font>
<font color="black"> 655. </font>
<font color="green"> 656.     def handle(self):</font>
<font color="red"> 657.         pass</font>
<font color="black"> 658. </font>
<font color="green"> 659.     def finish(self):</font>
<font color="red"> 660.         pass</font>
<font color="black"> 661. </font>
<font color="black"> 662. </font>
<font color="black"> 663. # The following two classes make it possible to use the same service</font>
<font color="black"> 664. # class for stream or datagram servers.</font>
<font color="black"> 665. # Each class sets up these instance variables:</font>
<font color="black"> 666. # - rfile: a file object from which receives the request is read</font>
<font color="black"> 667. # - wfile: a file object to which the reply is written</font>
<font color="black"> 668. # When the handle() method returns, wfile is flushed properly</font>
<font color="black"> 669. </font>
<font color="black"> 670. </font>
<font color="green"> 671. class StreamRequestHandler(BaseRequestHandler):</font>
<font color="black"> 672. </font>
<font color="green"> 673.     &quot;&quot;&quot;Define self.rfile and self.wfile for stream sockets.&quot;&quot;&quot;</font>
<font color="black"> 674. </font>
<font color="black"> 675.     # Default buffer sizes for rfile, wfile.</font>
<font color="black"> 676.     # We default rfile to buffered because otherwise it could be</font>
<font color="black"> 677.     # really slow for large data (a getc() call per byte); we make</font>
<font color="black"> 678.     # wfile unbuffered because (a) often after a write() we want to</font>
<font color="black"> 679.     # read and we need to flush the line; (b) big writes to unbuffered</font>
<font color="black"> 680.     # files are typically optimized by stdio even when big reads</font>
<font color="black"> 681.     # aren't.</font>
<font color="green"> 682.     rbufsize = -1</font>
<font color="green"> 683.     wbufsize = 0</font>
<font color="black"> 684. </font>
<font color="black"> 685.     # A timeout to apply to the request socket, if not None.</font>
<font color="green"> 686.     timeout = None</font>
<font color="black"> 687. </font>
<font color="black"> 688.     # Disable nagle algorithm for this socket, if True.</font>
<font color="black"> 689.     # Use only when wbufsize != 0, to avoid small packets.</font>
<font color="green"> 690.     disable_nagle_algorithm = False</font>
<font color="black"> 691. </font>
<font color="green"> 692.     def setup(self):</font>
<font color="red"> 693.         self.connection = self.request</font>
<font color="red"> 694.         if self.timeout is not None:</font>
<font color="red"> 695.             self.connection.settimeout(self.timeout)</font>
<font color="red"> 696.         if self.disable_nagle_algorithm:</font>
<font color="red"> 697.             self.connection.setsockopt(socket.IPPROTO_TCP,</font>
<font color="red"> 698.                                        socket.TCP_NODELAY, True)</font>
<font color="red"> 699.         self.rfile = self.connection.makefile('rb', self.rbufsize)</font>
<font color="red"> 700.         self.wfile = self.connection.makefile('wb', self.wbufsize)</font>
<font color="black"> 701. </font>
<font color="green"> 702.     def finish(self):</font>
<font color="red"> 703.         if not self.wfile.closed:</font>
<font color="red"> 704.             try:</font>
<font color="red"> 705.                 self.wfile.flush()</font>
<font color="red"> 706.             except socket.error:</font>
<font color="black"> 707.                 # An final socket error may have occurred here, such as</font>
<font color="black"> 708.                 # the local error ECONNABORTED.</font>
<font color="red"> 709.                 pass</font>
<font color="red"> 710.         self.wfile.close()</font>
<font color="red"> 711.         self.rfile.close()</font>
<font color="black"> 712. </font>
<font color="black"> 713. </font>
<font color="green"> 714. class DatagramRequestHandler(BaseRequestHandler):</font>
<font color="black"> 715. </font>
<font color="black"> 716.     # XXX Regrettably, I cannot get this working on Linux;</font>
<font color="black"> 717.     # s.recvfrom() doesn't return a meaningful client address.</font>
<font color="black"> 718. </font>
<font color="green"> 719.     &quot;&quot;&quot;Define self.rfile and self.wfile for datagram sockets.&quot;&quot;&quot;</font>
<font color="black"> 720. </font>
<font color="green"> 721.     def setup(self):</font>
<font color="red"> 722.         try:</font>
<font color="red"> 723.             from cStringIO import StringIO</font>
<font color="red"> 724.         except ImportError:</font>
<font color="red"> 725.             from StringIO import StringIO</font>
<font color="red"> 726.         self.packet, self.socket = self.request</font>
<font color="red"> 727.         self.rfile = StringIO(self.packet)</font>
<font color="red"> 728.         self.wfile = StringIO()</font>
<font color="black"> 729. </font>
<font color="green"> 730.     def finish(self):</font>
<font color="red"> 731.         self.socket.sendto(self.wfile.getvalue(), self.client_address)</font>
</pre>

