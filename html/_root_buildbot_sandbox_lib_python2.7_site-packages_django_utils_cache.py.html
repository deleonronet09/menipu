source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/cache.py</b><br>


file stats: <b>203 lines, 31 executed: 15.3% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. This module contains helper functions for controlling caching. It does so by</font>
<font color="black">   3. managing the &quot;Vary&quot; header of responses. It includes functions to patch the</font>
<font color="black">   4. header of response objects directly and decorators that change functions to do</font>
<font color="black">   5. that header-patching themselves.</font>
<font color="black">   6. </font>
<font color="black">   7. For information on the Vary header, see:</font>
<font color="black">   8. </font>
<font color="black">   9.     http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44</font>
<font color="black">  10. </font>
<font color="black">  11. Essentially, the &quot;Vary&quot; HTTP header defines which headers a cache should take</font>
<font color="black">  12. into account when building its cache key. Requests with the same path but</font>
<font color="black">  13. different header content for headers named in &quot;Vary&quot; need to get different</font>
<font color="black">  14. cache keys to prevent delivery of wrong content.</font>
<font color="black">  15. </font>
<font color="black">  16. An example: i18n middleware would need to distinguish caches by the</font>
<font color="black">  17. &quot;Accept-language&quot; header.</font>
<font color="green">  18. &quot;&quot;&quot;</font>
<font color="green">  19. from __future__ import unicode_literals</font>
<font color="black">  20. </font>
<font color="green">  21. import hashlib</font>
<font color="green">  22. import logging</font>
<font color="green">  23. import re</font>
<font color="green">  24. import time</font>
<font color="black">  25. </font>
<font color="green">  26. from django.conf import settings</font>
<font color="green">  27. from django.core.cache import caches</font>
<font color="green">  28. from django.http import HttpResponse, HttpResponseNotModified</font>
<font color="green">  29. from django.utils.encoding import force_bytes, force_text, iri_to_uri</font>
<font color="green">  30. from django.utils.http import (</font>
<font color="black">  31.     http_date, parse_etags, parse_http_date_safe, quote_etag,</font>
<font color="black">  32. )</font>
<font color="green">  33. from django.utils.timezone import get_current_timezone_name</font>
<font color="green">  34. from django.utils.translation import get_language</font>
<font color="black">  35. </font>
<font color="green">  36. cc_delim_re = re.compile(r'\s*,\s*')</font>
<font color="black">  37. </font>
<font color="green">  38. logger = logging.getLogger('django.request')</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. def patch_cache_control(response, **kwargs):</font>
<font color="black">  42.     &quot;&quot;&quot;</font>
<font color="black">  43.     This function patches the Cache-Control header by adding all</font>
<font color="black">  44.     keyword arguments to it. The transformation is as follows:</font>
<font color="black">  45. </font>
<font color="black">  46.     * All keyword parameter names are turned to lowercase, and underscores</font>
<font color="black">  47.       are converted to hyphens.</font>
<font color="black">  48.     * If the value of a parameter is True (exactly True, not just a</font>
<font color="black">  49.       true value), only the parameter name is added to the header.</font>
<font color="black">  50.     * All other parameters are added with their value, after applying</font>
<font color="black">  51.       str() to it.</font>
<font color="black">  52.     &quot;&quot;&quot;</font>
<font color="red">  53.     def dictitem(s):</font>
<font color="red">  54.         t = s.split('=', 1)</font>
<font color="red">  55.         if len(t) &gt; 1:</font>
<font color="red">  56.             return (t[0].lower(), t[1])</font>
<font color="black">  57.         else:</font>
<font color="red">  58.             return (t[0].lower(), True)</font>
<font color="black">  59. </font>
<font color="red">  60.     def dictvalue(t):</font>
<font color="red">  61.         if t[1] is True:</font>
<font color="red">  62.             return t[0]</font>
<font color="black">  63.         else:</font>
<font color="red">  64.             return '%s=%s' % (t[0], t[1])</font>
<font color="black">  65. </font>
<font color="red">  66.     if response.has_header('Cache-Control'):</font>
<font color="red">  67.         cc = cc_delim_re.split(response['Cache-Control'])</font>
<font color="red">  68.         cc = dict(dictitem(el) for el in cc)</font>
<font color="black">  69.     else:</font>
<font color="red">  70.         cc = {}</font>
<font color="black">  71. </font>
<font color="black">  72.     # If there's already a max-age header but we're being asked to set a new</font>
<font color="black">  73.     # max-age, use the minimum of the two ages. In practice this happens when</font>
<font color="black">  74.     # a decorator and a piece of middleware both operate on a given view.</font>
<font color="red">  75.     if 'max-age' in cc and 'max_age' in kwargs:</font>
<font color="red">  76.         kwargs['max_age'] = min(int(cc['max-age']), kwargs['max_age'])</font>
<font color="black">  77. </font>
<font color="black">  78.     # Allow overriding private caching and vice versa</font>
<font color="red">  79.     if 'private' in cc and 'public' in kwargs:</font>
<font color="red">  80.         del cc['private']</font>
<font color="red">  81.     elif 'public' in cc and 'private' in kwargs:</font>
<font color="red">  82.         del cc['public']</font>
<font color="black">  83. </font>
<font color="red">  84.     for (k, v) in kwargs.items():</font>
<font color="red">  85.         cc[k.replace('_', '-')] = v</font>
<font color="red">  86.     cc = ', '.join(dictvalue(el) for el in cc.items())</font>
<font color="red">  87.     response['Cache-Control'] = cc</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="green">  90. def get_max_age(response):</font>
<font color="black">  91.     &quot;&quot;&quot;</font>
<font color="black">  92.     Returns the max-age from the response Cache-Control header as an integer</font>
<font color="black">  93.     (or ``None`` if it wasn't found or wasn't an integer.</font>
<font color="black">  94.     &quot;&quot;&quot;</font>
<font color="red">  95.     if not response.has_header('Cache-Control'):</font>
<font color="red">  96.         return</font>
<font color="red">  97.     cc = dict(_to_tuple(el) for el in</font>
<font color="red">  98.         cc_delim_re.split(response['Cache-Control']))</font>
<font color="red">  99.     if 'max-age' in cc:</font>
<font color="red"> 100.         try:</font>
<font color="red"> 101.             return int(cc['max-age'])</font>
<font color="red"> 102.         except (ValueError, TypeError):</font>
<font color="red"> 103.             pass</font>
<font color="black"> 104. </font>
<font color="black"> 105. </font>
<font color="green"> 106. def set_response_etag(response):</font>
<font color="red"> 107.     if not response.streaming:</font>
<font color="red"> 108.         response['ETag'] = quote_etag(hashlib.md5(response.content).hexdigest())</font>
<font color="red"> 109.     return response</font>
<font color="black"> 110. </font>
<font color="black"> 111. </font>
<font color="green"> 112. def _precondition_failed(request):</font>
<font color="red"> 113.     logger.warning('Precondition Failed: %s', request.path,</font>
<font color="red"> 114.         extra={</font>
<font color="red"> 115.             'status_code': 412,</font>
<font color="red"> 116.             'request': request,</font>
<font color="black"> 117.         },</font>
<font color="black"> 118.     )</font>
<font color="red"> 119.     return HttpResponse(status=412)</font>
<font color="black"> 120. </font>
<font color="black"> 121. </font>
<font color="green"> 122. def _not_modified(request, response=None):</font>
<font color="red"> 123.     if response:</font>
<font color="black"> 124.         # We need to keep the cookies, see ticket #4994.</font>
<font color="red"> 125.         cookies = response.cookies</font>
<font color="red"> 126.         response = HttpResponseNotModified()</font>
<font color="red"> 127.         response.cookies = cookies</font>
<font color="red"> 128.         return response</font>
<font color="black"> 129.     else:</font>
<font color="red"> 130.         return HttpResponseNotModified()</font>
<font color="black"> 131. </font>
<font color="black"> 132. </font>
<font color="green"> 133. def get_conditional_response(request, etag=None, last_modified=None, response=None):</font>
<font color="black"> 134.     # Get HTTP request headers</font>
<font color="red"> 135.     if_modified_since = request.META.get('HTTP_IF_MODIFIED_SINCE')</font>
<font color="red"> 136.     if if_modified_since:</font>
<font color="red"> 137.         if_modified_since = parse_http_date_safe(if_modified_since)</font>
<font color="red"> 138.     if_unmodified_since = request.META.get('HTTP_IF_UNMODIFIED_SINCE')</font>
<font color="red"> 139.     if if_unmodified_since:</font>
<font color="red"> 140.         if_unmodified_since = parse_http_date_safe(if_unmodified_since)</font>
<font color="red"> 141.     if_none_match = request.META.get('HTTP_IF_NONE_MATCH')</font>
<font color="red"> 142.     if_match = request.META.get('HTTP_IF_MATCH')</font>
<font color="red"> 143.     etags = []</font>
<font color="red"> 144.     if if_none_match or if_match:</font>
<font color="black"> 145.         # There can be more than one ETag in the request, so we</font>
<font color="black"> 146.         # consider the list of values.</font>
<font color="red"> 147.         try:</font>
<font color="red"> 148.             etags = parse_etags(if_none_match or if_match)</font>
<font color="red"> 149.         except ValueError:</font>
<font color="black"> 150.             # In case of an invalid ETag, ignore all ETag headers.</font>
<font color="black"> 151.             # Apparently Opera sends invalidly quoted headers at times</font>
<font color="black"> 152.             # (we should be returning a 400 response, but that's a</font>
<font color="black"> 153.             # little extreme) -- this is bug #10681.</font>
<font color="red"> 154.             if_none_match = None</font>
<font color="red"> 155.             if_match = None</font>
<font color="black"> 156. </font>
<font color="black"> 157.     # If-None-Match must be ignored if original result would be anything</font>
<font color="black"> 158.     # other than a 2XX or 304 status. 304 status would result in no change.</font>
<font color="black"> 159.     # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26</font>
<font color="red"> 160.     if response and not (200 &lt;= response.status_code &lt; 300):</font>
<font color="red"> 161.         if_none_match = None</font>
<font color="red"> 162.         if_match = None</font>
<font color="black"> 163. </font>
<font color="black"> 164.     # If-Modified-Since must be ignored if the original result was not a 200.</font>
<font color="black"> 165.     # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25</font>
<font color="red"> 166.     if response and response.status_code != 200:</font>
<font color="red"> 167.         if_modified_since = None</font>
<font color="red"> 168.         if_unmodified_since = None</font>
<font color="black"> 169. </font>
<font color="red"> 170.     if not ((if_match and if_modified_since) or</font>
<font color="red"> 171.             (if_none_match and if_unmodified_since) or</font>
<font color="red"> 172.             (if_modified_since and if_unmodified_since) or</font>
<font color="red"> 173.             (if_match and if_none_match)):</font>
<font color="black"> 174.         # We only get here if no undefined combinations of headers are</font>
<font color="black"> 175.         # specified.</font>
<font color="red"> 176.         if ((if_none_match and (etag in etags or</font>
<font color="red"> 177.                 '*' in etags and etag)) and</font>
<font color="red"> 178.                 (not if_modified_since or</font>
<font color="red"> 179.                     (last_modified and if_modified_since and</font>
<font color="red"> 180.                     last_modified &lt;= if_modified_since))):</font>
<font color="red"> 181.             if request.method in ('GET', 'HEAD'):</font>
<font color="red"> 182.                 return _not_modified(request, response)</font>
<font color="black"> 183.             else:</font>
<font color="red"> 184.                 return _precondition_failed(request)</font>
<font color="red"> 185.         elif (if_match and ((not etag and '*' in etags) or</font>
<font color="red"> 186.                 (etag and etag not in etags) or</font>
<font color="red"> 187.                 (last_modified and if_unmodified_since and</font>
<font color="red"> 188.                 last_modified &gt; if_unmodified_since))):</font>
<font color="red"> 189.             return _precondition_failed(request)</font>
<font color="red"> 190.         elif (not if_none_match and request.method in ('GET', 'HEAD') and</font>
<font color="red"> 191.                 last_modified and if_modified_since and</font>
<font color="red"> 192.                 last_modified &lt;= if_modified_since):</font>
<font color="red"> 193.             return _not_modified(request, response)</font>
<font color="red"> 194.         elif (not if_match and</font>
<font color="red"> 195.                 last_modified and if_unmodified_since and</font>
<font color="red"> 196.                 last_modified &gt; if_unmodified_since):</font>
<font color="red"> 197.             return _precondition_failed(request)</font>
<font color="black"> 198. </font>
<font color="red"> 199.     return response</font>
<font color="black"> 200. </font>
<font color="black"> 201. </font>
<font color="green"> 202. def patch_response_headers(response, cache_timeout=None):</font>
<font color="black"> 203.     &quot;&quot;&quot;</font>
<font color="black"> 204.     Adds some useful headers to the given HttpResponse object:</font>
<font color="black"> 205.         ETag, Last-Modified, Expires and Cache-Control</font>
<font color="black"> 206. </font>
<font color="black"> 207.     Each header is only added if it isn't already set.</font>
<font color="black"> 208. </font>
<font color="black"> 209.     cache_timeout is in seconds. The CACHE_MIDDLEWARE_SECONDS setting is used</font>
<font color="black"> 210.     by default.</font>
<font color="black"> 211.     &quot;&quot;&quot;</font>
<font color="red"> 212.     if cache_timeout is None:</font>
<font color="red"> 213.         cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS</font>
<font color="red"> 214.     if cache_timeout &lt; 0:</font>
<font color="red"> 215.         cache_timeout = 0  # Can't have max-age negative</font>
<font color="red"> 216.     if settings.USE_ETAGS and not response.has_header('ETag'):</font>
<font color="red"> 217.         if hasattr(response, 'render') and callable(response.render):</font>
<font color="red"> 218.             response.add_post_render_callback(set_response_etag)</font>
<font color="black"> 219.         else:</font>
<font color="red"> 220.             response = set_response_etag(response)</font>
<font color="red"> 221.     if not response.has_header('Last-Modified'):</font>
<font color="red"> 222.         response['Last-Modified'] = http_date()</font>
<font color="red"> 223.     if not response.has_header('Expires'):</font>
<font color="red"> 224.         response['Expires'] = http_date(time.time() + cache_timeout)</font>
<font color="red"> 225.     patch_cache_control(response, max_age=cache_timeout)</font>
<font color="black"> 226. </font>
<font color="black"> 227. </font>
<font color="green"> 228. def add_never_cache_headers(response):</font>
<font color="black"> 229.     &quot;&quot;&quot;</font>
<font color="black"> 230.     Adds headers to a response to indicate that a page should never be cached.</font>
<font color="black"> 231.     &quot;&quot;&quot;</font>
<font color="red"> 232.     patch_response_headers(response, cache_timeout=-1)</font>
<font color="red"> 233.     patch_cache_control(response, no_cache=True, no_store=True, must_revalidate=True)</font>
<font color="black"> 234. </font>
<font color="black"> 235. </font>
<font color="green"> 236. def patch_vary_headers(response, newheaders):</font>
<font color="black"> 237.     &quot;&quot;&quot;</font>
<font color="black"> 238.     Adds (or updates) the &quot;Vary&quot; header in the given HttpResponse object.</font>
<font color="black"> 239.     newheaders is a list of header names that should be in &quot;Vary&quot;. Existing</font>
<font color="black"> 240.     headers in &quot;Vary&quot; aren't removed.</font>
<font color="black"> 241.     &quot;&quot;&quot;</font>
<font color="black"> 242.     # Note that we need to keep the original order intact, because cache</font>
<font color="black"> 243.     # implementations may rely on the order of the Vary contents in, say,</font>
<font color="black"> 244.     # computing an MD5 hash.</font>
<font color="red"> 245.     if response.has_header('Vary'):</font>
<font color="red"> 246.         vary_headers = cc_delim_re.split(response['Vary'])</font>
<font color="black"> 247.     else:</font>
<font color="red"> 248.         vary_headers = []</font>
<font color="black"> 249.     # Use .lower() here so we treat headers as case-insensitive.</font>
<font color="red"> 250.     existing_headers = set(header.lower() for header in vary_headers)</font>
<font color="red"> 251.     additional_headers = [newheader for newheader in newheaders</font>
<font color="red"> 252.                           if newheader.lower() not in existing_headers]</font>
<font color="red"> 253.     response['Vary'] = ', '.join(vary_headers + additional_headers)</font>
<font color="black"> 254. </font>
<font color="black"> 255. </font>
<font color="green"> 256. def has_vary_header(response, header_query):</font>
<font color="black"> 257.     &quot;&quot;&quot;</font>
<font color="black"> 258.     Checks to see if the response has a given header name in its Vary header.</font>
<font color="black"> 259.     &quot;&quot;&quot;</font>
<font color="red"> 260.     if not response.has_header('Vary'):</font>
<font color="red"> 261.         return False</font>
<font color="red"> 262.     vary_headers = cc_delim_re.split(response['Vary'])</font>
<font color="red"> 263.     existing_headers = set(header.lower() for header in vary_headers)</font>
<font color="red"> 264.     return header_query.lower() in existing_headers</font>
<font color="black"> 265. </font>
<font color="black"> 266. </font>
<font color="green"> 267. def _i18n_cache_key_suffix(request, cache_key):</font>
<font color="black"> 268.     &quot;&quot;&quot;If necessary, adds the current locale or time zone to the cache key.&quot;&quot;&quot;</font>
<font color="red"> 269.     if settings.USE_I18N or settings.USE_L10N:</font>
<font color="black"> 270.         # first check if LocaleMiddleware or another middleware added</font>
<font color="black"> 271.         # LANGUAGE_CODE to request, then fall back to the active language</font>
<font color="black"> 272.         # which in turn can also fall back to settings.LANGUAGE_CODE</font>
<font color="red"> 273.         cache_key += '.%s' % getattr(request, 'LANGUAGE_CODE', get_language())</font>
<font color="red"> 274.     if settings.USE_TZ:</font>
<font color="black"> 275.         # The datetime module doesn't restrict the output of tzname().</font>
<font color="black"> 276.         # Windows is known to use non-standard, locale-dependent names.</font>
<font color="black"> 277.         # User-defined tzinfo classes may return absolutely anything.</font>
<font color="black"> 278.         # Hence this paranoid conversion to create a valid cache key.</font>
<font color="red"> 279.         tz_name = force_text(get_current_timezone_name(), errors='ignore')</font>
<font color="red"> 280.         cache_key += '.%s' % tz_name.encode('ascii', 'ignore').decode('ascii').replace(' ', '_')</font>
<font color="red"> 281.     return cache_key</font>
<font color="black"> 282. </font>
<font color="black"> 283. </font>
<font color="green"> 284. def _generate_cache_key(request, method, headerlist, key_prefix):</font>
<font color="black"> 285.     &quot;&quot;&quot;Returns a cache key from the headers given in the header list.&quot;&quot;&quot;</font>
<font color="red"> 286.     ctx = hashlib.md5()</font>
<font color="red"> 287.     for header in headerlist:</font>
<font color="red"> 288.         value = request.META.get(header)</font>
<font color="red"> 289.         if value is not None:</font>
<font color="red"> 290.             ctx.update(force_bytes(value))</font>
<font color="red"> 291.     url = hashlib.md5(force_bytes(iri_to_uri(request.build_absolute_uri())))</font>
<font color="red"> 292.     cache_key = 'views.decorators.cache.cache_page.%s.%s.%s.%s' % (</font>
<font color="red"> 293.         key_prefix, method, url.hexdigest(), ctx.hexdigest())</font>
<font color="red"> 294.     return _i18n_cache_key_suffix(request, cache_key)</font>
<font color="black"> 295. </font>
<font color="black"> 296. </font>
<font color="green"> 297. def _generate_cache_header_key(key_prefix, request):</font>
<font color="black"> 298.     &quot;&quot;&quot;Returns a cache key for the header cache.&quot;&quot;&quot;</font>
<font color="red"> 299.     url = hashlib.md5(force_bytes(iri_to_uri(request.build_absolute_uri())))</font>
<font color="red"> 300.     cache_key = 'views.decorators.cache.cache_header.%s.%s' % (</font>
<font color="red"> 301.         key_prefix, url.hexdigest())</font>
<font color="red"> 302.     return _i18n_cache_key_suffix(request, cache_key)</font>
<font color="black"> 303. </font>
<font color="black"> 304. </font>
<font color="green"> 305. def get_cache_key(request, key_prefix=None, method='GET', cache=None):</font>
<font color="black"> 306.     &quot;&quot;&quot;</font>
<font color="black"> 307.     Returns a cache key based on the request URL and query. It can be used</font>
<font color="black"> 308.     in the request phase because it pulls the list of headers to take into</font>
<font color="black"> 309.     account from the global URL registry and uses those to build a cache key</font>
<font color="black"> 310.     to check against.</font>
<font color="black"> 311. </font>
<font color="black"> 312.     If there is no headerlist stored, the page needs to be rebuilt, so this</font>
<font color="black"> 313.     function returns None.</font>
<font color="black"> 314.     &quot;&quot;&quot;</font>
<font color="red"> 315.     if key_prefix is None:</font>
<font color="red"> 316.         key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX</font>
<font color="red"> 317.     cache_key = _generate_cache_header_key(key_prefix, request)</font>
<font color="red"> 318.     if cache is None:</font>
<font color="red"> 319.         cache = caches[settings.CACHE_MIDDLEWARE_ALIAS]</font>
<font color="red"> 320.     headerlist = cache.get(cache_key)</font>
<font color="red"> 321.     if headerlist is not None:</font>
<font color="red"> 322.         return _generate_cache_key(request, method, headerlist, key_prefix)</font>
<font color="black"> 323.     else:</font>
<font color="red"> 324.         return None</font>
<font color="black"> 325. </font>
<font color="black"> 326. </font>
<font color="green"> 327. def learn_cache_key(request, response, cache_timeout=None, key_prefix=None, cache=None):</font>
<font color="black"> 328.     &quot;&quot;&quot;</font>
<font color="black"> 329.     Learns what headers to take into account for some request URL from the</font>
<font color="black"> 330.     response object. It stores those headers in a global URL registry so that</font>
<font color="black"> 331.     later access to that URL will know what headers to take into account</font>
<font color="black"> 332.     without building the response object itself. The headers are named in the</font>
<font color="black"> 333.     Vary header of the response, but we want to prevent response generation.</font>
<font color="black"> 334. </font>
<font color="black"> 335.     The list of headers to use for cache key generation is stored in the same</font>
<font color="black"> 336.     cache as the pages themselves. If the cache ages some data out of the</font>
<font color="black"> 337.     cache, this just means that we have to build the response once to get at</font>
<font color="black"> 338.     the Vary header and so at the list of headers to use for the cache key.</font>
<font color="black"> 339.     &quot;&quot;&quot;</font>
<font color="red"> 340.     if key_prefix is None:</font>
<font color="red"> 341.         key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX</font>
<font color="red"> 342.     if cache_timeout is None:</font>
<font color="red"> 343.         cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS</font>
<font color="red"> 344.     cache_key = _generate_cache_header_key(key_prefix, request)</font>
<font color="red"> 345.     if cache is None:</font>
<font color="red"> 346.         cache = caches[settings.CACHE_MIDDLEWARE_ALIAS]</font>
<font color="red"> 347.     if response.has_header('Vary'):</font>
<font color="red"> 348.         is_accept_language_redundant = settings.USE_I18N or settings.USE_L10N</font>
<font color="black"> 349.         # If i18n or l10n are used, the generated cache key will be suffixed</font>
<font color="black"> 350.         # with the current locale. Adding the raw value of Accept-Language is</font>
<font color="black"> 351.         # redundant in that case and would result in storing the same content</font>
<font color="black"> 352.         # under multiple keys in the cache. See #18191 for details.</font>
<font color="red"> 353.         headerlist = []</font>
<font color="red"> 354.         for header in cc_delim_re.split(response['Vary']):</font>
<font color="red"> 355.             header = header.upper().replace('-', '_')</font>
<font color="red"> 356.             if header == 'ACCEPT_LANGUAGE' and is_accept_language_redundant:</font>
<font color="red"> 357.                 continue</font>
<font color="red"> 358.             headerlist.append('HTTP_' + header)</font>
<font color="red"> 359.         headerlist.sort()</font>
<font color="red"> 360.         cache.set(cache_key, headerlist, cache_timeout)</font>
<font color="red"> 361.         return _generate_cache_key(request, request.method, headerlist, key_prefix)</font>
<font color="black"> 362.     else:</font>
<font color="black"> 363.         # if there is no Vary header, we still need a cache key</font>
<font color="black"> 364.         # for the request.build_absolute_uri()</font>
<font color="red"> 365.         cache.set(cache_key, [], cache_timeout)</font>
<font color="red"> 366.         return _generate_cache_key(request, request.method, [], key_prefix)</font>
<font color="black"> 367. </font>
<font color="black"> 368. </font>
<font color="green"> 369. def _to_tuple(s):</font>
<font color="red"> 370.     t = s.split('=', 1)</font>
<font color="red"> 371.     if len(t) == 2:</font>
<font color="red"> 372.         return t[0].lower(), t[1]</font>
<font color="red"> 373.     return t[0].lower(), True</font>
</pre>

