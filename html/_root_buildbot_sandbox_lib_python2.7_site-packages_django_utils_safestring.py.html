source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/safestring.py</b><br>


file stats: <b>68 lines, 36 executed: 52.9% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Functions for working with &quot;safe strings&quot;: strings that can be displayed safely</font>
<font color="black">   3. without further escaping in HTML. Marking something as a &quot;safe string&quot; means</font>
<font color="black">   4. that the producer of the string has already turned characters that should not</font>
<font color="black">   5. be interpreted by the HTML engine (e.g. '&lt;') into the appropriate entities.</font>
<font color="green">   6. &quot;&quot;&quot;</font>
<font color="green">   7. from django.utils import six</font>
<font color="green">   8. from django.utils.functional import Promise, curry</font>
<font color="black">   9. </font>
<font color="black">  10. </font>
<font color="green">  11. class EscapeData(object):</font>
<font color="green">  12.     pass</font>
<font color="black">  13. </font>
<font color="black">  14. </font>
<font color="green">  15. class EscapeBytes(bytes, EscapeData):</font>
<font color="black">  16.     &quot;&quot;&quot;</font>
<font color="black">  17.     A byte string that should be HTML-escaped when output.</font>
<font color="green">  18.     &quot;&quot;&quot;</font>
<font color="green">  19.     pass</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class EscapeText(six.text_type, EscapeData):</font>
<font color="black">  23.     &quot;&quot;&quot;</font>
<font color="black">  24.     A unicode string object that should be HTML-escaped when output.</font>
<font color="green">  25.     &quot;&quot;&quot;</font>
<font color="green">  26.     pass</font>
<font color="black">  27. </font>
<font color="green">  28. if six.PY3:</font>
<font color="red">  29.     EscapeString = EscapeText</font>
<font color="black">  30. else:</font>
<font color="green">  31.     EscapeString = EscapeBytes</font>
<font color="black">  32.     # backwards compatibility for Python 2</font>
<font color="green">  33.     EscapeUnicode = EscapeText</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. class SafeData(object):</font>
<font color="green">  37.     def __html__(self):</font>
<font color="black">  38.         &quot;&quot;&quot;</font>
<font color="black">  39.         Returns the html representation of a string for interoperability.</font>
<font color="black">  40. </font>
<font color="black">  41.         This allows other template engines to understand Django's SafeData.</font>
<font color="black">  42.         &quot;&quot;&quot;</font>
<font color="red">  43.         return self</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. class SafeBytes(bytes, SafeData):</font>
<font color="black">  47.     &quot;&quot;&quot;</font>
<font color="black">  48.     A bytes subclass that has been specifically marked as &quot;safe&quot; (requires no</font>
<font color="black">  49.     further escaping) for HTML output purposes.</font>
<font color="green">  50.     &quot;&quot;&quot;</font>
<font color="green">  51.     def __add__(self, rhs):</font>
<font color="black">  52.         &quot;&quot;&quot;</font>
<font color="black">  53.         Concatenating a safe byte string with another safe byte string or safe</font>
<font color="black">  54.         unicode string is safe. Otherwise, the result is no longer safe.</font>
<font color="black">  55.         &quot;&quot;&quot;</font>
<font color="red">  56.         t = super(SafeBytes, self).__add__(rhs)</font>
<font color="red">  57.         if isinstance(rhs, SafeText):</font>
<font color="red">  58.             return SafeText(t)</font>
<font color="red">  59.         elif isinstance(rhs, SafeBytes):</font>
<font color="red">  60.             return SafeBytes(t)</font>
<font color="red">  61.         return t</font>
<font color="black">  62. </font>
<font color="green">  63.     def _proxy_method(self, *args, **kwargs):</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="black">  65.         Wrap a call to a normal unicode method up so that we return safe</font>
<font color="black">  66.         results. The method that is being wrapped is passed in the 'method'</font>
<font color="black">  67.         argument.</font>
<font color="black">  68.         &quot;&quot;&quot;</font>
<font color="red">  69.         method = kwargs.pop('method')</font>
<font color="red">  70.         data = method(self, *args, **kwargs)</font>
<font color="red">  71.         if isinstance(data, bytes):</font>
<font color="red">  72.             return SafeBytes(data)</font>
<font color="black">  73.         else:</font>
<font color="red">  74.             return SafeText(data)</font>
<font color="black">  75. </font>
<font color="green">  76.     decode = curry(_proxy_method, method=bytes.decode)</font>
<font color="black">  77. </font>
<font color="black">  78. </font>
<font color="green">  79. class SafeText(six.text_type, SafeData):</font>
<font color="black">  80.     &quot;&quot;&quot;</font>
<font color="black">  81.     A unicode (Python 2) / str (Python 3) subclass that has been specifically</font>
<font color="black">  82.     marked as &quot;safe&quot; for HTML output purposes.</font>
<font color="green">  83.     &quot;&quot;&quot;</font>
<font color="green">  84.     def __add__(self, rhs):</font>
<font color="black">  85.         &quot;&quot;&quot;</font>
<font color="black">  86.         Concatenating a safe unicode string with another safe byte string or</font>
<font color="black">  87.         safe unicode string is safe. Otherwise, the result is no longer safe.</font>
<font color="black">  88.         &quot;&quot;&quot;</font>
<font color="red">  89.         t = super(SafeText, self).__add__(rhs)</font>
<font color="red">  90.         if isinstance(rhs, SafeData):</font>
<font color="red">  91.             return SafeText(t)</font>
<font color="red">  92.         return t</font>
<font color="black">  93. </font>
<font color="green">  94.     def _proxy_method(self, *args, **kwargs):</font>
<font color="black">  95.         &quot;&quot;&quot;</font>
<font color="black">  96.         Wrap a call to a normal unicode method up so that we return safe</font>
<font color="black">  97.         results. The method that is being wrapped is passed in the 'method'</font>
<font color="black">  98.         argument.</font>
<font color="black">  99.         &quot;&quot;&quot;</font>
<font color="red"> 100.         method = kwargs.pop('method')</font>
<font color="red"> 101.         data = method(self, *args, **kwargs)</font>
<font color="red"> 102.         if isinstance(data, bytes):</font>
<font color="red"> 103.             return SafeBytes(data)</font>
<font color="black"> 104.         else:</font>
<font color="red"> 105.             return SafeText(data)</font>
<font color="black"> 106. </font>
<font color="green"> 107.     encode = curry(_proxy_method, method=six.text_type.encode)</font>
<font color="black"> 108. </font>
<font color="green"> 109. if six.PY3:</font>
<font color="red"> 110.     SafeString = SafeText</font>
<font color="black"> 111. else:</font>
<font color="green"> 112.     SafeString = SafeBytes</font>
<font color="black"> 113.     # backwards compatibility for Python 2</font>
<font color="green"> 114.     SafeUnicode = SafeText</font>
<font color="black"> 115. </font>
<font color="black"> 116. </font>
<font color="green"> 117. def mark_safe(s):</font>
<font color="black"> 118.     &quot;&quot;&quot;</font>
<font color="black"> 119.     Explicitly mark a string as safe for (HTML) output purposes. The returned</font>
<font color="black"> 120.     object can be used everywhere a string or unicode object is appropriate.</font>
<font color="black"> 121. </font>
<font color="black"> 122.     Can be called multiple times on a single string.</font>
<font color="black"> 123.     &quot;&quot;&quot;</font>
<font color="green"> 124.     if hasattr(s, '__html__'):</font>
<font color="red"> 125.         return s</font>
<font color="green"> 126.     if isinstance(s, bytes) or (isinstance(s, Promise) and s._delegate_bytes):</font>
<font color="green"> 127.         return SafeBytes(s)</font>
<font color="green"> 128.     if isinstance(s, (six.text_type, Promise)):</font>
<font color="green"> 129.         return SafeText(s)</font>
<font color="red"> 130.     return SafeString(str(s))</font>
<font color="black"> 131. </font>
<font color="black"> 132. </font>
<font color="green"> 133. def mark_for_escaping(s):</font>
<font color="black"> 134.     &quot;&quot;&quot;</font>
<font color="black"> 135.     Explicitly mark a string as requiring HTML escaping upon output. Has no</font>
<font color="black"> 136.     effect on SafeData subclasses.</font>
<font color="black"> 137. </font>
<font color="black"> 138.     Can be called multiple times on a single string (the resulting escaping is</font>
<font color="black"> 139.     only applied once).</font>
<font color="black"> 140.     &quot;&quot;&quot;</font>
<font color="red"> 141.     if hasattr(s, '__html__') or isinstance(s, EscapeData):</font>
<font color="red"> 142.         return s</font>
<font color="red"> 143.     if isinstance(s, bytes) or (isinstance(s, Promise) and s._delegate_bytes):</font>
<font color="red"> 144.         return EscapeBytes(s)</font>
<font color="red"> 145.     if isinstance(s, (six.text_type, Promise)):</font>
<font color="red"> 146.         return EscapeText(s)</font>
<font color="red"> 147.     return EscapeString(str(s))</font>
</pre>

