source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/files/storage.py</b><br>


file stats: <b>175 lines, 54 executed: 30.9% covered</b>
<pre>
<font color="green">   1. import errno</font>
<font color="green">   2. import os</font>
<font color="green">   3. import warnings</font>
<font color="green">   4. from datetime import datetime</font>
<font color="black">   5. </font>
<font color="green">   6. from django.conf import settings</font>
<font color="green">   7. from django.core.exceptions import SuspiciousFileOperation</font>
<font color="green">   8. from django.core.files import File, locks</font>
<font color="green">   9. from django.core.files.move import file_move_safe</font>
<font color="green">  10. from django.utils._os import abspathu, safe_join</font>
<font color="green">  11. from django.utils.crypto import get_random_string</font>
<font color="green">  12. from django.utils.deconstruct import deconstructible</font>
<font color="green">  13. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  14. from django.utils.encoding import filepath_to_uri, force_text</font>
<font color="green">  15. from django.utils.functional import LazyObject</font>
<font color="green">  16. from django.utils.inspect import func_supports_parameter</font>
<font color="green">  17. from django.utils.module_loading import import_string</font>
<font color="green">  18. from django.utils.six.moves.urllib.parse import urljoin</font>
<font color="green">  19. from django.utils.text import get_valid_filename</font>
<font color="black">  20. </font>
<font color="green">  21. __all__ = ('Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage')</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="green">  24. class Storage(object):</font>
<font color="black">  25.     &quot;&quot;&quot;</font>
<font color="black">  26.     A base storage class, providing some default behaviors that all other</font>
<font color="black">  27.     storage systems can inherit or override, as necessary.</font>
<font color="green">  28.     &quot;&quot;&quot;</font>
<font color="black">  29. </font>
<font color="black">  30.     # The following methods represent a public interface to private methods.</font>
<font color="black">  31.     # These shouldn't be overridden by subclasses unless absolutely necessary.</font>
<font color="black">  32. </font>
<font color="green">  33.     def open(self, name, mode='rb'):</font>
<font color="black">  34.         &quot;&quot;&quot;</font>
<font color="black">  35.         Retrieves the specified file from storage.</font>
<font color="black">  36.         &quot;&quot;&quot;</font>
<font color="red">  37.         return self._open(name, mode)</font>
<font color="black">  38. </font>
<font color="green">  39.     def save(self, name, content, max_length=None):</font>
<font color="black">  40.         &quot;&quot;&quot;</font>
<font color="black">  41.         Saves new content to the file specified by name. The content should be</font>
<font color="black">  42.         a proper File object or any python file-like object, ready to be read</font>
<font color="black">  43.         from the beginning.</font>
<font color="black">  44.         &quot;&quot;&quot;</font>
<font color="black">  45.         # Get the proper name for the file, as it will actually be saved.</font>
<font color="red">  46.         if name is None:</font>
<font color="red">  47.             name = content.name</font>
<font color="black">  48. </font>
<font color="red">  49.         if not hasattr(content, 'chunks'):</font>
<font color="red">  50.             content = File(content)</font>
<font color="black">  51. </font>
<font color="red">  52.         if func_supports_parameter(self.get_available_name, 'max_length'):</font>
<font color="red">  53.             name = self.get_available_name(name, max_length=max_length)</font>
<font color="black">  54.         else:</font>
<font color="red">  55.             warnings.warn(</font>
<font color="red">  56.                 'Backwards compatibility for storage backends without '</font>
<font color="black">  57.                 'support for the `max_length` argument in '</font>
<font color="black">  58.                 'Storage.get_available_name() will be removed in Django 1.10.',</font>
<font color="red">  59.                 RemovedInDjango110Warning, stacklevel=2</font>
<font color="black">  60.             )</font>
<font color="red">  61.             name = self.get_available_name(name)</font>
<font color="black">  62. </font>
<font color="red">  63.         name = self._save(name, content)</font>
<font color="black">  64. </font>
<font color="black">  65.         # Store filenames with forward slashes, even on Windows</font>
<font color="red">  66.         return force_text(name.replace('\\', '/'))</font>
<font color="black">  67. </font>
<font color="black">  68.     # These methods are part of the public API, with default implementations.</font>
<font color="black">  69. </font>
<font color="green">  70.     def get_valid_name(self, name):</font>
<font color="black">  71.         &quot;&quot;&quot;</font>
<font color="black">  72.         Returns a filename, based on the provided filename, that's suitable for</font>
<font color="black">  73.         use in the target storage system.</font>
<font color="black">  74.         &quot;&quot;&quot;</font>
<font color="red">  75.         return get_valid_filename(name)</font>
<font color="black">  76. </font>
<font color="green">  77.     def get_available_name(self, name, max_length=None):</font>
<font color="black">  78.         &quot;&quot;&quot;</font>
<font color="black">  79.         Returns a filename that's free on the target storage system, and</font>
<font color="black">  80.         available for new content to be written to.</font>
<font color="black">  81.         &quot;&quot;&quot;</font>
<font color="red">  82.         dir_name, file_name = os.path.split(name)</font>
<font color="red">  83.         file_root, file_ext = os.path.splitext(file_name)</font>
<font color="black">  84.         # If the filename already exists, add an underscore and a random 7</font>
<font color="black">  85.         # character alphanumeric string (before the file extension, if one</font>
<font color="black">  86.         # exists) to the filename until the generated filename doesn't exist.</font>
<font color="black">  87.         # Truncate original name if required, so the new filename does not</font>
<font color="black">  88.         # exceed the max_length.</font>
<font color="red">  89.         while self.exists(name) or (max_length and len(name) &gt; max_length):</font>
<font color="black">  90.             # file_ext includes the dot.</font>
<font color="red">  91.             name = os.path.join(dir_name, &quot;%s_%s%s&quot; % (file_root, get_random_string(7), file_ext))</font>
<font color="red">  92.             if max_length is None:</font>
<font color="red">  93.                 continue</font>
<font color="black">  94.             # Truncate file_root if max_length exceeded.</font>
<font color="red">  95.             truncation = len(name) - max_length</font>
<font color="red">  96.             if truncation &gt; 0:</font>
<font color="red">  97.                 file_root = file_root[:-truncation]</font>
<font color="black">  98.                 # Entire file_root was truncated in attempt to find an available filename.</font>
<font color="red">  99.                 if not file_root:</font>
<font color="red"> 100.                     raise SuspiciousFileOperation(</font>
<font color="red"> 101.                         'Storage can not find an available filename for &quot;%s&quot;. '</font>
<font color="black"> 102.                         'Please make sure that the corresponding file field '</font>
<font color="red"> 103.                         'allows sufficient &quot;max_length&quot;.' % name</font>
<font color="black"> 104.                     )</font>
<font color="red"> 105.                 name = os.path.join(dir_name, &quot;%s_%s%s&quot; % (file_root, get_random_string(7), file_ext))</font>
<font color="red"> 106.         return name</font>
<font color="black"> 107. </font>
<font color="green"> 108.     def path(self, name):</font>
<font color="black"> 109.         &quot;&quot;&quot;</font>
<font color="black"> 110.         Returns a local filesystem path where the file can be retrieved using</font>
<font color="black"> 111.         Python's built-in open() function. Storage systems that can't be</font>
<font color="black"> 112.         accessed using open() should *not* implement this method.</font>
<font color="black"> 113.         &quot;&quot;&quot;</font>
<font color="red"> 114.         raise NotImplementedError(&quot;This backend doesn't support absolute paths.&quot;)</font>
<font color="black"> 115. </font>
<font color="black"> 116.     # The following methods form the public API for storage systems, but with</font>
<font color="black"> 117.     # no default implementations. Subclasses must implement *all* of these.</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def delete(self, name):</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="black"> 121.         Deletes the specified file from the storage system.</font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="red"> 123.         raise NotImplementedError('subclasses of Storage must provide a delete() method')</font>
<font color="black"> 124. </font>
<font color="green"> 125.     def exists(self, name):</font>
<font color="black"> 126.         &quot;&quot;&quot;</font>
<font color="black"> 127.         Returns True if a file referenced by the given name already exists in the</font>
<font color="black"> 128.         storage system, or False if the name is available for a new file.</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="red"> 130.         raise NotImplementedError('subclasses of Storage must provide an exists() method')</font>
<font color="black"> 131. </font>
<font color="green"> 132.     def listdir(self, path):</font>
<font color="black"> 133.         &quot;&quot;&quot;</font>
<font color="black"> 134.         Lists the contents of the specified path, returning a 2-tuple of lists;</font>
<font color="black"> 135.         the first item being directories, the second item being files.</font>
<font color="black"> 136.         &quot;&quot;&quot;</font>
<font color="red"> 137.         raise NotImplementedError('subclasses of Storage must provide a listdir() method')</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def size(self, name):</font>
<font color="black"> 140.         &quot;&quot;&quot;</font>
<font color="black"> 141.         Returns the total size, in bytes, of the file specified by name.</font>
<font color="black"> 142.         &quot;&quot;&quot;</font>
<font color="red"> 143.         raise NotImplementedError('subclasses of Storage must provide a size() method')</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def url(self, name):</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="black"> 147.         Returns an absolute URL where the file's contents can be accessed</font>
<font color="black"> 148.         directly by a Web browser.</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="red"> 150.         raise NotImplementedError('subclasses of Storage must provide a url() method')</font>
<font color="black"> 151. </font>
<font color="green"> 152.     def accessed_time(self, name):</font>
<font color="black"> 153.         &quot;&quot;&quot;</font>
<font color="black"> 154.         Returns the last accessed time (as datetime object) of the file</font>
<font color="black"> 155.         specified by name.</font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="red"> 157.         raise NotImplementedError('subclasses of Storage must provide an accessed_time() method')</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def created_time(self, name):</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="black"> 161.         Returns the creation time (as datetime object) of the file</font>
<font color="black"> 162.         specified by name.</font>
<font color="black"> 163.         &quot;&quot;&quot;</font>
<font color="red"> 164.         raise NotImplementedError('subclasses of Storage must provide a created_time() method')</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def modified_time(self, name):</font>
<font color="black"> 167.         &quot;&quot;&quot;</font>
<font color="black"> 168.         Returns the last modified time (as datetime object) of the file</font>
<font color="black"> 169.         specified by name.</font>
<font color="black"> 170.         &quot;&quot;&quot;</font>
<font color="red"> 171.         raise NotImplementedError('subclasses of Storage must provide a modified_time() method')</font>
<font color="black"> 172. </font>
<font color="black"> 173. </font>
<font color="green"> 174. @deconstructible</font>
<font color="green"> 175. class FileSystemStorage(Storage):</font>
<font color="black"> 176.     &quot;&quot;&quot;</font>
<font color="black"> 177.     Standard filesystem storage</font>
<font color="green"> 178.     &quot;&quot;&quot;</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def __init__(self, location=None, base_url=None, file_permissions_mode=None,</font>
<font color="green"> 181.             directory_permissions_mode=None):</font>
<font color="red"> 182.         if location is None:</font>
<font color="red"> 183.             location = settings.MEDIA_ROOT</font>
<font color="red"> 184.         self.base_location = location</font>
<font color="red"> 185.         self.location = abspathu(self.base_location)</font>
<font color="red"> 186.         if base_url is None:</font>
<font color="red"> 187.             base_url = settings.MEDIA_URL</font>
<font color="red"> 188.         elif not base_url.endswith('/'):</font>
<font color="red"> 189.             base_url += '/'</font>
<font color="red"> 190.         self.base_url = base_url</font>
<font color="black"> 191.         self.file_permissions_mode = (</font>
<font color="red"> 192.             file_permissions_mode if file_permissions_mode is not None</font>
<font color="red"> 193.             else settings.FILE_UPLOAD_PERMISSIONS</font>
<font color="black"> 194.         )</font>
<font color="black"> 195.         self.directory_permissions_mode = (</font>
<font color="red"> 196.             directory_permissions_mode if directory_permissions_mode is not None</font>
<font color="red"> 197.             else settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS</font>
<font color="black"> 198.         )</font>
<font color="black"> 199. </font>
<font color="green"> 200.     def _open(self, name, mode='rb'):</font>
<font color="red"> 201.         return File(open(self.path(name), mode))</font>
<font color="black"> 202. </font>
<font color="green"> 203.     def _save(self, name, content):</font>
<font color="red"> 204.         full_path = self.path(name)</font>
<font color="black"> 205. </font>
<font color="black"> 206.         # Create any intermediate directories that do not exist.</font>
<font color="black"> 207.         # Note that there is a race between os.path.exists and os.makedirs:</font>
<font color="black"> 208.         # if os.makedirs fails with EEXIST, the directory was created</font>
<font color="black"> 209.         # concurrently, and we can continue normally. Refs #16082.</font>
<font color="red"> 210.         directory = os.path.dirname(full_path)</font>
<font color="red"> 211.         if not os.path.exists(directory):</font>
<font color="red"> 212.             try:</font>
<font color="red"> 213.                 if self.directory_permissions_mode is not None:</font>
<font color="black"> 214.                     # os.makedirs applies the global umask, so we reset it,</font>
<font color="black"> 215.                     # for consistency with file_permissions_mode behavior.</font>
<font color="red"> 216.                     old_umask = os.umask(0)</font>
<font color="red"> 217.                     try:</font>
<font color="red"> 218.                         os.makedirs(directory, self.directory_permissions_mode)</font>
<font color="black"> 219.                     finally:</font>
<font color="red"> 220.                         os.umask(old_umask)</font>
<font color="black"> 221.                 else:</font>
<font color="red"> 222.                     os.makedirs(directory)</font>
<font color="red"> 223.             except OSError as e:</font>
<font color="red"> 224.                 if e.errno != errno.EEXIST:</font>
<font color="red"> 225.                     raise</font>
<font color="red"> 226.         if not os.path.isdir(directory):</font>
<font color="red"> 227.             raise IOError(&quot;%s exists and is not a directory.&quot; % directory)</font>
<font color="black"> 228. </font>
<font color="black"> 229.         # There's a potential race condition between get_available_name and</font>
<font color="black"> 230.         # saving the file; it's possible that two threads might return the</font>
<font color="black"> 231.         # same name, at which point all sorts of fun happens. So we need to</font>
<font color="black"> 232.         # try to create the file, but if it already exists we have to go back</font>
<font color="black"> 233.         # to get_available_name() and try again.</font>
<font color="black"> 234. </font>
<font color="red"> 235.         while True:</font>
<font color="red"> 236.             try:</font>
<font color="black"> 237.                 # This file has a file path that we can move.</font>
<font color="red"> 238.                 if hasattr(content, 'temporary_file_path'):</font>
<font color="red"> 239.                     file_move_safe(content.temporary_file_path(), full_path)</font>
<font color="black"> 240. </font>
<font color="black"> 241.                 # This is a normal uploadedfile that we can stream.</font>
<font color="black"> 242.                 else:</font>
<font color="black"> 243.                     # This fun binary flag incantation makes os.open throw an</font>
<font color="black"> 244.                     # OSError if the file already exists before we open it.</font>
<font color="red"> 245.                     flags = (os.O_WRONLY | os.O_CREAT | os.O_EXCL |</font>
<font color="red"> 246.                              getattr(os, 'O_BINARY', 0))</font>
<font color="black"> 247.                     # The current umask value is masked out by os.open!</font>
<font color="red"> 248.                     fd = os.open(full_path, flags, 0o666)</font>
<font color="red"> 249.                     _file = None</font>
<font color="red"> 250.                     try:</font>
<font color="red"> 251.                         locks.lock(fd, locks.LOCK_EX)</font>
<font color="red"> 252.                         for chunk in content.chunks():</font>
<font color="red"> 253.                             if _file is None:</font>
<font color="red"> 254.                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'</font>
<font color="red"> 255.                                 _file = os.fdopen(fd, mode)</font>
<font color="red"> 256.                             _file.write(chunk)</font>
<font color="black"> 257.                     finally:</font>
<font color="red"> 258.                         locks.unlock(fd)</font>
<font color="red"> 259.                         if _file is not None:</font>
<font color="red"> 260.                             _file.close()</font>
<font color="black"> 261.                         else:</font>
<font color="red"> 262.                             os.close(fd)</font>
<font color="red"> 263.             except OSError as e:</font>
<font color="red"> 264.                 if e.errno == errno.EEXIST:</font>
<font color="black"> 265.                     # Ooops, the file exists. We need a new file name.</font>
<font color="red"> 266.                     name = self.get_available_name(name)</font>
<font color="red"> 267.                     full_path = self.path(name)</font>
<font color="black"> 268.                 else:</font>
<font color="red"> 269.                     raise</font>
<font color="black"> 270.             else:</font>
<font color="black"> 271.                 # OK, the file save worked. Break out of the loop.</font>
<font color="red"> 272.                 break</font>
<font color="black"> 273. </font>
<font color="red"> 274.         if self.file_permissions_mode is not None:</font>
<font color="red"> 275.             os.chmod(full_path, self.file_permissions_mode)</font>
<font color="black"> 276. </font>
<font color="red"> 277.         return name</font>
<font color="black"> 278. </font>
<font color="green"> 279.     def delete(self, name):</font>
<font color="red"> 280.         assert name, &quot;The name argument is not allowed to be empty.&quot;</font>
<font color="red"> 281.         name = self.path(name)</font>
<font color="black"> 282.         # If the file exists, delete it from the filesystem.</font>
<font color="black"> 283.         # Note that there is a race between os.path.exists and os.remove:</font>
<font color="black"> 284.         # if os.remove fails with ENOENT, the file was removed</font>
<font color="black"> 285.         # concurrently, and we can continue normally.</font>
<font color="red"> 286.         if os.path.exists(name):</font>
<font color="red"> 287.             try:</font>
<font color="red"> 288.                 os.remove(name)</font>
<font color="red"> 289.             except OSError as e:</font>
<font color="red"> 290.                 if e.errno != errno.ENOENT:</font>
<font color="red"> 291.                     raise</font>
<font color="black"> 292. </font>
<font color="green"> 293.     def exists(self, name):</font>
<font color="red"> 294.         return os.path.exists(self.path(name))</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def listdir(self, path):</font>
<font color="red"> 297.         path = self.path(path)</font>
<font color="red"> 298.         directories, files = [], []</font>
<font color="red"> 299.         for entry in os.listdir(path):</font>
<font color="red"> 300.             if os.path.isdir(os.path.join(path, entry)):</font>
<font color="red"> 301.                 directories.append(entry)</font>
<font color="black"> 302.             else:</font>
<font color="red"> 303.                 files.append(entry)</font>
<font color="red"> 304.         return directories, files</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def path(self, name):</font>
<font color="red"> 307.         return safe_join(self.location, name)</font>
<font color="black"> 308. </font>
<font color="green"> 309.     def size(self, name):</font>
<font color="red"> 310.         return os.path.getsize(self.path(name))</font>
<font color="black"> 311. </font>
<font color="green"> 312.     def url(self, name):</font>
<font color="red"> 313.         if self.base_url is None:</font>
<font color="red"> 314.             raise ValueError(&quot;This file is not accessible via a URL.&quot;)</font>
<font color="red"> 315.         return urljoin(self.base_url, filepath_to_uri(name))</font>
<font color="black"> 316. </font>
<font color="green"> 317.     def accessed_time(self, name):</font>
<font color="red"> 318.         return datetime.fromtimestamp(os.path.getatime(self.path(name)))</font>
<font color="black"> 319. </font>
<font color="green"> 320.     def created_time(self, name):</font>
<font color="red"> 321.         return datetime.fromtimestamp(os.path.getctime(self.path(name)))</font>
<font color="black"> 322. </font>
<font color="green"> 323.     def modified_time(self, name):</font>
<font color="red"> 324.         return datetime.fromtimestamp(os.path.getmtime(self.path(name)))</font>
<font color="black"> 325. </font>
<font color="black"> 326. </font>
<font color="green"> 327. def get_storage_class(import_path=None):</font>
<font color="red"> 328.     return import_string(import_path or settings.DEFAULT_FILE_STORAGE)</font>
<font color="black"> 329. </font>
<font color="black"> 330. </font>
<font color="green"> 331. class DefaultStorage(LazyObject):</font>
<font color="green"> 332.     def _setup(self):</font>
<font color="red"> 333.         self._wrapped = get_storage_class()()</font>
<font color="black"> 334. </font>
<font color="green"> 335. default_storage = DefaultStorage()</font>
</pre>

