source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/dispatch/dispatcher.py</b><br>


file stats: <b>140 lines, 88 executed: 62.9% covered</b>
<pre>
<font color="green">   1. import sys</font>
<font color="green">   2. import threading</font>
<font color="green">   3. import warnings</font>
<font color="green">   4. import weakref</font>
<font color="black">   5. </font>
<font color="green">   6. from django.utils import six</font>
<font color="green">   7. from django.utils.deprecation import RemovedInDjango20Warning</font>
<font color="green">   8. from django.utils.inspect import func_accepts_kwargs</font>
<font color="green">   9. from django.utils.six.moves import range</font>
<font color="black">  10. </font>
<font color="green">  11. if six.PY2:</font>
<font color="green">  12.     from .weakref_backports import WeakMethod</font>
<font color="black">  13. else:</font>
<font color="red">  14.     from weakref import WeakMethod</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. def _make_id(target):</font>
<font color="green">  18.     if hasattr(target, '__func__'):</font>
<font color="green">  19.         return (id(target.__self__), id(target.__func__))</font>
<font color="green">  20.     return id(target)</font>
<font color="green">  21. NONE_ID = _make_id(None)</font>
<font color="black">  22. </font>
<font color="black">  23. # A marker for caching</font>
<font color="green">  24. NO_RECEIVERS = object()</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. class Signal(object):</font>
<font color="black">  28.     &quot;&quot;&quot;</font>
<font color="black">  29.     Base class for all signals</font>
<font color="black">  30. </font>
<font color="black">  31.     Internal attributes:</font>
<font color="black">  32. </font>
<font color="black">  33.         receivers</font>
<font color="black">  34.             { receiverkey (id) : weakref(receiver) }</font>
<font color="green">  35.     &quot;&quot;&quot;</font>
<font color="green">  36.     def __init__(self, providing_args=None, use_caching=False):</font>
<font color="black">  37.         &quot;&quot;&quot;</font>
<font color="black">  38.         Create a new signal.</font>
<font color="black">  39. </font>
<font color="black">  40.         providing_args</font>
<font color="black">  41.             A list of the arguments this signal can pass along in a send() call.</font>
<font color="black">  42.         &quot;&quot;&quot;</font>
<font color="green">  43.         self.receivers = []</font>
<font color="green">  44.         if providing_args is None:</font>
<font color="green">  45.             providing_args = []</font>
<font color="green">  46.         self.providing_args = set(providing_args)</font>
<font color="green">  47.         self.lock = threading.Lock()</font>
<font color="green">  48.         self.use_caching = use_caching</font>
<font color="black">  49.         # For convenience we create empty caches even if they are not used.</font>
<font color="black">  50.         # A note about caching: if use_caching is defined, then for each</font>
<font color="black">  51.         # distinct sender we cache the receivers that sender has in</font>
<font color="black">  52.         # 'sender_receivers_cache'. The cache is cleaned when .connect() or</font>
<font color="black">  53.         # .disconnect() is called and populated on send().</font>
<font color="green">  54.         self.sender_receivers_cache = weakref.WeakKeyDictionary() if use_caching else {}</font>
<font color="green">  55.         self._dead_receivers = False</font>
<font color="black">  56. </font>
<font color="green">  57.     def connect(self, receiver, sender=None, weak=True, dispatch_uid=None):</font>
<font color="black">  58.         &quot;&quot;&quot;</font>
<font color="black">  59.         Connect receiver to sender for signal.</font>
<font color="black">  60. </font>
<font color="black">  61.         Arguments:</font>
<font color="black">  62. </font>
<font color="black">  63.             receiver</font>
<font color="black">  64.                 A function or an instance method which is to receive signals.</font>
<font color="black">  65.                 Receivers must be hashable objects.</font>
<font color="black">  66. </font>
<font color="black">  67.                 If weak is True, then receiver must be weak referenceable.</font>
<font color="black">  68. </font>
<font color="black">  69.                 Receivers must be able to accept keyword arguments.</font>
<font color="black">  70. </font>
<font color="black">  71.                 If a receiver is connected with a dispatch_uid argument, it</font>
<font color="black">  72.                 will not be added if another receiver was already connected</font>
<font color="black">  73.                 with that dispatch_uid.</font>
<font color="black">  74. </font>
<font color="black">  75.             sender</font>
<font color="black">  76.                 The sender to which the receiver should respond. Must either be</font>
<font color="black">  77.                 of type Signal, or None to receive events from any sender.</font>
<font color="black">  78. </font>
<font color="black">  79.             weak</font>
<font color="black">  80.                 Whether to use weak references to the receiver. By default, the</font>
<font color="black">  81.                 module will attempt to use weak references to the receiver</font>
<font color="black">  82.                 objects. If this parameter is false, then strong references will</font>
<font color="black">  83.                 be used.</font>
<font color="black">  84. </font>
<font color="black">  85.             dispatch_uid</font>
<font color="black">  86.                 An identifier used to uniquely identify a particular instance of</font>
<font color="black">  87.                 a receiver. This will usually be a string, though it may be</font>
<font color="black">  88.                 anything hashable.</font>
<font color="black">  89.         &quot;&quot;&quot;</font>
<font color="green">  90.         from django.conf import settings</font>
<font color="black">  91. </font>
<font color="black">  92.         # If DEBUG is on, check that we got a good receiver</font>
<font color="green">  93.         if settings.configured and settings.DEBUG:</font>
<font color="green">  94.             assert callable(receiver), &quot;Signal receivers must be callable.&quot;</font>
<font color="black">  95. </font>
<font color="black">  96.             # Check for **kwargs</font>
<font color="green">  97.             if not func_accepts_kwargs(receiver):</font>
<font color="red">  98.                 raise ValueError(&quot;Signal receivers must accept keyword arguments (**kwargs).&quot;)</font>
<font color="black">  99. </font>
<font color="green"> 100.         if dispatch_uid:</font>
<font color="green"> 101.             lookup_key = (dispatch_uid, _make_id(sender))</font>
<font color="black"> 102.         else:</font>
<font color="green"> 103.             lookup_key = (_make_id(receiver), _make_id(sender))</font>
<font color="black"> 104. </font>
<font color="green"> 105.         if weak:</font>
<font color="green"> 106.             ref = weakref.ref</font>
<font color="green"> 107.             receiver_object = receiver</font>
<font color="black"> 108.             # Check for bound methods</font>
<font color="green"> 109.             if hasattr(receiver, '__self__') and hasattr(receiver, '__func__'):</font>
<font color="green"> 110.                 ref = WeakMethod</font>
<font color="green"> 111.                 receiver_object = receiver.__self__</font>
<font color="green"> 112.             if six.PY3:</font>
<font color="red"> 113.                 receiver = ref(receiver)</font>
<font color="red"> 114.                 weakref.finalize(receiver_object, self._remove_receiver)</font>
<font color="black"> 115.             else:</font>
<font color="green"> 116.                 receiver = ref(receiver, self._remove_receiver)</font>
<font color="black"> 117. </font>
<font color="green"> 118.         with self.lock:</font>
<font color="green"> 119.             self._clear_dead_receivers()</font>
<font color="green"> 120.             for r_key, _ in self.receivers:</font>
<font color="green"> 121.                 if r_key == lookup_key:</font>
<font color="red"> 122.                     break</font>
<font color="black"> 123.             else:</font>
<font color="green"> 124.                 self.receivers.append((lookup_key, receiver))</font>
<font color="green"> 125.             self.sender_receivers_cache.clear()</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def disconnect(self, receiver=None, sender=None, weak=None, dispatch_uid=None):</font>
<font color="black"> 128.         &quot;&quot;&quot;</font>
<font color="black"> 129.         Disconnect receiver from sender for signal.</font>
<font color="black"> 130. </font>
<font color="black"> 131.         If weak references are used, disconnect need not be called. The receiver</font>
<font color="black"> 132.         will be remove from dispatch automatically.</font>
<font color="black"> 133. </font>
<font color="black"> 134.         Arguments:</font>
<font color="black"> 135. </font>
<font color="black"> 136.             receiver</font>
<font color="black"> 137.                 The registered receiver to disconnect. May be none if</font>
<font color="black"> 138.                 dispatch_uid is specified.</font>
<font color="black"> 139. </font>
<font color="black"> 140.             sender</font>
<font color="black"> 141.                 The registered sender to disconnect</font>
<font color="black"> 142. </font>
<font color="black"> 143.             dispatch_uid</font>
<font color="black"> 144.                 the unique identifier of the receiver to disconnect</font>
<font color="black"> 145.         &quot;&quot;&quot;</font>
<font color="red"> 146.         if weak is not None:</font>
<font color="red"> 147.             warnings.warn(&quot;Passing `weak` to disconnect has no effect.&quot;,</font>
<font color="red"> 148.                 RemovedInDjango20Warning, stacklevel=2)</font>
<font color="red"> 149.         if dispatch_uid:</font>
<font color="red"> 150.             lookup_key = (dispatch_uid, _make_id(sender))</font>
<font color="black"> 151.         else:</font>
<font color="red"> 152.             lookup_key = (_make_id(receiver), _make_id(sender))</font>
<font color="black"> 153. </font>
<font color="red"> 154.         disconnected = False</font>
<font color="red"> 155.         with self.lock:</font>
<font color="red"> 156.             self._clear_dead_receivers()</font>
<font color="red"> 157.             for index in range(len(self.receivers)):</font>
<font color="red"> 158.                 (r_key, _) = self.receivers[index]</font>
<font color="red"> 159.                 if r_key == lookup_key:</font>
<font color="red"> 160.                     disconnected = True</font>
<font color="red"> 161.                     del self.receivers[index]</font>
<font color="red"> 162.                     break</font>
<font color="red"> 163.             self.sender_receivers_cache.clear()</font>
<font color="red"> 164.         return disconnected</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def has_listeners(self, sender=None):</font>
<font color="red"> 167.         return bool(self._live_receivers(sender))</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def send(self, sender, **named):</font>
<font color="black"> 170.         &quot;&quot;&quot;</font>
<font color="black"> 171.         Send signal from sender to all connected receivers.</font>
<font color="black"> 172. </font>
<font color="black"> 173.         If any receiver raises an error, the error propagates back through send,</font>
<font color="black"> 174.         terminating the dispatch loop, so it is quite possible to not have all</font>
<font color="black"> 175.         receivers called if a raises an error.</font>
<font color="black"> 176. </font>
<font color="black"> 177.         Arguments:</font>
<font color="black"> 178. </font>
<font color="black"> 179.             sender</font>
<font color="black"> 180.                 The sender of the signal Either a specific object or None.</font>
<font color="black"> 181. </font>
<font color="black"> 182.             named</font>
<font color="black"> 183.                 Named arguments which will be passed to receivers.</font>
<font color="black"> 184. </font>
<font color="black"> 185.         Returns a list of tuple pairs [(receiver, response), ... ].</font>
<font color="black"> 186.         &quot;&quot;&quot;</font>
<font color="green"> 187.         responses = []</font>
<font color="green"> 188.         if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:</font>
<font color="green"> 189.             return responses</font>
<font color="black"> 190. </font>
<font color="green"> 191.         for receiver in self._live_receivers(sender):</font>
<font color="green"> 192.             response = receiver(signal=self, sender=sender, **named)</font>
<font color="green"> 193.             responses.append((receiver, response))</font>
<font color="green"> 194.         return responses</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def send_robust(self, sender, **named):</font>
<font color="black"> 197.         &quot;&quot;&quot;</font>
<font color="black"> 198.         Send signal from sender to all connected receivers catching errors.</font>
<font color="black"> 199. </font>
<font color="black"> 200.         Arguments:</font>
<font color="black"> 201. </font>
<font color="black"> 202.             sender</font>
<font color="black"> 203.                 The sender of the signal. Can be any python object (normally one</font>
<font color="black"> 204.                 registered with a connect if you actually want something to</font>
<font color="black"> 205.                 occur).</font>
<font color="black"> 206. </font>
<font color="black"> 207.             named</font>
<font color="black"> 208.                 Named arguments which will be passed to receivers. These</font>
<font color="black"> 209.                 arguments must be a subset of the argument names defined in</font>
<font color="black"> 210.                 providing_args.</font>
<font color="black"> 211. </font>
<font color="black"> 212.         Return a list of tuple pairs [(receiver, response), ... ]. May raise</font>
<font color="black"> 213.         DispatcherKeyError.</font>
<font color="black"> 214. </font>
<font color="black"> 215.         If any receiver raises an error (specifically any subclass of</font>
<font color="black"> 216.         Exception), the error instance is returned as the result for that</font>
<font color="black"> 217.         receiver. The traceback is always attached to the error at</font>
<font color="black"> 218.         ``__traceback__``.</font>
<font color="black"> 219.         &quot;&quot;&quot;</font>
<font color="red"> 220.         responses = []</font>
<font color="red"> 221.         if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:</font>
<font color="red"> 222.             return responses</font>
<font color="black"> 223. </font>
<font color="black"> 224.         # Call each receiver with whatever arguments it can accept.</font>
<font color="black"> 225.         # Return a list of tuple pairs [(receiver, response), ... ].</font>
<font color="red"> 226.         for receiver in self._live_receivers(sender):</font>
<font color="red"> 227.             try:</font>
<font color="red"> 228.                 response = receiver(signal=self, sender=sender, **named)</font>
<font color="red"> 229.             except Exception as err:</font>
<font color="red"> 230.                 if not hasattr(err, '__traceback__'):</font>
<font color="red"> 231.                     err.__traceback__ = sys.exc_info()[2]</font>
<font color="red"> 232.                 responses.append((receiver, err))</font>
<font color="black"> 233.             else:</font>
<font color="red"> 234.                 responses.append((receiver, response))</font>
<font color="red"> 235.         return responses</font>
<font color="black"> 236. </font>
<font color="green"> 237.     def _clear_dead_receivers(self):</font>
<font color="black"> 238.         # Note: caller is assumed to hold self.lock.</font>
<font color="green"> 239.         if self._dead_receivers:</font>
<font color="red"> 240.             self._dead_receivers = False</font>
<font color="red"> 241.             new_receivers = []</font>
<font color="red"> 242.             for r in self.receivers:</font>
<font color="red"> 243.                 if isinstance(r[1], weakref.ReferenceType) and r[1]() is None:</font>
<font color="red"> 244.                     continue</font>
<font color="red"> 245.                 new_receivers.append(r)</font>
<font color="red"> 246.             self.receivers = new_receivers</font>
<font color="black"> 247. </font>
<font color="green"> 248.     def _live_receivers(self, sender):</font>
<font color="black"> 249.         &quot;&quot;&quot;</font>
<font color="black"> 250.         Filter sequence of receivers to get resolved, live receivers.</font>
<font color="black"> 251. </font>
<font color="black"> 252.         This checks for weak references and resolves them, then returning only</font>
<font color="black"> 253.         live receivers.</font>
<font color="black"> 254.         &quot;&quot;&quot;</font>
<font color="green"> 255.         receivers = None</font>
<font color="green"> 256.         if self.use_caching and not self._dead_receivers:</font>
<font color="red"> 257.             receivers = self.sender_receivers_cache.get(sender)</font>
<font color="black"> 258.             # We could end up here with NO_RECEIVERS even if we do check this case in</font>
<font color="black"> 259.             # .send() prior to calling _live_receivers() due to concurrent .send() call.</font>
<font color="red"> 260.             if receivers is NO_RECEIVERS:</font>
<font color="red"> 261.                 return []</font>
<font color="green"> 262.         if receivers is None:</font>
<font color="green"> 263.             with self.lock:</font>
<font color="green"> 264.                 self._clear_dead_receivers()</font>
<font color="green"> 265.                 senderkey = _make_id(sender)</font>
<font color="green"> 266.                 receivers = []</font>
<font color="green"> 267.                 for (receiverkey, r_senderkey), receiver in self.receivers:</font>
<font color="green"> 268.                     if r_senderkey == NONE_ID or r_senderkey == senderkey:</font>
<font color="green"> 269.                         receivers.append(receiver)</font>
<font color="green"> 270.                 if self.use_caching:</font>
<font color="red"> 271.                     if not receivers:</font>
<font color="red"> 272.                         self.sender_receivers_cache[sender] = NO_RECEIVERS</font>
<font color="black"> 273.                     else:</font>
<font color="black"> 274.                         # Note, we must cache the weakref versions.</font>
<font color="red"> 275.                         self.sender_receivers_cache[sender] = receivers</font>
<font color="green"> 276.         non_weak_receivers = []</font>
<font color="green"> 277.         for receiver in receivers:</font>
<font color="green"> 278.             if isinstance(receiver, weakref.ReferenceType):</font>
<font color="black"> 279.                 # Dereference the weak reference.</font>
<font color="green"> 280.                 receiver = receiver()</font>
<font color="green"> 281.                 if receiver is not None:</font>
<font color="green"> 282.                     non_weak_receivers.append(receiver)</font>
<font color="black"> 283.             else:</font>
<font color="red"> 284.                 non_weak_receivers.append(receiver)</font>
<font color="green"> 285.         return non_weak_receivers</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def _remove_receiver(self, receiver=None):</font>
<font color="black"> 288.         # Mark that the self.receivers list has dead weakrefs. If so, we will</font>
<font color="black"> 289.         # clean those up in connect, disconnect and _live_receivers while</font>
<font color="black"> 290.         # holding self.lock. Note that doing the cleanup here isn't a good</font>
<font color="black"> 291.         # idea, _remove_receiver() will be called as side effect of garbage</font>
<font color="black"> 292.         # collection, and so the call can happen while we are already holding</font>
<font color="black"> 293.         # self.lock.</font>
<font color="red"> 294.         self._dead_receivers = True</font>
<font color="black"> 295. </font>
<font color="black"> 296. </font>
<font color="green"> 297. def receiver(signal, **kwargs):</font>
<font color="black"> 298.     &quot;&quot;&quot;</font>
<font color="black"> 299.     A decorator for connecting receivers to signals. Used by passing in the</font>
<font color="black"> 300.     signal (or list of signals) and keyword arguments to connect::</font>
<font color="black"> 301. </font>
<font color="black"> 302.         @receiver(post_save, sender=MyModel)</font>
<font color="black"> 303.         def signal_receiver(sender, **kwargs):</font>
<font color="black"> 304.             ...</font>
<font color="black"> 305. </font>
<font color="black"> 306.         @receiver([post_save, post_delete], sender=MyModel)</font>
<font color="black"> 307.         def signals_receiver(sender, **kwargs):</font>
<font color="black"> 308.             ...</font>
<font color="black"> 309.     &quot;&quot;&quot;</font>
<font color="green"> 310.     def _decorator(func):</font>
<font color="green"> 311.         if isinstance(signal, (list, tuple)):</font>
<font color="red"> 312.             for s in signal:</font>
<font color="red"> 313.                 s.connect(func, **kwargs)</font>
<font color="black"> 314.         else:</font>
<font color="green"> 315.             signal.connect(func, **kwargs)</font>
<font color="green"> 316.         return func</font>
<font color="green"> 317.     return _decorator</font>
</pre>

