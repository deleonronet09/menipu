source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/utils.py</b><br>


file stats: <b>296 lines, 85 executed: 28.7% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.utils</font>
<font color="black">   4.     ~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Utility functions.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">   9.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. import re</font>
<font color="green">  12. import errno</font>
<font color="green">  13. from collections import deque</font>
<font color="green">  14. from threading import Lock</font>
<font color="green">  15. from jinja2._compat import text_type, string_types, implements_iterator, \</font>
<font color="black">  16.      url_quote</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. _word_split_re = re.compile(r'(\s+)')</font>
<font color="green">  20. _punctuation_re = re.compile(</font>
<font color="green">  21.     '^(?P&lt;lead&gt;(?:%s)*)(?P&lt;middle&gt;.*?)(?P&lt;trail&gt;(?:%s)*)$' % (</font>
<font color="green">  22.         '|'.join(map(re.escape, ('(', '&lt;', '&amp;lt;'))),</font>
<font color="green">  23.         '|'.join(map(re.escape, ('.', ',', ')', '&gt;', '\n', '&amp;gt;')))</font>
<font color="black">  24.     )</font>
<font color="black">  25. )</font>
<font color="green">  26. _simple_email_re = re.compile(r'^\S+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+$')</font>
<font color="green">  27. _striptags_re = re.compile(r'(&lt;!--.*?--&gt;|&lt;[^&gt;]*&gt;)')</font>
<font color="green">  28. _entity_re = re.compile(r'&amp;([^;]+);')</font>
<font color="green">  29. _letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</font>
<font color="green">  30. _digits = '0123456789'</font>
<font color="black">  31. </font>
<font color="black">  32. # special singleton representing missing values for the runtime</font>
<font color="green">  33. missing = type('MissingType', (), {'__repr__': lambda x: 'missing'})()</font>
<font color="black">  34. </font>
<font color="black">  35. # internal code</font>
<font color="green">  36. internal_code = set()</font>
<font color="black">  37. </font>
<font color="green">  38. concat = u''.join</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. def contextfunction(f):</font>
<font color="black">  42.     &quot;&quot;&quot;This decorator can be used to mark a function or method context callable.</font>
<font color="black">  43.     A context callable is passed the active :class:`Context` as first argument when</font>
<font color="black">  44.     called from the template.  This is useful if a function wants to get access</font>
<font color="black">  45.     to the context or functions provided on the context object.  For example</font>
<font color="black">  46.     a function that returns a sorted list of template variables the current</font>
<font color="black">  47.     template exports could look like this::</font>
<font color="black">  48. </font>
<font color="black">  49.         @contextfunction</font>
<font color="black">  50.         def get_exported_names(context):</font>
<font color="black">  51.             return sorted(context.exported_vars)</font>
<font color="black">  52.     &quot;&quot;&quot;</font>
<font color="red">  53.     f.contextfunction = True</font>
<font color="red">  54.     return f</font>
<font color="black">  55. </font>
<font color="black">  56. </font>
<font color="green">  57. def evalcontextfunction(f):</font>
<font color="black">  58.     &quot;&quot;&quot;This decorator can be used to mark a function or method as an eval</font>
<font color="black">  59.     context callable.  This is similar to the :func:`contextfunction`</font>
<font color="black">  60.     but instead of passing the context, an evaluation context object is</font>
<font color="black">  61.     passed.  For more information about the eval context, see</font>
<font color="black">  62.     :ref:`eval-context`.</font>
<font color="black">  63. </font>
<font color="black">  64.     .. versionadded:: 2.4</font>
<font color="black">  65.     &quot;&quot;&quot;</font>
<font color="red">  66.     f.evalcontextfunction = True</font>
<font color="red">  67.     return f</font>
<font color="black">  68. </font>
<font color="black">  69. </font>
<font color="green">  70. def environmentfunction(f):</font>
<font color="black">  71.     &quot;&quot;&quot;This decorator can be used to mark a function or method as environment</font>
<font color="black">  72.     callable.  This decorator works exactly like the :func:`contextfunction`</font>
<font color="black">  73.     decorator just that the first argument is the active :class:`Environment`</font>
<font color="black">  74.     and not context.</font>
<font color="black">  75.     &quot;&quot;&quot;</font>
<font color="red">  76.     f.environmentfunction = True</font>
<font color="red">  77.     return f</font>
<font color="black">  78. </font>
<font color="black">  79. </font>
<font color="green">  80. def internalcode(f):</font>
<font color="black">  81.     &quot;&quot;&quot;Marks the function as internally used&quot;&quot;&quot;</font>
<font color="green">  82.     internal_code.add(f.__code__)</font>
<font color="green">  83.     return f</font>
<font color="black">  84. </font>
<font color="black">  85. </font>
<font color="green">  86. def is_undefined(obj):</font>
<font color="black">  87.     &quot;&quot;&quot;Check if the object passed is undefined.  This does nothing more than</font>
<font color="black">  88.     performing an instance check against :class:`Undefined` but looks nicer.</font>
<font color="black">  89.     This can be used for custom filters or tests that want to react to</font>
<font color="black">  90.     undefined variables.  For example a custom default filter can look like</font>
<font color="black">  91.     this::</font>
<font color="black">  92. </font>
<font color="black">  93.         def default(var, default=''):</font>
<font color="black">  94.             if is_undefined(var):</font>
<font color="black">  95.                 return default</font>
<font color="black">  96.             return var</font>
<font color="black">  97.     &quot;&quot;&quot;</font>
<font color="red">  98.     from jinja2.runtime import Undefined</font>
<font color="red">  99.     return isinstance(obj, Undefined)</font>
<font color="black"> 100. </font>
<font color="black"> 101. </font>
<font color="green"> 102. def consume(iterable):</font>
<font color="black"> 103.     &quot;&quot;&quot;Consumes an iterable without doing anything with it.&quot;&quot;&quot;</font>
<font color="red"> 104.     for event in iterable:</font>
<font color="red"> 105.         pass</font>
<font color="black"> 106. </font>
<font color="black"> 107. </font>
<font color="green"> 108. def clear_caches():</font>
<font color="black"> 109.     &quot;&quot;&quot;Jinja2 keeps internal caches for environments and lexers.  These are</font>
<font color="black"> 110.     used so that Jinja2 doesn't have to recreate environments and lexers all</font>
<font color="black"> 111.     the time.  Normally you don't have to care about that but if you are</font>
<font color="black"> 112.     messuring memory consumption you may want to clean the caches.</font>
<font color="black"> 113.     &quot;&quot;&quot;</font>
<font color="red"> 114.     from jinja2.environment import _spontaneous_environments</font>
<font color="red"> 115.     from jinja2.lexer import _lexer_cache</font>
<font color="red"> 116.     _spontaneous_environments.clear()</font>
<font color="red"> 117.     _lexer_cache.clear()</font>
<font color="black"> 118. </font>
<font color="black"> 119. </font>
<font color="green"> 120. def import_string(import_name, silent=False):</font>
<font color="black"> 121.     &quot;&quot;&quot;Imports an object based on a string.  This is useful if you want to</font>
<font color="black"> 122.     use import paths as endpoints or something similar.  An import path can</font>
<font color="black"> 123.     be specified either in dotted notation (``xml.sax.saxutils.escape``)</font>
<font color="black"> 124.     or with a colon as object delimiter (``xml.sax.saxutils:escape``).</font>
<font color="black"> 125. </font>
<font color="black"> 126.     If the `silent` is True the return value will be `None` if the import</font>
<font color="black"> 127.     fails.</font>
<font color="black"> 128. </font>
<font color="black"> 129.     :return: imported object</font>
<font color="black"> 130.     &quot;&quot;&quot;</font>
<font color="red"> 131.     try:</font>
<font color="red"> 132.         if ':' in import_name:</font>
<font color="red"> 133.             module, obj = import_name.split(':', 1)</font>
<font color="red"> 134.         elif '.' in import_name:</font>
<font color="red"> 135.             items = import_name.split('.')</font>
<font color="red"> 136.             module = '.'.join(items[:-1])</font>
<font color="red"> 137.             obj = items[-1]</font>
<font color="black"> 138.         else:</font>
<font color="red"> 139.             return __import__(import_name)</font>
<font color="red"> 140.         return getattr(__import__(module, None, None, [obj]), obj)</font>
<font color="red"> 141.     except (ImportError, AttributeError):</font>
<font color="red"> 142.         if not silent:</font>
<font color="red"> 143.             raise</font>
<font color="black"> 144. </font>
<font color="black"> 145. </font>
<font color="green"> 146. def open_if_exists(filename, mode='rb'):</font>
<font color="black"> 147.     &quot;&quot;&quot;Returns a file descriptor for the filename if that file exists,</font>
<font color="black"> 148.     otherwise `None`.</font>
<font color="black"> 149.     &quot;&quot;&quot;</font>
<font color="red"> 150.     try:</font>
<font color="red"> 151.         return open(filename, mode)</font>
<font color="red"> 152.     except IOError as e:</font>
<font color="red"> 153.         if e.errno not in (errno.ENOENT, errno.EISDIR, errno.EINVAL):</font>
<font color="red"> 154.             raise</font>
<font color="black"> 155. </font>
<font color="black"> 156. </font>
<font color="green"> 157. def object_type_repr(obj):</font>
<font color="black"> 158.     &quot;&quot;&quot;Returns the name of the object's type.  For some recognized</font>
<font color="black"> 159.     singletons the name of the object is returned instead. (For</font>
<font color="black"> 160.     example for `None` and `Ellipsis`).</font>
<font color="black"> 161.     &quot;&quot;&quot;</font>
<font color="red"> 162.     if obj is None:</font>
<font color="red"> 163.         return 'None'</font>
<font color="red"> 164.     elif obj is Ellipsis:</font>
<font color="red"> 165.         return 'Ellipsis'</font>
<font color="black"> 166.     # __builtin__ in 2.x, builtins in 3.x</font>
<font color="red"> 167.     if obj.__class__.__module__ in ('__builtin__', 'builtins'):</font>
<font color="red"> 168.         name = obj.__class__.__name__</font>
<font color="black"> 169.     else:</font>
<font color="red"> 170.         name = obj.__class__.__module__ + '.' + obj.__class__.__name__</font>
<font color="red"> 171.     return '%s object' % name</font>
<font color="black"> 172. </font>
<font color="black"> 173. </font>
<font color="green"> 174. def pformat(obj, verbose=False):</font>
<font color="black"> 175.     &quot;&quot;&quot;Prettyprint an object.  Either use the `pretty` library or the</font>
<font color="black"> 176.     builtin `pprint`.</font>
<font color="black"> 177.     &quot;&quot;&quot;</font>
<font color="red"> 178.     try:</font>
<font color="red"> 179.         from pretty import pretty</font>
<font color="red"> 180.         return pretty(obj, verbose=verbose)</font>
<font color="red"> 181.     except ImportError:</font>
<font color="red"> 182.         from pprint import pformat</font>
<font color="red"> 183.         return pformat(obj)</font>
<font color="black"> 184. </font>
<font color="black"> 185. </font>
<font color="green"> 186. def urlize(text, trim_url_limit=None, nofollow=False, target=None):</font>
<font color="black"> 187.     &quot;&quot;&quot;Converts any URLs in text into clickable links. Works on http://,</font>
<font color="black"> 188.     https:// and www. links. Links can have trailing punctuation (periods,</font>
<font color="black"> 189.     commas, close-parens) and leading punctuation (opening parens) and</font>
<font color="black"> 190.     it'll still do the right thing.</font>
<font color="black"> 191. </font>
<font color="black"> 192.     If trim_url_limit is not None, the URLs in link text will be limited</font>
<font color="black"> 193.     to trim_url_limit characters.</font>
<font color="black"> 194. </font>
<font color="black"> 195.     If nofollow is True, the URLs in link text will get a rel=&quot;nofollow&quot;</font>
<font color="black"> 196.     attribute.</font>
<font color="black"> 197. </font>
<font color="black"> 198.     If target is not None, a target attribute will be added to the link.</font>
<font color="black"> 199.     &quot;&quot;&quot;</font>
<font color="red"> 200.     trim_url = lambda x, limit=trim_url_limit: limit is not None \</font>
<font color="red"> 201.                          and (x[:limit] + (len(x) &gt;=limit and '...'</font>
<font color="red"> 202.                          or '')) or x</font>
<font color="red"> 203.     words = _word_split_re.split(text_type(escape(text)))</font>
<font color="red"> 204.     nofollow_attr = nofollow and ' rel=&quot;nofollow&quot;' or ''</font>
<font color="red"> 205.     if target is not None and isinstance(target, string_types):</font>
<font color="red"> 206.         target_attr = ' target=&quot;%s&quot;' % target</font>
<font color="black"> 207.     else:</font>
<font color="red"> 208.         target_attr = ''</font>
<font color="red"> 209.     for i, word in enumerate(words):</font>
<font color="red"> 210.         match = _punctuation_re.match(word)</font>
<font color="red"> 211.         if match:</font>
<font color="red"> 212.             lead, middle, trail = match.groups()</font>
<font color="red"> 213.             if middle.startswith('www.') or (</font>
<font color="red"> 214.                 '@' not in middle and</font>
<font color="red"> 215.                 not middle.startswith('http://') and</font>
<font color="red"> 216.                 not middle.startswith('https://') and</font>
<font color="red"> 217.                 len(middle) &gt; 0 and</font>
<font color="red"> 218.                 middle[0] in _letters + _digits and (</font>
<font color="red"> 219.                     middle.endswith('.org') or</font>
<font color="red"> 220.                     middle.endswith('.net') or</font>
<font color="red"> 221.                     middle.endswith('.com')</font>
<font color="black"> 222.                 )):</font>
<font color="red"> 223.                 middle = '&lt;a href=&quot;http://%s&quot;%s%s&gt;%s&lt;/a&gt;' % (middle,</font>
<font color="red"> 224.                     nofollow_attr, target_attr, trim_url(middle))</font>
<font color="red"> 225.             if middle.startswith('http://') or \</font>
<font color="red"> 226.                middle.startswith('https://'):</font>
<font color="red"> 227.                 middle = '&lt;a href=&quot;%s&quot;%s%s&gt;%s&lt;/a&gt;' % (middle,</font>
<font color="red"> 228.                     nofollow_attr, target_attr, trim_url(middle))</font>
<font color="red"> 229.             if '@' in middle and not middle.startswith('www.') and \</font>
<font color="red"> 230.                not ':' in middle and _simple_email_re.match(middle):</font>
<font color="red"> 231.                 middle = '&lt;a href=&quot;mailto:%s&quot;&gt;%s&lt;/a&gt;' % (middle, middle)</font>
<font color="red"> 232.             if lead + middle + trail != word:</font>
<font color="red"> 233.                 words[i] = lead + middle + trail</font>
<font color="red"> 234.     return u''.join(words)</font>
<font color="black"> 235. </font>
<font color="black"> 236. </font>
<font color="green"> 237. def generate_lorem_ipsum(n=5, html=True, min=20, max=100):</font>
<font color="black"> 238.     &quot;&quot;&quot;Generate some lorem ipsum for the template.&quot;&quot;&quot;</font>
<font color="red"> 239.     from jinja2.constants import LOREM_IPSUM_WORDS</font>
<font color="red"> 240.     from random import choice, randrange</font>
<font color="red"> 241.     words = LOREM_IPSUM_WORDS.split()</font>
<font color="red"> 242.     result = []</font>
<font color="black"> 243. </font>
<font color="red"> 244.     for _ in range(n):</font>
<font color="red"> 245.         next_capitalized = True</font>
<font color="red"> 246.         last_comma = last_fullstop = 0</font>
<font color="red"> 247.         word = None</font>
<font color="red"> 248.         last = None</font>
<font color="red"> 249.         p = []</font>
<font color="black"> 250. </font>
<font color="black"> 251.         # each paragraph contains out of 20 to 100 words.</font>
<font color="red"> 252.         for idx, _ in enumerate(range(randrange(min, max))):</font>
<font color="red"> 253.             while True:</font>
<font color="red"> 254.                 word = choice(words)</font>
<font color="red"> 255.                 if word != last:</font>
<font color="red"> 256.                     last = word</font>
<font color="red"> 257.                     break</font>
<font color="red"> 258.             if next_capitalized:</font>
<font color="red"> 259.                 word = word.capitalize()</font>
<font color="red"> 260.                 next_capitalized = False</font>
<font color="black"> 261.             # add commas</font>
<font color="red"> 262.             if idx - randrange(3, 8) &gt; last_comma:</font>
<font color="red"> 263.                 last_comma = idx</font>
<font color="red"> 264.                 last_fullstop += 2</font>
<font color="red"> 265.                 word += ','</font>
<font color="black"> 266.             # add end of sentences</font>
<font color="red"> 267.             if idx - randrange(10, 20) &gt; last_fullstop:</font>
<font color="red"> 268.                 last_comma = last_fullstop = idx</font>
<font color="red"> 269.                 word += '.'</font>
<font color="red"> 270.                 next_capitalized = True</font>
<font color="red"> 271.             p.append(word)</font>
<font color="black"> 272. </font>
<font color="black"> 273.         # ensure that the paragraph ends with a dot.</font>
<font color="red"> 274.         p = u' '.join(p)</font>
<font color="red"> 275.         if p.endswith(','):</font>
<font color="red"> 276.             p = p[:-1] + '.'</font>
<font color="red"> 277.         elif not p.endswith('.'):</font>
<font color="red"> 278.             p += '.'</font>
<font color="red"> 279.         result.append(p)</font>
<font color="black"> 280. </font>
<font color="red"> 281.     if not html:</font>
<font color="red"> 282.         return u'\n\n'.join(result)</font>
<font color="red"> 283.     return Markup(u'\n'.join(u'&lt;p&gt;%s&lt;/p&gt;' % escape(x) for x in result))</font>
<font color="black"> 284. </font>
<font color="black"> 285. </font>
<font color="green"> 286. def unicode_urlencode(obj, charset='utf-8', for_qs=False):</font>
<font color="black"> 287.     &quot;&quot;&quot;URL escapes a single bytestring or unicode string with the</font>
<font color="black"> 288.     given charset if applicable to URL safe quoting under all rules</font>
<font color="black"> 289.     that need to be considered under all supported Python versions.</font>
<font color="black"> 290. </font>
<font color="black"> 291.     If non strings are provided they are converted to their unicode</font>
<font color="black"> 292.     representation first.</font>
<font color="black"> 293.     &quot;&quot;&quot;</font>
<font color="red"> 294.     if not isinstance(obj, string_types):</font>
<font color="red"> 295.         obj = text_type(obj)</font>
<font color="red"> 296.     if isinstance(obj, text_type):</font>
<font color="red"> 297.         obj = obj.encode(charset)</font>
<font color="red"> 298.     safe = for_qs and b'' or b'/'</font>
<font color="red"> 299.     rv = text_type(url_quote(obj, safe))</font>
<font color="red"> 300.     if for_qs:</font>
<font color="red"> 301.         rv = rv.replace('%20', '+')</font>
<font color="red"> 302.     return rv</font>
<font color="black"> 303. </font>
<font color="black"> 304. </font>
<font color="green"> 305. class LRUCache(object):</font>
<font color="green"> 306.     &quot;&quot;&quot;A simple LRU Cache implementation.&quot;&quot;&quot;</font>
<font color="black"> 307. </font>
<font color="black"> 308.     # this is fast for small capacities (something below 1000) but doesn't</font>
<font color="black"> 309.     # scale.  But as long as it's only used as storage for templates this</font>
<font color="black"> 310.     # won't do any harm.</font>
<font color="black"> 311. </font>
<font color="green"> 312.     def __init__(self, capacity):</font>
<font color="green"> 313.         self.capacity = capacity</font>
<font color="green"> 314.         self._mapping = {}</font>
<font color="green"> 315.         self._queue = deque()</font>
<font color="green"> 316.         self._postinit()</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def _postinit(self):</font>
<font color="black"> 319.         # alias all queue methods for faster lookup</font>
<font color="green"> 320.         self._popleft = self._queue.popleft</font>
<font color="green"> 321.         self._pop = self._queue.pop</font>
<font color="green"> 322.         self._remove = self._queue.remove</font>
<font color="green"> 323.         self._wlock = Lock()</font>
<font color="green"> 324.         self._append = self._queue.append</font>
<font color="black"> 325. </font>
<font color="green"> 326.     def __getstate__(self):</font>
<font color="red"> 327.         return {</font>
<font color="red"> 328.             'capacity':     self.capacity,</font>
<font color="red"> 329.             '_mapping':     self._mapping,</font>
<font color="red"> 330.             '_queue':       self._queue</font>
<font color="black"> 331.         }</font>
<font color="black"> 332. </font>
<font color="green"> 333.     def __setstate__(self, d):</font>
<font color="red"> 334.         self.__dict__.update(d)</font>
<font color="red"> 335.         self._postinit()</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def __getnewargs__(self):</font>
<font color="red"> 338.         return (self.capacity,)</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def copy(self):</font>
<font color="black"> 341.         &quot;&quot;&quot;Return a shallow copy of the instance.&quot;&quot;&quot;</font>
<font color="red"> 342.         rv = self.__class__(self.capacity)</font>
<font color="red"> 343.         rv._mapping.update(self._mapping)</font>
<font color="red"> 344.         rv._queue = deque(self._queue)</font>
<font color="red"> 345.         return rv</font>
<font color="black"> 346. </font>
<font color="green"> 347.     def get(self, key, default=None):</font>
<font color="black"> 348.         &quot;&quot;&quot;Return an item from the cache dict or `default`&quot;&quot;&quot;</font>
<font color="red"> 349.         try:</font>
<font color="red"> 350.             return self[key]</font>
<font color="red"> 351.         except KeyError:</font>
<font color="red"> 352.             return default</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def setdefault(self, key, default=None):</font>
<font color="black"> 355.         &quot;&quot;&quot;Set `default` if the key is not in the cache otherwise</font>
<font color="black"> 356.         leave unchanged. Return the value of this key.</font>
<font color="black"> 357.         &quot;&quot;&quot;</font>
<font color="red"> 358.         self._wlock.acquire()</font>
<font color="red"> 359.         try:</font>
<font color="red"> 360.             try:</font>
<font color="red"> 361.                 return self[key]</font>
<font color="red"> 362.             except KeyError:</font>
<font color="red"> 363.                 self[key] = default</font>
<font color="red"> 364.                 return default</font>
<font color="black"> 365.         finally:</font>
<font color="red"> 366.             self._wlock.release()</font>
<font color="black"> 367. </font>
<font color="green"> 368.     def clear(self):</font>
<font color="black"> 369.         &quot;&quot;&quot;Clear the cache.&quot;&quot;&quot;</font>
<font color="red"> 370.         self._wlock.acquire()</font>
<font color="red"> 371.         try:</font>
<font color="red"> 372.             self._mapping.clear()</font>
<font color="red"> 373.             self._queue.clear()</font>
<font color="black"> 374.         finally:</font>
<font color="red"> 375.             self._wlock.release()</font>
<font color="black"> 376. </font>
<font color="green"> 377.     def __contains__(self, key):</font>
<font color="black"> 378.         &quot;&quot;&quot;Check if a key exists in this cache.&quot;&quot;&quot;</font>
<font color="red"> 379.         return key in self._mapping</font>
<font color="black"> 380. </font>
<font color="green"> 381.     def __len__(self):</font>
<font color="black"> 382.         &quot;&quot;&quot;Return the current size of the cache.&quot;&quot;&quot;</font>
<font color="red"> 383.         return len(self._mapping)</font>
<font color="black"> 384. </font>
<font color="green"> 385.     def __repr__(self):</font>
<font color="red"> 386.         return '&lt;%s %r&gt;' % (</font>
<font color="red"> 387.             self.__class__.__name__,</font>
<font color="red"> 388.             self._mapping</font>
<font color="black"> 389.         )</font>
<font color="black"> 390. </font>
<font color="green"> 391.     def __getitem__(self, key):</font>
<font color="black"> 392.         &quot;&quot;&quot;Get an item from the cache. Moves the item up so that it has the</font>
<font color="black"> 393.         highest priority then.</font>
<font color="black"> 394. </font>
<font color="black"> 395.         Raise a `KeyError` if it does not exist.</font>
<font color="black"> 396.         &quot;&quot;&quot;</font>
<font color="red"> 397.         self._wlock.acquire()</font>
<font color="red"> 398.         try:</font>
<font color="red"> 399.             rv = self._mapping[key]</font>
<font color="red"> 400.             if self._queue[-1] != key:</font>
<font color="red"> 401.                 try:</font>
<font color="red"> 402.                     self._remove(key)</font>
<font color="red"> 403.                 except ValueError:</font>
<font color="black"> 404.                     # if something removed the key from the container</font>
<font color="black"> 405.                     # when we read, ignore the ValueError that we would</font>
<font color="black"> 406.                     # get otherwise.</font>
<font color="red"> 407.                     pass</font>
<font color="red"> 408.                 self._append(key)</font>
<font color="red"> 409.             return rv</font>
<font color="black"> 410.         finally:</font>
<font color="red"> 411.             self._wlock.release()</font>
<font color="black"> 412. </font>
<font color="green"> 413.     def __setitem__(self, key, value):</font>
<font color="black"> 414.         &quot;&quot;&quot;Sets the value for an item. Moves the item up so that it</font>
<font color="black"> 415.         has the highest priority then.</font>
<font color="black"> 416.         &quot;&quot;&quot;</font>
<font color="red"> 417.         self._wlock.acquire()</font>
<font color="red"> 418.         try:</font>
<font color="red"> 419.             if key in self._mapping:</font>
<font color="red"> 420.                 self._remove(key)</font>
<font color="red"> 421.             elif len(self._mapping) == self.capacity:</font>
<font color="red"> 422.                 del self._mapping[self._popleft()]</font>
<font color="red"> 423.             self._append(key)</font>
<font color="red"> 424.             self._mapping[key] = value</font>
<font color="black"> 425.         finally:</font>
<font color="red"> 426.             self._wlock.release()</font>
<font color="black"> 427. </font>
<font color="green"> 428.     def __delitem__(self, key):</font>
<font color="black"> 429.         &quot;&quot;&quot;Remove an item from the cache dict.</font>
<font color="black"> 430.         Raise a `KeyError` if it does not exist.</font>
<font color="black"> 431.         &quot;&quot;&quot;</font>
<font color="red"> 432.         self._wlock.acquire()</font>
<font color="red"> 433.         try:</font>
<font color="red"> 434.             del self._mapping[key]</font>
<font color="red"> 435.             try:</font>
<font color="red"> 436.                 self._remove(key)</font>
<font color="red"> 437.             except ValueError:</font>
<font color="black"> 438.                 # __getitem__ is not locked, it might happen</font>
<font color="red"> 439.                 pass</font>
<font color="black"> 440.         finally:</font>
<font color="red"> 441.             self._wlock.release()</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def items(self):</font>
<font color="black"> 444.         &quot;&quot;&quot;Return a list of items.&quot;&quot;&quot;</font>
<font color="red"> 445.         result = [(key, self._mapping[key]) for key in list(self._queue)]</font>
<font color="red"> 446.         result.reverse()</font>
<font color="red"> 447.         return result</font>
<font color="black"> 448. </font>
<font color="green"> 449.     def iteritems(self):</font>
<font color="black"> 450.         &quot;&quot;&quot;Iterate over all items.&quot;&quot;&quot;</font>
<font color="red"> 451.         return iter(self.items())</font>
<font color="black"> 452. </font>
<font color="green"> 453.     def values(self):</font>
<font color="black"> 454.         &quot;&quot;&quot;Return a list of all values.&quot;&quot;&quot;</font>
<font color="red"> 455.         return [x[1] for x in self.items()]</font>
<font color="black"> 456. </font>
<font color="green"> 457.     def itervalue(self):</font>
<font color="black"> 458.         &quot;&quot;&quot;Iterate over all values.&quot;&quot;&quot;</font>
<font color="red"> 459.         return iter(self.values())</font>
<font color="black"> 460. </font>
<font color="green"> 461.     def keys(self):</font>
<font color="black"> 462.         &quot;&quot;&quot;Return a list of all keys ordered by most recent usage.&quot;&quot;&quot;</font>
<font color="red"> 463.         return list(self)</font>
<font color="black"> 464. </font>
<font color="green"> 465.     def iterkeys(self):</font>
<font color="black"> 466.         &quot;&quot;&quot;Iterate over all keys in the cache dict, ordered by</font>
<font color="black"> 467.         the most recent usage.</font>
<font color="black"> 468.         &quot;&quot;&quot;</font>
<font color="red"> 469.         return reversed(tuple(self._queue))</font>
<font color="black"> 470. </font>
<font color="green"> 471.     __iter__ = iterkeys</font>
<font color="black"> 472. </font>
<font color="green"> 473.     def __reversed__(self):</font>
<font color="black"> 474.         &quot;&quot;&quot;Iterate over the values in the cache dict, oldest items</font>
<font color="black"> 475.         coming first.</font>
<font color="black"> 476.         &quot;&quot;&quot;</font>
<font color="red"> 477.         return iter(tuple(self._queue))</font>
<font color="black"> 478. </font>
<font color="green"> 479.     __copy__ = copy</font>
<font color="black"> 480. </font>
<font color="black"> 481. </font>
<font color="black"> 482. # register the LRU cache as mutable mapping if possible</font>
<font color="green"> 483. try:</font>
<font color="green"> 484.     from collections import MutableMapping</font>
<font color="green"> 485.     MutableMapping.register(LRUCache)</font>
<font color="red"> 486. except ImportError:</font>
<font color="red"> 487.     pass</font>
<font color="black"> 488. </font>
<font color="black"> 489. </font>
<font color="green"> 490. @implements_iterator</font>
<font color="green"> 491. class Cycler(object):</font>
<font color="green"> 492.     &quot;&quot;&quot;A cycle helper for templates.&quot;&quot;&quot;</font>
<font color="black"> 493. </font>
<font color="green"> 494.     def __init__(self, *items):</font>
<font color="red"> 495.         if not items:</font>
<font color="red"> 496.             raise RuntimeError('at least one item has to be provided')</font>
<font color="red"> 497.         self.items = items</font>
<font color="red"> 498.         self.reset()</font>
<font color="black"> 499. </font>
<font color="green"> 500.     def reset(self):</font>
<font color="black"> 501.         &quot;&quot;&quot;Resets the cycle.&quot;&quot;&quot;</font>
<font color="red"> 502.         self.pos = 0</font>
<font color="black"> 503. </font>
<font color="green"> 504.     @property</font>
<font color="black"> 505.     def current(self):</font>
<font color="black"> 506.         &quot;&quot;&quot;Returns the current item.&quot;&quot;&quot;</font>
<font color="red"> 507.         return self.items[self.pos]</font>
<font color="black"> 508. </font>
<font color="green"> 509.     def __next__(self):</font>
<font color="black"> 510.         &quot;&quot;&quot;Goes one item ahead and returns it.&quot;&quot;&quot;</font>
<font color="red"> 511.         rv = self.current</font>
<font color="red"> 512.         self.pos = (self.pos + 1) % len(self.items)</font>
<font color="red"> 513.         return rv</font>
<font color="black"> 514. </font>
<font color="black"> 515. </font>
<font color="green"> 516. class Joiner(object):</font>
<font color="green"> 517.     &quot;&quot;&quot;A joining helper for templates.&quot;&quot;&quot;</font>
<font color="black"> 518. </font>
<font color="green"> 519.     def __init__(self, sep=u', '):</font>
<font color="red"> 520.         self.sep = sep</font>
<font color="red"> 521.         self.used = False</font>
<font color="black"> 522. </font>
<font color="green"> 523.     def __call__(self):</font>
<font color="red"> 524.         if not self.used:</font>
<font color="red"> 525.             self.used = True</font>
<font color="red"> 526.             return u''</font>
<font color="red"> 527.         return self.sep</font>
<font color="black"> 528. </font>
<font color="black"> 529. </font>
<font color="black"> 530. # Imported here because that's where it was in the past</font>
<font color="green"> 531. from markupsafe import Markup, escape, soft_unicode</font>
</pre>

