source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/handlers/wsgi.py</b><br>


file stats: <b>158 lines, 41 executed: 25.9% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import cgi</font>
<font color="green">   4. import codecs</font>
<font color="green">   5. import logging</font>
<font color="green">   6. import sys</font>
<font color="green">   7. from io import BytesIO</font>
<font color="green">   8. from threading import Lock</font>
<font color="black">   9. </font>
<font color="green">  10. from django import http</font>
<font color="green">  11. from django.conf import settings</font>
<font color="green">  12. from django.core import signals</font>
<font color="green">  13. from django.core.handlers import base</font>
<font color="green">  14. from django.core.urlresolvers import set_script_prefix</font>
<font color="green">  15. from django.utils import six</font>
<font color="green">  16. from django.utils.encoding import force_str, force_text</font>
<font color="green">  17. from django.utils.functional import cached_property</font>
<font color="black">  18. </font>
<font color="green">  19. logger = logging.getLogger('django.request')</font>
<font color="black">  20. </font>
<font color="black">  21. # encode() and decode() expect the charset to be a native string.</font>
<font color="green">  22. ISO_8859_1, UTF_8 = str('iso-8859-1'), str('utf-8')</font>
<font color="black">  23. </font>
<font color="black">  24. </font>
<font color="green">  25. class LimitedStream(object):</font>
<font color="black">  26.     '''</font>
<font color="black">  27.     LimitedStream wraps another stream in order to not allow reading from it</font>
<font color="black">  28.     past specified amount of bytes.</font>
<font color="green">  29.     '''</font>
<font color="green">  30.     def __init__(self, stream, limit, buf_size=64 * 1024 * 1024):</font>
<font color="red">  31.         self.stream = stream</font>
<font color="red">  32.         self.remaining = limit</font>
<font color="red">  33.         self.buffer = b''</font>
<font color="red">  34.         self.buf_size = buf_size</font>
<font color="black">  35. </font>
<font color="green">  36.     def _read_limited(self, size=None):</font>
<font color="red">  37.         if size is None or size &gt; self.remaining:</font>
<font color="red">  38.             size = self.remaining</font>
<font color="red">  39.         if size == 0:</font>
<font color="red">  40.             return b''</font>
<font color="red">  41.         result = self.stream.read(size)</font>
<font color="red">  42.         self.remaining -= len(result)</font>
<font color="red">  43.         return result</font>
<font color="black">  44. </font>
<font color="green">  45.     def read(self, size=None):</font>
<font color="red">  46.         if size is None:</font>
<font color="red">  47.             result = self.buffer + self._read_limited()</font>
<font color="red">  48.             self.buffer = b''</font>
<font color="red">  49.         elif size &lt; len(self.buffer):</font>
<font color="red">  50.             result = self.buffer[:size]</font>
<font color="red">  51.             self.buffer = self.buffer[size:]</font>
<font color="black">  52.         else:  # size &gt;= len(self.buffer)</font>
<font color="red">  53.             result = self.buffer + self._read_limited(size - len(self.buffer))</font>
<font color="red">  54.             self.buffer = b''</font>
<font color="red">  55.         return result</font>
<font color="black">  56. </font>
<font color="green">  57.     def readline(self, size=None):</font>
<font color="red">  58.         while b'\n' not in self.buffer and \</font>
<font color="red">  59.               (size is None or len(self.buffer) &lt; size):</font>
<font color="red">  60.             if size:</font>
<font color="black">  61.                 # since size is not None here, len(self.buffer) &lt; size</font>
<font color="red">  62.                 chunk = self._read_limited(size - len(self.buffer))</font>
<font color="black">  63.             else:</font>
<font color="red">  64.                 chunk = self._read_limited()</font>
<font color="red">  65.             if not chunk:</font>
<font color="red">  66.                 break</font>
<font color="red">  67.             self.buffer += chunk</font>
<font color="red">  68.         sio = BytesIO(self.buffer)</font>
<font color="red">  69.         if size:</font>
<font color="red">  70.             line = sio.readline(size)</font>
<font color="black">  71.         else:</font>
<font color="red">  72.             line = sio.readline()</font>
<font color="red">  73.         self.buffer = sio.read()</font>
<font color="red">  74.         return line</font>
<font color="black">  75. </font>
<font color="black">  76. </font>
<font color="green">  77. class WSGIRequest(http.HttpRequest):</font>
<font color="green">  78.     def __init__(self, environ):</font>
<font color="red">  79.         script_name = get_script_name(environ)</font>
<font color="red">  80.         path_info = get_path_info(environ)</font>
<font color="red">  81.         if not path_info:</font>
<font color="black">  82.             # Sometimes PATH_INFO exists, but is empty (e.g. accessing</font>
<font color="black">  83.             # the SCRIPT_NAME URL without a trailing slash). We really need to</font>
<font color="black">  84.             # operate as if they'd requested '/'. Not amazingly nice to force</font>
<font color="black">  85.             # the path like this, but should be harmless.</font>
<font color="red">  86.             path_info = '/'</font>
<font color="red">  87.         self.environ = environ</font>
<font color="red">  88.         self.path_info = path_info</font>
<font color="black">  89.         # be careful to only replace the first slash in the path because of</font>
<font color="black">  90.         # http://test/something and http://test//something being different as</font>
<font color="black">  91.         # stated in http://www.ietf.org/rfc/rfc2396.txt</font>
<font color="red">  92.         self.path = '%s/%s' % (script_name.rstrip('/'),</font>
<font color="red">  93.                                path_info.replace('/', '', 1))</font>
<font color="red">  94.         self.META = environ</font>
<font color="red">  95.         self.META['PATH_INFO'] = path_info</font>
<font color="red">  96.         self.META['SCRIPT_NAME'] = script_name</font>
<font color="red">  97.         self.method = environ['REQUEST_METHOD'].upper()</font>
<font color="red">  98.         _, content_params = cgi.parse_header(environ.get('CONTENT_TYPE', ''))</font>
<font color="red">  99.         if 'charset' in content_params:</font>
<font color="red"> 100.             try:</font>
<font color="red"> 101.                 codecs.lookup(content_params['charset'])</font>
<font color="red"> 102.             except LookupError:</font>
<font color="red"> 103.                 pass</font>
<font color="black"> 104.             else:</font>
<font color="red"> 105.                 self.encoding = content_params['charset']</font>
<font color="red"> 106.         self._post_parse_error = False</font>
<font color="red"> 107.         try:</font>
<font color="red"> 108.             content_length = int(environ.get('CONTENT_LENGTH'))</font>
<font color="red"> 109.         except (ValueError, TypeError):</font>
<font color="red"> 110.             content_length = 0</font>
<font color="red"> 111.         self._stream = LimitedStream(self.environ['wsgi.input'], content_length)</font>
<font color="red"> 112.         self._read_started = False</font>
<font color="red"> 113.         self.resolver_match = None</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def _get_scheme(self):</font>
<font color="red"> 116.         return self.environ.get('wsgi.url_scheme')</font>
<font color="black"> 117. </font>
<font color="green"> 118.     @cached_property</font>
<font color="black"> 119.     def GET(self):</font>
<font color="black"> 120.         # The WSGI spec says 'QUERY_STRING' may be absent.</font>
<font color="red"> 121.         raw_query_string = get_bytes_from_wsgi(self.environ, 'QUERY_STRING', '')</font>
<font color="red"> 122.         return http.QueryDict(raw_query_string, encoding=self._encoding)</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def _get_post(self):</font>
<font color="red"> 125.         if not hasattr(self, '_post'):</font>
<font color="red"> 126.             self._load_post_and_files()</font>
<font color="red"> 127.         return self._post</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def _set_post(self, post):</font>
<font color="red"> 130.         self._post = post</font>
<font color="black"> 131. </font>
<font color="green"> 132.     @cached_property</font>
<font color="black"> 133.     def COOKIES(self):</font>
<font color="red"> 134.         raw_cookie = get_str_from_wsgi(self.environ, 'HTTP_COOKIE', '')</font>
<font color="red"> 135.         return http.parse_cookie(raw_cookie)</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def _get_files(self):</font>
<font color="red"> 138.         if not hasattr(self, '_files'):</font>
<font color="red"> 139.             self._load_post_and_files()</font>
<font color="red"> 140.         return self._files</font>
<font color="black"> 141. </font>
<font color="green"> 142.     POST = property(_get_post, _set_post)</font>
<font color="green"> 143.     FILES = property(_get_files)</font>
<font color="black"> 144. </font>
<font color="black"> 145. </font>
<font color="green"> 146. class WSGIHandler(base.BaseHandler):</font>
<font color="green"> 147.     initLock = Lock()</font>
<font color="green"> 148.     request_class = WSGIRequest</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def __call__(self, environ, start_response):</font>
<font color="black"> 151.         # Set up middleware if needed. We couldn't do this earlier, because</font>
<font color="black"> 152.         # settings weren't available.</font>
<font color="red"> 153.         if self._request_middleware is None:</font>
<font color="red"> 154.             with self.initLock:</font>
<font color="red"> 155.                 try:</font>
<font color="black"> 156.                     # Check that middleware is still uninitialized.</font>
<font color="red"> 157.                     if self._request_middleware is None:</font>
<font color="red"> 158.                         self.load_middleware()</font>
<font color="red"> 159.                 except:</font>
<font color="black"> 160.                     # Unload whatever middleware we got</font>
<font color="red"> 161.                     self._request_middleware = None</font>
<font color="red"> 162.                     raise</font>
<font color="black"> 163. </font>
<font color="red"> 164.         set_script_prefix(get_script_name(environ))</font>
<font color="red"> 165.         signals.request_started.send(sender=self.__class__, environ=environ)</font>
<font color="red"> 166.         try:</font>
<font color="red"> 167.             request = self.request_class(environ)</font>
<font color="red"> 168.         except UnicodeDecodeError:</font>
<font color="red"> 169.             logger.warning('Bad Request (UnicodeDecodeError)',</font>
<font color="red"> 170.                 exc_info=sys.exc_info(),</font>
<font color="red"> 171.                 extra={</font>
<font color="red"> 172.                     'status_code': 400,</font>
<font color="black"> 173.                 }</font>
<font color="black"> 174.             )</font>
<font color="red"> 175.             response = http.HttpResponseBadRequest()</font>
<font color="black"> 176.         else:</font>
<font color="red"> 177.             response = self.get_response(request)</font>
<font color="black"> 178. </font>
<font color="red"> 179.         response._handler_class = self.__class__</font>
<font color="black"> 180. </font>
<font color="red"> 181.         status = '%s %s' % (response.status_code, response.reason_phrase)</font>
<font color="red"> 182.         response_headers = [(str(k), str(v)) for k, v in response.items()]</font>
<font color="red"> 183.         for c in response.cookies.values():</font>
<font color="red"> 184.             response_headers.append((str('Set-Cookie'), str(c.output(header=''))))</font>
<font color="red"> 185.         start_response(force_str(status), response_headers)</font>
<font color="red"> 186.         if getattr(response, 'file_to_stream', None) is not None and environ.get('wsgi.file_wrapper'):</font>
<font color="red"> 187.             response = environ['wsgi.file_wrapper'](response.file_to_stream)</font>
<font color="red"> 188.         return response</font>
<font color="black"> 189. </font>
<font color="black"> 190. </font>
<font color="green"> 191. def get_path_info(environ):</font>
<font color="black"> 192.     &quot;&quot;&quot;</font>
<font color="black"> 193.     Returns the HTTP request's PATH_INFO as a unicode string.</font>
<font color="black"> 194.     &quot;&quot;&quot;</font>
<font color="red"> 195.     path_info = get_bytes_from_wsgi(environ, 'PATH_INFO', '/')</font>
<font color="black"> 196. </font>
<font color="red"> 197.     return path_info.decode(UTF_8)</font>
<font color="black"> 198. </font>
<font color="black"> 199. </font>
<font color="green"> 200. def get_script_name(environ):</font>
<font color="black"> 201.     &quot;&quot;&quot;</font>
<font color="black"> 202.     Returns the equivalent of the HTTP request's SCRIPT_NAME environment</font>
<font color="black"> 203.     variable. If Apache mod_rewrite has been used, returns what would have been</font>
<font color="black"> 204.     the script name prior to any rewriting (so it's the script name as seen</font>
<font color="black"> 205.     from the client's perspective), unless the FORCE_SCRIPT_NAME setting is</font>
<font color="black"> 206.     set (to anything).</font>
<font color="black"> 207.     &quot;&quot;&quot;</font>
<font color="red"> 208.     if settings.FORCE_SCRIPT_NAME is not None:</font>
<font color="red"> 209.         return force_text(settings.FORCE_SCRIPT_NAME)</font>
<font color="black"> 210. </font>
<font color="black"> 211.     # If Apache's mod_rewrite had a whack at the URL, Apache set either</font>
<font color="black"> 212.     # SCRIPT_URL or REDIRECT_URL to the full resource URL before applying any</font>
<font color="black"> 213.     # rewrites. Unfortunately not every Web server (lighttpd!) passes this</font>
<font color="black"> 214.     # information through all the time, so FORCE_SCRIPT_NAME, above, is still</font>
<font color="black"> 215.     # needed.</font>
<font color="red"> 216.     script_url = get_bytes_from_wsgi(environ, 'SCRIPT_URL', '')</font>
<font color="red"> 217.     if not script_url:</font>
<font color="red"> 218.         script_url = get_bytes_from_wsgi(environ, 'REDIRECT_URL', '')</font>
<font color="black"> 219. </font>
<font color="red"> 220.     if script_url:</font>
<font color="red"> 221.         path_info = get_bytes_from_wsgi(environ, 'PATH_INFO', '')</font>
<font color="red"> 222.         script_name = script_url[:-len(path_info)] if path_info else script_url</font>
<font color="black"> 223.     else:</font>
<font color="red"> 224.         script_name = get_bytes_from_wsgi(environ, 'SCRIPT_NAME', '')</font>
<font color="black"> 225. </font>
<font color="red"> 226.     return script_name.decode(UTF_8)</font>
<font color="black"> 227. </font>
<font color="black"> 228. </font>
<font color="green"> 229. def get_bytes_from_wsgi(environ, key, default):</font>
<font color="black"> 230.     &quot;&quot;&quot;</font>
<font color="black"> 231.     Get a value from the WSGI environ dictionary as bytes.</font>
<font color="black"> 232. </font>
<font color="black"> 233.     key and default should be str objects. Under Python 2 they may also be</font>
<font color="black"> 234.     unicode objects provided they only contain ASCII characters.</font>
<font color="black"> 235.     &quot;&quot;&quot;</font>
<font color="red"> 236.     value = environ.get(str(key), str(default))</font>
<font color="black"> 237.     # Under Python 3, non-ASCII values in the WSGI environ are arbitrarily</font>
<font color="black"> 238.     # decoded with ISO-8859-1. This is wrong for Django websites where UTF-8</font>
<font color="black"> 239.     # is the default. Re-encode to recover the original bytestring.</font>
<font color="red"> 240.     return value.encode(ISO_8859_1) if six.PY3 else value</font>
<font color="black"> 241. </font>
<font color="black"> 242. </font>
<font color="green"> 243. def get_str_from_wsgi(environ, key, default):</font>
<font color="black"> 244.     &quot;&quot;&quot;</font>
<font color="black"> 245.     Get a value from the WSGI environ dictionary as str.</font>
<font color="black"> 246. </font>
<font color="black"> 247.     key and default should be str objects. Under Python 2 they may also be</font>
<font color="black"> 248.     unicode objects provided they only contain ASCII characters.</font>
<font color="black"> 249.     &quot;&quot;&quot;</font>
<font color="red"> 250.     value = get_bytes_from_wsgi(environ, key, default)</font>
<font color="red"> 251.     return value.decode(UTF_8, errors='replace') if six.PY3 else value</font>
</pre>

