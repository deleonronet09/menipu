source file: <b>/usr/lib/python2.7/email/header.py</b><br>


file stats: <b>246 lines, 41 executed: 16.7% covered</b>
<pre>
<font color="black">   1. # Copyright (C) 2002-2006 Python Software Foundation</font>
<font color="black">   2. # Author: Ben Gertzfield, Barry Warsaw</font>
<font color="black">   3. # Contact: email-sig@python.org</font>
<font color="black">   4. </font>
<font color="green">   5. &quot;&quot;&quot;Header encoding and decoding functionality.&quot;&quot;&quot;</font>
<font color="black">   6. </font>
<font color="black">   7. __all__ = [</font>
<font color="green">   8.     'Header',</font>
<font color="green">   9.     'decode_header',</font>
<font color="green">  10.     'make_header',</font>
<font color="black">  11.     ]</font>
<font color="black">  12. </font>
<font color="green">  13. import re</font>
<font color="green">  14. import binascii</font>
<font color="black">  15. </font>
<font color="green">  16. import email.quoprimime</font>
<font color="green">  17. import email.base64mime</font>
<font color="black">  18. </font>
<font color="green">  19. from email.errors import HeaderParseError</font>
<font color="green">  20. from email.charset import Charset</font>
<font color="black">  21. </font>
<font color="green">  22. NL = '\n'</font>
<font color="green">  23. SPACE = ' '</font>
<font color="green">  24. USPACE = u' '</font>
<font color="green">  25. SPACE8 = ' ' * 8</font>
<font color="green">  26. UEMPTYSTRING = u''</font>
<font color="black">  27. </font>
<font color="green">  28. MAXLINELEN = 76</font>
<font color="black">  29. </font>
<font color="green">  30. USASCII = Charset('us-ascii')</font>
<font color="green">  31. UTF8 = Charset('utf-8')</font>
<font color="black">  32. </font>
<font color="black">  33. # Match encoded-word strings in the form =?charset?q?Hello_World?=</font>
<font color="green">  34. ecre = re.compile(r'''</font>
<font color="black">  35.   =\?                   # literal =?</font>
<font color="black">  36.   (?P&lt;charset&gt;[^?]*?)   # non-greedy up to the next ? is the charset</font>
<font color="black">  37.   \?                    # literal ?</font>
<font color="black">  38.   (?P&lt;encoding&gt;[qb])    # either a &quot;q&quot; or a &quot;b&quot;, case insensitive</font>
<font color="black">  39.   \?                    # literal ?</font>
<font color="black">  40.   (?P&lt;encoded&gt;.*?)      # non-greedy up to the next ?= is the encoded string</font>
<font color="black">  41.   \?=                   # literal ?=</font>
<font color="black">  42.   (?=[ \t]|$)           # whitespace or the end of the string</font>
<font color="green">  43.   ''', re.VERBOSE | re.IGNORECASE | re.MULTILINE)</font>
<font color="black">  44. </font>
<font color="black">  45. # Field name regexp, including trailing colon, but not separating whitespace,</font>
<font color="black">  46. # according to RFC 2822.  Character range is from tilde to exclamation mark.</font>
<font color="black">  47. # For use with .match()</font>
<font color="green">  48. fcre = re.compile(r'[\041-\176]+:$')</font>
<font color="black">  49. </font>
<font color="black">  50. # Find a header embedded in a putative header value.  Used to check for</font>
<font color="black">  51. # header injection attack.</font>
<font color="green">  52. _embeded_header = re.compile(r'\n[^ \t]+:')</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="black">  55. </font>
<font color="black">  56. # Helpers</font>
<font color="green">  57. _max_append = email.quoprimime._max_append</font>
<font color="black">  58. </font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="green">  61. def decode_header(header):</font>
<font color="black">  62.     &quot;&quot;&quot;Decode a message header value without converting charset.</font>
<font color="black">  63. </font>
<font color="black">  64.     Returns a list of (decoded_string, charset) pairs containing each of the</font>
<font color="black">  65.     decoded parts of the header.  Charset is None for non-encoded parts of the</font>
<font color="black">  66.     header, otherwise a lower-case string containing the name of the character</font>
<font color="black">  67.     set specified in the encoded string.</font>
<font color="black">  68. </font>
<font color="black">  69.     An email.errors.HeaderParseError may be raised when certain decoding error</font>
<font color="black">  70.     occurs (e.g. a base64 decoding exception).</font>
<font color="black">  71.     &quot;&quot;&quot;</font>
<font color="black">  72.     # If no encoding, just return the header</font>
<font color="red">  73.     header = str(header)</font>
<font color="red">  74.     if not ecre.search(header):</font>
<font color="red">  75.         return [(header, None)]</font>
<font color="red">  76.     decoded = []</font>
<font color="red">  77.     dec = ''</font>
<font color="red">  78.     for line in header.splitlines():</font>
<font color="black">  79.         # This line might not have an encoding in it</font>
<font color="red">  80.         if not ecre.search(line):</font>
<font color="red">  81.             decoded.append((line, None))</font>
<font color="red">  82.             continue</font>
<font color="red">  83.         parts = ecre.split(line)</font>
<font color="red">  84.         while parts:</font>
<font color="red">  85.             unenc = parts.pop(0).strip()</font>
<font color="red">  86.             if unenc:</font>
<font color="black">  87.                 # Should we continue a long line?</font>
<font color="red">  88.                 if decoded and decoded[-1][1] is None:</font>
<font color="red">  89.                     decoded[-1] = (decoded[-1][0] + SPACE + unenc, None)</font>
<font color="black">  90.                 else:</font>
<font color="red">  91.                     decoded.append((unenc, None))</font>
<font color="red">  92.             if parts:</font>
<font color="red">  93.                 charset, encoding = [s.lower() for s in parts[0:2]]</font>
<font color="red">  94.                 encoded = parts[2]</font>
<font color="red">  95.                 dec = None</font>
<font color="red">  96.                 if encoding == 'q':</font>
<font color="red">  97.                     dec = email.quoprimime.header_decode(encoded)</font>
<font color="red">  98.                 elif encoding == 'b':</font>
<font color="red">  99.                     paderr = len(encoded) % 4   # Postel's law: add missing padding</font>
<font color="red"> 100.                     if paderr:</font>
<font color="red"> 101.                         encoded += '==='[:4 - paderr]</font>
<font color="red"> 102.                     try:</font>
<font color="red"> 103.                         dec = email.base64mime.decode(encoded)</font>
<font color="red"> 104.                     except binascii.Error:</font>
<font color="black"> 105.                         # Turn this into a higher level exception.  BAW: Right</font>
<font color="black"> 106.                         # now we throw the lower level exception away but</font>
<font color="black"> 107.                         # when/if we get exception chaining, we'll preserve it.</font>
<font color="red"> 108.                         raise HeaderParseError</font>
<font color="red"> 109.                 if dec is None:</font>
<font color="red"> 110.                     dec = encoded</font>
<font color="black"> 111. </font>
<font color="red"> 112.                 if decoded and decoded[-1][1] == charset:</font>
<font color="red"> 113.                     decoded[-1] = (decoded[-1][0] + dec, decoded[-1][1])</font>
<font color="black"> 114.                 else:</font>
<font color="red"> 115.                     decoded.append((dec, charset))</font>
<font color="red"> 116.             del parts[0:3]</font>
<font color="red"> 117.     return decoded</font>
<font color="black"> 118. </font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="green"> 121. def make_header(decoded_seq, maxlinelen=None, header_name=None,</font>
<font color="green"> 122.                 continuation_ws=' '):</font>
<font color="black"> 123.     &quot;&quot;&quot;Create a Header from a sequence of pairs as returned by decode_header()</font>
<font color="black"> 124. </font>
<font color="black"> 125.     decode_header() takes a header value string and returns a sequence of</font>
<font color="black"> 126.     pairs of the format (decoded_string, charset) where charset is the string</font>
<font color="black"> 127.     name of the character set.</font>
<font color="black"> 128. </font>
<font color="black"> 129.     This function takes one of those sequence of pairs and returns a Header</font>
<font color="black"> 130.     instance.  Optional maxlinelen, header_name, and continuation_ws are as in</font>
<font color="black"> 131.     the Header constructor.</font>
<font color="black"> 132.     &quot;&quot;&quot;</font>
<font color="red"> 133.     h = Header(maxlinelen=maxlinelen, header_name=header_name,</font>
<font color="red"> 134.                continuation_ws=continuation_ws)</font>
<font color="red"> 135.     for s, charset in decoded_seq:</font>
<font color="black"> 136.         # None means us-ascii but we can simply pass it on to h.append()</font>
<font color="red"> 137.         if charset is not None and not isinstance(charset, Charset):</font>
<font color="red"> 138.             charset = Charset(charset)</font>
<font color="red"> 139.         h.append(s, charset)</font>
<font color="red"> 140.     return h</font>
<font color="black"> 141. </font>
<font color="black"> 142. </font>
<font color="black"> 143. </font>
<font color="green"> 144. class Header:</font>
<font color="green"> 145.     def __init__(self, s=None, charset=None,</font>
<font color="green"> 146.                  maxlinelen=None, header_name=None,</font>
<font color="green"> 147.                  continuation_ws=' ', errors='strict'):</font>
<font color="black"> 148.         &quot;&quot;&quot;Create a MIME-compliant header that can contain many character sets.</font>
<font color="black"> 149. </font>
<font color="black"> 150.         Optional s is the initial header value.  If None, the initial header</font>
<font color="black"> 151.         value is not set.  You can later append to the header with .append()</font>
<font color="black"> 152.         method calls.  s may be a byte string or a Unicode string, but see the</font>
<font color="black"> 153.         .append() documentation for semantics.</font>
<font color="black"> 154. </font>
<font color="black"> 155.         Optional charset serves two purposes: it has the same meaning as the</font>
<font color="black"> 156.         charset argument to the .append() method.  It also sets the default</font>
<font color="black"> 157.         character set for all subsequent .append() calls that omit the charset</font>
<font color="black"> 158.         argument.  If charset is not provided in the constructor, the us-ascii</font>
<font color="black"> 159.         charset is used both as s's initial charset and as the default for</font>
<font color="black"> 160.         subsequent .append() calls.</font>
<font color="black"> 161. </font>
<font color="black"> 162.         The maximum line length can be specified explicit via maxlinelen.  For</font>
<font color="black"> 163.         splitting the first line to a shorter value (to account for the field</font>
<font color="black"> 164.         header which isn't included in s, e.g. `Subject') pass in the name of</font>
<font color="black"> 165.         the field in header_name.  The default maxlinelen is 76.</font>
<font color="black"> 166. </font>
<font color="black"> 167.         continuation_ws must be RFC 2822 compliant folding whitespace (usually</font>
<font color="black"> 168.         either a space or a hard tab) which will be prepended to continuation</font>
<font color="black"> 169.         lines.</font>
<font color="black"> 170. </font>
<font color="black"> 171.         errors is passed through to the .append() call.</font>
<font color="black"> 172.         &quot;&quot;&quot;</font>
<font color="red"> 173.         if charset is None:</font>
<font color="red"> 174.             charset = USASCII</font>
<font color="red"> 175.         if not isinstance(charset, Charset):</font>
<font color="red"> 176.             charset = Charset(charset)</font>
<font color="red"> 177.         self._charset = charset</font>
<font color="red"> 178.         self._continuation_ws = continuation_ws</font>
<font color="red"> 179.         cws_expanded_len = len(continuation_ws.replace('\t', SPACE8))</font>
<font color="black"> 180.         # BAW: I believe `chunks' and `maxlinelen' should be non-public.</font>
<font color="red"> 181.         self._chunks = []</font>
<font color="red"> 182.         if s is not None:</font>
<font color="red"> 183.             self.append(s, charset, errors)</font>
<font color="red"> 184.         if maxlinelen is None:</font>
<font color="red"> 185.             maxlinelen = MAXLINELEN</font>
<font color="red"> 186.         if header_name is None:</font>
<font color="black"> 187.             # We don't know anything about the field header so the first line</font>
<font color="black"> 188.             # is the same length as subsequent lines.</font>
<font color="red"> 189.             self._firstlinelen = maxlinelen</font>
<font color="black"> 190.         else:</font>
<font color="black"> 191.             # The first line should be shorter to take into account the field</font>
<font color="black"> 192.             # header.  Also subtract off 2 extra for the colon and space.</font>
<font color="red"> 193.             self._firstlinelen = maxlinelen - len(header_name) - 2</font>
<font color="black"> 194.         # Second and subsequent lines should subtract off the length in</font>
<font color="black"> 195.         # columns of the continuation whitespace prefix.</font>
<font color="red"> 196.         self._maxlinelen = maxlinelen - cws_expanded_len</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def __str__(self):</font>
<font color="black"> 199.         &quot;&quot;&quot;A synonym for self.encode().&quot;&quot;&quot;</font>
<font color="red"> 200.         return self.encode()</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def __unicode__(self):</font>
<font color="black"> 203.         &quot;&quot;&quot;Helper for the built-in unicode function.&quot;&quot;&quot;</font>
<font color="red"> 204.         uchunks = []</font>
<font color="red"> 205.         lastcs = None</font>
<font color="red"> 206.         for s, charset in self._chunks:</font>
<font color="black"> 207.             # We must preserve spaces between encoded and non-encoded word</font>
<font color="black"> 208.             # boundaries, which means for us we need to add a space when we go</font>
<font color="black"> 209.             # from a charset to None/us-ascii, or from None/us-ascii to a</font>
<font color="black"> 210.             # charset.  Only do this for the second and subsequent chunks.</font>
<font color="red"> 211.             nextcs = charset</font>
<font color="red"> 212.             if uchunks:</font>
<font color="red"> 213.                 if lastcs not in (None, 'us-ascii'):</font>
<font color="red"> 214.                     if nextcs in (None, 'us-ascii'):</font>
<font color="red"> 215.                         uchunks.append(USPACE)</font>
<font color="red"> 216.                         nextcs = None</font>
<font color="red"> 217.                 elif nextcs not in (None, 'us-ascii'):</font>
<font color="red"> 218.                     uchunks.append(USPACE)</font>
<font color="red"> 219.             lastcs = nextcs</font>
<font color="red"> 220.             uchunks.append(unicode(s, str(charset)))</font>
<font color="red"> 221.         return UEMPTYSTRING.join(uchunks)</font>
<font color="black"> 222. </font>
<font color="black"> 223.     # Rich comparison operators for equality only.  BAW: does it make sense to</font>
<font color="black"> 224.     # have or explicitly disable &lt;, &lt;=, &gt;, &gt;= operators?</font>
<font color="green"> 225.     def __eq__(self, other):</font>
<font color="black"> 226.         # other may be a Header or a string.  Both are fine so coerce</font>
<font color="black"> 227.         # ourselves to a string, swap the args and do another comparison.</font>
<font color="red"> 228.         return other == self.encode()</font>
<font color="black"> 229. </font>
<font color="green"> 230.     def __ne__(self, other):</font>
<font color="red"> 231.         return not self == other</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def append(self, s, charset=None, errors='strict'):</font>
<font color="black"> 234.         &quot;&quot;&quot;Append a string to the MIME header.</font>
<font color="black"> 235. </font>
<font color="black"> 236.         Optional charset, if given, should be a Charset instance or the name</font>
<font color="black"> 237.         of a character set (which will be converted to a Charset instance).  A</font>
<font color="black"> 238.         value of None (the default) means that the charset given in the</font>
<font color="black"> 239.         constructor is used.</font>
<font color="black"> 240. </font>
<font color="black"> 241.         s may be a byte string or a Unicode string.  If it is a byte string</font>
<font color="black"> 242.         (i.e. isinstance(s, str) is true), then charset is the encoding of</font>
<font color="black"> 243.         that byte string, and a UnicodeError will be raised if the string</font>
<font color="black"> 244.         cannot be decoded with that charset.  If s is a Unicode string, then</font>
<font color="black"> 245.         charset is a hint specifying the character set of the characters in</font>
<font color="black"> 246.         the string.  In this case, when producing an RFC 2822 compliant header</font>
<font color="black"> 247.         using RFC 2047 rules, the Unicode string will be encoded using the</font>
<font color="black"> 248.         following charsets in order: us-ascii, the charset hint, utf-8.  The</font>
<font color="black"> 249.         first character set not to provoke a UnicodeError is used.</font>
<font color="black"> 250. </font>
<font color="black"> 251.         Optional `errors' is passed as the third argument to any unicode() or</font>
<font color="black"> 252.         ustr.encode() call.</font>
<font color="black"> 253.         &quot;&quot;&quot;</font>
<font color="red"> 254.         if charset is None:</font>
<font color="red"> 255.             charset = self._charset</font>
<font color="red"> 256.         elif not isinstance(charset, Charset):</font>
<font color="red"> 257.             charset = Charset(charset)</font>
<font color="black"> 258.         # If the charset is our faux 8bit charset, leave the string unchanged</font>
<font color="red"> 259.         if charset != '8bit':</font>
<font color="black"> 260.             # We need to test that the string can be converted to unicode and</font>
<font color="black"> 261.             # back to a byte string, given the input and output codecs of the</font>
<font color="black"> 262.             # charset.</font>
<font color="red"> 263.             if isinstance(s, str):</font>
<font color="black"> 264.                 # Possibly raise UnicodeError if the byte string can't be</font>
<font color="black"> 265.                 # converted to a unicode with the input codec of the charset.</font>
<font color="red"> 266.                 incodec = charset.input_codec or 'us-ascii'</font>
<font color="red"> 267.                 ustr = unicode(s, incodec, errors)</font>
<font color="black"> 268.                 # Now make sure that the unicode could be converted back to a</font>
<font color="black"> 269.                 # byte string with the output codec, which may be different</font>
<font color="black"> 270.                 # than the iput coded.  Still, use the original byte string.</font>
<font color="red"> 271.                 outcodec = charset.output_codec or 'us-ascii'</font>
<font color="red"> 272.                 ustr.encode(outcodec, errors)</font>
<font color="red"> 273.             elif isinstance(s, unicode):</font>
<font color="black"> 274.                 # Now we have to be sure the unicode string can be converted</font>
<font color="black"> 275.                 # to a byte string with a reasonable output codec.  We want to</font>
<font color="black"> 276.                 # use the byte string in the chunk.</font>
<font color="red"> 277.                 for charset in USASCII, charset, UTF8:</font>
<font color="red"> 278.                     try:</font>
<font color="red"> 279.                         outcodec = charset.output_codec or 'us-ascii'</font>
<font color="red"> 280.                         s = s.encode(outcodec, errors)</font>
<font color="red"> 281.                         break</font>
<font color="red"> 282.                     except UnicodeError:</font>
<font color="red"> 283.                         pass</font>
<font color="black"> 284.                 else:</font>
<font color="red"> 285.                     assert False, 'utf-8 conversion failed'</font>
<font color="red"> 286.         self._chunks.append((s, charset))</font>
<font color="black"> 287. </font>
<font color="green"> 288.     def _split(self, s, charset, maxlinelen, splitchars):</font>
<font color="black"> 289.         # Split up a header safely for use with encode_chunks.</font>
<font color="red"> 290.         splittable = charset.to_splittable(s)</font>
<font color="red"> 291.         encoded = charset.from_splittable(splittable, True)</font>
<font color="red"> 292.         elen = charset.encoded_header_len(encoded)</font>
<font color="black"> 293.         # If the line's encoded length first, just return it</font>
<font color="red"> 294.         if elen &lt;= maxlinelen:</font>
<font color="red"> 295.             return [(encoded, charset)]</font>
<font color="black"> 296.         # If we have undetermined raw 8bit characters sitting in a byte</font>
<font color="black"> 297.         # string, we really don't know what the right thing to do is.  We</font>
<font color="black"> 298.         # can't really split it because it might be multibyte data which we</font>
<font color="black"> 299.         # could break if we split it between pairs.  The least harm seems to</font>
<font color="black"> 300.         # be to not split the header at all, but that means they could go out</font>
<font color="black"> 301.         # longer than maxlinelen.</font>
<font color="red"> 302.         if charset == '8bit':</font>
<font color="red"> 303.             return [(s, charset)]</font>
<font color="black"> 304.         # BAW: I'm not sure what the right test here is.  What we're trying to</font>
<font color="black"> 305.         # do is be faithful to RFC 2822's recommendation that ($2.2.3):</font>
<font color="black"> 306.         #</font>
<font color="black"> 307.         # &quot;Note: Though structured field bodies are defined in such a way that</font>
<font color="black"> 308.         #  folding can take place between many of the lexical tokens (and even</font>
<font color="black"> 309.         #  within some of the lexical tokens), folding SHOULD be limited to</font>
<font color="black"> 310.         #  placing the CRLF at higher-level syntactic breaks.&quot;</font>
<font color="black"> 311.         #</font>
<font color="black"> 312.         # For now, I can only imagine doing this when the charset is us-ascii,</font>
<font color="black"> 313.         # although it's possible that other charsets may also benefit from the</font>
<font color="black"> 314.         # higher-level syntactic breaks.</font>
<font color="red"> 315.         elif charset == 'us-ascii':</font>
<font color="red"> 316.             return self._split_ascii(s, charset, maxlinelen, splitchars)</font>
<font color="black"> 317.         # BAW: should we use encoded?</font>
<font color="red"> 318.         elif elen == len(s):</font>
<font color="black"> 319.             # We can split on _maxlinelen boundaries because we know that the</font>
<font color="black"> 320.             # encoding won't change the size of the string</font>
<font color="red"> 321.             splitpnt = maxlinelen</font>
<font color="red"> 322.             first = charset.from_splittable(splittable[:splitpnt], False)</font>
<font color="red"> 323.             last = charset.from_splittable(splittable[splitpnt:], False)</font>
<font color="black"> 324.         else:</font>
<font color="black"> 325.             # Binary search for split point</font>
<font color="red"> 326.             first, last = _binsplit(splittable, charset, maxlinelen)</font>
<font color="black"> 327.         # first is of the proper length so just wrap it in the appropriate</font>
<font color="black"> 328.         # chrome.  last must be recursively split.</font>
<font color="red"> 329.         fsplittable = charset.to_splittable(first)</font>
<font color="red"> 330.         fencoded = charset.from_splittable(fsplittable, True)</font>
<font color="red"> 331.         chunk = [(fencoded, charset)]</font>
<font color="red"> 332.         return chunk + self._split(last, charset, self._maxlinelen, splitchars)</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def _split_ascii(self, s, charset, firstlen, splitchars):</font>
<font color="red"> 335.         chunks = _split_ascii(s, firstlen, self._maxlinelen,</font>
<font color="red"> 336.                               self._continuation_ws, splitchars)</font>
<font color="red"> 337.         return zip(chunks, [charset]*len(chunks))</font>
<font color="black"> 338. </font>
<font color="green"> 339.     def _encode_chunks(self, newchunks, maxlinelen):</font>
<font color="black"> 340.         # MIME-encode a header with many different charsets and/or encodings.</font>
<font color="black"> 341.         #</font>
<font color="black"> 342.         # Given a list of pairs (string, charset), return a MIME-encoded</font>
<font color="black"> 343.         # string suitable for use in a header field.  Each pair may have</font>
<font color="black"> 344.         # different charsets and/or encodings, and the resulting header will</font>
<font color="black"> 345.         # accurately reflect each setting.</font>
<font color="black"> 346.         #</font>
<font color="black"> 347.         # Each encoding can be email.utils.QP (quoted-printable, for</font>
<font color="black"> 348.         # ASCII-like character sets like iso-8859-1), email.utils.BASE64</font>
<font color="black"> 349.         # (Base64, for non-ASCII like character sets like KOI8-R and</font>
<font color="black"> 350.         # iso-2022-jp), or None (no encoding).</font>
<font color="black"> 351.         #</font>
<font color="black"> 352.         # Each pair will be represented on a separate line; the resulting</font>
<font color="black"> 353.         # string will be in the format:</font>
<font color="black"> 354.         #</font>
<font color="black"> 355.         # =?charset1?q?Mar=EDa_Gonz=E1lez_Alonso?=\n</font>
<font color="black"> 356.         #  =?charset2?b?SvxyZ2VuIEL2aW5n?=&quot;</font>
<font color="red"> 357.         chunks = []</font>
<font color="red"> 358.         for header, charset in newchunks:</font>
<font color="red"> 359.             if not header:</font>
<font color="red"> 360.                 continue</font>
<font color="red"> 361.             if charset is None or charset.header_encoding is None:</font>
<font color="red"> 362.                 s = header</font>
<font color="black"> 363.             else:</font>
<font color="red"> 364.                 s = charset.header_encode(header)</font>
<font color="black"> 365.             # Don't add more folding whitespace than necessary</font>
<font color="red"> 366.             if chunks and chunks[-1].endswith(' '):</font>
<font color="red"> 367.                 extra = ''</font>
<font color="black"> 368.             else:</font>
<font color="red"> 369.                 extra = ' '</font>
<font color="red"> 370.             _max_append(chunks, s, maxlinelen, extra)</font>
<font color="red"> 371.         joiner = NL + self._continuation_ws</font>
<font color="red"> 372.         return joiner.join(chunks)</font>
<font color="black"> 373. </font>
<font color="green"> 374.     def encode(self, splitchars=';, '):</font>
<font color="black"> 375.         &quot;&quot;&quot;Encode a message header into an RFC-compliant format.</font>
<font color="black"> 376. </font>
<font color="black"> 377.         There are many issues involved in converting a given string for use in</font>
<font color="black"> 378.         an email header.  Only certain character sets are readable in most</font>
<font color="black"> 379.         email clients, and as header strings can only contain a subset of</font>
<font color="black"> 380.         7-bit ASCII, care must be taken to properly convert and encode (with</font>
<font color="black"> 381.         Base64 or quoted-printable) header strings.  In addition, there is a</font>
<font color="black"> 382.         75-character length limit on any given encoded header field, so</font>
<font color="black"> 383.         line-wrapping must be performed, even with double-byte character sets.</font>
<font color="black"> 384. </font>
<font color="black"> 385.         This method will do its best to convert the string to the correct</font>
<font color="black"> 386.         character set used in email, and encode and line wrap it safely with</font>
<font color="black"> 387.         the appropriate scheme for that character set.</font>
<font color="black"> 388. </font>
<font color="black"> 389.         If the given charset is not known or an error occurs during</font>
<font color="black"> 390.         conversion, this function will return the header untouched.</font>
<font color="black"> 391. </font>
<font color="black"> 392.         Optional splitchars is a string containing characters to split long</font>
<font color="black"> 393.         ASCII lines on, in rough support of RFC 2822's `highest level</font>
<font color="black"> 394.         syntactic breaks'.  This doesn't affect RFC 2047 encoded lines.</font>
<font color="black"> 395.         &quot;&quot;&quot;</font>
<font color="red"> 396.         newchunks = []</font>
<font color="red"> 397.         maxlinelen = self._firstlinelen</font>
<font color="red"> 398.         lastlen = 0</font>
<font color="red"> 399.         for s, charset in self._chunks:</font>
<font color="black"> 400.             # The first bit of the next chunk should be just long enough to</font>
<font color="black"> 401.             # fill the next line.  Don't forget the space separating the</font>
<font color="black"> 402.             # encoded words.</font>
<font color="red"> 403.             targetlen = maxlinelen - lastlen - 1</font>
<font color="red"> 404.             if targetlen &lt; charset.encoded_header_len(''):</font>
<font color="black"> 405.                 # Stick it on the next line</font>
<font color="red"> 406.                 targetlen = maxlinelen</font>
<font color="red"> 407.             newchunks += self._split(s, charset, targetlen, splitchars)</font>
<font color="red"> 408.             lastchunk, lastcharset = newchunks[-1]</font>
<font color="red"> 409.             lastlen = lastcharset.encoded_header_len(lastchunk)</font>
<font color="red"> 410.         value = self._encode_chunks(newchunks, maxlinelen)</font>
<font color="red"> 411.         if _embeded_header.search(value):</font>
<font color="red"> 412.             raise HeaderParseError(&quot;header value appears to contain &quot;</font>
<font color="red"> 413.                 &quot;an embedded header: {!r}&quot;.format(value))</font>
<font color="red"> 414.         return value</font>
<font color="black"> 415. </font>
<font color="black"> 416. </font>
<font color="black"> 417. </font>
<font color="green"> 418. def _split_ascii(s, firstlen, restlen, continuation_ws, splitchars):</font>
<font color="red"> 419.     lines = []</font>
<font color="red"> 420.     maxlen = firstlen</font>
<font color="red"> 421.     for line in s.splitlines():</font>
<font color="black"> 422.         # Ignore any leading whitespace (i.e. continuation whitespace) already</font>
<font color="black"> 423.         # on the line, since we'll be adding our own.</font>
<font color="red"> 424.         line = line.lstrip()</font>
<font color="red"> 425.         if len(line) &lt; maxlen:</font>
<font color="red"> 426.             lines.append(line)</font>
<font color="red"> 427.             maxlen = restlen</font>
<font color="red"> 428.             continue</font>
<font color="black"> 429.         # Attempt to split the line at the highest-level syntactic break</font>
<font color="black"> 430.         # possible.  Note that we don't have a lot of smarts about field</font>
<font color="black"> 431.         # syntax; we just try to break on semi-colons, then commas, then</font>
<font color="black"> 432.         # whitespace.</font>
<font color="red"> 433.         for ch in splitchars:</font>
<font color="red"> 434.             if ch in line:</font>
<font color="red"> 435.                 break</font>
<font color="black"> 436.         else:</font>
<font color="black"> 437.             # There's nothing useful to split the line on, not even spaces, so</font>
<font color="black"> 438.             # just append this line unchanged</font>
<font color="red"> 439.             lines.append(line)</font>
<font color="red"> 440.             maxlen = restlen</font>
<font color="red"> 441.             continue</font>
<font color="black"> 442.         # Now split the line on the character plus trailing whitespace</font>
<font color="red"> 443.         cre = re.compile(r'%s\s*' % ch)</font>
<font color="red"> 444.         if ch in ';,':</font>
<font color="red"> 445.             eol = ch</font>
<font color="black"> 446.         else:</font>
<font color="red"> 447.             eol = ''</font>
<font color="red"> 448.         joiner = eol + ' '</font>
<font color="red"> 449.         joinlen = len(joiner)</font>
<font color="red"> 450.         wslen = len(continuation_ws.replace('\t', SPACE8))</font>
<font color="red"> 451.         this = []</font>
<font color="red"> 452.         linelen = 0</font>
<font color="red"> 453.         for part in cre.split(line):</font>
<font color="red"> 454.             curlen = linelen + max(0, len(this)-1) * joinlen</font>
<font color="red"> 455.             partlen = len(part)</font>
<font color="red"> 456.             onfirstline = not lines</font>
<font color="black"> 457.             # We don't want to split after the field name, if we're on the</font>
<font color="black"> 458.             # first line and the field name is present in the header string.</font>
<font color="red"> 459.             if ch == ' ' and onfirstline and \</font>
<font color="red"> 460.                    len(this) == 1 and fcre.match(this[0]):</font>
<font color="red"> 461.                 this.append(part)</font>
<font color="red"> 462.                 linelen += partlen</font>
<font color="red"> 463.             elif curlen + partlen &gt; maxlen:</font>
<font color="red"> 464.                 if this:</font>
<font color="red"> 465.                     lines.append(joiner.join(this) + eol)</font>
<font color="black"> 466.                 # If this part is longer than maxlen and we aren't already</font>
<font color="black"> 467.                 # splitting on whitespace, try to recursively split this line</font>
<font color="black"> 468.                 # on whitespace.</font>
<font color="red"> 469.                 if partlen &gt; maxlen and ch != ' ':</font>
<font color="red"> 470.                     subl = _split_ascii(part, maxlen, restlen,</font>
<font color="red"> 471.                                         continuation_ws, ' ')</font>
<font color="red"> 472.                     lines.extend(subl[:-1])</font>
<font color="red"> 473.                     this = [subl[-1]]</font>
<font color="black"> 474.                 else:</font>
<font color="red"> 475.                     this = [part]</font>
<font color="red"> 476.                 linelen = wslen + len(this[-1])</font>
<font color="red"> 477.                 maxlen = restlen</font>
<font color="black"> 478.             else:</font>
<font color="red"> 479.                 this.append(part)</font>
<font color="red"> 480.                 linelen += partlen</font>
<font color="black"> 481.         # Put any left over parts on a line by themselves</font>
<font color="red"> 482.         if this:</font>
<font color="red"> 483.             lines.append(joiner.join(this))</font>
<font color="red"> 484.     return lines</font>
<font color="black"> 485. </font>
<font color="black"> 486. </font>
<font color="black"> 487. </font>
<font color="green"> 488. def _binsplit(splittable, charset, maxlinelen):</font>
<font color="red"> 489.     i = 0</font>
<font color="red"> 490.     j = len(splittable)</font>
<font color="red"> 491.     while i &lt; j:</font>
<font color="black"> 492.         # Invariants:</font>
<font color="black"> 493.         # 1. splittable[:k] fits for all k &lt;= i (note that we *assume*,</font>
<font color="black"> 494.         #    at the start, that splittable[:0] fits).</font>
<font color="black"> 495.         # 2. splittable[:k] does not fit for any k &gt; j (at the start,</font>
<font color="black"> 496.         #    this means we shouldn't look at any k &gt; len(splittable)).</font>
<font color="black"> 497.         # 3. We don't know about splittable[:k] for k in i+1..j.</font>
<font color="black"> 498.         # 4. We want to set i to the largest k that fits, with i &lt;= k &lt;= j.</font>
<font color="black"> 499.         #</font>
<font color="red"> 500.         m = (i+j+1) &gt;&gt; 1  # ceiling((i+j)/2); i &lt; m &lt;= j</font>
<font color="red"> 501.         chunk = charset.from_splittable(splittable[:m], True)</font>
<font color="red"> 502.         chunklen = charset.encoded_header_len(chunk)</font>
<font color="red"> 503.         if chunklen &lt;= maxlinelen:</font>
<font color="black"> 504.             # m is acceptable, so is a new lower bound.</font>
<font color="red"> 505.             i = m</font>
<font color="black"> 506.         else:</font>
<font color="black"> 507.             # m is not acceptable, so final i must be &lt; m.</font>
<font color="red"> 508.             j = m - 1</font>
<font color="black"> 509.     # i == j.  Invariant #1 implies that splittable[:i] fits, and</font>
<font color="black"> 510.     # invariant #2 implies that splittable[:i+1] does not fit, so i</font>
<font color="black"> 511.     # is what we're looking for.</font>
<font color="red"> 512.     first = charset.from_splittable(splittable[:i], False)</font>
<font color="red"> 513.     last  = charset.from_splittable(splittable[i:], False)</font>
<font color="red"> 514.     return first, last</font>
</pre>

