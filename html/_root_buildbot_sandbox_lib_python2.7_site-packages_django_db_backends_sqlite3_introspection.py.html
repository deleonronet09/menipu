source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/sqlite3/introspection.py</b><br>


file stats: <b>156 lines, 40 executed: 25.6% covered</b>
<pre>
<font color="green">   1. import re</font>
<font color="green">   2. from collections import namedtuple</font>
<font color="black">   3. </font>
<font color="green">   4. from django.db.backends.base.introspection import (</font>
<font color="black">   5.     BaseDatabaseIntrospection, FieldInfo, TableInfo,</font>
<font color="black">   6. )</font>
<font color="black">   7. </font>
<font color="green">   8. field_size_re = re.compile(r'^\s*(?:var)?char\s*\(\s*(\d+)\s*\)\s*$')</font>
<font color="green">   9. FieldInfo = namedtuple('FieldInfo', FieldInfo._fields + ('default',))</font>
<font color="black">  10. </font>
<font color="black">  11. </font>
<font color="green">  12. def get_field_size(name):</font>
<font color="black">  13.     &quot;&quot;&quot; Extract the size number from a &quot;varchar(11)&quot; type name &quot;&quot;&quot;</font>
<font color="red">  14.     m = field_size_re.search(name)</font>
<font color="red">  15.     return int(m.group(1)) if m else None</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="black">  18. # This light wrapper &quot;fakes&quot; a dictionary interface, because some SQLite data</font>
<font color="black">  19. # types include variables in them -- e.g. &quot;varchar(30)&quot; -- and can't be matched</font>
<font color="black">  20. # as a simple dictionary lookup.</font>
<font color="green">  21. class FlexibleFieldLookupDict(object):</font>
<font color="black">  22.     # Maps SQL types to Django Field types. Some of the SQL types have multiple</font>
<font color="black">  23.     # entries here because SQLite allows for anything and doesn't normalize the</font>
<font color="black">  24.     # field type; it uses whatever was given.</font>
<font color="green">  25.     base_data_types_reverse = {</font>
<font color="green">  26.         'bool': 'BooleanField',</font>
<font color="green">  27.         'boolean': 'BooleanField',</font>
<font color="green">  28.         'smallint': 'SmallIntegerField',</font>
<font color="green">  29.         'smallint unsigned': 'PositiveSmallIntegerField',</font>
<font color="green">  30.         'smallinteger': 'SmallIntegerField',</font>
<font color="green">  31.         'int': 'IntegerField',</font>
<font color="green">  32.         'integer': 'IntegerField',</font>
<font color="green">  33.         'bigint': 'BigIntegerField',</font>
<font color="green">  34.         'integer unsigned': 'PositiveIntegerField',</font>
<font color="green">  35.         'decimal': 'DecimalField',</font>
<font color="green">  36.         'real': 'FloatField',</font>
<font color="green">  37.         'text': 'TextField',</font>
<font color="green">  38.         'char': 'CharField',</font>
<font color="green">  39.         'blob': 'BinaryField',</font>
<font color="green">  40.         'date': 'DateField',</font>
<font color="green">  41.         'datetime': 'DateTimeField',</font>
<font color="green">  42.         'time': 'TimeField',</font>
<font color="black">  43.     }</font>
<font color="black">  44. </font>
<font color="green">  45.     def __getitem__(self, key):</font>
<font color="red">  46.         key = key.lower()</font>
<font color="red">  47.         try:</font>
<font color="red">  48.             return self.base_data_types_reverse[key]</font>
<font color="red">  49.         except KeyError:</font>
<font color="red">  50.             size = get_field_size(key)</font>
<font color="red">  51.             if size is not None:</font>
<font color="red">  52.                 return ('CharField', {'max_length': size})</font>
<font color="red">  53.             raise KeyError</font>
<font color="black">  54. </font>
<font color="black">  55. </font>
<font color="green">  56. class DatabaseIntrospection(BaseDatabaseIntrospection):</font>
<font color="green">  57.     data_types_reverse = FlexibleFieldLookupDict()</font>
<font color="black">  58. </font>
<font color="green">  59.     def get_table_list(self, cursor):</font>
<font color="black">  60.         &quot;&quot;&quot;</font>
<font color="black">  61.         Returns a list of table and view names in the current database.</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="black">  63.         # Skip the sqlite_sequence system table used for autoincrement key</font>
<font color="black">  64.         # generation.</font>
<font color="green">  65.         cursor.execute(&quot;&quot;&quot;</font>
<font color="black">  66.             SELECT name, type FROM sqlite_master</font>
<font color="black">  67.             WHERE type in ('table', 'view') AND NOT name='sqlite_sequence'</font>
<font color="green">  68.             ORDER BY name&quot;&quot;&quot;)</font>
<font color="green">  69.         return [TableInfo(row[0], row[1][0]) for row in cursor.fetchall()]</font>
<font color="black">  70. </font>
<font color="green">  71.     def get_table_description(self, cursor, table_name):</font>
<font color="black">  72.         &quot;Returns a description of the table, with the DB-API cursor.description interface.&quot;</font>
<font color="black">  73.         return [</font>
<font color="red">  74.             FieldInfo(</font>
<font color="black">  75.                 info['name'],</font>
<font color="black">  76.                 info['type'],</font>
<font color="black">  77.                 None,</font>
<font color="black">  78.                 info['size'],</font>
<font color="black">  79.                 None,</font>
<font color="black">  80.                 None,</font>
<font color="black">  81.                 info['null_ok'],</font>
<font color="black">  82.                 info['default'],</font>
<font color="red">  83.             ) for info in self._table_info(cursor, table_name)</font>
<font color="black">  84.         ]</font>
<font color="black">  85. </font>
<font color="green">  86.     def column_name_converter(self, name):</font>
<font color="black">  87.         &quot;&quot;&quot;</font>
<font color="black">  88.         SQLite will in some cases, e.g. when returning columns from views and</font>
<font color="black">  89.         subselects, return column names in 'alias.&quot;column&quot;' format instead of</font>
<font color="black">  90.         simply 'column'.</font>
<font color="black">  91. </font>
<font color="black">  92.         Affects SQLite &lt; 3.7.15, fixed by http://www.sqlite.org/src/info/5526e0aa3c</font>
<font color="black">  93.         &quot;&quot;&quot;</font>
<font color="black">  94.         # TODO: remove when SQLite &lt; 3.7.15 is sufficiently old.</font>
<font color="black">  95.         # 3.7.13 ships in Debian stable as of 2014-03-21.</font>
<font color="red">  96.         if self.connection.Database.sqlite_version_info &lt; (3, 7, 15):</font>
<font color="red">  97.             return name.split('.')[-1].strip('&quot;')</font>
<font color="black">  98.         else:</font>
<font color="red">  99.             return name</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def get_relations(self, cursor, table_name):</font>
<font color="black"> 102.         &quot;&quot;&quot;</font>
<font color="black"> 103.         Return a dictionary of {field_name: (field_name_other_table, other_table)}</font>
<font color="black"> 104.         representing all relationships to the given table.</font>
<font color="black"> 105.         &quot;&quot;&quot;</font>
<font color="black"> 106.         # Dictionary of relations to return</font>
<font color="red"> 107.         relations = {}</font>
<font color="black"> 108. </font>
<font color="black"> 109.         # Schema for this table</font>
<font color="red"> 110.         cursor.execute(&quot;SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s&quot;, [table_name, &quot;table&quot;])</font>
<font color="red"> 111.         try:</font>
<font color="red"> 112.             results = cursor.fetchone()[0].strip()</font>
<font color="red"> 113.         except TypeError:</font>
<font color="black"> 114.             # It might be a view, then no results will be returned</font>
<font color="red"> 115.             return relations</font>
<font color="red"> 116.         results = results[results.index('(') + 1:results.rindex(')')]</font>
<font color="black"> 117. </font>
<font color="black"> 118.         # Walk through and look for references to other tables. SQLite doesn't</font>
<font color="black"> 119.         # really have enforced references, but since it echoes out the SQL used</font>
<font color="black"> 120.         # to create the table we can look for REFERENCES statements used there.</font>
<font color="red"> 121.         for field_desc in results.split(','):</font>
<font color="red"> 122.             field_desc = field_desc.strip()</font>
<font color="red"> 123.             if field_desc.startswith(&quot;UNIQUE&quot;):</font>
<font color="red"> 124.                 continue</font>
<font color="black"> 125. </font>
<font color="red"> 126.             m = re.search('references (\S*) ?\([&quot;|]?(.*)[&quot;|]?\)', field_desc, re.I)</font>
<font color="red"> 127.             if not m:</font>
<font color="red"> 128.                 continue</font>
<font color="red"> 129.             table, column = [s.strip('&quot;') for s in m.groups()]</font>
<font color="black"> 130. </font>
<font color="red"> 131.             if field_desc.startswith(&quot;FOREIGN KEY&quot;):</font>
<font color="black"> 132.                 # Find name of the target FK field</font>
<font color="red"> 133.                 m = re.match('FOREIGN KEY\(([^\)]*)\).*', field_desc, re.I)</font>
<font color="red"> 134.                 field_name = m.groups()[0].strip('&quot;')</font>
<font color="black"> 135.             else:</font>
<font color="red"> 136.                 field_name = field_desc.split()[0].strip('&quot;')</font>
<font color="black"> 137. </font>
<font color="red"> 138.             cursor.execute(&quot;SELECT sql FROM sqlite_master WHERE tbl_name = %s&quot;, [table])</font>
<font color="red"> 139.             result = cursor.fetchall()[0]</font>
<font color="red"> 140.             other_table_results = result[0].strip()</font>
<font color="red"> 141.             li, ri = other_table_results.index('('), other_table_results.rindex(')')</font>
<font color="red"> 142.             other_table_results = other_table_results[li + 1:ri]</font>
<font color="black"> 143. </font>
<font color="red"> 144.             for other_desc in other_table_results.split(','):</font>
<font color="red"> 145.                 other_desc = other_desc.strip()</font>
<font color="red"> 146.                 if other_desc.startswith('UNIQUE'):</font>
<font color="red"> 147.                     continue</font>
<font color="black"> 148. </font>
<font color="red"> 149.                 other_name = other_desc.split(' ', 1)[0].strip('&quot;')</font>
<font color="red"> 150.                 if other_name == column:</font>
<font color="red"> 151.                     relations[field_name] = (other_name, table)</font>
<font color="red"> 152.                     break</font>
<font color="black"> 153. </font>
<font color="red"> 154.         return relations</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def get_key_columns(self, cursor, table_name):</font>
<font color="black"> 157.         &quot;&quot;&quot;</font>
<font color="black"> 158.         Returns a list of (column_name, referenced_table_name, referenced_column_name) for all</font>
<font color="black"> 159.         key columns in given table.</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="red"> 161.         key_columns = []</font>
<font color="black"> 162. </font>
<font color="black"> 163.         # Schema for this table</font>
<font color="red"> 164.         cursor.execute(&quot;SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s&quot;, [table_name, &quot;table&quot;])</font>
<font color="red"> 165.         results = cursor.fetchone()[0].strip()</font>
<font color="red"> 166.         results = results[results.index('(') + 1:results.rindex(')')]</font>
<font color="black"> 167. </font>
<font color="black"> 168.         # Walk through and look for references to other tables. SQLite doesn't</font>
<font color="black"> 169.         # really have enforced references, but since it echoes out the SQL used</font>
<font color="black"> 170.         # to create the table we can look for REFERENCES statements used there.</font>
<font color="red"> 171.         for field_index, field_desc in enumerate(results.split(',')):</font>
<font color="red"> 172.             field_desc = field_desc.strip()</font>
<font color="red"> 173.             if field_desc.startswith(&quot;UNIQUE&quot;):</font>
<font color="red"> 174.                 continue</font>
<font color="black"> 175. </font>
<font color="red"> 176.             m = re.search('&quot;(.*)&quot;.*references (.*) \([&quot;|](.*)[&quot;|]\)', field_desc, re.I)</font>
<font color="red"> 177.             if not m:</font>
<font color="red"> 178.                 continue</font>
<font color="black"> 179. </font>
<font color="black"> 180.             # This will append (column_name, referenced_table_name, referenced_column_name) to key_columns</font>
<font color="red"> 181.             key_columns.append(tuple(s.strip('&quot;') for s in m.groups()))</font>
<font color="black"> 182. </font>
<font color="red"> 183.         return key_columns</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def get_indexes(self, cursor, table_name):</font>
<font color="red"> 186.         indexes = {}</font>
<font color="red"> 187.         for info in self._table_info(cursor, table_name):</font>
<font color="red"> 188.             if info['pk'] != 0:</font>
<font color="red"> 189.                 indexes[info['name']] = {'primary_key': True,</font>
<font color="red"> 190.                                          'unique': False}</font>
<font color="red"> 191.         cursor.execute('PRAGMA index_list(%s)' % self.connection.ops.quote_name(table_name))</font>
<font color="black"> 192.         # seq, name, unique</font>
<font color="red"> 193.         for index, unique in [(field[1], field[2]) for field in cursor.fetchall()]:</font>
<font color="red"> 194.             cursor.execute('PRAGMA index_info(%s)' % self.connection.ops.quote_name(index))</font>
<font color="red"> 195.             info = cursor.fetchall()</font>
<font color="black"> 196.             # Skip indexes across multiple fields</font>
<font color="red"> 197.             if len(info) != 1:</font>
<font color="red"> 198.                 continue</font>
<font color="red"> 199.             name = info[0][2]  # seqno, cid, name</font>
<font color="red"> 200.             indexes[name] = {'primary_key': indexes.get(name, {}).get(&quot;primary_key&quot;, False),</font>
<font color="red"> 201.                              'unique': unique}</font>
<font color="red"> 202.         return indexes</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def get_primary_key_column(self, cursor, table_name):</font>
<font color="black"> 205.         &quot;&quot;&quot;</font>
<font color="black"> 206.         Get the column name of the primary key for the given table.</font>
<font color="black"> 207.         &quot;&quot;&quot;</font>
<font color="black"> 208.         # Don't use PRAGMA because that causes issues with some transactions</font>
<font color="red"> 209.         cursor.execute(&quot;SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s&quot;, [table_name, &quot;table&quot;])</font>
<font color="red"> 210.         row = cursor.fetchone()</font>
<font color="red"> 211.         if row is None:</font>
<font color="red"> 212.             raise ValueError(&quot;Table %s does not exist&quot; % table_name)</font>
<font color="red"> 213.         results = row[0].strip()</font>
<font color="red"> 214.         results = results[results.index('(') + 1:results.rindex(')')]</font>
<font color="red"> 215.         for field_desc in results.split(','):</font>
<font color="red"> 216.             field_desc = field_desc.strip()</font>
<font color="red"> 217.             m = re.search('&quot;(.*)&quot;.*PRIMARY KEY( AUTOINCREMENT)?$', field_desc)</font>
<font color="red"> 218.             if m:</font>
<font color="red"> 219.                 return m.groups()[0]</font>
<font color="red"> 220.         return None</font>
<font color="black"> 221. </font>
<font color="green"> 222.     def _table_info(self, cursor, name):</font>
<font color="red"> 223.         cursor.execute('PRAGMA table_info(%s)' % self.connection.ops.quote_name(name))</font>
<font color="black"> 224.         # cid, name, type, notnull, default_value, pk</font>
<font color="red"> 225.         return [{</font>
<font color="black"> 226.             'name': field[1],</font>
<font color="black"> 227.             'type': field[2],</font>
<font color="black"> 228.             'size': get_field_size(field[2]),</font>
<font color="black"> 229.             'null_ok': not field[3],</font>
<font color="black"> 230.             'default': field[4],</font>
<font color="black"> 231.             'pk': field[5],  # undocumented</font>
<font color="red"> 232.         } for field in cursor.fetchall()]</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def get_constraints(self, cursor, table_name):</font>
<font color="black"> 235.         &quot;&quot;&quot;</font>
<font color="black"> 236.         Retrieves any constraints or keys (unique, pk, fk, check, index) across one or more columns.</font>
<font color="black"> 237.         &quot;&quot;&quot;</font>
<font color="red"> 238.         constraints = {}</font>
<font color="black"> 239.         # Get the index info</font>
<font color="red"> 240.         cursor.execute(&quot;PRAGMA index_list(%s)&quot; % self.connection.ops.quote_name(table_name))</font>
<font color="red"> 241.         for row in cursor.fetchall():</font>
<font color="black"> 242.             # Sqlite3 3.8.9+ has 5 columns, however older versions only give 3</font>
<font color="black"> 243.             # columns. Discard last 2 columns if there.</font>
<font color="red"> 244.             number, index, unique = row[:3]</font>
<font color="black"> 245.             # Get the index info for that index</font>
<font color="red"> 246.             cursor.execute('PRAGMA index_info(%s)' % self.connection.ops.quote_name(index))</font>
<font color="red"> 247.             for index_rank, column_rank, column in cursor.fetchall():</font>
<font color="red"> 248.                 if index not in constraints:</font>
<font color="red"> 249.                     constraints[index] = {</font>
<font color="red"> 250.                         &quot;columns&quot;: [],</font>
<font color="red"> 251.                         &quot;primary_key&quot;: False,</font>
<font color="red"> 252.                         &quot;unique&quot;: bool(unique),</font>
<font color="red"> 253.                         &quot;foreign_key&quot;: False,</font>
<font color="red"> 254.                         &quot;check&quot;: False,</font>
<font color="red"> 255.                         &quot;index&quot;: True,</font>
<font color="black"> 256.                     }</font>
<font color="red"> 257.                 constraints[index]['columns'].append(column)</font>
<font color="black"> 258.         # Get the PK</font>
<font color="red"> 259.         pk_column = self.get_primary_key_column(cursor, table_name)</font>
<font color="red"> 260.         if pk_column:</font>
<font color="black"> 261.             # SQLite doesn't actually give a name to the PK constraint,</font>
<font color="black"> 262.             # so we invent one. This is fine, as the SQLite backend never</font>
<font color="black"> 263.             # deletes PK constraints by name, as you can't delete constraints</font>
<font color="black"> 264.             # in SQLite; we remake the table with a new PK instead.</font>
<font color="red"> 265.             constraints[&quot;__primary__&quot;] = {</font>
<font color="red"> 266.                 &quot;columns&quot;: [pk_column],</font>
<font color="red"> 267.                 &quot;primary_key&quot;: True,</font>
<font color="red"> 268.                 &quot;unique&quot;: False,  # It's not actually a unique constraint.</font>
<font color="red"> 269.                 &quot;foreign_key&quot;: False,</font>
<font color="red"> 270.                 &quot;check&quot;: False,</font>
<font color="red"> 271.                 &quot;index&quot;: False,</font>
<font color="black"> 272.             }</font>
<font color="red"> 273.         return constraints</font>
</pre>

