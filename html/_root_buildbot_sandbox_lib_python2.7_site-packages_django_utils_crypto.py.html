source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/crypto.py</b><br>


file stats: <b>95 lines, 24 executed: 25.3% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Django's standard crypto functions and utilities.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="green">   4. from __future__ import unicode_literals</font>
<font color="black">   5. </font>
<font color="green">   6. import binascii</font>
<font color="green">   7. import hashlib</font>
<font color="green">   8. import hmac</font>
<font color="green">   9. import random</font>
<font color="green">  10. import struct</font>
<font color="green">  11. import time</font>
<font color="black">  12. </font>
<font color="green">  13. from django.conf import settings</font>
<font color="green">  14. from django.utils import six</font>
<font color="green">  15. from django.utils.encoding import force_bytes</font>
<font color="green">  16. from django.utils.six.moves import range</font>
<font color="black">  17. </font>
<font color="black">  18. # Use the system PRNG if possible</font>
<font color="green">  19. try:</font>
<font color="green">  20.     random = random.SystemRandom()</font>
<font color="green">  21.     using_sysrandom = True</font>
<font color="red">  22. except NotImplementedError:</font>
<font color="red">  23.     import warnings</font>
<font color="red">  24.     warnings.warn('A secure pseudo-random number generator is not available '</font>
<font color="black">  25.                   'on your system. Falling back to Mersenne Twister.')</font>
<font color="red">  26.     using_sysrandom = False</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. def salted_hmac(key_salt, value, secret=None):</font>
<font color="black">  30.     &quot;&quot;&quot;</font>
<font color="black">  31.     Returns the HMAC-SHA1 of 'value', using a key generated from key_salt and a</font>
<font color="black">  32.     secret (which defaults to settings.SECRET_KEY).</font>
<font color="black">  33. </font>
<font color="black">  34.     A different key_salt should be passed in for every application of HMAC.</font>
<font color="black">  35.     &quot;&quot;&quot;</font>
<font color="red">  36.     if secret is None:</font>
<font color="red">  37.         secret = settings.SECRET_KEY</font>
<font color="black">  38. </font>
<font color="red">  39.     key_salt = force_bytes(key_salt)</font>
<font color="red">  40.     secret = force_bytes(secret)</font>
<font color="black">  41. </font>
<font color="black">  42.     # We need to generate a derived key from our base key.  We can do this by</font>
<font color="black">  43.     # passing the key_salt and our base key through a pseudo-random function and</font>
<font color="black">  44.     # SHA1 works nicely.</font>
<font color="red">  45.     key = hashlib.sha1(key_salt + secret).digest()</font>
<font color="black">  46. </font>
<font color="black">  47.     # If len(key_salt + secret) &gt; sha_constructor().block_size, the above</font>
<font color="black">  48.     # line is redundant and could be replaced by key = key_salt + secret, since</font>
<font color="black">  49.     # the hmac module does the same thing for keys longer than the block size.</font>
<font color="black">  50.     # However, we need to ensure that we *always* do this.</font>
<font color="red">  51.     return hmac.new(key, msg=force_bytes(value), digestmod=hashlib.sha1)</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. def get_random_string(length=12,</font>
<font color="green">  55.                       allowed_chars='abcdefghijklmnopqrstuvwxyz'</font>
<font color="black">  56.                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):</font>
<font color="black">  57.     &quot;&quot;&quot;</font>
<font color="black">  58.     Returns a securely generated random string.</font>
<font color="black">  59. </font>
<font color="black">  60.     The default length of 12 with the a-z, A-Z, 0-9 character set returns</font>
<font color="black">  61.     a 71-bit value. log_2((26+26+10)^12) =~ 71 bits</font>
<font color="black">  62.     &quot;&quot;&quot;</font>
<font color="red">  63.     if not using_sysrandom:</font>
<font color="black">  64.         # This is ugly, and a hack, but it makes things better than</font>
<font color="black">  65.         # the alternative of predictability. This re-seeds the PRNG</font>
<font color="black">  66.         # using a value that is hard for an attacker to predict, every</font>
<font color="black">  67.         # time a random string is required. This may change the</font>
<font color="black">  68.         # properties of the chosen random sequence slightly, but this</font>
<font color="black">  69.         # is better than absolute predictability.</font>
<font color="red">  70.         random.seed(</font>
<font color="red">  71.             hashlib.sha256(</font>
<font color="red">  72.                 (&quot;%s%s%s&quot; % (</font>
<font color="red">  73.                     random.getstate(),</font>
<font color="red">  74.                     time.time(),</font>
<font color="red">  75.                     settings.SECRET_KEY)).encode('utf-8')</font>
<font color="black">  76.             ).digest())</font>
<font color="red">  77.     return ''.join(random.choice(allowed_chars) for i in range(length))</font>
<font color="black">  78. </font>
<font color="black">  79. </font>
<font color="green">  80. if hasattr(hmac, &quot;compare_digest&quot;):</font>
<font color="black">  81.     # Prefer the stdlib implementation, when available.</font>
<font color="red">  82.     def constant_time_compare(val1, val2):</font>
<font color="red">  83.         return hmac.compare_digest(force_bytes(val1), force_bytes(val2))</font>
<font color="black">  84. else:</font>
<font color="green">  85.     def constant_time_compare(val1, val2):</font>
<font color="black">  86.         &quot;&quot;&quot;</font>
<font color="black">  87.         Returns True if the two strings are equal, False otherwise.</font>
<font color="black">  88. </font>
<font color="black">  89.         The time taken is independent of the number of characters that match.</font>
<font color="black">  90. </font>
<font color="black">  91.         For the sake of simplicity, this function executes in constant time only</font>
<font color="black">  92.         when the two strings have the same length. It short-circuits when they</font>
<font color="black">  93.         have different lengths. Since Django only uses it to compare hashes of</font>
<font color="black">  94.         known expected length, this is acceptable.</font>
<font color="black">  95.         &quot;&quot;&quot;</font>
<font color="red">  96.         if len(val1) != len(val2):</font>
<font color="red">  97.             return False</font>
<font color="red">  98.         result = 0</font>
<font color="red">  99.         if six.PY3 and isinstance(val1, bytes) and isinstance(val2, bytes):</font>
<font color="red"> 100.             for x, y in zip(val1, val2):</font>
<font color="red"> 101.                 result |= x ^ y</font>
<font color="black"> 102.         else:</font>
<font color="red"> 103.             for x, y in zip(val1, val2):</font>
<font color="red"> 104.                 result |= ord(x) ^ ord(y)</font>
<font color="red"> 105.         return result == 0</font>
<font color="black"> 106. </font>
<font color="black"> 107. </font>
<font color="green"> 108. def _bin_to_long(x):</font>
<font color="black"> 109.     &quot;&quot;&quot;</font>
<font color="black"> 110.     Convert a binary string into a long integer</font>
<font color="black"> 111. </font>
<font color="black"> 112.     This is a clever optimization for fast xor vector math</font>
<font color="black"> 113.     &quot;&quot;&quot;</font>
<font color="red"> 114.     return int(binascii.hexlify(x), 16)</font>
<font color="black"> 115. </font>
<font color="black"> 116. </font>
<font color="green"> 117. def _long_to_bin(x, hex_format_string):</font>
<font color="black"> 118.     &quot;&quot;&quot;</font>
<font color="black"> 119.     Convert a long integer into a binary string.</font>
<font color="black"> 120.     hex_format_string is like &quot;%020x&quot; for padding 10 characters.</font>
<font color="black"> 121.     &quot;&quot;&quot;</font>
<font color="red"> 122.     return binascii.unhexlify((hex_format_string % x).encode('ascii'))</font>
<font color="black"> 123. </font>
<font color="black"> 124. </font>
<font color="green"> 125. if hasattr(hashlib, &quot;pbkdf2_hmac&quot;):</font>
<font color="red"> 126.     def pbkdf2(password, salt, iterations, dklen=0, digest=None):</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         Implements PBKDF2 with the same API as Django's existing</font>
<font color="black"> 129.         implementation, using the stdlib.</font>
<font color="black"> 130. </font>
<font color="black"> 131.         This is used in Python 2.7.8+ and 3.4+.</font>
<font color="black"> 132.         &quot;&quot;&quot;</font>
<font color="red"> 133.         if digest is None:</font>
<font color="red"> 134.             digest = hashlib.sha256</font>
<font color="red"> 135.         if not dklen:</font>
<font color="red"> 136.             dklen = None</font>
<font color="red"> 137.         password = force_bytes(password)</font>
<font color="red"> 138.         salt = force_bytes(salt)</font>
<font color="red"> 139.         return hashlib.pbkdf2_hmac(</font>
<font color="red"> 140.             digest().name, password, salt, iterations, dklen)</font>
<font color="black"> 141. else:</font>
<font color="green"> 142.     def pbkdf2(password, salt, iterations, dklen=0, digest=None):</font>
<font color="black"> 143.         &quot;&quot;&quot;</font>
<font color="black"> 144.         Implements PBKDF2 as defined in RFC 2898, section 5.2</font>
<font color="black"> 145. </font>
<font color="black"> 146.         HMAC+SHA256 is used as the default pseudo random function.</font>
<font color="black"> 147. </font>
<font color="black"> 148.         As of 2014, 100,000 iterations was the recommended default which took</font>
<font color="black"> 149.         100ms on a 2.7Ghz Intel i7 with an optimized implementation. This is</font>
<font color="black"> 150.         probably the bare minimum for security given 1000 iterations was</font>
<font color="black"> 151.         recommended in 2001. This code is very well optimized for CPython and</font>
<font color="black"> 152.         is about five times slower than OpenSSL's implementation. Look in</font>
<font color="black"> 153.         django.contrib.auth.hashers for the present default, it is lower than</font>
<font color="black"> 154.         the recommended 100,000 because of the performance difference between</font>
<font color="black"> 155.         this and an optimized implementation.</font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="red"> 157.         assert iterations &gt; 0</font>
<font color="red"> 158.         if not digest:</font>
<font color="red"> 159.             digest = hashlib.sha256</font>
<font color="red"> 160.         password = force_bytes(password)</font>
<font color="red"> 161.         salt = force_bytes(salt)</font>
<font color="red"> 162.         hlen = digest().digest_size</font>
<font color="red"> 163.         if not dklen:</font>
<font color="red"> 164.             dklen = hlen</font>
<font color="red"> 165.         if dklen &gt; (2 ** 32 - 1) * hlen:</font>
<font color="red"> 166.             raise OverflowError('dklen too big')</font>
<font color="red"> 167.         l = -(-dklen // hlen)</font>
<font color="red"> 168.         r = dklen - (l - 1) * hlen</font>
<font color="black"> 169. </font>
<font color="red"> 170.         hex_format_string = &quot;%%0%ix&quot; % (hlen * 2)</font>
<font color="black"> 171. </font>
<font color="red"> 172.         inner, outer = digest(), digest()</font>
<font color="red"> 173.         if len(password) &gt; inner.block_size:</font>
<font color="red"> 174.             password = digest(password).digest()</font>
<font color="red"> 175.         password += b'\x00' * (inner.block_size - len(password))</font>
<font color="red"> 176.         inner.update(password.translate(hmac.trans_36))</font>
<font color="red"> 177.         outer.update(password.translate(hmac.trans_5C))</font>
<font color="black"> 178. </font>
<font color="red"> 179.         def F(i):</font>
<font color="red"> 180.             u = salt + struct.pack(b'&gt;I', i)</font>
<font color="red"> 181.             result = 0</font>
<font color="red"> 182.             for j in range(int(iterations)):</font>
<font color="red"> 183.                 dig1, dig2 = inner.copy(), outer.copy()</font>
<font color="red"> 184.                 dig1.update(u)</font>
<font color="red"> 185.                 dig2.update(dig1.digest())</font>
<font color="red"> 186.                 u = dig2.digest()</font>
<font color="red"> 187.                 result ^= _bin_to_long(u)</font>
<font color="red"> 188.             return _long_to_bin(result, hex_format_string)</font>
<font color="black"> 189. </font>
<font color="red"> 190.         T = [F(x) for x in range(1, l)]</font>
<font color="red"> 191.         return b''.join(T) + F(l)[:r]</font>
</pre>

