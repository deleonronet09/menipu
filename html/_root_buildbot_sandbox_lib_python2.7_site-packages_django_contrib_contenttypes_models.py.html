source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/contrib/contenttypes/models.py</b><br>


file stats: <b>125 lines, 59 executed: 47.2% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import warnings</font>
<font color="black">   4. </font>
<font color="green">   5. from django.apps import apps</font>
<font color="green">   6. from django.db import models</font>
<font color="green">   7. from django.db.utils import IntegrityError, OperationalError, ProgrammingError</font>
<font color="green">   8. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">   9. from django.utils.encoding import force_text, python_2_unicode_compatible</font>
<font color="green">  10. from django.utils.translation import ugettext_lazy as _</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class ContentTypeManager(models.Manager):</font>
<font color="green">  14.     use_in_migrations = True</font>
<font color="black">  15. </font>
<font color="black">  16.     # Cache to avoid re-looking up ContentType objects all over the place.</font>
<font color="black">  17.     # This cache is shared by all the get_for_* methods.</font>
<font color="green">  18.     _cache = {}</font>
<font color="black">  19. </font>
<font color="green">  20.     def get_by_natural_key(self, app_label, model):</font>
<font color="red">  21.         try:</font>
<font color="red">  22.             ct = self.__class__._cache[self.db][(app_label, model)]</font>
<font color="red">  23.         except KeyError:</font>
<font color="red">  24.             ct = self.get(app_label=app_label, model=model)</font>
<font color="red">  25.             self._add_to_cache(self.db, ct)</font>
<font color="red">  26.         return ct</font>
<font color="black">  27. </font>
<font color="green">  28.     def _get_opts(self, model, for_concrete_model):</font>
<font color="green">  29.         if for_concrete_model:</font>
<font color="green">  30.             model = model._meta.concrete_model</font>
<font color="red">  31.         elif model._deferred:</font>
<font color="red">  32.             model = model._meta.proxy_for_model</font>
<font color="green">  33.         return model._meta</font>
<font color="black">  34. </font>
<font color="green">  35.     def _get_from_cache(self, opts):</font>
<font color="green">  36.         key = (opts.app_label, opts.model_name)</font>
<font color="green">  37.         return self.__class__._cache[self.db][key]</font>
<font color="black">  38. </font>
<font color="green">  39.     def create(self, **kwargs):</font>
<font color="red">  40.         if 'name' in kwargs:</font>
<font color="red">  41.             del kwargs['name']</font>
<font color="red">  42.             warnings.warn(</font>
<font color="red">  43.                 &quot;ContentType.name field doesn't exist any longer. Please remove it from your code.&quot;,</font>
<font color="red">  44.                 RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red">  45.         return super(ContentTypeManager, self).create(**kwargs)</font>
<font color="black">  46. </font>
<font color="green">  47.     def get_for_model(self, model, for_concrete_model=True):</font>
<font color="black">  48.         &quot;&quot;&quot;</font>
<font color="black">  49.         Returns the ContentType object for a given model, creating the</font>
<font color="black">  50.         ContentType if necessary. Lookups are cached so that subsequent lookups</font>
<font color="black">  51.         for the same model don't hit the database.</font>
<font color="black">  52.         &quot;&quot;&quot;</font>
<font color="green">  53.         opts = self._get_opts(model, for_concrete_model)</font>
<font color="green">  54.         try:</font>
<font color="green">  55.             return self._get_from_cache(opts)</font>
<font color="green">  56.         except KeyError:</font>
<font color="green">  57.             pass</font>
<font color="black">  58. </font>
<font color="black">  59.         # The ContentType entry was not found in the cache, therefore we</font>
<font color="black">  60.         # proceed to load or create it.</font>
<font color="green">  61.         try:</font>
<font color="green">  62.             try:</font>
<font color="black">  63.                 # We start with get() and not get_or_create() in order to use</font>
<font color="black">  64.                 # the db_for_read (see #20401).</font>
<font color="green">  65.                 ct = self.get(app_label=opts.app_label, model=opts.model_name)</font>
<font color="green">  66.             except self.model.DoesNotExist:</font>
<font color="black">  67.                 # Not found in the database; we proceed to create it.  This time we</font>
<font color="black">  68.                 # use get_or_create to take care of any race conditions.</font>
<font color="green">  69.                 ct, created = self.get_or_create(</font>
<font color="green">  70.                     app_label=opts.app_label,</font>
<font color="green">  71.                     model=opts.model_name,</font>
<font color="black">  72.                 )</font>
<font color="red">  73.         except (OperationalError, ProgrammingError, IntegrityError):</font>
<font color="black">  74.             # It's possible to migrate a single app before contenttypes,</font>
<font color="black">  75.             # as it's not a required initial dependency (it's contrib!)</font>
<font color="black">  76.             # Have a nice error for this.</font>
<font color="red">  77.             raise RuntimeError(</font>
<font color="red">  78.                 &quot;Error creating new content types. Please make sure contenttypes &quot;</font>
<font color="black">  79.                 &quot;is migrated before trying to migrate apps individually.&quot;</font>
<font color="black">  80.             )</font>
<font color="green">  81.         self._add_to_cache(self.db, ct)</font>
<font color="green">  82.         return ct</font>
<font color="black">  83. </font>
<font color="green">  84.     def get_for_models(self, *models, **kwargs):</font>
<font color="black">  85.         &quot;&quot;&quot;</font>
<font color="black">  86.         Given *models, returns a dictionary mapping {model: content_type}.</font>
<font color="black">  87.         &quot;&quot;&quot;</font>
<font color="red">  88.         for_concrete_models = kwargs.pop('for_concrete_models', True)</font>
<font color="black">  89.         # Final results</font>
<font color="red">  90.         results = {}</font>
<font color="black">  91.         # models that aren't already in the cache</font>
<font color="red">  92.         needed_app_labels = set()</font>
<font color="red">  93.         needed_models = set()</font>
<font color="red">  94.         needed_opts = set()</font>
<font color="red">  95.         for model in models:</font>
<font color="red">  96.             opts = self._get_opts(model, for_concrete_models)</font>
<font color="red">  97.             try:</font>
<font color="red">  98.                 ct = self._get_from_cache(opts)</font>
<font color="red">  99.             except KeyError:</font>
<font color="red"> 100.                 needed_app_labels.add(opts.app_label)</font>
<font color="red"> 101.                 needed_models.add(opts.model_name)</font>
<font color="red"> 102.                 needed_opts.add(opts)</font>
<font color="black"> 103.             else:</font>
<font color="red"> 104.                 results[model] = ct</font>
<font color="red"> 105.         if needed_opts:</font>
<font color="red"> 106.             cts = self.filter(</font>
<font color="red"> 107.                 app_label__in=needed_app_labels,</font>
<font color="red"> 108.                 model__in=needed_models</font>
<font color="black"> 109.             )</font>
<font color="red"> 110.             for ct in cts:</font>
<font color="red"> 111.                 model = ct.model_class()</font>
<font color="red"> 112.                 if model._meta in needed_opts:</font>
<font color="red"> 113.                     results[model] = ct</font>
<font color="red"> 114.                     needed_opts.remove(model._meta)</font>
<font color="red"> 115.                 self._add_to_cache(self.db, ct)</font>
<font color="red"> 116.         for opts in needed_opts:</font>
<font color="black"> 117.             # These weren't in the cache, or the DB, create them.</font>
<font color="red"> 118.             ct = self.create(</font>
<font color="red"> 119.                 app_label=opts.app_label,</font>
<font color="red"> 120.                 model=opts.model_name,</font>
<font color="black"> 121.             )</font>
<font color="red"> 122.             self._add_to_cache(self.db, ct)</font>
<font color="red"> 123.             results[ct.model_class()] = ct</font>
<font color="red"> 124.         return results</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def get_for_id(self, id):</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         Lookup a ContentType by ID. Uses the same shared cache as get_for_model</font>
<font color="black"> 129.         (though ContentTypes are obviously not created on-the-fly by get_by_id).</font>
<font color="black"> 130.         &quot;&quot;&quot;</font>
<font color="red"> 131.         try:</font>
<font color="red"> 132.             ct = self.__class__._cache[self.db][id]</font>
<font color="red"> 133.         except KeyError:</font>
<font color="black"> 134.             # This could raise a DoesNotExist; that's correct behavior and will</font>
<font color="black"> 135.             # make sure that only correct ctypes get stored in the cache dict.</font>
<font color="red"> 136.             ct = self.get(pk=id)</font>
<font color="red"> 137.             self._add_to_cache(self.db, ct)</font>
<font color="red"> 138.         return ct</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def clear_cache(self):</font>
<font color="black"> 141.         &quot;&quot;&quot;</font>
<font color="black"> 142.         Clear out the content-type cache. This needs to happen during database</font>
<font color="black"> 143.         flushes to prevent caching of &quot;stale&quot; content type IDs (see</font>
<font color="black"> 144.         django.contrib.contenttypes.management.update_contenttypes for where</font>
<font color="black"> 145.         this gets called).</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="green"> 147.         self.__class__._cache.clear()</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def _add_to_cache(self, using, ct):</font>
<font color="black"> 150.         &quot;&quot;&quot;Insert a ContentType into the cache.&quot;&quot;&quot;</font>
<font color="black"> 151.         # Note it's possible for ContentType objects to be stale; model_class() will return None.</font>
<font color="black"> 152.         # Hence, there is no reliance on model._meta.app_label here, just using the model fields instead.</font>
<font color="green"> 153.         key = (ct.app_label, ct.model)</font>
<font color="green"> 154.         self.__class__._cache.setdefault(using, {})[key] = ct</font>
<font color="green"> 155.         self.__class__._cache.setdefault(using, {})[ct.id] = ct</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="green"> 158. @python_2_unicode_compatible</font>
<font color="green"> 159. class ContentType(models.Model):</font>
<font color="green"> 160.     app_label = models.CharField(max_length=100)</font>
<font color="green"> 161.     model = models.CharField(_('python model class name'), max_length=100)</font>
<font color="green"> 162.     objects = ContentTypeManager()</font>
<font color="black"> 163. </font>
<font color="green"> 164.     class Meta:</font>
<font color="green"> 165.         verbose_name = _('content type')</font>
<font color="green"> 166.         verbose_name_plural = _('content types')</font>
<font color="green"> 167.         db_table = 'django_content_type'</font>
<font color="green"> 168.         unique_together = (('app_label', 'model'),)</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def __str__(self):</font>
<font color="red"> 171.         return self.name</font>
<font color="black"> 172. </font>
<font color="green"> 173.     @property</font>
<font color="black"> 174.     def name(self):</font>
<font color="red"> 175.         model = self.model_class()</font>
<font color="red"> 176.         if not model:</font>
<font color="red"> 177.             return self.model</font>
<font color="red"> 178.         return force_text(model._meta.verbose_name)</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def model_class(self):</font>
<font color="black"> 181.         &quot;Returns the Python model class for this type of content.&quot;</font>
<font color="red"> 182.         try:</font>
<font color="red"> 183.             return apps.get_model(self.app_label, self.model)</font>
<font color="red"> 184.         except LookupError:</font>
<font color="red"> 185.             return None</font>
<font color="black"> 186. </font>
<font color="green"> 187.     def get_object_for_this_type(self, **kwargs):</font>
<font color="black"> 188.         &quot;&quot;&quot;</font>
<font color="black"> 189.         Returns an object of this type for the keyword arguments given.</font>
<font color="black"> 190.         Basically, this is a proxy around this object_type's get_object() model</font>
<font color="black"> 191.         method. The ObjectNotExist exception, if thrown, will not be caught,</font>
<font color="black"> 192.         so code that calls this method should catch it.</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="red"> 194.         return self.model_class()._base_manager.using(self._state.db).get(**kwargs)</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def get_all_objects_for_this_type(self, **kwargs):</font>
<font color="black"> 197.         &quot;&quot;&quot;</font>
<font color="black"> 198.         Returns all objects of this type for the keyword arguments given.</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="red"> 200.         return self.model_class()._base_manager.using(self._state.db).filter(**kwargs)</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def natural_key(self):</font>
<font color="red"> 203.         return (self.app_label, self.model)</font>
</pre>

