source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/serializers/base.py</b><br>


file stats: <b>118 lines, 73 executed: 61.9% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Module for abstract serializer/unserializer base classes.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="green">   4. from django.db import models</font>
<font color="green">   5. from django.utils import six</font>
<font color="black">   6. </font>
<font color="black">   7. </font>
<font color="green">   8. class SerializerDoesNotExist(KeyError):</font>
<font color="green">   9.     &quot;&quot;&quot;The requested serializer was not found.&quot;&quot;&quot;</font>
<font color="green">  10.     pass</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class SerializationError(Exception):</font>
<font color="green">  14.     &quot;&quot;&quot;Something bad happened during serialization.&quot;&quot;&quot;</font>
<font color="green">  15.     pass</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. class DeserializationError(Exception):</font>
<font color="green">  19.     &quot;&quot;&quot;Something bad happened during deserialization.&quot;&quot;&quot;</font>
<font color="black">  20. </font>
<font color="green">  21.     @classmethod</font>
<font color="black">  22.     def WithData(cls, original_exc, model, fk, field_value):</font>
<font color="black">  23.         &quot;&quot;&quot;</font>
<font color="black">  24.         Factory method for creating a deserialization error which has a more</font>
<font color="black">  25.         explanatory messsage.</font>
<font color="black">  26.         &quot;&quot;&quot;</font>
<font color="red">  27.         return cls(&quot;%s: (%s:pk=%s) field_value was '%s'&quot; % (original_exc, model, fk, field_value))</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. class ProgressBar(object):</font>
<font color="green">  31.     progress_width = 75</font>
<font color="black">  32. </font>
<font color="green">  33.     def __init__(self, output, total_count):</font>
<font color="green">  34.         self.output = output</font>
<font color="green">  35.         self.total_count = total_count</font>
<font color="green">  36.         self.prev_done = 0</font>
<font color="black">  37. </font>
<font color="green">  38.     def update(self, count):</font>
<font color="green">  39.         if not self.output:</font>
<font color="green">  40.             return</font>
<font color="red">  41.         perc = count * 100 // self.total_count</font>
<font color="red">  42.         done = perc * self.progress_width // 100</font>
<font color="red">  43.         if self.prev_done &gt;= done:</font>
<font color="red">  44.             return</font>
<font color="red">  45.         self.prev_done = done</font>
<font color="red">  46.         cr = '' if self.total_count == 1 else '\r'</font>
<font color="red">  47.         self.output.write(cr + '[' + '.' * done + ' ' * (self.progress_width - done) + ']')</font>
<font color="red">  48.         if done == self.progress_width:</font>
<font color="red">  49.             self.output.write('\n')</font>
<font color="red">  50.         self.output.flush()</font>
<font color="black">  51. </font>
<font color="black">  52. </font>
<font color="green">  53. class Serializer(object):</font>
<font color="black">  54.     &quot;&quot;&quot;</font>
<font color="black">  55.     Abstract serializer base class.</font>
<font color="green">  56.     &quot;&quot;&quot;</font>
<font color="black">  57. </font>
<font color="black">  58.     # Indicates if the implemented serializer is only available for</font>
<font color="black">  59.     # internal Django use.</font>
<font color="green">  60.     internal_use_only = False</font>
<font color="green">  61.     progress_class = ProgressBar</font>
<font color="black">  62. </font>
<font color="green">  63.     def serialize(self, queryset, **options):</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="black">  65.         Serialize a queryset.</font>
<font color="black">  66.         &quot;&quot;&quot;</font>
<font color="green">  67.         self.options = options</font>
<font color="black">  68. </font>
<font color="green">  69.         self.stream = options.pop(&quot;stream&quot;, six.StringIO())</font>
<font color="green">  70.         self.selected_fields = options.pop(&quot;fields&quot;, None)</font>
<font color="green">  71.         self.use_natural_foreign_keys = options.pop('use_natural_foreign_keys', False)</font>
<font color="green">  72.         self.use_natural_primary_keys = options.pop('use_natural_primary_keys', False)</font>
<font color="green">  73.         progress_bar = self.progress_class(</font>
<font color="green">  74.             options.pop('progress_output', None), options.pop('object_count', 0)</font>
<font color="black">  75.         )</font>
<font color="black">  76. </font>
<font color="green">  77.         self.start_serialization()</font>
<font color="green">  78.         self.first = True</font>
<font color="green">  79.         for count, obj in enumerate(queryset, start=1):</font>
<font color="green">  80.             self.start_object(obj)</font>
<font color="black">  81.             # Use the concrete parent class' _meta instead of the object's _meta</font>
<font color="black">  82.             # This is to avoid local_fields problems for proxy models. Refs #17717.</font>
<font color="green">  83.             concrete_model = obj._meta.concrete_model</font>
<font color="green">  84.             for field in concrete_model._meta.local_fields:</font>
<font color="green">  85.                 if field.serialize:</font>
<font color="green">  86.                     if field.remote_field is None:</font>
<font color="green">  87.                         if self.selected_fields is None or field.attname in self.selected_fields:</font>
<font color="green">  88.                             self.handle_field(obj, field)</font>
<font color="black">  89.                     else:</font>
<font color="green">  90.                         if self.selected_fields is None or field.attname[:-3] in self.selected_fields:</font>
<font color="green">  91.                             self.handle_fk_field(obj, field)</font>
<font color="green">  92.             for field in concrete_model._meta.many_to_many:</font>
<font color="red">  93.                 if field.serialize:</font>
<font color="red">  94.                     if self.selected_fields is None or field.attname in self.selected_fields:</font>
<font color="red">  95.                         self.handle_m2m_field(obj, field)</font>
<font color="green">  96.             self.end_object(obj)</font>
<font color="green">  97.             progress_bar.update(count)</font>
<font color="green">  98.             if self.first:</font>
<font color="green">  99.                 self.first = False</font>
<font color="green"> 100.         self.end_serialization()</font>
<font color="green"> 101.         return self.getvalue()</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def start_serialization(self):</font>
<font color="black"> 104.         &quot;&quot;&quot;</font>
<font color="black"> 105.         Called when serializing of the queryset starts.</font>
<font color="black"> 106.         &quot;&quot;&quot;</font>
<font color="red"> 107.         raise NotImplementedError('subclasses of Serializer must provide a start_serialization() method')</font>
<font color="black"> 108. </font>
<font color="green"> 109.     def end_serialization(self):</font>
<font color="black"> 110.         &quot;&quot;&quot;</font>
<font color="black"> 111.         Called when serializing of the queryset ends.</font>
<font color="black"> 112.         &quot;&quot;&quot;</font>
<font color="red"> 113.         pass</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def start_object(self, obj):</font>
<font color="black"> 116.         &quot;&quot;&quot;</font>
<font color="black"> 117.         Called when serializing of an object starts.</font>
<font color="black"> 118.         &quot;&quot;&quot;</font>
<font color="red"> 119.         raise NotImplementedError('subclasses of Serializer must provide a start_object() method')</font>
<font color="black"> 120. </font>
<font color="green"> 121.     def end_object(self, obj):</font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="black"> 123.         Called when serializing of an object ends.</font>
<font color="black"> 124.         &quot;&quot;&quot;</font>
<font color="red"> 125.         pass</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def handle_field(self, obj, field):</font>
<font color="black"> 128.         &quot;&quot;&quot;</font>
<font color="black"> 129.         Called to handle each individual (non-relational) field on an object.</font>
<font color="black"> 130.         &quot;&quot;&quot;</font>
<font color="red"> 131.         raise NotImplementedError('subclasses of Serializer must provide an handle_field() method')</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def handle_fk_field(self, obj, field):</font>
<font color="black"> 134.         &quot;&quot;&quot;</font>
<font color="black"> 135.         Called to handle a ForeignKey field.</font>
<font color="black"> 136.         &quot;&quot;&quot;</font>
<font color="red"> 137.         raise NotImplementedError('subclasses of Serializer must provide an handle_fk_field() method')</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def handle_m2m_field(self, obj, field):</font>
<font color="black"> 140.         &quot;&quot;&quot;</font>
<font color="black"> 141.         Called to handle a ManyToManyField.</font>
<font color="black"> 142.         &quot;&quot;&quot;</font>
<font color="red"> 143.         raise NotImplementedError('subclasses of Serializer must provide an handle_m2m_field() method')</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def getvalue(self):</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="black"> 147.         Return the fully serialized queryset (or None if the output stream is</font>
<font color="black"> 148.         not seekable).</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="green"> 150.         if callable(getattr(self.stream, 'getvalue', None)):</font>
<font color="green"> 151.             return self.stream.getvalue()</font>
<font color="black"> 152. </font>
<font color="black"> 153. </font>
<font color="green"> 154. class Deserializer(six.Iterator):</font>
<font color="black"> 155.     &quot;&quot;&quot;</font>
<font color="black"> 156.     Abstract base deserializer class.</font>
<font color="green"> 157.     &quot;&quot;&quot;</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def __init__(self, stream_or_string, **options):</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="black"> 161.         Init this serializer given a stream or a string</font>
<font color="black"> 162.         &quot;&quot;&quot;</font>
<font color="red"> 163.         self.options = options</font>
<font color="red"> 164.         if isinstance(stream_or_string, six.string_types):</font>
<font color="red"> 165.             self.stream = six.StringIO(stream_or_string)</font>
<font color="black"> 166.         else:</font>
<font color="red"> 167.             self.stream = stream_or_string</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def __iter__(self):</font>
<font color="red"> 170.         return self</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def __next__(self):</font>
<font color="black"> 173.         &quot;&quot;&quot;Iteration iterface -- return the next item in the stream&quot;&quot;&quot;</font>
<font color="red"> 174.         raise NotImplementedError('subclasses of Deserializer must provide a __next__() method')</font>
<font color="black"> 175. </font>
<font color="black"> 176. </font>
<font color="green"> 177. class DeserializedObject(object):</font>
<font color="black"> 178.     &quot;&quot;&quot;</font>
<font color="black"> 179.     A deserialized model.</font>
<font color="black"> 180. </font>
<font color="black"> 181.     Basically a container for holding the pre-saved deserialized data along</font>
<font color="black"> 182.     with the many-to-many data saved with the object.</font>
<font color="black"> 183. </font>
<font color="black"> 184.     Call ``save()`` to save the object (with the many-to-many data) to the</font>
<font color="black"> 185.     database; call ``save(save_m2m=False)`` to save just the object fields</font>
<font color="black"> 186.     (and not touch the many-to-many stuff.)</font>
<font color="green"> 187.     &quot;&quot;&quot;</font>
<font color="black"> 188. </font>
<font color="green"> 189.     def __init__(self, obj, m2m_data=None):</font>
<font color="red"> 190.         self.object = obj</font>
<font color="red"> 191.         self.m2m_data = m2m_data</font>
<font color="black"> 192. </font>
<font color="green"> 193.     def __repr__(self):</font>
<font color="red"> 194.         return &quot;&lt;DeserializedObject: %s(pk=%s)&gt;&quot; % (</font>
<font color="red"> 195.             self.object._meta.label, self.object.pk)</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def save(self, save_m2m=True, using=None, **kwargs):</font>
<font color="black"> 198.         # Call save on the Model baseclass directly. This bypasses any</font>
<font color="black"> 199.         # model-defined save. The save is also forced to be raw.</font>
<font color="black"> 200.         # raw=True is passed to any pre/post_save signals.</font>
<font color="red"> 201.         models.Model.save_base(self.object, using=using, raw=True, **kwargs)</font>
<font color="red"> 202.         if self.m2m_data and save_m2m:</font>
<font color="red"> 203.             for accessor_name, object_list in self.m2m_data.items():</font>
<font color="red"> 204.                 setattr(self.object, accessor_name, object_list)</font>
<font color="black"> 205. </font>
<font color="black"> 206.         # prevent a second (possibly accidental) call to save() from saving</font>
<font color="black"> 207.         # the m2m data twice.</font>
<font color="red"> 208.         self.m2m_data = None</font>
<font color="black"> 209. </font>
<font color="black"> 210. </font>
<font color="green"> 211. def build_instance(Model, data, db):</font>
<font color="black"> 212.     &quot;&quot;&quot;</font>
<font color="black"> 213.     Build a model instance.</font>
<font color="black"> 214. </font>
<font color="black"> 215.     If the model instance doesn't have a primary key and the model supports</font>
<font color="black"> 216.     natural keys, try to retrieve it from the database.</font>
<font color="black"> 217.     &quot;&quot;&quot;</font>
<font color="red"> 218.     obj = Model(**data)</font>
<font color="red"> 219.     if (obj.pk is None and hasattr(Model, 'natural_key') and</font>
<font color="red"> 220.             hasattr(Model._default_manager, 'get_by_natural_key')):</font>
<font color="red"> 221.         natural_key = obj.natural_key()</font>
<font color="red"> 222.         try:</font>
<font color="red"> 223.             obj.pk = Model._default_manager.db_manager(db).get_by_natural_key(*natural_key).pk</font>
<font color="red"> 224.         except Model.DoesNotExist:</font>
<font color="red"> 225.             pass</font>
<font color="red"> 226.     return obj</font>
</pre>

