source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/migrations/state.py</b><br>


file stats: <b>379 lines, 209 executed: 55.1% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import copy</font>
<font color="green">   4. from collections import OrderedDict</font>
<font color="green">   5. from contextlib import contextmanager</font>
<font color="black">   6. </font>
<font color="green">   7. from django.apps import AppConfig</font>
<font color="green">   8. from django.apps.registry import Apps, apps as global_apps</font>
<font color="green">   9. from django.conf import settings</font>
<font color="green">  10. from django.db import models</font>
<font color="green">  11. from django.db.models.fields.proxy import OrderWrt</font>
<font color="green">  12. from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT</font>
<font color="green">  13. from django.db.models.options import DEFAULT_NAMES, normalize_together</font>
<font color="green">  14. from django.db.models.utils import make_model_tuple</font>
<font color="green">  15. from django.utils import six</font>
<font color="green">  16. from django.utils.encoding import force_text, smart_text</font>
<font color="green">  17. from django.utils.functional import cached_property</font>
<font color="green">  18. from django.utils.module_loading import import_string</font>
<font color="green">  19. from django.utils.version import get_docs_version</font>
<font color="black">  20. </font>
<font color="green">  21. from .exceptions import InvalidBasesError</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="green">  24. def _get_app_label_and_model_name(model, app_label=''):</font>
<font color="green">  25.     if isinstance(model, six.string_types):</font>
<font color="green">  26.         split = model.split('.', 1)</font>
<font color="green">  27.         return (tuple(split) if len(split) == 2 else (app_label, split[0]))</font>
<font color="black">  28.     else:</font>
<font color="red">  29.         return model._meta.app_label, model._meta.model_name</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. def get_related_models_recursive(model):</font>
<font color="black">  33.     &quot;&quot;&quot;</font>
<font color="black">  34.     Returns all models that have a direct or indirect relationship</font>
<font color="black">  35.     to the given model.</font>
<font color="black">  36. </font>
<font color="black">  37.     Relationships are either defined by explicit relational fields, like</font>
<font color="black">  38.     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another</font>
<font color="black">  39.     model (a superclass is related to its subclasses, but not vice versa). Note,</font>
<font color="black">  40.     however, that a model inheriting from a concrete model is also related to</font>
<font color="black">  41.     its superclass through the implicit *_ptr OneToOneField on the subclass.</font>
<font color="black">  42.     &quot;&quot;&quot;</font>
<font color="green">  43.     def _related_models(m):</font>
<font color="black">  44.         return [</font>
<font color="green">  45.             f.related_model for f in m._meta.get_fields(include_parents=True, include_hidden=True)</font>
<font color="green">  46.             if f.is_relation and f.related_model is not None and not isinstance(f.related_model, six.string_types)</font>
<font color="black">  47.         ] + [</font>
<font color="green">  48.             subclass for subclass in m.__subclasses__()</font>
<font color="red">  49.             if issubclass(subclass, models.Model)</font>
<font color="black">  50.         ]</font>
<font color="black">  51. </font>
<font color="green">  52.     seen = set()</font>
<font color="green">  53.     queue = _related_models(model)</font>
<font color="green">  54.     for rel_mod in queue:</font>
<font color="green">  55.         rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name</font>
<font color="green">  56.         if (rel_app_label, rel_model_name) in seen:</font>
<font color="green">  57.             continue</font>
<font color="green">  58.         seen.add((rel_app_label, rel_model_name))</font>
<font color="green">  59.         queue.extend(_related_models(rel_mod))</font>
<font color="green">  60.     return seen - {(model._meta.app_label, model._meta.model_name)}</font>
<font color="black">  61. </font>
<font color="black">  62. </font>
<font color="green">  63. class ProjectState(object):</font>
<font color="black">  64.     &quot;&quot;&quot;</font>
<font color="black">  65.     Represents the entire project's overall state.</font>
<font color="black">  66.     This is the item that is passed around - we do it here rather than at the</font>
<font color="black">  67.     app level so that cross-app FKs/etc. resolve properly.</font>
<font color="green">  68.     &quot;&quot;&quot;</font>
<font color="black">  69. </font>
<font color="green">  70.     def __init__(self, models=None, real_apps=None):</font>
<font color="green">  71.         self.models = models or {}</font>
<font color="black">  72.         # Apps to include from main registry, usually unmigrated ones</font>
<font color="green">  73.         self.real_apps = real_apps or []</font>
<font color="black">  74. </font>
<font color="green">  75.     def add_model(self, model_state):</font>
<font color="green">  76.         app_label, model_name = model_state.app_label, model_state.name_lower</font>
<font color="green">  77.         self.models[(app_label, model_name)] = model_state</font>
<font color="green">  78.         if 'apps' in self.__dict__:  # hasattr would cache the property</font>
<font color="green">  79.             self.reload_model(app_label, model_name)</font>
<font color="black">  80. </font>
<font color="green">  81.     def remove_model(self, app_label, model_name):</font>
<font color="red">  82.         del self.models[app_label, model_name]</font>
<font color="red">  83.         if 'apps' in self.__dict__:  # hasattr would cache the property</font>
<font color="red">  84.             self.apps.unregister_model(app_label, model_name)</font>
<font color="black">  85.             # Need to do this explicitly since unregister_model() doesn't clear</font>
<font color="black">  86.             # the cache automatically (#24513)</font>
<font color="red">  87.             self.apps.clear_cache()</font>
<font color="black">  88. </font>
<font color="green">  89.     def reload_model(self, app_label, model_name):</font>
<font color="green">  90.         if 'apps' in self.__dict__:  # hasattr would cache the property</font>
<font color="green">  91.             try:</font>
<font color="green">  92.                 old_model = self.apps.get_model(app_label, model_name)</font>
<font color="green">  93.             except LookupError:</font>
<font color="green">  94.                 related_models = set()</font>
<font color="black">  95.             else:</font>
<font color="black">  96.                 # Get all relations to and from the old model before reloading,</font>
<font color="black">  97.                 # as _meta.apps may change</font>
<font color="green">  98.                 related_models = get_related_models_recursive(old_model)</font>
<font color="black">  99. </font>
<font color="black"> 100.             # Get all outgoing references from the model to be rendered</font>
<font color="green"> 101.             model_state = self.models[(app_label, model_name)]</font>
<font color="black"> 102.             # Directly related models are the models pointed to by ForeignKeys,</font>
<font color="black"> 103.             # OneToOneFields, and ManyToManyFields.</font>
<font color="green"> 104.             direct_related_models = set()</font>
<font color="green"> 105.             for name, field in model_state.fields:</font>
<font color="green"> 106.                 if field.is_relation:</font>
<font color="green"> 107.                     if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:</font>
<font color="red"> 108.                         continue</font>
<font color="green"> 109.                     rel_app_label, rel_model_name = _get_app_label_and_model_name(field.related_model, app_label)</font>
<font color="green"> 110.                     direct_related_models.add((rel_app_label, rel_model_name.lower()))</font>
<font color="black"> 111. </font>
<font color="black"> 112.             # For all direct related models recursively get all related models.</font>
<font color="green"> 113.             related_models.update(direct_related_models)</font>
<font color="green"> 114.             for rel_app_label, rel_model_name in direct_related_models:</font>
<font color="green"> 115.                 try:</font>
<font color="green"> 116.                     rel_model = self.apps.get_model(rel_app_label, rel_model_name)</font>
<font color="red"> 117.                 except LookupError:</font>
<font color="red"> 118.                     pass</font>
<font color="black"> 119.                 else:</font>
<font color="green"> 120.                     related_models.update(get_related_models_recursive(rel_model))</font>
<font color="black"> 121. </font>
<font color="black"> 122.             # Include the model itself</font>
<font color="green"> 123.             related_models.add((app_label, model_name))</font>
<font color="black"> 124. </font>
<font color="black"> 125.             # Unregister all related models</font>
<font color="green"> 126.             with self.apps.bulk_update():</font>
<font color="green"> 127.                 for rel_app_label, rel_model_name in related_models:</font>
<font color="green"> 128.                     self.apps.unregister_model(rel_app_label, rel_model_name)</font>
<font color="black"> 129. </font>
<font color="green"> 130.             states_to_be_rendered = []</font>
<font color="black"> 131.             # Gather all models states of those models that will be rerendered.</font>
<font color="black"> 132.             # This includes:</font>
<font color="black"> 133.             # 1. All related models of unmigrated apps</font>
<font color="green"> 134.             for model_state in self.apps.real_models:</font>
<font color="red"> 135.                 if (model_state.app_label, model_state.name_lower) in related_models:</font>
<font color="red"> 136.                     states_to_be_rendered.append(model_state)</font>
<font color="black"> 137. </font>
<font color="black"> 138.             # 2. All related models of migrated apps</font>
<font color="green"> 139.             for rel_app_label, rel_model_name in related_models:</font>
<font color="green"> 140.                 try:</font>
<font color="green"> 141.                     model_state = self.models[rel_app_label, rel_model_name]</font>
<font color="green"> 142.                 except KeyError:</font>
<font color="green"> 143.                     pass</font>
<font color="black"> 144.                 else:</font>
<font color="green"> 145.                     states_to_be_rendered.append(model_state)</font>
<font color="black"> 146. </font>
<font color="black"> 147.             # Render all models</font>
<font color="green"> 148.             self.apps.render_multiple(states_to_be_rendered)</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def clone(self):</font>
<font color="black"> 151.         &quot;Returns an exact copy of this ProjectState&quot;</font>
<font color="green"> 152.         new_state = ProjectState(</font>
<font color="green"> 153.             models={k: v.clone() for k, v in self.models.items()},</font>
<font color="green"> 154.             real_apps=self.real_apps,</font>
<font color="black"> 155.         )</font>
<font color="green"> 156.         if 'apps' in self.__dict__:</font>
<font color="green"> 157.             new_state.apps = self.apps.clone()</font>
<font color="green"> 158.         return new_state</font>
<font color="black"> 159. </font>
<font color="green"> 160.     @cached_property</font>
<font color="black"> 161.     def apps(self):</font>
<font color="green"> 162.         return StateApps(self.real_apps, self.models)</font>
<font color="black"> 163. </font>
<font color="green"> 164.     @property</font>
<font color="black"> 165.     def concrete_apps(self):</font>
<font color="red"> 166.         self.apps = StateApps(self.real_apps, self.models, ignore_swappable=True)</font>
<font color="red"> 167.         return self.apps</font>
<font color="black"> 168. </font>
<font color="green"> 169.     @classmethod</font>
<font color="black"> 170.     def from_apps(cls, apps):</font>
<font color="black"> 171.         &quot;Takes in an Apps and returns a ProjectState matching it&quot;</font>
<font color="red"> 172.         app_models = {}</font>
<font color="red"> 173.         for model in apps.get_models(include_swapped=True):</font>
<font color="red"> 174.             model_state = ModelState.from_model(model)</font>
<font color="red"> 175.             app_models[(model_state.app_label, model_state.name_lower)] = model_state</font>
<font color="red"> 176.         return cls(app_models)</font>
<font color="black"> 177. </font>
<font color="green"> 178.     def __eq__(self, other):</font>
<font color="red"> 179.         if set(self.models.keys()) != set(other.models.keys()):</font>
<font color="red"> 180.             return False</font>
<font color="red"> 181.         if set(self.real_apps) != set(other.real_apps):</font>
<font color="red"> 182.             return False</font>
<font color="red"> 183.         return all(model == other.models[key] for key, model in self.models.items())</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def __ne__(self, other):</font>
<font color="red"> 186.         return not (self == other)</font>
<font color="black"> 187. </font>
<font color="black"> 188. </font>
<font color="green"> 189. class AppConfigStub(AppConfig):</font>
<font color="black"> 190.     &quot;&quot;&quot;</font>
<font color="black"> 191.     Stubs a Django AppConfig. Only provides a label, and a dict of models.</font>
<font color="green"> 192.     &quot;&quot;&quot;</font>
<font color="black"> 193.     # Not used, but required by AppConfig.__init__</font>
<font color="green"> 194.     path = ''</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def __init__(self, label):</font>
<font color="green"> 197.         self.label = label</font>
<font color="black"> 198.         # App-label and app-name are not the same thing, so technically passing</font>
<font color="black"> 199.         # in the label here is wrong. In practice, migrations don't care about</font>
<font color="black"> 200.         # the app name, but we need something unique, and the label works fine.</font>
<font color="green"> 201.         super(AppConfigStub, self).__init__(label, None)</font>
<font color="black"> 202. </font>
<font color="green"> 203.     def import_models(self, all_models):</font>
<font color="green"> 204.         self.models = all_models</font>
<font color="black"> 205. </font>
<font color="black"> 206. </font>
<font color="green"> 207. class StateApps(Apps):</font>
<font color="black"> 208.     &quot;&quot;&quot;</font>
<font color="black"> 209.     Subclass of the global Apps registry class to better handle dynamic model</font>
<font color="black"> 210.     additions and removals.</font>
<font color="green"> 211.     &quot;&quot;&quot;</font>
<font color="green"> 212.     def __init__(self, real_apps, models, ignore_swappable=False):</font>
<font color="black"> 213.         # Any apps in self.real_apps should have all their models included</font>
<font color="black"> 214.         # in the render. We don't use the original model instances as there</font>
<font color="black"> 215.         # are some variables that refer to the Apps object.</font>
<font color="black"> 216.         # FKs/M2Ms from real apps are also not included as they just</font>
<font color="black"> 217.         # mess things up with partial states (due to lack of dependencies)</font>
<font color="green"> 218.         self.real_models = []</font>
<font color="green"> 219.         for app_label in real_apps:</font>
<font color="green"> 220.             app = global_apps.get_app_config(app_label)</font>
<font color="green"> 221.             for model in app.get_models():</font>
<font color="red"> 222.                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))</font>
<font color="black"> 223.         # Populate the app registry with a stub for each application.</font>
<font color="green"> 224.         app_labels = {model_state.app_label for model_state in models.values()}</font>
<font color="green"> 225.         app_configs = [AppConfigStub(label) for label in sorted(real_apps + list(app_labels))]</font>
<font color="green"> 226.         super(StateApps, self).__init__(app_configs)</font>
<font color="black"> 227. </font>
<font color="green"> 228.         self.render_multiple(list(models.values()) + self.real_models)</font>
<font color="black"> 229. </font>
<font color="black"> 230.         # There shouldn't be any operations pending at this point.</font>
<font color="green"> 231.         pending_models = set(self._pending_operations)</font>
<font color="green"> 232.         if ignore_swappable:</font>
<font color="red"> 233.             pending_models -= {make_model_tuple(settings.AUTH_USER_MODEL)}</font>
<font color="green"> 234.         if pending_models:</font>
<font color="red"> 235.             raise ValueError(self._pending_models_error(pending_models))</font>
<font color="black"> 236. </font>
<font color="green"> 237.     def _pending_models_error(self, pending_models):</font>
<font color="black"> 238.         &quot;&quot;&quot;</font>
<font color="black"> 239.         Almost all internal uses of lazy operations are to resolve string model</font>
<font color="black"> 240.         references in related fields. We can extract the fields from those</font>
<font color="black"> 241.         operations and use them to provide a nicer error message.</font>
<font color="black"> 242. </font>
<font color="black"> 243.         This will work for any function passed to lazy_related_operation() that</font>
<font color="black"> 244.         has a keyword argument called 'field'.</font>
<font color="black"> 245.         &quot;&quot;&quot;</font>
<font color="red"> 246.         def extract_field(operation):</font>
<font color="black"> 247.             # operation is annotated with the field in</font>
<font color="black"> 248.             # apps.register.Apps.lazy_model_operation().</font>
<font color="red"> 249.             return getattr(operation, 'field', None)</font>
<font color="black"> 250. </font>
<font color="red"> 251.         def extract_field_names(operations):</font>
<font color="red"> 252.             return (str(field) for field in map(extract_field, operations) if field)</font>
<font color="black"> 253. </font>
<font color="red"> 254.         get_ops = self._pending_operations.__getitem__</font>
<font color="black"> 255.         # Ordered list of pairs of the form</font>
<font color="black"> 256.         # ((app_label, model_name), [field_name_1, field_name_2, ...])</font>
<font color="red"> 257.         models_fields = sorted(</font>
<font color="red"> 258.             (model_key, sorted(extract_field_names(get_ops(model_key))))</font>
<font color="red"> 259.             for model_key in pending_models</font>
<font color="black"> 260.         )</font>
<font color="black"> 261. </font>
<font color="red"> 262.         def model_text(model_key, fields):</font>
<font color="red"> 263.             field_list = &quot;, &quot;.join(fields)</font>
<font color="red"> 264.             field_text = &quot; (referred to by fields: %s)&quot; % field_list if fields else &quot;&quot;</font>
<font color="red"> 265.             return (&quot;%s.%s&quot; % model_key) + field_text</font>
<font color="black"> 266. </font>
<font color="red"> 267.         msg = &quot;Unhandled pending operations for models:&quot;</font>
<font color="red"> 268.         return &quot;\n  &quot;.join([msg] + [model_text(*i) for i in models_fields])</font>
<font color="black"> 269. </font>
<font color="green"> 270.     @contextmanager</font>
<font color="black"> 271.     def bulk_update(self):</font>
<font color="black"> 272.         # Avoid clearing each model's cache for each change. Instead, clear</font>
<font color="black"> 273.         # all caches when we're finished updating the model instances.</font>
<font color="green"> 274.         ready = self.ready</font>
<font color="green"> 275.         self.ready = False</font>
<font color="green"> 276.         try:</font>
<font color="green"> 277.             yield</font>
<font color="black"> 278.         finally:</font>
<font color="green"> 279.             self.ready = ready</font>
<font color="green"> 280.             self.clear_cache()</font>
<font color="black"> 281. </font>
<font color="green"> 282.     def render_multiple(self, model_states):</font>
<font color="black"> 283.         # We keep trying to render the models in a loop, ignoring invalid</font>
<font color="black"> 284.         # base errors, until the size of the unrendered models doesn't</font>
<font color="black"> 285.         # decrease by at least one, meaning there's a base dependency loop/</font>
<font color="black"> 286.         # missing base.</font>
<font color="green"> 287.         if not model_states:</font>
<font color="green"> 288.             return</font>
<font color="black"> 289.         # Prevent that all model caches are expired for each render.</font>
<font color="green"> 290.         with self.bulk_update():</font>
<font color="green"> 291.             unrendered_models = model_states</font>
<font color="green"> 292.             while unrendered_models:</font>
<font color="green"> 293.                 new_unrendered_models = []</font>
<font color="green"> 294.                 for model in unrendered_models:</font>
<font color="green"> 295.                     try:</font>
<font color="green"> 296.                         model.render(self)</font>
<font color="red"> 297.                     except InvalidBasesError:</font>
<font color="red"> 298.                         new_unrendered_models.append(model)</font>
<font color="green"> 299.                 if len(new_unrendered_models) == len(unrendered_models):</font>
<font color="red"> 300.                     raise InvalidBasesError(</font>
<font color="red"> 301.                         &quot;Cannot resolve bases for %r\nThis can happen if you are inheriting models from an &quot;</font>
<font color="black"> 302.                         &quot;app with migrations (e.g. contrib.auth)\n in an app with no migrations; see &quot;</font>
<font color="black"> 303.                         &quot;https://docs.djangoproject.com/en/%s/topics/migrations/#dependencies &quot;</font>
<font color="red"> 304.                         &quot;for more&quot; % (new_unrendered_models, get_docs_version())</font>
<font color="black"> 305.                     )</font>
<font color="green"> 306.                 unrendered_models = new_unrendered_models</font>
<font color="black"> 307. </font>
<font color="green"> 308.     def clone(self):</font>
<font color="black"> 309.         &quot;&quot;&quot;</font>
<font color="black"> 310.         Return a clone of this registry, mainly used by the migration framework.</font>
<font color="black"> 311.         &quot;&quot;&quot;</font>
<font color="green"> 312.         clone = StateApps([], {})</font>
<font color="green"> 313.         clone.all_models = copy.deepcopy(self.all_models)</font>
<font color="green"> 314.         clone.app_configs = copy.deepcopy(self.app_configs)</font>
<font color="black"> 315.         # No need to actually clone them, they'll never change</font>
<font color="green"> 316.         clone.real_models = self.real_models</font>
<font color="green"> 317.         return clone</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def register_model(self, app_label, model):</font>
<font color="green"> 320.         self.all_models[app_label][model._meta.model_name] = model</font>
<font color="green"> 321.         if app_label not in self.app_configs:</font>
<font color="green"> 322.             self.app_configs[app_label] = AppConfigStub(app_label)</font>
<font color="green"> 323.             self.app_configs[app_label].models = OrderedDict()</font>
<font color="green"> 324.         self.app_configs[app_label].models[model._meta.model_name] = model</font>
<font color="green"> 325.         self.do_pending_operations(model)</font>
<font color="green"> 326.         self.clear_cache()</font>
<font color="black"> 327. </font>
<font color="green"> 328.     def unregister_model(self, app_label, model_name):</font>
<font color="green"> 329.         try:</font>
<font color="green"> 330.             del self.all_models[app_label][model_name]</font>
<font color="green"> 331.             del self.app_configs[app_label].models[model_name]</font>
<font color="green"> 332.         except KeyError:</font>
<font color="green"> 333.             pass</font>
<font color="black"> 334. </font>
<font color="black"> 335. </font>
<font color="green"> 336. class ModelState(object):</font>
<font color="black"> 337.     &quot;&quot;&quot;</font>
<font color="black"> 338.     Represents a Django Model. We don't use the actual Model class</font>
<font color="black"> 339.     as it's not designed to have its options changed - instead, we</font>
<font color="black"> 340.     mutate this one and then render it into a Model as required.</font>
<font color="black"> 341. </font>
<font color="black"> 342.     Note that while you are allowed to mutate .fields, you are not allowed</font>
<font color="black"> 343.     to mutate the Field instances inside there themselves - you must instead</font>
<font color="black"> 344.     assign new ones, as these are not detached during a clone.</font>
<font color="green"> 345.     &quot;&quot;&quot;</font>
<font color="black"> 346. </font>
<font color="green"> 347.     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):</font>
<font color="green"> 348.         self.app_label = app_label</font>
<font color="green"> 349.         self.name = force_text(name)</font>
<font color="green"> 350.         self.fields = fields</font>
<font color="green"> 351.         self.options = options or {}</font>
<font color="green"> 352.         self.bases = bases or (models.Model, )</font>
<font color="green"> 353.         self.managers = managers or []</font>
<font color="black"> 354.         # Sanity-check that fields is NOT a dict. It must be ordered.</font>
<font color="green"> 355.         if isinstance(self.fields, dict):</font>
<font color="red"> 356.             raise ValueError(&quot;ModelState.fields cannot be a dict - it must be a list of 2-tuples.&quot;)</font>
<font color="green"> 357.         for name, field in fields:</font>
<font color="black"> 358.             # Sanity-check that fields are NOT already bound to a model.</font>
<font color="green"> 359.             if hasattr(field, 'model'):</font>
<font color="red"> 360.                 raise ValueError(</font>
<font color="red"> 361.                     'ModelState.fields cannot be bound to a model - &quot;%s&quot; is.' % name</font>
<font color="black"> 362.                 )</font>
<font color="black"> 363.             # Sanity-check that relation fields are NOT referring to a model class.</font>
<font color="green"> 364.             if field.is_relation and hasattr(field.related_model, '_meta'):</font>
<font color="red"> 365.                 raise ValueError(</font>
<font color="red"> 366.                     'ModelState.fields cannot refer to a model class - &quot;%s.to&quot; does. '</font>
<font color="red"> 367.                     'Use a string reference instead.' % name</font>
<font color="black"> 368.                 )</font>
<font color="green"> 369.             if field.many_to_many and hasattr(field.remote_field.through, '_meta'):</font>
<font color="red"> 370.                 raise ValueError(</font>
<font color="red"> 371.                     'ModelState.fields cannot refer to a model class - &quot;%s.through&quot; does. '</font>
<font color="red"> 372.                     'Use a string reference instead.' % name</font>
<font color="black"> 373.                 )</font>
<font color="black"> 374. </font>
<font color="green"> 375.     @cached_property</font>
<font color="black"> 376.     def name_lower(self):</font>
<font color="green"> 377.         return self.name.lower()</font>
<font color="black"> 378. </font>
<font color="green"> 379.     @classmethod</font>
<font color="green"> 380.     def from_model(cls, model, exclude_rels=False):</font>
<font color="black"> 381.         &quot;&quot;&quot;</font>
<font color="black"> 382.         Feed me a model, get a ModelState representing it out.</font>
<font color="black"> 383.         &quot;&quot;&quot;</font>
<font color="black"> 384.         # Deconstruct the fields</font>
<font color="red"> 385.         fields = []</font>
<font color="red"> 386.         for field in model._meta.local_fields:</font>
<font color="red"> 387.             if getattr(field, &quot;remote_field&quot;, None) and exclude_rels:</font>
<font color="red"> 388.                 continue</font>
<font color="red"> 389.             if isinstance(field, OrderWrt):</font>
<font color="red"> 390.                 continue</font>
<font color="red"> 391.             name = force_text(field.name, strings_only=True)</font>
<font color="red"> 392.             try:</font>
<font color="red"> 393.                 fields.append((name, field.clone()))</font>
<font color="red"> 394.             except TypeError as e:</font>
<font color="red"> 395.                 raise TypeError(&quot;Couldn't reconstruct field %s on %s: %s&quot; % (</font>
<font color="red"> 396.                     name,</font>
<font color="red"> 397.                     model._meta.label,</font>
<font color="red"> 398.                     e,</font>
<font color="black"> 399.                 ))</font>
<font color="red"> 400.         if not exclude_rels:</font>
<font color="red"> 401.             for field in model._meta.local_many_to_many:</font>
<font color="red"> 402.                 name = force_text(field.name, strings_only=True)</font>
<font color="red"> 403.                 try:</font>
<font color="red"> 404.                     fields.append((name, field.clone()))</font>
<font color="red"> 405.                 except TypeError as e:</font>
<font color="red"> 406.                     raise TypeError(&quot;Couldn't reconstruct m2m field %s on %s: %s&quot; % (</font>
<font color="red"> 407.                         name,</font>
<font color="red"> 408.                         model._meta.object_name,</font>
<font color="red"> 409.                         e,</font>
<font color="black"> 410.                     ))</font>
<font color="black"> 411.         # Extract the options</font>
<font color="red"> 412.         options = {}</font>
<font color="red"> 413.         for name in DEFAULT_NAMES:</font>
<font color="black"> 414.             # Ignore some special options</font>
<font color="red"> 415.             if name in [&quot;apps&quot;, &quot;app_label&quot;]:</font>
<font color="red"> 416.                 continue</font>
<font color="red"> 417.             elif name in model._meta.original_attrs:</font>
<font color="red"> 418.                 if name == &quot;unique_together&quot;:</font>
<font color="red"> 419.                     ut = model._meta.original_attrs[&quot;unique_together&quot;]</font>
<font color="red"> 420.                     options[name] = set(normalize_together(ut))</font>
<font color="red"> 421.                 elif name == &quot;index_together&quot;:</font>
<font color="red"> 422.                     it = model._meta.original_attrs[&quot;index_together&quot;]</font>
<font color="red"> 423.                     options[name] = set(normalize_together(it))</font>
<font color="black"> 424.                 else:</font>
<font color="red"> 425.                     options[name] = model._meta.original_attrs[name]</font>
<font color="black"> 426.         # Force-convert all options to text_type (#23226)</font>
<font color="red"> 427.         options = cls.force_text_recursive(options)</font>
<font color="black"> 428.         # If we're ignoring relationships, remove all field-listing model</font>
<font color="black"> 429.         # options (that option basically just means &quot;make a stub model&quot;)</font>
<font color="red"> 430.         if exclude_rels:</font>
<font color="red"> 431.             for key in [&quot;unique_together&quot;, &quot;index_together&quot;, &quot;order_with_respect_to&quot;]:</font>
<font color="red"> 432.                 if key in options:</font>
<font color="red"> 433.                     del options[key]</font>
<font color="black"> 434. </font>
<font color="red"> 435.         def flatten_bases(model):</font>
<font color="red"> 436.             bases = []</font>
<font color="red"> 437.             for base in model.__bases__:</font>
<font color="red"> 438.                 if hasattr(base, &quot;_meta&quot;) and base._meta.abstract:</font>
<font color="red"> 439.                     bases.extend(flatten_bases(base))</font>
<font color="black"> 440.                 else:</font>
<font color="red"> 441.                     bases.append(base)</font>
<font color="red"> 442.             return bases</font>
<font color="black"> 443. </font>
<font color="black"> 444.         # We can't rely on __mro__ directly because we only want to flatten</font>
<font color="black"> 445.         # abstract models and not the whole tree. However by recursing on</font>
<font color="black"> 446.         # __bases__ we may end up with duplicates and ordering issues, we</font>
<font color="black"> 447.         # therefore discard any duplicates and reorder the bases according</font>
<font color="black"> 448.         # to their index in the MRO.</font>
<font color="red"> 449.         flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))</font>
<font color="black"> 450. </font>
<font color="black"> 451.         # Make our record</font>
<font color="red"> 452.         bases = tuple(</font>
<font color="red"> 453.             (</font>
<font color="black"> 454.                 base._meta.label_lower</font>
<font color="black"> 455.                 if hasattr(base, &quot;_meta&quot;) else</font>
<font color="black"> 456.                 base</font>
<font color="black"> 457.             )</font>
<font color="red"> 458.             for base in flattened_bases</font>
<font color="black"> 459.         )</font>
<font color="black"> 460.         # Ensure at least one base inherits from models.Model</font>
<font color="red"> 461.         if not any((isinstance(base, six.string_types) or issubclass(base, models.Model)) for base in bases):</font>
<font color="red"> 462.             bases = (models.Model,)</font>
<font color="black"> 463. </font>
<font color="black"> 464.         # Constructs all managers on the model</font>
<font color="red"> 465.         managers_mapping = {}</font>
<font color="black"> 466. </font>
<font color="red"> 467.         def reconstruct_manager(mgr):</font>
<font color="red"> 468.             as_manager, manager_path, qs_path, args, kwargs = mgr.deconstruct()</font>
<font color="red"> 469.             if as_manager:</font>
<font color="red"> 470.                 qs_class = import_string(qs_path)</font>
<font color="red"> 471.                 instance = qs_class.as_manager()</font>
<font color="black"> 472.             else:</font>
<font color="red"> 473.                 manager_class = import_string(manager_path)</font>
<font color="red"> 474.                 instance = manager_class(*args, **kwargs)</font>
<font color="black"> 475.             # We rely on the ordering of the creation_counter of the original</font>
<font color="black"> 476.             # instance</font>
<font color="red"> 477.             name = force_text(mgr.name)</font>
<font color="red"> 478.             managers_mapping[name] = (mgr.creation_counter, instance)</font>
<font color="black"> 479. </font>
<font color="red"> 480.         if hasattr(model, &quot;_default_manager&quot;):</font>
<font color="red"> 481.             default_manager_name = force_text(model._default_manager.name)</font>
<font color="black"> 482.             # Make sure the default manager is always the first</font>
<font color="red"> 483.             if model._default_manager.use_in_migrations:</font>
<font color="red"> 484.                 reconstruct_manager(model._default_manager)</font>
<font color="black"> 485.             else:</font>
<font color="black"> 486.                 # Force this manager to be the first and thus default</font>
<font color="red"> 487.                 managers_mapping[default_manager_name] = (0, models.Manager())</font>
<font color="black"> 488.             # Sort all managers by their creation counter</font>
<font color="red"> 489.             for _, manager, _ in sorted(model._meta.managers):</font>
<font color="red"> 490.                 if manager.name == &quot;_base_manager&quot; or not manager.use_in_migrations:</font>
<font color="red"> 491.                     continue</font>
<font color="red"> 492.                 reconstruct_manager(manager)</font>
<font color="black"> 493.             # Sort all managers by their creation counter but take only name and</font>
<font color="black"> 494.             # instance for further processing</font>
<font color="black"> 495.             managers = [</font>
<font color="red"> 496.                 (name, instance) for name, (cc, instance) in</font>
<font color="red"> 497.                 sorted(managers_mapping.items(), key=lambda v: v[1])</font>
<font color="black"> 498.             ]</font>
<font color="black"> 499.             # If the only manager on the model is the default manager defined</font>
<font color="black"> 500.             # by Django (`objects = models.Manager()`), this manager will not</font>
<font color="black"> 501.             # be added to the model state.</font>
<font color="red"> 502.             if managers == [('objects', models.Manager())]:</font>
<font color="red"> 503.                 managers = []</font>
<font color="black"> 504.         else:</font>
<font color="red"> 505.             managers = []</font>
<font color="black"> 506. </font>
<font color="black"> 507.         # Construct the new ModelState</font>
<font color="red"> 508.         return cls(</font>
<font color="red"> 509.             model._meta.app_label,</font>
<font color="red"> 510.             model._meta.object_name,</font>
<font color="red"> 511.             fields,</font>
<font color="red"> 512.             options,</font>
<font color="red"> 513.             bases,</font>
<font color="red"> 514.             managers,</font>
<font color="black"> 515.         )</font>
<font color="black"> 516. </font>
<font color="green"> 517.     @classmethod</font>
<font color="black"> 518.     def force_text_recursive(cls, value):</font>
<font color="red"> 519.         if isinstance(value, six.string_types):</font>
<font color="red"> 520.             return smart_text(value)</font>
<font color="red"> 521.         elif isinstance(value, list):</font>
<font color="red"> 522.             return [cls.force_text_recursive(x) for x in value]</font>
<font color="red"> 523.         elif isinstance(value, tuple):</font>
<font color="red"> 524.             return tuple(cls.force_text_recursive(x) for x in value)</font>
<font color="red"> 525.         elif isinstance(value, set):</font>
<font color="red"> 526.             return set(cls.force_text_recursive(x) for x in value)</font>
<font color="red"> 527.         elif isinstance(value, dict):</font>
<font color="black"> 528.             return {</font>
<font color="red"> 529.                 cls.force_text_recursive(k): cls.force_text_recursive(v)</font>
<font color="red"> 530.                 for k, v in value.items()</font>
<font color="black"> 531.             }</font>
<font color="red"> 532.         return value</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def construct_managers(self):</font>
<font color="black"> 535.         &quot;Deep-clone the managers using deconstruction&quot;</font>
<font color="black"> 536.         # Sort all managers by their creation counter</font>
<font color="green"> 537.         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)</font>
<font color="green"> 538.         for mgr_name, manager in sorted_managers:</font>
<font color="green"> 539.             mgr_name = force_text(mgr_name)</font>
<font color="green"> 540.             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()</font>
<font color="green"> 541.             if as_manager:</font>
<font color="red"> 542.                 qs_class = import_string(qs_path)</font>
<font color="red"> 543.                 yield mgr_name, qs_class.as_manager()</font>
<font color="black"> 544.             else:</font>
<font color="green"> 545.                 manager_class = import_string(manager_path)</font>
<font color="green"> 546.                 yield mgr_name, manager_class(*args, **kwargs)</font>
<font color="black"> 547. </font>
<font color="green"> 548.     def clone(self):</font>
<font color="black"> 549.         &quot;Returns an exact copy of this ModelState&quot;</font>
<font color="green"> 550.         return self.__class__(</font>
<font color="green"> 551.             app_label=self.app_label,</font>
<font color="green"> 552.             name=self.name,</font>
<font color="green"> 553.             fields=list(self.fields),</font>
<font color="green"> 554.             options=dict(self.options),</font>
<font color="green"> 555.             bases=self.bases,</font>
<font color="green"> 556.             managers=list(self.managers),</font>
<font color="black"> 557.         )</font>
<font color="black"> 558. </font>
<font color="green"> 559.     def render(self, apps):</font>
<font color="black"> 560.         &quot;Creates a Model object from our current state into the given apps&quot;</font>
<font color="black"> 561.         # First, make a Meta object</font>
<font color="green"> 562.         meta_contents = {'app_label': self.app_label, &quot;apps&quot;: apps}</font>
<font color="green"> 563.         meta_contents.update(self.options)</font>
<font color="green"> 564.         meta = type(str(&quot;Meta&quot;), tuple(), meta_contents)</font>
<font color="black"> 565.         # Then, work out our bases</font>
<font color="green"> 566.         try:</font>
<font color="green"> 567.             bases = tuple(</font>
<font color="green"> 568.                 (apps.get_model(base) if isinstance(base, six.string_types) else base)</font>
<font color="green"> 569.                 for base in self.bases</font>
<font color="black"> 570.             )</font>
<font color="red"> 571.         except LookupError:</font>
<font color="red"> 572.             raise InvalidBasesError(&quot;Cannot resolve one or more bases from %r&quot; % (self.bases,))</font>
<font color="black"> 573.         # Turn fields into a dict for the body, add other bits</font>
<font color="green"> 574.         body = {name: field.clone() for name, field in self.fields}</font>
<font color="green"> 575.         body['Meta'] = meta</font>
<font color="green"> 576.         body['__module__'] = &quot;__fake__&quot;</font>
<font color="black"> 577. </font>
<font color="black"> 578.         # Restore managers</font>
<font color="green"> 579.         body.update(self.construct_managers())</font>
<font color="black"> 580. </font>
<font color="black"> 581.         # Then, make a Model object (apps.register_model is called in __new__)</font>
<font color="green"> 582.         return type(</font>
<font color="green"> 583.             str(self.name),</font>
<font color="green"> 584.             bases,</font>
<font color="green"> 585.             body,</font>
<font color="black"> 586.         )</font>
<font color="black"> 587. </font>
<font color="green"> 588.     def get_field_by_name(self, name):</font>
<font color="red"> 589.         for fname, field in self.fields:</font>
<font color="red"> 590.             if fname == name:</font>
<font color="red"> 591.                 return field</font>
<font color="red"> 592.         raise ValueError(&quot;No field called %s on model %s&quot; % (name, self.name))</font>
<font color="black"> 593. </font>
<font color="green"> 594.     def __repr__(self):</font>
<font color="red"> 595.         return &quot;&lt;ModelState: '%s.%s'&gt;&quot; % (self.app_label, self.name)</font>
<font color="black"> 596. </font>
<font color="green"> 597.     def __eq__(self, other):</font>
<font color="black"> 598.         return (</font>
<font color="red"> 599.             (self.app_label == other.app_label) and</font>
<font color="red"> 600.             (self.name == other.name) and</font>
<font color="red"> 601.             (len(self.fields) == len(other.fields)) and</font>
<font color="red"> 602.             all((k1 == k2 and (f1.deconstruct()[1:] == f2.deconstruct()[1:]))</font>
<font color="red"> 603.                 for (k1, f1), (k2, f2) in zip(self.fields, other.fields)) and</font>
<font color="red"> 604.             (self.options == other.options) and</font>
<font color="red"> 605.             (self.bases == other.bases) and</font>
<font color="red"> 606.             (self.managers == other.managers)</font>
<font color="black"> 607.         )</font>
<font color="black"> 608. </font>
<font color="green"> 609.     def __ne__(self, other):</font>
<font color="red"> 610.         return not (self == other)</font>
</pre>

