source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/migrations/graph.py</b><br>


file stats: <b>170 lines, 102 executed: 60.0% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import warnings</font>
<font color="green">   4. from collections import deque</font>
<font color="green">   5. from functools import total_ordering</font>
<font color="black">   6. </font>
<font color="green">   7. from django.db.migrations.state import ProjectState</font>
<font color="green">   8. from django.utils.datastructures import OrderedSet</font>
<font color="green">   9. from django.utils.encoding import python_2_unicode_compatible</font>
<font color="black">  10. </font>
<font color="green">  11. from .exceptions import CircularDependencyError, NodeNotFoundError</font>
<font color="black">  12. </font>
<font color="black">  13. RECURSION_DEPTH_WARNING = (</font>
<font color="green">  14.     &quot;Maximum recursion depth exceeded while generating migration graph, &quot;</font>
<font color="black">  15.     &quot;falling back to iterative approach. If you're experiencing performance issues, &quot;</font>
<font color="black">  16.     &quot;consider squashing migrations as described at &quot;</font>
<font color="black">  17.     &quot;https://docs.djangoproject.com/en/dev/topics/migrations/#squashing-migrations.&quot;</font>
<font color="black">  18. )</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. @python_2_unicode_compatible</font>
<font color="green">  22. @total_ordering</font>
<font color="green">  23. class Node(object):</font>
<font color="black">  24.     &quot;&quot;&quot;</font>
<font color="black">  25.     A single node in the migration graph. Contains direct links to adjacent</font>
<font color="black">  26.     nodes in either direction.</font>
<font color="green">  27.     &quot;&quot;&quot;</font>
<font color="green">  28.     def __init__(self, key):</font>
<font color="green">  29.         self.key = key</font>
<font color="green">  30.         self.children = set()</font>
<font color="green">  31.         self.parents = set()</font>
<font color="black">  32. </font>
<font color="green">  33.     def __eq__(self, other):</font>
<font color="green">  34.         return self.key == other</font>
<font color="black">  35. </font>
<font color="green">  36.     def __lt__(self, other):</font>
<font color="green">  37.         return self.key &lt; other</font>
<font color="black">  38. </font>
<font color="green">  39.     def __hash__(self):</font>
<font color="green">  40.         return hash(self.key)</font>
<font color="black">  41. </font>
<font color="green">  42.     def __getitem__(self, item):</font>
<font color="green">  43.         return self.key[item]</font>
<font color="black">  44. </font>
<font color="green">  45.     def __str__(self):</font>
<font color="red">  46.         return str(self.key)</font>
<font color="black">  47. </font>
<font color="green">  48.     def __repr__(self):</font>
<font color="red">  49.         return '&lt;Node: (%r, %r)&gt;' % self.key</font>
<font color="black">  50. </font>
<font color="green">  51.     def add_child(self, child):</font>
<font color="green">  52.         self.children.add(child)</font>
<font color="black">  53. </font>
<font color="green">  54.     def add_parent(self, parent):</font>
<font color="green">  55.         self.parents.add(parent)</font>
<font color="black">  56. </font>
<font color="black">  57.     # Use manual caching, @cached_property effectively doubles the</font>
<font color="black">  58.     # recursion depth for each recursion.</font>
<font color="green">  59.     def ancestors(self):</font>
<font color="black">  60.         # Use self.key instead of self to speed up the frequent hashing</font>
<font color="black">  61.         # when constructing an OrderedSet.</font>
<font color="green">  62.         if '_ancestors' not in self.__dict__:</font>
<font color="green">  63.             ancestors = deque([self.key])</font>
<font color="green">  64.             for parent in sorted(self.parents):</font>
<font color="green">  65.                 ancestors.extendleft(reversed(parent.ancestors()))</font>
<font color="green">  66.             self.__dict__['_ancestors'] = list(OrderedSet(ancestors))</font>
<font color="green">  67.         return self.__dict__['_ancestors']</font>
<font color="black">  68. </font>
<font color="black">  69.     # Use manual caching, @cached_property effectively doubles the</font>
<font color="black">  70.     # recursion depth for each recursion.</font>
<font color="green">  71.     def descendants(self):</font>
<font color="black">  72.         # Use self.key instead of self to speed up the frequent hashing</font>
<font color="black">  73.         # when constructing an OrderedSet.</font>
<font color="red">  74.         if '_descendants' not in self.__dict__:</font>
<font color="red">  75.             descendants = deque([self.key])</font>
<font color="red">  76.             for child in sorted(self.children):</font>
<font color="red">  77.                 descendants.extendleft(reversed(child.descendants()))</font>
<font color="red">  78.             self.__dict__['_descendants'] = list(OrderedSet(descendants))</font>
<font color="red">  79.         return self.__dict__['_descendants']</font>
<font color="black">  80. </font>
<font color="black">  81. </font>
<font color="green">  82. @python_2_unicode_compatible</font>
<font color="green">  83. class MigrationGraph(object):</font>
<font color="black">  84.     &quot;&quot;&quot;</font>
<font color="black">  85.     Represents the digraph of all migrations in a project.</font>
<font color="black">  86. </font>
<font color="black">  87.     Each migration is a node, and each dependency is an edge. There are</font>
<font color="black">  88.     no implicit dependencies between numbered migrations - the numbering is</font>
<font color="black">  89.     merely a convention to aid file listing. Every new numbered migration</font>
<font color="black">  90.     has a declared dependency to the previous number, meaning that VCS</font>
<font color="black">  91.     branch merges can be detected and resolved.</font>
<font color="black">  92. </font>
<font color="black">  93.     Migrations files can be marked as replacing another set of migrations -</font>
<font color="black">  94.     this is to support the &quot;squash&quot; feature. The graph handler isn't responsible</font>
<font color="black">  95.     for these; instead, the code to load them in here should examine the</font>
<font color="black">  96.     migration files and if the replaced migrations are all either unapplied</font>
<font color="black">  97.     or not present, it should ignore the replaced ones, load in just the</font>
<font color="black">  98.     replacing migration, and repoint any dependencies that pointed to the</font>
<font color="black">  99.     replaced migrations to point to the replacing one.</font>
<font color="black"> 100. </font>
<font color="black"> 101.     A node should be a tuple: (app_path, migration_name). The tree special-cases</font>
<font color="black"> 102.     things within an app - namely, root nodes and leaf nodes ignore dependencies</font>
<font color="black"> 103.     to other apps.</font>
<font color="green"> 104.     &quot;&quot;&quot;</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def __init__(self):</font>
<font color="green"> 107.         self.node_map = {}</font>
<font color="green"> 108.         self.nodes = {}</font>
<font color="green"> 109.         self.cached = False</font>
<font color="black"> 110. </font>
<font color="green"> 111.     def add_node(self, key, implementation):</font>
<font color="green"> 112.         node = Node(key)</font>
<font color="green"> 113.         self.node_map[key] = node</font>
<font color="green"> 114.         self.nodes[key] = implementation</font>
<font color="green"> 115.         self.clear_cache()</font>
<font color="black"> 116. </font>
<font color="green"> 117.     def add_dependency(self, migration, child, parent):</font>
<font color="green"> 118.         if child not in self.nodes:</font>
<font color="red"> 119.             raise NodeNotFoundError(</font>
<font color="red"> 120.                 &quot;Migration %s dependencies reference nonexistent child node %r&quot; % (migration, child),</font>
<font color="red"> 121.                 child</font>
<font color="black"> 122.             )</font>
<font color="green"> 123.         if parent not in self.nodes:</font>
<font color="red"> 124.             raise NodeNotFoundError(</font>
<font color="red"> 125.                 &quot;Migration %s dependencies reference nonexistent parent node %r&quot; % (migration, parent),</font>
<font color="red"> 126.                 parent</font>
<font color="black"> 127.             )</font>
<font color="green"> 128.         self.node_map[child].add_parent(self.node_map[parent])</font>
<font color="green"> 129.         self.node_map[parent].add_child(self.node_map[child])</font>
<font color="green"> 130.         self.clear_cache()</font>
<font color="black"> 131. </font>
<font color="green"> 132.     def clear_cache(self):</font>
<font color="green"> 133.         if self.cached:</font>
<font color="red"> 134.             for node in self.nodes:</font>
<font color="red"> 135.                 self.node_map[node].__dict__.pop('_ancestors', None)</font>
<font color="red"> 136.                 self.node_map[node].__dict__.pop('_descendants', None)</font>
<font color="red"> 137.             self.cached = False</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def forwards_plan(self, target):</font>
<font color="black"> 140.         &quot;&quot;&quot;</font>
<font color="black"> 141.         Given a node, returns a list of which previous nodes (dependencies)</font>
<font color="black"> 142.         must be applied, ending with the node itself.</font>
<font color="black"> 143.         This is the list you would follow if applying the migrations to</font>
<font color="black"> 144.         a database.</font>
<font color="black"> 145.         &quot;&quot;&quot;</font>
<font color="green"> 146.         if target not in self.nodes:</font>
<font color="red"> 147.             raise NodeNotFoundError(&quot;Node %r not a valid node&quot; % (target, ), target)</font>
<font color="black"> 148.         # Use parent.key instead of parent to speed up the frequent hashing in ensure_not_cyclic</font>
<font color="green"> 149.         self.ensure_not_cyclic(target, lambda x: (parent.key for parent in self.node_map[x].parents))</font>
<font color="green"> 150.         self.cached = True</font>
<font color="green"> 151.         node = self.node_map[target]</font>
<font color="green"> 152.         try:</font>
<font color="green"> 153.             return node.ancestors()</font>
<font color="red"> 154.         except RuntimeError:</font>
<font color="black"> 155.             # fallback to iterative dfs</font>
<font color="red"> 156.             warnings.warn(RECURSION_DEPTH_WARNING, RuntimeWarning)</font>
<font color="red"> 157.             return self.iterative_dfs(node)</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def backwards_plan(self, target):</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="black"> 161.         Given a node, returns a list of which dependent nodes (dependencies)</font>
<font color="black"> 162.         must be unapplied, ending with the node itself.</font>
<font color="black"> 163.         This is the list you would follow if removing the migrations from</font>
<font color="black"> 164.         a database.</font>
<font color="black"> 165.         &quot;&quot;&quot;</font>
<font color="red"> 166.         if target not in self.nodes:</font>
<font color="red"> 167.             raise NodeNotFoundError(&quot;Node %r not a valid node&quot; % (target, ), target)</font>
<font color="black"> 168.         # Use child.key instead of child to speed up the frequent hashing in ensure_not_cyclic</font>
<font color="red"> 169.         self.ensure_not_cyclic(target, lambda x: (child.key for child in self.node_map[x].children))</font>
<font color="red"> 170.         self.cached = True</font>
<font color="red"> 171.         node = self.node_map[target]</font>
<font color="red"> 172.         try:</font>
<font color="red"> 173.             return node.descendants()</font>
<font color="red"> 174.         except RuntimeError:</font>
<font color="black"> 175.             # fallback to iterative dfs</font>
<font color="red"> 176.             warnings.warn(RECURSION_DEPTH_WARNING, RuntimeWarning)</font>
<font color="red"> 177.             return self.iterative_dfs(node, forwards=False)</font>
<font color="black"> 178. </font>
<font color="green"> 179.     def iterative_dfs(self, start, forwards=True):</font>
<font color="black"> 180.         &quot;&quot;&quot;</font>
<font color="black"> 181.         Iterative depth first search, for finding dependencies.</font>
<font color="black"> 182.         &quot;&quot;&quot;</font>
<font color="red"> 183.         visited = deque()</font>
<font color="red"> 184.         visited.append(start)</font>
<font color="red"> 185.         if forwards:</font>
<font color="red"> 186.             stack = deque(sorted(start.parents))</font>
<font color="black"> 187.         else:</font>
<font color="red"> 188.             stack = deque(sorted(start.children))</font>
<font color="red"> 189.         while stack:</font>
<font color="red"> 190.             node = stack.popleft()</font>
<font color="red"> 191.             visited.appendleft(node)</font>
<font color="red"> 192.             if forwards:</font>
<font color="red"> 193.                 children = sorted(node.parents, reverse=True)</font>
<font color="black"> 194.             else:</font>
<font color="red"> 195.                 children = sorted(node.children, reverse=True)</font>
<font color="black"> 196.             # reverse sorting is needed because prepending using deque.extendleft</font>
<font color="black"> 197.             # also effectively reverses values</font>
<font color="red"> 198.             stack.extendleft(children)</font>
<font color="black"> 199. </font>
<font color="red"> 200.         return list(OrderedSet(visited))</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def root_nodes(self, app=None):</font>
<font color="black"> 203.         &quot;&quot;&quot;</font>
<font color="black"> 204.         Returns all root nodes - that is, nodes with no dependencies inside</font>
<font color="black"> 205.         their app. These are the starting point for an app.</font>
<font color="black"> 206.         &quot;&quot;&quot;</font>
<font color="green"> 207.         roots = set()</font>
<font color="green"> 208.         for node in self.nodes:</font>
<font color="green"> 209.             if (not any(key[0] == node[0] for key in self.node_map[node].parents)</font>
<font color="green"> 210.                     and (not app or app == node[0])):</font>
<font color="green"> 211.                 roots.add(node)</font>
<font color="green"> 212.         return sorted(roots)</font>
<font color="black"> 213. </font>
<font color="green"> 214.     def leaf_nodes(self, app=None):</font>
<font color="black"> 215.         &quot;&quot;&quot;</font>
<font color="black"> 216.         Returns all leaf nodes - that is, nodes with no dependents in their app.</font>
<font color="black"> 217.         These are the &quot;most current&quot; version of an app's schema.</font>
<font color="black"> 218.         Having more than one per app is technically an error, but one that</font>
<font color="black"> 219.         gets handled further up, in the interactive command - it's usually the</font>
<font color="black"> 220.         result of a VCS merge and needs some user input.</font>
<font color="black"> 221.         &quot;&quot;&quot;</font>
<font color="green"> 222.         leaves = set()</font>
<font color="green"> 223.         for node in self.nodes:</font>
<font color="green"> 224.             if (not any(key[0] == node[0] for key in self.node_map[node].children)</font>
<font color="green"> 225.                     and (not app or app == node[0])):</font>
<font color="green"> 226.                 leaves.add(node)</font>
<font color="green"> 227.         return sorted(leaves)</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def ensure_not_cyclic(self, start, get_children):</font>
<font color="black"> 230.         # Algo from GvR:</font>
<font color="black"> 231.         # http://neopythonic.blogspot.co.uk/2009/01/detecting-cycles-in-directed-graph.html</font>
<font color="green"> 232.         todo = set(self.nodes)</font>
<font color="green"> 233.         while todo:</font>
<font color="green"> 234.             node = todo.pop()</font>
<font color="green"> 235.             stack = [node]</font>
<font color="green"> 236.             while stack:</font>
<font color="green"> 237.                 top = stack[-1]</font>
<font color="green"> 238.                 for node in get_children(top):</font>
<font color="green"> 239.                     if node in stack:</font>
<font color="red"> 240.                         cycle = stack[stack.index(node):]</font>
<font color="red"> 241.                         raise CircularDependencyError(&quot;, &quot;.join(&quot;%s.%s&quot; % n for n in cycle))</font>
<font color="green"> 242.                     if node in todo:</font>
<font color="green"> 243.                         stack.append(node)</font>
<font color="green"> 244.                         todo.remove(node)</font>
<font color="green"> 245.                         break</font>
<font color="black"> 246.                 else:</font>
<font color="green"> 247.                     node = stack.pop()</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def __str__(self):</font>
<font color="red"> 250.         return 'Graph: %s nodes, %s edges' % self._nodes_and_edges()</font>
<font color="black"> 251. </font>
<font color="green"> 252.     def __repr__(self):</font>
<font color="red"> 253.         nodes, edges = self._nodes_and_edges()</font>
<font color="red"> 254.         return '&lt;%s: nodes=%s, edges=%s&gt;' % (self.__class__.__name__, nodes, edges)</font>
<font color="black"> 255. </font>
<font color="green"> 256.     def _nodes_and_edges(self):</font>
<font color="red"> 257.         return len(self.nodes), sum(len(node.parents) for node in self.node_map.values())</font>
<font color="black"> 258. </font>
<font color="green"> 259.     def make_state(self, nodes=None, at_end=True, real_apps=None):</font>
<font color="black"> 260.         &quot;&quot;&quot;</font>
<font color="black"> 261.         Given a migration node or nodes, returns a complete ProjectState for it.</font>
<font color="black"> 262.         If at_end is False, returns the state before the migration has run.</font>
<font color="black"> 263.         If nodes is not provided, returns the overall most current project state.</font>
<font color="black"> 264.         &quot;&quot;&quot;</font>
<font color="red"> 265.         if nodes is None:</font>
<font color="red"> 266.             nodes = list(self.leaf_nodes())</font>
<font color="red"> 267.         if len(nodes) == 0:</font>
<font color="red"> 268.             return ProjectState()</font>
<font color="red"> 269.         if not isinstance(nodes[0], tuple):</font>
<font color="red"> 270.             nodes = [nodes]</font>
<font color="red"> 271.         plan = []</font>
<font color="red"> 272.         for node in nodes:</font>
<font color="red"> 273.             for migration in self.forwards_plan(node):</font>
<font color="red"> 274.                 if migration not in plan:</font>
<font color="red"> 275.                     if not at_end and migration in nodes:</font>
<font color="red"> 276.                         continue</font>
<font color="red"> 277.                     plan.append(migration)</font>
<font color="red"> 278.         project_state = ProjectState(real_apps=real_apps)</font>
<font color="red"> 279.         for node in plan:</font>
<font color="red"> 280.             project_state = self.nodes[node].mutate_state(project_state, preserve=False)</font>
<font color="red"> 281.         return project_state</font>
<font color="black"> 282. </font>
<font color="green"> 283.     def __contains__(self, node):</font>
<font color="green"> 284.         return node in self.nodes</font>
</pre>

