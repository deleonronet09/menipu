source file: <b>/usr/lib/python2.7/difflib.py</b><br>


file stats: <b>696 lines, 74 executed: 10.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Module difflib -- helpers for computing deltas between objects.</font>
<font color="black">   3. </font>
<font color="black">   4. Function get_close_matches(word, possibilities, n=3, cutoff=0.6):</font>
<font color="black">   5.     Use SequenceMatcher to return list of the best &quot;good enough&quot; matches.</font>
<font color="black">   6. </font>
<font color="black">   7. Function context_diff(a, b):</font>
<font color="black">   8.     For two lists of strings, return a delta in context diff format.</font>
<font color="black">   9. </font>
<font color="black">  10. Function ndiff(a, b):</font>
<font color="black">  11.     Return a delta: the difference between `a` and `b` (lists of strings).</font>
<font color="black">  12. </font>
<font color="black">  13. Function restore(delta, which):</font>
<font color="black">  14.     Return one of the two sequences that generated an ndiff delta.</font>
<font color="black">  15. </font>
<font color="black">  16. Function unified_diff(a, b):</font>
<font color="black">  17.     For two lists of strings, return a delta in unified diff format.</font>
<font color="black">  18. </font>
<font color="black">  19. Class SequenceMatcher:</font>
<font color="black">  20.     A flexible class for comparing pairs of sequences of any type.</font>
<font color="black">  21. </font>
<font color="black">  22. Class Differ:</font>
<font color="black">  23.     For producing human-readable deltas from sequences of lines of text.</font>
<font color="black">  24. </font>
<font color="black">  25. Class HtmlDiff:</font>
<font color="black">  26.     For producing HTML side by side comparison with change highlights.</font>
<font color="green">  27. &quot;&quot;&quot;</font>
<font color="black">  28. </font>
<font color="green">  29. __all__ = ['get_close_matches', 'ndiff', 'restore', 'SequenceMatcher',</font>
<font color="green">  30.            'Differ','IS_CHARACTER_JUNK', 'IS_LINE_JUNK', 'context_diff',</font>
<font color="green">  31.            'unified_diff', 'HtmlDiff', 'Match']</font>
<font color="black">  32. </font>
<font color="green">  33. import heapq</font>
<font color="green">  34. from collections import namedtuple as _namedtuple</font>
<font color="green">  35. from functools import reduce</font>
<font color="black">  36. </font>
<font color="green">  37. Match = _namedtuple('Match', 'a b size')</font>
<font color="black">  38. </font>
<font color="green">  39. def _calculate_ratio(matches, length):</font>
<font color="red">  40.     if length:</font>
<font color="red">  41.         return 2.0 * matches / length</font>
<font color="red">  42.     return 1.0</font>
<font color="black">  43. </font>
<font color="green">  44. class SequenceMatcher:</font>
<font color="black">  45. </font>
<font color="black">  46.     &quot;&quot;&quot;</font>
<font color="black">  47.     SequenceMatcher is a flexible class for comparing pairs of sequences of</font>
<font color="black">  48.     any type, so long as the sequence elements are hashable.  The basic</font>
<font color="black">  49.     algorithm predates, and is a little fancier than, an algorithm</font>
<font color="black">  50.     published in the late 1980's by Ratcliff and Obershelp under the</font>
<font color="black">  51.     hyperbolic name &quot;gestalt pattern matching&quot;.  The basic idea is to find</font>
<font color="black">  52.     the longest contiguous matching subsequence that contains no &quot;junk&quot;</font>
<font color="black">  53.     elements (R-O doesn't address junk).  The same idea is then applied</font>
<font color="black">  54.     recursively to the pieces of the sequences to the left and to the right</font>
<font color="black">  55.     of the matching subsequence.  This does not yield minimal edit</font>
<font color="black">  56.     sequences, but does tend to yield matches that &quot;look right&quot; to people.</font>
<font color="black">  57. </font>
<font color="black">  58.     SequenceMatcher tries to compute a &quot;human-friendly diff&quot; between two</font>
<font color="black">  59.     sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the</font>
<font color="black">  60.     longest *contiguous* &amp; junk-free matching subsequence.  That's what</font>
<font color="black">  61.     catches peoples' eyes.  The Windows(tm) windiff has another interesting</font>
<font color="black">  62.     notion, pairing up elements that appear uniquely in each sequence.</font>
<font color="black">  63.     That, and the method here, appear to yield more intuitive difference</font>
<font color="black">  64.     reports than does diff.  This method appears to be the least vulnerable</font>
<font color="black">  65.     to synching up on blocks of &quot;junk lines&quot;, though (like blank lines in</font>
<font color="black">  66.     ordinary text files, or maybe &quot;&lt;P&gt;&quot; lines in HTML files).  That may be</font>
<font color="black">  67.     because this is the only method of the 3 that has a *concept* of</font>
<font color="black">  68.     &quot;junk&quot; &lt;wink&gt;.</font>
<font color="black">  69. </font>
<font color="black">  70.     Example, comparing two strings, and considering blanks to be &quot;junk&quot;:</font>
<font color="black">  71. </font>
<font color="black">  72.     &gt;&gt;&gt; s = SequenceMatcher(lambda x: x == &quot; &quot;,</font>
<font color="black">  73.     ...                     &quot;private Thread currentThread;&quot;,</font>
<font color="black">  74.     ...                     &quot;private volatile Thread currentThread;&quot;)</font>
<font color="black">  75.     &gt;&gt;&gt;</font>
<font color="black">  76. </font>
<font color="black">  77.     .ratio() returns a float in [0, 1], measuring the &quot;similarity&quot; of the</font>
<font color="black">  78.     sequences.  As a rule of thumb, a .ratio() value over 0.6 means the</font>
<font color="black">  79.     sequences are close matches:</font>
<font color="black">  80. </font>
<font color="black">  81.     &gt;&gt;&gt; print round(s.ratio(), 3)</font>
<font color="black">  82.     0.866</font>
<font color="black">  83.     &gt;&gt;&gt;</font>
<font color="black">  84. </font>
<font color="black">  85.     If you're only interested in where the sequences match,</font>
<font color="black">  86.     .get_matching_blocks() is handy:</font>
<font color="black">  87. </font>
<font color="black">  88.     &gt;&gt;&gt; for block in s.get_matching_blocks():</font>
<font color="black">  89.     ...     print &quot;a[%d] and b[%d] match for %d elements&quot; % block</font>
<font color="black">  90.     a[0] and b[0] match for 8 elements</font>
<font color="black">  91.     a[8] and b[17] match for 21 elements</font>
<font color="black">  92.     a[29] and b[38] match for 0 elements</font>
<font color="black">  93. </font>
<font color="black">  94.     Note that the last tuple returned by .get_matching_blocks() is always a</font>
<font color="black">  95.     dummy, (len(a), len(b), 0), and this is the only case in which the last</font>
<font color="black">  96.     tuple element (number of elements matched) is 0.</font>
<font color="black">  97. </font>
<font color="black">  98.     If you want to know how to change the first sequence into the second,</font>
<font color="black">  99.     use .get_opcodes():</font>
<font color="black"> 100. </font>
<font color="black"> 101.     &gt;&gt;&gt; for opcode in s.get_opcodes():</font>
<font color="black"> 102.     ...     print &quot;%6s a[%d:%d] b[%d:%d]&quot; % opcode</font>
<font color="black"> 103.      equal a[0:8] b[0:8]</font>
<font color="black"> 104.     insert a[8:8] b[8:17]</font>
<font color="black"> 105.      equal a[8:29] b[17:38]</font>
<font color="black"> 106. </font>
<font color="black"> 107.     See the Differ class for a fancy human-friendly file differencer, which</font>
<font color="black"> 108.     uses SequenceMatcher both to compare sequences of lines, and to compare</font>
<font color="black"> 109.     sequences of characters within similar (near-matching) lines.</font>
<font color="black"> 110. </font>
<font color="black"> 111.     See also function get_close_matches() in this module, which shows how</font>
<font color="black"> 112.     simple code building on SequenceMatcher can be used to do useful work.</font>
<font color="black"> 113. </font>
<font color="black"> 114.     Timing:  Basic R-O is cubic time worst case and quadratic time expected</font>
<font color="black"> 115.     case.  SequenceMatcher is quadratic time for the worst case and has</font>
<font color="black"> 116.     expected-case behavior dependent in a complicated way on how many</font>
<font color="black"> 117.     elements the sequences have in common; best case time is linear.</font>
<font color="black"> 118. </font>
<font color="black"> 119.     Methods:</font>
<font color="black"> 120. </font>
<font color="black"> 121.     __init__(isjunk=None, a='', b='')</font>
<font color="black"> 122.         Construct a SequenceMatcher.</font>
<font color="black"> 123. </font>
<font color="black"> 124.     set_seqs(a, b)</font>
<font color="black"> 125.         Set the two sequences to be compared.</font>
<font color="black"> 126. </font>
<font color="black"> 127.     set_seq1(a)</font>
<font color="black"> 128.         Set the first sequence to be compared.</font>
<font color="black"> 129. </font>
<font color="black"> 130.     set_seq2(b)</font>
<font color="black"> 131.         Set the second sequence to be compared.</font>
<font color="black"> 132. </font>
<font color="black"> 133.     find_longest_match(alo, ahi, blo, bhi)</font>
<font color="black"> 134.         Find longest matching block in a[alo:ahi] and b[blo:bhi].</font>
<font color="black"> 135. </font>
<font color="black"> 136.     get_matching_blocks()</font>
<font color="black"> 137.         Return list of triples describing matching subsequences.</font>
<font color="black"> 138. </font>
<font color="black"> 139.     get_opcodes()</font>
<font color="black"> 140.         Return list of 5-tuples describing how to turn a into b.</font>
<font color="black"> 141. </font>
<font color="black"> 142.     ratio()</font>
<font color="black"> 143.         Return a measure of the sequences' similarity (float in [0,1]).</font>
<font color="black"> 144. </font>
<font color="black"> 145.     quick_ratio()</font>
<font color="black"> 146.         Return an upper bound on .ratio() relatively quickly.</font>
<font color="black"> 147. </font>
<font color="black"> 148.     real_quick_ratio()</font>
<font color="black"> 149.         Return an upper bound on ratio() very quickly.</font>
<font color="green"> 150.     &quot;&quot;&quot;</font>
<font color="black"> 151. </font>
<font color="green"> 152.     def __init__(self, isjunk=None, a='', b='', autojunk=True):</font>
<font color="black"> 153.         &quot;&quot;&quot;Construct a SequenceMatcher.</font>
<font color="black"> 154. </font>
<font color="black"> 155.         Optional arg isjunk is None (the default), or a one-argument</font>
<font color="black"> 156.         function that takes a sequence element and returns true iff the</font>
<font color="black"> 157.         element is junk.  None is equivalent to passing &quot;lambda x: 0&quot;, i.e.</font>
<font color="black"> 158.         no elements are considered to be junk.  For example, pass</font>
<font color="black"> 159.             lambda x: x in &quot; \\t&quot;</font>
<font color="black"> 160.         if you're comparing lines as sequences of characters, and don't</font>
<font color="black"> 161.         want to synch up on blanks or hard tabs.</font>
<font color="black"> 162. </font>
<font color="black"> 163.         Optional arg a is the first of two sequences to be compared.  By</font>
<font color="black"> 164.         default, an empty string.  The elements of a must be hashable.  See</font>
<font color="black"> 165.         also .set_seqs() and .set_seq1().</font>
<font color="black"> 166. </font>
<font color="black"> 167.         Optional arg b is the second of two sequences to be compared.  By</font>
<font color="black"> 168.         default, an empty string.  The elements of b must be hashable. See</font>
<font color="black"> 169.         also .set_seqs() and .set_seq2().</font>
<font color="black"> 170. </font>
<font color="black"> 171.         Optional arg autojunk should be set to False to disable the</font>
<font color="black"> 172.         &quot;automatic junk heuristic&quot; that treats popular elements as junk</font>
<font color="black"> 173.         (see module documentation for more information).</font>
<font color="black"> 174.         &quot;&quot;&quot;</font>
<font color="black"> 175. </font>
<font color="black"> 176.         # Members:</font>
<font color="black"> 177.         # a</font>
<font color="black"> 178.         #      first sequence</font>
<font color="black"> 179.         # b</font>
<font color="black"> 180.         #      second sequence; differences are computed as &quot;what do</font>
<font color="black"> 181.         #      we need to do to 'a' to change it into 'b'?&quot;</font>
<font color="black"> 182.         # b2j</font>
<font color="black"> 183.         #      for x in b, b2j[x] is a list of the indices (into b)</font>
<font color="black"> 184.         #      at which x appears; junk elements do not appear</font>
<font color="black"> 185.         # fullbcount</font>
<font color="black"> 186.         #      for x in b, fullbcount[x] == the number of times x</font>
<font color="black"> 187.         #      appears in b; only materialized if really needed (used</font>
<font color="black"> 188.         #      only for computing quick_ratio())</font>
<font color="black"> 189.         # matching_blocks</font>
<font color="black"> 190.         #      a list of (i, j, k) triples, where a[i:i+k] == b[j:j+k];</font>
<font color="black"> 191.         #      ascending &amp; non-overlapping in i and in j; terminated by</font>
<font color="black"> 192.         #      a dummy (len(a), len(b), 0) sentinel</font>
<font color="black"> 193.         # opcodes</font>
<font color="black"> 194.         #      a list of (tag, i1, i2, j1, j2) tuples, where tag is</font>
<font color="black"> 195.         #      one of</font>
<font color="black"> 196.         #          'replace'   a[i1:i2] should be replaced by b[j1:j2]</font>
<font color="black"> 197.         #          'delete'    a[i1:i2] should be deleted</font>
<font color="black"> 198.         #          'insert'    b[j1:j2] should be inserted</font>
<font color="black"> 199.         #          'equal'     a[i1:i2] == b[j1:j2]</font>
<font color="black"> 200.         # isjunk</font>
<font color="black"> 201.         #      a user-supplied function taking a sequence element and</font>
<font color="black"> 202.         #      returning true iff the element is &quot;junk&quot; -- this has</font>
<font color="black"> 203.         #      subtle but helpful effects on the algorithm, which I'll</font>
<font color="black"> 204.         #      get around to writing up someday &lt;0.9 wink&gt;.</font>
<font color="black"> 205.         #      DON'T USE!  Only __chain_b uses this.  Use isbjunk.</font>
<font color="black"> 206.         # isbjunk</font>
<font color="black"> 207.         #      for x in b, isbjunk(x) == isjunk(x) but much faster;</font>
<font color="black"> 208.         #      it's really the __contains__ method of a hidden dict.</font>
<font color="black"> 209.         #      DOES NOT WORK for x in a!</font>
<font color="black"> 210.         # isbpopular</font>
<font color="black"> 211.         #      for x in b, isbpopular(x) is true iff b is reasonably long</font>
<font color="black"> 212.         #      (at least 200 elements) and x accounts for more than 1 + 1% of</font>
<font color="black"> 213.         #      its elements (when autojunk is enabled).</font>
<font color="black"> 214.         #      DOES NOT WORK for x in a!</font>
<font color="black"> 215. </font>
<font color="red"> 216.         self.isjunk = isjunk</font>
<font color="red"> 217.         self.a = self.b = None</font>
<font color="red"> 218.         self.autojunk = autojunk</font>
<font color="red"> 219.         self.set_seqs(a, b)</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def set_seqs(self, a, b):</font>
<font color="black"> 222.         &quot;&quot;&quot;Set the two sequences to be compared.</font>
<font color="black"> 223. </font>
<font color="black"> 224.         &gt;&gt;&gt; s = SequenceMatcher()</font>
<font color="black"> 225.         &gt;&gt;&gt; s.set_seqs(&quot;abcd&quot;, &quot;bcde&quot;)</font>
<font color="black"> 226.         &gt;&gt;&gt; s.ratio()</font>
<font color="black"> 227.         0.75</font>
<font color="black"> 228.         &quot;&quot;&quot;</font>
<font color="black"> 229. </font>
<font color="red"> 230.         self.set_seq1(a)</font>
<font color="red"> 231.         self.set_seq2(b)</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def set_seq1(self, a):</font>
<font color="black"> 234.         &quot;&quot;&quot;Set the first sequence to be compared.</font>
<font color="black"> 235. </font>
<font color="black"> 236.         The second sequence to be compared is not changed.</font>
<font color="black"> 237. </font>
<font color="black"> 238.         &gt;&gt;&gt; s = SequenceMatcher(None, &quot;abcd&quot;, &quot;bcde&quot;)</font>
<font color="black"> 239.         &gt;&gt;&gt; s.ratio()</font>
<font color="black"> 240.         0.75</font>
<font color="black"> 241.         &gt;&gt;&gt; s.set_seq1(&quot;bcde&quot;)</font>
<font color="black"> 242.         &gt;&gt;&gt; s.ratio()</font>
<font color="black"> 243.         1.0</font>
<font color="black"> 244.         &gt;&gt;&gt;</font>
<font color="black"> 245. </font>
<font color="black"> 246.         SequenceMatcher computes and caches detailed information about the</font>
<font color="black"> 247.         second sequence, so if you want to compare one sequence S against</font>
<font color="black"> 248.         many sequences, use .set_seq2(S) once and call .set_seq1(x)</font>
<font color="black"> 249.         repeatedly for each of the other sequences.</font>
<font color="black"> 250. </font>
<font color="black"> 251.         See also set_seqs() and set_seq2().</font>
<font color="black"> 252.         &quot;&quot;&quot;</font>
<font color="black"> 253. </font>
<font color="red"> 254.         if a is self.a:</font>
<font color="red"> 255.             return</font>
<font color="red"> 256.         self.a = a</font>
<font color="red"> 257.         self.matching_blocks = self.opcodes = None</font>
<font color="black"> 258. </font>
<font color="green"> 259.     def set_seq2(self, b):</font>
<font color="black"> 260.         &quot;&quot;&quot;Set the second sequence to be compared.</font>
<font color="black"> 261. </font>
<font color="black"> 262.         The first sequence to be compared is not changed.</font>
<font color="black"> 263. </font>
<font color="black"> 264.         &gt;&gt;&gt; s = SequenceMatcher(None, &quot;abcd&quot;, &quot;bcde&quot;)</font>
<font color="black"> 265.         &gt;&gt;&gt; s.ratio()</font>
<font color="black"> 266.         0.75</font>
<font color="black"> 267.         &gt;&gt;&gt; s.set_seq2(&quot;abcd&quot;)</font>
<font color="black"> 268.         &gt;&gt;&gt; s.ratio()</font>
<font color="black"> 269.         1.0</font>
<font color="black"> 270.         &gt;&gt;&gt;</font>
<font color="black"> 271. </font>
<font color="black"> 272.         SequenceMatcher computes and caches detailed information about the</font>
<font color="black"> 273.         second sequence, so if you want to compare one sequence S against</font>
<font color="black"> 274.         many sequences, use .set_seq2(S) once and call .set_seq1(x)</font>
<font color="black"> 275.         repeatedly for each of the other sequences.</font>
<font color="black"> 276. </font>
<font color="black"> 277.         See also set_seqs() and set_seq1().</font>
<font color="black"> 278.         &quot;&quot;&quot;</font>
<font color="black"> 279. </font>
<font color="red"> 280.         if b is self.b:</font>
<font color="red"> 281.             return</font>
<font color="red"> 282.         self.b = b</font>
<font color="red"> 283.         self.matching_blocks = self.opcodes = None</font>
<font color="red"> 284.         self.fullbcount = None</font>
<font color="red"> 285.         self.__chain_b()</font>
<font color="black"> 286. </font>
<font color="black"> 287.     # For each element x in b, set b2j[x] to a list of the indices in</font>
<font color="black"> 288.     # b where x appears; the indices are in increasing order; note that</font>
<font color="black"> 289.     # the number of times x appears in b is len(b2j[x]) ...</font>
<font color="black"> 290.     # when self.isjunk is defined, junk elements don't show up in this</font>
<font color="black"> 291.     # map at all, which stops the central find_longest_match method</font>
<font color="black"> 292.     # from starting any matching block at a junk element ...</font>
<font color="black"> 293.     # also creates the fast isbjunk function ...</font>
<font color="black"> 294.     # b2j also does not contain entries for &quot;popular&quot; elements, meaning</font>
<font color="black"> 295.     # elements that account for more than 1 + 1% of the total elements, and</font>
<font color="black"> 296.     # when the sequence is reasonably large (&gt;= 200 elements); this can</font>
<font color="black"> 297.     # be viewed as an adaptive notion of semi-junk, and yields an enormous</font>
<font color="black"> 298.     # speedup when, e.g., comparing program files with hundreds of</font>
<font color="black"> 299.     # instances of &quot;return NULL;&quot; ...</font>
<font color="black"> 300.     # note that this is only called when b changes; so for cross-product</font>
<font color="black"> 301.     # kinds of matches, it's best to call set_seq2 once, then set_seq1</font>
<font color="black"> 302.     # repeatedly</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def __chain_b(self):</font>
<font color="black"> 305.         # Because isjunk is a user-defined (not C) function, and we test</font>
<font color="black"> 306.         # for junk a LOT, it's important to minimize the number of calls.</font>
<font color="black"> 307.         # Before the tricks described here, __chain_b was by far the most</font>
<font color="black"> 308.         # time-consuming routine in the whole module!  If anyone sees</font>
<font color="black"> 309.         # Jim Roskind, thank him again for profile.py -- I never would</font>
<font color="black"> 310.         # have guessed that.</font>
<font color="black"> 311.         # The first trick is to build b2j ignoring the possibility</font>
<font color="black"> 312.         # of junk.  I.e., we don't call isjunk at all yet.  Throwing</font>
<font color="black"> 313.         # out the junk later is much cheaper than building b2j &quot;right&quot;</font>
<font color="black"> 314.         # from the start.</font>
<font color="red"> 315.         b = self.b</font>
<font color="red"> 316.         self.b2j = b2j = {}</font>
<font color="black"> 317. </font>
<font color="red"> 318.         for i, elt in enumerate(b):</font>
<font color="red"> 319.             indices = b2j.setdefault(elt, [])</font>
<font color="red"> 320.             indices.append(i)</font>
<font color="black"> 321. </font>
<font color="black"> 322.         # Purge junk elements</font>
<font color="red"> 323.         junk = set()</font>
<font color="red"> 324.         isjunk = self.isjunk</font>
<font color="red"> 325.         if isjunk:</font>
<font color="red"> 326.             for elt in list(b2j.keys()):  # using list() since b2j is modified</font>
<font color="red"> 327.                 if isjunk(elt):</font>
<font color="red"> 328.                     junk.add(elt)</font>
<font color="red"> 329.                     del b2j[elt]</font>
<font color="black"> 330. </font>
<font color="black"> 331.         # Purge popular elements that are not junk</font>
<font color="red"> 332.         popular = set()</font>
<font color="red"> 333.         n = len(b)</font>
<font color="red"> 334.         if self.autojunk and n &gt;= 200:</font>
<font color="red"> 335.             ntest = n // 100 + 1</font>
<font color="red"> 336.             for elt, idxs in list(b2j.items()):</font>
<font color="red"> 337.                 if len(idxs) &gt; ntest:</font>
<font color="red"> 338.                     popular.add(elt)</font>
<font color="red"> 339.                     del b2j[elt]</font>
<font color="black"> 340. </font>
<font color="black"> 341.         # Now for x in b, isjunk(x) == x in junk, but the latter is much faster.</font>
<font color="black"> 342.         # Sicne the number of *unique* junk elements is probably small, the</font>
<font color="black"> 343.         # memory burden of keeping this set alive is likely trivial compared to</font>
<font color="black"> 344.         # the size of b2j.</font>
<font color="red"> 345.         self.isbjunk = junk.__contains__</font>
<font color="red"> 346.         self.isbpopular = popular.__contains__</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def find_longest_match(self, alo, ahi, blo, bhi):</font>
<font color="black"> 349.         &quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</font>
<font color="black"> 350. </font>
<font color="black"> 351.         If isjunk is not defined:</font>
<font color="black"> 352. </font>
<font color="black"> 353.         Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</font>
<font color="black"> 354.             alo &lt;= i &lt;= i+k &lt;= ahi</font>
<font color="black"> 355.             blo &lt;= j &lt;= j+k &lt;= bhi</font>
<font color="black"> 356.         and for all (i',j',k') meeting those conditions,</font>
<font color="black"> 357.             k &gt;= k'</font>
<font color="black"> 358.             i &lt;= i'</font>
<font color="black"> 359.             and if i == i', j &lt;= j'</font>
<font color="black"> 360. </font>
<font color="black"> 361.         In other words, of all maximal matching blocks, return one that</font>
<font color="black"> 362.         starts earliest in a, and of all those maximal matching blocks that</font>
<font color="black"> 363.         start earliest in a, return the one that starts earliest in b.</font>
<font color="black"> 364. </font>
<font color="black"> 365.         &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</font>
<font color="black"> 366.         &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</font>
<font color="black"> 367.         Match(a=0, b=4, size=5)</font>
<font color="black"> 368. </font>
<font color="black"> 369.         If isjunk is defined, first the longest matching block is</font>
<font color="black"> 370.         determined as above, but with the additional restriction that no</font>
<font color="black"> 371.         junk element appears in the block.  Then that block is extended as</font>
<font color="black"> 372.         far as possible by matching (only) junk elements on both sides.  So</font>
<font color="black"> 373.         the resulting block never matches on junk except as identical junk</font>
<font color="black"> 374.         happens to be adjacent to an &quot;interesting&quot; match.</font>
<font color="black"> 375. </font>
<font color="black"> 376.         Here's the same example as before, but considering blanks to be</font>
<font color="black"> 377.         junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</font>
<font color="black"> 378.         end of the second sequence directly.  Instead only the &quot;abcd&quot; can</font>
<font color="black"> 379.         match, and matches the leftmost &quot;abcd&quot; in the second sequence:</font>
<font color="black"> 380. </font>
<font color="black"> 381.         &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</font>
<font color="black"> 382.         &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</font>
<font color="black"> 383.         Match(a=1, b=0, size=4)</font>
<font color="black"> 384. </font>
<font color="black"> 385.         If no blocks match, return (alo, blo, 0).</font>
<font color="black"> 386. </font>
<font color="black"> 387.         &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</font>
<font color="black"> 388.         &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</font>
<font color="black"> 389.         Match(a=0, b=0, size=0)</font>
<font color="black"> 390.         &quot;&quot;&quot;</font>
<font color="black"> 391. </font>
<font color="black"> 392.         # CAUTION:  stripping common prefix or suffix would be incorrect.</font>
<font color="black"> 393.         # E.g.,</font>
<font color="black"> 394.         #    ab</font>
<font color="black"> 395.         #    acab</font>
<font color="black"> 396.         # Longest matching block is &quot;ab&quot;, but if common prefix is</font>
<font color="black"> 397.         # stripped, it's &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</font>
<font color="black"> 398.         # strip, so ends up claiming that ab is changed to acab by</font>
<font color="black"> 399.         # inserting &quot;ca&quot; in the middle.  That's minimal but unintuitive:</font>
<font color="black"> 400.         # &quot;it's obvious&quot; that someone inserted &quot;ac&quot; at the front.</font>
<font color="black"> 401.         # Windiff ends up at the same place as diff, but by pairing up</font>
<font color="black"> 402.         # the unique 'b's and then matching the first two 'a's.</font>
<font color="black"> 403. </font>
<font color="red"> 404.         a, b, b2j, isbjunk = self.a, self.b, self.b2j, self.isbjunk</font>
<font color="red"> 405.         besti, bestj, bestsize = alo, blo, 0</font>
<font color="black"> 406.         # find longest junk-free match</font>
<font color="black"> 407.         # during an iteration of the loop, j2len[j] = length of longest</font>
<font color="black"> 408.         # junk-free match ending with a[i-1] and b[j]</font>
<font color="red"> 409.         j2len = {}</font>
<font color="red"> 410.         nothing = []</font>
<font color="red"> 411.         for i in xrange(alo, ahi):</font>
<font color="black"> 412.             # look at all instances of a[i] in b; note that because</font>
<font color="black"> 413.             # b2j has no junk keys, the loop is skipped if a[i] is junk</font>
<font color="red"> 414.             j2lenget = j2len.get</font>
<font color="red"> 415.             newj2len = {}</font>
<font color="red"> 416.             for j in b2j.get(a[i], nothing):</font>
<font color="black"> 417.                 # a[i] matches b[j]</font>
<font color="red"> 418.                 if j &lt; blo:</font>
<font color="red"> 419.                     continue</font>
<font color="red"> 420.                 if j &gt;= bhi:</font>
<font color="red"> 421.                     break</font>
<font color="red"> 422.                 k = newj2len[j] = j2lenget(j-1, 0) + 1</font>
<font color="red"> 423.                 if k &gt; bestsize:</font>
<font color="red"> 424.                     besti, bestj, bestsize = i-k+1, j-k+1, k</font>
<font color="red"> 425.             j2len = newj2len</font>
<font color="black"> 426. </font>
<font color="black"> 427.         # Extend the best by non-junk elements on each end.  In particular,</font>
<font color="black"> 428.         # &quot;popular&quot; non-junk elements aren't in b2j, which greatly speeds</font>
<font color="black"> 429.         # the inner loop above, but also means &quot;the best&quot; match so far</font>
<font color="black"> 430.         # doesn't contain any junk *or* popular non-junk elements.</font>
<font color="red"> 431.         while besti &gt; alo and bestj &gt; blo and \</font>
<font color="red"> 432.               not isbjunk(b[bestj-1]) and \</font>
<font color="red"> 433.               a[besti-1] == b[bestj-1]:</font>
<font color="red"> 434.             besti, bestj, bestsize = besti-1, bestj-1, bestsize+1</font>
<font color="red"> 435.         while besti+bestsize &lt; ahi and bestj+bestsize &lt; bhi and \</font>
<font color="red"> 436.               not isbjunk(b[bestj+bestsize]) and \</font>
<font color="red"> 437.               a[besti+bestsize] == b[bestj+bestsize]:</font>
<font color="red"> 438.             bestsize += 1</font>
<font color="black"> 439. </font>
<font color="black"> 440.         # Now that we have a wholly interesting match (albeit possibly</font>
<font color="black"> 441.         # empty!), we may as well suck up the matching junk on each</font>
<font color="black"> 442.         # side of it too.  Can't think of a good reason not to, and it</font>
<font color="black"> 443.         # saves post-processing the (possibly considerable) expense of</font>
<font color="black"> 444.         # figuring out what to do with it.  In the case of an empty</font>
<font color="black"> 445.         # interesting match, this is clearly the right thing to do,</font>
<font color="black"> 446.         # because no other kind of match is possible in the regions.</font>
<font color="red"> 447.         while besti &gt; alo and bestj &gt; blo and \</font>
<font color="red"> 448.               isbjunk(b[bestj-1]) and \</font>
<font color="red"> 449.               a[besti-1] == b[bestj-1]:</font>
<font color="red"> 450.             besti, bestj, bestsize = besti-1, bestj-1, bestsize+1</font>
<font color="red"> 451.         while besti+bestsize &lt; ahi and bestj+bestsize &lt; bhi and \</font>
<font color="red"> 452.               isbjunk(b[bestj+bestsize]) and \</font>
<font color="red"> 453.               a[besti+bestsize] == b[bestj+bestsize]:</font>
<font color="red"> 454.             bestsize = bestsize + 1</font>
<font color="black"> 455. </font>
<font color="red"> 456.         return Match(besti, bestj, bestsize)</font>
<font color="black"> 457. </font>
<font color="green"> 458.     def get_matching_blocks(self):</font>
<font color="black"> 459.         &quot;&quot;&quot;Return list of triples describing matching subsequences.</font>
<font color="black"> 460. </font>
<font color="black"> 461.         Each triple is of the form (i, j, n), and means that</font>
<font color="black"> 462.         a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in</font>
<font color="black"> 463.         i and in j.  New in Python 2.5, it's also guaranteed that if</font>
<font color="black"> 464.         (i, j, n) and (i', j', n') are adjacent triples in the list, and</font>
<font color="black"> 465.         the second is not the last triple in the list, then i+n != i' or</font>
<font color="black"> 466.         j+n != j'.  IOW, adjacent triples never describe adjacent equal</font>
<font color="black"> 467.         blocks.</font>
<font color="black"> 468. </font>
<font color="black"> 469.         The last triple is a dummy, (len(a), len(b), 0), and is the only</font>
<font color="black"> 470.         triple with n==0.</font>
<font color="black"> 471. </font>
<font color="black"> 472.         &gt;&gt;&gt; s = SequenceMatcher(None, &quot;abxcd&quot;, &quot;abcd&quot;)</font>
<font color="black"> 473.         &gt;&gt;&gt; s.get_matching_blocks()</font>
<font color="black"> 474.         [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]</font>
<font color="black"> 475.         &quot;&quot;&quot;</font>
<font color="black"> 476. </font>
<font color="red"> 477.         if self.matching_blocks is not None:</font>
<font color="red"> 478.             return self.matching_blocks</font>
<font color="red"> 479.         la, lb = len(self.a), len(self.b)</font>
<font color="black"> 480. </font>
<font color="black"> 481.         # This is most naturally expressed as a recursive algorithm, but</font>
<font color="black"> 482.         # at least one user bumped into extreme use cases that exceeded</font>
<font color="black"> 483.         # the recursion limit on their box.  So, now we maintain a list</font>
<font color="black"> 484.         # ('queue`) of blocks we still need to look at, and append partial</font>
<font color="black"> 485.         # results to `matching_blocks` in a loop; the matches are sorted</font>
<font color="black"> 486.         # at the end.</font>
<font color="red"> 487.         queue = [(0, la, 0, lb)]</font>
<font color="red"> 488.         matching_blocks = []</font>
<font color="red"> 489.         while queue:</font>
<font color="red"> 490.             alo, ahi, blo, bhi = queue.pop()</font>
<font color="red"> 491.             i, j, k = x = self.find_longest_match(alo, ahi, blo, bhi)</font>
<font color="black"> 492.             # a[alo:i] vs b[blo:j] unknown</font>
<font color="black"> 493.             # a[i:i+k] same as b[j:j+k]</font>
<font color="black"> 494.             # a[i+k:ahi] vs b[j+k:bhi] unknown</font>
<font color="red"> 495.             if k:   # if k is 0, there was no matching block</font>
<font color="red"> 496.                 matching_blocks.append(x)</font>
<font color="red"> 497.                 if alo &lt; i and blo &lt; j:</font>
<font color="red"> 498.                     queue.append((alo, i, blo, j))</font>
<font color="red"> 499.                 if i+k &lt; ahi and j+k &lt; bhi:</font>
<font color="red"> 500.                     queue.append((i+k, ahi, j+k, bhi))</font>
<font color="red"> 501.         matching_blocks.sort()</font>
<font color="black"> 502. </font>
<font color="black"> 503.         # It's possible that we have adjacent equal blocks in the</font>
<font color="black"> 504.         # matching_blocks list now.  Starting with 2.5, this code was added</font>
<font color="black"> 505.         # to collapse them.</font>
<font color="red"> 506.         i1 = j1 = k1 = 0</font>
<font color="red"> 507.         non_adjacent = []</font>
<font color="red"> 508.         for i2, j2, k2 in matching_blocks:</font>
<font color="black"> 509.             # Is this block adjacent to i1, j1, k1?</font>
<font color="red"> 510.             if i1 + k1 == i2 and j1 + k1 == j2:</font>
<font color="black"> 511.                 # Yes, so collapse them -- this just increases the length of</font>
<font color="black"> 512.                 # the first block by the length of the second, and the first</font>
<font color="black"> 513.                 # block so lengthened remains the block to compare against.</font>
<font color="red"> 514.                 k1 += k2</font>
<font color="black"> 515.             else:</font>
<font color="black"> 516.                 # Not adjacent.  Remember the first block (k1==0 means it's</font>
<font color="black"> 517.                 # the dummy we started with), and make the second block the</font>
<font color="black"> 518.                 # new block to compare against.</font>
<font color="red"> 519.                 if k1:</font>
<font color="red"> 520.                     non_adjacent.append((i1, j1, k1))</font>
<font color="red"> 521.                 i1, j1, k1 = i2, j2, k2</font>
<font color="red"> 522.         if k1:</font>
<font color="red"> 523.             non_adjacent.append((i1, j1, k1))</font>
<font color="black"> 524. </font>
<font color="red"> 525.         non_adjacent.append( (la, lb, 0) )</font>
<font color="red"> 526.         self.matching_blocks = non_adjacent</font>
<font color="red"> 527.         return map(Match._make, self.matching_blocks)</font>
<font color="black"> 528. </font>
<font color="green"> 529.     def get_opcodes(self):</font>
<font color="black"> 530.         &quot;&quot;&quot;Return list of 5-tuples describing how to turn a into b.</font>
<font color="black"> 531. </font>
<font color="black"> 532.         Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple</font>
<font color="black"> 533.         has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the</font>
<font color="black"> 534.         tuple preceding it, and likewise for j1 == the previous j2.</font>
<font color="black"> 535. </font>
<font color="black"> 536.         The tags are strings, with these meanings:</font>
<font color="black"> 537. </font>
<font color="black"> 538.         'replace':  a[i1:i2] should be replaced by b[j1:j2]</font>
<font color="black"> 539.         'delete':   a[i1:i2] should be deleted.</font>
<font color="black"> 540.                     Note that j1==j2 in this case.</font>
<font color="black"> 541.         'insert':   b[j1:j2] should be inserted at a[i1:i1].</font>
<font color="black"> 542.                     Note that i1==i2 in this case.</font>
<font color="black"> 543.         'equal':    a[i1:i2] == b[j1:j2]</font>
<font color="black"> 544. </font>
<font color="black"> 545.         &gt;&gt;&gt; a = &quot;qabxcd&quot;</font>
<font color="black"> 546.         &gt;&gt;&gt; b = &quot;abycdf&quot;</font>
<font color="black"> 547.         &gt;&gt;&gt; s = SequenceMatcher(None, a, b)</font>
<font color="black"> 548.         &gt;&gt;&gt; for tag, i1, i2, j1, j2 in s.get_opcodes():</font>
<font color="black"> 549.         ...    print (&quot;%7s a[%d:%d] (%s) b[%d:%d] (%s)&quot; %</font>
<font color="black"> 550.         ...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2]))</font>
<font color="black"> 551.          delete a[0:1] (q) b[0:0] ()</font>
<font color="black"> 552.           equal a[1:3] (ab) b[0:2] (ab)</font>
<font color="black"> 553.         replace a[3:4] (x) b[2:3] (y)</font>
<font color="black"> 554.           equal a[4:6] (cd) b[3:5] (cd)</font>
<font color="black"> 555.          insert a[6:6] () b[5:6] (f)</font>
<font color="black"> 556.         &quot;&quot;&quot;</font>
<font color="black"> 557. </font>
<font color="red"> 558.         if self.opcodes is not None:</font>
<font color="red"> 559.             return self.opcodes</font>
<font color="red"> 560.         i = j = 0</font>
<font color="red"> 561.         self.opcodes = answer = []</font>
<font color="red"> 562.         for ai, bj, size in self.get_matching_blocks():</font>
<font color="black"> 563.             # invariant:  we've pumped out correct diffs to change</font>
<font color="black"> 564.             # a[:i] into b[:j], and the next matching block is</font>
<font color="black"> 565.             # a[ai:ai+size] == b[bj:bj+size].  So we need to pump</font>
<font color="black"> 566.             # out a diff to change a[i:ai] into b[j:bj], pump out</font>
<font color="black"> 567.             # the matching block, and move (i,j) beyond the match</font>
<font color="red"> 568.             tag = ''</font>
<font color="red"> 569.             if i &lt; ai and j &lt; bj:</font>
<font color="red"> 570.                 tag = 'replace'</font>
<font color="red"> 571.             elif i &lt; ai:</font>
<font color="red"> 572.                 tag = 'delete'</font>
<font color="red"> 573.             elif j &lt; bj:</font>
<font color="red"> 574.                 tag = 'insert'</font>
<font color="red"> 575.             if tag:</font>
<font color="red"> 576.                 answer.append( (tag, i, ai, j, bj) )</font>
<font color="red"> 577.             i, j = ai+size, bj+size</font>
<font color="black"> 578.             # the list of matching blocks is terminated by a</font>
<font color="black"> 579.             # sentinel with size 0</font>
<font color="red"> 580.             if size:</font>
<font color="red"> 581.                 answer.append( ('equal', ai, i, bj, j) )</font>
<font color="red"> 582.         return answer</font>
<font color="black"> 583. </font>
<font color="green"> 584.     def get_grouped_opcodes(self, n=3):</font>
<font color="black"> 585.         &quot;&quot;&quot; Isolate change clusters by eliminating ranges with no changes.</font>
<font color="black"> 586. </font>
<font color="black"> 587.         Return a generator of groups with up to n lines of context.</font>
<font color="black"> 588.         Each group is in the same format as returned by get_opcodes().</font>
<font color="black"> 589. </font>
<font color="black"> 590.         &gt;&gt;&gt; from pprint import pprint</font>
<font color="black"> 591.         &gt;&gt;&gt; a = map(str, range(1,40))</font>
<font color="black"> 592.         &gt;&gt;&gt; b = a[:]</font>
<font color="black"> 593.         &gt;&gt;&gt; b[8:8] = ['i']     # Make an insertion</font>
<font color="black"> 594.         &gt;&gt;&gt; b[20] += 'x'       # Make a replacement</font>
<font color="black"> 595.         &gt;&gt;&gt; b[23:28] = []      # Make a deletion</font>
<font color="black"> 596.         &gt;&gt;&gt; b[30] += 'y'       # Make another replacement</font>
<font color="black"> 597.         &gt;&gt;&gt; pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))</font>
<font color="black"> 598.         [[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],</font>
<font color="black"> 599.          [('equal', 16, 19, 17, 20),</font>
<font color="black"> 600.           ('replace', 19, 20, 20, 21),</font>
<font color="black"> 601.           ('equal', 20, 22, 21, 23),</font>
<font color="black"> 602.           ('delete', 22, 27, 23, 23),</font>
<font color="black"> 603.           ('equal', 27, 30, 23, 26)],</font>
<font color="black"> 604.          [('equal', 31, 34, 27, 30),</font>
<font color="black"> 605.           ('replace', 34, 35, 30, 31),</font>
<font color="black"> 606.           ('equal', 35, 38, 31, 34)]]</font>
<font color="black"> 607.         &quot;&quot;&quot;</font>
<font color="black"> 608. </font>
<font color="red"> 609.         codes = self.get_opcodes()</font>
<font color="red"> 610.         if not codes:</font>
<font color="red"> 611.             codes = [(&quot;equal&quot;, 0, 1, 0, 1)]</font>
<font color="black"> 612.         # Fixup leading and trailing groups if they show no changes.</font>
<font color="red"> 613.         if codes[0][0] == 'equal':</font>
<font color="red"> 614.             tag, i1, i2, j1, j2 = codes[0]</font>
<font color="red"> 615.             codes[0] = tag, max(i1, i2-n), i2, max(j1, j2-n), j2</font>
<font color="red"> 616.         if codes[-1][0] == 'equal':</font>
<font color="red"> 617.             tag, i1, i2, j1, j2 = codes[-1]</font>
<font color="red"> 618.             codes[-1] = tag, i1, min(i2, i1+n), j1, min(j2, j1+n)</font>
<font color="black"> 619. </font>
<font color="red"> 620.         nn = n + n</font>
<font color="red"> 621.         group = []</font>
<font color="red"> 622.         for tag, i1, i2, j1, j2 in codes:</font>
<font color="black"> 623.             # End the current group and start a new one whenever</font>
<font color="black"> 624.             # there is a large range with no changes.</font>
<font color="red"> 625.             if tag == 'equal' and i2-i1 &gt; nn:</font>
<font color="red"> 626.                 group.append((tag, i1, min(i2, i1+n), j1, min(j2, j1+n)))</font>
<font color="red"> 627.                 yield group</font>
<font color="red"> 628.                 group = []</font>
<font color="red"> 629.                 i1, j1 = max(i1, i2-n), max(j1, j2-n)</font>
<font color="red"> 630.             group.append((tag, i1, i2, j1 ,j2))</font>
<font color="red"> 631.         if group and not (len(group)==1 and group[0][0] == 'equal'):</font>
<font color="red"> 632.             yield group</font>
<font color="black"> 633. </font>
<font color="green"> 634.     def ratio(self):</font>
<font color="black"> 635.         &quot;&quot;&quot;Return a measure of the sequences' similarity (float in [0,1]).</font>
<font color="black"> 636. </font>
<font color="black"> 637.         Where T is the total number of elements in both sequences, and</font>
<font color="black"> 638.         M is the number of matches, this is 2.0*M / T.</font>
<font color="black"> 639.         Note that this is 1 if the sequences are identical, and 0 if</font>
<font color="black"> 640.         they have nothing in common.</font>
<font color="black"> 641. </font>
<font color="black"> 642.         .ratio() is expensive to compute if you haven't already computed</font>
<font color="black"> 643.         .get_matching_blocks() or .get_opcodes(), in which case you may</font>
<font color="black"> 644.         want to try .quick_ratio() or .real_quick_ratio() first to get an</font>
<font color="black"> 645.         upper bound.</font>
<font color="black"> 646. </font>
<font color="black"> 647.         &gt;&gt;&gt; s = SequenceMatcher(None, &quot;abcd&quot;, &quot;bcde&quot;)</font>
<font color="black"> 648.         &gt;&gt;&gt; s.ratio()</font>
<font color="black"> 649.         0.75</font>
<font color="black"> 650.         &gt;&gt;&gt; s.quick_ratio()</font>
<font color="black"> 651.         0.75</font>
<font color="black"> 652.         &gt;&gt;&gt; s.real_quick_ratio()</font>
<font color="black"> 653.         1.0</font>
<font color="black"> 654.         &quot;&quot;&quot;</font>
<font color="black"> 655. </font>
<font color="red"> 656.         matches = reduce(lambda sum, triple: sum + triple[-1],</font>
<font color="red"> 657.                          self.get_matching_blocks(), 0)</font>
<font color="red"> 658.         return _calculate_ratio(matches, len(self.a) + len(self.b))</font>
<font color="black"> 659. </font>
<font color="green"> 660.     def quick_ratio(self):</font>
<font color="black"> 661.         &quot;&quot;&quot;Return an upper bound on ratio() relatively quickly.</font>
<font color="black"> 662. </font>
<font color="black"> 663.         This isn't defined beyond that it is an upper bound on .ratio(), and</font>
<font color="black"> 664.         is faster to compute.</font>
<font color="black"> 665.         &quot;&quot;&quot;</font>
<font color="black"> 666. </font>
<font color="black"> 667.         # viewing a and b as multisets, set matches to the cardinality</font>
<font color="black"> 668.         # of their intersection; this counts the number of matches</font>
<font color="black"> 669.         # without regard to order, so is clearly an upper bound</font>
<font color="red"> 670.         if self.fullbcount is None:</font>
<font color="red"> 671.             self.fullbcount = fullbcount = {}</font>
<font color="red"> 672.             for elt in self.b:</font>
<font color="red"> 673.                 fullbcount[elt] = fullbcount.get(elt, 0) + 1</font>
<font color="red"> 674.         fullbcount = self.fullbcount</font>
<font color="black"> 675.         # avail[x] is the number of times x appears in 'b' less the</font>
<font color="black"> 676.         # number of times we've seen it in 'a' so far ... kinda</font>
<font color="red"> 677.         avail = {}</font>
<font color="red"> 678.         availhas, matches = avail.__contains__, 0</font>
<font color="red"> 679.         for elt in self.a:</font>
<font color="red"> 680.             if availhas(elt):</font>
<font color="red"> 681.                 numb = avail[elt]</font>
<font color="black"> 682.             else:</font>
<font color="red"> 683.                 numb = fullbcount.get(elt, 0)</font>
<font color="red"> 684.             avail[elt] = numb - 1</font>
<font color="red"> 685.             if numb &gt; 0:</font>
<font color="red"> 686.                 matches = matches + 1</font>
<font color="red"> 687.         return _calculate_ratio(matches, len(self.a) + len(self.b))</font>
<font color="black"> 688. </font>
<font color="green"> 689.     def real_quick_ratio(self):</font>
<font color="black"> 690.         &quot;&quot;&quot;Return an upper bound on ratio() very quickly.</font>
<font color="black"> 691. </font>
<font color="black"> 692.         This isn't defined beyond that it is an upper bound on .ratio(), and</font>
<font color="black"> 693.         is faster to compute than either .ratio() or .quick_ratio().</font>
<font color="black"> 694.         &quot;&quot;&quot;</font>
<font color="black"> 695. </font>
<font color="red"> 696.         la, lb = len(self.a), len(self.b)</font>
<font color="black"> 697.         # can't have more matches than the number of elements in the</font>
<font color="black"> 698.         # shorter sequence</font>
<font color="red"> 699.         return _calculate_ratio(min(la, lb), la + lb)</font>
<font color="black"> 700. </font>
<font color="green"> 701. def get_close_matches(word, possibilities, n=3, cutoff=0.6):</font>
<font color="black"> 702.     &quot;&quot;&quot;Use SequenceMatcher to return list of the best &quot;good enough&quot; matches.</font>
<font color="black"> 703. </font>
<font color="black"> 704.     word is a sequence for which close matches are desired (typically a</font>
<font color="black"> 705.     string).</font>
<font color="black"> 706. </font>
<font color="black"> 707.     possibilities is a list of sequences against which to match word</font>
<font color="black"> 708.     (typically a list of strings).</font>
<font color="black"> 709. </font>
<font color="black"> 710.     Optional arg n (default 3) is the maximum number of close matches to</font>
<font color="black"> 711.     return.  n must be &gt; 0.</font>
<font color="black"> 712. </font>
<font color="black"> 713.     Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities</font>
<font color="black"> 714.     that don't score at least that similar to word are ignored.</font>
<font color="black"> 715. </font>
<font color="black"> 716.     The best (no more than n) matches among the possibilities are returned</font>
<font color="black"> 717.     in a list, sorted by similarity score, most similar first.</font>
<font color="black"> 718. </font>
<font color="black"> 719.     &gt;&gt;&gt; get_close_matches(&quot;appel&quot;, [&quot;ape&quot;, &quot;apple&quot;, &quot;peach&quot;, &quot;puppy&quot;])</font>
<font color="black"> 720.     ['apple', 'ape']</font>
<font color="black"> 721.     &gt;&gt;&gt; import keyword as _keyword</font>
<font color="black"> 722.     &gt;&gt;&gt; get_close_matches(&quot;wheel&quot;, _keyword.kwlist)</font>
<font color="black"> 723.     ['while']</font>
<font color="black"> 724.     &gt;&gt;&gt; get_close_matches(&quot;apple&quot;, _keyword.kwlist)</font>
<font color="black"> 725.     []</font>
<font color="black"> 726.     &gt;&gt;&gt; get_close_matches(&quot;accept&quot;, _keyword.kwlist)</font>
<font color="black"> 727.     ['except']</font>
<font color="black"> 728.     &quot;&quot;&quot;</font>
<font color="black"> 729. </font>
<font color="red"> 730.     if not n &gt;  0:</font>
<font color="red"> 731.         raise ValueError(&quot;n must be &gt; 0: %r&quot; % (n,))</font>
<font color="red"> 732.     if not 0.0 &lt;= cutoff &lt;= 1.0:</font>
<font color="red"> 733.         raise ValueError(&quot;cutoff must be in [0.0, 1.0]: %r&quot; % (cutoff,))</font>
<font color="red"> 734.     result = []</font>
<font color="red"> 735.     s = SequenceMatcher()</font>
<font color="red"> 736.     s.set_seq2(word)</font>
<font color="red"> 737.     for x in possibilities:</font>
<font color="red"> 738.         s.set_seq1(x)</font>
<font color="red"> 739.         if s.real_quick_ratio() &gt;= cutoff and \</font>
<font color="red"> 740.            s.quick_ratio() &gt;= cutoff and \</font>
<font color="red"> 741.            s.ratio() &gt;= cutoff:</font>
<font color="red"> 742.             result.append((s.ratio(), x))</font>
<font color="black"> 743. </font>
<font color="black"> 744.     # Move the best scorers to head of list</font>
<font color="red"> 745.     result = heapq.nlargest(n, result)</font>
<font color="black"> 746.     # Strip scores for the best n matches</font>
<font color="red"> 747.     return [x for score, x in result]</font>
<font color="black"> 748. </font>
<font color="green"> 749. def _count_leading(line, ch):</font>
<font color="black"> 750.     &quot;&quot;&quot;</font>
<font color="black"> 751.     Return number of `ch` characters at the start of `line`.</font>
<font color="black"> 752. </font>
<font color="black"> 753.     Example:</font>
<font color="black"> 754. </font>
<font color="black"> 755.     &gt;&gt;&gt; _count_leading('   abc', ' ')</font>
<font color="black"> 756.     3</font>
<font color="black"> 757.     &quot;&quot;&quot;</font>
<font color="black"> 758. </font>
<font color="red"> 759.     i, n = 0, len(line)</font>
<font color="red"> 760.     while i &lt; n and line[i] == ch:</font>
<font color="red"> 761.         i += 1</font>
<font color="red"> 762.     return i</font>
<font color="black"> 763. </font>
<font color="green"> 764. class Differ:</font>
<font color="black"> 765.     r&quot;&quot;&quot;</font>
<font color="black"> 766.     Differ is a class for comparing sequences of lines of text, and</font>
<font color="black"> 767.     producing human-readable differences or deltas.  Differ uses</font>
<font color="black"> 768.     SequenceMatcher both to compare sequences of lines, and to compare</font>
<font color="black"> 769.     sequences of characters within similar (near-matching) lines.</font>
<font color="black"> 770. </font>
<font color="black"> 771.     Each line of a Differ delta begins with a two-letter code:</font>
<font color="black"> 772. </font>
<font color="black"> 773.         '- '    line unique to sequence 1</font>
<font color="black"> 774.         '+ '    line unique to sequence 2</font>
<font color="black"> 775.         '  '    line common to both sequences</font>
<font color="black"> 776.         '? '    line not present in either input sequence</font>
<font color="black"> 777. </font>
<font color="black"> 778.     Lines beginning with '? ' attempt to guide the eye to intraline</font>
<font color="black"> 779.     differences, and were not present in either input sequence.  These lines</font>
<font color="black"> 780.     can be confusing if the sequences contain tab characters.</font>
<font color="black"> 781. </font>
<font color="black"> 782.     Note that Differ makes no claim to produce a *minimal* diff.  To the</font>
<font color="black"> 783.     contrary, minimal diffs are often counter-intuitive, because they synch</font>
<font color="black"> 784.     up anywhere possible, sometimes accidental matches 100 pages apart.</font>
<font color="black"> 785.     Restricting synch points to contiguous matches preserves some notion of</font>
<font color="black"> 786.     locality, at the occasional cost of producing a longer diff.</font>
<font color="black"> 787. </font>
<font color="black"> 788.     Example: Comparing two texts.</font>
<font color="black"> 789. </font>
<font color="black"> 790.     First we set up the texts, sequences of individual single-line strings</font>
<font color="black"> 791.     ending with newlines (such sequences can also be obtained from the</font>
<font color="black"> 792.     `readlines()` method of file-like objects):</font>
<font color="black"> 793. </font>
<font color="black"> 794.     &gt;&gt;&gt; text1 = '''  1. Beautiful is better than ugly.</font>
<font color="black"> 795.     ...   2. Explicit is better than implicit.</font>
<font color="black"> 796.     ...   3. Simple is better than complex.</font>
<font color="black"> 797.     ...   4. Complex is better than complicated.</font>
<font color="black"> 798.     ... '''.splitlines(1)</font>
<font color="black"> 799.     &gt;&gt;&gt; len(text1)</font>
<font color="black"> 800.     4</font>
<font color="black"> 801.     &gt;&gt;&gt; text1[0][-1]</font>
<font color="black"> 802.     '\n'</font>
<font color="black"> 803.     &gt;&gt;&gt; text2 = '''  1. Beautiful is better than ugly.</font>
<font color="black"> 804.     ...   3.   Simple is better than complex.</font>
<font color="black"> 805.     ...   4. Complicated is better than complex.</font>
<font color="black"> 806.     ...   5. Flat is better than nested.</font>
<font color="black"> 807.     ... '''.splitlines(1)</font>
<font color="black"> 808. </font>
<font color="black"> 809.     Next we instantiate a Differ object:</font>
<font color="black"> 810. </font>
<font color="black"> 811.     &gt;&gt;&gt; d = Differ()</font>
<font color="black"> 812. </font>
<font color="black"> 813.     Note that when instantiating a Differ object we may pass functions to</font>
<font color="black"> 814.     filter out line and character 'junk'.  See Differ.__init__ for details.</font>
<font color="black"> 815. </font>
<font color="black"> 816.     Finally, we compare the two:</font>
<font color="black"> 817. </font>
<font color="black"> 818.     &gt;&gt;&gt; result = list(d.compare(text1, text2))</font>
<font color="black"> 819. </font>
<font color="black"> 820.     'result' is a list of strings, so let's pretty-print it:</font>
<font color="black"> 821. </font>
<font color="black"> 822.     &gt;&gt;&gt; from pprint import pprint as _pprint</font>
<font color="black"> 823.     &gt;&gt;&gt; _pprint(result)</font>
<font color="black"> 824.     ['    1. Beautiful is better than ugly.\n',</font>
<font color="black"> 825.      '-   2. Explicit is better than implicit.\n',</font>
<font color="black"> 826.      '-   3. Simple is better than complex.\n',</font>
<font color="black"> 827.      '+   3.   Simple is better than complex.\n',</font>
<font color="black"> 828.      '?     ++\n',</font>
<font color="black"> 829.      '-   4. Complex is better than complicated.\n',</font>
<font color="black"> 830.      '?            ^                     ---- ^\n',</font>
<font color="black"> 831.      '+   4. Complicated is better than complex.\n',</font>
<font color="black"> 832.      '?           ++++ ^                      ^\n',</font>
<font color="black"> 833.      '+   5. Flat is better than nested.\n']</font>
<font color="black"> 834. </font>
<font color="black"> 835.     As a single multi-line string it looks like this:</font>
<font color="black"> 836. </font>
<font color="black"> 837.     &gt;&gt;&gt; print ''.join(result),</font>
<font color="black"> 838.         1. Beautiful is better than ugly.</font>
<font color="black"> 839.     -   2. Explicit is better than implicit.</font>
<font color="black"> 840.     -   3. Simple is better than complex.</font>
<font color="black"> 841.     +   3.   Simple is better than complex.</font>
<font color="black"> 842.     ?     ++</font>
<font color="black"> 843.     -   4. Complex is better than complicated.</font>
<font color="black"> 844.     ?            ^                     ---- ^</font>
<font color="black"> 845.     +   4. Complicated is better than complex.</font>
<font color="black"> 846.     ?           ++++ ^                      ^</font>
<font color="black"> 847.     +   5. Flat is better than nested.</font>
<font color="black"> 848. </font>
<font color="black"> 849.     Methods:</font>
<font color="black"> 850. </font>
<font color="black"> 851.     __init__(linejunk=None, charjunk=None)</font>
<font color="black"> 852.         Construct a text differencer, with optional filters.</font>
<font color="black"> 853. </font>
<font color="black"> 854.     compare(a, b)</font>
<font color="black"> 855.         Compare two sequences of lines; generate the resulting delta.</font>
<font color="green"> 856.     &quot;&quot;&quot;</font>
<font color="black"> 857. </font>
<font color="green"> 858.     def __init__(self, linejunk=None, charjunk=None):</font>
<font color="black"> 859.         &quot;&quot;&quot;</font>
<font color="black"> 860.         Construct a text differencer, with optional filters.</font>
<font color="black"> 861. </font>
<font color="black"> 862.         The two optional keyword parameters are for filter functions:</font>
<font color="black"> 863. </font>
<font color="black"> 864.         - `linejunk`: A function that should accept a single string argument,</font>
<font color="black"> 865.           and return true iff the string is junk. The module-level function</font>
<font color="black"> 866.           `IS_LINE_JUNK` may be used to filter out lines without visible</font>
<font color="black"> 867.           characters, except for at most one splat ('#').  It is recommended</font>
<font color="black"> 868.           to leave linejunk None; as of Python 2.3, the underlying</font>
<font color="black"> 869.           SequenceMatcher class has grown an adaptive notion of &quot;noise&quot; lines</font>
<font color="black"> 870.           that's better than any static definition the author has ever been</font>
<font color="black"> 871.           able to craft.</font>
<font color="black"> 872. </font>
<font color="black"> 873.         - `charjunk`: A function that should accept a string of length 1. The</font>
<font color="black"> 874.           module-level function `IS_CHARACTER_JUNK` may be used to filter out</font>
<font color="black"> 875.           whitespace characters (a blank or tab; **note**: bad idea to include</font>
<font color="black"> 876.           newline in this!).  Use of IS_CHARACTER_JUNK is recommended.</font>
<font color="black"> 877.         &quot;&quot;&quot;</font>
<font color="black"> 878. </font>
<font color="red"> 879.         self.linejunk = linejunk</font>
<font color="red"> 880.         self.charjunk = charjunk</font>
<font color="black"> 881. </font>
<font color="green"> 882.     def compare(self, a, b):</font>
<font color="black"> 883.         r&quot;&quot;&quot;</font>
<font color="black"> 884.         Compare two sequences of lines; generate the resulting delta.</font>
<font color="black"> 885. </font>
<font color="black"> 886.         Each sequence must contain individual single-line strings ending with</font>
<font color="black"> 887.         newlines. Such sequences can be obtained from the `readlines()` method</font>
<font color="black"> 888.         of file-like objects.  The delta generated also consists of newline-</font>
<font color="black"> 889.         terminated strings, ready to be printed as-is via the writeline()</font>
<font color="black"> 890.         method of a file-like object.</font>
<font color="black"> 891. </font>
<font color="black"> 892.         Example:</font>
<font color="black"> 893. </font>
<font color="black"> 894.         &gt;&gt;&gt; print ''.join(Differ().compare('one\ntwo\nthree\n'.splitlines(1),</font>
<font color="black"> 895.         ...                                'ore\ntree\nemu\n'.splitlines(1))),</font>
<font color="black"> 896.         - one</font>
<font color="black"> 897.         ?  ^</font>
<font color="black"> 898.         + ore</font>
<font color="black"> 899.         ?  ^</font>
<font color="black"> 900.         - two</font>
<font color="black"> 901.         - three</font>
<font color="black"> 902.         ?  -</font>
<font color="black"> 903.         + tree</font>
<font color="black"> 904.         + emu</font>
<font color="black"> 905.         &quot;&quot;&quot;</font>
<font color="black"> 906. </font>
<font color="red"> 907.         cruncher = SequenceMatcher(self.linejunk, a, b)</font>
<font color="red"> 908.         for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():</font>
<font color="red"> 909.             if tag == 'replace':</font>
<font color="red"> 910.                 g = self._fancy_replace(a, alo, ahi, b, blo, bhi)</font>
<font color="red"> 911.             elif tag == 'delete':</font>
<font color="red"> 912.                 g = self._dump('-', a, alo, ahi)</font>
<font color="red"> 913.             elif tag == 'insert':</font>
<font color="red"> 914.                 g = self._dump('+', b, blo, bhi)</font>
<font color="red"> 915.             elif tag == 'equal':</font>
<font color="red"> 916.                 g = self._dump(' ', a, alo, ahi)</font>
<font color="black"> 917.             else:</font>
<font color="red"> 918.                 raise ValueError, 'unknown tag %r' % (tag,)</font>
<font color="black"> 919. </font>
<font color="red"> 920.             for line in g:</font>
<font color="red"> 921.                 yield line</font>
<font color="black"> 922. </font>
<font color="green"> 923.     def _dump(self, tag, x, lo, hi):</font>
<font color="black"> 924.         &quot;&quot;&quot;Generate comparison results for a same-tagged range.&quot;&quot;&quot;</font>
<font color="red"> 925.         for i in xrange(lo, hi):</font>
<font color="red"> 926.             yield '%s %s' % (tag, x[i])</font>
<font color="black"> 927. </font>
<font color="green"> 928.     def _plain_replace(self, a, alo, ahi, b, blo, bhi):</font>
<font color="red"> 929.         assert alo &lt; ahi and blo &lt; bhi</font>
<font color="black"> 930.         # dump the shorter block first -- reduces the burden on short-term</font>
<font color="black"> 931.         # memory if the blocks are of very different sizes</font>
<font color="red"> 932.         if bhi - blo &lt; ahi - alo:</font>
<font color="red"> 933.             first  = self._dump('+', b, blo, bhi)</font>
<font color="red"> 934.             second = self._dump('-', a, alo, ahi)</font>
<font color="black"> 935.         else:</font>
<font color="red"> 936.             first  = self._dump('-', a, alo, ahi)</font>
<font color="red"> 937.             second = self._dump('+', b, blo, bhi)</font>
<font color="black"> 938. </font>
<font color="red"> 939.         for g in first, second:</font>
<font color="red"> 940.             for line in g:</font>
<font color="red"> 941.                 yield line</font>
<font color="black"> 942. </font>
<font color="green"> 943.     def _fancy_replace(self, a, alo, ahi, b, blo, bhi):</font>
<font color="black"> 944.         r&quot;&quot;&quot;</font>
<font color="black"> 945.         When replacing one block of lines with another, search the blocks</font>
<font color="black"> 946.         for *similar* lines; the best-matching pair (if any) is used as a</font>
<font color="black"> 947.         synch point, and intraline difference marking is done on the</font>
<font color="black"> 948.         similar pair. Lots of work, but often worth it.</font>
<font color="black"> 949. </font>
<font color="black"> 950.         Example:</font>
<font color="black"> 951. </font>
<font color="black"> 952.         &gt;&gt;&gt; d = Differ()</font>
<font color="black"> 953.         &gt;&gt;&gt; results = d._fancy_replace(['abcDefghiJkl\n'], 0, 1,</font>
<font color="black"> 954.         ...                            ['abcdefGhijkl\n'], 0, 1)</font>
<font color="black"> 955.         &gt;&gt;&gt; print ''.join(results),</font>
<font color="black"> 956.         - abcDefghiJkl</font>
<font color="black"> 957.         ?    ^  ^  ^</font>
<font color="black"> 958.         + abcdefGhijkl</font>
<font color="black"> 959.         ?    ^  ^  ^</font>
<font color="black"> 960.         &quot;&quot;&quot;</font>
<font color="black"> 961. </font>
<font color="black"> 962.         # don't synch up unless the lines have a similarity score of at</font>
<font color="black"> 963.         # least cutoff; best_ratio tracks the best score seen so far</font>
<font color="red"> 964.         best_ratio, cutoff = 0.74, 0.75</font>
<font color="red"> 965.         cruncher = SequenceMatcher(self.charjunk)</font>
<font color="red"> 966.         eqi, eqj = None, None   # 1st indices of equal lines (if any)</font>
<font color="black"> 967. </font>
<font color="black"> 968.         # search for the pair that matches best without being identical</font>
<font color="black"> 969.         # (identical lines must be junk lines, &amp; we don't want to synch up</font>
<font color="black"> 970.         # on junk -- unless we have to)</font>
<font color="red"> 971.         for j in xrange(blo, bhi):</font>
<font color="red"> 972.             bj = b[j]</font>
<font color="red"> 973.             cruncher.set_seq2(bj)</font>
<font color="red"> 974.             for i in xrange(alo, ahi):</font>
<font color="red"> 975.                 ai = a[i]</font>
<font color="red"> 976.                 if ai == bj:</font>
<font color="red"> 977.                     if eqi is None:</font>
<font color="red"> 978.                         eqi, eqj = i, j</font>
<font color="red"> 979.                     continue</font>
<font color="red"> 980.                 cruncher.set_seq1(ai)</font>
<font color="black"> 981.                 # computing similarity is expensive, so use the quick</font>
<font color="black"> 982.                 # upper bounds first -- have seen this speed up messy</font>
<font color="black"> 983.                 # compares by a factor of 3.</font>
<font color="black"> 984.                 # note that ratio() is only expensive to compute the first</font>
<font color="black"> 985.                 # time it's called on a sequence pair; the expensive part</font>
<font color="black"> 986.                 # of the computation is cached by cruncher</font>
<font color="red"> 987.                 if cruncher.real_quick_ratio() &gt; best_ratio and \</font>
<font color="red"> 988.                       cruncher.quick_ratio() &gt; best_ratio and \</font>
<font color="red"> 989.                       cruncher.ratio() &gt; best_ratio:</font>
<font color="red"> 990.                     best_ratio, best_i, best_j = cruncher.ratio(), i, j</font>
<font color="red"> 991.         if best_ratio &lt; cutoff:</font>
<font color="black"> 992.             # no non-identical &quot;pretty close&quot; pair</font>
<font color="red"> 993.             if eqi is None:</font>
<font color="black"> 994.                 # no identical pair either -- treat it as a straight replace</font>
<font color="red"> 995.                 for line in self._plain_replace(a, alo, ahi, b, blo, bhi):</font>
<font color="red"> 996.                     yield line</font>
<font color="red"> 997.                 return</font>
<font color="black"> 998.             # no close pair, but an identical pair -- synch up on that</font>
<font color="red"> 999.             best_i, best_j, best_ratio = eqi, eqj, 1.0</font>
<font color="black">1000.         else:</font>
<font color="black">1001.             # there's a close pair, so forget the identical pair (if any)</font>
<font color="red">1002.             eqi = None</font>
<font color="black">1003. </font>
<font color="black">1004.         # a[best_i] very similar to b[best_j]; eqi is None iff they're not</font>
<font color="black">1005.         # identical</font>
<font color="black">1006. </font>
<font color="black">1007.         # pump out diffs from before the synch point</font>
<font color="red">1008.         for line in self._fancy_helper(a, alo, best_i, b, blo, best_j):</font>
<font color="red">1009.             yield line</font>
<font color="black">1010. </font>
<font color="black">1011.         # do intraline marking on the synch pair</font>
<font color="red">1012.         aelt, belt = a[best_i], b[best_j]</font>
<font color="red">1013.         if eqi is None:</font>
<font color="black">1014.             # pump out a '-', '?', '+', '?' quad for the synched lines</font>
<font color="red">1015.             atags = btags = &quot;&quot;</font>
<font color="red">1016.             cruncher.set_seqs(aelt, belt)</font>
<font color="red">1017.             for tag, ai1, ai2, bj1, bj2 in cruncher.get_opcodes():</font>
<font color="red">1018.                 la, lb = ai2 - ai1, bj2 - bj1</font>
<font color="red">1019.                 if tag == 'replace':</font>
<font color="red">1020.                     atags += '^' * la</font>
<font color="red">1021.                     btags += '^' * lb</font>
<font color="red">1022.                 elif tag == 'delete':</font>
<font color="red">1023.                     atags += '-' * la</font>
<font color="red">1024.                 elif tag == 'insert':</font>
<font color="red">1025.                     btags += '+' * lb</font>
<font color="red">1026.                 elif tag == 'equal':</font>
<font color="red">1027.                     atags += ' ' * la</font>
<font color="red">1028.                     btags += ' ' * lb</font>
<font color="black">1029.                 else:</font>
<font color="red">1030.                     raise ValueError, 'unknown tag %r' % (tag,)</font>
<font color="red">1031.             for line in self._qformat(aelt, belt, atags, btags):</font>
<font color="red">1032.                 yield line</font>
<font color="black">1033.         else:</font>
<font color="black">1034.             # the synch pair is identical</font>
<font color="red">1035.             yield '  ' + aelt</font>
<font color="black">1036. </font>
<font color="black">1037.         # pump out diffs from after the synch point</font>
<font color="red">1038.         for line in self._fancy_helper(a, best_i+1, ahi, b, best_j+1, bhi):</font>
<font color="red">1039.             yield line</font>
<font color="black">1040. </font>
<font color="green">1041.     def _fancy_helper(self, a, alo, ahi, b, blo, bhi):</font>
<font color="red">1042.         g = []</font>
<font color="red">1043.         if alo &lt; ahi:</font>
<font color="red">1044.             if blo &lt; bhi:</font>
<font color="red">1045.                 g = self._fancy_replace(a, alo, ahi, b, blo, bhi)</font>
<font color="black">1046.             else:</font>
<font color="red">1047.                 g = self._dump('-', a, alo, ahi)</font>
<font color="red">1048.         elif blo &lt; bhi:</font>
<font color="red">1049.             g = self._dump('+', b, blo, bhi)</font>
<font color="black">1050. </font>
<font color="red">1051.         for line in g:</font>
<font color="red">1052.             yield line</font>
<font color="black">1053. </font>
<font color="green">1054.     def _qformat(self, aline, bline, atags, btags):</font>
<font color="black">1055.         r&quot;&quot;&quot;</font>
<font color="black">1056.         Format &quot;?&quot; output and deal with leading tabs.</font>
<font color="black">1057. </font>
<font color="black">1058.         Example:</font>
<font color="black">1059. </font>
<font color="black">1060.         &gt;&gt;&gt; d = Differ()</font>
<font color="black">1061.         &gt;&gt;&gt; results = d._qformat('\tabcDefghiJkl\n', '\tabcdefGhijkl\n',</font>
<font color="black">1062.         ...                      '  ^ ^  ^      ', '  ^ ^  ^      ')</font>
<font color="black">1063.         &gt;&gt;&gt; for line in results: print repr(line)</font>
<font color="black">1064.         ...</font>
<font color="black">1065.         '- \tabcDefghiJkl\n'</font>
<font color="black">1066.         '? \t ^ ^  ^\n'</font>
<font color="black">1067.         '+ \tabcdefGhijkl\n'</font>
<font color="black">1068.         '? \t ^ ^  ^\n'</font>
<font color="black">1069.         &quot;&quot;&quot;</font>
<font color="black">1070. </font>
<font color="black">1071.         # Can hurt, but will probably help most of the time.</font>
<font color="red">1072.         common = min(_count_leading(aline, &quot;\t&quot;),</font>
<font color="red">1073.                      _count_leading(bline, &quot;\t&quot;))</font>
<font color="red">1074.         common = min(common, _count_leading(atags[:common], &quot; &quot;))</font>
<font color="red">1075.         common = min(common, _count_leading(btags[:common], &quot; &quot;))</font>
<font color="red">1076.         atags = atags[common:].rstrip()</font>
<font color="red">1077.         btags = btags[common:].rstrip()</font>
<font color="black">1078. </font>
<font color="red">1079.         yield &quot;- &quot; + aline</font>
<font color="red">1080.         if atags:</font>
<font color="red">1081.             yield &quot;? %s%s\n&quot; % (&quot;\t&quot; * common, atags)</font>
<font color="black">1082. </font>
<font color="red">1083.         yield &quot;+ &quot; + bline</font>
<font color="red">1084.         if btags:</font>
<font color="red">1085.             yield &quot;? %s%s\n&quot; % (&quot;\t&quot; * common, btags)</font>
<font color="black">1086. </font>
<font color="black">1087. # With respect to junk, an earlier version of ndiff simply refused to</font>
<font color="black">1088. # *start* a match with a junk element.  The result was cases like this:</font>
<font color="black">1089. #     before: private Thread currentThread;</font>
<font color="black">1090. #     after:  private volatile Thread currentThread;</font>
<font color="black">1091. # If you consider whitespace to be junk, the longest contiguous match</font>
<font color="black">1092. # not starting with junk is &quot;e Thread currentThread&quot;.  So ndiff reported</font>
<font color="black">1093. # that &quot;e volatil&quot; was inserted between the 't' and the 'e' in &quot;private&quot;.</font>
<font color="black">1094. # While an accurate view, to people that's absurd.  The current version</font>
<font color="black">1095. # looks for matching blocks that are entirely junk-free, then extends the</font>
<font color="black">1096. # longest one of those as far as possible but only with matching junk.</font>
<font color="black">1097. # So now &quot;currentThread&quot; is matched, then extended to suck up the</font>
<font color="black">1098. # preceding blank; then &quot;private&quot; is matched, and extended to suck up the</font>
<font color="black">1099. # following blank; then &quot;Thread&quot; is matched; and finally ndiff reports</font>
<font color="black">1100. # that &quot;volatile &quot; was inserted before &quot;Thread&quot;.  The only quibble</font>
<font color="black">1101. # remaining is that perhaps it was really the case that &quot; volatile&quot;</font>
<font color="black">1102. # was inserted after &quot;private&quot;.  I can live with that &lt;wink&gt;.</font>
<font color="black">1103. </font>
<font color="green">1104. import re</font>
<font color="black">1105. </font>
<font color="green">1106. def IS_LINE_JUNK(line, pat=re.compile(r&quot;\s*#?\s*$&quot;).match):</font>
<font color="black">1107.     r&quot;&quot;&quot;</font>
<font color="black">1108.     Return 1 for ignorable line: iff `line` is blank or contains a single '#'.</font>
<font color="black">1109. </font>
<font color="black">1110.     Examples:</font>
<font color="black">1111. </font>
<font color="black">1112.     &gt;&gt;&gt; IS_LINE_JUNK('\n')</font>
<font color="black">1113.     True</font>
<font color="black">1114.     &gt;&gt;&gt; IS_LINE_JUNK('  #   \n')</font>
<font color="black">1115.     True</font>
<font color="black">1116.     &gt;&gt;&gt; IS_LINE_JUNK('hello\n')</font>
<font color="black">1117.     False</font>
<font color="black">1118.     &quot;&quot;&quot;</font>
<font color="black">1119. </font>
<font color="red">1120.     return pat(line) is not None</font>
<font color="black">1121. </font>
<font color="green">1122. def IS_CHARACTER_JUNK(ch, ws=&quot; \t&quot;):</font>
<font color="black">1123.     r&quot;&quot;&quot;</font>
<font color="black">1124.     Return 1 for ignorable character: iff `ch` is a space or tab.</font>
<font color="black">1125. </font>
<font color="black">1126.     Examples:</font>
<font color="black">1127. </font>
<font color="black">1128.     &gt;&gt;&gt; IS_CHARACTER_JUNK(' ')</font>
<font color="black">1129.     True</font>
<font color="black">1130.     &gt;&gt;&gt; IS_CHARACTER_JUNK('\t')</font>
<font color="black">1131.     True</font>
<font color="black">1132.     &gt;&gt;&gt; IS_CHARACTER_JUNK('\n')</font>
<font color="black">1133.     False</font>
<font color="black">1134.     &gt;&gt;&gt; IS_CHARACTER_JUNK('x')</font>
<font color="black">1135.     False</font>
<font color="black">1136.     &quot;&quot;&quot;</font>
<font color="black">1137. </font>
<font color="red">1138.     return ch in ws</font>
<font color="black">1139. </font>
<font color="black">1140. </font>
<font color="black">1141. ########################################################################</font>
<font color="black">1142. ###  Unified Diff</font>
<font color="black">1143. ########################################################################</font>
<font color="black">1144. </font>
<font color="green">1145. def _format_range_unified(start, stop):</font>
<font color="black">1146.     'Convert range to the &quot;ed&quot; format'</font>
<font color="black">1147.     # Per the diff spec at http://www.unix.org/single_unix_specification/</font>
<font color="red">1148.     beginning = start + 1     # lines start numbering with one</font>
<font color="red">1149.     length = stop - start</font>
<font color="red">1150.     if length == 1:</font>
<font color="red">1151.         return '{}'.format(beginning)</font>
<font color="red">1152.     if not length:</font>
<font color="red">1153.         beginning -= 1        # empty ranges begin at line just before the range</font>
<font color="red">1154.     return '{},{}'.format(beginning, length)</font>
<font color="black">1155. </font>
<font color="green">1156. def unified_diff(a, b, fromfile='', tofile='', fromfiledate='',</font>
<font color="green">1157.                  tofiledate='', n=3, lineterm='\n'):</font>
<font color="black">1158.     r&quot;&quot;&quot;</font>
<font color="black">1159.     Compare two sequences of lines; generate the delta as a unified diff.</font>
<font color="black">1160. </font>
<font color="black">1161.     Unified diffs are a compact way of showing line changes and a few</font>
<font color="black">1162.     lines of context.  The number of context lines is set by 'n' which</font>
<font color="black">1163.     defaults to three.</font>
<font color="black">1164. </font>
<font color="black">1165.     By default, the diff control lines (those with ---, +++, or @@) are</font>
<font color="black">1166.     created with a trailing newline.  This is helpful so that inputs</font>
<font color="black">1167.     created from file.readlines() result in diffs that are suitable for</font>
<font color="black">1168.     file.writelines() since both the inputs and outputs have trailing</font>
<font color="black">1169.     newlines.</font>
<font color="black">1170. </font>
<font color="black">1171.     For inputs that do not have trailing newlines, set the lineterm</font>
<font color="black">1172.     argument to &quot;&quot; so that the output will be uniformly newline free.</font>
<font color="black">1173. </font>
<font color="black">1174.     The unidiff format normally has a header for filenames and modification</font>
<font color="black">1175.     times.  Any or all of these may be specified using strings for</font>
<font color="black">1176.     'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.</font>
<font color="black">1177.     The modification times are normally expressed in the ISO 8601 format.</font>
<font color="black">1178. </font>
<font color="black">1179.     Example:</font>
<font color="black">1180. </font>
<font color="black">1181.     &gt;&gt;&gt; for line in unified_diff('one two three four'.split(),</font>
<font color="black">1182.     ...             'zero one tree four'.split(), 'Original', 'Current',</font>
<font color="black">1183.     ...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',</font>
<font color="black">1184.     ...             lineterm=''):</font>
<font color="black">1185.     ...     print line                  # doctest: +NORMALIZE_WHITESPACE</font>
<font color="black">1186.     --- Original        2005-01-26 23:30:50</font>
<font color="black">1187.     +++ Current         2010-04-02 10:20:52</font>
<font color="black">1188.     @@ -1,4 +1,4 @@</font>
<font color="black">1189.     +zero</font>
<font color="black">1190.      one</font>
<font color="black">1191.     -two</font>
<font color="black">1192.     -three</font>
<font color="black">1193.     +tree</font>
<font color="black">1194.      four</font>
<font color="black">1195.     &quot;&quot;&quot;</font>
<font color="black">1196. </font>
<font color="red">1197.     started = False</font>
<font color="red">1198.     for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):</font>
<font color="red">1199.         if not started:</font>
<font color="red">1200.             started = True</font>
<font color="red">1201.             fromdate = '\t{}'.format(fromfiledate) if fromfiledate else ''</font>
<font color="red">1202.             todate = '\t{}'.format(tofiledate) if tofiledate else ''</font>
<font color="red">1203.             yield '--- {}{}{}'.format(fromfile, fromdate, lineterm)</font>
<font color="red">1204.             yield '+++ {}{}{}'.format(tofile, todate, lineterm)</font>
<font color="black">1205. </font>
<font color="red">1206.         first, last = group[0], group[-1]</font>
<font color="red">1207.         file1_range = _format_range_unified(first[1], last[2])</font>
<font color="red">1208.         file2_range = _format_range_unified(first[3], last[4])</font>
<font color="red">1209.         yield '@@ -{} +{} @@{}'.format(file1_range, file2_range, lineterm)</font>
<font color="black">1210. </font>
<font color="red">1211.         for tag, i1, i2, j1, j2 in group:</font>
<font color="red">1212.             if tag == 'equal':</font>
<font color="red">1213.                 for line in a[i1:i2]:</font>
<font color="red">1214.                     yield ' ' + line</font>
<font color="red">1215.                 continue</font>
<font color="red">1216.             if tag in ('replace', 'delete'):</font>
<font color="red">1217.                 for line in a[i1:i2]:</font>
<font color="red">1218.                     yield '-' + line</font>
<font color="red">1219.             if tag in ('replace', 'insert'):</font>
<font color="red">1220.                 for line in b[j1:j2]:</font>
<font color="red">1221.                     yield '+' + line</font>
<font color="black">1222. </font>
<font color="black">1223. </font>
<font color="black">1224. ########################################################################</font>
<font color="black">1225. ###  Context Diff</font>
<font color="black">1226. ########################################################################</font>
<font color="black">1227. </font>
<font color="green">1228. def _format_range_context(start, stop):</font>
<font color="black">1229.     'Convert range to the &quot;ed&quot; format'</font>
<font color="black">1230.     # Per the diff spec at http://www.unix.org/single_unix_specification/</font>
<font color="red">1231.     beginning = start + 1     # lines start numbering with one</font>
<font color="red">1232.     length = stop - start</font>
<font color="red">1233.     if not length:</font>
<font color="red">1234.         beginning -= 1        # empty ranges begin at line just before the range</font>
<font color="red">1235.     if length &lt;= 1:</font>
<font color="red">1236.         return '{}'.format(beginning)</font>
<font color="red">1237.     return '{},{}'.format(beginning, beginning + length - 1)</font>
<font color="black">1238. </font>
<font color="black">1239. # See http://www.unix.org/single_unix_specification/</font>
<font color="green">1240. def context_diff(a, b, fromfile='', tofile='',</font>
<font color="green">1241.                  fromfiledate='', tofiledate='', n=3, lineterm='\n'):</font>
<font color="black">1242.     r&quot;&quot;&quot;</font>
<font color="black">1243.     Compare two sequences of lines; generate the delta as a context diff.</font>
<font color="black">1244. </font>
<font color="black">1245.     Context diffs are a compact way of showing line changes and a few</font>
<font color="black">1246.     lines of context.  The number of context lines is set by 'n' which</font>
<font color="black">1247.     defaults to three.</font>
<font color="black">1248. </font>
<font color="black">1249.     By default, the diff control lines (those with *** or ---) are</font>
<font color="black">1250.     created with a trailing newline.  This is helpful so that inputs</font>
<font color="black">1251.     created from file.readlines() result in diffs that are suitable for</font>
<font color="black">1252.     file.writelines() since both the inputs and outputs have trailing</font>
<font color="black">1253.     newlines.</font>
<font color="black">1254. </font>
<font color="black">1255.     For inputs that do not have trailing newlines, set the lineterm</font>
<font color="black">1256.     argument to &quot;&quot; so that the output will be uniformly newline free.</font>
<font color="black">1257. </font>
<font color="black">1258.     The context diff format normally has a header for filenames and</font>
<font color="black">1259.     modification times.  Any or all of these may be specified using</font>
<font color="black">1260.     strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.</font>
<font color="black">1261.     The modification times are normally expressed in the ISO 8601 format.</font>
<font color="black">1262.     If not specified, the strings default to blanks.</font>
<font color="black">1263. </font>
<font color="black">1264.     Example:</font>
<font color="black">1265. </font>
<font color="black">1266.     &gt;&gt;&gt; print ''.join(context_diff('one\ntwo\nthree\nfour\n'.splitlines(1),</font>
<font color="black">1267.     ...       'zero\none\ntree\nfour\n'.splitlines(1), 'Original', 'Current')),</font>
<font color="black">1268.     *** Original</font>
<font color="black">1269.     --- Current</font>
<font color="black">1270.     ***************</font>
<font color="black">1271.     *** 1,4 ****</font>
<font color="black">1272.       one</font>
<font color="black">1273.     ! two</font>
<font color="black">1274.     ! three</font>
<font color="black">1275.       four</font>
<font color="black">1276.     --- 1,4 ----</font>
<font color="black">1277.     + zero</font>
<font color="black">1278.       one</font>
<font color="black">1279.     ! tree</font>
<font color="black">1280.       four</font>
<font color="black">1281.     &quot;&quot;&quot;</font>
<font color="black">1282. </font>
<font color="red">1283.     prefix = dict(insert='+ ', delete='- ', replace='! ', equal='  ')</font>
<font color="red">1284.     started = False</font>
<font color="red">1285.     for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):</font>
<font color="red">1286.         if not started:</font>
<font color="red">1287.             started = True</font>
<font color="red">1288.             fromdate = '\t{}'.format(fromfiledate) if fromfiledate else ''</font>
<font color="red">1289.             todate = '\t{}'.format(tofiledate) if tofiledate else ''</font>
<font color="red">1290.             yield '*** {}{}{}'.format(fromfile, fromdate, lineterm)</font>
<font color="red">1291.             yield '--- {}{}{}'.format(tofile, todate, lineterm)</font>
<font color="black">1292. </font>
<font color="red">1293.         first, last = group[0], group[-1]</font>
<font color="red">1294.         yield '***************' + lineterm</font>
<font color="black">1295. </font>
<font color="red">1296.         file1_range = _format_range_context(first[1], last[2])</font>
<font color="red">1297.         yield '*** {} ****{}'.format(file1_range, lineterm)</font>
<font color="black">1298. </font>
<font color="red">1299.         if any(tag in ('replace', 'delete') for tag, _, _, _, _ in group):</font>
<font color="red">1300.             for tag, i1, i2, _, _ in group:</font>
<font color="red">1301.                 if tag != 'insert':</font>
<font color="red">1302.                     for line in a[i1:i2]:</font>
<font color="red">1303.                         yield prefix[tag] + line</font>
<font color="black">1304. </font>
<font color="red">1305.         file2_range = _format_range_context(first[3], last[4])</font>
<font color="red">1306.         yield '--- {} ----{}'.format(file2_range, lineterm)</font>
<font color="black">1307. </font>
<font color="red">1308.         if any(tag in ('replace', 'insert') for tag, _, _, _, _ in group):</font>
<font color="red">1309.             for tag, _, _, j1, j2 in group:</font>
<font color="red">1310.                 if tag != 'delete':</font>
<font color="red">1311.                     for line in b[j1:j2]:</font>
<font color="red">1312.                         yield prefix[tag] + line</font>
<font color="black">1313. </font>
<font color="green">1314. def ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK):</font>
<font color="black">1315.     r&quot;&quot;&quot;</font>
<font color="black">1316.     Compare `a` and `b` (lists of strings); return a `Differ`-style delta.</font>
<font color="black">1317. </font>
<font color="black">1318.     Optional keyword parameters `linejunk` and `charjunk` are for filter</font>
<font color="black">1319.     functions (or None):</font>
<font color="black">1320. </font>
<font color="black">1321.     - linejunk: A function that should accept a single string argument, and</font>
<font color="black">1322.       return true iff the string is junk.  The default is None, and is</font>
<font color="black">1323.       recommended; as of Python 2.3, an adaptive notion of &quot;noise&quot; lines is</font>
<font color="black">1324.       used that does a good job on its own.</font>
<font color="black">1325. </font>
<font color="black">1326.     - charjunk: A function that should accept a string of length 1. The</font>
<font color="black">1327.       default is module-level function IS_CHARACTER_JUNK, which filters out</font>
<font color="black">1328.       whitespace characters (a blank or tab; note: bad idea to include newline</font>
<font color="black">1329.       in this!).</font>
<font color="black">1330. </font>
<font color="black">1331.     Tools/scripts/ndiff.py is a command-line front-end to this function.</font>
<font color="black">1332. </font>
<font color="black">1333.     Example:</font>
<font color="black">1334. </font>
<font color="black">1335.     &gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(1),</font>
<font color="black">1336.     ...              'ore\ntree\nemu\n'.splitlines(1))</font>
<font color="black">1337.     &gt;&gt;&gt; print ''.join(diff),</font>
<font color="black">1338.     - one</font>
<font color="black">1339.     ?  ^</font>
<font color="black">1340.     + ore</font>
<font color="black">1341.     ?  ^</font>
<font color="black">1342.     - two</font>
<font color="black">1343.     - three</font>
<font color="black">1344.     ?  -</font>
<font color="black">1345.     + tree</font>
<font color="black">1346.     + emu</font>
<font color="black">1347.     &quot;&quot;&quot;</font>
<font color="red">1348.     return Differ(linejunk, charjunk).compare(a, b)</font>
<font color="black">1349. </font>
<font color="green">1350. def _mdiff(fromlines, tolines, context=None, linejunk=None,</font>
<font color="green">1351.            charjunk=IS_CHARACTER_JUNK):</font>
<font color="black">1352.     r&quot;&quot;&quot;Returns generator yielding marked up from/to side by side differences.</font>
<font color="black">1353. </font>
<font color="black">1354.     Arguments:</font>
<font color="black">1355.     fromlines -- list of text lines to compared to tolines</font>
<font color="black">1356.     tolines -- list of text lines to be compared to fromlines</font>
<font color="black">1357.     context -- number of context lines to display on each side of difference,</font>
<font color="black">1358.                if None, all from/to text lines will be generated.</font>
<font color="black">1359.     linejunk -- passed on to ndiff (see ndiff documentation)</font>
<font color="black">1360.     charjunk -- passed on to ndiff (see ndiff documentation)</font>
<font color="black">1361. </font>
<font color="black">1362.     This function returns an iterator which returns a tuple:</font>
<font color="black">1363.     (from line tuple, to line tuple, boolean flag)</font>
<font color="black">1364. </font>
<font color="black">1365.     from/to line tuple -- (line num, line text)</font>
<font color="black">1366.         line num -- integer or None (to indicate a context separation)</font>
<font color="black">1367.         line text -- original line text with following markers inserted:</font>
<font color="black">1368.             '\0+' -- marks start of added text</font>
<font color="black">1369.             '\0-' -- marks start of deleted text</font>
<font color="black">1370.             '\0^' -- marks start of changed text</font>
<font color="black">1371.             '\1' -- marks end of added/deleted/changed text</font>
<font color="black">1372. </font>
<font color="black">1373.     boolean flag -- None indicates context separation, True indicates</font>
<font color="black">1374.         either &quot;from&quot; or &quot;to&quot; line contains a change, otherwise False.</font>
<font color="black">1375. </font>
<font color="black">1376.     This function/iterator was originally developed to generate side by side</font>
<font color="black">1377.     file difference for making HTML pages (see HtmlDiff class for example</font>
<font color="black">1378.     usage).</font>
<font color="black">1379. </font>
<font color="black">1380.     Note, this function utilizes the ndiff function to generate the side by</font>
<font color="black">1381.     side difference markup.  Optional ndiff arguments may be passed to this</font>
<font color="black">1382.     function and they in turn will be passed to ndiff.</font>
<font color="black">1383.     &quot;&quot;&quot;</font>
<font color="red">1384.     import re</font>
<font color="black">1385. </font>
<font color="black">1386.     # regular expression for finding intraline change indices</font>
<font color="red">1387.     change_re = re.compile('(\++|\-+|\^+)')</font>
<font color="black">1388. </font>
<font color="black">1389.     # create the difference iterator to generate the differences</font>
<font color="red">1390.     diff_lines_iterator = ndiff(fromlines,tolines,linejunk,charjunk)</font>
<font color="black">1391. </font>
<font color="red">1392.     def _make_line(lines, format_key, side, num_lines=[0,0]):</font>
<font color="black">1393.         &quot;&quot;&quot;Returns line of text with user's change markup and line formatting.</font>
<font color="black">1394. </font>
<font color="black">1395.         lines -- list of lines from the ndiff generator to produce a line of</font>
<font color="black">1396.                  text from.  When producing the line of text to return, the</font>
<font color="black">1397.                  lines used are removed from this list.</font>
<font color="black">1398.         format_key -- '+' return first line in list with &quot;add&quot; markup around</font>
<font color="black">1399.                           the entire line.</font>
<font color="black">1400.                       '-' return first line in list with &quot;delete&quot; markup around</font>
<font color="black">1401.                           the entire line.</font>
<font color="black">1402.                       '?' return first line in list with add/delete/change</font>
<font color="black">1403.                           intraline markup (indices obtained from second line)</font>
<font color="black">1404.                       None return first line in list with no markup</font>
<font color="black">1405.         side -- indice into the num_lines list (0=from,1=to)</font>
<font color="black">1406.         num_lines -- from/to current line number.  This is NOT intended to be a</font>
<font color="black">1407.                      passed parameter.  It is present as a keyword argument to</font>
<font color="black">1408.                      maintain memory of the current line numbers between calls</font>
<font color="black">1409.                      of this function.</font>
<font color="black">1410. </font>
<font color="black">1411.         Note, this function is purposefully not defined at the module scope so</font>
<font color="black">1412.         that data it needs from its parent function (within whose context it</font>
<font color="black">1413.         is defined) does not need to be of module scope.</font>
<font color="black">1414.         &quot;&quot;&quot;</font>
<font color="red">1415.         num_lines[side] += 1</font>
<font color="black">1416.         # Handle case where no user markup is to be added, just return line of</font>
<font color="black">1417.         # text with user's line format to allow for usage of the line number.</font>
<font color="red">1418.         if format_key is None:</font>
<font color="red">1419.             return (num_lines[side],lines.pop(0)[2:])</font>
<font color="black">1420.         # Handle case of intraline changes</font>
<font color="red">1421.         if format_key == '?':</font>
<font color="red">1422.             text, markers = lines.pop(0), lines.pop(0)</font>
<font color="black">1423.             # find intraline changes (store change type and indices in tuples)</font>
<font color="red">1424.             sub_info = []</font>
<font color="red">1425.             def record_sub_info(match_object,sub_info=sub_info):</font>
<font color="red">1426.                 sub_info.append([match_object.group(1)[0],match_object.span()])</font>
<font color="red">1427.                 return match_object.group(1)</font>
<font color="red">1428.             change_re.sub(record_sub_info,markers)</font>
<font color="black">1429.             # process each tuple inserting our special marks that won't be</font>
<font color="black">1430.             # noticed by an xml/html escaper.</font>
<font color="red">1431.             for key,(begin,end) in sub_info[::-1]:</font>
<font color="red">1432.                 text = text[0:begin]+'\0'+key+text[begin:end]+'\1'+text[end:]</font>
<font color="red">1433.             text = text[2:]</font>
<font color="black">1434.         # Handle case of add/delete entire line</font>
<font color="black">1435.         else:</font>
<font color="red">1436.             text = lines.pop(0)[2:]</font>
<font color="black">1437.             # if line of text is just a newline, insert a space so there is</font>
<font color="black">1438.             # something for the user to highlight and see.</font>
<font color="red">1439.             if not text:</font>
<font color="red">1440.                 text = ' '</font>
<font color="black">1441.             # insert marks that won't be noticed by an xml/html escaper.</font>
<font color="red">1442.             text = '\0' + format_key + text + '\1'</font>
<font color="black">1443.         # Return line of text, first allow user's line formatter to do its</font>
<font color="black">1444.         # thing (such as adding the line number) then replace the special</font>
<font color="black">1445.         # marks with what the user's change markup.</font>
<font color="red">1446.         return (num_lines[side],text)</font>
<font color="black">1447. </font>
<font color="red">1448.     def _line_iterator():</font>
<font color="black">1449.         &quot;&quot;&quot;Yields from/to lines of text with a change indication.</font>
<font color="black">1450. </font>
<font color="black">1451.         This function is an iterator.  It itself pulls lines from a</font>
<font color="black">1452.         differencing iterator, processes them and yields them.  When it can</font>
<font color="black">1453.         it yields both a &quot;from&quot; and a &quot;to&quot; line, otherwise it will yield one</font>
<font color="black">1454.         or the other.  In addition to yielding the lines of from/to text, a</font>
<font color="black">1455.         boolean flag is yielded to indicate if the text line(s) have</font>
<font color="black">1456.         differences in them.</font>
<font color="black">1457. </font>
<font color="black">1458.         Note, this function is purposefully not defined at the module scope so</font>
<font color="black">1459.         that data it needs from its parent function (within whose context it</font>
<font color="black">1460.         is defined) does not need to be of module scope.</font>
<font color="black">1461.         &quot;&quot;&quot;</font>
<font color="red">1462.         lines = []</font>
<font color="red">1463.         num_blanks_pending, num_blanks_to_yield = 0, 0</font>
<font color="red">1464.         while True:</font>
<font color="black">1465.             # Load up next 4 lines so we can look ahead, create strings which</font>
<font color="black">1466.             # are a concatenation of the first character of each of the 4 lines</font>
<font color="black">1467.             # so we can do some very readable comparisons.</font>
<font color="red">1468.             while len(lines) &lt; 4:</font>
<font color="red">1469.                 try:</font>
<font color="red">1470.                     lines.append(diff_lines_iterator.next())</font>
<font color="red">1471.                 except StopIteration:</font>
<font color="red">1472.                     lines.append('X')</font>
<font color="red">1473.             s = ''.join([line[0] for line in lines])</font>
<font color="red">1474.             if s.startswith('X'):</font>
<font color="black">1475.                 # When no more lines, pump out any remaining blank lines so the</font>
<font color="black">1476.                 # corresponding add/delete lines get a matching blank line so</font>
<font color="black">1477.                 # all line pairs get yielded at the next level.</font>
<font color="red">1478.                 num_blanks_to_yield = num_blanks_pending</font>
<font color="red">1479.             elif s.startswith('-?+?'):</font>
<font color="black">1480.                 # simple intraline change</font>
<font color="red">1481.                 yield _make_line(lines,'?',0), _make_line(lines,'?',1), True</font>
<font color="red">1482.                 continue</font>
<font color="red">1483.             elif s.startswith('--++'):</font>
<font color="black">1484.                 # in delete block, add block coming: we do NOT want to get</font>
<font color="black">1485.                 # caught up on blank lines yet, just process the delete line</font>
<font color="red">1486.                 num_blanks_pending -= 1</font>
<font color="red">1487.                 yield _make_line(lines,'-',0), None, True</font>
<font color="red">1488.                 continue</font>
<font color="red">1489.             elif s.startswith(('--?+', '--+', '- ')):</font>
<font color="black">1490.                 # in delete block and see a intraline change or unchanged line</font>
<font color="black">1491.                 # coming: yield the delete line and then blanks</font>
<font color="red">1492.                 from_line,to_line = _make_line(lines,'-',0), None</font>
<font color="red">1493.                 num_blanks_to_yield,num_blanks_pending = num_blanks_pending-1,0</font>
<font color="red">1494.             elif s.startswith('-+?'):</font>
<font color="black">1495.                 # intraline change</font>
<font color="red">1496.                 yield _make_line(lines,None,0), _make_line(lines,'?',1), True</font>
<font color="red">1497.                 continue</font>
<font color="red">1498.             elif s.startswith('-?+'):</font>
<font color="black">1499.                 # intraline change</font>
<font color="red">1500.                 yield _make_line(lines,'?',0), _make_line(lines,None,1), True</font>
<font color="red">1501.                 continue</font>
<font color="red">1502.             elif s.startswith('-'):</font>
<font color="black">1503.                 # delete FROM line</font>
<font color="red">1504.                 num_blanks_pending -= 1</font>
<font color="red">1505.                 yield _make_line(lines,'-',0), None, True</font>
<font color="red">1506.                 continue</font>
<font color="red">1507.             elif s.startswith('+--'):</font>
<font color="black">1508.                 # in add block, delete block coming: we do NOT want to get</font>
<font color="black">1509.                 # caught up on blank lines yet, just process the add line</font>
<font color="red">1510.                 num_blanks_pending += 1</font>
<font color="red">1511.                 yield None, _make_line(lines,'+',1), True</font>
<font color="red">1512.                 continue</font>
<font color="red">1513.             elif s.startswith(('+ ', '+-')):</font>
<font color="black">1514.                 # will be leaving an add block: yield blanks then add line</font>
<font color="red">1515.                 from_line, to_line = None, _make_line(lines,'+',1)</font>
<font color="red">1516.                 num_blanks_to_yield,num_blanks_pending = num_blanks_pending+1,0</font>
<font color="red">1517.             elif s.startswith('+'):</font>
<font color="black">1518.                 # inside an add block, yield the add line</font>
<font color="red">1519.                 num_blanks_pending += 1</font>
<font color="red">1520.                 yield None, _make_line(lines,'+',1), True</font>
<font color="red">1521.                 continue</font>
<font color="red">1522.             elif s.startswith(' '):</font>
<font color="black">1523.                 # unchanged text, yield it to both sides</font>
<font color="red">1524.                 yield _make_line(lines[:],None,0),_make_line(lines,None,1),False</font>
<font color="red">1525.                 continue</font>
<font color="black">1526.             # Catch up on the blank lines so when we yield the next from/to</font>
<font color="black">1527.             # pair, they are lined up.</font>
<font color="red">1528.             while(num_blanks_to_yield &lt; 0):</font>
<font color="red">1529.                 num_blanks_to_yield += 1</font>
<font color="red">1530.                 yield None,('','\n'),True</font>
<font color="red">1531.             while(num_blanks_to_yield &gt; 0):</font>
<font color="red">1532.                 num_blanks_to_yield -= 1</font>
<font color="red">1533.                 yield ('','\n'),None,True</font>
<font color="red">1534.             if s.startswith('X'):</font>
<font color="red">1535.                 raise StopIteration</font>
<font color="black">1536.             else:</font>
<font color="red">1537.                 yield from_line,to_line,True</font>
<font color="black">1538. </font>
<font color="red">1539.     def _line_pair_iterator():</font>
<font color="black">1540.         &quot;&quot;&quot;Yields from/to lines of text with a change indication.</font>
<font color="black">1541. </font>
<font color="black">1542.         This function is an iterator.  It itself pulls lines from the line</font>
<font color="black">1543.         iterator.  Its difference from that iterator is that this function</font>
<font color="black">1544.         always yields a pair of from/to text lines (with the change</font>
<font color="black">1545.         indication).  If necessary it will collect single from/to lines</font>
<font color="black">1546.         until it has a matching pair from/to pair to yield.</font>
<font color="black">1547. </font>
<font color="black">1548.         Note, this function is purposefully not defined at the module scope so</font>
<font color="black">1549.         that data it needs from its parent function (within whose context it</font>
<font color="black">1550.         is defined) does not need to be of module scope.</font>
<font color="black">1551.         &quot;&quot;&quot;</font>
<font color="red">1552.         line_iterator = _line_iterator()</font>
<font color="red">1553.         fromlines,tolines=[],[]</font>
<font color="red">1554.         while True:</font>
<font color="black">1555.             # Collecting lines of text until we have a from/to pair</font>
<font color="red">1556.             while (len(fromlines)==0 or len(tolines)==0):</font>
<font color="red">1557.                 from_line, to_line, found_diff =line_iterator.next()</font>
<font color="red">1558.                 if from_line is not None:</font>
<font color="red">1559.                     fromlines.append((from_line,found_diff))</font>
<font color="red">1560.                 if to_line is not None:</font>
<font color="red">1561.                     tolines.append((to_line,found_diff))</font>
<font color="black">1562.             # Once we have a pair, remove them from the collection and yield it</font>
<font color="red">1563.             from_line, fromDiff = fromlines.pop(0)</font>
<font color="red">1564.             to_line, to_diff = tolines.pop(0)</font>
<font color="red">1565.             yield (from_line,to_line,fromDiff or to_diff)</font>
<font color="black">1566. </font>
<font color="black">1567.     # Handle case where user does not want context differencing, just yield</font>
<font color="black">1568.     # them up without doing anything else with them.</font>
<font color="red">1569.     line_pair_iterator = _line_pair_iterator()</font>
<font color="red">1570.     if context is None:</font>
<font color="red">1571.         while True:</font>
<font color="red">1572.             yield line_pair_iterator.next()</font>
<font color="black">1573.     # Handle case where user wants context differencing.  We must do some</font>
<font color="black">1574.     # storage of lines until we know for sure that they are to be yielded.</font>
<font color="black">1575.     else:</font>
<font color="red">1576.         context += 1</font>
<font color="red">1577.         lines_to_write = 0</font>
<font color="red">1578.         while True:</font>
<font color="black">1579.             # Store lines up until we find a difference, note use of a</font>
<font color="black">1580.             # circular queue because we only need to keep around what</font>
<font color="black">1581.             # we need for context.</font>
<font color="red">1582.             index, contextLines = 0, [None]*(context)</font>
<font color="red">1583.             found_diff = False</font>
<font color="red">1584.             while(found_diff is False):</font>
<font color="red">1585.                 from_line, to_line, found_diff = line_pair_iterator.next()</font>
<font color="red">1586.                 i = index % context</font>
<font color="red">1587.                 contextLines[i] = (from_line, to_line, found_diff)</font>
<font color="red">1588.                 index += 1</font>
<font color="black">1589.             # Yield lines that we have collected so far, but first yield</font>
<font color="black">1590.             # the user's separator.</font>
<font color="red">1591.             if index &gt; context:</font>
<font color="red">1592.                 yield None, None, None</font>
<font color="red">1593.                 lines_to_write = context</font>
<font color="black">1594.             else:</font>
<font color="red">1595.                 lines_to_write = index</font>
<font color="red">1596.                 index = 0</font>
<font color="red">1597.             while(lines_to_write):</font>
<font color="red">1598.                 i = index % context</font>
<font color="red">1599.                 index += 1</font>
<font color="red">1600.                 yield contextLines[i]</font>
<font color="red">1601.                 lines_to_write -= 1</font>
<font color="black">1602.             # Now yield the context lines after the change</font>
<font color="red">1603.             lines_to_write = context-1</font>
<font color="red">1604.             while(lines_to_write):</font>
<font color="red">1605.                 from_line, to_line, found_diff = line_pair_iterator.next()</font>
<font color="black">1606.                 # If another change within the context, extend the context</font>
<font color="red">1607.                 if found_diff:</font>
<font color="red">1608.                     lines_to_write = context-1</font>
<font color="black">1609.                 else:</font>
<font color="red">1610.                     lines_to_write -= 1</font>
<font color="red">1611.                 yield from_line, to_line, found_diff</font>
<font color="black">1612. </font>
<font color="black">1613. </font>
<font color="black">1614. _file_template = &quot;&quot;&quot;</font>
<font color="black">1615. &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</font>
<font color="black">1616.           &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</font>
<font color="black">1617. </font>
<font color="black">1618. &lt;html&gt;</font>
<font color="black">1619. </font>
<font color="black">1620. &lt;head&gt;</font>
<font color="black">1621.     &lt;meta http-equiv=&quot;Content-Type&quot;</font>
<font color="black">1622.           content=&quot;text/html; charset=ISO-8859-1&quot; /&gt;</font>
<font color="black">1623.     &lt;title&gt;&lt;/title&gt;</font>
<font color="black">1624.     &lt;style type=&quot;text/css&quot;&gt;%(styles)s</font>
<font color="black">1625.     &lt;/style&gt;</font>
<font color="black">1626. &lt;/head&gt;</font>
<font color="black">1627. </font>
<font color="black">1628. &lt;body&gt;</font>
<font color="black">1629.     %(table)s%(legend)s</font>
<font color="black">1630. &lt;/body&gt;</font>
<font color="black">1631. </font>
<font color="green">1632. &lt;/html&gt;&quot;&quot;&quot;</font>
<font color="black">1633. </font>
<font color="black">1634. _styles = &quot;&quot;&quot;</font>
<font color="black">1635.         table.diff {font-family:Courier; border:medium;}</font>
<font color="black">1636.         .diff_header {background-color:#e0e0e0}</font>
<font color="black">1637.         td.diff_header {text-align:right}</font>
<font color="black">1638.         .diff_next {background-color:#c0c0c0}</font>
<font color="black">1639.         .diff_add {background-color:#aaffaa}</font>
<font color="black">1640.         .diff_chg {background-color:#ffff77}</font>
<font color="green">1641.         .diff_sub {background-color:#ffaaaa}&quot;&quot;&quot;</font>
<font color="black">1642. </font>
<font color="black">1643. _table_template = &quot;&quot;&quot;</font>
<font color="black">1644.     &lt;table class=&quot;diff&quot; id=&quot;difflib_chg_%(prefix)s_top&quot;</font>
<font color="black">1645.            cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; rules=&quot;groups&quot; &gt;</font>
<font color="black">1646.         &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt;</font>
<font color="black">1647.         &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt;</font>
<font color="black">1648.         %(header_row)s</font>
<font color="black">1649.         &lt;tbody&gt;</font>
<font color="black">1650. %(data_rows)s        &lt;/tbody&gt;</font>
<font color="green">1651.     &lt;/table&gt;&quot;&quot;&quot;</font>
<font color="black">1652. </font>
<font color="black">1653. _legend = &quot;&quot;&quot;</font>
<font color="black">1654.     &lt;table class=&quot;diff&quot; summary=&quot;Legends&quot;&gt;</font>
<font color="black">1655.         &lt;tr&gt; &lt;th colspan=&quot;2&quot;&gt; Legends &lt;/th&gt; &lt;/tr&gt;</font>
<font color="black">1656.         &lt;tr&gt; &lt;td&gt; &lt;table border=&quot;&quot; summary=&quot;Colors&quot;&gt;</font>
<font color="black">1657.                       &lt;tr&gt;&lt;th&gt; Colors &lt;/th&gt; &lt;/tr&gt;</font>
<font color="black">1658.                       &lt;tr&gt;&lt;td class=&quot;diff_add&quot;&gt;&amp;nbsp;Added&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;</font>
<font color="black">1659.                       &lt;tr&gt;&lt;td class=&quot;diff_chg&quot;&gt;Changed&lt;/td&gt; &lt;/tr&gt;</font>
<font color="black">1660.                       &lt;tr&gt;&lt;td class=&quot;diff_sub&quot;&gt;Deleted&lt;/td&gt; &lt;/tr&gt;</font>
<font color="black">1661.                   &lt;/table&gt;&lt;/td&gt;</font>
<font color="black">1662.              &lt;td&gt; &lt;table border=&quot;&quot; summary=&quot;Links&quot;&gt;</font>
<font color="black">1663.                       &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt; Links &lt;/th&gt; &lt;/tr&gt;</font>
<font color="black">1664.                       &lt;tr&gt;&lt;td&gt;(f)irst change&lt;/td&gt; &lt;/tr&gt;</font>
<font color="black">1665.                       &lt;tr&gt;&lt;td&gt;(n)ext change&lt;/td&gt; &lt;/tr&gt;</font>
<font color="black">1666.                       &lt;tr&gt;&lt;td&gt;(t)op&lt;/td&gt; &lt;/tr&gt;</font>
<font color="black">1667.                   &lt;/table&gt;&lt;/td&gt; &lt;/tr&gt;</font>
<font color="green">1668.     &lt;/table&gt;&quot;&quot;&quot;</font>
<font color="black">1669. </font>
<font color="green">1670. class HtmlDiff(object):</font>
<font color="black">1671.     &quot;&quot;&quot;For producing HTML side by side comparison with change highlights.</font>
<font color="black">1672. </font>
<font color="black">1673.     This class can be used to create an HTML table (or a complete HTML file</font>
<font color="black">1674.     containing the table) showing a side by side, line by line comparison</font>
<font color="black">1675.     of text with inter-line and intra-line change highlights.  The table can</font>
<font color="black">1676.     be generated in either full or contextual difference mode.</font>
<font color="black">1677. </font>
<font color="black">1678.     The following methods are provided for HTML generation:</font>
<font color="black">1679. </font>
<font color="black">1680.     make_table -- generates HTML for a single side by side table</font>
<font color="black">1681.     make_file -- generates complete HTML file with a single side by side table</font>
<font color="black">1682. </font>
<font color="black">1683.     See tools/scripts/diff.py for an example usage of this class.</font>
<font color="green">1684.     &quot;&quot;&quot;</font>
<font color="black">1685. </font>
<font color="green">1686.     _file_template = _file_template</font>
<font color="green">1687.     _styles = _styles</font>
<font color="green">1688.     _table_template = _table_template</font>
<font color="green">1689.     _legend = _legend</font>
<font color="green">1690.     _default_prefix = 0</font>
<font color="black">1691. </font>
<font color="green">1692.     def __init__(self,tabsize=8,wrapcolumn=None,linejunk=None,</font>
<font color="green">1693.                  charjunk=IS_CHARACTER_JUNK):</font>
<font color="black">1694.         &quot;&quot;&quot;HtmlDiff instance initializer</font>
<font color="black">1695. </font>
<font color="black">1696.         Arguments:</font>
<font color="black">1697.         tabsize -- tab stop spacing, defaults to 8.</font>
<font color="black">1698.         wrapcolumn -- column number where lines are broken and wrapped,</font>
<font color="black">1699.             defaults to None where lines are not wrapped.</font>
<font color="black">1700.         linejunk,charjunk -- keyword arguments passed into ndiff() (used to by</font>
<font color="black">1701.             HtmlDiff() to generate the side by side HTML differences).  See</font>
<font color="black">1702.             ndiff() documentation for argument default values and descriptions.</font>
<font color="black">1703.         &quot;&quot;&quot;</font>
<font color="red">1704.         self._tabsize = tabsize</font>
<font color="red">1705.         self._wrapcolumn = wrapcolumn</font>
<font color="red">1706.         self._linejunk = linejunk</font>
<font color="red">1707.         self._charjunk = charjunk</font>
<font color="black">1708. </font>
<font color="green">1709.     def make_file(self,fromlines,tolines,fromdesc='',todesc='',context=False,</font>
<font color="green">1710.                   numlines=5):</font>
<font color="black">1711.         &quot;&quot;&quot;Returns HTML file of side by side comparison with change highlights</font>
<font color="black">1712. </font>
<font color="black">1713.         Arguments:</font>
<font color="black">1714.         fromlines -- list of &quot;from&quot; lines</font>
<font color="black">1715.         tolines -- list of &quot;to&quot; lines</font>
<font color="black">1716.         fromdesc -- &quot;from&quot; file column header string</font>
<font color="black">1717.         todesc -- &quot;to&quot; file column header string</font>
<font color="black">1718.         context -- set to True for contextual differences (defaults to False</font>
<font color="black">1719.             which shows full differences).</font>
<font color="black">1720.         numlines -- number of context lines.  When context is set True,</font>
<font color="black">1721.             controls number of lines displayed before and after the change.</font>
<font color="black">1722.             When context is False, controls the number of lines to place</font>
<font color="black">1723.             the &quot;next&quot; link anchors before the next change (so click of</font>
<font color="black">1724.             &quot;next&quot; link jumps to just before the change).</font>
<font color="black">1725.         &quot;&quot;&quot;</font>
<font color="black">1726. </font>
<font color="red">1727.         return self._file_template % dict(</font>
<font color="red">1728.             styles = self._styles,</font>
<font color="red">1729.             legend = self._legend,</font>
<font color="red">1730.             table = self.make_table(fromlines,tolines,fromdesc,todesc,</font>
<font color="red">1731.                                     context=context,numlines=numlines))</font>
<font color="black">1732. </font>
<font color="green">1733.     def _tab_newline_replace(self,fromlines,tolines):</font>
<font color="black">1734.         &quot;&quot;&quot;Returns from/to line lists with tabs expanded and newlines removed.</font>
<font color="black">1735. </font>
<font color="black">1736.         Instead of tab characters being replaced by the number of spaces</font>
<font color="black">1737.         needed to fill in to the next tab stop, this function will fill</font>
<font color="black">1738.         the space with tab characters.  This is done so that the difference</font>
<font color="black">1739.         algorithms can identify changes in a file when tabs are replaced by</font>
<font color="black">1740.         spaces and vice versa.  At the end of the HTML generation, the tab</font>
<font color="black">1741.         characters will be replaced with a nonbreakable space.</font>
<font color="black">1742.         &quot;&quot;&quot;</font>
<font color="red">1743.         def expand_tabs(line):</font>
<font color="black">1744.             # hide real spaces</font>
<font color="red">1745.             line = line.replace(' ','\0')</font>
<font color="black">1746.             # expand tabs into spaces</font>
<font color="red">1747.             line = line.expandtabs(self._tabsize)</font>
<font color="black">1748.             # replace spaces from expanded tabs back into tab characters</font>
<font color="black">1749.             # (we'll replace them with markup after we do differencing)</font>
<font color="red">1750.             line = line.replace(' ','\t')</font>
<font color="red">1751.             return line.replace('\0',' ').rstrip('\n')</font>
<font color="red">1752.         fromlines = [expand_tabs(line) for line in fromlines]</font>
<font color="red">1753.         tolines = [expand_tabs(line) for line in tolines]</font>
<font color="red">1754.         return fromlines,tolines</font>
<font color="black">1755. </font>
<font color="green">1756.     def _split_line(self,data_list,line_num,text):</font>
<font color="black">1757.         &quot;&quot;&quot;Builds list of text lines by splitting text lines at wrap point</font>
<font color="black">1758. </font>
<font color="black">1759.         This function will determine if the input text line needs to be</font>
<font color="black">1760.         wrapped (split) into separate lines.  If so, the first wrap point</font>
<font color="black">1761.         will be determined and the first line appended to the output</font>
<font color="black">1762.         text line list.  This function is used recursively to handle</font>
<font color="black">1763.         the second part of the split line to further split it.</font>
<font color="black">1764.         &quot;&quot;&quot;</font>
<font color="black">1765.         # if blank line or context separator, just add it to the output list</font>
<font color="red">1766.         if not line_num:</font>
<font color="red">1767.             data_list.append((line_num,text))</font>
<font color="red">1768.             return</font>
<font color="black">1769. </font>
<font color="black">1770.         # if line text doesn't need wrapping, just add it to the output list</font>
<font color="red">1771.         size = len(text)</font>
<font color="red">1772.         max = self._wrapcolumn</font>
<font color="red">1773.         if (size &lt;= max) or ((size -(text.count('\0')*3)) &lt;= max):</font>
<font color="red">1774.             data_list.append((line_num,text))</font>
<font color="red">1775.             return</font>
<font color="black">1776. </font>
<font color="black">1777.         # scan text looking for the wrap point, keeping track if the wrap</font>
<font color="black">1778.         # point is inside markers</font>
<font color="red">1779.         i = 0</font>
<font color="red">1780.         n = 0</font>
<font color="red">1781.         mark = ''</font>
<font color="red">1782.         while n &lt; max and i &lt; size:</font>
<font color="red">1783.             if text[i] == '\0':</font>
<font color="red">1784.                 i += 1</font>
<font color="red">1785.                 mark = text[i]</font>
<font color="red">1786.                 i += 1</font>
<font color="red">1787.             elif text[i] == '\1':</font>
<font color="red">1788.                 i += 1</font>
<font color="red">1789.                 mark = ''</font>
<font color="black">1790.             else:</font>
<font color="red">1791.                 i += 1</font>
<font color="red">1792.                 n += 1</font>
<font color="black">1793. </font>
<font color="black">1794.         # wrap point is inside text, break it up into separate lines</font>
<font color="red">1795.         line1 = text[:i]</font>
<font color="red">1796.         line2 = text[i:]</font>
<font color="black">1797. </font>
<font color="black">1798.         # if wrap point is inside markers, place end marker at end of first</font>
<font color="black">1799.         # line and start marker at beginning of second line because each</font>
<font color="black">1800.         # line will have its own table tag markup around it.</font>
<font color="red">1801.         if mark:</font>
<font color="red">1802.             line1 = line1 + '\1'</font>
<font color="red">1803.             line2 = '\0' + mark + line2</font>
<font color="black">1804. </font>
<font color="black">1805.         # tack on first line onto the output list</font>
<font color="red">1806.         data_list.append((line_num,line1))</font>
<font color="black">1807. </font>
<font color="black">1808.         # use this routine again to wrap the remaining text</font>
<font color="red">1809.         self._split_line(data_list,'&gt;',line2)</font>
<font color="black">1810. </font>
<font color="green">1811.     def _line_wrapper(self,diffs):</font>
<font color="black">1812.         &quot;&quot;&quot;Returns iterator that splits (wraps) mdiff text lines&quot;&quot;&quot;</font>
<font color="black">1813. </font>
<font color="black">1814.         # pull from/to data and flags from mdiff iterator</font>
<font color="red">1815.         for fromdata,todata,flag in diffs:</font>
<font color="black">1816.             # check for context separators and pass them through</font>
<font color="red">1817.             if flag is None:</font>
<font color="red">1818.                 yield fromdata,todata,flag</font>
<font color="red">1819.                 continue</font>
<font color="red">1820.             (fromline,fromtext),(toline,totext) = fromdata,todata</font>
<font color="black">1821.             # for each from/to line split it at the wrap column to form</font>
<font color="black">1822.             # list of text lines.</font>
<font color="red">1823.             fromlist,tolist = [],[]</font>
<font color="red">1824.             self._split_line(fromlist,fromline,fromtext)</font>
<font color="red">1825.             self._split_line(tolist,toline,totext)</font>
<font color="black">1826.             # yield from/to line in pairs inserting blank lines as</font>
<font color="black">1827.             # necessary when one side has more wrapped lines</font>
<font color="red">1828.             while fromlist or tolist:</font>
<font color="red">1829.                 if fromlist:</font>
<font color="red">1830.                     fromdata = fromlist.pop(0)</font>
<font color="black">1831.                 else:</font>
<font color="red">1832.                     fromdata = ('',' ')</font>
<font color="red">1833.                 if tolist:</font>
<font color="red">1834.                     todata = tolist.pop(0)</font>
<font color="black">1835.                 else:</font>
<font color="red">1836.                     todata = ('',' ')</font>
<font color="red">1837.                 yield fromdata,todata,flag</font>
<font color="black">1838. </font>
<font color="green">1839.     def _collect_lines(self,diffs):</font>
<font color="black">1840.         &quot;&quot;&quot;Collects mdiff output into separate lists</font>
<font color="black">1841. </font>
<font color="black">1842.         Before storing the mdiff from/to data into a list, it is converted</font>
<font color="black">1843.         into a single line of text with HTML markup.</font>
<font color="black">1844.         &quot;&quot;&quot;</font>
<font color="black">1845. </font>
<font color="red">1846.         fromlist,tolist,flaglist = [],[],[]</font>
<font color="black">1847.         # pull from/to data and flags from mdiff style iterator</font>
<font color="red">1848.         for fromdata,todata,flag in diffs:</font>
<font color="red">1849.             try:</font>
<font color="black">1850.                 # store HTML markup of the lines into the lists</font>
<font color="red">1851.                 fromlist.append(self._format_line(0,flag,*fromdata))</font>
<font color="red">1852.                 tolist.append(self._format_line(1,flag,*todata))</font>
<font color="red">1853.             except TypeError:</font>
<font color="black">1854.                 # exceptions occur for lines where context separators go</font>
<font color="red">1855.                 fromlist.append(None)</font>
<font color="red">1856.                 tolist.append(None)</font>
<font color="red">1857.             flaglist.append(flag)</font>
<font color="red">1858.         return fromlist,tolist,flaglist</font>
<font color="black">1859. </font>
<font color="green">1860.     def _format_line(self,side,flag,linenum,text):</font>
<font color="black">1861.         &quot;&quot;&quot;Returns HTML markup of &quot;from&quot; / &quot;to&quot; text lines</font>
<font color="black">1862. </font>
<font color="black">1863.         side -- 0 or 1 indicating &quot;from&quot; or &quot;to&quot; text</font>
<font color="black">1864.         flag -- indicates if difference on line</font>
<font color="black">1865.         linenum -- line number (used for line number column)</font>
<font color="black">1866.         text -- line text to be marked up</font>
<font color="black">1867.         &quot;&quot;&quot;</font>
<font color="red">1868.         try:</font>
<font color="red">1869.             linenum = '%d' % linenum</font>
<font color="red">1870.             id = ' id=&quot;%s%s&quot;' % (self._prefix[side],linenum)</font>
<font color="red">1871.         except TypeError:</font>
<font color="black">1872.             # handle blank lines where linenum is '&gt;' or ''</font>
<font color="red">1873.             id = ''</font>
<font color="black">1874.         # replace those things that would get confused with HTML symbols</font>
<font color="red">1875.         text=text.replace(&quot;&amp;&quot;,&quot;&amp;amp;&quot;).replace(&quot;&gt;&quot;,&quot;&amp;gt;&quot;).replace(&quot;&lt;&quot;,&quot;&amp;lt;&quot;)</font>
<font color="black">1876. </font>
<font color="black">1877.         # make space non-breakable so they don't get compressed or line wrapped</font>
<font color="red">1878.         text = text.replace(' ','&amp;nbsp;').rstrip()</font>
<font color="black">1879. </font>
<font color="red">1880.         return '&lt;td class=&quot;diff_header&quot;%s&gt;%s&lt;/td&gt;&lt;td nowrap=&quot;nowrap&quot;&gt;%s&lt;/td&gt;' \</font>
<font color="red">1881.                % (id,linenum,text)</font>
<font color="black">1882. </font>
<font color="green">1883.     def _make_prefix(self):</font>
<font color="black">1884.         &quot;&quot;&quot;Create unique anchor prefixes&quot;&quot;&quot;</font>
<font color="black">1885. </font>
<font color="black">1886.         # Generate a unique anchor prefix so multiple tables</font>
<font color="black">1887.         # can exist on the same HTML page without conflicts.</font>
<font color="red">1888.         fromprefix = &quot;from%d_&quot; % HtmlDiff._default_prefix</font>
<font color="red">1889.         toprefix = &quot;to%d_&quot; % HtmlDiff._default_prefix</font>
<font color="red">1890.         HtmlDiff._default_prefix += 1</font>
<font color="black">1891.         # store prefixes so line format method has access</font>
<font color="red">1892.         self._prefix = [fromprefix,toprefix]</font>
<font color="black">1893. </font>
<font color="green">1894.     def _convert_flags(self,fromlist,tolist,flaglist,context,numlines):</font>
<font color="black">1895.         &quot;&quot;&quot;Makes list of &quot;next&quot; links&quot;&quot;&quot;</font>
<font color="black">1896. </font>
<font color="black">1897.         # all anchor names will be generated using the unique &quot;to&quot; prefix</font>
<font color="red">1898.         toprefix = self._prefix[1]</font>
<font color="black">1899. </font>
<font color="black">1900.         # process change flags, generating middle column of next anchors/links</font>
<font color="red">1901.         next_id = ['']*len(flaglist)</font>
<font color="red">1902.         next_href = ['']*len(flaglist)</font>
<font color="red">1903.         num_chg, in_change = 0, False</font>
<font color="red">1904.         last = 0</font>
<font color="red">1905.         for i,flag in enumerate(flaglist):</font>
<font color="red">1906.             if flag:</font>
<font color="red">1907.                 if not in_change:</font>
<font color="red">1908.                     in_change = True</font>
<font color="red">1909.                     last = i</font>
<font color="black">1910.                     # at the beginning of a change, drop an anchor a few lines</font>
<font color="black">1911.                     # (the context lines) before the change for the previous</font>
<font color="black">1912.                     # link</font>
<font color="red">1913.                     i = max([0,i-numlines])</font>
<font color="red">1914.                     next_id[i] = ' id=&quot;difflib_chg_%s_%d&quot;' % (toprefix,num_chg)</font>
<font color="black">1915.                     # at the beginning of a change, drop a link to the next</font>
<font color="black">1916.                     # change</font>
<font color="red">1917.                     num_chg += 1</font>
<font color="red">1918.                     next_href[last] = '&lt;a href=&quot;#difflib_chg_%s_%d&quot;&gt;n&lt;/a&gt;' % (</font>
<font color="red">1919.                          toprefix,num_chg)</font>
<font color="black">1920.             else:</font>
<font color="red">1921.                 in_change = False</font>
<font color="black">1922.         # check for cases where there is no content to avoid exceptions</font>
<font color="red">1923.         if not flaglist:</font>
<font color="red">1924.             flaglist = [False]</font>
<font color="red">1925.             next_id = ['']</font>
<font color="red">1926.             next_href = ['']</font>
<font color="red">1927.             last = 0</font>
<font color="red">1928.             if context:</font>
<font color="red">1929.                 fromlist = ['&lt;td&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;No Differences Found&amp;nbsp;&lt;/td&gt;']</font>
<font color="red">1930.                 tolist = fromlist</font>
<font color="black">1931.             else:</font>
<font color="red">1932.                 fromlist = tolist = ['&lt;td&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;Empty File&amp;nbsp;&lt;/td&gt;']</font>
<font color="black">1933.         # if not a change on first line, drop a link</font>
<font color="red">1934.         if not flaglist[0]:</font>
<font color="red">1935.             next_href[0] = '&lt;a href=&quot;#difflib_chg_%s_0&quot;&gt;f&lt;/a&gt;' % toprefix</font>
<font color="black">1936.         # redo the last link to link to the top</font>
<font color="red">1937.         next_href[last] = '&lt;a href=&quot;#difflib_chg_%s_top&quot;&gt;t&lt;/a&gt;' % (toprefix)</font>
<font color="black">1938. </font>
<font color="red">1939.         return fromlist,tolist,flaglist,next_href,next_id</font>
<font color="black">1940. </font>
<font color="green">1941.     def make_table(self,fromlines,tolines,fromdesc='',todesc='',context=False,</font>
<font color="green">1942.                    numlines=5):</font>
<font color="black">1943.         &quot;&quot;&quot;Returns HTML table of side by side comparison with change highlights</font>
<font color="black">1944. </font>
<font color="black">1945.         Arguments:</font>
<font color="black">1946.         fromlines -- list of &quot;from&quot; lines</font>
<font color="black">1947.         tolines -- list of &quot;to&quot; lines</font>
<font color="black">1948.         fromdesc -- &quot;from&quot; file column header string</font>
<font color="black">1949.         todesc -- &quot;to&quot; file column header string</font>
<font color="black">1950.         context -- set to True for contextual differences (defaults to False</font>
<font color="black">1951.             which shows full differences).</font>
<font color="black">1952.         numlines -- number of context lines.  When context is set True,</font>
<font color="black">1953.             controls number of lines displayed before and after the change.</font>
<font color="black">1954.             When context is False, controls the number of lines to place</font>
<font color="black">1955.             the &quot;next&quot; link anchors before the next change (so click of</font>
<font color="black">1956.             &quot;next&quot; link jumps to just before the change).</font>
<font color="black">1957.         &quot;&quot;&quot;</font>
<font color="black">1958. </font>
<font color="black">1959.         # make unique anchor prefixes so that multiple tables may exist</font>
<font color="black">1960.         # on the same page without conflict.</font>
<font color="red">1961.         self._make_prefix()</font>
<font color="black">1962. </font>
<font color="black">1963.         # change tabs to spaces before it gets more difficult after we insert</font>
<font color="black">1964.         # markup</font>
<font color="red">1965.         fromlines,tolines = self._tab_newline_replace(fromlines,tolines)</font>
<font color="black">1966. </font>
<font color="black">1967.         # create diffs iterator which generates side by side from/to data</font>
<font color="red">1968.         if context:</font>
<font color="red">1969.             context_lines = numlines</font>
<font color="black">1970.         else:</font>
<font color="red">1971.             context_lines = None</font>
<font color="red">1972.         diffs = _mdiff(fromlines,tolines,context_lines,linejunk=self._linejunk,</font>
<font color="red">1973.                       charjunk=self._charjunk)</font>
<font color="black">1974. </font>
<font color="black">1975.         # set up iterator to wrap lines that exceed desired width</font>
<font color="red">1976.         if self._wrapcolumn:</font>
<font color="red">1977.             diffs = self._line_wrapper(diffs)</font>
<font color="black">1978. </font>
<font color="black">1979.         # collect up from/to lines and flags into lists (also format the lines)</font>
<font color="red">1980.         fromlist,tolist,flaglist = self._collect_lines(diffs)</font>
<font color="black">1981. </font>
<font color="black">1982.         # process change flags, generating middle column of next anchors/links</font>
<font color="red">1983.         fromlist,tolist,flaglist,next_href,next_id = self._convert_flags(</font>
<font color="red">1984.             fromlist,tolist,flaglist,context,numlines)</font>
<font color="black">1985. </font>
<font color="red">1986.         s = []</font>
<font color="red">1987.         fmt = '            &lt;tr&gt;&lt;td class=&quot;diff_next&quot;%s&gt;%s&lt;/td&gt;%s' + \</font>
<font color="red">1988.               '&lt;td class=&quot;diff_next&quot;&gt;%s&lt;/td&gt;%s&lt;/tr&gt;\n'</font>
<font color="red">1989.         for i in range(len(flaglist)):</font>
<font color="red">1990.             if flaglist[i] is None:</font>
<font color="black">1991.                 # mdiff yields None on separator lines skip the bogus ones</font>
<font color="black">1992.                 # generated for the first line</font>
<font color="red">1993.                 if i &gt; 0:</font>
<font color="red">1994.                     s.append('        &lt;/tbody&gt;        \n        &lt;tbody&gt;\n')</font>
<font color="black">1995.             else:</font>
<font color="red">1996.                 s.append( fmt % (next_id[i],next_href[i],fromlist[i],</font>
<font color="red">1997.                                            next_href[i],tolist[i]))</font>
<font color="red">1998.         if fromdesc or todesc:</font>
<font color="red">1999.             header_row = '&lt;thead&gt;&lt;tr&gt;%s%s%s%s&lt;/tr&gt;&lt;/thead&gt;' % (</font>
<font color="red">2000.                 '&lt;th class=&quot;diff_next&quot;&gt;&lt;br /&gt;&lt;/th&gt;',</font>
<font color="red">2001.                 '&lt;th colspan=&quot;2&quot; class=&quot;diff_header&quot;&gt;%s&lt;/th&gt;' % fromdesc,</font>
<font color="red">2002.                 '&lt;th class=&quot;diff_next&quot;&gt;&lt;br /&gt;&lt;/th&gt;',</font>
<font color="red">2003.                 '&lt;th colspan=&quot;2&quot; class=&quot;diff_header&quot;&gt;%s&lt;/th&gt;' % todesc)</font>
<font color="black">2004.         else:</font>
<font color="red">2005.             header_row = ''</font>
<font color="black">2006. </font>
<font color="red">2007.         table = self._table_template % dict(</font>
<font color="red">2008.             data_rows=''.join(s),</font>
<font color="red">2009.             header_row=header_row,</font>
<font color="red">2010.             prefix=self._prefix[1])</font>
<font color="black">2011. </font>
<font color="red">2012.         return table.replace('\0+','&lt;span class=&quot;diff_add&quot;&gt;'). \</font>
<font color="red">2013.                      replace('\0-','&lt;span class=&quot;diff_sub&quot;&gt;'). \</font>
<font color="red">2014.                      replace('\0^','&lt;span class=&quot;diff_chg&quot;&gt;'). \</font>
<font color="red">2015.                      replace('\1','&lt;/span&gt;'). \</font>
<font color="red">2016.                      replace('\t','&amp;nbsp;')</font>
<font color="black">2017. </font>
<font color="green">2018. del re</font>
<font color="black">2019. </font>
<font color="green">2020. def restore(delta, which):</font>
<font color="black">2021.     r&quot;&quot;&quot;</font>
<font color="black">2022.     Generate one of the two sequences that generated a delta.</font>
<font color="black">2023. </font>
<font color="black">2024.     Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract</font>
<font color="black">2025.     lines originating from file 1 or 2 (parameter `which`), stripping off line</font>
<font color="black">2026.     prefixes.</font>
<font color="black">2027. </font>
<font color="black">2028.     Examples:</font>
<font color="black">2029. </font>
<font color="black">2030.     &gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(1),</font>
<font color="black">2031.     ...              'ore\ntree\nemu\n'.splitlines(1))</font>
<font color="black">2032.     &gt;&gt;&gt; diff = list(diff)</font>
<font color="black">2033.     &gt;&gt;&gt; print ''.join(restore(diff, 1)),</font>
<font color="black">2034.     one</font>
<font color="black">2035.     two</font>
<font color="black">2036.     three</font>
<font color="black">2037.     &gt;&gt;&gt; print ''.join(restore(diff, 2)),</font>
<font color="black">2038.     ore</font>
<font color="black">2039.     tree</font>
<font color="black">2040.     emu</font>
<font color="black">2041.     &quot;&quot;&quot;</font>
<font color="red">2042.     try:</font>
<font color="red">2043.         tag = {1: &quot;- &quot;, 2: &quot;+ &quot;}[int(which)]</font>
<font color="red">2044.     except KeyError:</font>
<font color="red">2045.         raise ValueError, ('unknown delta choice (must be 1 or 2): %r'</font>
<font color="red">2046.                            % which)</font>
<font color="red">2047.     prefixes = (&quot;  &quot;, tag)</font>
<font color="red">2048.     for line in delta:</font>
<font color="red">2049.         if line[:2] in prefixes:</font>
<font color="red">2050.             yield line[2:]</font>
<font color="black">2051. </font>
<font color="green">2052. def _test():</font>
<font color="red">2053.     import doctest, difflib</font>
<font color="red">2054.     return doctest.testmod(difflib)</font>
<font color="black">2055. </font>
<font color="green">2056. if __name__ == &quot;__main__&quot;:</font>
<font color="red">2057.     _test()</font>
</pre>

