source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/sql/subqueries.py</b><br>


file stats: <b>121 lines, 40 executed: 33.1% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Query subclasses which provide extra functionality beyond simple data retrieval.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. from django.core.exceptions import FieldError</font>
<font color="green">   6. from django.db import connections</font>
<font color="green">   7. from django.db.models.query_utils import Q</font>
<font color="green">   8. from django.db.models.sql.constants import (</font>
<font color="black">   9.     CURSOR, GET_ITERATOR_CHUNK_SIZE, NO_RESULTS,</font>
<font color="black">  10. )</font>
<font color="green">  11. from django.db.models.sql.query import Query</font>
<font color="green">  12. from django.utils import six</font>
<font color="black">  13. </font>
<font color="green">  14. __all__ = ['DeleteQuery', 'UpdateQuery', 'InsertQuery', 'AggregateQuery']</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. class DeleteQuery(Query):</font>
<font color="black">  18.     &quot;&quot;&quot;</font>
<font color="black">  19.     Delete queries are done through this class, since they are more constrained</font>
<font color="black">  20.     than general queries.</font>
<font color="green">  21.     &quot;&quot;&quot;</font>
<font color="black">  22. </font>
<font color="green">  23.     compiler = 'SQLDeleteCompiler'</font>
<font color="black">  24. </font>
<font color="green">  25.     def do_query(self, table, where, using):</font>
<font color="red">  26.         self.tables = [table]</font>
<font color="red">  27.         self.where = where</font>
<font color="red">  28.         cursor = self.get_compiler(using).execute_sql(CURSOR)</font>
<font color="red">  29.         return cursor.rowcount if cursor else 0</font>
<font color="black">  30. </font>
<font color="green">  31.     def delete_batch(self, pk_list, using, field=None):</font>
<font color="black">  32.         &quot;&quot;&quot;</font>
<font color="black">  33.         Set up and execute delete queries for all the objects in pk_list.</font>
<font color="black">  34. </font>
<font color="black">  35.         More than one physical query may be executed if there are a</font>
<font color="black">  36.         lot of values in pk_list.</font>
<font color="black">  37.         &quot;&quot;&quot;</font>
<font color="black">  38.         # number of objects deleted</font>
<font color="red">  39.         num_deleted = 0</font>
<font color="red">  40.         if not field:</font>
<font color="red">  41.             field = self.get_meta().pk</font>
<font color="red">  42.         for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE):</font>
<font color="red">  43.             self.where = self.where_class()</font>
<font color="red">  44.             self.add_q(Q(</font>
<font color="red">  45.                 **{field.attname + '__in': pk_list[offset:offset + GET_ITERATOR_CHUNK_SIZE]}))</font>
<font color="red">  46.             num_deleted += self.do_query(self.get_meta().db_table, self.where, using=using)</font>
<font color="red">  47.         return num_deleted</font>
<font color="black">  48. </font>
<font color="green">  49.     def delete_qs(self, query, using):</font>
<font color="black">  50.         &quot;&quot;&quot;</font>
<font color="black">  51.         Delete the queryset in one SQL query (if possible). For simple queries</font>
<font color="black">  52.         this is done by copying the query.query.where to self.query, for</font>
<font color="black">  53.         complex queries by using subquery.</font>
<font color="black">  54.         &quot;&quot;&quot;</font>
<font color="red">  55.         innerq = query.query</font>
<font color="black">  56.         # Make sure the inner query has at least one table in use.</font>
<font color="red">  57.         innerq.get_initial_alias()</font>
<font color="black">  58.         # The same for our new query.</font>
<font color="red">  59.         self.get_initial_alias()</font>
<font color="red">  60.         innerq_used_tables = [t for t in innerq.tables</font>
<font color="red">  61.                               if innerq.alias_refcount[t]]</font>
<font color="red">  62.         if not innerq_used_tables or innerq_used_tables == self.tables:</font>
<font color="black">  63.             # There is only the base table in use in the query.</font>
<font color="red">  64.             self.where = innerq.where</font>
<font color="black">  65.         else:</font>
<font color="red">  66.             pk = query.model._meta.pk</font>
<font color="red">  67.             if not connections[using].features.update_can_self_select:</font>
<font color="black">  68.                 # We can't do the delete using subquery.</font>
<font color="red">  69.                 values = list(query.values_list('pk', flat=True))</font>
<font color="red">  70.                 if not values:</font>
<font color="red">  71.                     return</font>
<font color="red">  72.                 return self.delete_batch(values, using)</font>
<font color="black">  73.             else:</font>
<font color="red">  74.                 innerq.clear_select_clause()</font>
<font color="black">  75.                 innerq.select = [</font>
<font color="red">  76.                     pk.get_col(self.get_initial_alias())</font>
<font color="black">  77.                 ]</font>
<font color="red">  78.                 values = innerq</font>
<font color="red">  79.             self.where = self.where_class()</font>
<font color="red">  80.             self.add_q(Q(pk__in=values))</font>
<font color="red">  81.         cursor = self.get_compiler(using).execute_sql(CURSOR)</font>
<font color="red">  82.         return cursor.rowcount if cursor else 0</font>
<font color="black">  83. </font>
<font color="black">  84. </font>
<font color="green">  85. class UpdateQuery(Query):</font>
<font color="black">  86.     &quot;&quot;&quot;</font>
<font color="black">  87.     Represents an &quot;update&quot; SQL query.</font>
<font color="green">  88.     &quot;&quot;&quot;</font>
<font color="black">  89. </font>
<font color="green">  90.     compiler = 'SQLUpdateCompiler'</font>
<font color="black">  91. </font>
<font color="green">  92.     def __init__(self, *args, **kwargs):</font>
<font color="red">  93.         super(UpdateQuery, self).__init__(*args, **kwargs)</font>
<font color="red">  94.         self._setup_query()</font>
<font color="black">  95. </font>
<font color="green">  96.     def _setup_query(self):</font>
<font color="black">  97.         &quot;&quot;&quot;</font>
<font color="black">  98.         Runs on initialization and after cloning. Any attributes that would</font>
<font color="black">  99.         normally be set in __init__ should go in here, instead, so that they</font>
<font color="black"> 100.         are also set up after a clone() call.</font>
<font color="black"> 101.         &quot;&quot;&quot;</font>
<font color="red"> 102.         self.values = []</font>
<font color="red"> 103.         self.related_ids = None</font>
<font color="red"> 104.         if not hasattr(self, 'related_updates'):</font>
<font color="red"> 105.             self.related_updates = {}</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def clone(self, klass=None, **kwargs):</font>
<font color="red"> 108.         return super(UpdateQuery, self).clone(klass,</font>
<font color="red"> 109.                 related_updates=self.related_updates.copy(), **kwargs)</font>
<font color="black"> 110. </font>
<font color="green"> 111.     def update_batch(self, pk_list, values, using):</font>
<font color="red"> 112.         self.add_update_values(values)</font>
<font color="red"> 113.         for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE):</font>
<font color="red"> 114.             self.where = self.where_class()</font>
<font color="red"> 115.             self.add_q(Q(pk__in=pk_list[offset: offset + GET_ITERATOR_CHUNK_SIZE]))</font>
<font color="red"> 116.             self.get_compiler(using).execute_sql(NO_RESULTS)</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def add_update_values(self, values):</font>
<font color="black"> 119.         &quot;&quot;&quot;</font>
<font color="black"> 120.         Convert a dictionary of field name to value mappings into an update</font>
<font color="black"> 121.         query. This is the entry point for the public update() method on</font>
<font color="black"> 122.         querysets.</font>
<font color="black"> 123.         &quot;&quot;&quot;</font>
<font color="red"> 124.         values_seq = []</font>
<font color="red"> 125.         for name, val in six.iteritems(values):</font>
<font color="red"> 126.             field = self.get_meta().get_field(name)</font>
<font color="red"> 127.             direct = not (field.auto_created and not field.concrete) or not field.concrete</font>
<font color="red"> 128.             model = field.model._meta.concrete_model</font>
<font color="red"> 129.             if not direct or (field.is_relation and field.many_to_many):</font>
<font color="red"> 130.                 raise FieldError(</font>
<font color="red"> 131.                     'Cannot update model field %r (only non-relations and '</font>
<font color="red"> 132.                     'foreign keys permitted).' % field</font>
<font color="black"> 133.                 )</font>
<font color="red"> 134.             if model is not self.get_meta().model:</font>
<font color="red"> 135.                 self.add_related_update(model, field, val)</font>
<font color="red"> 136.                 continue</font>
<font color="red"> 137.             values_seq.append((field, model, val))</font>
<font color="red"> 138.         return self.add_update_fields(values_seq)</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def add_update_fields(self, values_seq):</font>
<font color="black"> 141.         &quot;&quot;&quot;</font>
<font color="black"> 142.         Append a sequence of (field, model, value) triples to the internal list</font>
<font color="black"> 143.         that will be used to generate the UPDATE query. Might be more usefully</font>
<font color="black"> 144.         called add_update_targets() to hint at the extra information here.</font>
<font color="black"> 145.         &quot;&quot;&quot;</font>
<font color="red"> 146.         self.values.extend(values_seq)</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def add_related_update(self, model, field, value):</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="black"> 150.         Adds (name, value) to an update query for an ancestor model.</font>
<font color="black"> 151. </font>
<font color="black"> 152.         Updates are coalesced so that we only run one update query per ancestor.</font>
<font color="black"> 153.         &quot;&quot;&quot;</font>
<font color="red"> 154.         self.related_updates.setdefault(model, []).append((field, None, value))</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def get_related_updates(self):</font>
<font color="black"> 157.         &quot;&quot;&quot;</font>
<font color="black"> 158.         Returns a list of query objects: one for each update required to an</font>
<font color="black"> 159.         ancestor model. Each query will have the same filtering conditions as</font>
<font color="black"> 160.         the current query but will only update a single table.</font>
<font color="black"> 161.         &quot;&quot;&quot;</font>
<font color="red"> 162.         if not self.related_updates:</font>
<font color="red"> 163.             return []</font>
<font color="red"> 164.         result = []</font>
<font color="red"> 165.         for model, values in six.iteritems(self.related_updates):</font>
<font color="red"> 166.             query = UpdateQuery(model)</font>
<font color="red"> 167.             query.values = values</font>
<font color="red"> 168.             if self.related_ids is not None:</font>
<font color="red"> 169.                 query.add_filter(('pk__in', self.related_ids))</font>
<font color="red"> 170.             result.append(query)</font>
<font color="red"> 171.         return result</font>
<font color="black"> 172. </font>
<font color="black"> 173. </font>
<font color="green"> 174. class InsertQuery(Query):</font>
<font color="green"> 175.     compiler = 'SQLInsertCompiler'</font>
<font color="black"> 176. </font>
<font color="green"> 177.     def __init__(self, *args, **kwargs):</font>
<font color="green"> 178.         super(InsertQuery, self).__init__(*args, **kwargs)</font>
<font color="green"> 179.         self.fields = []</font>
<font color="green"> 180.         self.objs = []</font>
<font color="black"> 181. </font>
<font color="green"> 182.     def clone(self, klass=None, **kwargs):</font>
<font color="red"> 183.         extras = {</font>
<font color="red"> 184.             'fields': self.fields[:],</font>
<font color="red"> 185.             'objs': self.objs[:],</font>
<font color="red"> 186.             'raw': self.raw,</font>
<font color="black"> 187.         }</font>
<font color="red"> 188.         extras.update(kwargs)</font>
<font color="red"> 189.         return super(InsertQuery, self).clone(klass, **extras)</font>
<font color="black"> 190. </font>
<font color="green"> 191.     def insert_values(self, fields, objs, raw=False):</font>
<font color="black"> 192.         &quot;&quot;&quot;</font>
<font color="black"> 193.         Set up the insert query from the 'insert_values' dictionary. The</font>
<font color="black"> 194.         dictionary gives the model field names and their target values.</font>
<font color="black"> 195. </font>
<font color="black"> 196.         If 'raw_values' is True, the values in the 'insert_values' dictionary</font>
<font color="black"> 197.         are inserted directly into the query, rather than passed as SQL</font>
<font color="black"> 198.         parameters. This provides a way to insert NULL and DEFAULT keywords</font>
<font color="black"> 199.         into the query, for example.</font>
<font color="black"> 200.         &quot;&quot;&quot;</font>
<font color="green"> 201.         self.fields = fields</font>
<font color="green"> 202.         self.objs = objs</font>
<font color="green"> 203.         self.raw = raw</font>
<font color="black"> 204. </font>
<font color="black"> 205. </font>
<font color="green"> 206. class AggregateQuery(Query):</font>
<font color="black"> 207.     &quot;&quot;&quot;</font>
<font color="black"> 208.     An AggregateQuery takes another query as a parameter to the FROM</font>
<font color="black"> 209.     clause and only selects the elements in the provided list.</font>
<font color="green"> 210.     &quot;&quot;&quot;</font>
<font color="black"> 211. </font>
<font color="green"> 212.     compiler = 'SQLAggregateCompiler'</font>
<font color="black"> 213. </font>
<font color="green"> 214.     def add_subquery(self, query, using):</font>
<font color="red"> 215.         self.subquery, self.sub_params = query.get_compiler(using).as_sql(</font>
<font color="red"> 216.             with_col_aliases=True,</font>
<font color="red"> 217.             subquery=True,</font>
<font color="black"> 218.         )</font>
</pre>

