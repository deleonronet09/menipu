source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/query_utils.py</b><br>


file stats: <b>201 lines, 68 executed: 33.8% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Various data structures used in query construction.</font>
<font color="black">   3. </font>
<font color="black">   4. Factored out from django.db.models.query to avoid making the main module very</font>
<font color="black">   5. large and/or so that they can be used by other modules without getting into</font>
<font color="black">   6. circular import difficulties.</font>
<font color="green">   7. &quot;&quot;&quot;</font>
<font color="green">   8. from __future__ import unicode_literals</font>
<font color="black">   9. </font>
<font color="green">  10. import inspect</font>
<font color="green">  11. from collections import namedtuple</font>
<font color="black">  12. </font>
<font color="green">  13. from django.core.exceptions import FieldDoesNotExist</font>
<font color="green">  14. from django.db.backends import utils</font>
<font color="green">  15. from django.db.models.constants import LOOKUP_SEP</font>
<font color="green">  16. from django.utils import tree</font>
<font color="black">  17. </font>
<font color="black">  18. # PathInfo is used when converting lookups (fk__somecol). The contents</font>
<font color="black">  19. # describe the relation in Model terms (model Options and Fields for both</font>
<font color="black">  20. # sides of the relation. The join_field is the field backing the relation.</font>
<font color="green">  21. PathInfo = namedtuple('PathInfo', 'from_opts to_opts target_fields join_field m2m direct')</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="green">  24. class InvalidQuery(Exception):</font>
<font color="black">  25.     &quot;&quot;&quot;</font>
<font color="black">  26.     The query passed to raw isn't a safe query to use with raw.</font>
<font color="green">  27.     &quot;&quot;&quot;</font>
<font color="green">  28.     pass</font>
<font color="black">  29. </font>
<font color="black">  30. </font>
<font color="green">  31. class QueryWrapper(object):</font>
<font color="black">  32.     &quot;&quot;&quot;</font>
<font color="black">  33.     A type that indicates the contents are an SQL fragment and the associate</font>
<font color="black">  34.     parameters. Can be used to pass opaque data to a where-clause, for example.</font>
<font color="green">  35.     &quot;&quot;&quot;</font>
<font color="green">  36.     contains_aggregate = False</font>
<font color="black">  37. </font>
<font color="green">  38.     def __init__(self, sql, params):</font>
<font color="red">  39.         self.data = sql, list(params)</font>
<font color="black">  40. </font>
<font color="green">  41.     def as_sql(self, compiler=None, connection=None):</font>
<font color="red">  42.         return self.data</font>
<font color="black">  43. </font>
<font color="black">  44. </font>
<font color="green">  45. class Q(tree.Node):</font>
<font color="black">  46.     &quot;&quot;&quot;</font>
<font color="black">  47.     Encapsulates filters as objects that can then be combined logically (using</font>
<font color="black">  48.     &amp; and |).</font>
<font color="green">  49.     &quot;&quot;&quot;</font>
<font color="black">  50.     # Connection types</font>
<font color="green">  51.     AND = 'AND'</font>
<font color="green">  52.     OR = 'OR'</font>
<font color="green">  53.     default = AND</font>
<font color="black">  54. </font>
<font color="green">  55.     def __init__(self, *args, **kwargs):</font>
<font color="green">  56.         super(Q, self).__init__(children=list(args) + list(kwargs.items()))</font>
<font color="black">  57. </font>
<font color="green">  58.     def _combine(self, other, conn):</font>
<font color="red">  59.         if not isinstance(other, Q):</font>
<font color="red">  60.             raise TypeError(other)</font>
<font color="red">  61.         obj = type(self)()</font>
<font color="red">  62.         obj.connector = conn</font>
<font color="red">  63.         obj.add(self, conn)</font>
<font color="red">  64.         obj.add(other, conn)</font>
<font color="red">  65.         return obj</font>
<font color="black">  66. </font>
<font color="green">  67.     def __or__(self, other):</font>
<font color="red">  68.         return self._combine(other, self.OR)</font>
<font color="black">  69. </font>
<font color="green">  70.     def __and__(self, other):</font>
<font color="red">  71.         return self._combine(other, self.AND)</font>
<font color="black">  72. </font>
<font color="green">  73.     def __invert__(self):</font>
<font color="red">  74.         obj = type(self)()</font>
<font color="red">  75.         obj.add(self, self.AND)</font>
<font color="red">  76.         obj.negate()</font>
<font color="red">  77.         return obj</font>
<font color="black">  78. </font>
<font color="green">  79.     def clone(self):</font>
<font color="red">  80.         clone = self.__class__._new_instance(</font>
<font color="red">  81.             children=[], connector=self.connector, negated=self.negated)</font>
<font color="red">  82.         for child in self.children:</font>
<font color="red">  83.             if hasattr(child, 'clone'):</font>
<font color="red">  84.                 clone.children.append(child.clone())</font>
<font color="black">  85.             else:</font>
<font color="red">  86.                 clone.children.append(child)</font>
<font color="red">  87.         return clone</font>
<font color="black">  88. </font>
<font color="green">  89.     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):</font>
<font color="black">  90.         # We must promote any new joins to left outer joins so that when Q is</font>
<font color="black">  91.         # used as an expression, rows aren't filtered due to joins.</font>
<font color="red">  92.         clause, joins = query._add_q(self, reuse, allow_joins=allow_joins, split_subq=False)</font>
<font color="red">  93.         query.promote_joins(joins)</font>
<font color="red">  94.         return clause</font>
<font color="black">  95. </font>
<font color="green">  96.     @classmethod</font>
<font color="black">  97.     def _refs_aggregate(cls, obj, existing_aggregates):</font>
<font color="red">  98.         if not isinstance(obj, tree.Node):</font>
<font color="red">  99.             aggregate, aggregate_lookups = refs_aggregate(obj[0].split(LOOKUP_SEP), existing_aggregates)</font>
<font color="red"> 100.             if not aggregate and hasattr(obj[1], 'refs_aggregate'):</font>
<font color="red"> 101.                 return obj[1].refs_aggregate(existing_aggregates)</font>
<font color="red"> 102.             return aggregate, aggregate_lookups</font>
<font color="red"> 103.         for c in obj.children:</font>
<font color="red"> 104.             aggregate, aggregate_lookups = cls._refs_aggregate(c, existing_aggregates)</font>
<font color="red"> 105.             if aggregate:</font>
<font color="red"> 106.                 return aggregate, aggregate_lookups</font>
<font color="red"> 107.         return False, ()</font>
<font color="black"> 108. </font>
<font color="green"> 109.     def refs_aggregate(self, existing_aggregates):</font>
<font color="red"> 110.         if not existing_aggregates:</font>
<font color="red"> 111.             return False</font>
<font color="black"> 112. </font>
<font color="red"> 113.         return self._refs_aggregate(self, existing_aggregates)</font>
<font color="black"> 114. </font>
<font color="black"> 115. </font>
<font color="green"> 116. class DeferredAttribute(object):</font>
<font color="black"> 117.     &quot;&quot;&quot;</font>
<font color="black"> 118.     A wrapper for a deferred-loading field. When the value is read from this</font>
<font color="black"> 119.     object the first time, the query is executed.</font>
<font color="green"> 120.     &quot;&quot;&quot;</font>
<font color="green"> 121.     def __init__(self, field_name, model):</font>
<font color="red"> 122.         self.field_name = field_name</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def __get__(self, instance, owner):</font>
<font color="black"> 125.         &quot;&quot;&quot;</font>
<font color="black"> 126.         Retrieves and caches the value from the datastore on the first lookup.</font>
<font color="black"> 127.         Returns the cached value.</font>
<font color="black"> 128.         &quot;&quot;&quot;</font>
<font color="red"> 129.         non_deferred_model = instance._meta.proxy_for_model</font>
<font color="red"> 130.         opts = non_deferred_model._meta</font>
<font color="black"> 131. </font>
<font color="red"> 132.         assert instance is not None</font>
<font color="red"> 133.         data = instance.__dict__</font>
<font color="red"> 134.         if data.get(self.field_name, self) is self:</font>
<font color="black"> 135.             # self.field_name is the attname of the field, but only() takes the</font>
<font color="black"> 136.             # actual name, so we need to translate it here.</font>
<font color="red"> 137.             try:</font>
<font color="red"> 138.                 f = opts.get_field(self.field_name)</font>
<font color="red"> 139.             except FieldDoesNotExist:</font>
<font color="red"> 140.                 f = [f for f in opts.fields if f.attname == self.field_name][0]</font>
<font color="red"> 141.             name = f.name</font>
<font color="black"> 142.             # Let's see if the field is part of the parent chain. If so we</font>
<font color="black"> 143.             # might be able to reuse the already loaded value. Refs #18343.</font>
<font color="red"> 144.             val = self._check_parent_chain(instance, name)</font>
<font color="red"> 145.             if val is None:</font>
<font color="red"> 146.                 instance.refresh_from_db(fields=[self.field_name])</font>
<font color="red"> 147.                 val = getattr(instance, self.field_name)</font>
<font color="red"> 148.             data[self.field_name] = val</font>
<font color="red"> 149.         return data[self.field_name]</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def __set__(self, instance, value):</font>
<font color="black"> 152.         &quot;&quot;&quot;</font>
<font color="black"> 153.         Deferred loading attributes can be set normally (which means there will</font>
<font color="black"> 154.         never be a database lookup involved.</font>
<font color="black"> 155.         &quot;&quot;&quot;</font>
<font color="red"> 156.         instance.__dict__[self.field_name] = value</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def _check_parent_chain(self, instance, name):</font>
<font color="black"> 159.         &quot;&quot;&quot;</font>
<font color="black"> 160.         Check if the field value can be fetched from a parent field already</font>
<font color="black"> 161.         loaded in the instance. This can be done if the to-be fetched</font>
<font color="black"> 162.         field is a primary key field.</font>
<font color="black"> 163.         &quot;&quot;&quot;</font>
<font color="red"> 164.         opts = instance._meta</font>
<font color="red"> 165.         f = opts.get_field(name)</font>
<font color="red"> 166.         link_field = opts.get_ancestor_link(f.model)</font>
<font color="red"> 167.         if f.primary_key and f != link_field:</font>
<font color="red"> 168.             return getattr(instance, link_field.attname)</font>
<font color="red"> 169.         return None</font>
<font color="black"> 170. </font>
<font color="black"> 171. </font>
<font color="green"> 172. class RegisterLookupMixin(object):</font>
<font color="green"> 173.     def _get_lookup(self, lookup_name):</font>
<font color="green"> 174.         try:</font>
<font color="green"> 175.             return self.class_lookups[lookup_name]</font>
<font color="red"> 176.         except KeyError:</font>
<font color="black"> 177.             # To allow for inheritance, check parent class' class_lookups.</font>
<font color="red"> 178.             for parent in inspect.getmro(self.__class__):</font>
<font color="red"> 179.                 if 'class_lookups' not in parent.__dict__:</font>
<font color="red"> 180.                     continue</font>
<font color="red"> 181.                 if lookup_name in parent.class_lookups:</font>
<font color="red"> 182.                     return parent.class_lookups[lookup_name]</font>
<font color="red"> 183.         except AttributeError:</font>
<font color="black"> 184.             # This class didn't have any class_lookups</font>
<font color="red"> 185.             pass</font>
<font color="red"> 186.         return None</font>
<font color="black"> 187. </font>
<font color="green"> 188.     def get_lookup(self, lookup_name):</font>
<font color="green"> 189.         from django.db.models.lookups import Lookup</font>
<font color="green"> 190.         found = self._get_lookup(lookup_name)</font>
<font color="green"> 191.         if found is None and hasattr(self, 'output_field'):</font>
<font color="red"> 192.             return self.output_field.get_lookup(lookup_name)</font>
<font color="green"> 193.         if found is not None and not issubclass(found, Lookup):</font>
<font color="red"> 194.             return None</font>
<font color="green"> 195.         return found</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def get_transform(self, lookup_name):</font>
<font color="red"> 198.         from django.db.models.lookups import Transform</font>
<font color="red"> 199.         found = self._get_lookup(lookup_name)</font>
<font color="red"> 200.         if found is None and hasattr(self, 'output_field'):</font>
<font color="red"> 201.             return self.output_field.get_transform(lookup_name)</font>
<font color="red"> 202.         if found is not None and not issubclass(found, Transform):</font>
<font color="red"> 203.             return None</font>
<font color="red"> 204.         return found</font>
<font color="black"> 205. </font>
<font color="green"> 206.     @classmethod</font>
<font color="green"> 207.     def register_lookup(cls, lookup, lookup_name=None):</font>
<font color="green"> 208.         if lookup_name is None:</font>
<font color="green"> 209.             lookup_name = lookup.lookup_name</font>
<font color="green"> 210.         if 'class_lookups' not in cls.__dict__:</font>
<font color="green"> 211.             cls.class_lookups = {}</font>
<font color="green"> 212.         cls.class_lookups[lookup_name] = lookup</font>
<font color="green"> 213.         return lookup</font>
<font color="black"> 214. </font>
<font color="green"> 215.     @classmethod</font>
<font color="green"> 216.     def _unregister_lookup(cls, lookup, lookup_name=None):</font>
<font color="black"> 217.         &quot;&quot;&quot;</font>
<font color="black"> 218.         Remove given lookup from cls lookups. For use in tests only as it's</font>
<font color="black"> 219.         not thread-safe.</font>
<font color="black"> 220.         &quot;&quot;&quot;</font>
<font color="red"> 221.         if lookup_name is None:</font>
<font color="red"> 222.             lookup_name = lookup.lookup_name</font>
<font color="red"> 223.         del cls.class_lookups[lookup_name]</font>
<font color="black"> 224. </font>
<font color="black"> 225. </font>
<font color="green"> 226. def select_related_descend(field, restricted, requested, load_fields, reverse=False):</font>
<font color="black"> 227.     &quot;&quot;&quot;</font>
<font color="black"> 228.     Returns True if this field should be used to descend deeper for</font>
<font color="black"> 229.     select_related() purposes. Used by both the query construction code</font>
<font color="black"> 230.     (sql.query.fill_related_selections()) and the model instance creation code</font>
<font color="black"> 231.     (query.get_klass_info()).</font>
<font color="black"> 232. </font>
<font color="black"> 233.     Arguments:</font>
<font color="black"> 234.      * field - the field to be checked</font>
<font color="black"> 235.      * restricted - a boolean field, indicating if the field list has been</font>
<font color="black"> 236.        manually restricted using a requested clause)</font>
<font color="black"> 237.      * requested - The select_related() dictionary.</font>
<font color="black"> 238.      * load_fields - the set of fields to be loaded on this model</font>
<font color="black"> 239.      * reverse - boolean, True if we are checking a reverse select related</font>
<font color="black"> 240.     &quot;&quot;&quot;</font>
<font color="red"> 241.     if not field.remote_field:</font>
<font color="red"> 242.         return False</font>
<font color="red"> 243.     if field.remote_field.parent_link and not reverse:</font>
<font color="red"> 244.         return False</font>
<font color="red"> 245.     if restricted:</font>
<font color="red"> 246.         if reverse and field.related_query_name() not in requested:</font>
<font color="red"> 247.             return False</font>
<font color="red"> 248.         if not reverse and field.name not in requested:</font>
<font color="red"> 249.             return False</font>
<font color="red"> 250.     if not restricted and field.null:</font>
<font color="red"> 251.         return False</font>
<font color="red"> 252.     if load_fields:</font>
<font color="red"> 253.         if field.attname not in load_fields:</font>
<font color="red"> 254.             if restricted and field.name in requested:</font>
<font color="red"> 255.                 raise InvalidQuery(&quot;Field %s.%s cannot be both deferred&quot;</font>
<font color="black"> 256.                                    &quot; and traversed using select_related&quot;</font>
<font color="black"> 257.                                    &quot; at the same time.&quot; %</font>
<font color="red"> 258.                                    (field.model._meta.object_name, field.name))</font>
<font color="red"> 259.             return False</font>
<font color="red"> 260.     return True</font>
<font color="black"> 261. </font>
<font color="black"> 262. </font>
<font color="black"> 263. # This function is needed because data descriptors must be defined on a class</font>
<font color="black"> 264. # object, not an instance, to have any effect.</font>
<font color="black"> 265. </font>
<font color="green"> 266. def deferred_class_factory(model, attrs):</font>
<font color="black"> 267.     &quot;&quot;&quot;</font>
<font color="black"> 268.     Returns a class object that is a copy of &quot;model&quot; with the specified &quot;attrs&quot;</font>
<font color="black"> 269.     being replaced with DeferredAttribute objects. The &quot;pk_value&quot; ties the</font>
<font color="black"> 270.     deferred attributes to a particular instance of the model.</font>
<font color="black"> 271.     &quot;&quot;&quot;</font>
<font color="red"> 272.     if not attrs:</font>
<font color="red"> 273.         return model</font>
<font color="red"> 274.     opts = model._meta</font>
<font color="black"> 275.     # Never create deferred models based on deferred model</font>
<font color="red"> 276.     if model._deferred:</font>
<font color="black"> 277.         # Deferred models are proxies for the non-deferred model. We never</font>
<font color="black"> 278.         # create chains of defers =&gt; proxy_for_model is the non-deferred</font>
<font color="black"> 279.         # model.</font>
<font color="red"> 280.         model = opts.proxy_for_model</font>
<font color="black"> 281.     # The app registry wants a unique name for each model, otherwise the new</font>
<font color="black"> 282.     # class won't be created (we get an exception). Therefore, we generate</font>
<font color="black"> 283.     # the name using the passed in attrs. It's OK to reuse an existing class</font>
<font color="black"> 284.     # object if the attrs are identical.</font>
<font color="red"> 285.     name = &quot;%s_Deferred_%s&quot; % (model.__name__, '_'.join(sorted(attrs)))</font>
<font color="red"> 286.     name = utils.truncate_name(name, 80, 32)</font>
<font color="black"> 287. </font>
<font color="red"> 288.     try:</font>
<font color="red"> 289.         return opts.apps.get_model(model._meta.app_label, name)</font>
<font color="black"> 290. </font>
<font color="red"> 291.     except LookupError:</font>
<font color="black"> 292. </font>
<font color="red"> 293.         class Meta:</font>
<font color="red"> 294.             proxy = True</font>
<font color="red"> 295.             apps = opts.apps</font>
<font color="red"> 296.             app_label = opts.app_label</font>
<font color="black"> 297. </font>
<font color="red"> 298.         overrides = {attr: DeferredAttribute(attr, model) for attr in attrs}</font>
<font color="red"> 299.         overrides[&quot;Meta&quot;] = Meta</font>
<font color="red"> 300.         overrides[&quot;__module__&quot;] = model.__module__</font>
<font color="red"> 301.         overrides[&quot;_deferred&quot;] = True</font>
<font color="red"> 302.         return type(str(name), (model,), overrides)</font>
<font color="black"> 303. </font>
<font color="black"> 304. </font>
<font color="black"> 305. # The above function is also used to unpickle model instances with deferred</font>
<font color="black"> 306. # fields.</font>
<font color="green"> 307. deferred_class_factory.__safe_for_unpickling__ = True</font>
<font color="black"> 308. </font>
<font color="black"> 309. </font>
<font color="green"> 310. def refs_aggregate(lookup_parts, aggregates):</font>
<font color="black"> 311.     &quot;&quot;&quot;</font>
<font color="black"> 312.     A helper method to check if the lookup_parts contains references</font>
<font color="black"> 313.     to the given aggregates set. Because the LOOKUP_SEP is contained in the</font>
<font color="black"> 314.     default annotation names we must check each prefix of the lookup_parts</font>
<font color="black"> 315.     for a match.</font>
<font color="black"> 316.     &quot;&quot;&quot;</font>
<font color="red"> 317.     for n in range(len(lookup_parts) + 1):</font>
<font color="red"> 318.         level_n_lookup = LOOKUP_SEP.join(lookup_parts[0:n])</font>
<font color="red"> 319.         if level_n_lookup in aggregates and aggregates[level_n_lookup].contains_aggregate:</font>
<font color="red"> 320.             return aggregates[level_n_lookup], lookup_parts[n:]</font>
<font color="red"> 321.     return False, ()</font>
<font color="black"> 322. </font>
<font color="black"> 323. </font>
<font color="green"> 324. def refs_expression(lookup_parts, annotations):</font>
<font color="black"> 325.     &quot;&quot;&quot;</font>
<font color="black"> 326.     A helper method to check if the lookup_parts contains references</font>
<font color="black"> 327.     to the given annotations set. Because the LOOKUP_SEP is contained in the</font>
<font color="black"> 328.     default annotation names we must check each prefix of the lookup_parts</font>
<font color="black"> 329.     for a match.</font>
<font color="black"> 330.     &quot;&quot;&quot;</font>
<font color="red"> 331.     for n in range(len(lookup_parts) + 1):</font>
<font color="red"> 332.         level_n_lookup = LOOKUP_SEP.join(lookup_parts[0:n])</font>
<font color="red"> 333.         if level_n_lookup in annotations and annotations[level_n_lookup]:</font>
<font color="red"> 334.             return annotations[level_n_lookup], lookup_parts[n:]</font>
<font color="red"> 335.     return False, ()</font>
<font color="black"> 336. </font>
<font color="black"> 337. </font>
<font color="green"> 338. def check_rel_lookup_compatibility(model, target_opts, field):</font>
<font color="black"> 339.     &quot;&quot;&quot;</font>
<font color="black"> 340.     Check that self.model is compatible with target_opts. Compatibility</font>
<font color="black"> 341.     is OK if:</font>
<font color="black"> 342.       1) model and opts match (where proxy inheritance is removed)</font>
<font color="black"> 343.       2) model is parent of opts' model or the other way around</font>
<font color="black"> 344.     &quot;&quot;&quot;</font>
<font color="green"> 345.     def check(opts):</font>
<font color="black"> 346.         return (</font>
<font color="green"> 347.             model._meta.concrete_model == opts.concrete_model or</font>
<font color="red"> 348.             opts.concrete_model in model._meta.get_parent_list() or</font>
<font color="red"> 349.             model in opts.get_parent_list()</font>
<font color="black"> 350.         )</font>
<font color="black"> 351.     # If the field is a primary key, then doing a query against the field's</font>
<font color="black"> 352.     # model is ok, too. Consider the case:</font>
<font color="black"> 353.     # class Restaurant(models.Model):</font>
<font color="black"> 354.     #     place = OnetoOneField(Place, primary_key=True):</font>
<font color="black"> 355.     # Restaurant.objects.filter(pk__in=Restaurant.objects.all()).</font>
<font color="black"> 356.     # If we didn't have the primary key check, then pk__in (== place__in) would</font>
<font color="black"> 357.     # give Place's opts as the target opts, but Restaurant isn't compatible</font>
<font color="black"> 358.     # with that. This logic applies only to primary keys, as when doing __in=qs,</font>
<font color="black"> 359.     # we are going to turn this into __in=qs.values('pk') later on.</font>
<font color="black"> 360.     return (</font>
<font color="green"> 361.         check(target_opts) or</font>
<font color="red"> 362.         (getattr(field, 'primary_key', False) and check(field.model._meta))</font>
<font color="black"> 363.     )</font>
</pre>

