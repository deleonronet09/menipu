source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/decorators.py</b><br>


file stats: <b>107 lines, 53 executed: 49.5% covered</b>
<pre>
<font color="green">   1. &quot;Functions that help with dynamically creating decorators for views.&quot;</font>
<font color="black">   2. </font>
<font color="green">   3. try:</font>
<font color="green">   4.     from contextlib import ContextDecorator</font>
<font color="green">   5. except ImportError:</font>
<font color="green">   6.     ContextDecorator = None</font>
<font color="black">   7. </font>
<font color="green">   8. from functools import WRAPPER_ASSIGNMENTS, update_wrapper, wraps</font>
<font color="black">   9. </font>
<font color="green">  10. from django.utils import six</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class classonlymethod(classmethod):</font>
<font color="green">  14.     def __get__(self, instance, owner):</font>
<font color="red">  15.         if instance is not None:</font>
<font color="red">  16.             raise AttributeError(&quot;This method is available only on the class, not on instances.&quot;)</font>
<font color="red">  17.         return super(classonlymethod, self).__get__(instance, owner)</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. def method_decorator(decorator, name=''):</font>
<font color="black">  21.     &quot;&quot;&quot;</font>
<font color="black">  22.     Converts a function decorator into a method decorator</font>
<font color="black">  23.     &quot;&quot;&quot;</font>
<font color="black">  24.     # 'obj' can be a class or a function. If 'obj' is a function at the time it</font>
<font color="black">  25.     # is passed to _dec,  it will eventually be a method of the class it is</font>
<font color="black">  26.     # defined on. If 'obj' is a class, the 'name' is required to be the name</font>
<font color="black">  27.     # of the method that will be decorated.</font>
<font color="green">  28.     def _dec(obj):</font>
<font color="green">  29.         is_class = isinstance(obj, type)</font>
<font color="green">  30.         if is_class:</font>
<font color="red">  31.             if name and hasattr(obj, name):</font>
<font color="red">  32.                 func = getattr(obj, name)</font>
<font color="red">  33.                 if not callable(func):</font>
<font color="red">  34.                     raise TypeError(</font>
<font color="red">  35.                         &quot;Cannot decorate '{0}' as it isn't a callable &quot;</font>
<font color="red">  36.                         &quot;attribute of {1} ({2})&quot;.format(name, obj, func)</font>
<font color="black">  37.                     )</font>
<font color="black">  38.             else:</font>
<font color="red">  39.                 raise ValueError(</font>
<font color="red">  40.                     &quot;The keyword argument `name` must be the name of a method &quot;</font>
<font color="black">  41.                     &quot;of the decorated class: {0}. Got '{1}' instead&quot;.format(</font>
<font color="red">  42.                         obj, name,</font>
<font color="black">  43.                     )</font>
<font color="black">  44.                 )</font>
<font color="black">  45.         else:</font>
<font color="green">  46.             func = obj</font>
<font color="black">  47. </font>
<font color="green">  48.         def decorate(function):</font>
<font color="black">  49.             &quot;&quot;&quot;</font>
<font color="black">  50.             Apply a list/tuple of decorators if decorator is one. Decorator</font>
<font color="black">  51.             functions are applied so that the call order is the same as the</font>
<font color="black">  52.             order in which they appear in the iterable.</font>
<font color="black">  53.             &quot;&quot;&quot;</font>
<font color="green">  54.             if hasattr(decorator, '__iter__'):</font>
<font color="red">  55.                 for dec in decorator[::-1]:</font>
<font color="red">  56.                     function = dec(function)</font>
<font color="red">  57.                 return function</font>
<font color="green">  58.             return decorator(function)</font>
<font color="black">  59. </font>
<font color="green">  60.         def _wrapper(self, *args, **kwargs):</font>
<font color="red">  61.             @decorate</font>
<font color="black">  62.             def bound_func(*args2, **kwargs2):</font>
<font color="red">  63.                 return func.__get__(self, type(self))(*args2, **kwargs2)</font>
<font color="black">  64.             # bound_func has the signature that 'decorator' expects i.e.  no</font>
<font color="black">  65.             # 'self' argument, but it is a closure over self so it can call</font>
<font color="black">  66.             # 'func' correctly.</font>
<font color="red">  67.             return bound_func(*args, **kwargs)</font>
<font color="black">  68.         # In case 'decorator' adds attributes to the function it decorates, we</font>
<font color="black">  69.         # want to copy those. We don't have access to bound_func in this scope,</font>
<font color="black">  70.         # but we can cheat by using it on a dummy function.</font>
<font color="black">  71. </font>
<font color="green">  72.         @decorate</font>
<font color="black">  73.         def dummy(*args, **kwargs):</font>
<font color="red">  74.             pass</font>
<font color="green">  75.         update_wrapper(_wrapper, dummy)</font>
<font color="black">  76.         # Need to preserve any existing attributes of 'func', including the name.</font>
<font color="green">  77.         update_wrapper(_wrapper, func)</font>
<font color="black">  78. </font>
<font color="green">  79.         if is_class:</font>
<font color="red">  80.             setattr(obj, name, _wrapper)</font>
<font color="red">  81.             return obj</font>
<font color="black">  82. </font>
<font color="green">  83.         return _wrapper</font>
<font color="black">  84.     # Don't worry about making _dec look similar to a list/tuple as it's rather</font>
<font color="black">  85.     # meaningless.</font>
<font color="green">  86.     if not hasattr(decorator, '__iter__'):</font>
<font color="green">  87.         update_wrapper(_dec, decorator, assigned=available_attrs(decorator))</font>
<font color="black">  88.     # Change the name to aid debugging.</font>
<font color="green">  89.     if hasattr(decorator, '__name__'):</font>
<font color="green">  90.         _dec.__name__ = 'method_decorator(%s)' % decorator.__name__</font>
<font color="black">  91.     else:</font>
<font color="red">  92.         _dec.__name__ = 'method_decorator(%s)' % decorator.__class__.__name__</font>
<font color="green">  93.     return _dec</font>
<font color="black">  94. </font>
<font color="black">  95. </font>
<font color="green">  96. def decorator_from_middleware_with_args(middleware_class):</font>
<font color="black">  97.     &quot;&quot;&quot;</font>
<font color="black">  98.     Like decorator_from_middleware, but returns a function</font>
<font color="black">  99.     that accepts the arguments to be passed to the middleware_class.</font>
<font color="black"> 100.     Use like::</font>
<font color="black"> 101. </font>
<font color="black"> 102.          cache_page = decorator_from_middleware_with_args(CacheMiddleware)</font>
<font color="black"> 103.          # ...</font>
<font color="black"> 104. </font>
<font color="black"> 105.          @cache_page(3600)</font>
<font color="black"> 106.          def my_view(request):</font>
<font color="black"> 107.              # ...</font>
<font color="black"> 108.     &quot;&quot;&quot;</font>
<font color="red"> 109.     return make_middleware_decorator(middleware_class)</font>
<font color="black"> 110. </font>
<font color="black"> 111. </font>
<font color="green"> 112. def decorator_from_middleware(middleware_class):</font>
<font color="black"> 113.     &quot;&quot;&quot;</font>
<font color="black"> 114.     Given a middleware class (not an instance), returns a view decorator. This</font>
<font color="black"> 115.     lets you use middleware functionality on a per-view basis. The middleware</font>
<font color="black"> 116.     is created with no params passed.</font>
<font color="black"> 117.     &quot;&quot;&quot;</font>
<font color="green"> 118.     return make_middleware_decorator(middleware_class)()</font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="green"> 121. def available_attrs(fn):</font>
<font color="black"> 122.     &quot;&quot;&quot;</font>
<font color="black"> 123.     Return the list of functools-wrappable attributes on a callable.</font>
<font color="black"> 124.     This is required as a workaround for http://bugs.python.org/issue3445</font>
<font color="black"> 125.     under Python 2.</font>
<font color="black"> 126.     &quot;&quot;&quot;</font>
<font color="green"> 127.     if six.PY3:</font>
<font color="red"> 128.         return WRAPPER_ASSIGNMENTS</font>
<font color="black"> 129.     else:</font>
<font color="green"> 130.         return tuple(a for a in WRAPPER_ASSIGNMENTS if hasattr(fn, a))</font>
<font color="black"> 131. </font>
<font color="black"> 132. </font>
<font color="green"> 133. def make_middleware_decorator(middleware_class):</font>
<font color="green"> 134.     def _make_decorator(*m_args, **m_kwargs):</font>
<font color="green"> 135.         middleware = middleware_class(*m_args, **m_kwargs)</font>
<font color="black"> 136. </font>
<font color="green"> 137.         def _decorator(view_func):</font>
<font color="green"> 138.             @wraps(view_func, assigned=available_attrs(view_func))</font>
<font color="black"> 139.             def _wrapped_view(request, *args, **kwargs):</font>
<font color="red"> 140.                 if hasattr(middleware, 'process_request'):</font>
<font color="red"> 141.                     result = middleware.process_request(request)</font>
<font color="red"> 142.                     if result is not None:</font>
<font color="red"> 143.                         return result</font>
<font color="red"> 144.                 if hasattr(middleware, 'process_view'):</font>
<font color="red"> 145.                     result = middleware.process_view(request, view_func, args, kwargs)</font>
<font color="red"> 146.                     if result is not None:</font>
<font color="red"> 147.                         return result</font>
<font color="red"> 148.                 try:</font>
<font color="red"> 149.                     response = view_func(request, *args, **kwargs)</font>
<font color="red"> 150.                 except Exception as e:</font>
<font color="red"> 151.                     if hasattr(middleware, 'process_exception'):</font>
<font color="red"> 152.                         result = middleware.process_exception(request, e)</font>
<font color="red"> 153.                         if result is not None:</font>
<font color="red"> 154.                             return result</font>
<font color="red"> 155.                     raise</font>
<font color="red"> 156.                 if hasattr(response, 'render') and callable(response.render):</font>
<font color="red"> 157.                     if hasattr(middleware, 'process_template_response'):</font>
<font color="red"> 158.                         response = middleware.process_template_response(request, response)</font>
<font color="black"> 159.                     # Defer running of process_response until after the template</font>
<font color="black"> 160.                     # has been rendered:</font>
<font color="red"> 161.                     if hasattr(middleware, 'process_response'):</font>
<font color="red"> 162.                         callback = lambda response: middleware.process_response(request, response)</font>
<font color="red"> 163.                         response.add_post_render_callback(callback)</font>
<font color="black"> 164.                 else:</font>
<font color="red"> 165.                     if hasattr(middleware, 'process_response'):</font>
<font color="red"> 166.                         return middleware.process_response(request, response)</font>
<font color="red"> 167.                 return response</font>
<font color="green"> 168.             return _wrapped_view</font>
<font color="green"> 169.         return _decorator</font>
<font color="green"> 170.     return _make_decorator</font>
<font color="black"> 171. </font>
<font color="black"> 172. </font>
<font color="green"> 173. if ContextDecorator is None:</font>
<font color="black"> 174.     # ContextDecorator was introduced in Python 3.2</font>
<font color="black"> 175.     # See https://docs.python.org/3/library/contextlib.html#contextlib.ContextDecorator</font>
<font color="green"> 176.     class ContextDecorator(object):</font>
<font color="black"> 177.         &quot;&quot;&quot;</font>
<font color="black"> 178.         A base class that enables a context manager to also be used as a decorator.</font>
<font color="green"> 179.         &quot;&quot;&quot;</font>
<font color="green"> 180.         def __call__(self, func):</font>
<font color="green"> 181.             @wraps(func, assigned=available_attrs(func))</font>
<font color="black"> 182.             def inner(*args, **kwargs):</font>
<font color="red"> 183.                 with self:</font>
<font color="red"> 184.                     return func(*args, **kwargs)</font>
<font color="green"> 185.             return inner</font>
<font color="black"> 186. </font>
<font color="black"> 187. </font>
<font color="green"> 188. class classproperty(object):</font>
<font color="green"> 189.     def __init__(self, method=None):</font>
<font color="green"> 190.         self.fget = method</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def __get__(self, instance, owner):</font>
<font color="red"> 193.         return self.fget(owner)</font>
<font color="black"> 194. </font>
<font color="green"> 195.     def getter(self, method):</font>
<font color="red"> 196.         self.fget = method</font>
<font color="red"> 197.         return self</font>
</pre>

