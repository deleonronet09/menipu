source file: <b>/usr/lib/python2.7/xml/dom/minidom.py</b><br>


file stats: <b>1437 lines, 363 executed: 25.3% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Simple implementation of the Level 1 DOM.</font>
<font color="black">   2. </font>
<font color="black">   3. Namespaces and other minor Level 2 features are also supported.</font>
<font color="black">   4. </font>
<font color="black">   5. parse(&quot;foo.xml&quot;)</font>
<font color="black">   6. </font>
<font color="black">   7. parseString(&quot;&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;&quot;)</font>
<font color="black">   8. </font>
<font color="black">   9. Todo:</font>
<font color="black">  10. =====</font>
<font color="black">  11.  * convenience methods for getting elements and text.</font>
<font color="black">  12.  * more testing</font>
<font color="black">  13.  * bring some of the writer and linearizer code into conformance with this</font>
<font color="black">  14.         interface</font>
<font color="black">  15.  * SAX 2 namespaces</font>
<font color="green">  16. &quot;&quot;&quot;</font>
<font color="black">  17. </font>
<font color="green">  18. import xml.dom</font>
<font color="black">  19. </font>
<font color="green">  20. from xml.dom import EMPTY_NAMESPACE, EMPTY_PREFIX, XMLNS_NAMESPACE, domreg</font>
<font color="green">  21. from xml.dom.minicompat import *</font>
<font color="green">  22. from xml.dom.xmlbuilder import DOMImplementationLS, DocumentLS</font>
<font color="black">  23. </font>
<font color="black">  24. # This is used by the ID-cache invalidation checks; the list isn't</font>
<font color="black">  25. # actually complete, since the nodes being checked will never be the</font>
<font color="black">  26. # DOCUMENT_NODE or DOCUMENT_FRAGMENT_NODE.  (The node being checked is</font>
<font color="black">  27. # the node being added or removed, not the node being modified.)</font>
<font color="black">  28. #</font>
<font color="green">  29. _nodeTypes_with_children = (xml.dom.Node.ELEMENT_NODE,</font>
<font color="green">  30.                             xml.dom.Node.ENTITY_REFERENCE_NODE)</font>
<font color="black">  31. </font>
<font color="black">  32. </font>
<font color="green">  33. class Node(xml.dom.Node):</font>
<font color="green">  34.     namespaceURI = None # this is non-null only for elements and attributes</font>
<font color="green">  35.     parentNode = None</font>
<font color="green">  36.     ownerDocument = None</font>
<font color="green">  37.     nextSibling = None</font>
<font color="green">  38.     previousSibling = None</font>
<font color="black">  39. </font>
<font color="green">  40.     prefix = EMPTY_PREFIX # non-null only for NS elements and attributes</font>
<font color="black">  41. </font>
<font color="green">  42.     def __nonzero__(self):</font>
<font color="red">  43.         return True</font>
<font color="black">  44. </font>
<font color="green">  45.     def toxml(self, encoding = None):</font>
<font color="red">  46.         return self.toprettyxml(&quot;&quot;, &quot;&quot;, encoding)</font>
<font color="black">  47. </font>
<font color="green">  48.     def toprettyxml(self, indent=&quot;\t&quot;, newl=&quot;\n&quot;, encoding = None):</font>
<font color="black">  49.         # indent = the indentation string to prepend, per level</font>
<font color="black">  50.         # newl = the newline string to append</font>
<font color="red">  51.         writer = _get_StringIO()</font>
<font color="red">  52.         if encoding is not None:</font>
<font color="red">  53.             import codecs</font>
<font color="black">  54.             # Can't use codecs.getwriter to preserve 2.0 compatibility</font>
<font color="red">  55.             writer = codecs.lookup(encoding)[3](writer)</font>
<font color="red">  56.         if self.nodeType == Node.DOCUMENT_NODE:</font>
<font color="black">  57.             # Can pass encoding only to document, to put it into XML header</font>
<font color="red">  58.             self.writexml(writer, &quot;&quot;, indent, newl, encoding)</font>
<font color="black">  59.         else:</font>
<font color="red">  60.             self.writexml(writer, &quot;&quot;, indent, newl)</font>
<font color="red">  61.         return writer.getvalue()</font>
<font color="black">  62. </font>
<font color="green">  63.     def hasChildNodes(self):</font>
<font color="red">  64.         if self.childNodes:</font>
<font color="red">  65.             return True</font>
<font color="black">  66.         else:</font>
<font color="red">  67.             return False</font>
<font color="black">  68. </font>
<font color="green">  69.     def _get_childNodes(self):</font>
<font color="red">  70.         return self.childNodes</font>
<font color="black">  71. </font>
<font color="green">  72.     def _get_firstChild(self):</font>
<font color="red">  73.         if self.childNodes:</font>
<font color="red">  74.             return self.childNodes[0]</font>
<font color="black">  75. </font>
<font color="green">  76.     def _get_lastChild(self):</font>
<font color="red">  77.         if self.childNodes:</font>
<font color="red">  78.             return self.childNodes[-1]</font>
<font color="black">  79. </font>
<font color="green">  80.     def insertBefore(self, newChild, refChild):</font>
<font color="red">  81.         if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:</font>
<font color="red">  82.             for c in tuple(newChild.childNodes):</font>
<font color="red">  83.                 self.insertBefore(c, refChild)</font>
<font color="black">  84.             ### The DOM does not clearly specify what to return in this case</font>
<font color="red">  85.             return newChild</font>
<font color="red">  86.         if newChild.nodeType not in self._child_node_types:</font>
<font color="red">  87.             raise xml.dom.HierarchyRequestErr(</font>
<font color="red">  88.                 &quot;%s cannot be child of %s&quot; % (repr(newChild), repr(self)))</font>
<font color="red">  89.         if newChild.parentNode is not None:</font>
<font color="red">  90.             newChild.parentNode.removeChild(newChild)</font>
<font color="red">  91.         if refChild is None:</font>
<font color="red">  92.             self.appendChild(newChild)</font>
<font color="black">  93.         else:</font>
<font color="red">  94.             try:</font>
<font color="red">  95.                 index = self.childNodes.index(refChild)</font>
<font color="red">  96.             except ValueError:</font>
<font color="red">  97.                 raise xml.dom.NotFoundErr()</font>
<font color="red">  98.             if newChild.nodeType in _nodeTypes_with_children:</font>
<font color="red">  99.                 _clear_id_cache(self)</font>
<font color="red"> 100.             self.childNodes.insert(index, newChild)</font>
<font color="red"> 101.             newChild.nextSibling = refChild</font>
<font color="red"> 102.             refChild.previousSibling = newChild</font>
<font color="red"> 103.             if index:</font>
<font color="red"> 104.                 node = self.childNodes[index-1]</font>
<font color="red"> 105.                 node.nextSibling = newChild</font>
<font color="red"> 106.                 newChild.previousSibling = node</font>
<font color="black"> 107.             else:</font>
<font color="red"> 108.                 newChild.previousSibling = None</font>
<font color="red"> 109.             newChild.parentNode = self</font>
<font color="red"> 110.         return newChild</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def appendChild(self, node):</font>
<font color="red"> 113.         if node.nodeType == self.DOCUMENT_FRAGMENT_NODE:</font>
<font color="red"> 114.             for c in tuple(node.childNodes):</font>
<font color="red"> 115.                 self.appendChild(c)</font>
<font color="black"> 116.             ### The DOM does not clearly specify what to return in this case</font>
<font color="red"> 117.             return node</font>
<font color="red"> 118.         if node.nodeType not in self._child_node_types:</font>
<font color="red"> 119.             raise xml.dom.HierarchyRequestErr(</font>
<font color="red"> 120.                 &quot;%s cannot be child of %s&quot; % (repr(node), repr(self)))</font>
<font color="red"> 121.         elif node.nodeType in _nodeTypes_with_children:</font>
<font color="red"> 122.             _clear_id_cache(self)</font>
<font color="red"> 123.         if node.parentNode is not None:</font>
<font color="red"> 124.             node.parentNode.removeChild(node)</font>
<font color="red"> 125.         _append_child(self, node)</font>
<font color="red"> 126.         node.nextSibling = None</font>
<font color="red"> 127.         return node</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def replaceChild(self, newChild, oldChild):</font>
<font color="red"> 130.         if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:</font>
<font color="red"> 131.             refChild = oldChild.nextSibling</font>
<font color="red"> 132.             self.removeChild(oldChild)</font>
<font color="red"> 133.             return self.insertBefore(newChild, refChild)</font>
<font color="red"> 134.         if newChild.nodeType not in self._child_node_types:</font>
<font color="red"> 135.             raise xml.dom.HierarchyRequestErr(</font>
<font color="red"> 136.                 &quot;%s cannot be child of %s&quot; % (repr(newChild), repr(self)))</font>
<font color="red"> 137.         if newChild is oldChild:</font>
<font color="red"> 138.             return</font>
<font color="red"> 139.         if newChild.parentNode is not None:</font>
<font color="red"> 140.             newChild.parentNode.removeChild(newChild)</font>
<font color="red"> 141.         try:</font>
<font color="red"> 142.             index = self.childNodes.index(oldChild)</font>
<font color="red"> 143.         except ValueError:</font>
<font color="red"> 144.             raise xml.dom.NotFoundErr()</font>
<font color="red"> 145.         self.childNodes[index] = newChild</font>
<font color="red"> 146.         newChild.parentNode = self</font>
<font color="red"> 147.         oldChild.parentNode = None</font>
<font color="red"> 148.         if (newChild.nodeType in _nodeTypes_with_children</font>
<font color="red"> 149.             or oldChild.nodeType in _nodeTypes_with_children):</font>
<font color="red"> 150.             _clear_id_cache(self)</font>
<font color="red"> 151.         newChild.nextSibling = oldChild.nextSibling</font>
<font color="red"> 152.         newChild.previousSibling = oldChild.previousSibling</font>
<font color="red"> 153.         oldChild.nextSibling = None</font>
<font color="red"> 154.         oldChild.previousSibling = None</font>
<font color="red"> 155.         if newChild.previousSibling:</font>
<font color="red"> 156.             newChild.previousSibling.nextSibling = newChild</font>
<font color="red"> 157.         if newChild.nextSibling:</font>
<font color="red"> 158.             newChild.nextSibling.previousSibling = newChild</font>
<font color="red"> 159.         return oldChild</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def removeChild(self, oldChild):</font>
<font color="red"> 162.         try:</font>
<font color="red"> 163.             self.childNodes.remove(oldChild)</font>
<font color="red"> 164.         except ValueError:</font>
<font color="red"> 165.             raise xml.dom.NotFoundErr()</font>
<font color="red"> 166.         if oldChild.nextSibling is not None:</font>
<font color="red"> 167.             oldChild.nextSibling.previousSibling = oldChild.previousSibling</font>
<font color="red"> 168.         if oldChild.previousSibling is not None:</font>
<font color="red"> 169.             oldChild.previousSibling.nextSibling = oldChild.nextSibling</font>
<font color="red"> 170.         oldChild.nextSibling = oldChild.previousSibling = None</font>
<font color="red"> 171.         if oldChild.nodeType in _nodeTypes_with_children:</font>
<font color="red"> 172.             _clear_id_cache(self)</font>
<font color="black"> 173. </font>
<font color="red"> 174.         oldChild.parentNode = None</font>
<font color="red"> 175.         return oldChild</font>
<font color="black"> 176. </font>
<font color="green"> 177.     def normalize(self):</font>
<font color="red"> 178.         L = []</font>
<font color="red"> 179.         for child in self.childNodes:</font>
<font color="red"> 180.             if child.nodeType == Node.TEXT_NODE:</font>
<font color="red"> 181.                 if not child.data:</font>
<font color="black"> 182.                     # empty text node; discard</font>
<font color="red"> 183.                     if L:</font>
<font color="red"> 184.                         L[-1].nextSibling = child.nextSibling</font>
<font color="red"> 185.                     if child.nextSibling:</font>
<font color="red"> 186.                         child.nextSibling.previousSibling = child.previousSibling</font>
<font color="red"> 187.                     child.unlink()</font>
<font color="red"> 188.                 elif L and L[-1].nodeType == child.nodeType:</font>
<font color="black"> 189.                     # collapse text node</font>
<font color="red"> 190.                     node = L[-1]</font>
<font color="red"> 191.                     node.data = node.data + child.data</font>
<font color="red"> 192.                     node.nextSibling = child.nextSibling</font>
<font color="red"> 193.                     if child.nextSibling:</font>
<font color="red"> 194.                         child.nextSibling.previousSibling = node</font>
<font color="red"> 195.                     child.unlink()</font>
<font color="black"> 196.                 else:</font>
<font color="red"> 197.                     L.append(child)</font>
<font color="black"> 198.             else:</font>
<font color="red"> 199.                 L.append(child)</font>
<font color="red"> 200.                 if child.nodeType == Node.ELEMENT_NODE:</font>
<font color="red"> 201.                     child.normalize()</font>
<font color="red"> 202.         self.childNodes[:] = L</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def cloneNode(self, deep):</font>
<font color="red"> 205.         return _clone_node(self, deep, self.ownerDocument or self)</font>
<font color="black"> 206. </font>
<font color="green"> 207.     def isSupported(self, feature, version):</font>
<font color="red"> 208.         return self.ownerDocument.implementation.hasFeature(feature, version)</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def _get_localName(self):</font>
<font color="black"> 211.         # Overridden in Element and Attr where localName can be Non-Null</font>
<font color="red"> 212.         return None</font>
<font color="black"> 213. </font>
<font color="black"> 214.     # Node interfaces from Level 3 (WD 9 April 2002)</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def isSameNode(self, other):</font>
<font color="red"> 217.         return self is other</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def getInterface(self, feature):</font>
<font color="red"> 220.         if self.isSupported(feature, None):</font>
<font color="red"> 221.             return self</font>
<font color="black"> 222.         else:</font>
<font color="red"> 223.             return None</font>
<font color="black"> 224. </font>
<font color="black"> 225.     # The &quot;user data&quot; functions use a dictionary that is only present</font>
<font color="black"> 226.     # if some user data has been set, so be careful not to assume it</font>
<font color="black"> 227.     # exists.</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def getUserData(self, key):</font>
<font color="red"> 230.         try:</font>
<font color="red"> 231.             return self._user_data[key][0]</font>
<font color="red"> 232.         except (AttributeError, KeyError):</font>
<font color="red"> 233.             return None</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def setUserData(self, key, data, handler):</font>
<font color="red"> 236.         old = None</font>
<font color="red"> 237.         try:</font>
<font color="red"> 238.             d = self._user_data</font>
<font color="red"> 239.         except AttributeError:</font>
<font color="red"> 240.             d = {}</font>
<font color="red"> 241.             self._user_data = d</font>
<font color="red"> 242.         if key in d:</font>
<font color="red"> 243.             old = d[key][0]</font>
<font color="red"> 244.         if data is None:</font>
<font color="black"> 245.             # ignore handlers passed for None</font>
<font color="red"> 246.             handler = None</font>
<font color="red"> 247.             if old is not None:</font>
<font color="red"> 248.                 del d[key]</font>
<font color="black"> 249.         else:</font>
<font color="red"> 250.             d[key] = (data, handler)</font>
<font color="red"> 251.         return old</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def _call_user_data_handler(self, operation, src, dst):</font>
<font color="red"> 254.         if hasattr(self, &quot;_user_data&quot;):</font>
<font color="red"> 255.             for key, (data, handler) in self._user_data.items():</font>
<font color="red"> 256.                 if handler is not None:</font>
<font color="red"> 257.                     handler.handle(operation, key, data, src, dst)</font>
<font color="black"> 258. </font>
<font color="black"> 259.     # minidom-specific API:</font>
<font color="black"> 260. </font>
<font color="green"> 261.     def unlink(self):</font>
<font color="red"> 262.         self.parentNode = self.ownerDocument = None</font>
<font color="red"> 263.         if self.childNodes:</font>
<font color="red"> 264.             for child in self.childNodes:</font>
<font color="red"> 265.                 child.unlink()</font>
<font color="red"> 266.             self.childNodes = NodeList()</font>
<font color="red"> 267.         self.previousSibling = None</font>
<font color="red"> 268.         self.nextSibling = None</font>
<font color="black"> 269. </font>
<font color="green"> 270. defproperty(Node, &quot;firstChild&quot;, doc=&quot;First child node, or None.&quot;)</font>
<font color="green"> 271. defproperty(Node, &quot;lastChild&quot;,  doc=&quot;Last child node, or None.&quot;)</font>
<font color="green"> 272. defproperty(Node, &quot;localName&quot;,  doc=&quot;Namespace-local name of this node.&quot;)</font>
<font color="black"> 273. </font>
<font color="black"> 274. </font>
<font color="green"> 275. def _append_child(self, node):</font>
<font color="black"> 276.     # fast path with less checks; usable by DOM builders if careful</font>
<font color="red"> 277.     childNodes = self.childNodes</font>
<font color="red"> 278.     if childNodes:</font>
<font color="red"> 279.         last = childNodes[-1]</font>
<font color="red"> 280.         node.__dict__[&quot;previousSibling&quot;] = last</font>
<font color="red"> 281.         last.__dict__[&quot;nextSibling&quot;] = node</font>
<font color="red"> 282.     childNodes.append(node)</font>
<font color="red"> 283.     node.__dict__[&quot;parentNode&quot;] = self</font>
<font color="black"> 284. </font>
<font color="green"> 285. def _in_document(node):</font>
<font color="black"> 286.     # return True iff node is part of a document tree</font>
<font color="red"> 287.     while node is not None:</font>
<font color="red"> 288.         if node.nodeType == Node.DOCUMENT_NODE:</font>
<font color="red"> 289.             return True</font>
<font color="red"> 290.         node = node.parentNode</font>
<font color="red"> 291.     return False</font>
<font color="black"> 292. </font>
<font color="green"> 293. def _write_data(writer, data):</font>
<font color="black"> 294.     &quot;Writes datachars to writer.&quot;</font>
<font color="red"> 295.     if data:</font>
<font color="red"> 296.         data = data.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;).replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;). \</font>
<font color="red"> 297.                     replace(&quot;\&quot;&quot;, &quot;&amp;quot;&quot;).replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)</font>
<font color="red"> 298.         writer.write(data)</font>
<font color="black"> 299. </font>
<font color="green"> 300. def _get_elements_by_tagName_helper(parent, name, rc):</font>
<font color="red"> 301.     for node in parent.childNodes:</font>
<font color="red"> 302.         if node.nodeType == Node.ELEMENT_NODE and \</font>
<font color="red"> 303.             (name == &quot;*&quot; or node.tagName == name):</font>
<font color="red"> 304.             rc.append(node)</font>
<font color="red"> 305.         _get_elements_by_tagName_helper(node, name, rc)</font>
<font color="red"> 306.     return rc</font>
<font color="black"> 307. </font>
<font color="green"> 308. def _get_elements_by_tagName_ns_helper(parent, nsURI, localName, rc):</font>
<font color="red"> 309.     for node in parent.childNodes:</font>
<font color="red"> 310.         if node.nodeType == Node.ELEMENT_NODE:</font>
<font color="red"> 311.             if ((localName == &quot;*&quot; or node.localName == localName) and</font>
<font color="red"> 312.                 (nsURI == &quot;*&quot; or node.namespaceURI == nsURI)):</font>
<font color="red"> 313.                 rc.append(node)</font>
<font color="red"> 314.             _get_elements_by_tagName_ns_helper(node, nsURI, localName, rc)</font>
<font color="red"> 315.     return rc</font>
<font color="black"> 316. </font>
<font color="green"> 317. class DocumentFragment(Node):</font>
<font color="green"> 318.     nodeType = Node.DOCUMENT_FRAGMENT_NODE</font>
<font color="green"> 319.     nodeName = &quot;#document-fragment&quot;</font>
<font color="green"> 320.     nodeValue = None</font>
<font color="green"> 321.     attributes = None</font>
<font color="green"> 322.     parentNode = None</font>
<font color="green"> 323.     _child_node_types = (Node.ELEMENT_NODE,</font>
<font color="green"> 324.                          Node.TEXT_NODE,</font>
<font color="green"> 325.                          Node.CDATA_SECTION_NODE,</font>
<font color="green"> 326.                          Node.ENTITY_REFERENCE_NODE,</font>
<font color="green"> 327.                          Node.PROCESSING_INSTRUCTION_NODE,</font>
<font color="green"> 328.                          Node.COMMENT_NODE,</font>
<font color="green"> 329.                          Node.NOTATION_NODE)</font>
<font color="black"> 330. </font>
<font color="green"> 331.     def __init__(self):</font>
<font color="red"> 332.         self.childNodes = NodeList()</font>
<font color="black"> 333. </font>
<font color="black"> 334. </font>
<font color="green"> 335. class Attr(Node):</font>
<font color="green"> 336.     nodeType = Node.ATTRIBUTE_NODE</font>
<font color="green"> 337.     attributes = None</font>
<font color="green"> 338.     ownerElement = None</font>
<font color="green"> 339.     specified = False</font>
<font color="green"> 340.     _is_id = False</font>
<font color="black"> 341. </font>
<font color="green"> 342.     _child_node_types = (Node.TEXT_NODE, Node.ENTITY_REFERENCE_NODE)</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def __init__(self, qName, namespaceURI=EMPTY_NAMESPACE, localName=None,</font>
<font color="green"> 345.                  prefix=None):</font>
<font color="black"> 346.         # skip setattr for performance</font>
<font color="red"> 347.         d = self.__dict__</font>
<font color="red"> 348.         d[&quot;nodeName&quot;] = d[&quot;name&quot;] = qName</font>
<font color="red"> 349.         d[&quot;namespaceURI&quot;] = namespaceURI</font>
<font color="red"> 350.         d[&quot;prefix&quot;] = prefix</font>
<font color="red"> 351.         d['childNodes'] = NodeList()</font>
<font color="black"> 352. </font>
<font color="black"> 353.         # Add the single child node that represents the value of the attr</font>
<font color="red"> 354.         self.childNodes.append(Text())</font>
<font color="black"> 355. </font>
<font color="black"> 356.         # nodeValue and value are set elsewhere</font>
<font color="black"> 357. </font>
<font color="green"> 358.     def _get_localName(self):</font>
<font color="red"> 359.         return self.nodeName.split(&quot;:&quot;, 1)[-1]</font>
<font color="black"> 360. </font>
<font color="green"> 361.     def _get_specified(self):</font>
<font color="red"> 362.         return self.specified</font>
<font color="black"> 363. </font>
<font color="green"> 364.     def __setattr__(self, name, value):</font>
<font color="red"> 365.         d = self.__dict__</font>
<font color="red"> 366.         if name in (&quot;value&quot;, &quot;nodeValue&quot;):</font>
<font color="red"> 367.             d[&quot;value&quot;] = d[&quot;nodeValue&quot;] = value</font>
<font color="red"> 368.             d2 = self.childNodes[0].__dict__</font>
<font color="red"> 369.             d2[&quot;data&quot;] = d2[&quot;nodeValue&quot;] = value</font>
<font color="red"> 370.             if self.ownerElement is not None:</font>
<font color="red"> 371.                 _clear_id_cache(self.ownerElement)</font>
<font color="red"> 372.         elif name in (&quot;name&quot;, &quot;nodeName&quot;):</font>
<font color="red"> 373.             d[&quot;name&quot;] = d[&quot;nodeName&quot;] = value</font>
<font color="red"> 374.             if self.ownerElement is not None:</font>
<font color="red"> 375.                 _clear_id_cache(self.ownerElement)</font>
<font color="black"> 376.         else:</font>
<font color="red"> 377.             d[name] = value</font>
<font color="black"> 378. </font>
<font color="green"> 379.     def _set_prefix(self, prefix):</font>
<font color="red"> 380.         nsuri = self.namespaceURI</font>
<font color="red"> 381.         if prefix == &quot;xmlns&quot;:</font>
<font color="red"> 382.             if nsuri and nsuri != XMLNS_NAMESPACE:</font>
<font color="red"> 383.                 raise xml.dom.NamespaceErr(</font>
<font color="red"> 384.                     &quot;illegal use of 'xmlns' prefix for the wrong namespace&quot;)</font>
<font color="red"> 385.         d = self.__dict__</font>
<font color="red"> 386.         d['prefix'] = prefix</font>
<font color="red"> 387.         if prefix is None:</font>
<font color="red"> 388.             newName = self.localName</font>
<font color="black"> 389.         else:</font>
<font color="red"> 390.             newName = &quot;%s:%s&quot; % (prefix, self.localName)</font>
<font color="red"> 391.         if self.ownerElement:</font>
<font color="red"> 392.             _clear_id_cache(self.ownerElement)</font>
<font color="red"> 393.         d['nodeName'] = d['name'] = newName</font>
<font color="black"> 394. </font>
<font color="green"> 395.     def _set_value(self, value):</font>
<font color="red"> 396.         d = self.__dict__</font>
<font color="red"> 397.         d['value'] = d['nodeValue'] = value</font>
<font color="red"> 398.         if self.ownerElement:</font>
<font color="red"> 399.             _clear_id_cache(self.ownerElement)</font>
<font color="red"> 400.         self.childNodes[0].data = value</font>
<font color="black"> 401. </font>
<font color="green"> 402.     def unlink(self):</font>
<font color="black"> 403.         # This implementation does not call the base implementation</font>
<font color="black"> 404.         # since most of that is not needed, and the expense of the</font>
<font color="black"> 405.         # method call is not warranted.  We duplicate the removal of</font>
<font color="black"> 406.         # children, but that's all we needed from the base class.</font>
<font color="red"> 407.         elem = self.ownerElement</font>
<font color="red"> 408.         if elem is not None:</font>
<font color="red"> 409.             del elem._attrs[self.nodeName]</font>
<font color="red"> 410.             del elem._attrsNS[(self.namespaceURI, self.localName)]</font>
<font color="red"> 411.             if self._is_id:</font>
<font color="red"> 412.                 self._is_id = False</font>
<font color="red"> 413.                 elem._magic_id_nodes -= 1</font>
<font color="red"> 414.                 self.ownerDocument._magic_id_count -= 1</font>
<font color="red"> 415.         for child in self.childNodes:</font>
<font color="red"> 416.             child.unlink()</font>
<font color="red"> 417.         del self.childNodes[:]</font>
<font color="black"> 418. </font>
<font color="green"> 419.     def _get_isId(self):</font>
<font color="red"> 420.         if self._is_id:</font>
<font color="red"> 421.             return True</font>
<font color="red"> 422.         doc = self.ownerDocument</font>
<font color="red"> 423.         elem = self.ownerElement</font>
<font color="red"> 424.         if doc is None or elem is None:</font>
<font color="red"> 425.             return False</font>
<font color="black"> 426. </font>
<font color="red"> 427.         info = doc._get_elem_info(elem)</font>
<font color="red"> 428.         if info is None:</font>
<font color="red"> 429.             return False</font>
<font color="red"> 430.         if self.namespaceURI:</font>
<font color="red"> 431.             return info.isIdNS(self.namespaceURI, self.localName)</font>
<font color="black"> 432.         else:</font>
<font color="red"> 433.             return info.isId(self.nodeName)</font>
<font color="black"> 434. </font>
<font color="green"> 435.     def _get_schemaType(self):</font>
<font color="red"> 436.         doc = self.ownerDocument</font>
<font color="red"> 437.         elem = self.ownerElement</font>
<font color="red"> 438.         if doc is None or elem is None:</font>
<font color="red"> 439.             return _no_type</font>
<font color="black"> 440. </font>
<font color="red"> 441.         info = doc._get_elem_info(elem)</font>
<font color="red"> 442.         if info is None:</font>
<font color="red"> 443.             return _no_type</font>
<font color="red"> 444.         if self.namespaceURI:</font>
<font color="red"> 445.             return info.getAttributeTypeNS(self.namespaceURI, self.localName)</font>
<font color="black"> 446.         else:</font>
<font color="red"> 447.             return info.getAttributeType(self.nodeName)</font>
<font color="black"> 448. </font>
<font color="green"> 449. defproperty(Attr, &quot;isId&quot;,       doc=&quot;True if this attribute is an ID.&quot;)</font>
<font color="green"> 450. defproperty(Attr, &quot;localName&quot;,  doc=&quot;Namespace-local name of this attribute.&quot;)</font>
<font color="green"> 451. defproperty(Attr, &quot;schemaType&quot;, doc=&quot;Schema type for this attribute.&quot;)</font>
<font color="black"> 452. </font>
<font color="black"> 453. </font>
<font color="green"> 454. class NamedNodeMap(object):</font>
<font color="black"> 455.     &quot;&quot;&quot;The attribute list is a transient interface to the underlying</font>
<font color="black"> 456.     dictionaries.  Mutations here will change the underlying element's</font>
<font color="black"> 457.     dictionary.</font>
<font color="black"> 458. </font>
<font color="black"> 459.     Ordering is imposed artificially and does not reflect the order of</font>
<font color="black"> 460.     attributes as found in an input document.</font>
<font color="green"> 461.     &quot;&quot;&quot;</font>
<font color="black"> 462. </font>
<font color="green"> 463.     __slots__ = ('_attrs', '_attrsNS', '_ownerElement')</font>
<font color="black"> 464. </font>
<font color="green"> 465.     def __init__(self, attrs, attrsNS, ownerElement):</font>
<font color="red"> 466.         self._attrs = attrs</font>
<font color="red"> 467.         self._attrsNS = attrsNS</font>
<font color="red"> 468.         self._ownerElement = ownerElement</font>
<font color="black"> 469. </font>
<font color="green"> 470.     def _get_length(self):</font>
<font color="red"> 471.         return len(self._attrs)</font>
<font color="black"> 472. </font>
<font color="green"> 473.     def item(self, index):</font>
<font color="red"> 474.         try:</font>
<font color="red"> 475.             return self[self._attrs.keys()[index]]</font>
<font color="red"> 476.         except IndexError:</font>
<font color="red"> 477.             return None</font>
<font color="black"> 478. </font>
<font color="green"> 479.     def items(self):</font>
<font color="red"> 480.         L = []</font>
<font color="red"> 481.         for node in self._attrs.values():</font>
<font color="red"> 482.             L.append((node.nodeName, node.value))</font>
<font color="red"> 483.         return L</font>
<font color="black"> 484. </font>
<font color="green"> 485.     def itemsNS(self):</font>
<font color="red"> 486.         L = []</font>
<font color="red"> 487.         for node in self._attrs.values():</font>
<font color="red"> 488.             L.append(((node.namespaceURI, node.localName), node.value))</font>
<font color="red"> 489.         return L</font>
<font color="black"> 490. </font>
<font color="green"> 491.     def has_key(self, key):</font>
<font color="red"> 492.         if isinstance(key, StringTypes):</font>
<font color="red"> 493.             return key in self._attrs</font>
<font color="black"> 494.         else:</font>
<font color="red"> 495.             return key in self._attrsNS</font>
<font color="black"> 496. </font>
<font color="green"> 497.     def keys(self):</font>
<font color="red"> 498.         return self._attrs.keys()</font>
<font color="black"> 499. </font>
<font color="green"> 500.     def keysNS(self):</font>
<font color="red"> 501.         return self._attrsNS.keys()</font>
<font color="black"> 502. </font>
<font color="green"> 503.     def values(self):</font>
<font color="red"> 504.         return self._attrs.values()</font>
<font color="black"> 505. </font>
<font color="green"> 506.     def get(self, name, value=None):</font>
<font color="red"> 507.         return self._attrs.get(name, value)</font>
<font color="black"> 508. </font>
<font color="green"> 509.     __len__ = _get_length</font>
<font color="black"> 510. </font>
<font color="green"> 511.     __hash__ = None # Mutable type can't be correctly hashed</font>
<font color="green"> 512.     def __cmp__(self, other):</font>
<font color="red"> 513.         if self._attrs is getattr(other, &quot;_attrs&quot;, None):</font>
<font color="red"> 514.             return 0</font>
<font color="black"> 515.         else:</font>
<font color="red"> 516.             return cmp(id(self), id(other))</font>
<font color="black"> 517. </font>
<font color="green"> 518.     def __getitem__(self, attname_or_tuple):</font>
<font color="red"> 519.         if isinstance(attname_or_tuple, tuple):</font>
<font color="red"> 520.             return self._attrsNS[attname_or_tuple]</font>
<font color="black"> 521.         else:</font>
<font color="red"> 522.             return self._attrs[attname_or_tuple]</font>
<font color="black"> 523. </font>
<font color="black"> 524.     # same as set</font>
<font color="green"> 525.     def __setitem__(self, attname, value):</font>
<font color="red"> 526.         if isinstance(value, StringTypes):</font>
<font color="red"> 527.             try:</font>
<font color="red"> 528.                 node = self._attrs[attname]</font>
<font color="red"> 529.             except KeyError:</font>
<font color="red"> 530.                 node = Attr(attname)</font>
<font color="red"> 531.                 node.ownerDocument = self._ownerElement.ownerDocument</font>
<font color="red"> 532.                 self.setNamedItem(node)</font>
<font color="red"> 533.             node.value = value</font>
<font color="black"> 534.         else:</font>
<font color="red"> 535.             if not isinstance(value, Attr):</font>
<font color="red"> 536.                 raise TypeError, &quot;value must be a string or Attr object&quot;</font>
<font color="red"> 537.             node = value</font>
<font color="red"> 538.             self.setNamedItem(node)</font>
<font color="black"> 539. </font>
<font color="green"> 540.     def getNamedItem(self, name):</font>
<font color="red"> 541.         try:</font>
<font color="red"> 542.             return self._attrs[name]</font>
<font color="red"> 543.         except KeyError:</font>
<font color="red"> 544.             return None</font>
<font color="black"> 545. </font>
<font color="green"> 546.     def getNamedItemNS(self, namespaceURI, localName):</font>
<font color="red"> 547.         try:</font>
<font color="red"> 548.             return self._attrsNS[(namespaceURI, localName)]</font>
<font color="red"> 549.         except KeyError:</font>
<font color="red"> 550.             return None</font>
<font color="black"> 551. </font>
<font color="green"> 552.     def removeNamedItem(self, name):</font>
<font color="red"> 553.         n = self.getNamedItem(name)</font>
<font color="red"> 554.         if n is not None:</font>
<font color="red"> 555.             _clear_id_cache(self._ownerElement)</font>
<font color="red"> 556.             del self._attrs[n.nodeName]</font>
<font color="red"> 557.             del self._attrsNS[(n.namespaceURI, n.localName)]</font>
<font color="red"> 558.             if 'ownerElement' in n.__dict__:</font>
<font color="red"> 559.                 n.__dict__['ownerElement'] = None</font>
<font color="red"> 560.             return n</font>
<font color="black"> 561.         else:</font>
<font color="red"> 562.             raise xml.dom.NotFoundErr()</font>
<font color="black"> 563. </font>
<font color="green"> 564.     def removeNamedItemNS(self, namespaceURI, localName):</font>
<font color="red"> 565.         n = self.getNamedItemNS(namespaceURI, localName)</font>
<font color="red"> 566.         if n is not None:</font>
<font color="red"> 567.             _clear_id_cache(self._ownerElement)</font>
<font color="red"> 568.             del self._attrsNS[(n.namespaceURI, n.localName)]</font>
<font color="red"> 569.             del self._attrs[n.nodeName]</font>
<font color="red"> 570.             if 'ownerElement' in n.__dict__:</font>
<font color="red"> 571.                 n.__dict__['ownerElement'] = None</font>
<font color="red"> 572.             return n</font>
<font color="black"> 573.         else:</font>
<font color="red"> 574.             raise xml.dom.NotFoundErr()</font>
<font color="black"> 575. </font>
<font color="green"> 576.     def setNamedItem(self, node):</font>
<font color="red"> 577.         if not isinstance(node, Attr):</font>
<font color="red"> 578.             raise xml.dom.HierarchyRequestErr(</font>
<font color="red"> 579.                 &quot;%s cannot be child of %s&quot; % (repr(node), repr(self)))</font>
<font color="red"> 580.         old = self._attrs.get(node.name)</font>
<font color="red"> 581.         if old:</font>
<font color="red"> 582.             old.unlink()</font>
<font color="red"> 583.         self._attrs[node.name] = node</font>
<font color="red"> 584.         self._attrsNS[(node.namespaceURI, node.localName)] = node</font>
<font color="red"> 585.         node.ownerElement = self._ownerElement</font>
<font color="red"> 586.         _clear_id_cache(node.ownerElement)</font>
<font color="red"> 587.         return old</font>
<font color="black"> 588. </font>
<font color="green"> 589.     def setNamedItemNS(self, node):</font>
<font color="red"> 590.         return self.setNamedItem(node)</font>
<font color="black"> 591. </font>
<font color="green"> 592.     def __delitem__(self, attname_or_tuple):</font>
<font color="red"> 593.         node = self[attname_or_tuple]</font>
<font color="red"> 594.         _clear_id_cache(node.ownerElement)</font>
<font color="red"> 595.         node.unlink()</font>
<font color="black"> 596. </font>
<font color="green"> 597.     def __getstate__(self):</font>
<font color="red"> 598.         return self._attrs, self._attrsNS, self._ownerElement</font>
<font color="black"> 599. </font>
<font color="green"> 600.     def __setstate__(self, state):</font>
<font color="red"> 601.         self._attrs, self._attrsNS, self._ownerElement = state</font>
<font color="black"> 602. </font>
<font color="green"> 603. defproperty(NamedNodeMap, &quot;length&quot;,</font>
<font color="green"> 604.             doc=&quot;Number of nodes in the NamedNodeMap.&quot;)</font>
<font color="black"> 605. </font>
<font color="green"> 606. AttributeList = NamedNodeMap</font>
<font color="black"> 607. </font>
<font color="black"> 608. </font>
<font color="green"> 609. class TypeInfo(object):</font>
<font color="green"> 610.     __slots__ = 'namespace', 'name'</font>
<font color="black"> 611. </font>
<font color="green"> 612.     def __init__(self, namespace, name):</font>
<font color="green"> 613.         self.namespace = namespace</font>
<font color="green"> 614.         self.name = name</font>
<font color="black"> 615. </font>
<font color="green"> 616.     def __repr__(self):</font>
<font color="red"> 617.         if self.namespace:</font>
<font color="red"> 618.             return &quot;&lt;TypeInfo %r (from %r)&gt;&quot; % (self.name, self.namespace)</font>
<font color="black"> 619.         else:</font>
<font color="red"> 620.             return &quot;&lt;TypeInfo %r&gt;&quot; % self.name</font>
<font color="black"> 621. </font>
<font color="green"> 622.     def _get_name(self):</font>
<font color="red"> 623.         return self.name</font>
<font color="black"> 624. </font>
<font color="green"> 625.     def _get_namespace(self):</font>
<font color="red"> 626.         return self.namespace</font>
<font color="black"> 627. </font>
<font color="green"> 628. _no_type = TypeInfo(None, None)</font>
<font color="black"> 629. </font>
<font color="green"> 630. class Element(Node):</font>
<font color="green"> 631.     nodeType = Node.ELEMENT_NODE</font>
<font color="green"> 632.     nodeValue = None</font>
<font color="green"> 633.     schemaType = _no_type</font>
<font color="black"> 634. </font>
<font color="green"> 635.     _magic_id_nodes = 0</font>
<font color="black"> 636. </font>
<font color="green"> 637.     _child_node_types = (Node.ELEMENT_NODE,</font>
<font color="green"> 638.                          Node.PROCESSING_INSTRUCTION_NODE,</font>
<font color="green"> 639.                          Node.COMMENT_NODE,</font>
<font color="green"> 640.                          Node.TEXT_NODE,</font>
<font color="green"> 641.                          Node.CDATA_SECTION_NODE,</font>
<font color="green"> 642.                          Node.ENTITY_REFERENCE_NODE)</font>
<font color="black"> 643. </font>
<font color="green"> 644.     def __init__(self, tagName, namespaceURI=EMPTY_NAMESPACE, prefix=None,</font>
<font color="green"> 645.                  localName=None):</font>
<font color="red"> 646.         self.tagName = self.nodeName = tagName</font>
<font color="red"> 647.         self.prefix = prefix</font>
<font color="red"> 648.         self.namespaceURI = namespaceURI</font>
<font color="red"> 649.         self.childNodes = NodeList()</font>
<font color="black"> 650. </font>
<font color="red"> 651.         self._attrs = {}   # attributes are double-indexed:</font>
<font color="red"> 652.         self._attrsNS = {} #    tagName -&gt; Attribute</font>
<font color="black"> 653.                            #    URI,localName -&gt; Attribute</font>
<font color="black"> 654.                            # in the future: consider lazy generation</font>
<font color="black"> 655.                            # of attribute objects this is too tricky</font>
<font color="black"> 656.                            # for now because of headaches with</font>
<font color="black"> 657.                            # namespaces.</font>
<font color="black"> 658. </font>
<font color="green"> 659.     def _get_localName(self):</font>
<font color="red"> 660.         return self.tagName.split(&quot;:&quot;, 1)[-1]</font>
<font color="black"> 661. </font>
<font color="green"> 662.     def _get_tagName(self):</font>
<font color="red"> 663.         return self.tagName</font>
<font color="black"> 664. </font>
<font color="green"> 665.     def unlink(self):</font>
<font color="red"> 666.         for attr in self._attrs.values():</font>
<font color="red"> 667.             attr.unlink()</font>
<font color="red"> 668.         self._attrs = None</font>
<font color="red"> 669.         self._attrsNS = None</font>
<font color="red"> 670.         Node.unlink(self)</font>
<font color="black"> 671. </font>
<font color="green"> 672.     def getAttribute(self, attname):</font>
<font color="red"> 673.         try:</font>
<font color="red"> 674.             return self._attrs[attname].value</font>
<font color="red"> 675.         except KeyError:</font>
<font color="red"> 676.             return &quot;&quot;</font>
<font color="black"> 677. </font>
<font color="green"> 678.     def getAttributeNS(self, namespaceURI, localName):</font>
<font color="red"> 679.         try:</font>
<font color="red"> 680.             return self._attrsNS[(namespaceURI, localName)].value</font>
<font color="red"> 681.         except KeyError:</font>
<font color="red"> 682.             return &quot;&quot;</font>
<font color="black"> 683. </font>
<font color="green"> 684.     def setAttribute(self, attname, value):</font>
<font color="red"> 685.         attr = self.getAttributeNode(attname)</font>
<font color="red"> 686.         if attr is None:</font>
<font color="red"> 687.             attr = Attr(attname)</font>
<font color="black"> 688.             # for performance</font>
<font color="red"> 689.             d = attr.__dict__</font>
<font color="red"> 690.             d[&quot;value&quot;] = d[&quot;nodeValue&quot;] = value</font>
<font color="red"> 691.             d[&quot;ownerDocument&quot;] = self.ownerDocument</font>
<font color="red"> 692.             self.setAttributeNode(attr)</font>
<font color="red"> 693.         elif value != attr.value:</font>
<font color="red"> 694.             d = attr.__dict__</font>
<font color="red"> 695.             d[&quot;value&quot;] = d[&quot;nodeValue&quot;] = value</font>
<font color="red"> 696.             if attr.isId:</font>
<font color="red"> 697.                 _clear_id_cache(self)</font>
<font color="black"> 698. </font>
<font color="green"> 699.     def setAttributeNS(self, namespaceURI, qualifiedName, value):</font>
<font color="red"> 700.         prefix, localname = _nssplit(qualifiedName)</font>
<font color="red"> 701.         attr = self.getAttributeNodeNS(namespaceURI, localname)</font>
<font color="red"> 702.         if attr is None:</font>
<font color="black"> 703.             # for performance</font>
<font color="red"> 704.             attr = Attr(qualifiedName, namespaceURI, localname, prefix)</font>
<font color="red"> 705.             d = attr.__dict__</font>
<font color="red"> 706.             d[&quot;prefix&quot;] = prefix</font>
<font color="red"> 707.             d[&quot;nodeName&quot;] = qualifiedName</font>
<font color="red"> 708.             d[&quot;value&quot;] = d[&quot;nodeValue&quot;] = value</font>
<font color="red"> 709.             d[&quot;ownerDocument&quot;] = self.ownerDocument</font>
<font color="red"> 710.             self.setAttributeNode(attr)</font>
<font color="black"> 711.         else:</font>
<font color="red"> 712.             d = attr.__dict__</font>
<font color="red"> 713.             if value != attr.value:</font>
<font color="red"> 714.                 d[&quot;value&quot;] = d[&quot;nodeValue&quot;] = value</font>
<font color="red"> 715.                 if attr.isId:</font>
<font color="red"> 716.                     _clear_id_cache(self)</font>
<font color="red"> 717.             if attr.prefix != prefix:</font>
<font color="red"> 718.                 d[&quot;prefix&quot;] = prefix</font>
<font color="red"> 719.                 d[&quot;nodeName&quot;] = qualifiedName</font>
<font color="black"> 720. </font>
<font color="green"> 721.     def getAttributeNode(self, attrname):</font>
<font color="red"> 722.         return self._attrs.get(attrname)</font>
<font color="black"> 723. </font>
<font color="green"> 724.     def getAttributeNodeNS(self, namespaceURI, localName):</font>
<font color="red"> 725.         return self._attrsNS.get((namespaceURI, localName))</font>
<font color="black"> 726. </font>
<font color="green"> 727.     def setAttributeNode(self, attr):</font>
<font color="red"> 728.         if attr.ownerElement not in (None, self):</font>
<font color="red"> 729.             raise xml.dom.InuseAttributeErr(&quot;attribute node already owned&quot;)</font>
<font color="red"> 730.         old1 = self._attrs.get(attr.name, None)</font>
<font color="red"> 731.         if old1 is not None:</font>
<font color="red"> 732.             self.removeAttributeNode(old1)</font>
<font color="red"> 733.         old2 = self._attrsNS.get((attr.namespaceURI, attr.localName), None)</font>
<font color="red"> 734.         if old2 is not None and old2 is not old1:</font>
<font color="red"> 735.             self.removeAttributeNode(old2)</font>
<font color="red"> 736.         _set_attribute_node(self, attr)</font>
<font color="black"> 737. </font>
<font color="red"> 738.         if old1 is not attr:</font>
<font color="black"> 739.             # It might have already been part of this node, in which case</font>
<font color="black"> 740.             # it doesn't represent a change, and should not be returned.</font>
<font color="red"> 741.             return old1</font>
<font color="red"> 742.         if old2 is not attr:</font>
<font color="red"> 743.             return old2</font>
<font color="black"> 744. </font>
<font color="green"> 745.     setAttributeNodeNS = setAttributeNode</font>
<font color="black"> 746. </font>
<font color="green"> 747.     def removeAttribute(self, name):</font>
<font color="red"> 748.         try:</font>
<font color="red"> 749.             attr = self._attrs[name]</font>
<font color="red"> 750.         except KeyError:</font>
<font color="red"> 751.             raise xml.dom.NotFoundErr()</font>
<font color="red"> 752.         self.removeAttributeNode(attr)</font>
<font color="black"> 753. </font>
<font color="green"> 754.     def removeAttributeNS(self, namespaceURI, localName):</font>
<font color="red"> 755.         try:</font>
<font color="red"> 756.             attr = self._attrsNS[(namespaceURI, localName)]</font>
<font color="red"> 757.         except KeyError:</font>
<font color="red"> 758.             raise xml.dom.NotFoundErr()</font>
<font color="red"> 759.         self.removeAttributeNode(attr)</font>
<font color="black"> 760. </font>
<font color="green"> 761.     def removeAttributeNode(self, node):</font>
<font color="red"> 762.         if node is None:</font>
<font color="red"> 763.             raise xml.dom.NotFoundErr()</font>
<font color="red"> 764.         try:</font>
<font color="red"> 765.             self._attrs[node.name]</font>
<font color="red"> 766.         except KeyError:</font>
<font color="red"> 767.             raise xml.dom.NotFoundErr()</font>
<font color="red"> 768.         _clear_id_cache(self)</font>
<font color="red"> 769.         node.unlink()</font>
<font color="black"> 770.         # Restore this since the node is still useful and otherwise</font>
<font color="black"> 771.         # unlinked</font>
<font color="red"> 772.         node.ownerDocument = self.ownerDocument</font>
<font color="black"> 773. </font>
<font color="green"> 774.     removeAttributeNodeNS = removeAttributeNode</font>
<font color="black"> 775. </font>
<font color="green"> 776.     def hasAttribute(self, name):</font>
<font color="red"> 777.         return name in self._attrs</font>
<font color="black"> 778. </font>
<font color="green"> 779.     def hasAttributeNS(self, namespaceURI, localName):</font>
<font color="red"> 780.         return (namespaceURI, localName) in self._attrsNS</font>
<font color="black"> 781. </font>
<font color="green"> 782.     def getElementsByTagName(self, name):</font>
<font color="red"> 783.         return _get_elements_by_tagName_helper(self, name, NodeList())</font>
<font color="black"> 784. </font>
<font color="green"> 785.     def getElementsByTagNameNS(self, namespaceURI, localName):</font>
<font color="red"> 786.         return _get_elements_by_tagName_ns_helper(</font>
<font color="red"> 787.             self, namespaceURI, localName, NodeList())</font>
<font color="black"> 788. </font>
<font color="green"> 789.     def __repr__(self):</font>
<font color="red"> 790.         return &quot;&lt;DOM Element: %s at %#x&gt;&quot; % (self.tagName, id(self))</font>
<font color="black"> 791. </font>
<font color="green"> 792.     def writexml(self, writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;):</font>
<font color="black"> 793.         # indent = current indentation</font>
<font color="black"> 794.         # addindent = indentation to add to higher levels</font>
<font color="black"> 795.         # newl = newline string</font>
<font color="red"> 796.         writer.write(indent+&quot;&lt;&quot; + self.tagName)</font>
<font color="black"> 797. </font>
<font color="red"> 798.         attrs = self._get_attributes()</font>
<font color="red"> 799.         a_names = attrs.keys()</font>
<font color="red"> 800.         a_names.sort()</font>
<font color="black"> 801. </font>
<font color="red"> 802.         for a_name in a_names:</font>
<font color="red"> 803.             writer.write(&quot; %s=\&quot;&quot; % a_name)</font>
<font color="red"> 804.             _write_data(writer, attrs[a_name].value)</font>
<font color="red"> 805.             writer.write(&quot;\&quot;&quot;)</font>
<font color="red"> 806.         if self.childNodes:</font>
<font color="red"> 807.             writer.write(&quot;&gt;&quot;)</font>
<font color="red"> 808.             if (len(self.childNodes) == 1 and</font>
<font color="red"> 809.                 self.childNodes[0].nodeType == Node.TEXT_NODE):</font>
<font color="red"> 810.                 self.childNodes[0].writexml(writer, '', '', '')</font>
<font color="black"> 811.             else:</font>
<font color="red"> 812.                 writer.write(newl)</font>
<font color="red"> 813.                 for node in self.childNodes:</font>
<font color="red"> 814.                     node.writexml(writer, indent+addindent, addindent, newl)</font>
<font color="red"> 815.                 writer.write(indent)</font>
<font color="red"> 816.             writer.write(&quot;&lt;/%s&gt;%s&quot; % (self.tagName, newl))</font>
<font color="black"> 817.         else:</font>
<font color="red"> 818.             writer.write(&quot;/&gt;%s&quot;%(newl))</font>
<font color="black"> 819. </font>
<font color="green"> 820.     def _get_attributes(self):</font>
<font color="red"> 821.         return NamedNodeMap(self._attrs, self._attrsNS, self)</font>
<font color="black"> 822. </font>
<font color="green"> 823.     def hasAttributes(self):</font>
<font color="red"> 824.         if self._attrs:</font>
<font color="red"> 825.             return True</font>
<font color="black"> 826.         else:</font>
<font color="red"> 827.             return False</font>
<font color="black"> 828. </font>
<font color="black"> 829.     # DOM Level 3 attributes, based on the 22 Oct 2002 draft</font>
<font color="black"> 830. </font>
<font color="green"> 831.     def setIdAttribute(self, name):</font>
<font color="red"> 832.         idAttr = self.getAttributeNode(name)</font>
<font color="red"> 833.         self.setIdAttributeNode(idAttr)</font>
<font color="black"> 834. </font>
<font color="green"> 835.     def setIdAttributeNS(self, namespaceURI, localName):</font>
<font color="red"> 836.         idAttr = self.getAttributeNodeNS(namespaceURI, localName)</font>
<font color="red"> 837.         self.setIdAttributeNode(idAttr)</font>
<font color="black"> 838. </font>
<font color="green"> 839.     def setIdAttributeNode(self, idAttr):</font>
<font color="red"> 840.         if idAttr is None or not self.isSameNode(idAttr.ownerElement):</font>
<font color="red"> 841.             raise xml.dom.NotFoundErr()</font>
<font color="red"> 842.         if _get_containing_entref(self) is not None:</font>
<font color="red"> 843.             raise xml.dom.NoModificationAllowedErr()</font>
<font color="red"> 844.         if not idAttr._is_id:</font>
<font color="red"> 845.             idAttr.__dict__['_is_id'] = True</font>
<font color="red"> 846.             self._magic_id_nodes += 1</font>
<font color="red"> 847.             self.ownerDocument._magic_id_count += 1</font>
<font color="red"> 848.             _clear_id_cache(self)</font>
<font color="black"> 849. </font>
<font color="green"> 850. defproperty(Element, &quot;attributes&quot;,</font>
<font color="green"> 851.             doc=&quot;NamedNodeMap of attributes on the element.&quot;)</font>
<font color="green"> 852. defproperty(Element, &quot;localName&quot;,</font>
<font color="green"> 853.             doc=&quot;Namespace-local name of this element.&quot;)</font>
<font color="black"> 854. </font>
<font color="black"> 855. </font>
<font color="green"> 856. def _set_attribute_node(element, attr):</font>
<font color="red"> 857.     _clear_id_cache(element)</font>
<font color="red"> 858.     element._attrs[attr.name] = attr</font>
<font color="red"> 859.     element._attrsNS[(attr.namespaceURI, attr.localName)] = attr</font>
<font color="black"> 860. </font>
<font color="black"> 861.     # This creates a circular reference, but Element.unlink()</font>
<font color="black"> 862.     # breaks the cycle since the references to the attribute</font>
<font color="black"> 863.     # dictionaries are tossed.</font>
<font color="red"> 864.     attr.__dict__['ownerElement'] = element</font>
<font color="black"> 865. </font>
<font color="black"> 866. </font>
<font color="green"> 867. class Childless:</font>
<font color="black"> 868.     &quot;&quot;&quot;Mixin that makes childless-ness easy to implement and avoids</font>
<font color="black"> 869.     the complexity of the Node methods that deal with children.</font>
<font color="green"> 870.     &quot;&quot;&quot;</font>
<font color="black"> 871. </font>
<font color="green"> 872.     attributes = None</font>
<font color="green"> 873.     childNodes = EmptyNodeList()</font>
<font color="green"> 874.     firstChild = None</font>
<font color="green"> 875.     lastChild = None</font>
<font color="black"> 876. </font>
<font color="green"> 877.     def _get_firstChild(self):</font>
<font color="red"> 878.         return None</font>
<font color="black"> 879. </font>
<font color="green"> 880.     def _get_lastChild(self):</font>
<font color="red"> 881.         return None</font>
<font color="black"> 882. </font>
<font color="green"> 883.     def appendChild(self, node):</font>
<font color="red"> 884.         raise xml.dom.HierarchyRequestErr(</font>
<font color="red"> 885.             self.nodeName + &quot; nodes cannot have children&quot;)</font>
<font color="black"> 886. </font>
<font color="green"> 887.     def hasChildNodes(self):</font>
<font color="red"> 888.         return False</font>
<font color="black"> 889. </font>
<font color="green"> 890.     def insertBefore(self, newChild, refChild):</font>
<font color="red"> 891.         raise xml.dom.HierarchyRequestErr(</font>
<font color="red"> 892.             self.nodeName + &quot; nodes do not have children&quot;)</font>
<font color="black"> 893. </font>
<font color="green"> 894.     def removeChild(self, oldChild):</font>
<font color="red"> 895.         raise xml.dom.NotFoundErr(</font>
<font color="red"> 896.             self.nodeName + &quot; nodes do not have children&quot;)</font>
<font color="black"> 897. </font>
<font color="green"> 898.     def normalize(self):</font>
<font color="black"> 899.         # For childless nodes, normalize() has nothing to do.</font>
<font color="red"> 900.         pass</font>
<font color="black"> 901. </font>
<font color="green"> 902.     def replaceChild(self, newChild, oldChild):</font>
<font color="red"> 903.         raise xml.dom.HierarchyRequestErr(</font>
<font color="red"> 904.             self.nodeName + &quot; nodes do not have children&quot;)</font>
<font color="black"> 905. </font>
<font color="black"> 906. </font>
<font color="green"> 907. class ProcessingInstruction(Childless, Node):</font>
<font color="green"> 908.     nodeType = Node.PROCESSING_INSTRUCTION_NODE</font>
<font color="black"> 909. </font>
<font color="green"> 910.     def __init__(self, target, data):</font>
<font color="red"> 911.         self.target = self.nodeName = target</font>
<font color="red"> 912.         self.data = self.nodeValue = data</font>
<font color="black"> 913. </font>
<font color="green"> 914.     def _get_data(self):</font>
<font color="red"> 915.         return self.data</font>
<font color="green"> 916.     def _set_data(self, value):</font>
<font color="red"> 917.         d = self.__dict__</font>
<font color="red"> 918.         d['data'] = d['nodeValue'] = value</font>
<font color="black"> 919. </font>
<font color="green"> 920.     def _get_target(self):</font>
<font color="red"> 921.         return self.target</font>
<font color="green"> 922.     def _set_target(self, value):</font>
<font color="red"> 923.         d = self.__dict__</font>
<font color="red"> 924.         d['target'] = d['nodeName'] = value</font>
<font color="black"> 925. </font>
<font color="green"> 926.     def __setattr__(self, name, value):</font>
<font color="red"> 927.         if name == &quot;data&quot; or name == &quot;nodeValue&quot;:</font>
<font color="red"> 928.             self.__dict__['data'] = self.__dict__['nodeValue'] = value</font>
<font color="red"> 929.         elif name == &quot;target&quot; or name == &quot;nodeName&quot;:</font>
<font color="red"> 930.             self.__dict__['target'] = self.__dict__['nodeName'] = value</font>
<font color="black"> 931.         else:</font>
<font color="red"> 932.             self.__dict__[name] = value</font>
<font color="black"> 933. </font>
<font color="green"> 934.     def writexml(self, writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;):</font>
<font color="red"> 935.         writer.write(&quot;%s&lt;?%s %s?&gt;%s&quot; % (indent,self.target, self.data, newl))</font>
<font color="black"> 936. </font>
<font color="black"> 937. </font>
<font color="green"> 938. class CharacterData(Childless, Node):</font>
<font color="green"> 939.     def _get_length(self):</font>
<font color="red"> 940.         return len(self.data)</font>
<font color="green"> 941.     __len__ = _get_length</font>
<font color="black"> 942. </font>
<font color="green"> 943.     def _get_data(self):</font>
<font color="red"> 944.         return self.__dict__['data']</font>
<font color="green"> 945.     def _set_data(self, data):</font>
<font color="red"> 946.         d = self.__dict__</font>
<font color="red"> 947.         d['data'] = d['nodeValue'] = data</font>
<font color="black"> 948. </font>
<font color="green"> 949.     _get_nodeValue = _get_data</font>
<font color="green"> 950.     _set_nodeValue = _set_data</font>
<font color="black"> 951. </font>
<font color="green"> 952.     def __setattr__(self, name, value):</font>
<font color="red"> 953.         if name == &quot;data&quot; or name == &quot;nodeValue&quot;:</font>
<font color="red"> 954.             self.__dict__['data'] = self.__dict__['nodeValue'] = value</font>
<font color="black"> 955.         else:</font>
<font color="red"> 956.             self.__dict__[name] = value</font>
<font color="black"> 957. </font>
<font color="green"> 958.     def __repr__(self):</font>
<font color="red"> 959.         data = self.data</font>
<font color="red"> 960.         if len(data) &gt; 10:</font>
<font color="red"> 961.             dotdotdot = &quot;...&quot;</font>
<font color="black"> 962.         else:</font>
<font color="red"> 963.             dotdotdot = &quot;&quot;</font>
<font color="red"> 964.         return '&lt;DOM %s node &quot;%r%s&quot;&gt;' % (</font>
<font color="red"> 965.             self.__class__.__name__, data[0:10], dotdotdot)</font>
<font color="black"> 966. </font>
<font color="green"> 967.     def substringData(self, offset, count):</font>
<font color="red"> 968.         if offset &lt; 0:</font>
<font color="red"> 969.             raise xml.dom.IndexSizeErr(&quot;offset cannot be negative&quot;)</font>
<font color="red"> 970.         if offset &gt;= len(self.data):</font>
<font color="red"> 971.             raise xml.dom.IndexSizeErr(&quot;offset cannot be beyond end of data&quot;)</font>
<font color="red"> 972.         if count &lt; 0:</font>
<font color="red"> 973.             raise xml.dom.IndexSizeErr(&quot;count cannot be negative&quot;)</font>
<font color="red"> 974.         return self.data[offset:offset+count]</font>
<font color="black"> 975. </font>
<font color="green"> 976.     def appendData(self, arg):</font>
<font color="red"> 977.         self.data = self.data + arg</font>
<font color="black"> 978. </font>
<font color="green"> 979.     def insertData(self, offset, arg):</font>
<font color="red"> 980.         if offset &lt; 0:</font>
<font color="red"> 981.             raise xml.dom.IndexSizeErr(&quot;offset cannot be negative&quot;)</font>
<font color="red"> 982.         if offset &gt;= len(self.data):</font>
<font color="red"> 983.             raise xml.dom.IndexSizeErr(&quot;offset cannot be beyond end of data&quot;)</font>
<font color="red"> 984.         if arg:</font>
<font color="red"> 985.             self.data = &quot;%s%s%s&quot; % (</font>
<font color="red"> 986.                 self.data[:offset], arg, self.data[offset:])</font>
<font color="black"> 987. </font>
<font color="green"> 988.     def deleteData(self, offset, count):</font>
<font color="red"> 989.         if offset &lt; 0:</font>
<font color="red"> 990.             raise xml.dom.IndexSizeErr(&quot;offset cannot be negative&quot;)</font>
<font color="red"> 991.         if offset &gt;= len(self.data):</font>
<font color="red"> 992.             raise xml.dom.IndexSizeErr(&quot;offset cannot be beyond end of data&quot;)</font>
<font color="red"> 993.         if count &lt; 0:</font>
<font color="red"> 994.             raise xml.dom.IndexSizeErr(&quot;count cannot be negative&quot;)</font>
<font color="red"> 995.         if count:</font>
<font color="red"> 996.             self.data = self.data[:offset] + self.data[offset+count:]</font>
<font color="black"> 997. </font>
<font color="green"> 998.     def replaceData(self, offset, count, arg):</font>
<font color="red"> 999.         if offset &lt; 0:</font>
<font color="red">1000.             raise xml.dom.IndexSizeErr(&quot;offset cannot be negative&quot;)</font>
<font color="red">1001.         if offset &gt;= len(self.data):</font>
<font color="red">1002.             raise xml.dom.IndexSizeErr(&quot;offset cannot be beyond end of data&quot;)</font>
<font color="red">1003.         if count &lt; 0:</font>
<font color="red">1004.             raise xml.dom.IndexSizeErr(&quot;count cannot be negative&quot;)</font>
<font color="red">1005.         if count:</font>
<font color="red">1006.             self.data = &quot;%s%s%s&quot; % (</font>
<font color="red">1007.                 self.data[:offset], arg, self.data[offset+count:])</font>
<font color="black">1008. </font>
<font color="green">1009. defproperty(CharacterData, &quot;length&quot;, doc=&quot;Length of the string data.&quot;)</font>
<font color="black">1010. </font>
<font color="black">1011. </font>
<font color="green">1012. class Text(CharacterData):</font>
<font color="black">1013.     # Make sure we don't add an instance __dict__ if we don't already</font>
<font color="black">1014.     # have one, at least when that's possible:</font>
<font color="black">1015.     # XXX this does not work, CharacterData is an old-style class</font>
<font color="black">1016.     # __slots__ = ()</font>
<font color="black">1017. </font>
<font color="green">1018.     nodeType = Node.TEXT_NODE</font>
<font color="green">1019.     nodeName = &quot;#text&quot;</font>
<font color="green">1020.     attributes = None</font>
<font color="black">1021. </font>
<font color="green">1022.     def splitText(self, offset):</font>
<font color="red">1023.         if offset &lt; 0 or offset &gt; len(self.data):</font>
<font color="red">1024.             raise xml.dom.IndexSizeErr(&quot;illegal offset value&quot;)</font>
<font color="red">1025.         newText = self.__class__()</font>
<font color="red">1026.         newText.data = self.data[offset:]</font>
<font color="red">1027.         newText.ownerDocument = self.ownerDocument</font>
<font color="red">1028.         next = self.nextSibling</font>
<font color="red">1029.         if self.parentNode and self in self.parentNode.childNodes:</font>
<font color="red">1030.             if next is None:</font>
<font color="red">1031.                 self.parentNode.appendChild(newText)</font>
<font color="black">1032.             else:</font>
<font color="red">1033.                 self.parentNode.insertBefore(newText, next)</font>
<font color="red">1034.         self.data = self.data[:offset]</font>
<font color="red">1035.         return newText</font>
<font color="black">1036. </font>
<font color="green">1037.     def writexml(self, writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;):</font>
<font color="red">1038.         _write_data(writer, &quot;%s%s%s&quot; % (indent, self.data, newl))</font>
<font color="black">1039. </font>
<font color="black">1040.     # DOM Level 3 (WD 9 April 2002)</font>
<font color="black">1041. </font>
<font color="green">1042.     def _get_wholeText(self):</font>
<font color="red">1043.         L = [self.data]</font>
<font color="red">1044.         n = self.previousSibling</font>
<font color="red">1045.         while n is not None:</font>
<font color="red">1046.             if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):</font>
<font color="red">1047.                 L.insert(0, n.data)</font>
<font color="red">1048.                 n = n.previousSibling</font>
<font color="black">1049.             else:</font>
<font color="red">1050.                 break</font>
<font color="red">1051.         n = self.nextSibling</font>
<font color="red">1052.         while n is not None:</font>
<font color="red">1053.             if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):</font>
<font color="red">1054.                 L.append(n.data)</font>
<font color="red">1055.                 n = n.nextSibling</font>
<font color="black">1056.             else:</font>
<font color="red">1057.                 break</font>
<font color="red">1058.         return ''.join(L)</font>
<font color="black">1059. </font>
<font color="green">1060.     def replaceWholeText(self, content):</font>
<font color="black">1061.         # XXX This needs to be seriously changed if minidom ever</font>
<font color="black">1062.         # supports EntityReference nodes.</font>
<font color="red">1063.         parent = self.parentNode</font>
<font color="red">1064.         n = self.previousSibling</font>
<font color="red">1065.         while n is not None:</font>
<font color="red">1066.             if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):</font>
<font color="red">1067.                 next = n.previousSibling</font>
<font color="red">1068.                 parent.removeChild(n)</font>
<font color="red">1069.                 n = next</font>
<font color="black">1070.             else:</font>
<font color="red">1071.                 break</font>
<font color="red">1072.         n = self.nextSibling</font>
<font color="red">1073.         if not content:</font>
<font color="red">1074.             parent.removeChild(self)</font>
<font color="red">1075.         while n is not None:</font>
<font color="red">1076.             if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):</font>
<font color="red">1077.                 next = n.nextSibling</font>
<font color="red">1078.                 parent.removeChild(n)</font>
<font color="red">1079.                 n = next</font>
<font color="black">1080.             else:</font>
<font color="red">1081.                 break</font>
<font color="red">1082.         if content:</font>
<font color="red">1083.             d = self.__dict__</font>
<font color="red">1084.             d['data'] = content</font>
<font color="red">1085.             d['nodeValue'] = content</font>
<font color="red">1086.             return self</font>
<font color="black">1087.         else:</font>
<font color="red">1088.             return None</font>
<font color="black">1089. </font>
<font color="green">1090.     def _get_isWhitespaceInElementContent(self):</font>
<font color="red">1091.         if self.data.strip():</font>
<font color="red">1092.             return False</font>
<font color="red">1093.         elem = _get_containing_element(self)</font>
<font color="red">1094.         if elem is None:</font>
<font color="red">1095.             return False</font>
<font color="red">1096.         info = self.ownerDocument._get_elem_info(elem)</font>
<font color="red">1097.         if info is None:</font>
<font color="red">1098.             return False</font>
<font color="black">1099.         else:</font>
<font color="red">1100.             return info.isElementContent()</font>
<font color="black">1101. </font>
<font color="green">1102. defproperty(Text, &quot;isWhitespaceInElementContent&quot;,</font>
<font color="green">1103.             doc=&quot;True iff this text node contains only whitespace&quot;</font>
<font color="black">1104.                 &quot; and is in element content.&quot;)</font>
<font color="green">1105. defproperty(Text, &quot;wholeText&quot;,</font>
<font color="green">1106.             doc=&quot;The text of all logically-adjacent text nodes.&quot;)</font>
<font color="black">1107. </font>
<font color="black">1108. </font>
<font color="green">1109. def _get_containing_element(node):</font>
<font color="red">1110.     c = node.parentNode</font>
<font color="red">1111.     while c is not None:</font>
<font color="red">1112.         if c.nodeType == Node.ELEMENT_NODE:</font>
<font color="red">1113.             return c</font>
<font color="red">1114.         c = c.parentNode</font>
<font color="red">1115.     return None</font>
<font color="black">1116. </font>
<font color="green">1117. def _get_containing_entref(node):</font>
<font color="red">1118.     c = node.parentNode</font>
<font color="red">1119.     while c is not None:</font>
<font color="red">1120.         if c.nodeType == Node.ENTITY_REFERENCE_NODE:</font>
<font color="red">1121.             return c</font>
<font color="red">1122.         c = c.parentNode</font>
<font color="red">1123.     return None</font>
<font color="black">1124. </font>
<font color="black">1125. </font>
<font color="green">1126. class Comment(Childless, CharacterData):</font>
<font color="green">1127.     nodeType = Node.COMMENT_NODE</font>
<font color="green">1128.     nodeName = &quot;#comment&quot;</font>
<font color="black">1129. </font>
<font color="green">1130.     def __init__(self, data):</font>
<font color="red">1131.         self.data = self.nodeValue = data</font>
<font color="black">1132. </font>
<font color="green">1133.     def writexml(self, writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;):</font>
<font color="red">1134.         if &quot;--&quot; in self.data:</font>
<font color="red">1135.             raise ValueError(&quot;'--' is not allowed in a comment node&quot;)</font>
<font color="red">1136.         writer.write(&quot;%s&lt;!--%s--&gt;%s&quot; % (indent, self.data, newl))</font>
<font color="black">1137. </font>
<font color="black">1138. </font>
<font color="green">1139. class CDATASection(Text):</font>
<font color="black">1140.     # Make sure we don't add an instance __dict__ if we don't already</font>
<font color="black">1141.     # have one, at least when that's possible:</font>
<font color="black">1142.     # XXX this does not work, Text is an old-style class</font>
<font color="black">1143.     # __slots__ = ()</font>
<font color="black">1144. </font>
<font color="green">1145.     nodeType = Node.CDATA_SECTION_NODE</font>
<font color="green">1146.     nodeName = &quot;#cdata-section&quot;</font>
<font color="black">1147. </font>
<font color="green">1148.     def writexml(self, writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;):</font>
<font color="red">1149.         if self.data.find(&quot;]]&gt;&quot;) &gt;= 0:</font>
<font color="red">1150.             raise ValueError(&quot;']]&gt;' not allowed in a CDATA section&quot;)</font>
<font color="red">1151.         writer.write(&quot;&lt;![CDATA[%s]]&gt;&quot; % self.data)</font>
<font color="black">1152. </font>
<font color="black">1153. </font>
<font color="green">1154. class ReadOnlySequentialNamedNodeMap(object):</font>
<font color="green">1155.     __slots__ = '_seq',</font>
<font color="black">1156. </font>
<font color="green">1157.     def __init__(self, seq=()):</font>
<font color="black">1158.         # seq should be a list or tuple</font>
<font color="red">1159.         self._seq = seq</font>
<font color="black">1160. </font>
<font color="green">1161.     def __len__(self):</font>
<font color="red">1162.         return len(self._seq)</font>
<font color="black">1163. </font>
<font color="green">1164.     def _get_length(self):</font>
<font color="red">1165.         return len(self._seq)</font>
<font color="black">1166. </font>
<font color="green">1167.     def getNamedItem(self, name):</font>
<font color="red">1168.         for n in self._seq:</font>
<font color="red">1169.             if n.nodeName == name:</font>
<font color="red">1170.                 return n</font>
<font color="black">1171. </font>
<font color="green">1172.     def getNamedItemNS(self, namespaceURI, localName):</font>
<font color="red">1173.         for n in self._seq:</font>
<font color="red">1174.             if n.namespaceURI == namespaceURI and n.localName == localName:</font>
<font color="red">1175.                 return n</font>
<font color="black">1176. </font>
<font color="green">1177.     def __getitem__(self, name_or_tuple):</font>
<font color="red">1178.         if isinstance(name_or_tuple, tuple):</font>
<font color="red">1179.             node = self.getNamedItemNS(*name_or_tuple)</font>
<font color="black">1180.         else:</font>
<font color="red">1181.             node = self.getNamedItem(name_or_tuple)</font>
<font color="red">1182.         if node is None:</font>
<font color="red">1183.             raise KeyError, name_or_tuple</font>
<font color="red">1184.         return node</font>
<font color="black">1185. </font>
<font color="green">1186.     def item(self, index):</font>
<font color="red">1187.         if index &lt; 0:</font>
<font color="red">1188.             return None</font>
<font color="red">1189.         try:</font>
<font color="red">1190.             return self._seq[index]</font>
<font color="red">1191.         except IndexError:</font>
<font color="red">1192.             return None</font>
<font color="black">1193. </font>
<font color="green">1194.     def removeNamedItem(self, name):</font>
<font color="red">1195.         raise xml.dom.NoModificationAllowedErr(</font>
<font color="red">1196.             &quot;NamedNodeMap instance is read-only&quot;)</font>
<font color="black">1197. </font>
<font color="green">1198.     def removeNamedItemNS(self, namespaceURI, localName):</font>
<font color="red">1199.         raise xml.dom.NoModificationAllowedErr(</font>
<font color="red">1200.             &quot;NamedNodeMap instance is read-only&quot;)</font>
<font color="black">1201. </font>
<font color="green">1202.     def setNamedItem(self, node):</font>
<font color="red">1203.         raise xml.dom.NoModificationAllowedErr(</font>
<font color="red">1204.             &quot;NamedNodeMap instance is read-only&quot;)</font>
<font color="black">1205. </font>
<font color="green">1206.     def setNamedItemNS(self, node):</font>
<font color="red">1207.         raise xml.dom.NoModificationAllowedErr(</font>
<font color="red">1208.             &quot;NamedNodeMap instance is read-only&quot;)</font>
<font color="black">1209. </font>
<font color="green">1210.     def __getstate__(self):</font>
<font color="red">1211.         return [self._seq]</font>
<font color="black">1212. </font>
<font color="green">1213.     def __setstate__(self, state):</font>
<font color="red">1214.         self._seq = state[0]</font>
<font color="black">1215. </font>
<font color="green">1216. defproperty(ReadOnlySequentialNamedNodeMap, &quot;length&quot;,</font>
<font color="green">1217.             doc=&quot;Number of entries in the NamedNodeMap.&quot;)</font>
<font color="black">1218. </font>
<font color="black">1219. </font>
<font color="green">1220. class Identified:</font>
<font color="green">1221.     &quot;&quot;&quot;Mix-in class that supports the publicId and systemId attributes.&quot;&quot;&quot;</font>
<font color="black">1222. </font>
<font color="black">1223.     # XXX this does not work, this is an old-style class</font>
<font color="black">1224.     # __slots__ = 'publicId', 'systemId'</font>
<font color="black">1225. </font>
<font color="green">1226.     def _identified_mixin_init(self, publicId, systemId):</font>
<font color="red">1227.         self.publicId = publicId</font>
<font color="red">1228.         self.systemId = systemId</font>
<font color="black">1229. </font>
<font color="green">1230.     def _get_publicId(self):</font>
<font color="red">1231.         return self.publicId</font>
<font color="black">1232. </font>
<font color="green">1233.     def _get_systemId(self):</font>
<font color="red">1234.         return self.systemId</font>
<font color="black">1235. </font>
<font color="green">1236. class DocumentType(Identified, Childless, Node):</font>
<font color="green">1237.     nodeType = Node.DOCUMENT_TYPE_NODE</font>
<font color="green">1238.     nodeValue = None</font>
<font color="green">1239.     name = None</font>
<font color="green">1240.     publicId = None</font>
<font color="green">1241.     systemId = None</font>
<font color="green">1242.     internalSubset = None</font>
<font color="black">1243. </font>
<font color="green">1244.     def __init__(self, qualifiedName):</font>
<font color="red">1245.         self.entities = ReadOnlySequentialNamedNodeMap()</font>
<font color="red">1246.         self.notations = ReadOnlySequentialNamedNodeMap()</font>
<font color="red">1247.         if qualifiedName:</font>
<font color="red">1248.             prefix, localname = _nssplit(qualifiedName)</font>
<font color="red">1249.             self.name = localname</font>
<font color="red">1250.         self.nodeName = self.name</font>
<font color="black">1251. </font>
<font color="green">1252.     def _get_internalSubset(self):</font>
<font color="red">1253.         return self.internalSubset</font>
<font color="black">1254. </font>
<font color="green">1255.     def cloneNode(self, deep):</font>
<font color="red">1256.         if self.ownerDocument is None:</font>
<font color="black">1257.             # it's ok</font>
<font color="red">1258.             clone = DocumentType(None)</font>
<font color="red">1259.             clone.name = self.name</font>
<font color="red">1260.             clone.nodeName = self.name</font>
<font color="red">1261.             operation = xml.dom.UserDataHandler.NODE_CLONED</font>
<font color="red">1262.             if deep:</font>
<font color="red">1263.                 clone.entities._seq = []</font>
<font color="red">1264.                 clone.notations._seq = []</font>
<font color="red">1265.                 for n in self.notations._seq:</font>
<font color="red">1266.                     notation = Notation(n.nodeName, n.publicId, n.systemId)</font>
<font color="red">1267.                     clone.notations._seq.append(notation)</font>
<font color="red">1268.                     n._call_user_data_handler(operation, n, notation)</font>
<font color="red">1269.                 for e in self.entities._seq:</font>
<font color="red">1270.                     entity = Entity(e.nodeName, e.publicId, e.systemId,</font>
<font color="red">1271.                                     e.notationName)</font>
<font color="red">1272.                     entity.actualEncoding = e.actualEncoding</font>
<font color="red">1273.                     entity.encoding = e.encoding</font>
<font color="red">1274.                     entity.version = e.version</font>
<font color="red">1275.                     clone.entities._seq.append(entity)</font>
<font color="red">1276.                     e._call_user_data_handler(operation, n, entity)</font>
<font color="red">1277.             self._call_user_data_handler(operation, self, clone)</font>
<font color="red">1278.             return clone</font>
<font color="black">1279.         else:</font>
<font color="red">1280.             return None</font>
<font color="black">1281. </font>
<font color="green">1282.     def writexml(self, writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;):</font>
<font color="red">1283.         writer.write(&quot;&lt;!DOCTYPE &quot;)</font>
<font color="red">1284.         writer.write(self.name)</font>
<font color="red">1285.         if self.publicId:</font>
<font color="red">1286.             writer.write(&quot;%s  PUBLIC '%s'%s  '%s'&quot;</font>
<font color="red">1287.                          % (newl, self.publicId, newl, self.systemId))</font>
<font color="red">1288.         elif self.systemId:</font>
<font color="red">1289.             writer.write(&quot;%s  SYSTEM '%s'&quot; % (newl, self.systemId))</font>
<font color="red">1290.         if self.internalSubset is not None:</font>
<font color="red">1291.             writer.write(&quot; [&quot;)</font>
<font color="red">1292.             writer.write(self.internalSubset)</font>
<font color="red">1293.             writer.write(&quot;]&quot;)</font>
<font color="red">1294.         writer.write(&quot;&gt;&quot;+newl)</font>
<font color="black">1295. </font>
<font color="green">1296. class Entity(Identified, Node):</font>
<font color="green">1297.     attributes = None</font>
<font color="green">1298.     nodeType = Node.ENTITY_NODE</font>
<font color="green">1299.     nodeValue = None</font>
<font color="black">1300. </font>
<font color="green">1301.     actualEncoding = None</font>
<font color="green">1302.     encoding = None</font>
<font color="green">1303.     version = None</font>
<font color="black">1304. </font>
<font color="green">1305.     def __init__(self, name, publicId, systemId, notation):</font>
<font color="red">1306.         self.nodeName = name</font>
<font color="red">1307.         self.notationName = notation</font>
<font color="red">1308.         self.childNodes = NodeList()</font>
<font color="red">1309.         self._identified_mixin_init(publicId, systemId)</font>
<font color="black">1310. </font>
<font color="green">1311.     def _get_actualEncoding(self):</font>
<font color="red">1312.         return self.actualEncoding</font>
<font color="black">1313. </font>
<font color="green">1314.     def _get_encoding(self):</font>
<font color="red">1315.         return self.encoding</font>
<font color="black">1316. </font>
<font color="green">1317.     def _get_version(self):</font>
<font color="red">1318.         return self.version</font>
<font color="black">1319. </font>
<font color="green">1320.     def appendChild(self, newChild):</font>
<font color="red">1321.         raise xml.dom.HierarchyRequestErr(</font>
<font color="red">1322.             &quot;cannot append children to an entity node&quot;)</font>
<font color="black">1323. </font>
<font color="green">1324.     def insertBefore(self, newChild, refChild):</font>
<font color="red">1325.         raise xml.dom.HierarchyRequestErr(</font>
<font color="red">1326.             &quot;cannot insert children below an entity node&quot;)</font>
<font color="black">1327. </font>
<font color="green">1328.     def removeChild(self, oldChild):</font>
<font color="red">1329.         raise xml.dom.HierarchyRequestErr(</font>
<font color="red">1330.             &quot;cannot remove children from an entity node&quot;)</font>
<font color="black">1331. </font>
<font color="green">1332.     def replaceChild(self, newChild, oldChild):</font>
<font color="red">1333.         raise xml.dom.HierarchyRequestErr(</font>
<font color="red">1334.             &quot;cannot replace children of an entity node&quot;)</font>
<font color="black">1335. </font>
<font color="green">1336. class Notation(Identified, Childless, Node):</font>
<font color="green">1337.     nodeType = Node.NOTATION_NODE</font>
<font color="green">1338.     nodeValue = None</font>
<font color="black">1339. </font>
<font color="green">1340.     def __init__(self, name, publicId, systemId):</font>
<font color="red">1341.         self.nodeName = name</font>
<font color="red">1342.         self._identified_mixin_init(publicId, systemId)</font>
<font color="black">1343. </font>
<font color="black">1344. </font>
<font color="green">1345. class DOMImplementation(DOMImplementationLS):</font>
<font color="green">1346.     _features = [(&quot;core&quot;, &quot;1.0&quot;),</font>
<font color="green">1347.                  (&quot;core&quot;, &quot;2.0&quot;),</font>
<font color="green">1348.                  (&quot;core&quot;, None),</font>
<font color="green">1349.                  (&quot;xml&quot;, &quot;1.0&quot;),</font>
<font color="green">1350.                  (&quot;xml&quot;, &quot;2.0&quot;),</font>
<font color="green">1351.                  (&quot;xml&quot;, None),</font>
<font color="green">1352.                  (&quot;ls-load&quot;, &quot;3.0&quot;),</font>
<font color="green">1353.                  (&quot;ls-load&quot;, None),</font>
<font color="black">1354.                  ]</font>
<font color="black">1355. </font>
<font color="green">1356.     def hasFeature(self, feature, version):</font>
<font color="red">1357.         if version == &quot;&quot;:</font>
<font color="red">1358.             version = None</font>
<font color="red">1359.         return (feature.lower(), version) in self._features</font>
<font color="black">1360. </font>
<font color="green">1361.     def createDocument(self, namespaceURI, qualifiedName, doctype):</font>
<font color="red">1362.         if doctype and doctype.parentNode is not None:</font>
<font color="red">1363.             raise xml.dom.WrongDocumentErr(</font>
<font color="red">1364.                 &quot;doctype object owned by another DOM tree&quot;)</font>
<font color="red">1365.         doc = self._create_document()</font>
<font color="black">1366. </font>
<font color="red">1367.         add_root_element = not (namespaceURI is None</font>
<font color="red">1368.                                 and qualifiedName is None</font>
<font color="red">1369.                                 and doctype is None)</font>
<font color="black">1370. </font>
<font color="red">1371.         if not qualifiedName and add_root_element:</font>
<font color="black">1372.             # The spec is unclear what to raise here; SyntaxErr</font>
<font color="black">1373.             # would be the other obvious candidate. Since Xerces raises</font>
<font color="black">1374.             # InvalidCharacterErr, and since SyntaxErr is not listed</font>
<font color="black">1375.             # for createDocument, that seems to be the better choice.</font>
<font color="black">1376.             # XXX: need to check for illegal characters here and in</font>
<font color="black">1377.             # createElement.</font>
<font color="black">1378. </font>
<font color="black">1379.             # DOM Level III clears this up when talking about the return value</font>
<font color="black">1380.             # of this function.  If namespaceURI, qName and DocType are</font>
<font color="black">1381.             # Null the document is returned without a document element</font>
<font color="black">1382.             # Otherwise if doctype or namespaceURI are not None</font>
<font color="black">1383.             # Then we go back to the above problem</font>
<font color="red">1384.             raise xml.dom.InvalidCharacterErr(&quot;Element with no name&quot;)</font>
<font color="black">1385. </font>
<font color="red">1386.         if add_root_element:</font>
<font color="red">1387.             prefix, localname = _nssplit(qualifiedName)</font>
<font color="red">1388.             if prefix == &quot;xml&quot; \</font>
<font color="red">1389.                and namespaceURI != &quot;http://www.w3.org/XML/1998/namespace&quot;:</font>
<font color="red">1390.                 raise xml.dom.NamespaceErr(&quot;illegal use of 'xml' prefix&quot;)</font>
<font color="red">1391.             if prefix and not namespaceURI:</font>
<font color="red">1392.                 raise xml.dom.NamespaceErr(</font>
<font color="red">1393.                     &quot;illegal use of prefix without namespaces&quot;)</font>
<font color="red">1394.             element = doc.createElementNS(namespaceURI, qualifiedName)</font>
<font color="red">1395.             if doctype:</font>
<font color="red">1396.                 doc.appendChild(doctype)</font>
<font color="red">1397.             doc.appendChild(element)</font>
<font color="black">1398. </font>
<font color="red">1399.         if doctype:</font>
<font color="red">1400.             doctype.parentNode = doctype.ownerDocument = doc</font>
<font color="black">1401. </font>
<font color="red">1402.         doc.doctype = doctype</font>
<font color="red">1403.         doc.implementation = self</font>
<font color="red">1404.         return doc</font>
<font color="black">1405. </font>
<font color="green">1406.     def createDocumentType(self, qualifiedName, publicId, systemId):</font>
<font color="red">1407.         doctype = DocumentType(qualifiedName)</font>
<font color="red">1408.         doctype.publicId = publicId</font>
<font color="red">1409.         doctype.systemId = systemId</font>
<font color="red">1410.         return doctype</font>
<font color="black">1411. </font>
<font color="black">1412.     # DOM Level 3 (WD 9 April 2002)</font>
<font color="black">1413. </font>
<font color="green">1414.     def getInterface(self, feature):</font>
<font color="red">1415.         if self.hasFeature(feature, None):</font>
<font color="red">1416.             return self</font>
<font color="black">1417.         else:</font>
<font color="red">1418.             return None</font>
<font color="black">1419. </font>
<font color="black">1420.     # internal</font>
<font color="green">1421.     def _create_document(self):</font>
<font color="red">1422.         return Document()</font>
<font color="black">1423. </font>
<font color="green">1424. class ElementInfo(object):</font>
<font color="black">1425.     &quot;&quot;&quot;Object that represents content-model information for an element.</font>
<font color="black">1426. </font>
<font color="black">1427.     This implementation is not expected to be used in practice; DOM</font>
<font color="black">1428.     builders should provide implementations which do the right thing</font>
<font color="black">1429.     using information available to it.</font>
<font color="black">1430. </font>
<font color="green">1431.     &quot;&quot;&quot;</font>
<font color="black">1432. </font>
<font color="green">1433.     __slots__ = 'tagName',</font>
<font color="black">1434. </font>
<font color="green">1435.     def __init__(self, name):</font>
<font color="red">1436.         self.tagName = name</font>
<font color="black">1437. </font>
<font color="green">1438.     def getAttributeType(self, aname):</font>
<font color="red">1439.         return _no_type</font>
<font color="black">1440. </font>
<font color="green">1441.     def getAttributeTypeNS(self, namespaceURI, localName):</font>
<font color="red">1442.         return _no_type</font>
<font color="black">1443. </font>
<font color="green">1444.     def isElementContent(self):</font>
<font color="red">1445.         return False</font>
<font color="black">1446. </font>
<font color="green">1447.     def isEmpty(self):</font>
<font color="black">1448.         &quot;&quot;&quot;Returns true iff this element is declared to have an EMPTY</font>
<font color="black">1449.         content model.&quot;&quot;&quot;</font>
<font color="red">1450.         return False</font>
<font color="black">1451. </font>
<font color="green">1452.     def isId(self, aname):</font>
<font color="black">1453.         &quot;&quot;&quot;Returns true iff the named attribute is a DTD-style ID.&quot;&quot;&quot;</font>
<font color="red">1454.         return False</font>
<font color="black">1455. </font>
<font color="green">1456.     def isIdNS(self, namespaceURI, localName):</font>
<font color="black">1457.         &quot;&quot;&quot;Returns true iff the identified attribute is a DTD-style ID.&quot;&quot;&quot;</font>
<font color="red">1458.         return False</font>
<font color="black">1459. </font>
<font color="green">1460.     def __getstate__(self):</font>
<font color="red">1461.         return self.tagName</font>
<font color="black">1462. </font>
<font color="green">1463.     def __setstate__(self, state):</font>
<font color="red">1464.         self.tagName = state</font>
<font color="black">1465. </font>
<font color="green">1466. def _clear_id_cache(node):</font>
<font color="red">1467.     if node.nodeType == Node.DOCUMENT_NODE:</font>
<font color="red">1468.         node._id_cache.clear()</font>
<font color="red">1469.         node._id_search_stack = None</font>
<font color="red">1470.     elif _in_document(node):</font>
<font color="red">1471.         node.ownerDocument._id_cache.clear()</font>
<font color="red">1472.         node.ownerDocument._id_search_stack= None</font>
<font color="black">1473. </font>
<font color="green">1474. class Document(Node, DocumentLS):</font>
<font color="green">1475.     _child_node_types = (Node.ELEMENT_NODE, Node.PROCESSING_INSTRUCTION_NODE,</font>
<font color="green">1476.                          Node.COMMENT_NODE, Node.DOCUMENT_TYPE_NODE)</font>
<font color="black">1477. </font>
<font color="green">1478.     nodeType = Node.DOCUMENT_NODE</font>
<font color="green">1479.     nodeName = &quot;#document&quot;</font>
<font color="green">1480.     nodeValue = None</font>
<font color="green">1481.     attributes = None</font>
<font color="green">1482.     doctype = None</font>
<font color="green">1483.     parentNode = None</font>
<font color="green">1484.     previousSibling = nextSibling = None</font>
<font color="black">1485. </font>
<font color="green">1486.     implementation = DOMImplementation()</font>
<font color="black">1487. </font>
<font color="black">1488.     # Document attributes from Level 3 (WD 9 April 2002)</font>
<font color="black">1489. </font>
<font color="green">1490.     actualEncoding = None</font>
<font color="green">1491.     encoding = None</font>
<font color="green">1492.     standalone = None</font>
<font color="green">1493.     version = None</font>
<font color="green">1494.     strictErrorChecking = False</font>
<font color="green">1495.     errorHandler = None</font>
<font color="green">1496.     documentURI = None</font>
<font color="black">1497. </font>
<font color="green">1498.     _magic_id_count = 0</font>
<font color="black">1499. </font>
<font color="green">1500.     def __init__(self):</font>
<font color="red">1501.         self.childNodes = NodeList()</font>
<font color="black">1502.         # mapping of (namespaceURI, localName) -&gt; ElementInfo</font>
<font color="black">1503.         #        and tagName -&gt; ElementInfo</font>
<font color="red">1504.         self._elem_info = {}</font>
<font color="red">1505.         self._id_cache = {}</font>
<font color="red">1506.         self._id_search_stack = None</font>
<font color="black">1507. </font>
<font color="green">1508.     def _get_elem_info(self, element):</font>
<font color="red">1509.         if element.namespaceURI:</font>
<font color="red">1510.             key = element.namespaceURI, element.localName</font>
<font color="black">1511.         else:</font>
<font color="red">1512.             key = element.tagName</font>
<font color="red">1513.         return self._elem_info.get(key)</font>
<font color="black">1514. </font>
<font color="green">1515.     def _get_actualEncoding(self):</font>
<font color="red">1516.         return self.actualEncoding</font>
<font color="black">1517. </font>
<font color="green">1518.     def _get_doctype(self):</font>
<font color="red">1519.         return self.doctype</font>
<font color="black">1520. </font>
<font color="green">1521.     def _get_documentURI(self):</font>
<font color="red">1522.         return self.documentURI</font>
<font color="black">1523. </font>
<font color="green">1524.     def _get_encoding(self):</font>
<font color="red">1525.         return self.encoding</font>
<font color="black">1526. </font>
<font color="green">1527.     def _get_errorHandler(self):</font>
<font color="red">1528.         return self.errorHandler</font>
<font color="black">1529. </font>
<font color="green">1530.     def _get_standalone(self):</font>
<font color="red">1531.         return self.standalone</font>
<font color="black">1532. </font>
<font color="green">1533.     def _get_strictErrorChecking(self):</font>
<font color="red">1534.         return self.strictErrorChecking</font>
<font color="black">1535. </font>
<font color="green">1536.     def _get_version(self):</font>
<font color="red">1537.         return self.version</font>
<font color="black">1538. </font>
<font color="green">1539.     def appendChild(self, node):</font>
<font color="red">1540.         if node.nodeType not in self._child_node_types:</font>
<font color="red">1541.             raise xml.dom.HierarchyRequestErr(</font>
<font color="red">1542.                 &quot;%s cannot be child of %s&quot; % (repr(node), repr(self)))</font>
<font color="red">1543.         if node.parentNode is not None:</font>
<font color="black">1544.             # This needs to be done before the next test since this</font>
<font color="black">1545.             # may *be* the document element, in which case it should</font>
<font color="black">1546.             # end up re-ordered to the end.</font>
<font color="red">1547.             node.parentNode.removeChild(node)</font>
<font color="black">1548. </font>
<font color="red">1549.         if node.nodeType == Node.ELEMENT_NODE \</font>
<font color="red">1550.            and self._get_documentElement():</font>
<font color="red">1551.             raise xml.dom.HierarchyRequestErr(</font>
<font color="red">1552.                 &quot;two document elements disallowed&quot;)</font>
<font color="red">1553.         return Node.appendChild(self, node)</font>
<font color="black">1554. </font>
<font color="green">1555.     def removeChild(self, oldChild):</font>
<font color="red">1556.         try:</font>
<font color="red">1557.             self.childNodes.remove(oldChild)</font>
<font color="red">1558.         except ValueError:</font>
<font color="red">1559.             raise xml.dom.NotFoundErr()</font>
<font color="red">1560.         oldChild.nextSibling = oldChild.previousSibling = None</font>
<font color="red">1561.         oldChild.parentNode = None</font>
<font color="red">1562.         if self.documentElement is oldChild:</font>
<font color="red">1563.             self.documentElement = None</font>
<font color="black">1564. </font>
<font color="red">1565.         return oldChild</font>
<font color="black">1566. </font>
<font color="green">1567.     def _get_documentElement(self):</font>
<font color="red">1568.         for node in self.childNodes:</font>
<font color="red">1569.             if node.nodeType == Node.ELEMENT_NODE:</font>
<font color="red">1570.                 return node</font>
<font color="black">1571. </font>
<font color="green">1572.     def unlink(self):</font>
<font color="red">1573.         if self.doctype is not None:</font>
<font color="red">1574.             self.doctype.unlink()</font>
<font color="red">1575.             self.doctype = None</font>
<font color="red">1576.         Node.unlink(self)</font>
<font color="black">1577. </font>
<font color="green">1578.     def cloneNode(self, deep):</font>
<font color="red">1579.         if not deep:</font>
<font color="red">1580.             return None</font>
<font color="red">1581.         clone = self.implementation.createDocument(None, None, None)</font>
<font color="red">1582.         clone.encoding = self.encoding</font>
<font color="red">1583.         clone.standalone = self.standalone</font>
<font color="red">1584.         clone.version = self.version</font>
<font color="red">1585.         for n in self.childNodes:</font>
<font color="red">1586.             childclone = _clone_node(n, deep, clone)</font>
<font color="red">1587.             assert childclone.ownerDocument.isSameNode(clone)</font>
<font color="red">1588.             clone.childNodes.append(childclone)</font>
<font color="red">1589.             if childclone.nodeType == Node.DOCUMENT_NODE:</font>
<font color="red">1590.                 assert clone.documentElement is None</font>
<font color="red">1591.             elif childclone.nodeType == Node.DOCUMENT_TYPE_NODE:</font>
<font color="red">1592.                 assert clone.doctype is None</font>
<font color="red">1593.                 clone.doctype = childclone</font>
<font color="red">1594.             childclone.parentNode = clone</font>
<font color="red">1595.         self._call_user_data_handler(xml.dom.UserDataHandler.NODE_CLONED,</font>
<font color="red">1596.                                      self, clone)</font>
<font color="red">1597.         return clone</font>
<font color="black">1598. </font>
<font color="green">1599.     def createDocumentFragment(self):</font>
<font color="red">1600.         d = DocumentFragment()</font>
<font color="red">1601.         d.ownerDocument = self</font>
<font color="red">1602.         return d</font>
<font color="black">1603. </font>
<font color="green">1604.     def createElement(self, tagName):</font>
<font color="red">1605.         e = Element(tagName)</font>
<font color="red">1606.         e.ownerDocument = self</font>
<font color="red">1607.         return e</font>
<font color="black">1608. </font>
<font color="green">1609.     def createTextNode(self, data):</font>
<font color="red">1610.         if not isinstance(data, StringTypes):</font>
<font color="red">1611.             raise TypeError, &quot;node contents must be a string&quot;</font>
<font color="red">1612.         t = Text()</font>
<font color="red">1613.         t.data = data</font>
<font color="red">1614.         t.ownerDocument = self</font>
<font color="red">1615.         return t</font>
<font color="black">1616. </font>
<font color="green">1617.     def createCDATASection(self, data):</font>
<font color="red">1618.         if not isinstance(data, StringTypes):</font>
<font color="red">1619.             raise TypeError, &quot;node contents must be a string&quot;</font>
<font color="red">1620.         c = CDATASection()</font>
<font color="red">1621.         c.data = data</font>
<font color="red">1622.         c.ownerDocument = self</font>
<font color="red">1623.         return c</font>
<font color="black">1624. </font>
<font color="green">1625.     def createComment(self, data):</font>
<font color="red">1626.         c = Comment(data)</font>
<font color="red">1627.         c.ownerDocument = self</font>
<font color="red">1628.         return c</font>
<font color="black">1629. </font>
<font color="green">1630.     def createProcessingInstruction(self, target, data):</font>
<font color="red">1631.         p = ProcessingInstruction(target, data)</font>
<font color="red">1632.         p.ownerDocument = self</font>
<font color="red">1633.         return p</font>
<font color="black">1634. </font>
<font color="green">1635.     def createAttribute(self, qName):</font>
<font color="red">1636.         a = Attr(qName)</font>
<font color="red">1637.         a.ownerDocument = self</font>
<font color="red">1638.         a.value = &quot;&quot;</font>
<font color="red">1639.         return a</font>
<font color="black">1640. </font>
<font color="green">1641.     def createElementNS(self, namespaceURI, qualifiedName):</font>
<font color="red">1642.         prefix, localName = _nssplit(qualifiedName)</font>
<font color="red">1643.         e = Element(qualifiedName, namespaceURI, prefix)</font>
<font color="red">1644.         e.ownerDocument = self</font>
<font color="red">1645.         return e</font>
<font color="black">1646. </font>
<font color="green">1647.     def createAttributeNS(self, namespaceURI, qualifiedName):</font>
<font color="red">1648.         prefix, localName = _nssplit(qualifiedName)</font>
<font color="red">1649.         a = Attr(qualifiedName, namespaceURI, localName, prefix)</font>
<font color="red">1650.         a.ownerDocument = self</font>
<font color="red">1651.         a.value = &quot;&quot;</font>
<font color="red">1652.         return a</font>
<font color="black">1653. </font>
<font color="black">1654.     # A couple of implementation-specific helpers to create node types</font>
<font color="black">1655.     # not supported by the W3C DOM specs:</font>
<font color="black">1656. </font>
<font color="green">1657.     def _create_entity(self, name, publicId, systemId, notationName):</font>
<font color="red">1658.         e = Entity(name, publicId, systemId, notationName)</font>
<font color="red">1659.         e.ownerDocument = self</font>
<font color="red">1660.         return e</font>
<font color="black">1661. </font>
<font color="green">1662.     def _create_notation(self, name, publicId, systemId):</font>
<font color="red">1663.         n = Notation(name, publicId, systemId)</font>
<font color="red">1664.         n.ownerDocument = self</font>
<font color="red">1665.         return n</font>
<font color="black">1666. </font>
<font color="green">1667.     def getElementById(self, id):</font>
<font color="red">1668.         if id in self._id_cache:</font>
<font color="red">1669.             return self._id_cache[id]</font>
<font color="red">1670.         if not (self._elem_info or self._magic_id_count):</font>
<font color="red">1671.             return None</font>
<font color="black">1672. </font>
<font color="red">1673.         stack = self._id_search_stack</font>
<font color="red">1674.         if stack is None:</font>
<font color="black">1675.             # we never searched before, or the cache has been cleared</font>
<font color="red">1676.             stack = [self.documentElement]</font>
<font color="red">1677.             self._id_search_stack = stack</font>
<font color="red">1678.         elif not stack:</font>
<font color="black">1679.             # Previous search was completed and cache is still valid;</font>
<font color="black">1680.             # no matching node.</font>
<font color="red">1681.             return None</font>
<font color="black">1682. </font>
<font color="red">1683.         result = None</font>
<font color="red">1684.         while stack:</font>
<font color="red">1685.             node = stack.pop()</font>
<font color="black">1686.             # add child elements to stack for continued searching</font>
<font color="red">1687.             stack.extend([child for child in node.childNodes</font>
<font color="red">1688.                           if child.nodeType in _nodeTypes_with_children])</font>
<font color="black">1689.             # check this node</font>
<font color="red">1690.             info = self._get_elem_info(node)</font>
<font color="red">1691.             if info:</font>
<font color="black">1692.                 # We have to process all ID attributes before</font>
<font color="black">1693.                 # returning in order to get all the attributes set to</font>
<font color="black">1694.                 # be IDs using Element.setIdAttribute*().</font>
<font color="red">1695.                 for attr in node.attributes.values():</font>
<font color="red">1696.                     if attr.namespaceURI:</font>
<font color="red">1697.                         if info.isIdNS(attr.namespaceURI, attr.localName):</font>
<font color="red">1698.                             self._id_cache[attr.value] = node</font>
<font color="red">1699.                             if attr.value == id:</font>
<font color="red">1700.                                 result = node</font>
<font color="red">1701.                             elif not node._magic_id_nodes:</font>
<font color="red">1702.                                 break</font>
<font color="red">1703.                     elif info.isId(attr.name):</font>
<font color="red">1704.                         self._id_cache[attr.value] = node</font>
<font color="red">1705.                         if attr.value == id:</font>
<font color="red">1706.                             result = node</font>
<font color="red">1707.                         elif not node._magic_id_nodes:</font>
<font color="red">1708.                             break</font>
<font color="red">1709.                     elif attr._is_id:</font>
<font color="red">1710.                         self._id_cache[attr.value] = node</font>
<font color="red">1711.                         if attr.value == id:</font>
<font color="red">1712.                             result = node</font>
<font color="red">1713.                         elif node._magic_id_nodes == 1:</font>
<font color="red">1714.                             break</font>
<font color="red">1715.             elif node._magic_id_nodes:</font>
<font color="red">1716.                 for attr in node.attributes.values():</font>
<font color="red">1717.                     if attr._is_id:</font>
<font color="red">1718.                         self._id_cache[attr.value] = node</font>
<font color="red">1719.                         if attr.value == id:</font>
<font color="red">1720.                             result = node</font>
<font color="red">1721.             if result is not None:</font>
<font color="red">1722.                 break</font>
<font color="red">1723.         return result</font>
<font color="black">1724. </font>
<font color="green">1725.     def getElementsByTagName(self, name):</font>
<font color="red">1726.         return _get_elements_by_tagName_helper(self, name, NodeList())</font>
<font color="black">1727. </font>
<font color="green">1728.     def getElementsByTagNameNS(self, namespaceURI, localName):</font>
<font color="red">1729.         return _get_elements_by_tagName_ns_helper(</font>
<font color="red">1730.             self, namespaceURI, localName, NodeList())</font>
<font color="black">1731. </font>
<font color="green">1732.     def isSupported(self, feature, version):</font>
<font color="red">1733.         return self.implementation.hasFeature(feature, version)</font>
<font color="black">1734. </font>
<font color="green">1735.     def importNode(self, node, deep):</font>
<font color="red">1736.         if node.nodeType == Node.DOCUMENT_NODE:</font>
<font color="red">1737.             raise xml.dom.NotSupportedErr(&quot;cannot import document nodes&quot;)</font>
<font color="red">1738.         elif node.nodeType == Node.DOCUMENT_TYPE_NODE:</font>
<font color="red">1739.             raise xml.dom.NotSupportedErr(&quot;cannot import document type nodes&quot;)</font>
<font color="red">1740.         return _clone_node(node, deep, self)</font>
<font color="black">1741. </font>
<font color="green">1742.     def writexml(self, writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;,</font>
<font color="green">1743.                  encoding = None):</font>
<font color="red">1744.         if encoding is None:</font>
<font color="red">1745.             writer.write('&lt;?xml version=&quot;1.0&quot; ?&gt;'+newl)</font>
<font color="black">1746.         else:</font>
<font color="red">1747.             writer.write('&lt;?xml version=&quot;1.0&quot; encoding=&quot;%s&quot;?&gt;%s' % (encoding, newl))</font>
<font color="red">1748.         for node in self.childNodes:</font>
<font color="red">1749.             node.writexml(writer, indent, addindent, newl)</font>
<font color="black">1750. </font>
<font color="black">1751.     # DOM Level 3 (WD 9 April 2002)</font>
<font color="black">1752. </font>
<font color="green">1753.     def renameNode(self, n, namespaceURI, name):</font>
<font color="red">1754.         if n.ownerDocument is not self:</font>
<font color="red">1755.             raise xml.dom.WrongDocumentErr(</font>
<font color="red">1756.                 &quot;cannot rename nodes from other documents;\n&quot;</font>
<font color="red">1757.                 &quot;expected %s,\nfound %s&quot; % (self, n.ownerDocument))</font>
<font color="red">1758.         if n.nodeType not in (Node.ELEMENT_NODE, Node.ATTRIBUTE_NODE):</font>
<font color="red">1759.             raise xml.dom.NotSupportedErr(</font>
<font color="red">1760.                 &quot;renameNode() only applies to element and attribute nodes&quot;)</font>
<font color="red">1761.         if namespaceURI != EMPTY_NAMESPACE:</font>
<font color="red">1762.             if ':' in name:</font>
<font color="red">1763.                 prefix, localName = name.split(':', 1)</font>
<font color="red">1764.                 if (  prefix == &quot;xmlns&quot;</font>
<font color="red">1765.                       and namespaceURI != xml.dom.XMLNS_NAMESPACE):</font>
<font color="red">1766.                     raise xml.dom.NamespaceErr(</font>
<font color="red">1767.                         &quot;illegal use of 'xmlns' prefix&quot;)</font>
<font color="black">1768.             else:</font>
<font color="red">1769.                 if (  name == &quot;xmlns&quot;</font>
<font color="red">1770.                       and namespaceURI != xml.dom.XMLNS_NAMESPACE</font>
<font color="red">1771.                       and n.nodeType == Node.ATTRIBUTE_NODE):</font>
<font color="red">1772.                     raise xml.dom.NamespaceErr(</font>
<font color="red">1773.                         &quot;illegal use of the 'xmlns' attribute&quot;)</font>
<font color="red">1774.                 prefix = None</font>
<font color="red">1775.                 localName = name</font>
<font color="black">1776.         else:</font>
<font color="red">1777.             prefix = None</font>
<font color="red">1778.             localName = None</font>
<font color="red">1779.         if n.nodeType == Node.ATTRIBUTE_NODE:</font>
<font color="red">1780.             element = n.ownerElement</font>
<font color="red">1781.             if element is not None:</font>
<font color="red">1782.                 is_id = n._is_id</font>
<font color="red">1783.                 element.removeAttributeNode(n)</font>
<font color="black">1784.         else:</font>
<font color="red">1785.             element = None</font>
<font color="black">1786.         # avoid __setattr__</font>
<font color="red">1787.         d = n.__dict__</font>
<font color="red">1788.         d['prefix'] = prefix</font>
<font color="red">1789.         d['localName'] = localName</font>
<font color="red">1790.         d['namespaceURI'] = namespaceURI</font>
<font color="red">1791.         d['nodeName'] = name</font>
<font color="red">1792.         if n.nodeType == Node.ELEMENT_NODE:</font>
<font color="red">1793.             d['tagName'] = name</font>
<font color="black">1794.         else:</font>
<font color="black">1795.             # attribute node</font>
<font color="red">1796.             d['name'] = name</font>
<font color="red">1797.             if element is not None:</font>
<font color="red">1798.                 element.setAttributeNode(n)</font>
<font color="red">1799.                 if is_id:</font>
<font color="red">1800.                     element.setIdAttributeNode(n)</font>
<font color="black">1801.         # It's not clear from a semantic perspective whether we should</font>
<font color="black">1802.         # call the user data handlers for the NODE_RENAMED event since</font>
<font color="black">1803.         # we're re-using the existing node.  The draft spec has been</font>
<font color="black">1804.         # interpreted as meaning &quot;no, don't call the handler unless a</font>
<font color="black">1805.         # new node is created.&quot;</font>
<font color="red">1806.         return n</font>
<font color="black">1807. </font>
<font color="green">1808. defproperty(Document, &quot;documentElement&quot;,</font>
<font color="green">1809.             doc=&quot;Top-level element of this document.&quot;)</font>
<font color="black">1810. </font>
<font color="black">1811. </font>
<font color="green">1812. def _clone_node(node, deep, newOwnerDocument):</font>
<font color="black">1813.     &quot;&quot;&quot;</font>
<font color="black">1814.     Clone a node and give it the new owner document.</font>
<font color="black">1815.     Called by Node.cloneNode and Document.importNode</font>
<font color="black">1816.     &quot;&quot;&quot;</font>
<font color="red">1817.     if node.ownerDocument.isSameNode(newOwnerDocument):</font>
<font color="red">1818.         operation = xml.dom.UserDataHandler.NODE_CLONED</font>
<font color="black">1819.     else:</font>
<font color="red">1820.         operation = xml.dom.UserDataHandler.NODE_IMPORTED</font>
<font color="red">1821.     if node.nodeType == Node.ELEMENT_NODE:</font>
<font color="red">1822.         clone = newOwnerDocument.createElementNS(node.namespaceURI,</font>
<font color="red">1823.                                                  node.nodeName)</font>
<font color="red">1824.         for attr in node.attributes.values():</font>
<font color="red">1825.             clone.setAttributeNS(attr.namespaceURI, attr.nodeName, attr.value)</font>
<font color="red">1826.             a = clone.getAttributeNodeNS(attr.namespaceURI, attr.localName)</font>
<font color="red">1827.             a.specified = attr.specified</font>
<font color="black">1828. </font>
<font color="red">1829.         if deep:</font>
<font color="red">1830.             for child in node.childNodes:</font>
<font color="red">1831.                 c = _clone_node(child, deep, newOwnerDocument)</font>
<font color="red">1832.                 clone.appendChild(c)</font>
<font color="black">1833. </font>
<font color="red">1834.     elif node.nodeType == Node.DOCUMENT_FRAGMENT_NODE:</font>
<font color="red">1835.         clone = newOwnerDocument.createDocumentFragment()</font>
<font color="red">1836.         if deep:</font>
<font color="red">1837.             for child in node.childNodes:</font>
<font color="red">1838.                 c = _clone_node(child, deep, newOwnerDocument)</font>
<font color="red">1839.                 clone.appendChild(c)</font>
<font color="black">1840. </font>
<font color="red">1841.     elif node.nodeType == Node.TEXT_NODE:</font>
<font color="red">1842.         clone = newOwnerDocument.createTextNode(node.data)</font>
<font color="red">1843.     elif node.nodeType == Node.CDATA_SECTION_NODE:</font>
<font color="red">1844.         clone = newOwnerDocument.createCDATASection(node.data)</font>
<font color="red">1845.     elif node.nodeType == Node.PROCESSING_INSTRUCTION_NODE:</font>
<font color="red">1846.         clone = newOwnerDocument.createProcessingInstruction(node.target,</font>
<font color="red">1847.                                                              node.data)</font>
<font color="red">1848.     elif node.nodeType == Node.COMMENT_NODE:</font>
<font color="red">1849.         clone = newOwnerDocument.createComment(node.data)</font>
<font color="red">1850.     elif node.nodeType == Node.ATTRIBUTE_NODE:</font>
<font color="red">1851.         clone = newOwnerDocument.createAttributeNS(node.namespaceURI,</font>
<font color="red">1852.                                                    node.nodeName)</font>
<font color="red">1853.         clone.specified = True</font>
<font color="red">1854.         clone.value = node.value</font>
<font color="red">1855.     elif node.nodeType == Node.DOCUMENT_TYPE_NODE:</font>
<font color="red">1856.         assert node.ownerDocument is not newOwnerDocument</font>
<font color="red">1857.         operation = xml.dom.UserDataHandler.NODE_IMPORTED</font>
<font color="red">1858.         clone = newOwnerDocument.implementation.createDocumentType(</font>
<font color="red">1859.             node.name, node.publicId, node.systemId)</font>
<font color="red">1860.         clone.ownerDocument = newOwnerDocument</font>
<font color="red">1861.         if deep:</font>
<font color="red">1862.             clone.entities._seq = []</font>
<font color="red">1863.             clone.notations._seq = []</font>
<font color="red">1864.             for n in node.notations._seq:</font>
<font color="red">1865.                 notation = Notation(n.nodeName, n.publicId, n.systemId)</font>
<font color="red">1866.                 notation.ownerDocument = newOwnerDocument</font>
<font color="red">1867.                 clone.notations._seq.append(notation)</font>
<font color="red">1868.                 if hasattr(n, '_call_user_data_handler'):</font>
<font color="red">1869.                     n._call_user_data_handler(operation, n, notation)</font>
<font color="red">1870.             for e in node.entities._seq:</font>
<font color="red">1871.                 entity = Entity(e.nodeName, e.publicId, e.systemId,</font>
<font color="red">1872.                                 e.notationName)</font>
<font color="red">1873.                 entity.actualEncoding = e.actualEncoding</font>
<font color="red">1874.                 entity.encoding = e.encoding</font>
<font color="red">1875.                 entity.version = e.version</font>
<font color="red">1876.                 entity.ownerDocument = newOwnerDocument</font>
<font color="red">1877.                 clone.entities._seq.append(entity)</font>
<font color="red">1878.                 if hasattr(e, '_call_user_data_handler'):</font>
<font color="red">1879.                     e._call_user_data_handler(operation, n, entity)</font>
<font color="black">1880.     else:</font>
<font color="black">1881.         # Note the cloning of Document and DocumentType nodes is</font>
<font color="black">1882.         # implementation specific.  minidom handles those cases</font>
<font color="black">1883.         # directly in the cloneNode() methods.</font>
<font color="red">1884.         raise xml.dom.NotSupportedErr(&quot;Cannot clone node %s&quot; % repr(node))</font>
<font color="black">1885. </font>
<font color="black">1886.     # Check for _call_user_data_handler() since this could conceivably</font>
<font color="black">1887.     # used with other DOM implementations (one of the FourThought</font>
<font color="black">1888.     # DOMs, perhaps?).</font>
<font color="red">1889.     if hasattr(node, '_call_user_data_handler'):</font>
<font color="red">1890.         node._call_user_data_handler(operation, node, clone)</font>
<font color="red">1891.     return clone</font>
<font color="black">1892. </font>
<font color="black">1893. </font>
<font color="green">1894. def _nssplit(qualifiedName):</font>
<font color="red">1895.     fields = qualifiedName.split(':', 1)</font>
<font color="red">1896.     if len(fields) == 2:</font>
<font color="red">1897.         return fields</font>
<font color="black">1898.     else:</font>
<font color="red">1899.         return (None, fields[0])</font>
<font color="black">1900. </font>
<font color="black">1901. </font>
<font color="green">1902. def _get_StringIO():</font>
<font color="black">1903.     # we can't use cStringIO since it doesn't support Unicode strings</font>
<font color="red">1904.     from StringIO import StringIO</font>
<font color="red">1905.     return StringIO()</font>
<font color="black">1906. </font>
<font color="green">1907. def _do_pulldom_parse(func, args, kwargs):</font>
<font color="red">1908.     events = func(*args, **kwargs)</font>
<font color="red">1909.     toktype, rootNode = events.getEvent()</font>
<font color="red">1910.     events.expandNode(rootNode)</font>
<font color="red">1911.     events.clear()</font>
<font color="red">1912.     return rootNode</font>
<font color="black">1913. </font>
<font color="green">1914. def parse(file, parser=None, bufsize=None):</font>
<font color="black">1915.     &quot;&quot;&quot;Parse a file into a DOM by filename or file object.&quot;&quot;&quot;</font>
<font color="red">1916.     if parser is None and not bufsize:</font>
<font color="red">1917.         from xml.dom import expatbuilder</font>
<font color="red">1918.         return expatbuilder.parse(file)</font>
<font color="black">1919.     else:</font>
<font color="red">1920.         from xml.dom import pulldom</font>
<font color="red">1921.         return _do_pulldom_parse(pulldom.parse, (file,),</font>
<font color="red">1922.             {'parser': parser, 'bufsize': bufsize})</font>
<font color="black">1923. </font>
<font color="green">1924. def parseString(string, parser=None):</font>
<font color="black">1925.     &quot;&quot;&quot;Parse a file into a DOM from a string.&quot;&quot;&quot;</font>
<font color="red">1926.     if parser is None:</font>
<font color="red">1927.         from xml.dom import expatbuilder</font>
<font color="red">1928.         return expatbuilder.parseString(string)</font>
<font color="black">1929.     else:</font>
<font color="red">1930.         from xml.dom import pulldom</font>
<font color="red">1931.         return _do_pulldom_parse(pulldom.parseString, (string,),</font>
<font color="red">1932.                                  {'parser': parser})</font>
<font color="black">1933. </font>
<font color="green">1934. def getDOMImplementation(features=None):</font>
<font color="red">1935.     if features:</font>
<font color="red">1936.         if isinstance(features, StringTypes):</font>
<font color="red">1937.             features = domreg._parse_feature_string(features)</font>
<font color="red">1938.         for f, v in features:</font>
<font color="red">1939.             if not Document.implementation.hasFeature(f, v):</font>
<font color="red">1940.                 return None</font>
<font color="red">1941.     return Document.implementation</font>
</pre>

