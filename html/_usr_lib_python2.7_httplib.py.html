source file: <b>/usr/lib/python2.7/httplib.py</b><br>


file stats: <b>776 lines, 226 executed: 29.1% covered</b>
<pre>
<font color="black">   1. r&quot;&quot;&quot;HTTP/1.1 client library</font>
<font color="black">   2. </font>
<font color="black">   3. &lt;intro stuff goes here&gt;</font>
<font color="black">   4. &lt;other stuff, too&gt;</font>
<font color="black">   5. </font>
<font color="black">   6. HTTPConnection goes through a number of &quot;states&quot;, which define when a client</font>
<font color="black">   7. may legally make another request or fetch the response for a particular</font>
<font color="black">   8. request. This diagram details these state transitions:</font>
<font color="black">   9. </font>
<font color="black">  10.     (null)</font>
<font color="black">  11.       |</font>
<font color="black">  12.       | HTTPConnection()</font>
<font color="black">  13.       v</font>
<font color="black">  14.     Idle</font>
<font color="black">  15.       |</font>
<font color="black">  16.       | putrequest()</font>
<font color="black">  17.       v</font>
<font color="black">  18.     Request-started</font>
<font color="black">  19.       |</font>
<font color="black">  20.       | ( putheader() )*  endheaders()</font>
<font color="black">  21.       v</font>
<font color="black">  22.     Request-sent</font>
<font color="black">  23.       |</font>
<font color="black">  24.       | response = getresponse()</font>
<font color="black">  25.       v</font>
<font color="black">  26.     Unread-response   [Response-headers-read]</font>
<font color="black">  27.       |\____________________</font>
<font color="black">  28.       |                     |</font>
<font color="black">  29.       | response.read()     | putrequest()</font>
<font color="black">  30.       v                     v</font>
<font color="black">  31.     Idle                  Req-started-unread-response</font>
<font color="black">  32.                      ______/|</font>
<font color="black">  33.                    /        |</font>
<font color="black">  34.    response.read() |        | ( putheader() )*  endheaders()</font>
<font color="black">  35.                    v        v</font>
<font color="black">  36.        Request-started    Req-sent-unread-response</font>
<font color="black">  37.                             |</font>
<font color="black">  38.                             | response.read()</font>
<font color="black">  39.                             v</font>
<font color="black">  40.                           Request-sent</font>
<font color="black">  41. </font>
<font color="black">  42. This diagram presents the following rules:</font>
<font color="black">  43.   -- a second request may not be started until {response-headers-read}</font>
<font color="black">  44.   -- a response [object] cannot be retrieved until {request-sent}</font>
<font color="black">  45.   -- there is no differentiation between an unread response body and a</font>
<font color="black">  46.      partially read response body</font>
<font color="black">  47. </font>
<font color="black">  48. Note: this enforcement is applied by the HTTPConnection class. The</font>
<font color="black">  49.       HTTPResponse class does not enforce this state machine, which</font>
<font color="black">  50.       implies sophisticated clients may accelerate the request/response</font>
<font color="black">  51.       pipeline. Caution should be taken, though: accelerating the states</font>
<font color="black">  52.       beyond the above pattern may imply knowledge of the server's</font>
<font color="black">  53.       connection-close behavior for certain requests. For example, it</font>
<font color="black">  54.       is impossible to tell whether the server will close the connection</font>
<font color="black">  55.       UNTIL the response headers have been read; this means that further</font>
<font color="black">  56.       requests cannot be placed into the pipeline until it is known that</font>
<font color="black">  57.       the server will NOT be closing the connection.</font>
<font color="black">  58. </font>
<font color="black">  59. Logical State                  __state            __response</font>
<font color="black">  60. -------------                  -------            ----------</font>
<font color="black">  61. Idle                           _CS_IDLE           None</font>
<font color="black">  62. Request-started                _CS_REQ_STARTED    None</font>
<font color="black">  63. Request-sent                   _CS_REQ_SENT       None</font>
<font color="black">  64. Unread-response                _CS_IDLE           &lt;response_class&gt;</font>
<font color="black">  65. Req-started-unread-response    _CS_REQ_STARTED    &lt;response_class&gt;</font>
<font color="black">  66. Req-sent-unread-response       _CS_REQ_SENT       &lt;response_class&gt;</font>
<font color="green">  67. &quot;&quot;&quot;</font>
<font color="black">  68. </font>
<font color="green">  69. from array import array</font>
<font color="green">  70. import os</font>
<font color="green">  71. import socket</font>
<font color="green">  72. from sys import py3kwarning</font>
<font color="green">  73. from urlparse import urlsplit</font>
<font color="green">  74. import warnings</font>
<font color="green">  75. with warnings.catch_warnings():</font>
<font color="green">  76.     if py3kwarning:</font>
<font color="red">  77.         warnings.filterwarnings(&quot;ignore&quot;, &quot;.*mimetools has been removed&quot;,</font>
<font color="red">  78.                                 DeprecationWarning)</font>
<font color="green">  79.     import mimetools</font>
<font color="black">  80. </font>
<font color="green">  81. try:</font>
<font color="green">  82.     from cStringIO import StringIO</font>
<font color="red">  83. except ImportError:</font>
<font color="red">  84.     from StringIO import StringIO</font>
<font color="black">  85. </font>
<font color="green">  86. __all__ = [&quot;HTTP&quot;, &quot;HTTPResponse&quot;, &quot;HTTPConnection&quot;,</font>
<font color="green">  87.            &quot;HTTPException&quot;, &quot;NotConnected&quot;, &quot;UnknownProtocol&quot;,</font>
<font color="green">  88.            &quot;UnknownTransferEncoding&quot;, &quot;UnimplementedFileMode&quot;,</font>
<font color="green">  89.            &quot;IncompleteRead&quot;, &quot;InvalidURL&quot;, &quot;ImproperConnectionState&quot;,</font>
<font color="green">  90.            &quot;CannotSendRequest&quot;, &quot;CannotSendHeader&quot;, &quot;ResponseNotReady&quot;,</font>
<font color="green">  91.            &quot;BadStatusLine&quot;, &quot;error&quot;, &quot;responses&quot;]</font>
<font color="black">  92. </font>
<font color="green">  93. HTTP_PORT = 80</font>
<font color="green">  94. HTTPS_PORT = 443</font>
<font color="black">  95. </font>
<font color="green">  96. _UNKNOWN = 'UNKNOWN'</font>
<font color="black">  97. </font>
<font color="black">  98. # connection states</font>
<font color="green">  99. _CS_IDLE = 'Idle'</font>
<font color="green"> 100. _CS_REQ_STARTED = 'Request-started'</font>
<font color="green"> 101. _CS_REQ_SENT = 'Request-sent'</font>
<font color="black"> 102. </font>
<font color="black"> 103. # status codes</font>
<font color="black"> 104. # informational</font>
<font color="green"> 105. CONTINUE = 100</font>
<font color="green"> 106. SWITCHING_PROTOCOLS = 101</font>
<font color="green"> 107. PROCESSING = 102</font>
<font color="black"> 108. </font>
<font color="black"> 109. # successful</font>
<font color="green"> 110. OK = 200</font>
<font color="green"> 111. CREATED = 201</font>
<font color="green"> 112. ACCEPTED = 202</font>
<font color="green"> 113. NON_AUTHORITATIVE_INFORMATION = 203</font>
<font color="green"> 114. NO_CONTENT = 204</font>
<font color="green"> 115. RESET_CONTENT = 205</font>
<font color="green"> 116. PARTIAL_CONTENT = 206</font>
<font color="green"> 117. MULTI_STATUS = 207</font>
<font color="green"> 118. IM_USED = 226</font>
<font color="black"> 119. </font>
<font color="black"> 120. # redirection</font>
<font color="green"> 121. MULTIPLE_CHOICES = 300</font>
<font color="green"> 122. MOVED_PERMANENTLY = 301</font>
<font color="green"> 123. FOUND = 302</font>
<font color="green"> 124. SEE_OTHER = 303</font>
<font color="green"> 125. NOT_MODIFIED = 304</font>
<font color="green"> 126. USE_PROXY = 305</font>
<font color="green"> 127. TEMPORARY_REDIRECT = 307</font>
<font color="black"> 128. </font>
<font color="black"> 129. # client error</font>
<font color="green"> 130. BAD_REQUEST = 400</font>
<font color="green"> 131. UNAUTHORIZED = 401</font>
<font color="green"> 132. PAYMENT_REQUIRED = 402</font>
<font color="green"> 133. FORBIDDEN = 403</font>
<font color="green"> 134. NOT_FOUND = 404</font>
<font color="green"> 135. METHOD_NOT_ALLOWED = 405</font>
<font color="green"> 136. NOT_ACCEPTABLE = 406</font>
<font color="green"> 137. PROXY_AUTHENTICATION_REQUIRED = 407</font>
<font color="green"> 138. REQUEST_TIMEOUT = 408</font>
<font color="green"> 139. CONFLICT = 409</font>
<font color="green"> 140. GONE = 410</font>
<font color="green"> 141. LENGTH_REQUIRED = 411</font>
<font color="green"> 142. PRECONDITION_FAILED = 412</font>
<font color="green"> 143. REQUEST_ENTITY_TOO_LARGE = 413</font>
<font color="green"> 144. REQUEST_URI_TOO_LONG = 414</font>
<font color="green"> 145. UNSUPPORTED_MEDIA_TYPE = 415</font>
<font color="green"> 146. REQUESTED_RANGE_NOT_SATISFIABLE = 416</font>
<font color="green"> 147. EXPECTATION_FAILED = 417</font>
<font color="green"> 148. UNPROCESSABLE_ENTITY = 422</font>
<font color="green"> 149. LOCKED = 423</font>
<font color="green"> 150. FAILED_DEPENDENCY = 424</font>
<font color="green"> 151. UPGRADE_REQUIRED = 426</font>
<font color="black"> 152. </font>
<font color="black"> 153. # server error</font>
<font color="green"> 154. INTERNAL_SERVER_ERROR = 500</font>
<font color="green"> 155. NOT_IMPLEMENTED = 501</font>
<font color="green"> 156. BAD_GATEWAY = 502</font>
<font color="green"> 157. SERVICE_UNAVAILABLE = 503</font>
<font color="green"> 158. GATEWAY_TIMEOUT = 504</font>
<font color="green"> 159. HTTP_VERSION_NOT_SUPPORTED = 505</font>
<font color="green"> 160. INSUFFICIENT_STORAGE = 507</font>
<font color="green"> 161. NOT_EXTENDED = 510</font>
<font color="black"> 162. </font>
<font color="black"> 163. # Mapping status codes to official W3C names</font>
<font color="green"> 164. responses = {</font>
<font color="green"> 165.     100: 'Continue',</font>
<font color="green"> 166.     101: 'Switching Protocols',</font>
<font color="black"> 167. </font>
<font color="green"> 168.     200: 'OK',</font>
<font color="green"> 169.     201: 'Created',</font>
<font color="green"> 170.     202: 'Accepted',</font>
<font color="green"> 171.     203: 'Non-Authoritative Information',</font>
<font color="green"> 172.     204: 'No Content',</font>
<font color="green"> 173.     205: 'Reset Content',</font>
<font color="green"> 174.     206: 'Partial Content',</font>
<font color="black"> 175. </font>
<font color="green"> 176.     300: 'Multiple Choices',</font>
<font color="green"> 177.     301: 'Moved Permanently',</font>
<font color="green"> 178.     302: 'Found',</font>
<font color="green"> 179.     303: 'See Other',</font>
<font color="green"> 180.     304: 'Not Modified',</font>
<font color="green"> 181.     305: 'Use Proxy',</font>
<font color="green"> 182.     306: '(Unused)',</font>
<font color="green"> 183.     307: 'Temporary Redirect',</font>
<font color="black"> 184. </font>
<font color="green"> 185.     400: 'Bad Request',</font>
<font color="green"> 186.     401: 'Unauthorized',</font>
<font color="green"> 187.     402: 'Payment Required',</font>
<font color="green"> 188.     403: 'Forbidden',</font>
<font color="green"> 189.     404: 'Not Found',</font>
<font color="green"> 190.     405: 'Method Not Allowed',</font>
<font color="green"> 191.     406: 'Not Acceptable',</font>
<font color="green"> 192.     407: 'Proxy Authentication Required',</font>
<font color="green"> 193.     408: 'Request Timeout',</font>
<font color="green"> 194.     409: 'Conflict',</font>
<font color="green"> 195.     410: 'Gone',</font>
<font color="green"> 196.     411: 'Length Required',</font>
<font color="green"> 197.     412: 'Precondition Failed',</font>
<font color="green"> 198.     413: 'Request Entity Too Large',</font>
<font color="green"> 199.     414: 'Request-URI Too Long',</font>
<font color="green"> 200.     415: 'Unsupported Media Type',</font>
<font color="green"> 201.     416: 'Requested Range Not Satisfiable',</font>
<font color="green"> 202.     417: 'Expectation Failed',</font>
<font color="black"> 203. </font>
<font color="green"> 204.     500: 'Internal Server Error',</font>
<font color="green"> 205.     501: 'Not Implemented',</font>
<font color="green"> 206.     502: 'Bad Gateway',</font>
<font color="green"> 207.     503: 'Service Unavailable',</font>
<font color="green"> 208.     504: 'Gateway Timeout',</font>
<font color="green"> 209.     505: 'HTTP Version Not Supported',</font>
<font color="black"> 210. }</font>
<font color="black"> 211. </font>
<font color="black"> 212. # maximal amount of data to read at one time in _safe_read</font>
<font color="green"> 213. MAXAMOUNT = 1048576</font>
<font color="black"> 214. </font>
<font color="black"> 215. # maximal line length when calling readline().</font>
<font color="green"> 216. _MAXLINE = 65536</font>
<font color="black"> 217. </font>
<font color="black"> 218. # maximum amount of headers accepted</font>
<font color="green"> 219. _MAXHEADERS = 100</font>
<font color="black"> 220. </font>
<font color="black"> 221. </font>
<font color="green"> 222. class HTTPMessage(mimetools.Message):</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def addheader(self, key, value):</font>
<font color="black"> 225.         &quot;&quot;&quot;Add header for field key handling repeats.&quot;&quot;&quot;</font>
<font color="red"> 226.         prev = self.dict.get(key)</font>
<font color="red"> 227.         if prev is None:</font>
<font color="red"> 228.             self.dict[key] = value</font>
<font color="black"> 229.         else:</font>
<font color="red"> 230.             combined = &quot;, &quot;.join((prev, value))</font>
<font color="red"> 231.             self.dict[key] = combined</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def addcontinue(self, key, more):</font>
<font color="black"> 234.         &quot;&quot;&quot;Add more field data from a continuation line.&quot;&quot;&quot;</font>
<font color="red"> 235.         prev = self.dict[key]</font>
<font color="red"> 236.         self.dict[key] = prev + &quot;\n &quot; + more</font>
<font color="black"> 237. </font>
<font color="green"> 238.     def readheaders(self):</font>
<font color="black"> 239.         &quot;&quot;&quot;Read header lines.</font>
<font color="black"> 240. </font>
<font color="black"> 241.         Read header lines up to the entirely blank line that terminates them.</font>
<font color="black"> 242.         The (normally blank) line that ends the headers is skipped, but not</font>
<font color="black"> 243.         included in the returned list.  If a non-header line ends the headers,</font>
<font color="black"> 244.         (which is an error), an attempt is made to backspace over it; it is</font>
<font color="black"> 245.         never included in the returned list.</font>
<font color="black"> 246. </font>
<font color="black"> 247.         The variable self.status is set to the empty string if all went well,</font>
<font color="black"> 248.         otherwise it is an error message.  The variable self.headers is a</font>
<font color="black"> 249.         completely uninterpreted list of lines contained in the header (so</font>
<font color="black"> 250.         printing them will reproduce the header exactly as it appears in the</font>
<font color="black"> 251.         file).</font>
<font color="black"> 252. </font>
<font color="black"> 253.         If multiple header fields with the same name occur, they are combined</font>
<font color="black"> 254.         according to the rules in RFC 2616 sec 4.2:</font>
<font color="black"> 255. </font>
<font color="black"> 256.         Appending each subsequent field-value to the first, each separated</font>
<font color="black"> 257.         by a comma. The order in which header fields with the same field-name</font>
<font color="black"> 258.         are received is significant to the interpretation of the combined</font>
<font color="black"> 259.         field value.</font>
<font color="black"> 260.         &quot;&quot;&quot;</font>
<font color="black"> 261.         # XXX The implementation overrides the readheaders() method of</font>
<font color="black"> 262.         # rfc822.Message.  The base class design isn't amenable to</font>
<font color="black"> 263.         # customized behavior here so the method here is a copy of the</font>
<font color="black"> 264.         # base class code with a few small changes.</font>
<font color="black"> 265. </font>
<font color="red"> 266.         self.dict = {}</font>
<font color="red"> 267.         self.unixfrom = ''</font>
<font color="red"> 268.         self.headers = hlist = []</font>
<font color="red"> 269.         self.status = ''</font>
<font color="red"> 270.         headerseen = &quot;&quot;</font>
<font color="red"> 271.         firstline = 1</font>
<font color="red"> 272.         startofline = unread = tell = None</font>
<font color="red"> 273.         if hasattr(self.fp, 'unread'):</font>
<font color="red"> 274.             unread = self.fp.unread</font>
<font color="red"> 275.         elif self.seekable:</font>
<font color="red"> 276.             tell = self.fp.tell</font>
<font color="red"> 277.         while True:</font>
<font color="red"> 278.             if len(hlist) &gt; _MAXHEADERS:</font>
<font color="red"> 279.                 raise HTTPException(&quot;got more than %d headers&quot; % _MAXHEADERS)</font>
<font color="red"> 280.             if tell:</font>
<font color="red"> 281.                 try:</font>
<font color="red"> 282.                     startofline = tell()</font>
<font color="red"> 283.                 except IOError:</font>
<font color="red"> 284.                     startofline = tell = None</font>
<font color="red"> 285.                     self.seekable = 0</font>
<font color="red"> 286.             line = self.fp.readline(_MAXLINE + 1)</font>
<font color="red"> 287.             if len(line) &gt; _MAXLINE:</font>
<font color="red"> 288.                 raise LineTooLong(&quot;header line&quot;)</font>
<font color="red"> 289.             if not line:</font>
<font color="red"> 290.                 self.status = 'EOF in headers'</font>
<font color="red"> 291.                 break</font>
<font color="black"> 292.             # Skip unix From name time lines</font>
<font color="red"> 293.             if firstline and line.startswith('From '):</font>
<font color="red"> 294.                 self.unixfrom = self.unixfrom + line</font>
<font color="red"> 295.                 continue</font>
<font color="red"> 296.             firstline = 0</font>
<font color="red"> 297.             if headerseen and line[0] in ' \t':</font>
<font color="black"> 298.                 # XXX Not sure if continuation lines are handled properly</font>
<font color="black"> 299.                 # for http and/or for repeating headers</font>
<font color="black"> 300.                 # It's a continuation line.</font>
<font color="red"> 301.                 hlist.append(line)</font>
<font color="red"> 302.                 self.addcontinue(headerseen, line.strip())</font>
<font color="red"> 303.                 continue</font>
<font color="red"> 304.             elif self.iscomment(line):</font>
<font color="black"> 305.                 # It's a comment.  Ignore it.</font>
<font color="red"> 306.                 continue</font>
<font color="red"> 307.             elif self.islast(line):</font>
<font color="black"> 308.                 # Note! No pushback here!  The delimiter line gets eaten.</font>
<font color="red"> 309.                 break</font>
<font color="red"> 310.             headerseen = self.isheader(line)</font>
<font color="red"> 311.             if headerseen:</font>
<font color="black"> 312.                 # It's a legal header line, save it.</font>
<font color="red"> 313.                 hlist.append(line)</font>
<font color="red"> 314.                 self.addheader(headerseen, line[len(headerseen)+1:].strip())</font>
<font color="red"> 315.                 continue</font>
<font color="black"> 316.             else:</font>
<font color="black"> 317.                 # It's not a header line; throw it back and stop here.</font>
<font color="red"> 318.                 if not self.dict:</font>
<font color="red"> 319.                     self.status = 'No headers'</font>
<font color="black"> 320.                 else:</font>
<font color="red"> 321.                     self.status = 'Non-header line where header expected'</font>
<font color="black"> 322.                 # Try to undo the read.</font>
<font color="red"> 323.                 if unread:</font>
<font color="red"> 324.                     unread(line)</font>
<font color="red"> 325.                 elif tell:</font>
<font color="red"> 326.                     self.fp.seek(startofline)</font>
<font color="black"> 327.                 else:</font>
<font color="red"> 328.                     self.status = self.status + '; bad seek'</font>
<font color="red"> 329.                 break</font>
<font color="black"> 330. </font>
<font color="green"> 331. class HTTPResponse:</font>
<font color="black"> 332. </font>
<font color="black"> 333.     # strict: If true, raise BadStatusLine if the status line can't be</font>
<font color="black"> 334.     # parsed as a valid HTTP/1.0 or 1.1 status line.  By default it is</font>
<font color="black"> 335.     # false because it prevents clients from talking to HTTP/0.9</font>
<font color="black"> 336.     # servers.  Note that a response with a sufficiently corrupted</font>
<font color="black"> 337.     # status line will look like an HTTP/0.9 response.</font>
<font color="black"> 338. </font>
<font color="black"> 339.     # See RFC 2616 sec 19.6 and RFC 1945 sec 6 for details.</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def __init__(self, sock, debuglevel=0, strict=0, method=None, buffering=False):</font>
<font color="red"> 342.         if buffering:</font>
<font color="black"> 343.             # The caller won't be using any sock.recv() calls, so buffering</font>
<font color="black"> 344.             # is fine and recommended for performance.</font>
<font color="red"> 345.             self.fp = sock.makefile('rb')</font>
<font color="black"> 346.         else:</font>
<font color="black"> 347.             # The buffer size is specified as zero, because the headers of</font>
<font color="black"> 348.             # the response are read with readline().  If the reads were</font>
<font color="black"> 349.             # buffered the readline() calls could consume some of the</font>
<font color="black"> 350.             # response, which make be read via a recv() on the underlying</font>
<font color="black"> 351.             # socket.</font>
<font color="red"> 352.             self.fp = sock.makefile('rb', 0)</font>
<font color="red"> 353.         self.debuglevel = debuglevel</font>
<font color="red"> 354.         self.strict = strict</font>
<font color="red"> 355.         self._method = method</font>
<font color="black"> 356. </font>
<font color="red"> 357.         self.msg = None</font>
<font color="black"> 358. </font>
<font color="black"> 359.         # from the Status-Line of the response</font>
<font color="red"> 360.         self.version = _UNKNOWN # HTTP-Version</font>
<font color="red"> 361.         self.status = _UNKNOWN  # Status-Code</font>
<font color="red"> 362.         self.reason = _UNKNOWN  # Reason-Phrase</font>
<font color="black"> 363. </font>
<font color="red"> 364.         self.chunked = _UNKNOWN         # is &quot;chunked&quot; being used?</font>
<font color="red"> 365.         self.chunk_left = _UNKNOWN      # bytes left to read in current chunk</font>
<font color="red"> 366.         self.length = _UNKNOWN          # number of bytes left in response</font>
<font color="red"> 367.         self.will_close = _UNKNOWN      # conn will close at end of response</font>
<font color="black"> 368. </font>
<font color="green"> 369.     def _read_status(self):</font>
<font color="black"> 370.         # Initialize with Simple-Response defaults</font>
<font color="red"> 371.         line = self.fp.readline(_MAXLINE + 1)</font>
<font color="red"> 372.         if len(line) &gt; _MAXLINE:</font>
<font color="red"> 373.             raise LineTooLong(&quot;header line&quot;)</font>
<font color="red"> 374.         if self.debuglevel &gt; 0:</font>
<font color="red"> 375.             print &quot;reply:&quot;, repr(line)</font>
<font color="red"> 376.         if not line:</font>
<font color="black"> 377.             # Presumably, the server closed the connection before</font>
<font color="black"> 378.             # sending a valid response.</font>
<font color="red"> 379.             raise BadStatusLine(line)</font>
<font color="red"> 380.         try:</font>
<font color="red"> 381.             [version, status, reason] = line.split(None, 2)</font>
<font color="red"> 382.         except ValueError:</font>
<font color="red"> 383.             try:</font>
<font color="red"> 384.                 [version, status] = line.split(None, 1)</font>
<font color="red"> 385.                 reason = &quot;&quot;</font>
<font color="red"> 386.             except ValueError:</font>
<font color="black"> 387.                 # empty version will cause next test to fail and status</font>
<font color="black"> 388.                 # will be treated as 0.9 response.</font>
<font color="red"> 389.                 version = &quot;&quot;</font>
<font color="red"> 390.         if not version.startswith('HTTP/'):</font>
<font color="red"> 391.             if self.strict:</font>
<font color="red"> 392.                 self.close()</font>
<font color="red"> 393.                 raise BadStatusLine(line)</font>
<font color="black"> 394.             else:</font>
<font color="black"> 395.                 # assume it's a Simple-Response from an 0.9 server</font>
<font color="red"> 396.                 self.fp = LineAndFileWrapper(line, self.fp)</font>
<font color="red"> 397.                 return &quot;HTTP/0.9&quot;, 200, &quot;&quot;</font>
<font color="black"> 398. </font>
<font color="black"> 399.         # The status code is a three-digit number</font>
<font color="red"> 400.         try:</font>
<font color="red"> 401.             status = int(status)</font>
<font color="red"> 402.             if status &lt; 100 or status &gt; 999:</font>
<font color="red"> 403.                 raise BadStatusLine(line)</font>
<font color="red"> 404.         except ValueError:</font>
<font color="red"> 405.             raise BadStatusLine(line)</font>
<font color="red"> 406.         return version, status, reason</font>
<font color="black"> 407. </font>
<font color="green"> 408.     def begin(self):</font>
<font color="red"> 409.         if self.msg is not None:</font>
<font color="black"> 410.             # we've already started reading the response</font>
<font color="red"> 411.             return</font>
<font color="black"> 412. </font>
<font color="black"> 413.         # read until we get a non-100 response</font>
<font color="red"> 414.         while True:</font>
<font color="red"> 415.             version, status, reason = self._read_status()</font>
<font color="red"> 416.             if status != CONTINUE:</font>
<font color="red"> 417.                 break</font>
<font color="black"> 418.             # skip the header from the 100 response</font>
<font color="red"> 419.             while True:</font>
<font color="red"> 420.                 skip = self.fp.readline(_MAXLINE + 1)</font>
<font color="red"> 421.                 if len(skip) &gt; _MAXLINE:</font>
<font color="red"> 422.                     raise LineTooLong(&quot;header line&quot;)</font>
<font color="red"> 423.                 skip = skip.strip()</font>
<font color="red"> 424.                 if not skip:</font>
<font color="red"> 425.                     break</font>
<font color="red"> 426.                 if self.debuglevel &gt; 0:</font>
<font color="red"> 427.                     print &quot;header:&quot;, skip</font>
<font color="black"> 428. </font>
<font color="red"> 429.         self.status = status</font>
<font color="red"> 430.         self.reason = reason.strip()</font>
<font color="red"> 431.         if version == 'HTTP/1.0':</font>
<font color="red"> 432.             self.version = 10</font>
<font color="red"> 433.         elif version.startswith('HTTP/1.'):</font>
<font color="red"> 434.             self.version = 11   # use HTTP/1.1 code for HTTP/1.x where x&gt;=1</font>
<font color="red"> 435.         elif version == 'HTTP/0.9':</font>
<font color="red"> 436.             self.version = 9</font>
<font color="black"> 437.         else:</font>
<font color="red"> 438.             raise UnknownProtocol(version)</font>
<font color="black"> 439. </font>
<font color="red"> 440.         if self.version == 9:</font>
<font color="red"> 441.             self.length = None</font>
<font color="red"> 442.             self.chunked = 0</font>
<font color="red"> 443.             self.will_close = 1</font>
<font color="red"> 444.             self.msg = HTTPMessage(StringIO())</font>
<font color="red"> 445.             return</font>
<font color="black"> 446. </font>
<font color="red"> 447.         self.msg = HTTPMessage(self.fp, 0)</font>
<font color="red"> 448.         if self.debuglevel &gt; 0:</font>
<font color="red"> 449.             for hdr in self.msg.headers:</font>
<font color="red"> 450.                 print &quot;header:&quot;, hdr,</font>
<font color="black"> 451. </font>
<font color="black"> 452.         # don't let the msg keep an fp</font>
<font color="red"> 453.         self.msg.fp = None</font>
<font color="black"> 454. </font>
<font color="black"> 455.         # are we using the chunked-style of transfer encoding?</font>
<font color="red"> 456.         tr_enc = self.msg.getheader('transfer-encoding')</font>
<font color="red"> 457.         if tr_enc and tr_enc.lower() == &quot;chunked&quot;:</font>
<font color="red"> 458.             self.chunked = 1</font>
<font color="red"> 459.             self.chunk_left = None</font>
<font color="black"> 460.         else:</font>
<font color="red"> 461.             self.chunked = 0</font>
<font color="black"> 462. </font>
<font color="black"> 463.         # will the connection close at the end of the response?</font>
<font color="red"> 464.         self.will_close = self._check_close()</font>
<font color="black"> 465. </font>
<font color="black"> 466.         # do we have a Content-Length?</font>
<font color="black"> 467.         # NOTE: RFC 2616, S4.4, #3 says we ignore this if tr_enc is &quot;chunked&quot;</font>
<font color="red"> 468.         length = self.msg.getheader('content-length')</font>
<font color="red"> 469.         if length and not self.chunked:</font>
<font color="red"> 470.             try:</font>
<font color="red"> 471.                 self.length = int(length)</font>
<font color="red"> 472.             except ValueError:</font>
<font color="red"> 473.                 self.length = None</font>
<font color="black"> 474.             else:</font>
<font color="red"> 475.                 if self.length &lt; 0:  # ignore nonsensical negative lengths</font>
<font color="red"> 476.                     self.length = None</font>
<font color="black"> 477.         else:</font>
<font color="red"> 478.             self.length = None</font>
<font color="black"> 479. </font>
<font color="black"> 480.         # does the body have a fixed length? (of zero)</font>
<font color="red"> 481.         if (status == NO_CONTENT or status == NOT_MODIFIED or</font>
<font color="red"> 482.             100 &lt;= status &lt; 200 or      # 1xx codes</font>
<font color="red"> 483.             self._method == 'HEAD'):</font>
<font color="red"> 484.             self.length = 0</font>
<font color="black"> 485. </font>
<font color="black"> 486.         # if the connection remains open, and we aren't using chunked, and</font>
<font color="black"> 487.         # a content-length was not provided, then assume that the connection</font>
<font color="black"> 488.         # WILL close.</font>
<font color="red"> 489.         if not self.will_close and \</font>
<font color="red"> 490.            not self.chunked and \</font>
<font color="red"> 491.            self.length is None:</font>
<font color="red"> 492.             self.will_close = 1</font>
<font color="black"> 493. </font>
<font color="green"> 494.     def _check_close(self):</font>
<font color="red"> 495.         conn = self.msg.getheader('connection')</font>
<font color="red"> 496.         if self.version == 11:</font>
<font color="black"> 497.             # An HTTP/1.1 proxy is assumed to stay open unless</font>
<font color="black"> 498.             # explicitly closed.</font>
<font color="red"> 499.             conn = self.msg.getheader('connection')</font>
<font color="red"> 500.             if conn and &quot;close&quot; in conn.lower():</font>
<font color="red"> 501.                 return True</font>
<font color="red"> 502.             return False</font>
<font color="black"> 503. </font>
<font color="black"> 504.         # Some HTTP/1.0 implementations have support for persistent</font>
<font color="black"> 505.         # connections, using rules different than HTTP/1.1.</font>
<font color="black"> 506. </font>
<font color="black"> 507.         # For older HTTP, Keep-Alive indicates persistent connection.</font>
<font color="red"> 508.         if self.msg.getheader('keep-alive'):</font>
<font color="red"> 509.             return False</font>
<font color="black"> 510. </font>
<font color="black"> 511.         # At least Akamai returns a &quot;Connection: Keep-Alive&quot; header,</font>
<font color="black"> 512.         # which was supposed to be sent by the client.</font>
<font color="red"> 513.         if conn and &quot;keep-alive&quot; in conn.lower():</font>
<font color="red"> 514.             return False</font>
<font color="black"> 515. </font>
<font color="black"> 516.         # Proxy-Connection is a netscape hack.</font>
<font color="red"> 517.         pconn = self.msg.getheader('proxy-connection')</font>
<font color="red"> 518.         if pconn and &quot;keep-alive&quot; in pconn.lower():</font>
<font color="red"> 519.             return False</font>
<font color="black"> 520. </font>
<font color="black"> 521.         # otherwise, assume it will close</font>
<font color="red"> 522.         return True</font>
<font color="black"> 523. </font>
<font color="green"> 524.     def close(self):</font>
<font color="red"> 525.         if self.fp:</font>
<font color="red"> 526.             self.fp.close()</font>
<font color="red"> 527.             self.fp = None</font>
<font color="black"> 528. </font>
<font color="green"> 529.     def isclosed(self):</font>
<font color="black"> 530.         # NOTE: it is possible that we will not ever call self.close(). This</font>
<font color="black"> 531.         #       case occurs when will_close is TRUE, length is None, and we</font>
<font color="black"> 532.         #       read up to the last byte, but NOT past it.</font>
<font color="black"> 533.         #</font>
<font color="black"> 534.         # IMPLIES: if will_close is FALSE, then self.close() will ALWAYS be</font>
<font color="black"> 535.         #          called, meaning self.isclosed() is meaningful.</font>
<font color="red"> 536.         return self.fp is None</font>
<font color="black"> 537. </font>
<font color="black"> 538.     # XXX It would be nice to have readline and __iter__ for this, too.</font>
<font color="black"> 539. </font>
<font color="green"> 540.     def read(self, amt=None):</font>
<font color="red"> 541.         if self.fp is None:</font>
<font color="red"> 542.             return ''</font>
<font color="black"> 543. </font>
<font color="red"> 544.         if self._method == 'HEAD':</font>
<font color="red"> 545.             self.close()</font>
<font color="red"> 546.             return ''</font>
<font color="black"> 547. </font>
<font color="red"> 548.         if self.chunked:</font>
<font color="red"> 549.             return self._read_chunked(amt)</font>
<font color="black"> 550. </font>
<font color="red"> 551.         if amt is None:</font>
<font color="black"> 552.             # unbounded read</font>
<font color="red"> 553.             if self.length is None:</font>
<font color="red"> 554.                 s = self.fp.read()</font>
<font color="black"> 555.             else:</font>
<font color="red"> 556.                 try:</font>
<font color="red"> 557.                     s = self._safe_read(self.length)</font>
<font color="red"> 558.                 except IncompleteRead:</font>
<font color="red"> 559.                     self.close()</font>
<font color="red"> 560.                     raise</font>
<font color="red"> 561.                 self.length = 0</font>
<font color="red"> 562.             self.close()        # we read everything</font>
<font color="red"> 563.             return s</font>
<font color="black"> 564. </font>
<font color="red"> 565.         if self.length is not None:</font>
<font color="red"> 566.             if amt &gt; self.length:</font>
<font color="black"> 567.                 # clip the read to the &quot;end of response&quot;</font>
<font color="red"> 568.                 amt = self.length</font>
<font color="black"> 569. </font>
<font color="black"> 570.         # we do not use _safe_read() here because this may be a .will_close</font>
<font color="black"> 571.         # connection, and the user is reading more bytes than will be provided</font>
<font color="black"> 572.         # (for example, reading in 1k chunks)</font>
<font color="red"> 573.         s = self.fp.read(amt)</font>
<font color="red"> 574.         if not s and amt:</font>
<font color="black"> 575.             # Ideally, we would raise IncompleteRead if the content-length</font>
<font color="black"> 576.             # wasn't satisfied, but it might break compatibility.</font>
<font color="red"> 577.             self.close()</font>
<font color="red"> 578.         if self.length is not None:</font>
<font color="red"> 579.             self.length -= len(s)</font>
<font color="red"> 580.             if not self.length:</font>
<font color="red"> 581.                 self.close()</font>
<font color="black"> 582. </font>
<font color="red"> 583.         return s</font>
<font color="black"> 584. </font>
<font color="green"> 585.     def _read_chunked(self, amt):</font>
<font color="red"> 586.         assert self.chunked != _UNKNOWN</font>
<font color="red"> 587.         chunk_left = self.chunk_left</font>
<font color="red"> 588.         value = []</font>
<font color="red"> 589.         while True:</font>
<font color="red"> 590.             if chunk_left is None:</font>
<font color="red"> 591.                 line = self.fp.readline(_MAXLINE + 1)</font>
<font color="red"> 592.                 if len(line) &gt; _MAXLINE:</font>
<font color="red"> 593.                     raise LineTooLong(&quot;chunk size&quot;)</font>
<font color="red"> 594.                 i = line.find(';')</font>
<font color="red"> 595.                 if i &gt;= 0:</font>
<font color="red"> 596.                     line = line[:i] # strip chunk-extensions</font>
<font color="red"> 597.                 try:</font>
<font color="red"> 598.                     chunk_left = int(line, 16)</font>
<font color="red"> 599.                 except ValueError:</font>
<font color="black"> 600.                     # close the connection as protocol synchronisation is</font>
<font color="black"> 601.                     # probably lost</font>
<font color="red"> 602.                     self.close()</font>
<font color="red"> 603.                     raise IncompleteRead(''.join(value))</font>
<font color="red"> 604.                 if chunk_left == 0:</font>
<font color="red"> 605.                     break</font>
<font color="red"> 606.             if amt is None:</font>
<font color="red"> 607.                 value.append(self._safe_read(chunk_left))</font>
<font color="red"> 608.             elif amt &lt; chunk_left:</font>
<font color="red"> 609.                 value.append(self._safe_read(amt))</font>
<font color="red"> 610.                 self.chunk_left = chunk_left - amt</font>
<font color="red"> 611.                 return ''.join(value)</font>
<font color="red"> 612.             elif amt == chunk_left:</font>
<font color="red"> 613.                 value.append(self._safe_read(amt))</font>
<font color="red"> 614.                 self._safe_read(2)  # toss the CRLF at the end of the chunk</font>
<font color="red"> 615.                 self.chunk_left = None</font>
<font color="red"> 616.                 return ''.join(value)</font>
<font color="black"> 617.             else:</font>
<font color="red"> 618.                 value.append(self._safe_read(chunk_left))</font>
<font color="red"> 619.                 amt -= chunk_left</font>
<font color="black"> 620. </font>
<font color="black"> 621.             # we read the whole chunk, get another</font>
<font color="red"> 622.             self._safe_read(2)      # toss the CRLF at the end of the chunk</font>
<font color="red"> 623.             chunk_left = None</font>
<font color="black"> 624. </font>
<font color="black"> 625.         # read and discard trailer up to the CRLF terminator</font>
<font color="black"> 626.         ### note: we shouldn't have any trailers!</font>
<font color="red"> 627.         while True:</font>
<font color="red"> 628.             line = self.fp.readline(_MAXLINE + 1)</font>
<font color="red"> 629.             if len(line) &gt; _MAXLINE:</font>
<font color="red"> 630.                 raise LineTooLong(&quot;trailer line&quot;)</font>
<font color="red"> 631.             if not line:</font>
<font color="black"> 632.                 # a vanishingly small number of sites EOF without</font>
<font color="black"> 633.                 # sending the trailer</font>
<font color="red"> 634.                 break</font>
<font color="red"> 635.             if line == '\r\n':</font>
<font color="red"> 636.                 break</font>
<font color="black"> 637. </font>
<font color="black"> 638.         # we read everything; close the &quot;file&quot;</font>
<font color="red"> 639.         self.close()</font>
<font color="black"> 640. </font>
<font color="red"> 641.         return ''.join(value)</font>
<font color="black"> 642. </font>
<font color="green"> 643.     def _safe_read(self, amt):</font>
<font color="black"> 644.         &quot;&quot;&quot;Read the number of bytes requested, compensating for partial reads.</font>
<font color="black"> 645. </font>
<font color="black"> 646.         Normally, we have a blocking socket, but a read() can be interrupted</font>
<font color="black"> 647.         by a signal (resulting in a partial read).</font>
<font color="black"> 648. </font>
<font color="black"> 649.         Note that we cannot distinguish between EOF and an interrupt when zero</font>
<font color="black"> 650.         bytes have been read. IncompleteRead() will be raised in this</font>
<font color="black"> 651.         situation.</font>
<font color="black"> 652. </font>
<font color="black"> 653.         This function should be used when &lt;amt&gt; bytes &quot;should&quot; be present for</font>
<font color="black"> 654.         reading. If the bytes are truly not available (due to EOF), then the</font>
<font color="black"> 655.         IncompleteRead exception can be used to detect the problem.</font>
<font color="black"> 656.         &quot;&quot;&quot;</font>
<font color="black"> 657.         # NOTE(gps): As of svn r74426 socket._fileobject.read(x) will never</font>
<font color="black"> 658.         # return less than x bytes unless EOF is encountered.  It now handles</font>
<font color="black"> 659.         # signal interruptions (socket.error EINTR) internally.  This code</font>
<font color="black"> 660.         # never caught that exception anyways.  It seems largely pointless.</font>
<font color="black"> 661.         # self.fp.read(amt) will work fine.</font>
<font color="red"> 662.         s = []</font>
<font color="red"> 663.         while amt &gt; 0:</font>
<font color="red"> 664.             chunk = self.fp.read(min(amt, MAXAMOUNT))</font>
<font color="red"> 665.             if not chunk:</font>
<font color="red"> 666.                 raise IncompleteRead(''.join(s), amt)</font>
<font color="red"> 667.             s.append(chunk)</font>
<font color="red"> 668.             amt -= len(chunk)</font>
<font color="red"> 669.         return ''.join(s)</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def fileno(self):</font>
<font color="red"> 672.         return self.fp.fileno()</font>
<font color="black"> 673. </font>
<font color="green"> 674.     def getheader(self, name, default=None):</font>
<font color="red"> 675.         if self.msg is None:</font>
<font color="red"> 676.             raise ResponseNotReady()</font>
<font color="red"> 677.         return self.msg.getheader(name, default)</font>
<font color="black"> 678. </font>
<font color="green"> 679.     def getheaders(self):</font>
<font color="black"> 680.         &quot;&quot;&quot;Return list of (header, value) tuples.&quot;&quot;&quot;</font>
<font color="red"> 681.         if self.msg is None:</font>
<font color="red"> 682.             raise ResponseNotReady()</font>
<font color="red"> 683.         return self.msg.items()</font>
<font color="black"> 684. </font>
<font color="black"> 685. </font>
<font color="green"> 686. class HTTPConnection:</font>
<font color="black"> 687. </font>
<font color="green"> 688.     _http_vsn = 11</font>
<font color="green"> 689.     _http_vsn_str = 'HTTP/1.1'</font>
<font color="black"> 690. </font>
<font color="green"> 691.     response_class = HTTPResponse</font>
<font color="green"> 692.     default_port = HTTP_PORT</font>
<font color="green"> 693.     auto_open = 1</font>
<font color="green"> 694.     debuglevel = 0</font>
<font color="green"> 695.     strict = 0</font>
<font color="black"> 696. </font>
<font color="green"> 697.     def __init__(self, host, port=None, strict=None,</font>
<font color="green"> 698.                  timeout=socket._GLOBAL_DEFAULT_TIMEOUT, source_address=None):</font>
<font color="red"> 699.         self.timeout = timeout</font>
<font color="red"> 700.         self.source_address = source_address</font>
<font color="red"> 701.         self.sock = None</font>
<font color="red"> 702.         self._buffer = []</font>
<font color="red"> 703.         self.__response = None</font>
<font color="red"> 704.         self.__state = _CS_IDLE</font>
<font color="red"> 705.         self._method = None</font>
<font color="red"> 706.         self._tunnel_host = None</font>
<font color="red"> 707.         self._tunnel_port = None</font>
<font color="red"> 708.         self._tunnel_headers = {}</font>
<font color="black"> 709. </font>
<font color="red"> 710.         self._set_hostport(host, port)</font>
<font color="red"> 711.         if strict is not None:</font>
<font color="red"> 712.             self.strict = strict</font>
<font color="black"> 713. </font>
<font color="green"> 714.     def set_tunnel(self, host, port=None, headers=None):</font>
<font color="black"> 715.         &quot;&quot;&quot; Sets up the host and the port for the HTTP CONNECT Tunnelling.</font>
<font color="black"> 716. </font>
<font color="black"> 717.         The headers argument should be a mapping of extra HTTP headers</font>
<font color="black"> 718.         to send with the CONNECT request.</font>
<font color="black"> 719.         &quot;&quot;&quot;</font>
<font color="red"> 720.         self._tunnel_host = host</font>
<font color="red"> 721.         self._tunnel_port = port</font>
<font color="red"> 722.         if headers:</font>
<font color="red"> 723.             self._tunnel_headers = headers</font>
<font color="black"> 724.         else:</font>
<font color="red"> 725.             self._tunnel_headers.clear()</font>
<font color="black"> 726. </font>
<font color="green"> 727.     def _set_hostport(self, host, port):</font>
<font color="red"> 728.         if port is None:</font>
<font color="red"> 729.             i = host.rfind(':')</font>
<font color="red"> 730.             j = host.rfind(']')         # ipv6 addresses have [...]</font>
<font color="red"> 731.             if i &gt; j:</font>
<font color="red"> 732.                 try:</font>
<font color="red"> 733.                     port = int(host[i+1:])</font>
<font color="red"> 734.                 except ValueError:</font>
<font color="red"> 735.                     if host[i+1:] == &quot;&quot;:  # http://foo.com:/ == http://foo.com/</font>
<font color="red"> 736.                         port = self.default_port</font>
<font color="black"> 737.                     else:</font>
<font color="red"> 738.                         raise InvalidURL(&quot;nonnumeric port: '%s'&quot; % host[i+1:])</font>
<font color="red"> 739.                 host = host[:i]</font>
<font color="black"> 740.             else:</font>
<font color="red"> 741.                 port = self.default_port</font>
<font color="red"> 742.             if host and host[0] == '[' and host[-1] == ']':</font>
<font color="red"> 743.                 host = host[1:-1]</font>
<font color="red"> 744.         self.host = host</font>
<font color="red"> 745.         self.port = port</font>
<font color="black"> 746. </font>
<font color="green"> 747.     def set_debuglevel(self, level):</font>
<font color="red"> 748.         self.debuglevel = level</font>
<font color="black"> 749. </font>
<font color="green"> 750.     def _tunnel(self):</font>
<font color="red"> 751.         self._set_hostport(self._tunnel_host, self._tunnel_port)</font>
<font color="red"> 752.         self.send(&quot;CONNECT %s:%d HTTP/1.0\r\n&quot; % (self.host, self.port))</font>
<font color="red"> 753.         for header, value in self._tunnel_headers.iteritems():</font>
<font color="red"> 754.             self.send(&quot;%s: %s\r\n&quot; % (header, value))</font>
<font color="red"> 755.         self.send(&quot;\r\n&quot;)</font>
<font color="red"> 756.         response = self.response_class(self.sock, strict = self.strict,</font>
<font color="red"> 757.                                        method = self._method)</font>
<font color="red"> 758.         (version, code, message) = response._read_status()</font>
<font color="black"> 759. </font>
<font color="red"> 760.         if code != 200:</font>
<font color="red"> 761.             self.close()</font>
<font color="red"> 762.             raise socket.error(&quot;Tunnel connection failed: %d %s&quot; % (code,</font>
<font color="red"> 763.                                                                     message.strip()))</font>
<font color="red"> 764.         while True:</font>
<font color="red"> 765.             line = response.fp.readline(_MAXLINE + 1)</font>
<font color="red"> 766.             if len(line) &gt; _MAXLINE:</font>
<font color="red"> 767.                 raise LineTooLong(&quot;header line&quot;)</font>
<font color="red"> 768.             if not line:</font>
<font color="black"> 769.                 # for sites which EOF without sending trailer</font>
<font color="red"> 770.                 break</font>
<font color="red"> 771.             if line == '\r\n':</font>
<font color="red"> 772.                 break</font>
<font color="black"> 773. </font>
<font color="black"> 774. </font>
<font color="green"> 775.     def connect(self):</font>
<font color="black"> 776.         &quot;&quot;&quot;Connect to the host and port specified in __init__.&quot;&quot;&quot;</font>
<font color="red"> 777.         self.sock = socket.create_connection((self.host,self.port),</font>
<font color="red"> 778.                                              self.timeout, self.source_address)</font>
<font color="black"> 779. </font>
<font color="red"> 780.         if self._tunnel_host:</font>
<font color="red"> 781.             self._tunnel()</font>
<font color="black"> 782. </font>
<font color="green"> 783.     def close(self):</font>
<font color="black"> 784.         &quot;&quot;&quot;Close the connection to the HTTP server.&quot;&quot;&quot;</font>
<font color="red"> 785.         if self.sock:</font>
<font color="red"> 786.             self.sock.close()   # close it manually... there may be other refs</font>
<font color="red"> 787.             self.sock = None</font>
<font color="red"> 788.         if self.__response:</font>
<font color="red"> 789.             self.__response.close()</font>
<font color="red"> 790.             self.__response = None</font>
<font color="red"> 791.         self.__state = _CS_IDLE</font>
<font color="black"> 792. </font>
<font color="green"> 793.     def send(self, data):</font>
<font color="black"> 794.         &quot;&quot;&quot;Send `data' to the server.&quot;&quot;&quot;</font>
<font color="red"> 795.         if self.sock is None:</font>
<font color="red"> 796.             if self.auto_open:</font>
<font color="red"> 797.                 self.connect()</font>
<font color="black"> 798.             else:</font>
<font color="red"> 799.                 raise NotConnected()</font>
<font color="black"> 800. </font>
<font color="red"> 801.         if self.debuglevel &gt; 0:</font>
<font color="red"> 802.             print &quot;send:&quot;, repr(data)</font>
<font color="red"> 803.         blocksize = 8192</font>
<font color="red"> 804.         if hasattr(data,'read') and not isinstance(data, array):</font>
<font color="red"> 805.             if self.debuglevel &gt; 0: print &quot;sendIng a read()able&quot;</font>
<font color="red"> 806.             datablock = data.read(blocksize)</font>
<font color="red"> 807.             while datablock:</font>
<font color="red"> 808.                 self.sock.sendall(datablock)</font>
<font color="red"> 809.                 datablock = data.read(blocksize)</font>
<font color="black"> 810.         else:</font>
<font color="red"> 811.             self.sock.sendall(data)</font>
<font color="black"> 812. </font>
<font color="green"> 813.     def _output(self, s):</font>
<font color="black"> 814.         &quot;&quot;&quot;Add a line of output to the current request buffer.</font>
<font color="black"> 815. </font>
<font color="black"> 816.         Assumes that the line does *not* end with \\r\\n.</font>
<font color="black"> 817.         &quot;&quot;&quot;</font>
<font color="red"> 818.         self._buffer.append(s)</font>
<font color="black"> 819. </font>
<font color="green"> 820.     def _send_output(self, message_body=None):</font>
<font color="black"> 821.         &quot;&quot;&quot;Send the currently buffered request and clear the buffer.</font>
<font color="black"> 822. </font>
<font color="black"> 823.         Appends an extra \\r\\n to the buffer.</font>
<font color="black"> 824.         A message_body may be specified, to be appended to the request.</font>
<font color="black"> 825.         &quot;&quot;&quot;</font>
<font color="red"> 826.         self._buffer.extend((&quot;&quot;, &quot;&quot;))</font>
<font color="red"> 827.         msg = &quot;\r\n&quot;.join(self._buffer)</font>
<font color="red"> 828.         del self._buffer[:]</font>
<font color="black"> 829.         # If msg and message_body are sent in a single send() call,</font>
<font color="black"> 830.         # it will avoid performance problems caused by the interaction</font>
<font color="black"> 831.         # between delayed ack and the Nagle algorithm.</font>
<font color="red"> 832.         if isinstance(message_body, str):</font>
<font color="red"> 833.             msg += message_body</font>
<font color="red"> 834.             message_body = None</font>
<font color="red"> 835.         self.send(msg)</font>
<font color="red"> 836.         if message_body is not None:</font>
<font color="black"> 837.             #message_body was not a string (i.e. it is a file) and</font>
<font color="black"> 838.             #we must run the risk of Nagle</font>
<font color="red"> 839.             self.send(message_body)</font>
<font color="black"> 840. </font>
<font color="green"> 841.     def putrequest(self, method, url, skip_host=0, skip_accept_encoding=0):</font>
<font color="black"> 842.         &quot;&quot;&quot;Send a request to the server.</font>
<font color="black"> 843. </font>
<font color="black"> 844.         `method' specifies an HTTP request method, e.g. 'GET'.</font>
<font color="black"> 845.         `url' specifies the object being requested, e.g. '/index.html'.</font>
<font color="black"> 846.         `skip_host' if True does not add automatically a 'Host:' header</font>
<font color="black"> 847.         `skip_accept_encoding' if True does not add automatically an</font>
<font color="black"> 848.            'Accept-Encoding:' header</font>
<font color="black"> 849.         &quot;&quot;&quot;</font>
<font color="black"> 850. </font>
<font color="black"> 851.         # if a prior response has been completed, then forget about it.</font>
<font color="red"> 852.         if self.__response and self.__response.isclosed():</font>
<font color="red"> 853.             self.__response = None</font>
<font color="black"> 854. </font>
<font color="black"> 855. </font>
<font color="black"> 856.         # in certain cases, we cannot issue another request on this connection.</font>
<font color="black"> 857.         # this occurs when:</font>
<font color="black"> 858.         #   1) we are in the process of sending a request.   (_CS_REQ_STARTED)</font>
<font color="black"> 859.         #   2) a response to a previous request has signalled that it is going</font>
<font color="black"> 860.         #      to close the connection upon completion.</font>
<font color="black"> 861.         #   3) the headers for the previous response have not been read, thus</font>
<font color="black"> 862.         #      we cannot determine whether point (2) is true.   (_CS_REQ_SENT)</font>
<font color="black"> 863.         #</font>
<font color="black"> 864.         # if there is no prior response, then we can request at will.</font>
<font color="black"> 865.         #</font>
<font color="black"> 866.         # if point (2) is true, then we will have passed the socket to the</font>
<font color="black"> 867.         # response (effectively meaning, &quot;there is no prior response&quot;), and</font>
<font color="black"> 868.         # will open a new one when a new request is made.</font>
<font color="black"> 869.         #</font>
<font color="black"> 870.         # Note: if a prior response exists, then we *can* start a new request.</font>
<font color="black"> 871.         #       We are not allowed to begin fetching the response to this new</font>
<font color="black"> 872.         #       request, however, until that prior response is complete.</font>
<font color="black"> 873.         #</font>
<font color="red"> 874.         if self.__state == _CS_IDLE:</font>
<font color="red"> 875.             self.__state = _CS_REQ_STARTED</font>
<font color="black"> 876.         else:</font>
<font color="red"> 877.             raise CannotSendRequest()</font>
<font color="black"> 878. </font>
<font color="black"> 879.         # Save the method we use, we need it later in the response phase</font>
<font color="red"> 880.         self._method = method</font>
<font color="red"> 881.         if not url:</font>
<font color="red"> 882.             url = '/'</font>
<font color="red"> 883.         hdr = '%s %s %s' % (method, url, self._http_vsn_str)</font>
<font color="black"> 884. </font>
<font color="red"> 885.         self._output(hdr)</font>
<font color="black"> 886. </font>
<font color="red"> 887.         if self._http_vsn == 11:</font>
<font color="black"> 888.             # Issue some standard headers for better HTTP/1.1 compliance</font>
<font color="black"> 889. </font>
<font color="red"> 890.             if not skip_host:</font>
<font color="black"> 891.                 # this header is issued *only* for HTTP/1.1</font>
<font color="black"> 892.                 # connections. more specifically, this means it is</font>
<font color="black"> 893.                 # only issued when the client uses the new</font>
<font color="black"> 894.                 # HTTPConnection() class. backwards-compat clients</font>
<font color="black"> 895.                 # will be using HTTP/1.0 and those clients may be</font>
<font color="black"> 896.                 # issuing this header themselves. we should NOT issue</font>
<font color="black"> 897.                 # it twice; some web servers (such as Apache) barf</font>
<font color="black"> 898.                 # when they see two Host: headers</font>
<font color="black"> 899. </font>
<font color="black"> 900.                 # If we need a non-standard port,include it in the</font>
<font color="black"> 901.                 # header.  If the request is going through a proxy,</font>
<font color="black"> 902.                 # but the host of the actual URL, not the host of the</font>
<font color="black"> 903.                 # proxy.</font>
<font color="black"> 904. </font>
<font color="red"> 905.                 netloc = ''</font>
<font color="red"> 906.                 if url.startswith('http'):</font>
<font color="red"> 907.                     nil, netloc, nil, nil, nil = urlsplit(url)</font>
<font color="black"> 908. </font>
<font color="red"> 909.                 if netloc:</font>
<font color="red"> 910.                     try:</font>
<font color="red"> 911.                         netloc_enc = netloc.encode(&quot;ascii&quot;)</font>
<font color="red"> 912.                     except UnicodeEncodeError:</font>
<font color="red"> 913.                         netloc_enc = netloc.encode(&quot;idna&quot;)</font>
<font color="red"> 914.                     self.putheader('Host', netloc_enc)</font>
<font color="black"> 915.                 else:</font>
<font color="red"> 916.                     try:</font>
<font color="red"> 917.                         host_enc = self.host.encode(&quot;ascii&quot;)</font>
<font color="red"> 918.                     except UnicodeEncodeError:</font>
<font color="red"> 919.                         host_enc = self.host.encode(&quot;idna&quot;)</font>
<font color="black"> 920.                     # Wrap the IPv6 Host Header with [] (RFC 2732)</font>
<font color="red"> 921.                     if host_enc.find(':') &gt;= 0:</font>
<font color="red"> 922.                         host_enc = &quot;[&quot; + host_enc + &quot;]&quot;</font>
<font color="red"> 923.                     if self.port == self.default_port:</font>
<font color="red"> 924.                         self.putheader('Host', host_enc)</font>
<font color="black"> 925.                     else:</font>
<font color="red"> 926.                         self.putheader('Host', &quot;%s:%s&quot; % (host_enc, self.port))</font>
<font color="black"> 927. </font>
<font color="black"> 928.             # note: we are assuming that clients will not attempt to set these</font>
<font color="black"> 929.             #       headers since *this* library must deal with the</font>
<font color="black"> 930.             #       consequences. this also means that when the supporting</font>
<font color="black"> 931.             #       libraries are updated to recognize other forms, then this</font>
<font color="black"> 932.             #       code should be changed (removed or updated).</font>
<font color="black"> 933. </font>
<font color="black"> 934.             # we only want a Content-Encoding of &quot;identity&quot; since we don't</font>
<font color="black"> 935.             # support encodings such as x-gzip or x-deflate.</font>
<font color="red"> 936.             if not skip_accept_encoding:</font>
<font color="red"> 937.                 self.putheader('Accept-Encoding', 'identity')</font>
<font color="black"> 938. </font>
<font color="black"> 939.             # we can accept &quot;chunked&quot; Transfer-Encodings, but no others</font>
<font color="black"> 940.             # NOTE: no TE header implies *only* &quot;chunked&quot;</font>
<font color="black"> 941.             #self.putheader('TE', 'chunked')</font>
<font color="black"> 942. </font>
<font color="black"> 943.             # if TE is supplied in the header, then it must appear in a</font>
<font color="black"> 944.             # Connection header.</font>
<font color="black"> 945.             #self.putheader('Connection', 'TE')</font>
<font color="black"> 946. </font>
<font color="black"> 947.         else:</font>
<font color="black"> 948.             # For HTTP/1.0, the server will assume &quot;not chunked&quot;</font>
<font color="red"> 949.             pass</font>
<font color="black"> 950. </font>
<font color="green"> 951.     def putheader(self, header, *values):</font>
<font color="black"> 952.         &quot;&quot;&quot;Send a request header line to the server.</font>
<font color="black"> 953. </font>
<font color="black"> 954.         For example: h.putheader('Accept', 'text/html')</font>
<font color="black"> 955.         &quot;&quot;&quot;</font>
<font color="red"> 956.         if self.__state != _CS_REQ_STARTED:</font>
<font color="red"> 957.             raise CannotSendHeader()</font>
<font color="black"> 958. </font>
<font color="red"> 959.         hdr = '%s: %s' % (header, '\r\n\t'.join([str(v) for v in values]))</font>
<font color="red"> 960.         self._output(hdr)</font>
<font color="black"> 961. </font>
<font color="green"> 962.     def endheaders(self, message_body=None):</font>
<font color="black"> 963.         &quot;&quot;&quot;Indicate that the last header line has been sent to the server.</font>
<font color="black"> 964. </font>
<font color="black"> 965.         This method sends the request to the server.  The optional</font>
<font color="black"> 966.         message_body argument can be used to pass a message body</font>
<font color="black"> 967.         associated with the request.  The message body will be sent in</font>
<font color="black"> 968.         the same packet as the message headers if it is string, otherwise it is</font>
<font color="black"> 969.         sent as a separate packet.</font>
<font color="black"> 970.         &quot;&quot;&quot;</font>
<font color="red"> 971.         if self.__state == _CS_REQ_STARTED:</font>
<font color="red"> 972.             self.__state = _CS_REQ_SENT</font>
<font color="black"> 973.         else:</font>
<font color="red"> 974.             raise CannotSendHeader()</font>
<font color="red"> 975.         self._send_output(message_body)</font>
<font color="black"> 976. </font>
<font color="green"> 977.     def request(self, method, url, body=None, headers={}):</font>
<font color="black"> 978.         &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;</font>
<font color="red"> 979.         self._send_request(method, url, body, headers)</font>
<font color="black"> 980. </font>
<font color="green"> 981.     def _set_content_length(self, body):</font>
<font color="black"> 982.         # Set the content-length based on the body.</font>
<font color="red"> 983.         thelen = None</font>
<font color="red"> 984.         try:</font>
<font color="red"> 985.             thelen = str(len(body))</font>
<font color="red"> 986.         except TypeError, te:</font>
<font color="black"> 987.             # If this is a file-like object, try to</font>
<font color="black"> 988.             # fstat its file descriptor</font>
<font color="red"> 989.             try:</font>
<font color="red"> 990.                 thelen = str(os.fstat(body.fileno()).st_size)</font>
<font color="red"> 991.             except (AttributeError, OSError):</font>
<font color="black"> 992.                 # Don't send a length if this failed</font>
<font color="red"> 993.                 if self.debuglevel &gt; 0: print &quot;Cannot stat!!&quot;</font>
<font color="black"> 994. </font>
<font color="red"> 995.         if thelen is not None:</font>
<font color="red"> 996.             self.putheader('Content-Length', thelen)</font>
<font color="black"> 997. </font>
<font color="green"> 998.     def _send_request(self, method, url, body, headers):</font>
<font color="black"> 999.         # Honor explicitly requested Host: and Accept-Encoding: headers.</font>
<font color="red">1000.         header_names = dict.fromkeys([k.lower() for k in headers])</font>
<font color="red">1001.         skips = {}</font>
<font color="red">1002.         if 'host' in header_names:</font>
<font color="red">1003.             skips['skip_host'] = 1</font>
<font color="red">1004.         if 'accept-encoding' in header_names:</font>
<font color="red">1005.             skips['skip_accept_encoding'] = 1</font>
<font color="black">1006. </font>
<font color="red">1007.         self.putrequest(method, url, **skips)</font>
<font color="black">1008. </font>
<font color="red">1009.         if body is not None and 'content-length' not in header_names:</font>
<font color="red">1010.             self._set_content_length(body)</font>
<font color="red">1011.         for hdr, value in headers.iteritems():</font>
<font color="red">1012.             self.putheader(hdr, value)</font>
<font color="red">1013.         self.endheaders(body)</font>
<font color="black">1014. </font>
<font color="green">1015.     def getresponse(self, buffering=False):</font>
<font color="black">1016.         &quot;Get the response from the server.&quot;</font>
<font color="black">1017. </font>
<font color="black">1018.         # if a prior response has been completed, then forget about it.</font>
<font color="red">1019.         if self.__response and self.__response.isclosed():</font>
<font color="red">1020.             self.__response = None</font>
<font color="black">1021. </font>
<font color="black">1022.         #</font>
<font color="black">1023.         # if a prior response exists, then it must be completed (otherwise, we</font>
<font color="black">1024.         # cannot read this response's header to determine the connection-close</font>
<font color="black">1025.         # behavior)</font>
<font color="black">1026.         #</font>
<font color="black">1027.         # note: if a prior response existed, but was connection-close, then the</font>
<font color="black">1028.         # socket and response were made independent of this HTTPConnection</font>
<font color="black">1029.         # object since a new request requires that we open a whole new</font>
<font color="black">1030.         # connection</font>
<font color="black">1031.         #</font>
<font color="black">1032.         # this means the prior response had one of two states:</font>
<font color="black">1033.         #   1) will_close: this connection was reset and the prior socket and</font>
<font color="black">1034.         #                  response operate independently</font>
<font color="black">1035.         #   2) persistent: the response was retained and we await its</font>
<font color="black">1036.         #                  isclosed() status to become true.</font>
<font color="black">1037.         #</font>
<font color="red">1038.         if self.__state != _CS_REQ_SENT or self.__response:</font>
<font color="red">1039.             raise ResponseNotReady()</font>
<font color="black">1040. </font>
<font color="red">1041.         args = (self.sock,)</font>
<font color="red">1042.         kwds = {&quot;strict&quot;:self.strict, &quot;method&quot;:self._method}</font>
<font color="red">1043.         if self.debuglevel &gt; 0:</font>
<font color="red">1044.             args += (self.debuglevel,)</font>
<font color="red">1045.         if buffering:</font>
<font color="black">1046.             #only add this keyword if non-default, for compatibility with</font>
<font color="black">1047.             #other response_classes.</font>
<font color="red">1048.             kwds[&quot;buffering&quot;] = True;</font>
<font color="red">1049.         response = self.response_class(*args, **kwds)</font>
<font color="black">1050. </font>
<font color="red">1051.         response.begin()</font>
<font color="red">1052.         assert response.will_close != _UNKNOWN</font>
<font color="red">1053.         self.__state = _CS_IDLE</font>
<font color="black">1054. </font>
<font color="red">1055.         if response.will_close:</font>
<font color="black">1056.             # this effectively passes the connection to the response</font>
<font color="red">1057.             self.close()</font>
<font color="black">1058.         else:</font>
<font color="black">1059.             # remember this, so we can tell when it is complete</font>
<font color="red">1060.             self.__response = response</font>
<font color="black">1061. </font>
<font color="red">1062.         return response</font>
<font color="black">1063. </font>
<font color="black">1064. </font>
<font color="green">1065. class HTTP:</font>
<font color="green">1066.     &quot;Compatibility class with httplib.py from 1.5.&quot;</font>
<font color="black">1067. </font>
<font color="green">1068.     _http_vsn = 10</font>
<font color="green">1069.     _http_vsn_str = 'HTTP/1.0'</font>
<font color="black">1070. </font>
<font color="green">1071.     debuglevel = 0</font>
<font color="black">1072. </font>
<font color="green">1073.     _connection_class = HTTPConnection</font>
<font color="black">1074. </font>
<font color="green">1075.     def __init__(self, host='', port=None, strict=None):</font>
<font color="black">1076.         &quot;Provide a default host, since the superclass requires one.&quot;</font>
<font color="black">1077. </font>
<font color="black">1078.         # some joker passed 0 explicitly, meaning default port</font>
<font color="red">1079.         if port == 0:</font>
<font color="red">1080.             port = None</font>
<font color="black">1081. </font>
<font color="black">1082.         # Note that we may pass an empty string as the host; this will raise</font>
<font color="black">1083.         # an error when we attempt to connect. Presumably, the client code</font>
<font color="black">1084.         # will call connect before then, with a proper host.</font>
<font color="red">1085.         self._setup(self._connection_class(host, port, strict))</font>
<font color="black">1086. </font>
<font color="green">1087.     def _setup(self, conn):</font>
<font color="red">1088.         self._conn = conn</font>
<font color="black">1089. </font>
<font color="black">1090.         # set up delegation to flesh out interface</font>
<font color="red">1091.         self.send = conn.send</font>
<font color="red">1092.         self.putrequest = conn.putrequest</font>
<font color="red">1093.         self.putheader = conn.putheader</font>
<font color="red">1094.         self.endheaders = conn.endheaders</font>
<font color="red">1095.         self.set_debuglevel = conn.set_debuglevel</font>
<font color="black">1096. </font>
<font color="red">1097.         conn._http_vsn = self._http_vsn</font>
<font color="red">1098.         conn._http_vsn_str = self._http_vsn_str</font>
<font color="black">1099. </font>
<font color="red">1100.         self.file = None</font>
<font color="black">1101. </font>
<font color="green">1102.     def connect(self, host=None, port=None):</font>
<font color="black">1103.         &quot;Accept arguments to set the host/port, since the superclass doesn't.&quot;</font>
<font color="black">1104. </font>
<font color="red">1105.         if host is not None:</font>
<font color="red">1106.             self._conn._set_hostport(host, port)</font>
<font color="red">1107.         self._conn.connect()</font>
<font color="black">1108. </font>
<font color="green">1109.     def getfile(self):</font>
<font color="black">1110.         &quot;Provide a getfile, since the superclass' does not use this concept.&quot;</font>
<font color="red">1111.         return self.file</font>
<font color="black">1112. </font>
<font color="green">1113.     def getreply(self, buffering=False):</font>
<font color="black">1114.         &quot;&quot;&quot;Compat definition since superclass does not define it.</font>
<font color="black">1115. </font>
<font color="black">1116.         Returns a tuple consisting of:</font>
<font color="black">1117.         - server status code (e.g. '200' if all goes well)</font>
<font color="black">1118.         - server &quot;reason&quot; corresponding to status code</font>
<font color="black">1119.         - any RFC822 headers in the response from the server</font>
<font color="black">1120.         &quot;&quot;&quot;</font>
<font color="red">1121.         try:</font>
<font color="red">1122.             if not buffering:</font>
<font color="red">1123.                 response = self._conn.getresponse()</font>
<font color="black">1124.             else:</font>
<font color="black">1125.                 #only add this keyword if non-default for compatibility</font>
<font color="black">1126.                 #with other connection classes</font>
<font color="red">1127.                 response = self._conn.getresponse(buffering)</font>
<font color="red">1128.         except BadStatusLine, e:</font>
<font color="black">1129.             ### hmm. if getresponse() ever closes the socket on a bad request,</font>
<font color="black">1130.             ### then we are going to have problems with self.sock</font>
<font color="black">1131. </font>
<font color="black">1132.             ### should we keep this behavior? do people use it?</font>
<font color="black">1133.             # keep the socket open (as a file), and return it</font>
<font color="red">1134.             self.file = self._conn.sock.makefile('rb', 0)</font>
<font color="black">1135. </font>
<font color="black">1136.             # close our socket -- we want to restart after any protocol error</font>
<font color="red">1137.             self.close()</font>
<font color="black">1138. </font>
<font color="red">1139.             self.headers = None</font>
<font color="red">1140.             return -1, e.line, None</font>
<font color="black">1141. </font>
<font color="red">1142.         self.headers = response.msg</font>
<font color="red">1143.         self.file = response.fp</font>
<font color="red">1144.         return response.status, response.reason, response.msg</font>
<font color="black">1145. </font>
<font color="green">1146.     def close(self):</font>
<font color="red">1147.         self._conn.close()</font>
<font color="black">1148. </font>
<font color="black">1149.         # note that self.file == response.fp, which gets closed by the</font>
<font color="black">1150.         # superclass. just clear the object ref here.</font>
<font color="black">1151.         ### hmm. messy. if status==-1, then self.file is owned by us.</font>
<font color="black">1152.         ### well... we aren't explicitly closing, but losing this ref will</font>
<font color="black">1153.         ### do it</font>
<font color="red">1154.         self.file = None</font>
<font color="black">1155. </font>
<font color="green">1156. try:</font>
<font color="green">1157.     import ssl</font>
<font color="red">1158. except ImportError:</font>
<font color="red">1159.     pass</font>
<font color="black">1160. else:</font>
<font color="green">1161.     class HTTPSConnection(HTTPConnection):</font>
<font color="green">1162.         &quot;This class allows communication via SSL.&quot;</font>
<font color="black">1163. </font>
<font color="green">1164.         default_port = HTTPS_PORT</font>
<font color="black">1165. </font>
<font color="green">1166.         def __init__(self, host, port=None, key_file=None, cert_file=None,</font>
<font color="green">1167.                      strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,</font>
<font color="green">1168.                      source_address=None):</font>
<font color="red">1169.             HTTPConnection.__init__(self, host, port, strict, timeout,</font>
<font color="red">1170.                                     source_address)</font>
<font color="red">1171.             self.key_file = key_file</font>
<font color="red">1172.             self.cert_file = cert_file</font>
<font color="black">1173. </font>
<font color="green">1174.         def connect(self):</font>
<font color="black">1175.             &quot;Connect to a host on a given (SSL) port.&quot;</font>
<font color="black">1176. </font>
<font color="red">1177.             sock = socket.create_connection((self.host, self.port),</font>
<font color="red">1178.                                             self.timeout, self.source_address)</font>
<font color="red">1179.             if self._tunnel_host:</font>
<font color="red">1180.                 self.sock = sock</font>
<font color="red">1181.                 self._tunnel()</font>
<font color="red">1182.             self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file)</font>
<font color="black">1183. </font>
<font color="green">1184.     __all__.append(&quot;HTTPSConnection&quot;)</font>
<font color="black">1185. </font>
<font color="green">1186.     class HTTPS(HTTP):</font>
<font color="black">1187.         &quot;&quot;&quot;Compatibility with 1.5 httplib interface</font>
<font color="black">1188. </font>
<font color="black">1189.         Python 1.5.2 did not have an HTTPS class, but it defined an</font>
<font color="black">1190.         interface for sending http requests that is also useful for</font>
<font color="black">1191.         https.</font>
<font color="green">1192.         &quot;&quot;&quot;</font>
<font color="black">1193. </font>
<font color="green">1194.         _connection_class = HTTPSConnection</font>
<font color="black">1195. </font>
<font color="green">1196.         def __init__(self, host='', port=None, key_file=None, cert_file=None,</font>
<font color="green">1197.                      strict=None):</font>
<font color="black">1198.             # provide a default host, pass the X509 cert info</font>
<font color="black">1199. </font>
<font color="black">1200.             # urf. compensate for bad input.</font>
<font color="red">1201.             if port == 0:</font>
<font color="red">1202.                 port = None</font>
<font color="red">1203.             self._setup(self._connection_class(host, port, key_file,</font>
<font color="red">1204.                                                cert_file, strict))</font>
<font color="black">1205. </font>
<font color="black">1206.             # we never actually use these for anything, but we keep them</font>
<font color="black">1207.             # here for compatibility with post-1.5.2 CVS.</font>
<font color="red">1208.             self.key_file = key_file</font>
<font color="red">1209.             self.cert_file = cert_file</font>
<font color="black">1210. </font>
<font color="black">1211. </font>
<font color="green">1212.     def FakeSocket (sock, sslobj):</font>
<font color="red">1213.         warnings.warn(&quot;FakeSocket is deprecated, and won't be in 3.x.  &quot; +</font>
<font color="red">1214.                       &quot;Use the result of ssl.wrap_socket() directly instead.&quot;,</font>
<font color="red">1215.                       DeprecationWarning, stacklevel=2)</font>
<font color="red">1216.         return sslobj</font>
<font color="black">1217. </font>
<font color="black">1218. </font>
<font color="green">1219. class HTTPException(Exception):</font>
<font color="black">1220.     # Subclasses that define an __init__ must call Exception.__init__</font>
<font color="black">1221.     # or define self.args.  Otherwise, str() will fail.</font>
<font color="green">1222.     pass</font>
<font color="black">1223. </font>
<font color="green">1224. class NotConnected(HTTPException):</font>
<font color="green">1225.     pass</font>
<font color="black">1226. </font>
<font color="green">1227. class InvalidURL(HTTPException):</font>
<font color="green">1228.     pass</font>
<font color="black">1229. </font>
<font color="green">1230. class UnknownProtocol(HTTPException):</font>
<font color="green">1231.     def __init__(self, version):</font>
<font color="red">1232.         self.args = version,</font>
<font color="red">1233.         self.version = version</font>
<font color="black">1234. </font>
<font color="green">1235. class UnknownTransferEncoding(HTTPException):</font>
<font color="green">1236.     pass</font>
<font color="black">1237. </font>
<font color="green">1238. class UnimplementedFileMode(HTTPException):</font>
<font color="green">1239.     pass</font>
<font color="black">1240. </font>
<font color="green">1241. class IncompleteRead(HTTPException):</font>
<font color="green">1242.     def __init__(self, partial, expected=None):</font>
<font color="red">1243.         self.args = partial,</font>
<font color="red">1244.         self.partial = partial</font>
<font color="red">1245.         self.expected = expected</font>
<font color="green">1246.     def __repr__(self):</font>
<font color="red">1247.         if self.expected is not None:</font>
<font color="red">1248.             e = ', %i more expected' % self.expected</font>
<font color="black">1249.         else:</font>
<font color="red">1250.             e = ''</font>
<font color="red">1251.         return 'IncompleteRead(%i bytes read%s)' % (len(self.partial), e)</font>
<font color="green">1252.     def __str__(self):</font>
<font color="red">1253.         return repr(self)</font>
<font color="black">1254. </font>
<font color="green">1255. class ImproperConnectionState(HTTPException):</font>
<font color="green">1256.     pass</font>
<font color="black">1257. </font>
<font color="green">1258. class CannotSendRequest(ImproperConnectionState):</font>
<font color="green">1259.     pass</font>
<font color="black">1260. </font>
<font color="green">1261. class CannotSendHeader(ImproperConnectionState):</font>
<font color="green">1262.     pass</font>
<font color="black">1263. </font>
<font color="green">1264. class ResponseNotReady(ImproperConnectionState):</font>
<font color="green">1265.     pass</font>
<font color="black">1266. </font>
<font color="green">1267. class BadStatusLine(HTTPException):</font>
<font color="green">1268.     def __init__(self, line):</font>
<font color="red">1269.         if not line:</font>
<font color="red">1270.             line = repr(line)</font>
<font color="red">1271.         self.args = line,</font>
<font color="red">1272.         self.line = line</font>
<font color="black">1273. </font>
<font color="green">1274. class LineTooLong(HTTPException):</font>
<font color="green">1275.     def __init__(self, line_type):</font>
<font color="red">1276.         HTTPException.__init__(self, &quot;got more than %d bytes when reading %s&quot;</font>
<font color="red">1277.                                      % (_MAXLINE, line_type))</font>
<font color="black">1278. </font>
<font color="black">1279. # for backwards compatibility</font>
<font color="green">1280. error = HTTPException</font>
<font color="black">1281. </font>
<font color="green">1282. class LineAndFileWrapper:</font>
<font color="green">1283.     &quot;&quot;&quot;A limited file-like object for HTTP/0.9 responses.&quot;&quot;&quot;</font>
<font color="black">1284. </font>
<font color="black">1285.     # The status-line parsing code calls readline(), which normally</font>
<font color="black">1286.     # get the HTTP status line.  For a 0.9 response, however, this is</font>
<font color="black">1287.     # actually the first line of the body!  Clients need to get a</font>
<font color="black">1288.     # readable file object that contains that line.</font>
<font color="black">1289. </font>
<font color="green">1290.     def __init__(self, line, file):</font>
<font color="red">1291.         self._line = line</font>
<font color="red">1292.         self._file = file</font>
<font color="red">1293.         self._line_consumed = 0</font>
<font color="red">1294.         self._line_offset = 0</font>
<font color="red">1295.         self._line_left = len(line)</font>
<font color="black">1296. </font>
<font color="green">1297.     def __getattr__(self, attr):</font>
<font color="red">1298.         return getattr(self._file, attr)</font>
<font color="black">1299. </font>
<font color="green">1300.     def _done(self):</font>
<font color="black">1301.         # called when the last byte is read from the line.  After the</font>
<font color="black">1302.         # call, all read methods are delegated to the underlying file</font>
<font color="black">1303.         # object.</font>
<font color="red">1304.         self._line_consumed = 1</font>
<font color="red">1305.         self.read = self._file.read</font>
<font color="red">1306.         self.readline = self._file.readline</font>
<font color="red">1307.         self.readlines = self._file.readlines</font>
<font color="black">1308. </font>
<font color="green">1309.     def read(self, amt=None):</font>
<font color="red">1310.         if self._line_consumed:</font>
<font color="red">1311.             return self._file.read(amt)</font>
<font color="red">1312.         assert self._line_left</font>
<font color="red">1313.         if amt is None or amt &gt; self._line_left:</font>
<font color="red">1314.             s = self._line[self._line_offset:]</font>
<font color="red">1315.             self._done()</font>
<font color="red">1316.             if amt is None:</font>
<font color="red">1317.                 return s + self._file.read()</font>
<font color="black">1318.             else:</font>
<font color="red">1319.                 return s + self._file.read(amt - len(s))</font>
<font color="black">1320.         else:</font>
<font color="red">1321.             assert amt &lt;= self._line_left</font>
<font color="red">1322.             i = self._line_offset</font>
<font color="red">1323.             j = i + amt</font>
<font color="red">1324.             s = self._line[i:j]</font>
<font color="red">1325.             self._line_offset = j</font>
<font color="red">1326.             self._line_left -= amt</font>
<font color="red">1327.             if self._line_left == 0:</font>
<font color="red">1328.                 self._done()</font>
<font color="red">1329.             return s</font>
<font color="black">1330. </font>
<font color="green">1331.     def readline(self):</font>
<font color="red">1332.         if self._line_consumed:</font>
<font color="red">1333.             return self._file.readline()</font>
<font color="red">1334.         assert self._line_left</font>
<font color="red">1335.         s = self._line[self._line_offset:]</font>
<font color="red">1336.         self._done()</font>
<font color="red">1337.         return s</font>
<font color="black">1338. </font>
<font color="green">1339.     def readlines(self, size=None):</font>
<font color="red">1340.         if self._line_consumed:</font>
<font color="red">1341.             return self._file.readlines(size)</font>
<font color="red">1342.         assert self._line_left</font>
<font color="red">1343.         L = [self._line[self._line_offset:]]</font>
<font color="red">1344.         self._done()</font>
<font color="red">1345.         if size is None:</font>
<font color="red">1346.             return L + self._file.readlines()</font>
<font color="black">1347.         else:</font>
<font color="red">1348.             return L + self._file.readlines(size)</font>
</pre>

