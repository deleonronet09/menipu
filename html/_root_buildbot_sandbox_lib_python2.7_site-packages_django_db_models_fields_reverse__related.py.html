source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/fields/reverse_related.py</b><br>


file stats: <b>167 lines, 103 executed: 61.7% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. &quot;Rel objects&quot; for related fields.</font>
<font color="black">   3. </font>
<font color="black">   4. &quot;Rel objects&quot; (for lack of a better name) carry information about the relation</font>
<font color="black">   5. modeled by a related field and provide some utility functions. They're stored</font>
<font color="black">   6. in the ``remote_field`` attribute of the field.</font>
<font color="black">   7. </font>
<font color="black">   8. They also act as reverse fields for the purposes of the Meta API because</font>
<font color="black">   9. they're the closest concept currently available.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="black">  11. </font>
<font color="green">  12. from __future__ import unicode_literals</font>
<font color="black">  13. </font>
<font color="green">  14. import warnings</font>
<font color="black">  15. </font>
<font color="green">  16. from django.core import exceptions</font>
<font color="green">  17. from django.utils.deprecation import RemovedInDjango20Warning</font>
<font color="green">  18. from django.utils.encoding import smart_text</font>
<font color="green">  19. from django.utils.functional import cached_property</font>
<font color="black">  20. </font>
<font color="green">  21. from . import BLANK_CHOICE_DASH</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="green">  24. class ForeignObjectRel(object):</font>
<font color="black">  25.     &quot;&quot;&quot;</font>
<font color="black">  26.     Used by ForeignObject to store information about the relation.</font>
<font color="black">  27. </font>
<font color="black">  28.     ``_meta.get_fields()`` returns this class to provide access to the field</font>
<font color="black">  29.     flags for the reverse relation.</font>
<font color="green">  30.     &quot;&quot;&quot;</font>
<font color="black">  31. </font>
<font color="black">  32.     # Field flags</font>
<font color="green">  33.     auto_created = True</font>
<font color="green">  34.     concrete = False</font>
<font color="green">  35.     editable = False</font>
<font color="green">  36.     is_relation = True</font>
<font color="black">  37. </font>
<font color="black">  38.     # Reverse relations are always nullable (Django can't enforce that a</font>
<font color="black">  39.     # foreign key on the related model points to this model).</font>
<font color="green">  40.     null = True</font>
<font color="black">  41. </font>
<font color="green">  42.     def __init__(self, field, to, related_name=None, related_query_name=None,</font>
<font color="green">  43.             limit_choices_to=None, parent_link=False, on_delete=None):</font>
<font color="green">  44.         self.field = field</font>
<font color="green">  45.         self.model = to</font>
<font color="green">  46.         self.related_name = related_name</font>
<font color="green">  47.         self.related_query_name = related_query_name</font>
<font color="green">  48.         self.limit_choices_to = {} if limit_choices_to is None else limit_choices_to</font>
<font color="green">  49.         self.parent_link = parent_link</font>
<font color="green">  50.         self.on_delete = on_delete</font>
<font color="black">  51. </font>
<font color="green">  52.         self.symmetrical = False</font>
<font color="green">  53.         self.multiple = True</font>
<font color="black">  54. </font>
<font color="black">  55.     # Some of the following cached_properties can't be initialized in</font>
<font color="black">  56.     # __init__ as the field doesn't have its model yet. Calling these methods</font>
<font color="black">  57.     # before field.contribute_to_class() has been called will result in</font>
<font color="black">  58.     # AttributeError</font>
<font color="green">  59.     @property</font>
<font color="black">  60.     def to(self):</font>
<font color="red">  61.         warnings.warn(</font>
<font color="red">  62.             &quot;Usage of ForeignObjectRel.to attribute has been deprecated. &quot;</font>
<font color="black">  63.             &quot;Use the model attribute instead.&quot;,</font>
<font color="red">  64.             RemovedInDjango20Warning, 2)</font>
<font color="red">  65.         return self.model</font>
<font color="black">  66. </font>
<font color="green">  67.     @cached_property</font>
<font color="black">  68.     def hidden(self):</font>
<font color="red">  69.         return self.is_hidden()</font>
<font color="black">  70. </font>
<font color="green">  71.     @cached_property</font>
<font color="black">  72.     def name(self):</font>
<font color="green">  73.         return self.field.related_query_name()</font>
<font color="black">  74. </font>
<font color="green">  75.     @property</font>
<font color="black">  76.     def remote_field(self):</font>
<font color="red">  77.         return self.field</font>
<font color="black">  78. </font>
<font color="green">  79.     @property</font>
<font color="black">  80.     def target_field(self):</font>
<font color="black">  81.         &quot;&quot;&quot;</font>
<font color="black">  82.         When filtering against this relation, returns the field on the remote</font>
<font color="black">  83.         model against which the filtering should happen.</font>
<font color="black">  84.         &quot;&quot;&quot;</font>
<font color="red">  85.         target_fields = self.get_path_info()[-1].target_fields</font>
<font color="red">  86.         if len(target_fields) &gt; 1:</font>
<font color="red">  87.             raise exceptions.FieldError(&quot;Can't use target_field for multicolumn relations.&quot;)</font>
<font color="red">  88.         return target_fields[0]</font>
<font color="black">  89. </font>
<font color="green">  90.     @cached_property</font>
<font color="black">  91.     def related_model(self):</font>
<font color="green">  92.         if not self.field.model:</font>
<font color="red">  93.             raise AttributeError(</font>
<font color="red">  94.                 &quot;This property can't be accessed before self.field.contribute_to_class has been called.&quot;)</font>
<font color="green">  95.         return self.field.model</font>
<font color="black">  96. </font>
<font color="green">  97.     @cached_property</font>
<font color="black">  98.     def many_to_many(self):</font>
<font color="red">  99.         return self.field.many_to_many</font>
<font color="black"> 100. </font>
<font color="green"> 101.     @cached_property</font>
<font color="black"> 102.     def many_to_one(self):</font>
<font color="red"> 103.         return self.field.one_to_many</font>
<font color="black"> 104. </font>
<font color="green"> 105.     @cached_property</font>
<font color="black"> 106.     def one_to_many(self):</font>
<font color="red"> 107.         return self.field.many_to_one</font>
<font color="black"> 108. </font>
<font color="green"> 109.     @cached_property</font>
<font color="black"> 110.     def one_to_one(self):</font>
<font color="red"> 111.         return self.field.one_to_one</font>
<font color="black"> 112. </font>
<font color="green"> 113.     def get_prep_lookup(self, lookup_name, value):</font>
<font color="red"> 114.         return self.field.get_prep_lookup(lookup_name, value)</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def get_lookup(self, lookup_name):</font>
<font color="red"> 117.         return self.field.get_lookup(lookup_name)</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def get_internal_type(self):</font>
<font color="red"> 120.         return self.field.get_internal_type()</font>
<font color="black"> 121. </font>
<font color="green"> 122.     @property</font>
<font color="black"> 123.     def db_type(self):</font>
<font color="red"> 124.         return self.field.db_type</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def __repr__(self):</font>
<font color="red"> 127.         return '&lt;%s: %s.%s&gt;' % (</font>
<font color="red"> 128.             type(self).__name__,</font>
<font color="red"> 129.             self.related_model._meta.app_label,</font>
<font color="red"> 130.             self.related_model._meta.model_name,</font>
<font color="black"> 131.         )</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH,</font>
<font color="green"> 134.                     limit_to_currently_related=False):</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="black"> 136.         Return choices with a default blank choices included, for use as</font>
<font color="black"> 137.         SelectField choices for this field.</font>
<font color="black"> 138. </font>
<font color="black"> 139.         Analog of django.db.models.fields.Field.get_choices(), provided</font>
<font color="black"> 140.         initially for utilization by RelatedFieldListFilter.</font>
<font color="black"> 141.         &quot;&quot;&quot;</font>
<font color="red"> 142.         first_choice = blank_choice if include_blank else []</font>
<font color="red"> 143.         queryset = self.related_model._default_manager.all()</font>
<font color="red"> 144.         if limit_to_currently_related:</font>
<font color="red"> 145.             queryset = queryset.complex_filter(</font>
<font color="red"> 146.                 {'%s__isnull' % self.related_model._meta.model_name: False}</font>
<font color="black"> 147.             )</font>
<font color="red"> 148.         lst = [(x._get_pk_val(), smart_text(x)) for x in queryset]</font>
<font color="red"> 149.         return first_choice + lst</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def get_db_prep_lookup(self, lookup_type, value, connection, prepared=False):</font>
<font color="black"> 152.         # Defer to the actual field definition for db prep</font>
<font color="red"> 153.         return self.field.get_db_prep_lookup(lookup_type, value, connection=connection, prepared=prepared)</font>
<font color="black"> 154. </font>
<font color="green"> 155.     def is_hidden(self):</font>
<font color="black"> 156.         &quot;Should the related object be hidden?&quot;</font>
<font color="green"> 157.         return bool(self.related_name) and self.related_name[-1] == '+'</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def get_joining_columns(self):</font>
<font color="red"> 160.         return self.field.get_reverse_joining_columns()</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def get_extra_restriction(self, where_class, alias, related_alias):</font>
<font color="red"> 163.         return self.field.get_extra_restriction(where_class, related_alias, alias)</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def set_field_name(self):</font>
<font color="black"> 166.         &quot;&quot;&quot;</font>
<font color="black"> 167.         Set the related field's name, this is not available until later stages</font>
<font color="black"> 168.         of app loading, so set_field_name is called from</font>
<font color="black"> 169.         set_attributes_from_rel()</font>
<font color="black"> 170.         &quot;&quot;&quot;</font>
<font color="black"> 171.         # By default foreign object doesn't relate to any remote field (for</font>
<font color="black"> 172.         # example custom multicolumn joins currently have no remote field).</font>
<font color="red"> 173.         self.field_name = None</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def get_accessor_name(self, model=None):</font>
<font color="black"> 176.         # This method encapsulates the logic that decides what name to give an</font>
<font color="black"> 177.         # accessor descriptor that retrieves related many-to-one or</font>
<font color="black"> 178.         # many-to-many objects. It uses the lower-cased object_name + &quot;_set&quot;,</font>
<font color="black"> 179.         # but this can be overridden with the &quot;related_name&quot; option.</font>
<font color="black"> 180.         # Due to backwards compatibility ModelForms need to be able to provide</font>
<font color="black"> 181.         # an alternate model. See BaseInlineFormSet.get_default_prefix().</font>
<font color="green"> 182.         opts = model._meta if model else self.related_model._meta</font>
<font color="green"> 183.         model = model or self.related_model</font>
<font color="green"> 184.         if self.multiple:</font>
<font color="black"> 185.             # If this is a symmetrical m2m relation on self, there is no reverse accessor.</font>
<font color="green"> 186.             if self.symmetrical and model == self.model:</font>
<font color="red"> 187.                 return None</font>
<font color="green"> 188.         if self.related_name:</font>
<font color="green"> 189.             return self.related_name</font>
<font color="green"> 190.         if opts.default_related_name:</font>
<font color="red"> 191.             return opts.default_related_name % {</font>
<font color="red"> 192.                 'model_name': opts.model_name.lower(),</font>
<font color="red"> 193.                 'app_label': opts.app_label.lower(),</font>
<font color="black"> 194.             }</font>
<font color="green"> 195.         return opts.model_name + ('_set' if self.multiple else '')</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def get_cache_name(self):</font>
<font color="red"> 198.         return &quot;_%s_cache&quot; % self.get_accessor_name()</font>
<font color="black"> 199. </font>
<font color="green"> 200.     def get_path_info(self):</font>
<font color="red"> 201.         return self.field.get_reverse_path_info()</font>
<font color="black"> 202. </font>
<font color="black"> 203. </font>
<font color="green"> 204. class ManyToOneRel(ForeignObjectRel):</font>
<font color="black"> 205.     &quot;&quot;&quot;</font>
<font color="black"> 206.     Used by the ForeignKey field to store information about the relation.</font>
<font color="black"> 207. </font>
<font color="black"> 208.     ``_meta.get_fields()`` returns this class to provide access to the field</font>
<font color="black"> 209.     flags for the reverse relation.</font>
<font color="black"> 210. </font>
<font color="black"> 211.     Note: Because we somewhat abuse the Rel objects by using them as reverse</font>
<font color="black"> 212.     fields we get the funny situation where</font>
<font color="black"> 213.     ``ManyToOneRel.many_to_one == False`` and</font>
<font color="black"> 214.     ``ManyToOneRel.one_to_many == True``. This is unfortunate but the actual</font>
<font color="black"> 215.     ManyToOneRel class is a private API and there is work underway to turn</font>
<font color="black"> 216.     reverse relations into actual fields.</font>
<font color="green"> 217.     &quot;&quot;&quot;</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def __init__(self, field, to, field_name, related_name=None, related_query_name=None,</font>
<font color="green"> 220.             limit_choices_to=None, parent_link=False, on_delete=None):</font>
<font color="green"> 221.         super(ManyToOneRel, self).__init__(</font>
<font color="green"> 222.             field, to,</font>
<font color="green"> 223.             related_name=related_name,</font>
<font color="green"> 224.             related_query_name=related_query_name,</font>
<font color="green"> 225.             limit_choices_to=limit_choices_to,</font>
<font color="green"> 226.             parent_link=parent_link,</font>
<font color="green"> 227.             on_delete=on_delete,</font>
<font color="black"> 228.         )</font>
<font color="black"> 229. </font>
<font color="green"> 230.         self.field_name = field_name</font>
<font color="black"> 231. </font>
<font color="green"> 232.     def __getstate__(self):</font>
<font color="green"> 233.         state = self.__dict__.copy()</font>
<font color="green"> 234.         state.pop('related_model', None)</font>
<font color="green"> 235.         return state</font>
<font color="black"> 236. </font>
<font color="green"> 237.     def get_related_field(self):</font>
<font color="black"> 238.         &quot;&quot;&quot;</font>
<font color="black"> 239.         Return the Field in the 'to' object to which this relationship is tied.</font>
<font color="black"> 240.         &quot;&quot;&quot;</font>
<font color="red"> 241.         field = self.model._meta.get_field(self.field_name)</font>
<font color="red"> 242.         if not field.concrete:</font>
<font color="red"> 243.             raise exceptions.FieldDoesNotExist(&quot;No related field named '%s'&quot; %</font>
<font color="red"> 244.                     self.field_name)</font>
<font color="red"> 245.         return field</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def set_field_name(self):</font>
<font color="green"> 248.         self.field_name = self.field_name or self.model._meta.pk.name</font>
<font color="black"> 249. </font>
<font color="black"> 250. </font>
<font color="green"> 251. class OneToOneRel(ManyToOneRel):</font>
<font color="black"> 252.     &quot;&quot;&quot;</font>
<font color="black"> 253.     Used by OneToOneField to store information about the relation.</font>
<font color="black"> 254. </font>
<font color="black"> 255.     ``_meta.get_fields()`` returns this class to provide access to the field</font>
<font color="black"> 256.     flags for the reverse relation.</font>
<font color="green"> 257.     &quot;&quot;&quot;</font>
<font color="black"> 258. </font>
<font color="green"> 259.     def __init__(self, field, to, field_name, related_name=None, related_query_name=None,</font>
<font color="green"> 260.             limit_choices_to=None, parent_link=False, on_delete=None):</font>
<font color="red"> 261.         super(OneToOneRel, self).__init__(</font>
<font color="red"> 262.             field, to, field_name,</font>
<font color="red"> 263.             related_name=related_name,</font>
<font color="red"> 264.             related_query_name=related_query_name,</font>
<font color="red"> 265.             limit_choices_to=limit_choices_to,</font>
<font color="red"> 266.             parent_link=parent_link,</font>
<font color="red"> 267.             on_delete=on_delete,</font>
<font color="black"> 268.         )</font>
<font color="black"> 269. </font>
<font color="red"> 270.         self.multiple = False</font>
<font color="black"> 271. </font>
<font color="black"> 272. </font>
<font color="green"> 273. class ManyToManyRel(ForeignObjectRel):</font>
<font color="black"> 274.     &quot;&quot;&quot;</font>
<font color="black"> 275.     Used by ManyToManyField to store information about the relation.</font>
<font color="black"> 276. </font>
<font color="black"> 277.     ``_meta.get_fields()`` returns this class to provide access to the field</font>
<font color="black"> 278.     flags for the reverse relation.</font>
<font color="green"> 279.     &quot;&quot;&quot;</font>
<font color="black"> 280. </font>
<font color="green"> 281.     def __init__(self, field, to, related_name=None, related_query_name=None,</font>
<font color="green"> 282.             limit_choices_to=None, symmetrical=True, through=None, through_fields=None,</font>
<font color="green"> 283.             db_constraint=True):</font>
<font color="green"> 284.         super(ManyToManyRel, self).__init__(</font>
<font color="green"> 285.             field, to,</font>
<font color="green"> 286.             related_name=related_name,</font>
<font color="green"> 287.             related_query_name=related_query_name,</font>
<font color="green"> 288.             limit_choices_to=limit_choices_to,</font>
<font color="black"> 289.         )</font>
<font color="black"> 290. </font>
<font color="green"> 291.         if through and not db_constraint:</font>
<font color="red"> 292.             raise ValueError(&quot;Can't supply a through model and db_constraint=False&quot;)</font>
<font color="green"> 293.         self.through = through</font>
<font color="black"> 294. </font>
<font color="green"> 295.         if through_fields and not through:</font>
<font color="red"> 296.             raise ValueError(&quot;Cannot specify through_fields without a through model&quot;)</font>
<font color="green"> 297.         self.through_fields = through_fields</font>
<font color="black"> 298. </font>
<font color="green"> 299.         self.symmetrical = symmetrical</font>
<font color="green"> 300.         self.db_constraint = db_constraint</font>
<font color="black"> 301. </font>
<font color="green"> 302.     def get_related_field(self):</font>
<font color="black"> 303.         &quot;&quot;&quot;</font>
<font color="black"> 304.         Return the field in the 'to' object to which this relationship is tied.</font>
<font color="black"> 305.         Provided for symmetry with ManyToOneRel.</font>
<font color="black"> 306.         &quot;&quot;&quot;</font>
<font color="red"> 307.         opts = self.through._meta</font>
<font color="red"> 308.         if self.through_fields:</font>
<font color="red"> 309.             field = opts.get_field(self.through_fields[0])</font>
<font color="black"> 310.         else:</font>
<font color="red"> 311.             for field in opts.fields:</font>
<font color="red"> 312.                 rel = getattr(field, 'remote_field', None)</font>
<font color="red"> 313.                 if rel and rel.model == self.model:</font>
<font color="red"> 314.                     break</font>
<font color="red"> 315.         return field.foreign_related_fields[0]</font>
</pre>

