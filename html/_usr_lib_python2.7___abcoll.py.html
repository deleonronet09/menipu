source file: <b>/usr/lib/python2.7/_abcoll.py</b><br>


file stats: <b>391 lines, 21 executed: 5.4% covered</b>
<pre>
<font color="black">   1. # Copyright 2007 Google, Inc. All Rights Reserved.</font>
<font color="black">   2. # Licensed to PSF under a Contributor Agreement.</font>
<font color="black">   3. </font>
<font color="black">   4. &quot;&quot;&quot;Abstract Base Classes (ABCs) for collections, according to PEP 3119.</font>
<font color="black">   5. </font>
<font color="black">   6. DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported</font>
<font color="black">   7. via collections; they are defined here only to alleviate certain</font>
<font color="black">   8. bootstrapping issues.  Unit tests are in test_collections.</font>
<font color="red">   9. &quot;&quot;&quot;</font>
<font color="black">  10. </font>
<font color="red">  11. from abc import ABCMeta, abstractmethod</font>
<font color="red">  12. import sys</font>
<font color="black">  13. </font>
<font color="red">  14. __all__ = [&quot;Hashable&quot;, &quot;Iterable&quot;, &quot;Iterator&quot;,</font>
<font color="red">  15.            &quot;Sized&quot;, &quot;Container&quot;, &quot;Callable&quot;,</font>
<font color="red">  16.            &quot;Set&quot;, &quot;MutableSet&quot;,</font>
<font color="red">  17.            &quot;Mapping&quot;, &quot;MutableMapping&quot;,</font>
<font color="red">  18.            &quot;MappingView&quot;, &quot;KeysView&quot;, &quot;ItemsView&quot;, &quot;ValuesView&quot;,</font>
<font color="red">  19.            &quot;Sequence&quot;, &quot;MutableSequence&quot;,</font>
<font color="black">  20.            ]</font>
<font color="black">  21. </font>
<font color="black">  22. ### ONE-TRICK PONIES ###</font>
<font color="black">  23. </font>
<font color="red">  24. def _hasattr(C, attr):</font>
<font color="green">  25.     try:</font>
<font color="green">  26.         return any(attr in B.__dict__ for B in C.__mro__)</font>
<font color="red">  27.     except AttributeError:</font>
<font color="black">  28.         # Old-style class</font>
<font color="red">  29.         return hasattr(C, attr)</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="red">  32. class Hashable:</font>
<font color="red">  33.     __metaclass__ = ABCMeta</font>
<font color="black">  34. </font>
<font color="red">  35.     @abstractmethod</font>
<font color="black">  36.     def __hash__(self):</font>
<font color="red">  37.         return 0</font>
<font color="black">  38. </font>
<font color="red">  39.     @classmethod</font>
<font color="black">  40.     def __subclasshook__(cls, C):</font>
<font color="red">  41.         if cls is Hashable:</font>
<font color="red">  42.             try:</font>
<font color="red">  43.                 for B in C.__mro__:</font>
<font color="red">  44.                     if &quot;__hash__&quot; in B.__dict__:</font>
<font color="red">  45.                         if B.__dict__[&quot;__hash__&quot;]:</font>
<font color="red">  46.                             return True</font>
<font color="red">  47.                         break</font>
<font color="red">  48.             except AttributeError:</font>
<font color="black">  49.                 # Old-style class</font>
<font color="red">  50.                 if getattr(C, &quot;__hash__&quot;, None):</font>
<font color="red">  51.                     return True</font>
<font color="red">  52.         return NotImplemented</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="red">  55. class Iterable:</font>
<font color="red">  56.     __metaclass__ = ABCMeta</font>
<font color="black">  57. </font>
<font color="red">  58.     @abstractmethod</font>
<font color="black">  59.     def __iter__(self):</font>
<font color="red">  60.         while False:</font>
<font color="red">  61.             yield None</font>
<font color="black">  62. </font>
<font color="red">  63.     @classmethod</font>
<font color="black">  64.     def __subclasshook__(cls, C):</font>
<font color="green">  65.         if cls is Iterable:</font>
<font color="green">  66.             if _hasattr(C, &quot;__iter__&quot;):</font>
<font color="green">  67.                 return True</font>
<font color="red">  68.         return NotImplemented</font>
<font color="black">  69. </font>
<font color="red">  70. Iterable.register(str)</font>
<font color="black">  71. </font>
<font color="black">  72. </font>
<font color="red">  73. class Iterator(Iterable):</font>
<font color="black">  74. </font>
<font color="red">  75.     @abstractmethod</font>
<font color="black">  76.     def next(self):</font>
<font color="black">  77.         'Return the next item from the iterator. When exhausted, raise StopIteration'</font>
<font color="red">  78.         raise StopIteration</font>
<font color="black">  79. </font>
<font color="red">  80.     def __iter__(self):</font>
<font color="red">  81.         return self</font>
<font color="black">  82. </font>
<font color="red">  83.     @classmethod</font>
<font color="black">  84.     def __subclasshook__(cls, C):</font>
<font color="green">  85.         if cls is Iterator:</font>
<font color="green">  86.             if _hasattr(C, &quot;next&quot;) and _hasattr(C, &quot;__iter__&quot;):</font>
<font color="red">  87.                 return True</font>
<font color="green">  88.         return NotImplemented</font>
<font color="black">  89. </font>
<font color="black">  90. </font>
<font color="red">  91. class Sized:</font>
<font color="red">  92.     __metaclass__ = ABCMeta</font>
<font color="black">  93. </font>
<font color="red">  94.     @abstractmethod</font>
<font color="black">  95.     def __len__(self):</font>
<font color="red">  96.         return 0</font>
<font color="black">  97. </font>
<font color="red">  98.     @classmethod</font>
<font color="black">  99.     def __subclasshook__(cls, C):</font>
<font color="green"> 100.         if cls is Sized:</font>
<font color="red"> 101.             if _hasattr(C, &quot;__len__&quot;):</font>
<font color="red"> 102.                 return True</font>
<font color="green"> 103.         return NotImplemented</font>
<font color="black"> 104. </font>
<font color="black"> 105. </font>
<font color="red"> 106. class Container:</font>
<font color="red"> 107.     __metaclass__ = ABCMeta</font>
<font color="black"> 108. </font>
<font color="red"> 109.     @abstractmethod</font>
<font color="black"> 110.     def __contains__(self, x):</font>
<font color="red"> 111.         return False</font>
<font color="black"> 112. </font>
<font color="red"> 113.     @classmethod</font>
<font color="black"> 114.     def __subclasshook__(cls, C):</font>
<font color="red"> 115.         if cls is Container:</font>
<font color="red"> 116.             if _hasattr(C, &quot;__contains__&quot;):</font>
<font color="red"> 117.                 return True</font>
<font color="red"> 118.         return NotImplemented</font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="red"> 121. class Callable:</font>
<font color="red"> 122.     __metaclass__ = ABCMeta</font>
<font color="black"> 123. </font>
<font color="red"> 124.     @abstractmethod</font>
<font color="black"> 125.     def __call__(self, *args, **kwds):</font>
<font color="red"> 126.         return False</font>
<font color="black"> 127. </font>
<font color="red"> 128.     @classmethod</font>
<font color="black"> 129.     def __subclasshook__(cls, C):</font>
<font color="red"> 130.         if cls is Callable:</font>
<font color="red"> 131.             if _hasattr(C, &quot;__call__&quot;):</font>
<font color="red"> 132.                 return True</font>
<font color="red"> 133.         return NotImplemented</font>
<font color="black"> 134. </font>
<font color="black"> 135. </font>
<font color="black"> 136. ### SETS ###</font>
<font color="black"> 137. </font>
<font color="black"> 138. </font>
<font color="red"> 139. class Set(Sized, Iterable, Container):</font>
<font color="black"> 140.     &quot;&quot;&quot;A set is a finite, iterable container.</font>
<font color="black"> 141. </font>
<font color="black"> 142.     This class provides concrete generic implementations of all</font>
<font color="black"> 143.     methods except for __contains__, __iter__ and __len__.</font>
<font color="black"> 144. </font>
<font color="black"> 145.     To override the comparisons (presumably for speed, as the</font>
<font color="black"> 146.     semantics are fixed), all you have to do is redefine __le__ and</font>
<font color="black"> 147.     then the other operations will automatically follow suit.</font>
<font color="red"> 148.     &quot;&quot;&quot;</font>
<font color="black"> 149. </font>
<font color="red"> 150.     def __le__(self, other):</font>
<font color="red"> 151.         if not isinstance(other, Set):</font>
<font color="red"> 152.             return NotImplemented</font>
<font color="red"> 153.         if len(self) &gt; len(other):</font>
<font color="red"> 154.             return False</font>
<font color="red"> 155.         for elem in self:</font>
<font color="red"> 156.             if elem not in other:</font>
<font color="red"> 157.                 return False</font>
<font color="red"> 158.         return True</font>
<font color="black"> 159. </font>
<font color="red"> 160.     def __lt__(self, other):</font>
<font color="red"> 161.         if not isinstance(other, Set):</font>
<font color="red"> 162.             return NotImplemented</font>
<font color="red"> 163.         return len(self) &lt; len(other) and self.__le__(other)</font>
<font color="black"> 164. </font>
<font color="red"> 165.     def __gt__(self, other):</font>
<font color="red"> 166.         if not isinstance(other, Set):</font>
<font color="red"> 167.             return NotImplemented</font>
<font color="red"> 168.         return other.__lt__(self)</font>
<font color="black"> 169. </font>
<font color="red"> 170.     def __ge__(self, other):</font>
<font color="red"> 171.         if not isinstance(other, Set):</font>
<font color="red"> 172.             return NotImplemented</font>
<font color="red"> 173.         return other.__le__(self)</font>
<font color="black"> 174. </font>
<font color="red"> 175.     def __eq__(self, other):</font>
<font color="red"> 176.         if not isinstance(other, Set):</font>
<font color="red"> 177.             return NotImplemented</font>
<font color="red"> 178.         return len(self) == len(other) and self.__le__(other)</font>
<font color="black"> 179. </font>
<font color="red"> 180.     def __ne__(self, other):</font>
<font color="red"> 181.         return not (self == other)</font>
<font color="black"> 182. </font>
<font color="red"> 183.     @classmethod</font>
<font color="black"> 184.     def _from_iterable(cls, it):</font>
<font color="black"> 185.         '''Construct an instance of the class from any iterable input.</font>
<font color="black"> 186. </font>
<font color="black"> 187.         Must override this method if the class constructor signature</font>
<font color="black"> 188.         does not accept an iterable for an input.</font>
<font color="black"> 189.         '''</font>
<font color="red"> 190.         return cls(it)</font>
<font color="black"> 191. </font>
<font color="red"> 192.     def __and__(self, other):</font>
<font color="red"> 193.         if not isinstance(other, Iterable):</font>
<font color="red"> 194.             return NotImplemented</font>
<font color="red"> 195.         return self._from_iterable(value for value in other if value in self)</font>
<font color="black"> 196. </font>
<font color="red"> 197.     def isdisjoint(self, other):</font>
<font color="black"> 198.         'Return True if two sets have a null intersection.'</font>
<font color="red"> 199.         for value in other:</font>
<font color="red"> 200.             if value in self:</font>
<font color="red"> 201.                 return False</font>
<font color="red"> 202.         return True</font>
<font color="black"> 203. </font>
<font color="red"> 204.     def __or__(self, other):</font>
<font color="red"> 205.         if not isinstance(other, Iterable):</font>
<font color="red"> 206.             return NotImplemented</font>
<font color="red"> 207.         chain = (e for s in (self, other) for e in s)</font>
<font color="red"> 208.         return self._from_iterable(chain)</font>
<font color="black"> 209. </font>
<font color="red"> 210.     def __sub__(self, other):</font>
<font color="red"> 211.         if not isinstance(other, Set):</font>
<font color="red"> 212.             if not isinstance(other, Iterable):</font>
<font color="red"> 213.                 return NotImplemented</font>
<font color="red"> 214.             other = self._from_iterable(other)</font>
<font color="red"> 215.         return self._from_iterable(value for value in self</font>
<font color="red"> 216.                                    if value not in other)</font>
<font color="black"> 217. </font>
<font color="red"> 218.     def __xor__(self, other):</font>
<font color="red"> 219.         if not isinstance(other, Set):</font>
<font color="red"> 220.             if not isinstance(other, Iterable):</font>
<font color="red"> 221.                 return NotImplemented</font>
<font color="red"> 222.             other = self._from_iterable(other)</font>
<font color="red"> 223.         return (self - other) | (other - self)</font>
<font color="black"> 224. </font>
<font color="black"> 225.     # Sets are not hashable by default, but subclasses can change this</font>
<font color="red"> 226.     __hash__ = None</font>
<font color="black"> 227. </font>
<font color="red"> 228.     def _hash(self):</font>
<font color="black"> 229.         &quot;&quot;&quot;Compute the hash value of a set.</font>
<font color="black"> 230. </font>
<font color="black"> 231.         Note that we don't define __hash__: not all sets are hashable.</font>
<font color="black"> 232.         But if you define a hashable set type, its __hash__ should</font>
<font color="black"> 233.         call this function.</font>
<font color="black"> 234. </font>
<font color="black"> 235.         This must be compatible __eq__.</font>
<font color="black"> 236. </font>
<font color="black"> 237.         All sets ought to compare equal if they contain the same</font>
<font color="black"> 238.         elements, regardless of how they are implemented, and</font>
<font color="black"> 239.         regardless of the order of the elements; so there's not much</font>
<font color="black"> 240.         freedom for __eq__ or __hash__.  We match the algorithm used</font>
<font color="black"> 241.         by the built-in frozenset type.</font>
<font color="black"> 242.         &quot;&quot;&quot;</font>
<font color="red"> 243.         MAX = sys.maxint</font>
<font color="red"> 244.         MASK = 2 * MAX + 1</font>
<font color="red"> 245.         n = len(self)</font>
<font color="red"> 246.         h = 1927868237 * (n + 1)</font>
<font color="red"> 247.         h &amp;= MASK</font>
<font color="red"> 248.         for x in self:</font>
<font color="red"> 249.             hx = hash(x)</font>
<font color="red"> 250.             h ^= (hx ^ (hx &lt;&lt; 16) ^ 89869747)  * 3644798167</font>
<font color="red"> 251.             h &amp;= MASK</font>
<font color="red"> 252.         h = h * 69069 + 907133923</font>
<font color="red"> 253.         h &amp;= MASK</font>
<font color="red"> 254.         if h &gt; MAX:</font>
<font color="red"> 255.             h -= MASK + 1</font>
<font color="red"> 256.         if h == -1:</font>
<font color="red"> 257.             h = 590923713</font>
<font color="red"> 258.         return h</font>
<font color="black"> 259. </font>
<font color="red"> 260. Set.register(frozenset)</font>
<font color="black"> 261. </font>
<font color="black"> 262. </font>
<font color="red"> 263. class MutableSet(Set):</font>
<font color="black"> 264.     &quot;&quot;&quot;A mutable set is a finite, iterable container.</font>
<font color="black"> 265. </font>
<font color="black"> 266.     This class provides concrete generic implementations of all</font>
<font color="black"> 267.     methods except for __contains__, __iter__, __len__,</font>
<font color="black"> 268.     add(), and discard().</font>
<font color="black"> 269. </font>
<font color="black"> 270.     To override the comparisons (presumably for speed, as the</font>
<font color="black"> 271.     semantics are fixed), all you have to do is redefine __le__ and</font>
<font color="black"> 272.     then the other operations will automatically follow suit.</font>
<font color="red"> 273.     &quot;&quot;&quot;</font>
<font color="black"> 274. </font>
<font color="red"> 275.     @abstractmethod</font>
<font color="black"> 276.     def add(self, value):</font>
<font color="black"> 277.         &quot;&quot;&quot;Add an element.&quot;&quot;&quot;</font>
<font color="red"> 278.         raise NotImplementedError</font>
<font color="black"> 279. </font>
<font color="red"> 280.     @abstractmethod</font>
<font color="black"> 281.     def discard(self, value):</font>
<font color="black"> 282.         &quot;&quot;&quot;Remove an element.  Do not raise an exception if absent.&quot;&quot;&quot;</font>
<font color="red"> 283.         raise NotImplementedError</font>
<font color="black"> 284. </font>
<font color="red"> 285.     def remove(self, value):</font>
<font color="black"> 286.         &quot;&quot;&quot;Remove an element. If not a member, raise a KeyError.&quot;&quot;&quot;</font>
<font color="red"> 287.         if value not in self:</font>
<font color="red"> 288.             raise KeyError(value)</font>
<font color="red"> 289.         self.discard(value)</font>
<font color="black"> 290. </font>
<font color="red"> 291.     def pop(self):</font>
<font color="black"> 292.         &quot;&quot;&quot;Return the popped value.  Raise KeyError if empty.&quot;&quot;&quot;</font>
<font color="red"> 293.         it = iter(self)</font>
<font color="red"> 294.         try:</font>
<font color="red"> 295.             value = next(it)</font>
<font color="red"> 296.         except StopIteration:</font>
<font color="red"> 297.             raise KeyError</font>
<font color="red"> 298.         self.discard(value)</font>
<font color="red"> 299.         return value</font>
<font color="black"> 300. </font>
<font color="red"> 301.     def clear(self):</font>
<font color="black"> 302.         &quot;&quot;&quot;This is slow (creates N new iterators!) but effective.&quot;&quot;&quot;</font>
<font color="red"> 303.         try:</font>
<font color="red"> 304.             while True:</font>
<font color="red"> 305.                 self.pop()</font>
<font color="red"> 306.         except KeyError:</font>
<font color="red"> 307.             pass</font>
<font color="black"> 308. </font>
<font color="red"> 309.     def __ior__(self, it):</font>
<font color="red"> 310.         for value in it:</font>
<font color="red"> 311.             self.add(value)</font>
<font color="red"> 312.         return self</font>
<font color="black"> 313. </font>
<font color="red"> 314.     def __iand__(self, it):</font>
<font color="red"> 315.         for value in (self - it):</font>
<font color="red"> 316.             self.discard(value)</font>
<font color="red"> 317.         return self</font>
<font color="black"> 318. </font>
<font color="red"> 319.     def __ixor__(self, it):</font>
<font color="red"> 320.         if it is self:</font>
<font color="red"> 321.             self.clear()</font>
<font color="black"> 322.         else:</font>
<font color="red"> 323.             if not isinstance(it, Set):</font>
<font color="red"> 324.                 it = self._from_iterable(it)</font>
<font color="red"> 325.             for value in it:</font>
<font color="red"> 326.                 if value in self:</font>
<font color="red"> 327.                     self.discard(value)</font>
<font color="black"> 328.                 else:</font>
<font color="red"> 329.                     self.add(value)</font>
<font color="red"> 330.         return self</font>
<font color="black"> 331. </font>
<font color="red"> 332.     def __isub__(self, it):</font>
<font color="red"> 333.         if it is self:</font>
<font color="red"> 334.             self.clear()</font>
<font color="black"> 335.         else:</font>
<font color="red"> 336.             for value in it:</font>
<font color="red"> 337.                 self.discard(value)</font>
<font color="red"> 338.         return self</font>
<font color="black"> 339. </font>
<font color="red"> 340. MutableSet.register(set)</font>
<font color="black"> 341. </font>
<font color="black"> 342. </font>
<font color="black"> 343. ### MAPPINGS ###</font>
<font color="black"> 344. </font>
<font color="black"> 345. </font>
<font color="red"> 346. class Mapping(Sized, Iterable, Container):</font>
<font color="black"> 347. </font>
<font color="black"> 348.     &quot;&quot;&quot;A Mapping is a generic container for associating key/value</font>
<font color="black"> 349.     pairs.</font>
<font color="black"> 350. </font>
<font color="black"> 351.     This class provides concrete generic implementations of all</font>
<font color="black"> 352.     methods except for __getitem__, __iter__, and __len__.</font>
<font color="black"> 353. </font>
<font color="red"> 354.     &quot;&quot;&quot;</font>
<font color="black"> 355. </font>
<font color="red"> 356.     @abstractmethod</font>
<font color="black"> 357.     def __getitem__(self, key):</font>
<font color="red"> 358.         raise KeyError</font>
<font color="black"> 359. </font>
<font color="red"> 360.     def get(self, key, default=None):</font>
<font color="black"> 361.         'D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.'</font>
<font color="red"> 362.         try:</font>
<font color="red"> 363.             return self[key]</font>
<font color="red"> 364.         except KeyError:</font>
<font color="red"> 365.             return default</font>
<font color="black"> 366. </font>
<font color="red"> 367.     def __contains__(self, key):</font>
<font color="red"> 368.         try:</font>
<font color="red"> 369.             self[key]</font>
<font color="red"> 370.         except KeyError:</font>
<font color="red"> 371.             return False</font>
<font color="black"> 372.         else:</font>
<font color="red"> 373.             return True</font>
<font color="black"> 374. </font>
<font color="red"> 375.     def iterkeys(self):</font>
<font color="black"> 376.         'D.iterkeys() -&gt; an iterator over the keys of D'</font>
<font color="red"> 377.         return iter(self)</font>
<font color="black"> 378. </font>
<font color="red"> 379.     def itervalues(self):</font>
<font color="black"> 380.         'D.itervalues() -&gt; an iterator over the values of D'</font>
<font color="red"> 381.         for key in self:</font>
<font color="red"> 382.             yield self[key]</font>
<font color="black"> 383. </font>
<font color="red"> 384.     def iteritems(self):</font>
<font color="black"> 385.         'D.iteritems() -&gt; an iterator over the (key, value) items of D'</font>
<font color="red"> 386.         for key in self:</font>
<font color="red"> 387.             yield (key, self[key])</font>
<font color="black"> 388. </font>
<font color="red"> 389.     def keys(self):</font>
<font color="black"> 390.         &quot;D.keys() -&gt; list of D's keys&quot;</font>
<font color="red"> 391.         return list(self)</font>
<font color="black"> 392. </font>
<font color="red"> 393.     def items(self):</font>
<font color="black"> 394.         &quot;D.items() -&gt; list of D's (key, value) pairs, as 2-tuples&quot;</font>
<font color="red"> 395.         return [(key, self[key]) for key in self]</font>
<font color="black"> 396. </font>
<font color="red"> 397.     def values(self):</font>
<font color="black"> 398.         &quot;D.values() -&gt; list of D's values&quot;</font>
<font color="red"> 399.         return [self[key] for key in self]</font>
<font color="black"> 400. </font>
<font color="black"> 401.     # Mappings are not hashable by default, but subclasses can change this</font>
<font color="red"> 402.     __hash__ = None</font>
<font color="black"> 403. </font>
<font color="red"> 404.     def __eq__(self, other):</font>
<font color="red"> 405.         if not isinstance(other, Mapping):</font>
<font color="red"> 406.             return NotImplemented</font>
<font color="red"> 407.         return dict(self.items()) == dict(other.items())</font>
<font color="black"> 408. </font>
<font color="red"> 409.     def __ne__(self, other):</font>
<font color="red"> 410.         return not (self == other)</font>
<font color="black"> 411. </font>
<font color="red"> 412. class MappingView(Sized):</font>
<font color="black"> 413. </font>
<font color="red"> 414.     def __init__(self, mapping):</font>
<font color="red"> 415.         self._mapping = mapping</font>
<font color="black"> 416. </font>
<font color="red"> 417.     def __len__(self):</font>
<font color="red"> 418.         return len(self._mapping)</font>
<font color="black"> 419. </font>
<font color="red"> 420.     def __repr__(self):</font>
<font color="red"> 421.         return '{0.__class__.__name__}({0._mapping!r})'.format(self)</font>
<font color="black"> 422. </font>
<font color="black"> 423. </font>
<font color="red"> 424. class KeysView(MappingView, Set):</font>
<font color="black"> 425. </font>
<font color="red"> 426.     @classmethod</font>
<font color="black"> 427.     def _from_iterable(self, it):</font>
<font color="red"> 428.         return set(it)</font>
<font color="black"> 429. </font>
<font color="red"> 430.     def __contains__(self, key):</font>
<font color="red"> 431.         return key in self._mapping</font>
<font color="black"> 432. </font>
<font color="red"> 433.     def __iter__(self):</font>
<font color="red"> 434.         for key in self._mapping:</font>
<font color="red"> 435.             yield key</font>
<font color="black"> 436. </font>
<font color="black"> 437. </font>
<font color="red"> 438. class ItemsView(MappingView, Set):</font>
<font color="black"> 439. </font>
<font color="red"> 440.     @classmethod</font>
<font color="black"> 441.     def _from_iterable(self, it):</font>
<font color="red"> 442.         return set(it)</font>
<font color="black"> 443. </font>
<font color="red"> 444.     def __contains__(self, item):</font>
<font color="red"> 445.         key, value = item</font>
<font color="red"> 446.         try:</font>
<font color="red"> 447.             v = self._mapping[key]</font>
<font color="red"> 448.         except KeyError:</font>
<font color="red"> 449.             return False</font>
<font color="black"> 450.         else:</font>
<font color="red"> 451.             return v == value</font>
<font color="black"> 452. </font>
<font color="red"> 453.     def __iter__(self):</font>
<font color="red"> 454.         for key in self._mapping:</font>
<font color="red"> 455.             yield (key, self._mapping[key])</font>
<font color="black"> 456. </font>
<font color="black"> 457. </font>
<font color="red"> 458. class ValuesView(MappingView):</font>
<font color="black"> 459. </font>
<font color="red"> 460.     def __contains__(self, value):</font>
<font color="red"> 461.         for key in self._mapping:</font>
<font color="red"> 462.             if value == self._mapping[key]:</font>
<font color="red"> 463.                 return True</font>
<font color="red"> 464.         return False</font>
<font color="black"> 465. </font>
<font color="red"> 466.     def __iter__(self):</font>
<font color="red"> 467.         for key in self._mapping:</font>
<font color="red"> 468.             yield self._mapping[key]</font>
<font color="black"> 469. </font>
<font color="black"> 470. </font>
<font color="red"> 471. class MutableMapping(Mapping):</font>
<font color="black"> 472. </font>
<font color="black"> 473.     &quot;&quot;&quot;A MutableMapping is a generic container for associating</font>
<font color="black"> 474.     key/value pairs.</font>
<font color="black"> 475. </font>
<font color="black"> 476.     This class provides concrete generic implementations of all</font>
<font color="black"> 477.     methods except for __getitem__, __setitem__, __delitem__,</font>
<font color="black"> 478.     __iter__, and __len__.</font>
<font color="black"> 479. </font>
<font color="red"> 480.     &quot;&quot;&quot;</font>
<font color="black"> 481. </font>
<font color="red"> 482.     @abstractmethod</font>
<font color="black"> 483.     def __setitem__(self, key, value):</font>
<font color="red"> 484.         raise KeyError</font>
<font color="black"> 485. </font>
<font color="red"> 486.     @abstractmethod</font>
<font color="black"> 487.     def __delitem__(self, key):</font>
<font color="red"> 488.         raise KeyError</font>
<font color="black"> 489. </font>
<font color="red"> 490.     __marker = object()</font>
<font color="black"> 491. </font>
<font color="red"> 492.     def pop(self, key, default=__marker):</font>
<font color="black"> 493.         '''D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</font>
<font color="black"> 494.           If key is not found, d is returned if given, otherwise KeyError is raised.</font>
<font color="black"> 495.         '''</font>
<font color="red"> 496.         try:</font>
<font color="red"> 497.             value = self[key]</font>
<font color="red"> 498.         except KeyError:</font>
<font color="red"> 499.             if default is self.__marker:</font>
<font color="red"> 500.                 raise</font>
<font color="red"> 501.             return default</font>
<font color="black"> 502.         else:</font>
<font color="red"> 503.             del self[key]</font>
<font color="red"> 504.             return value</font>
<font color="black"> 505. </font>
<font color="red"> 506.     def popitem(self):</font>
<font color="black"> 507.         '''D.popitem() -&gt; (k, v), remove and return some (key, value) pair</font>
<font color="black"> 508.            as a 2-tuple; but raise KeyError if D is empty.</font>
<font color="black"> 509.         '''</font>
<font color="red"> 510.         try:</font>
<font color="red"> 511.             key = next(iter(self))</font>
<font color="red"> 512.         except StopIteration:</font>
<font color="red"> 513.             raise KeyError</font>
<font color="red"> 514.         value = self[key]</font>
<font color="red"> 515.         del self[key]</font>
<font color="red"> 516.         return key, value</font>
<font color="black"> 517. </font>
<font color="red"> 518.     def clear(self):</font>
<font color="black"> 519.         'D.clear() -&gt; None.  Remove all items from D.'</font>
<font color="red"> 520.         try:</font>
<font color="red"> 521.             while True:</font>
<font color="red"> 522.                 self.popitem()</font>
<font color="red"> 523.         except KeyError:</font>
<font color="red"> 524.             pass</font>
<font color="black"> 525. </font>
<font color="red"> 526.     def update(*args, **kwds):</font>
<font color="black"> 527.         ''' D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.</font>
<font color="black"> 528.             If E present and has a .keys() method, does:     for k in E: D[k] = E[k]</font>
<font color="black"> 529.             If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v</font>
<font color="black"> 530.             In either case, this is followed by: for k, v in F.items(): D[k] = v</font>
<font color="black"> 531.         '''</font>
<font color="green"> 532.         if len(args) &gt; 2:</font>
<font color="red"> 533.             raise TypeError(&quot;update() takes at most 2 positional &quot;</font>
<font color="red"> 534.                             &quot;arguments ({} given)&quot;.format(len(args)))</font>
<font color="green"> 535.         elif not args:</font>
<font color="red"> 536.             raise TypeError(&quot;update() takes at least 1 argument (0 given)&quot;)</font>
<font color="green"> 537.         self = args[0]</font>
<font color="green"> 538.         other = args[1] if len(args) &gt;= 2 else ()</font>
<font color="black"> 539. </font>
<font color="green"> 540.         if isinstance(other, Mapping):</font>
<font color="green"> 541.             for key in other:</font>
<font color="green"> 542.                 self[key] = other[key]</font>
<font color="green"> 543.         elif hasattr(other, &quot;keys&quot;):</font>
<font color="red"> 544.             for key in other.keys():</font>
<font color="red"> 545.                 self[key] = other[key]</font>
<font color="black"> 546.         else:</font>
<font color="green"> 547.             for key, value in other:</font>
<font color="green"> 548.                 self[key] = value</font>
<font color="green"> 549.         for key, value in kwds.items():</font>
<font color="red"> 550.             self[key] = value</font>
<font color="black"> 551. </font>
<font color="red"> 552.     def setdefault(self, key, default=None):</font>
<font color="black"> 553.         'D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D'</font>
<font color="red"> 554.         try:</font>
<font color="red"> 555.             return self[key]</font>
<font color="red"> 556.         except KeyError:</font>
<font color="red"> 557.             self[key] = default</font>
<font color="red"> 558.         return default</font>
<font color="black"> 559. </font>
<font color="red"> 560. MutableMapping.register(dict)</font>
<font color="black"> 561. </font>
<font color="black"> 562. </font>
<font color="black"> 563. ### SEQUENCES ###</font>
<font color="black"> 564. </font>
<font color="black"> 565. </font>
<font color="red"> 566. class Sequence(Sized, Iterable, Container):</font>
<font color="black"> 567.     &quot;&quot;&quot;All the operations on a read-only sequence.</font>
<font color="black"> 568. </font>
<font color="black"> 569.     Concrete subclasses must override __new__ or __init__,</font>
<font color="black"> 570.     __getitem__, and __len__.</font>
<font color="red"> 571.     &quot;&quot;&quot;</font>
<font color="black"> 572. </font>
<font color="red"> 573.     @abstractmethod</font>
<font color="black"> 574.     def __getitem__(self, index):</font>
<font color="red"> 575.         raise IndexError</font>
<font color="black"> 576. </font>
<font color="red"> 577.     def __iter__(self):</font>
<font color="red"> 578.         i = 0</font>
<font color="red"> 579.         try:</font>
<font color="red"> 580.             while True:</font>
<font color="red"> 581.                 v = self[i]</font>
<font color="red"> 582.                 yield v</font>
<font color="red"> 583.                 i += 1</font>
<font color="red"> 584.         except IndexError:</font>
<font color="red"> 585.             return</font>
<font color="black"> 586. </font>
<font color="red"> 587.     def __contains__(self, value):</font>
<font color="red"> 588.         for v in self:</font>
<font color="red"> 589.             if v == value:</font>
<font color="red"> 590.                 return True</font>
<font color="red"> 591.         return False</font>
<font color="black"> 592. </font>
<font color="red"> 593.     def __reversed__(self):</font>
<font color="red"> 594.         for i in reversed(range(len(self))):</font>
<font color="red"> 595.             yield self[i]</font>
<font color="black"> 596. </font>
<font color="red"> 597.     def index(self, value):</font>
<font color="black"> 598.         '''S.index(value) -&gt; integer -- return first index of value.</font>
<font color="black"> 599.            Raises ValueError if the value is not present.</font>
<font color="black"> 600.         '''</font>
<font color="red"> 601.         for i, v in enumerate(self):</font>
<font color="red"> 602.             if v == value:</font>
<font color="red"> 603.                 return i</font>
<font color="red"> 604.         raise ValueError</font>
<font color="black"> 605. </font>
<font color="red"> 606.     def count(self, value):</font>
<font color="black"> 607.         'S.count(value) -&gt; integer -- return number of occurrences of value'</font>
<font color="red"> 608.         return sum(1 for v in self if v == value)</font>
<font color="black"> 609. </font>
<font color="red"> 610. Sequence.register(tuple)</font>
<font color="red"> 611. Sequence.register(basestring)</font>
<font color="red"> 612. Sequence.register(buffer)</font>
<font color="red"> 613. Sequence.register(xrange)</font>
<font color="black"> 614. </font>
<font color="black"> 615. </font>
<font color="red"> 616. class MutableSequence(Sequence):</font>
<font color="black"> 617. </font>
<font color="black"> 618.     &quot;&quot;&quot;All the operations on a read-only sequence.</font>
<font color="black"> 619. </font>
<font color="black"> 620.     Concrete subclasses must provide __new__ or __init__,</font>
<font color="black"> 621.     __getitem__, __setitem__, __delitem__, __len__, and insert().</font>
<font color="black"> 622. </font>
<font color="red"> 623.     &quot;&quot;&quot;</font>
<font color="black"> 624. </font>
<font color="red"> 625.     @abstractmethod</font>
<font color="black"> 626.     def __setitem__(self, index, value):</font>
<font color="red"> 627.         raise IndexError</font>
<font color="black"> 628. </font>
<font color="red"> 629.     @abstractmethod</font>
<font color="black"> 630.     def __delitem__(self, index):</font>
<font color="red"> 631.         raise IndexError</font>
<font color="black"> 632. </font>
<font color="red"> 633.     @abstractmethod</font>
<font color="black"> 634.     def insert(self, index, value):</font>
<font color="black"> 635.         'S.insert(index, object) -- insert object before index'</font>
<font color="red"> 636.         raise IndexError</font>
<font color="black"> 637. </font>
<font color="red"> 638.     def append(self, value):</font>
<font color="black"> 639.         'S.append(object) -- append object to the end of the sequence'</font>
<font color="red"> 640.         self.insert(len(self), value)</font>
<font color="black"> 641. </font>
<font color="red"> 642.     def reverse(self):</font>
<font color="black"> 643.         'S.reverse() -- reverse *IN PLACE*'</font>
<font color="red"> 644.         n = len(self)</font>
<font color="red"> 645.         for i in range(n//2):</font>
<font color="red"> 646.             self[i], self[n-i-1] = self[n-i-1], self[i]</font>
<font color="black"> 647. </font>
<font color="red"> 648.     def extend(self, values):</font>
<font color="black"> 649.         'S.extend(iterable) -- extend sequence by appending elements from the iterable'</font>
<font color="red"> 650.         for v in values:</font>
<font color="red"> 651.             self.append(v)</font>
<font color="black"> 652. </font>
<font color="red"> 653.     def pop(self, index=-1):</font>
<font color="black"> 654.         '''S.pop([index]) -&gt; item -- remove and return item at index (default last).</font>
<font color="black"> 655.            Raise IndexError if list is empty or index is out of range.</font>
<font color="black"> 656.         '''</font>
<font color="red"> 657.         v = self[index]</font>
<font color="red"> 658.         del self[index]</font>
<font color="red"> 659.         return v</font>
<font color="black"> 660. </font>
<font color="red"> 661.     def remove(self, value):</font>
<font color="black"> 662.         '''S.remove(value) -- remove first occurrence of value.</font>
<font color="black"> 663.            Raise ValueError if the value is not present.</font>
<font color="black"> 664.         '''</font>
<font color="red"> 665.         del self[self.index(value)]</font>
<font color="black"> 666. </font>
<font color="red"> 667.     def __iadd__(self, values):</font>
<font color="red"> 668.         self.extend(values)</font>
<font color="red"> 669.         return self</font>
<font color="black"> 670. </font>
<font color="red"> 671. MutableSequence.register(list)</font>
</pre>

