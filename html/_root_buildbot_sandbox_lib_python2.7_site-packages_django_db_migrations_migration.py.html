source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/migrations/migration.py</b><br>


file stats: <b>89 lines, 43 executed: 48.3% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. from django.db.transaction import atomic</font>
<font color="green">   4. from django.utils.encoding import python_2_unicode_compatible</font>
<font color="black">   5. </font>
<font color="green">   6. from .exceptions import IrreversibleError</font>
<font color="black">   7. </font>
<font color="black">   8. </font>
<font color="green">   9. @python_2_unicode_compatible</font>
<font color="green">  10. class Migration(object):</font>
<font color="black">  11.     &quot;&quot;&quot;</font>
<font color="black">  12.     The base class for all migrations.</font>
<font color="black">  13. </font>
<font color="black">  14.     Migration files will import this from django.db.migrations.Migration</font>
<font color="black">  15.     and subclass it as a class called Migration. It will have one or more</font>
<font color="black">  16.     of the following attributes:</font>
<font color="black">  17. </font>
<font color="black">  18.      - operations: A list of Operation instances, probably from django.db.migrations.operations</font>
<font color="black">  19.      - dependencies: A list of tuples of (app_path, migration_name)</font>
<font color="black">  20.      - run_before: A list of tuples of (app_path, migration_name)</font>
<font color="black">  21.      - replaces: A list of migration_names</font>
<font color="black">  22. </font>
<font color="black">  23.     Note that all migrations come out of migrations and into the Loader or</font>
<font color="black">  24.     Graph as instances, having been initialized with their app label and name.</font>
<font color="green">  25.     &quot;&quot;&quot;</font>
<font color="black">  26. </font>
<font color="black">  27.     # Operations to apply during this migration, in order.</font>
<font color="green">  28.     operations = []</font>
<font color="black">  29. </font>
<font color="black">  30.     # Other migrations that should be run before this migration.</font>
<font color="black">  31.     # Should be a list of (app, migration_name).</font>
<font color="green">  32.     dependencies = []</font>
<font color="black">  33. </font>
<font color="black">  34.     # Other migrations that should be run after this one (i.e. have</font>
<font color="black">  35.     # this migration added to their dependencies). Useful to make third-party</font>
<font color="black">  36.     # apps' migrations run after your AUTH_USER replacement, for example.</font>
<font color="green">  37.     run_before = []</font>
<font color="black">  38. </font>
<font color="black">  39.     # Migration names in this app that this migration replaces. If this is</font>
<font color="black">  40.     # non-empty, this migration will only be applied if all these migrations</font>
<font color="black">  41.     # are not applied.</font>
<font color="green">  42.     replaces = []</font>
<font color="black">  43. </font>
<font color="black">  44.     # Is this an initial migration? Initial migrations are skipped on</font>
<font color="black">  45.     # --fake-initial if the table or fields already exist. If None, check if</font>
<font color="black">  46.     # the migration has any dependencies to determine if there are dependencies</font>
<font color="black">  47.     # to tell if db introspection needs to be done. If True, always perform</font>
<font color="black">  48.     # introspection. If False, never perform introspection.</font>
<font color="green">  49.     initial = None</font>
<font color="black">  50. </font>
<font color="green">  51.     def __init__(self, name, app_label):</font>
<font color="green">  52.         self.name = name</font>
<font color="green">  53.         self.app_label = app_label</font>
<font color="black">  54.         # Copy dependencies &amp; other attrs as we might mutate them at runtime</font>
<font color="green">  55.         self.operations = list(self.__class__.operations)</font>
<font color="green">  56.         self.dependencies = list(self.__class__.dependencies)</font>
<font color="green">  57.         self.run_before = list(self.__class__.run_before)</font>
<font color="green">  58.         self.replaces = list(self.__class__.replaces)</font>
<font color="black">  59. </font>
<font color="green">  60.     def __eq__(self, other):</font>
<font color="red">  61.         if not isinstance(other, Migration):</font>
<font color="red">  62.             return False</font>
<font color="red">  63.         return (self.name == other.name) and (self.app_label == other.app_label)</font>
<font color="black">  64. </font>
<font color="green">  65.     def __ne__(self, other):</font>
<font color="red">  66.         return not (self == other)</font>
<font color="black">  67. </font>
<font color="green">  68.     def __repr__(self):</font>
<font color="red">  69.         return &quot;&lt;Migration %s.%s&gt;&quot; % (self.app_label, self.name)</font>
<font color="black">  70. </font>
<font color="green">  71.     def __str__(self):</font>
<font color="red">  72.         return &quot;%s.%s&quot; % (self.app_label, self.name)</font>
<font color="black">  73. </font>
<font color="green">  74.     def __hash__(self):</font>
<font color="green">  75.         return hash(&quot;%s.%s&quot; % (self.app_label, self.name))</font>
<font color="black">  76. </font>
<font color="green">  77.     def mutate_state(self, project_state, preserve=True):</font>
<font color="black">  78.         &quot;&quot;&quot;</font>
<font color="black">  79.         Takes a ProjectState and returns a new one with the migration's</font>
<font color="black">  80.         operations applied to it. Preserves the original object state by</font>
<font color="black">  81.         default and will return a mutated state from a copy.</font>
<font color="black">  82.         &quot;&quot;&quot;</font>
<font color="red">  83.         new_state = project_state</font>
<font color="red">  84.         if preserve:</font>
<font color="red">  85.             new_state = project_state.clone()</font>
<font color="black">  86. </font>
<font color="red">  87.         for operation in self.operations:</font>
<font color="red">  88.             operation.state_forwards(self.app_label, new_state)</font>
<font color="red">  89.         return new_state</font>
<font color="black">  90. </font>
<font color="green">  91.     def apply(self, project_state, schema_editor, collect_sql=False):</font>
<font color="black">  92.         &quot;&quot;&quot;</font>
<font color="black">  93.         Takes a project_state representing all migrations prior to this one</font>
<font color="black">  94.         and a schema_editor for a live database and applies the migration</font>
<font color="black">  95.         in a forwards order.</font>
<font color="black">  96. </font>
<font color="black">  97.         Returns the resulting project state for efficient re-use by following</font>
<font color="black">  98.         Migrations.</font>
<font color="black">  99.         &quot;&quot;&quot;</font>
<font color="green"> 100.         for operation in self.operations:</font>
<font color="black"> 101.             # If this operation cannot be represented as SQL, place a comment</font>
<font color="black"> 102.             # there instead</font>
<font color="green"> 103.             if collect_sql:</font>
<font color="red"> 104.                 schema_editor.collected_sql.append(&quot;--&quot;)</font>
<font color="red"> 105.                 if not operation.reduces_to_sql:</font>
<font color="red"> 106.                     schema_editor.collected_sql.append(</font>
<font color="red"> 107.                         &quot;-- MIGRATION NOW PERFORMS OPERATION THAT CANNOT BE WRITTEN AS SQL:&quot;</font>
<font color="black"> 108.                     )</font>
<font color="red"> 109.                 schema_editor.collected_sql.append(&quot;-- %s&quot; % operation.describe())</font>
<font color="red"> 110.                 schema_editor.collected_sql.append(&quot;--&quot;)</font>
<font color="red"> 111.                 if not operation.reduces_to_sql:</font>
<font color="red"> 112.                     continue</font>
<font color="black"> 113.             # Save the state before the operation has run</font>
<font color="green"> 114.             old_state = project_state.clone()</font>
<font color="green"> 115.             operation.state_forwards(self.app_label, project_state)</font>
<font color="black"> 116.             # Run the operation</font>
<font color="green"> 117.             if not schema_editor.connection.features.can_rollback_ddl and operation.atomic:</font>
<font color="black"> 118.                 # We're forcing a transaction on a non-transactional-DDL backend</font>
<font color="red"> 119.                 with atomic(schema_editor.connection.alias):</font>
<font color="red"> 120.                     operation.database_forwards(self.app_label, schema_editor, old_state, project_state)</font>
<font color="black"> 121.             else:</font>
<font color="black"> 122.                 # Normal behaviour</font>
<font color="green"> 123.                 operation.database_forwards(self.app_label, schema_editor, old_state, project_state)</font>
<font color="green"> 124.         return project_state</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def unapply(self, project_state, schema_editor, collect_sql=False):</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         Takes a project_state representing all migrations prior to this one</font>
<font color="black"> 129.         and a schema_editor for a live database and applies the migration</font>
<font color="black"> 130.         in a reverse order.</font>
<font color="black"> 131. </font>
<font color="black"> 132.         The backwards migration process consists of two phases:</font>
<font color="black"> 133. </font>
<font color="black"> 134.         1. The intermediate states from right before the first until right</font>
<font color="black"> 135.            after the last operation inside this migration are preserved.</font>
<font color="black"> 136.         2. The operations are applied in reverse order using the states</font>
<font color="black"> 137.            recorded in step 1.</font>
<font color="black"> 138.         &quot;&quot;&quot;</font>
<font color="black"> 139.         # Construct all the intermediate states we need for a reverse migration</font>
<font color="red"> 140.         to_run = []</font>
<font color="red"> 141.         new_state = project_state</font>
<font color="black"> 142.         # Phase 1</font>
<font color="red"> 143.         for operation in self.operations:</font>
<font color="black"> 144.             # If it's irreversible, error out</font>
<font color="red"> 145.             if not operation.reversible:</font>
<font color="red"> 146.                 raise IrreversibleError(&quot;Operation %s in %s is not reversible&quot; % (operation, self))</font>
<font color="black"> 147.             # Preserve new state from previous run to not tamper the same state</font>
<font color="black"> 148.             # over all operations</font>
<font color="red"> 149.             new_state = new_state.clone()</font>
<font color="red"> 150.             old_state = new_state.clone()</font>
<font color="red"> 151.             operation.state_forwards(self.app_label, new_state)</font>
<font color="red"> 152.             to_run.insert(0, (operation, old_state, new_state))</font>
<font color="black"> 153. </font>
<font color="black"> 154.         # Phase 2</font>
<font color="red"> 155.         for operation, to_state, from_state in to_run:</font>
<font color="red"> 156.             if collect_sql:</font>
<font color="red"> 157.                 schema_editor.collected_sql.append(&quot;--&quot;)</font>
<font color="red"> 158.                 if not operation.reduces_to_sql:</font>
<font color="red"> 159.                     schema_editor.collected_sql.append(</font>
<font color="red"> 160.                         &quot;-- MIGRATION NOW PERFORMS OPERATION THAT CANNOT BE WRITTEN AS SQL:&quot;</font>
<font color="black"> 161.                     )</font>
<font color="red"> 162.                 schema_editor.collected_sql.append(&quot;-- %s&quot; % operation.describe())</font>
<font color="red"> 163.                 schema_editor.collected_sql.append(&quot;--&quot;)</font>
<font color="red"> 164.                 if not operation.reduces_to_sql:</font>
<font color="red"> 165.                     continue</font>
<font color="red"> 166.             if not schema_editor.connection.features.can_rollback_ddl and operation.atomic:</font>
<font color="black"> 167.                 # We're forcing a transaction on a non-transactional-DDL backend</font>
<font color="red"> 168.                 with atomic(schema_editor.connection.alias):</font>
<font color="red"> 169.                     operation.database_backwards(self.app_label, schema_editor, from_state, to_state)</font>
<font color="black"> 170.             else:</font>
<font color="black"> 171.                 # Normal behaviour</font>
<font color="red"> 172.                 operation.database_backwards(self.app_label, schema_editor, from_state, to_state)</font>
<font color="red"> 173.         return project_state</font>
<font color="black"> 174. </font>
<font color="black"> 175. </font>
<font color="green"> 176. class SwappableTuple(tuple):</font>
<font color="black"> 177.     &quot;&quot;&quot;</font>
<font color="black"> 178.     Subclass of tuple so Django can tell this was originally a swappable</font>
<font color="black"> 179.     dependency when it reads the migration file.</font>
<font color="green"> 180.     &quot;&quot;&quot;</font>
<font color="black"> 181. </font>
<font color="green"> 182.     def __new__(cls, value, setting):</font>
<font color="green"> 183.         self = tuple.__new__(cls, value)</font>
<font color="green"> 184.         self.setting = setting</font>
<font color="green"> 185.         return self</font>
<font color="black"> 186. </font>
<font color="black"> 187. </font>
<font color="green"> 188. def swappable_dependency(value):</font>
<font color="black"> 189.     &quot;&quot;&quot;</font>
<font color="black"> 190.     Turns a setting value into a dependency.</font>
<font color="black"> 191.     &quot;&quot;&quot;</font>
<font color="green"> 192.     return SwappableTuple((value.split(&quot;.&quot;, 1)[0], &quot;__first__&quot;), value)</font>
</pre>

