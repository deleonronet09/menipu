source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/parser.py</b><br>


file stats: <b>690 lines, 66 executed: 9.6% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.parser</font>
<font color="black">   4.     ~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Implements the template parser.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">   9.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. from jinja2 import nodes</font>
<font color="green">  12. from jinja2.exceptions import TemplateSyntaxError, TemplateAssertionError</font>
<font color="green">  13. from jinja2.lexer import describe_token, describe_token_expr</font>
<font color="green">  14. from jinja2._compat import imap</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. _statement_keywords = frozenset(['for', 'if', 'block', 'extends', 'print',</font>
<font color="green">  18.                                  'macro', 'include', 'from', 'import',</font>
<font color="green">  19.                                  'set'])</font>
<font color="green">  20. _compare_operators = frozenset(['eq', 'ne', 'lt', 'lteq', 'gt', 'gteq'])</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="green">  23. class Parser(object):</font>
<font color="black">  24.     &quot;&quot;&quot;This is the central parsing class Jinja2 uses.  It's passed to</font>
<font color="black">  25.     extensions and can be used to parse expressions or statements.</font>
<font color="green">  26.     &quot;&quot;&quot;</font>
<font color="black">  27. </font>
<font color="green">  28.     def __init__(self, environment, source, name=None, filename=None,</font>
<font color="green">  29.                  state=None):</font>
<font color="red">  30.         self.environment = environment</font>
<font color="red">  31.         self.stream = environment._tokenize(source, name, filename, state)</font>
<font color="red">  32.         self.name = name</font>
<font color="red">  33.         self.filename = filename</font>
<font color="red">  34.         self.closed = False</font>
<font color="red">  35.         self.extensions = {}</font>
<font color="red">  36.         for extension in environment.iter_extensions():</font>
<font color="red">  37.             for tag in extension.tags:</font>
<font color="red">  38.                 self.extensions[tag] = extension.parse</font>
<font color="red">  39.         self._last_identifier = 0</font>
<font color="red">  40.         self._tag_stack = []</font>
<font color="red">  41.         self._end_token_stack = []</font>
<font color="black">  42. </font>
<font color="green">  43.     def fail(self, msg, lineno=None, exc=TemplateSyntaxError):</font>
<font color="black">  44.         &quot;&quot;&quot;Convenience method that raises `exc` with the message, passed</font>
<font color="black">  45.         line number or last line number as well as the current name and</font>
<font color="black">  46.         filename.</font>
<font color="black">  47.         &quot;&quot;&quot;</font>
<font color="red">  48.         if lineno is None:</font>
<font color="red">  49.             lineno = self.stream.current.lineno</font>
<font color="red">  50.         raise exc(msg, lineno, self.name, self.filename)</font>
<font color="black">  51. </font>
<font color="green">  52.     def _fail_ut_eof(self, name, end_token_stack, lineno):</font>
<font color="red">  53.         expected = []</font>
<font color="red">  54.         for exprs in end_token_stack:</font>
<font color="red">  55.             expected.extend(imap(describe_token_expr, exprs))</font>
<font color="red">  56.         if end_token_stack:</font>
<font color="red">  57.             currently_looking = ' or '.join(</font>
<font color="red">  58.                 &quot;'%s'&quot; % describe_token_expr(expr)</font>
<font color="red">  59.                 for expr in end_token_stack[-1])</font>
<font color="black">  60.         else:</font>
<font color="red">  61.             currently_looking = None</font>
<font color="black">  62. </font>
<font color="red">  63.         if name is None:</font>
<font color="red">  64.             message = ['Unexpected end of template.']</font>
<font color="black">  65.         else:</font>
<font color="red">  66.             message = ['Encountered unknown tag \'%s\'.' % name]</font>
<font color="black">  67. </font>
<font color="red">  68.         if currently_looking:</font>
<font color="red">  69.             if name is not None and name in expected:</font>
<font color="red">  70.                 message.append('You probably made a nesting mistake. Jinja '</font>
<font color="black">  71.                                'is expecting this tag, but currently looking '</font>
<font color="red">  72.                                'for %s.' % currently_looking)</font>
<font color="black">  73.             else:</font>
<font color="red">  74.                 message.append('Jinja was looking for the following tags: '</font>
<font color="red">  75.                                '%s.' % currently_looking)</font>
<font color="black">  76. </font>
<font color="red">  77.         if self._tag_stack:</font>
<font color="red">  78.             message.append('The innermost block that needs to be '</font>
<font color="red">  79.                            'closed is \'%s\'.' % self._tag_stack[-1])</font>
<font color="black">  80. </font>
<font color="red">  81.         self.fail(' '.join(message), lineno)</font>
<font color="black">  82. </font>
<font color="green">  83.     def fail_unknown_tag(self, name, lineno=None):</font>
<font color="black">  84.         &quot;&quot;&quot;Called if the parser encounters an unknown tag.  Tries to fail</font>
<font color="black">  85.         with a human readable error message that could help to identify</font>
<font color="black">  86.         the problem.</font>
<font color="black">  87.         &quot;&quot;&quot;</font>
<font color="red">  88.         return self._fail_ut_eof(name, self._end_token_stack, lineno)</font>
<font color="black">  89. </font>
<font color="green">  90.     def fail_eof(self, end_tokens=None, lineno=None):</font>
<font color="black">  91.         &quot;&quot;&quot;Like fail_unknown_tag but for end of template situations.&quot;&quot;&quot;</font>
<font color="red">  92.         stack = list(self._end_token_stack)</font>
<font color="red">  93.         if end_tokens is not None:</font>
<font color="red">  94.             stack.append(end_tokens)</font>
<font color="red">  95.         return self._fail_ut_eof(None, stack, lineno)</font>
<font color="black">  96. </font>
<font color="green">  97.     def is_tuple_end(self, extra_end_rules=None):</font>
<font color="black">  98.         &quot;&quot;&quot;Are we at the end of a tuple?&quot;&quot;&quot;</font>
<font color="red">  99.         if self.stream.current.type in ('variable_end', 'block_end', 'rparen'):</font>
<font color="red"> 100.             return True</font>
<font color="red"> 101.         elif extra_end_rules is not None:</font>
<font color="red"> 102.             return self.stream.current.test_any(extra_end_rules)</font>
<font color="red"> 103.         return False</font>
<font color="black"> 104. </font>
<font color="green"> 105.     def free_identifier(self, lineno=None):</font>
<font color="black"> 106.         &quot;&quot;&quot;Return a new free identifier as :class:`~jinja2.nodes.InternalName`.&quot;&quot;&quot;</font>
<font color="red"> 107.         self._last_identifier += 1</font>
<font color="red"> 108.         rv = object.__new__(nodes.InternalName)</font>
<font color="red"> 109.         nodes.Node.__init__(rv, 'fi%d' % self._last_identifier, lineno=lineno)</font>
<font color="red"> 110.         return rv</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def parse_statement(self):</font>
<font color="black"> 113.         &quot;&quot;&quot;Parse a single statement.&quot;&quot;&quot;</font>
<font color="red"> 114.         token = self.stream.current</font>
<font color="red"> 115.         if token.type != 'name':</font>
<font color="red"> 116.             self.fail('tag name expected', token.lineno)</font>
<font color="red"> 117.         self._tag_stack.append(token.value)</font>
<font color="red"> 118.         pop_tag = True</font>
<font color="red"> 119.         try:</font>
<font color="red"> 120.             if token.value in _statement_keywords:</font>
<font color="red"> 121.                 return getattr(self, 'parse_' + self.stream.current.value)()</font>
<font color="red"> 122.             if token.value == 'call':</font>
<font color="red"> 123.                 return self.parse_call_block()</font>
<font color="red"> 124.             if token.value == 'filter':</font>
<font color="red"> 125.                 return self.parse_filter_block()</font>
<font color="red"> 126.             ext = self.extensions.get(token.value)</font>
<font color="red"> 127.             if ext is not None:</font>
<font color="red"> 128.                 return ext(self)</font>
<font color="black"> 129. </font>
<font color="black"> 130.             # did not work out, remove the token we pushed by accident</font>
<font color="black"> 131.             # from the stack so that the unknown tag fail function can</font>
<font color="black"> 132.             # produce a proper error message.</font>
<font color="red"> 133.             self._tag_stack.pop()</font>
<font color="red"> 134.             pop_tag = False</font>
<font color="red"> 135.             self.fail_unknown_tag(token.value, token.lineno)</font>
<font color="black"> 136.         finally:</font>
<font color="red"> 137.             if pop_tag:</font>
<font color="red"> 138.                 self._tag_stack.pop()</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def parse_statements(self, end_tokens, drop_needle=False):</font>
<font color="black"> 141.         &quot;&quot;&quot;Parse multiple statements into a list until one of the end tokens</font>
<font color="black"> 142.         is reached.  This is used to parse the body of statements as it also</font>
<font color="black"> 143.         parses template data if appropriate.  The parser checks first if the</font>
<font color="black"> 144.         current token is a colon and skips it if there is one.  Then it checks</font>
<font color="black"> 145.         for the block end and parses until if one of the `end_tokens` is</font>
<font color="black"> 146.         reached.  Per default the active token in the stream at the end of</font>
<font color="black"> 147.         the call is the matched end token.  If this is not wanted `drop_needle`</font>
<font color="black"> 148.         can be set to `True` and the end token is removed.</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="black"> 150.         # the first token may be a colon for python compatibility</font>
<font color="red"> 151.         self.stream.skip_if('colon')</font>
<font color="black"> 152. </font>
<font color="black"> 153.         # in the future it would be possible to add whole code sections</font>
<font color="black"> 154.         # by adding some sort of end of statement token and parsing those here.</font>
<font color="red"> 155.         self.stream.expect('block_end')</font>
<font color="red"> 156.         result = self.subparse(end_tokens)</font>
<font color="black"> 157. </font>
<font color="black"> 158.         # we reached the end of the template too early, the subparser</font>
<font color="black"> 159.         # does not check for this, so we do that now</font>
<font color="red"> 160.         if self.stream.current.type == 'eof':</font>
<font color="red"> 161.             self.fail_eof(end_tokens)</font>
<font color="black"> 162. </font>
<font color="red"> 163.         if drop_needle:</font>
<font color="red"> 164.             next(self.stream)</font>
<font color="red"> 165.         return result</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def parse_set(self):</font>
<font color="black"> 168.         &quot;&quot;&quot;Parse an assign statement.&quot;&quot;&quot;</font>
<font color="red"> 169.         lineno = next(self.stream).lineno</font>
<font color="red"> 170.         target = self.parse_assign_target()</font>
<font color="red"> 171.         if self.stream.skip_if('assign'):</font>
<font color="red"> 172.             expr = self.parse_tuple()</font>
<font color="red"> 173.             return nodes.Assign(target, expr, lineno=lineno)</font>
<font color="red"> 174.         body = self.parse_statements(('name:endset',),</font>
<font color="red"> 175.                                      drop_needle=True)</font>
<font color="red"> 176.         return nodes.AssignBlock(target, body, lineno=lineno)</font>
<font color="black"> 177. </font>
<font color="green"> 178.     def parse_for(self):</font>
<font color="black"> 179.         &quot;&quot;&quot;Parse a for loop.&quot;&quot;&quot;</font>
<font color="red"> 180.         lineno = self.stream.expect('name:for').lineno</font>
<font color="red"> 181.         target = self.parse_assign_target(extra_end_rules=('name:in',))</font>
<font color="red"> 182.         self.stream.expect('name:in')</font>
<font color="red"> 183.         iter = self.parse_tuple(with_condexpr=False,</font>
<font color="red"> 184.                                 extra_end_rules=('name:recursive',))</font>
<font color="red"> 185.         test = None</font>
<font color="red"> 186.         if self.stream.skip_if('name:if'):</font>
<font color="red"> 187.             test = self.parse_expression()</font>
<font color="red"> 188.         recursive = self.stream.skip_if('name:recursive')</font>
<font color="red"> 189.         body = self.parse_statements(('name:endfor', 'name:else'))</font>
<font color="red"> 190.         if next(self.stream).value == 'endfor':</font>
<font color="red"> 191.             else_ = []</font>
<font color="black"> 192.         else:</font>
<font color="red"> 193.             else_ = self.parse_statements(('name:endfor',), drop_needle=True)</font>
<font color="red"> 194.         return nodes.For(target, iter, body, else_, test,</font>
<font color="red"> 195.                          recursive, lineno=lineno)</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def parse_if(self):</font>
<font color="black"> 198.         &quot;&quot;&quot;Parse an if construct.&quot;&quot;&quot;</font>
<font color="red"> 199.         node = result = nodes.If(lineno=self.stream.expect('name:if').lineno)</font>
<font color="red"> 200.         while 1:</font>
<font color="red"> 201.             node.test = self.parse_tuple(with_condexpr=False)</font>
<font color="red"> 202.             node.body = self.parse_statements(('name:elif', 'name:else',</font>
<font color="red"> 203.                                                'name:endif'))</font>
<font color="red"> 204.             token = next(self.stream)</font>
<font color="red"> 205.             if token.test('name:elif'):</font>
<font color="red"> 206.                 new_node = nodes.If(lineno=self.stream.current.lineno)</font>
<font color="red"> 207.                 node.else_ = [new_node]</font>
<font color="red"> 208.                 node = new_node</font>
<font color="red"> 209.                 continue</font>
<font color="red"> 210.             elif token.test('name:else'):</font>
<font color="red"> 211.                 node.else_ = self.parse_statements(('name:endif',),</font>
<font color="red"> 212.                                                    drop_needle=True)</font>
<font color="black"> 213.             else:</font>
<font color="red"> 214.                 node.else_ = []</font>
<font color="red"> 215.             break</font>
<font color="red"> 216.         return result</font>
<font color="black"> 217. </font>
<font color="green"> 218.     def parse_block(self):</font>
<font color="red"> 219.         node = nodes.Block(lineno=next(self.stream).lineno)</font>
<font color="red"> 220.         node.name = self.stream.expect('name').value</font>
<font color="red"> 221.         node.scoped = self.stream.skip_if('name:scoped')</font>
<font color="black"> 222. </font>
<font color="black"> 223.         # common problem people encounter when switching from django</font>
<font color="black"> 224.         # to jinja.  we do not support hyphens in block names, so let's</font>
<font color="black"> 225.         # raise a nicer error message in that case.</font>
<font color="red"> 226.         if self.stream.current.type == 'sub':</font>
<font color="red"> 227.             self.fail('Block names in Jinja have to be valid Python '</font>
<font color="black"> 228.                       'identifiers and may not contain hyphens, use an '</font>
<font color="black"> 229.                       'underscore instead.')</font>
<font color="black"> 230. </font>
<font color="red"> 231.         node.body = self.parse_statements(('name:endblock',), drop_needle=True)</font>
<font color="red"> 232.         self.stream.skip_if('name:' + node.name)</font>
<font color="red"> 233.         return node</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def parse_extends(self):</font>
<font color="red"> 236.         node = nodes.Extends(lineno=next(self.stream).lineno)</font>
<font color="red"> 237.         node.template = self.parse_expression()</font>
<font color="red"> 238.         return node</font>
<font color="black"> 239. </font>
<font color="green"> 240.     def parse_import_context(self, node, default):</font>
<font color="red"> 241.         if self.stream.current.test_any('name:with', 'name:without') and \</font>
<font color="red"> 242.            self.stream.look().test('name:context'):</font>
<font color="red"> 243.             node.with_context = next(self.stream).value == 'with'</font>
<font color="red"> 244.             self.stream.skip()</font>
<font color="black"> 245.         else:</font>
<font color="red"> 246.             node.with_context = default</font>
<font color="red"> 247.         return node</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def parse_include(self):</font>
<font color="red"> 250.         node = nodes.Include(lineno=next(self.stream).lineno)</font>
<font color="red"> 251.         node.template = self.parse_expression()</font>
<font color="red"> 252.         if self.stream.current.test('name:ignore') and \</font>
<font color="red"> 253.            self.stream.look().test('name:missing'):</font>
<font color="red"> 254.             node.ignore_missing = True</font>
<font color="red"> 255.             self.stream.skip(2)</font>
<font color="black"> 256.         else:</font>
<font color="red"> 257.             node.ignore_missing = False</font>
<font color="red"> 258.         return self.parse_import_context(node, True)</font>
<font color="black"> 259. </font>
<font color="green"> 260.     def parse_import(self):</font>
<font color="red"> 261.         node = nodes.Import(lineno=next(self.stream).lineno)</font>
<font color="red"> 262.         node.template = self.parse_expression()</font>
<font color="red"> 263.         self.stream.expect('name:as')</font>
<font color="red"> 264.         node.target = self.parse_assign_target(name_only=True).name</font>
<font color="red"> 265.         return self.parse_import_context(node, False)</font>
<font color="black"> 266. </font>
<font color="green"> 267.     def parse_from(self):</font>
<font color="red"> 268.         node = nodes.FromImport(lineno=next(self.stream).lineno)</font>
<font color="red"> 269.         node.template = self.parse_expression()</font>
<font color="red"> 270.         self.stream.expect('name:import')</font>
<font color="red"> 271.         node.names = []</font>
<font color="black"> 272. </font>
<font color="red"> 273.         def parse_context():</font>
<font color="red"> 274.             if self.stream.current.value in ('with', 'without') and \</font>
<font color="red"> 275.                self.stream.look().test('name:context'):</font>
<font color="red"> 276.                 node.with_context = next(self.stream).value == 'with'</font>
<font color="red"> 277.                 self.stream.skip()</font>
<font color="red"> 278.                 return True</font>
<font color="red"> 279.             return False</font>
<font color="black"> 280. </font>
<font color="red"> 281.         while 1:</font>
<font color="red"> 282.             if node.names:</font>
<font color="red"> 283.                 self.stream.expect('comma')</font>
<font color="red"> 284.             if self.stream.current.type == 'name':</font>
<font color="red"> 285.                 if parse_context():</font>
<font color="red"> 286.                     break</font>
<font color="red"> 287.                 target = self.parse_assign_target(name_only=True)</font>
<font color="red"> 288.                 if target.name.startswith('_'):</font>
<font color="red"> 289.                     self.fail('names starting with an underline can not '</font>
<font color="red"> 290.                               'be imported', target.lineno,</font>
<font color="red"> 291.                               exc=TemplateAssertionError)</font>
<font color="red"> 292.                 if self.stream.skip_if('name:as'):</font>
<font color="red"> 293.                     alias = self.parse_assign_target(name_only=True)</font>
<font color="red"> 294.                     node.names.append((target.name, alias.name))</font>
<font color="black"> 295.                 else:</font>
<font color="red"> 296.                     node.names.append(target.name)</font>
<font color="red"> 297.                 if parse_context() or self.stream.current.type != 'comma':</font>
<font color="red"> 298.                     break</font>
<font color="black"> 299.             else:</font>
<font color="red"> 300.                 break</font>
<font color="red"> 301.         if not hasattr(node, 'with_context'):</font>
<font color="red"> 302.             node.with_context = False</font>
<font color="red"> 303.             self.stream.skip_if('comma')</font>
<font color="red"> 304.         return node</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def parse_signature(self, node):</font>
<font color="red"> 307.         node.args = args = []</font>
<font color="red"> 308.         node.defaults = defaults = []</font>
<font color="red"> 309.         self.stream.expect('lparen')</font>
<font color="red"> 310.         while self.stream.current.type != 'rparen':</font>
<font color="red"> 311.             if args:</font>
<font color="red"> 312.                 self.stream.expect('comma')</font>
<font color="red"> 313.             arg = self.parse_assign_target(name_only=True)</font>
<font color="red"> 314.             arg.set_ctx('param')</font>
<font color="red"> 315.             if self.stream.skip_if('assign'):</font>
<font color="red"> 316.                 defaults.append(self.parse_expression())</font>
<font color="red"> 317.             elif defaults:</font>
<font color="red"> 318.                 self.fail('non-default argument follows default argument')</font>
<font color="red"> 319.             args.append(arg)</font>
<font color="red"> 320.         self.stream.expect('rparen')</font>
<font color="black"> 321. </font>
<font color="green"> 322.     def parse_call_block(self):</font>
<font color="red"> 323.         node = nodes.CallBlock(lineno=next(self.stream).lineno)</font>
<font color="red"> 324.         if self.stream.current.type == 'lparen':</font>
<font color="red"> 325.             self.parse_signature(node)</font>
<font color="black"> 326.         else:</font>
<font color="red"> 327.             node.args = []</font>
<font color="red"> 328.             node.defaults = []</font>
<font color="black"> 329. </font>
<font color="red"> 330.         node.call = self.parse_expression()</font>
<font color="red"> 331.         if not isinstance(node.call, nodes.Call):</font>
<font color="red"> 332.             self.fail('expected call', node.lineno)</font>
<font color="red"> 333.         node.body = self.parse_statements(('name:endcall',), drop_needle=True)</font>
<font color="red"> 334.         return node</font>
<font color="black"> 335. </font>
<font color="green"> 336.     def parse_filter_block(self):</font>
<font color="red"> 337.         node = nodes.FilterBlock(lineno=next(self.stream).lineno)</font>
<font color="red"> 338.         node.filter = self.parse_filter(None, start_inline=True)</font>
<font color="red"> 339.         node.body = self.parse_statements(('name:endfilter',),</font>
<font color="red"> 340.                                           drop_needle=True)</font>
<font color="red"> 341.         return node</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def parse_macro(self):</font>
<font color="red"> 344.         node = nodes.Macro(lineno=next(self.stream).lineno)</font>
<font color="red"> 345.         node.name = self.parse_assign_target(name_only=True).name</font>
<font color="red"> 346.         self.parse_signature(node)</font>
<font color="red"> 347.         node.body = self.parse_statements(('name:endmacro',),</font>
<font color="red"> 348.                                           drop_needle=True)</font>
<font color="red"> 349.         return node</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def parse_print(self):</font>
<font color="red"> 352.         node = nodes.Output(lineno=next(self.stream).lineno)</font>
<font color="red"> 353.         node.nodes = []</font>
<font color="red"> 354.         while self.stream.current.type != 'block_end':</font>
<font color="red"> 355.             if node.nodes:</font>
<font color="red"> 356.                 self.stream.expect('comma')</font>
<font color="red"> 357.             node.nodes.append(self.parse_expression())</font>
<font color="red"> 358.         return node</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def parse_assign_target(self, with_tuple=True, name_only=False,</font>
<font color="green"> 361.                             extra_end_rules=None):</font>
<font color="black"> 362.         &quot;&quot;&quot;Parse an assignment target.  As Jinja2 allows assignments to</font>
<font color="black"> 363.         tuples, this function can parse all allowed assignment targets.  Per</font>
<font color="black"> 364.         default assignments to tuples are parsed, that can be disable however</font>
<font color="black"> 365.         by setting `with_tuple` to `False`.  If only assignments to names are</font>
<font color="black"> 366.         wanted `name_only` can be set to `True`.  The `extra_end_rules`</font>
<font color="black"> 367.         parameter is forwarded to the tuple parsing function.</font>
<font color="black"> 368.         &quot;&quot;&quot;</font>
<font color="red"> 369.         if name_only:</font>
<font color="red"> 370.             token = self.stream.expect('name')</font>
<font color="red"> 371.             target = nodes.Name(token.value, 'store', lineno=token.lineno)</font>
<font color="black"> 372.         else:</font>
<font color="red"> 373.             if with_tuple:</font>
<font color="red"> 374.                 target = self.parse_tuple(simplified=True,</font>
<font color="red"> 375.                                           extra_end_rules=extra_end_rules)</font>
<font color="black"> 376.             else:</font>
<font color="red"> 377.                 target = self.parse_primary()</font>
<font color="red"> 378.             target.set_ctx('store')</font>
<font color="red"> 379.         if not target.can_assign():</font>
<font color="red"> 380.             self.fail('can\'t assign to %r' % target.__class__.</font>
<font color="red"> 381.                       __name__.lower(), target.lineno)</font>
<font color="red"> 382.         return target</font>
<font color="black"> 383. </font>
<font color="green"> 384.     def parse_expression(self, with_condexpr=True):</font>
<font color="black"> 385.         &quot;&quot;&quot;Parse an expression.  Per default all expressions are parsed, if</font>
<font color="black"> 386.         the optional `with_condexpr` parameter is set to `False` conditional</font>
<font color="black"> 387.         expressions are not parsed.</font>
<font color="black"> 388.         &quot;&quot;&quot;</font>
<font color="red"> 389.         if with_condexpr:</font>
<font color="red"> 390.             return self.parse_condexpr()</font>
<font color="red"> 391.         return self.parse_or()</font>
<font color="black"> 392. </font>
<font color="green"> 393.     def parse_condexpr(self):</font>
<font color="red"> 394.         lineno = self.stream.current.lineno</font>
<font color="red"> 395.         expr1 = self.parse_or()</font>
<font color="red"> 396.         while self.stream.skip_if('name:if'):</font>
<font color="red"> 397.             expr2 = self.parse_or()</font>
<font color="red"> 398.             if self.stream.skip_if('name:else'):</font>
<font color="red"> 399.                 expr3 = self.parse_condexpr()</font>
<font color="black"> 400.             else:</font>
<font color="red"> 401.                 expr3 = None</font>
<font color="red"> 402.             expr1 = nodes.CondExpr(expr2, expr1, expr3, lineno=lineno)</font>
<font color="red"> 403.             lineno = self.stream.current.lineno</font>
<font color="red"> 404.         return expr1</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def parse_or(self):</font>
<font color="red"> 407.         lineno = self.stream.current.lineno</font>
<font color="red"> 408.         left = self.parse_and()</font>
<font color="red"> 409.         while self.stream.skip_if('name:or'):</font>
<font color="red"> 410.             right = self.parse_and()</font>
<font color="red"> 411.             left = nodes.Or(left, right, lineno=lineno)</font>
<font color="red"> 412.             lineno = self.stream.current.lineno</font>
<font color="red"> 413.         return left</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def parse_and(self):</font>
<font color="red"> 416.         lineno = self.stream.current.lineno</font>
<font color="red"> 417.         left = self.parse_not()</font>
<font color="red"> 418.         while self.stream.skip_if('name:and'):</font>
<font color="red"> 419.             right = self.parse_not()</font>
<font color="red"> 420.             left = nodes.And(left, right, lineno=lineno)</font>
<font color="red"> 421.             lineno = self.stream.current.lineno</font>
<font color="red"> 422.         return left</font>
<font color="black"> 423. </font>
<font color="green"> 424.     def parse_not(self):</font>
<font color="red"> 425.         if self.stream.current.test('name:not'):</font>
<font color="red"> 426.             lineno = next(self.stream).lineno</font>
<font color="red"> 427.             return nodes.Not(self.parse_not(), lineno=lineno)</font>
<font color="red"> 428.         return self.parse_compare()</font>
<font color="black"> 429. </font>
<font color="green"> 430.     def parse_compare(self):</font>
<font color="red"> 431.         lineno = self.stream.current.lineno</font>
<font color="red"> 432.         expr = self.parse_add()</font>
<font color="red"> 433.         ops = []</font>
<font color="red"> 434.         while 1:</font>
<font color="red"> 435.             token_type = self.stream.current.type</font>
<font color="red"> 436.             if token_type in _compare_operators:</font>
<font color="red"> 437.                 next(self.stream)</font>
<font color="red"> 438.                 ops.append(nodes.Operand(token_type, self.parse_add()))</font>
<font color="red"> 439.             elif self.stream.skip_if('name:in'):</font>
<font color="red"> 440.                 ops.append(nodes.Operand('in', self.parse_add()))</font>
<font color="red"> 441.             elif (self.stream.current.test('name:not') and</font>
<font color="red"> 442.                   self.stream.look().test('name:in')):</font>
<font color="red"> 443.                 self.stream.skip(2)</font>
<font color="red"> 444.                 ops.append(nodes.Operand('notin', self.parse_add()))</font>
<font color="black"> 445.             else:</font>
<font color="red"> 446.                 break</font>
<font color="red"> 447.             lineno = self.stream.current.lineno</font>
<font color="red"> 448.         if not ops:</font>
<font color="red"> 449.             return expr</font>
<font color="red"> 450.         return nodes.Compare(expr, ops, lineno=lineno)</font>
<font color="black"> 451. </font>
<font color="green"> 452.     def parse_add(self):</font>
<font color="red"> 453.         lineno = self.stream.current.lineno</font>
<font color="red"> 454.         left = self.parse_sub()</font>
<font color="red"> 455.         while self.stream.current.type == 'add':</font>
<font color="red"> 456.             next(self.stream)</font>
<font color="red"> 457.             right = self.parse_sub()</font>
<font color="red"> 458.             left = nodes.Add(left, right, lineno=lineno)</font>
<font color="red"> 459.             lineno = self.stream.current.lineno</font>
<font color="red"> 460.         return left</font>
<font color="black"> 461. </font>
<font color="green"> 462.     def parse_sub(self):</font>
<font color="red"> 463.         lineno = self.stream.current.lineno</font>
<font color="red"> 464.         left = self.parse_concat()</font>
<font color="red"> 465.         while self.stream.current.type == 'sub':</font>
<font color="red"> 466.             next(self.stream)</font>
<font color="red"> 467.             right = self.parse_concat()</font>
<font color="red"> 468.             left = nodes.Sub(left, right, lineno=lineno)</font>
<font color="red"> 469.             lineno = self.stream.current.lineno</font>
<font color="red"> 470.         return left</font>
<font color="black"> 471. </font>
<font color="green"> 472.     def parse_concat(self):</font>
<font color="red"> 473.         lineno = self.stream.current.lineno</font>
<font color="red"> 474.         args = [self.parse_mul()]</font>
<font color="red"> 475.         while self.stream.current.type == 'tilde':</font>
<font color="red"> 476.             next(self.stream)</font>
<font color="red"> 477.             args.append(self.parse_mul())</font>
<font color="red"> 478.         if len(args) == 1:</font>
<font color="red"> 479.             return args[0]</font>
<font color="red"> 480.         return nodes.Concat(args, lineno=lineno)</font>
<font color="black"> 481. </font>
<font color="green"> 482.     def parse_mul(self):</font>
<font color="red"> 483.         lineno = self.stream.current.lineno</font>
<font color="red"> 484.         left = self.parse_div()</font>
<font color="red"> 485.         while self.stream.current.type == 'mul':</font>
<font color="red"> 486.             next(self.stream)</font>
<font color="red"> 487.             right = self.parse_div()</font>
<font color="red"> 488.             left = nodes.Mul(left, right, lineno=lineno)</font>
<font color="red"> 489.             lineno = self.stream.current.lineno</font>
<font color="red"> 490.         return left</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def parse_div(self):</font>
<font color="red"> 493.         lineno = self.stream.current.lineno</font>
<font color="red"> 494.         left = self.parse_floordiv()</font>
<font color="red"> 495.         while self.stream.current.type == 'div':</font>
<font color="red"> 496.             next(self.stream)</font>
<font color="red"> 497.             right = self.parse_floordiv()</font>
<font color="red"> 498.             left = nodes.Div(left, right, lineno=lineno)</font>
<font color="red"> 499.             lineno = self.stream.current.lineno</font>
<font color="red"> 500.         return left</font>
<font color="black"> 501. </font>
<font color="green"> 502.     def parse_floordiv(self):</font>
<font color="red"> 503.         lineno = self.stream.current.lineno</font>
<font color="red"> 504.         left = self.parse_mod()</font>
<font color="red"> 505.         while self.stream.current.type == 'floordiv':</font>
<font color="red"> 506.             next(self.stream)</font>
<font color="red"> 507.             right = self.parse_mod()</font>
<font color="red"> 508.             left = nodes.FloorDiv(left, right, lineno=lineno)</font>
<font color="red"> 509.             lineno = self.stream.current.lineno</font>
<font color="red"> 510.         return left</font>
<font color="black"> 511. </font>
<font color="green"> 512.     def parse_mod(self):</font>
<font color="red"> 513.         lineno = self.stream.current.lineno</font>
<font color="red"> 514.         left = self.parse_pow()</font>
<font color="red"> 515.         while self.stream.current.type == 'mod':</font>
<font color="red"> 516.             next(self.stream)</font>
<font color="red"> 517.             right = self.parse_pow()</font>
<font color="red"> 518.             left = nodes.Mod(left, right, lineno=lineno)</font>
<font color="red"> 519.             lineno = self.stream.current.lineno</font>
<font color="red"> 520.         return left</font>
<font color="black"> 521. </font>
<font color="green"> 522.     def parse_pow(self):</font>
<font color="red"> 523.         lineno = self.stream.current.lineno</font>
<font color="red"> 524.         left = self.parse_unary()</font>
<font color="red"> 525.         while self.stream.current.type == 'pow':</font>
<font color="red"> 526.             next(self.stream)</font>
<font color="red"> 527.             right = self.parse_unary()</font>
<font color="red"> 528.             left = nodes.Pow(left, right, lineno=lineno)</font>
<font color="red"> 529.             lineno = self.stream.current.lineno</font>
<font color="red"> 530.         return left</font>
<font color="black"> 531. </font>
<font color="green"> 532.     def parse_unary(self, with_filter=True):</font>
<font color="red"> 533.         token_type = self.stream.current.type</font>
<font color="red"> 534.         lineno = self.stream.current.lineno</font>
<font color="red"> 535.         if token_type == 'sub':</font>
<font color="red"> 536.             next(self.stream)</font>
<font color="red"> 537.             node = nodes.Neg(self.parse_unary(False), lineno=lineno)</font>
<font color="red"> 538.         elif token_type == 'add':</font>
<font color="red"> 539.             next(self.stream)</font>
<font color="red"> 540.             node = nodes.Pos(self.parse_unary(False), lineno=lineno)</font>
<font color="black"> 541.         else:</font>
<font color="red"> 542.             node = self.parse_primary()</font>
<font color="red"> 543.         node = self.parse_postfix(node)</font>
<font color="red"> 544.         if with_filter:</font>
<font color="red"> 545.             node = self.parse_filter_expr(node)</font>
<font color="red"> 546.         return node</font>
<font color="black"> 547. </font>
<font color="green"> 548.     def parse_primary(self):</font>
<font color="red"> 549.         token = self.stream.current</font>
<font color="red"> 550.         if token.type == 'name':</font>
<font color="red"> 551.             if token.value in ('true', 'false', 'True', 'False'):</font>
<font color="red"> 552.                 node = nodes.Const(token.value in ('true', 'True'),</font>
<font color="red"> 553.                                    lineno=token.lineno)</font>
<font color="red"> 554.             elif token.value in ('none', 'None'):</font>
<font color="red"> 555.                 node = nodes.Const(None, lineno=token.lineno)</font>
<font color="black"> 556.             else:</font>
<font color="red"> 557.                 node = nodes.Name(token.value, 'load', lineno=token.lineno)</font>
<font color="red"> 558.             next(self.stream)</font>
<font color="red"> 559.         elif token.type == 'string':</font>
<font color="red"> 560.             next(self.stream)</font>
<font color="red"> 561.             buf = [token.value]</font>
<font color="red"> 562.             lineno = token.lineno</font>
<font color="red"> 563.             while self.stream.current.type == 'string':</font>
<font color="red"> 564.                 buf.append(self.stream.current.value)</font>
<font color="red"> 565.                 next(self.stream)</font>
<font color="red"> 566.             node = nodes.Const(''.join(buf), lineno=lineno)</font>
<font color="red"> 567.         elif token.type in ('integer', 'float'):</font>
<font color="red"> 568.             next(self.stream)</font>
<font color="red"> 569.             node = nodes.Const(token.value, lineno=token.lineno)</font>
<font color="red"> 570.         elif token.type == 'lparen':</font>
<font color="red"> 571.             next(self.stream)</font>
<font color="red"> 572.             node = self.parse_tuple(explicit_parentheses=True)</font>
<font color="red"> 573.             self.stream.expect('rparen')</font>
<font color="red"> 574.         elif token.type == 'lbracket':</font>
<font color="red"> 575.             node = self.parse_list()</font>
<font color="red"> 576.         elif token.type == 'lbrace':</font>
<font color="red"> 577.             node = self.parse_dict()</font>
<font color="black"> 578.         else:</font>
<font color="red"> 579.             self.fail(&quot;unexpected '%s'&quot; % describe_token(token), token.lineno)</font>
<font color="red"> 580.         return node</font>
<font color="black"> 581. </font>
<font color="green"> 582.     def parse_tuple(self, simplified=False, with_condexpr=True,</font>
<font color="green"> 583.                     extra_end_rules=None, explicit_parentheses=False):</font>
<font color="black"> 584.         &quot;&quot;&quot;Works like `parse_expression` but if multiple expressions are</font>
<font color="black"> 585.         delimited by a comma a :class:`~jinja2.nodes.Tuple` node is created.</font>
<font color="black"> 586.         This method could also return a regular expression instead of a tuple</font>
<font color="black"> 587.         if no commas where found.</font>
<font color="black"> 588. </font>
<font color="black"> 589.         The default parsing mode is a full tuple.  If `simplified` is `True`</font>
<font color="black"> 590.         only names and literals are parsed.  The `no_condexpr` parameter is</font>
<font color="black"> 591.         forwarded to :meth:`parse_expression`.</font>
<font color="black"> 592. </font>
<font color="black"> 593.         Because tuples do not require delimiters and may end in a bogus comma</font>
<font color="black"> 594.         an extra hint is needed that marks the end of a tuple.  For example</font>
<font color="black"> 595.         for loops support tuples between `for` and `in`.  In that case the</font>
<font color="black"> 596.         `extra_end_rules` is set to ``['name:in']``.</font>
<font color="black"> 597. </font>
<font color="black"> 598.         `explicit_parentheses` is true if the parsing was triggered by an</font>
<font color="black"> 599.         expression in parentheses.  This is used to figure out if an empty</font>
<font color="black"> 600.         tuple is a valid expression or not.</font>
<font color="black"> 601.         &quot;&quot;&quot;</font>
<font color="red"> 602.         lineno = self.stream.current.lineno</font>
<font color="red"> 603.         if simplified:</font>
<font color="red"> 604.             parse = self.parse_primary</font>
<font color="red"> 605.         elif with_condexpr:</font>
<font color="red"> 606.             parse = self.parse_expression</font>
<font color="black"> 607.         else:</font>
<font color="red"> 608.             parse = lambda: self.parse_expression(with_condexpr=False)</font>
<font color="red"> 609.         args = []</font>
<font color="red"> 610.         is_tuple = False</font>
<font color="red"> 611.         while 1:</font>
<font color="red"> 612.             if args:</font>
<font color="red"> 613.                 self.stream.expect('comma')</font>
<font color="red"> 614.             if self.is_tuple_end(extra_end_rules):</font>
<font color="red"> 615.                 break</font>
<font color="red"> 616.             args.append(parse())</font>
<font color="red"> 617.             if self.stream.current.type == 'comma':</font>
<font color="red"> 618.                 is_tuple = True</font>
<font color="black"> 619.             else:</font>
<font color="red"> 620.                 break</font>
<font color="red"> 621.             lineno = self.stream.current.lineno</font>
<font color="black"> 622. </font>
<font color="red"> 623.         if not is_tuple:</font>
<font color="red"> 624.             if args:</font>
<font color="red"> 625.                 return args[0]</font>
<font color="black"> 626. </font>
<font color="black"> 627.             # if we don't have explicit parentheses, an empty tuple is</font>
<font color="black"> 628.             # not a valid expression.  This would mean nothing (literally</font>
<font color="black"> 629.             # nothing) in the spot of an expression would be an empty</font>
<font color="black"> 630.             # tuple.</font>
<font color="red"> 631.             if not explicit_parentheses:</font>
<font color="red"> 632.                 self.fail('Expected an expression, got \'%s\'' %</font>
<font color="red"> 633.                           describe_token(self.stream.current))</font>
<font color="black"> 634. </font>
<font color="red"> 635.         return nodes.Tuple(args, 'load', lineno=lineno)</font>
<font color="black"> 636. </font>
<font color="green"> 637.     def parse_list(self):</font>
<font color="red"> 638.         token = self.stream.expect('lbracket')</font>
<font color="red"> 639.         items = []</font>
<font color="red"> 640.         while self.stream.current.type != 'rbracket':</font>
<font color="red"> 641.             if items:</font>
<font color="red"> 642.                 self.stream.expect('comma')</font>
<font color="red"> 643.             if self.stream.current.type == 'rbracket':</font>
<font color="red"> 644.                 break</font>
<font color="red"> 645.             items.append(self.parse_expression())</font>
<font color="red"> 646.         self.stream.expect('rbracket')</font>
<font color="red"> 647.         return nodes.List(items, lineno=token.lineno)</font>
<font color="black"> 648. </font>
<font color="green"> 649.     def parse_dict(self):</font>
<font color="red"> 650.         token = self.stream.expect('lbrace')</font>
<font color="red"> 651.         items = []</font>
<font color="red"> 652.         while self.stream.current.type != 'rbrace':</font>
<font color="red"> 653.             if items:</font>
<font color="red"> 654.                 self.stream.expect('comma')</font>
<font color="red"> 655.             if self.stream.current.type == 'rbrace':</font>
<font color="red"> 656.                 break</font>
<font color="red"> 657.             key = self.parse_expression()</font>
<font color="red"> 658.             self.stream.expect('colon')</font>
<font color="red"> 659.             value = self.parse_expression()</font>
<font color="red"> 660.             items.append(nodes.Pair(key, value, lineno=key.lineno))</font>
<font color="red"> 661.         self.stream.expect('rbrace')</font>
<font color="red"> 662.         return nodes.Dict(items, lineno=token.lineno)</font>
<font color="black"> 663. </font>
<font color="green"> 664.     def parse_postfix(self, node):</font>
<font color="red"> 665.         while 1:</font>
<font color="red"> 666.             token_type = self.stream.current.type</font>
<font color="red"> 667.             if token_type == 'dot' or token_type == 'lbracket':</font>
<font color="red"> 668.                 node = self.parse_subscript(node)</font>
<font color="black"> 669.             # calls are valid both after postfix expressions (getattr</font>
<font color="black"> 670.             # and getitem) as well as filters and tests</font>
<font color="red"> 671.             elif token_type == 'lparen':</font>
<font color="red"> 672.                 node = self.parse_call(node)</font>
<font color="black"> 673.             else:</font>
<font color="red"> 674.                 break</font>
<font color="red"> 675.         return node</font>
<font color="black"> 676. </font>
<font color="green"> 677.     def parse_filter_expr(self, node):</font>
<font color="red"> 678.         while 1:</font>
<font color="red"> 679.             token_type = self.stream.current.type</font>
<font color="red"> 680.             if token_type == 'pipe':</font>
<font color="red"> 681.                 node = self.parse_filter(node)</font>
<font color="red"> 682.             elif token_type == 'name' and self.stream.current.value == 'is':</font>
<font color="red"> 683.                 node = self.parse_test(node)</font>
<font color="black"> 684.             # calls are valid both after postfix expressions (getattr</font>
<font color="black"> 685.             # and getitem) as well as filters and tests</font>
<font color="red"> 686.             elif token_type == 'lparen':</font>
<font color="red"> 687.                 node = self.parse_call(node)</font>
<font color="black"> 688.             else:</font>
<font color="red"> 689.                 break</font>
<font color="red"> 690.         return node</font>
<font color="black"> 691. </font>
<font color="green"> 692.     def parse_subscript(self, node):</font>
<font color="red"> 693.         token = next(self.stream)</font>
<font color="red"> 694.         if token.type == 'dot':</font>
<font color="red"> 695.             attr_token = self.stream.current</font>
<font color="red"> 696.             next(self.stream)</font>
<font color="red"> 697.             if attr_token.type == 'name':</font>
<font color="red"> 698.                 return nodes.Getattr(node, attr_token.value, 'load',</font>
<font color="red"> 699.                                      lineno=token.lineno)</font>
<font color="red"> 700.             elif attr_token.type != 'integer':</font>
<font color="red"> 701.                 self.fail('expected name or number', attr_token.lineno)</font>
<font color="red"> 702.             arg = nodes.Const(attr_token.value, lineno=attr_token.lineno)</font>
<font color="red"> 703.             return nodes.Getitem(node, arg, 'load', lineno=token.lineno)</font>
<font color="red"> 704.         if token.type == 'lbracket':</font>
<font color="red"> 705.             args = []</font>
<font color="red"> 706.             while self.stream.current.type != 'rbracket':</font>
<font color="red"> 707.                 if args:</font>
<font color="red"> 708.                     self.stream.expect('comma')</font>
<font color="red"> 709.                 args.append(self.parse_subscribed())</font>
<font color="red"> 710.             self.stream.expect('rbracket')</font>
<font color="red"> 711.             if len(args) == 1:</font>
<font color="red"> 712.                 arg = args[0]</font>
<font color="black"> 713.             else:</font>
<font color="red"> 714.                 arg = nodes.Tuple(args, 'load', lineno=token.lineno)</font>
<font color="red"> 715.             return nodes.Getitem(node, arg, 'load', lineno=token.lineno)</font>
<font color="red"> 716.         self.fail('expected subscript expression', self.lineno)</font>
<font color="black"> 717. </font>
<font color="green"> 718.     def parse_subscribed(self):</font>
<font color="red"> 719.         lineno = self.stream.current.lineno</font>
<font color="black"> 720. </font>
<font color="red"> 721.         if self.stream.current.type == 'colon':</font>
<font color="red"> 722.             next(self.stream)</font>
<font color="red"> 723.             args = [None]</font>
<font color="black"> 724.         else:</font>
<font color="red"> 725.             node = self.parse_expression()</font>
<font color="red"> 726.             if self.stream.current.type != 'colon':</font>
<font color="red"> 727.                 return node</font>
<font color="red"> 728.             next(self.stream)</font>
<font color="red"> 729.             args = [node]</font>
<font color="black"> 730. </font>
<font color="red"> 731.         if self.stream.current.type == 'colon':</font>
<font color="red"> 732.             args.append(None)</font>
<font color="red"> 733.         elif self.stream.current.type not in ('rbracket', 'comma'):</font>
<font color="red"> 734.             args.append(self.parse_expression())</font>
<font color="black"> 735.         else:</font>
<font color="red"> 736.             args.append(None)</font>
<font color="black"> 737. </font>
<font color="red"> 738.         if self.stream.current.type == 'colon':</font>
<font color="red"> 739.             next(self.stream)</font>
<font color="red"> 740.             if self.stream.current.type not in ('rbracket', 'comma'):</font>
<font color="red"> 741.                 args.append(self.parse_expression())</font>
<font color="black"> 742.             else:</font>
<font color="red"> 743.                 args.append(None)</font>
<font color="black"> 744.         else:</font>
<font color="red"> 745.             args.append(None)</font>
<font color="black"> 746. </font>
<font color="red"> 747.         return nodes.Slice(lineno=lineno, *args)</font>
<font color="black"> 748. </font>
<font color="green"> 749.     def parse_call(self, node):</font>
<font color="red"> 750.         token = self.stream.expect('lparen')</font>
<font color="red"> 751.         args = []</font>
<font color="red"> 752.         kwargs = []</font>
<font color="red"> 753.         dyn_args = dyn_kwargs = None</font>
<font color="red"> 754.         require_comma = False</font>
<font color="black"> 755. </font>
<font color="red"> 756.         def ensure(expr):</font>
<font color="red"> 757.             if not expr:</font>
<font color="red"> 758.                 self.fail('invalid syntax for function call expression',</font>
<font color="red"> 759.                           token.lineno)</font>
<font color="black"> 760. </font>
<font color="red"> 761.         while self.stream.current.type != 'rparen':</font>
<font color="red"> 762.             if require_comma:</font>
<font color="red"> 763.                 self.stream.expect('comma')</font>
<font color="black"> 764.                 # support for trailing comma</font>
<font color="red"> 765.                 if self.stream.current.type == 'rparen':</font>
<font color="red"> 766.                     break</font>
<font color="red"> 767.             if self.stream.current.type == 'mul':</font>
<font color="red"> 768.                 ensure(dyn_args is None and dyn_kwargs is None)</font>
<font color="red"> 769.                 next(self.stream)</font>
<font color="red"> 770.                 dyn_args = self.parse_expression()</font>
<font color="red"> 771.             elif self.stream.current.type == 'pow':</font>
<font color="red"> 772.                 ensure(dyn_kwargs is None)</font>
<font color="red"> 773.                 next(self.stream)</font>
<font color="red"> 774.                 dyn_kwargs = self.parse_expression()</font>
<font color="black"> 775.             else:</font>
<font color="red"> 776.                 ensure(dyn_args is None and dyn_kwargs is None)</font>
<font color="red"> 777.                 if self.stream.current.type == 'name' and \</font>
<font color="red"> 778.                    self.stream.look().type == 'assign':</font>
<font color="red"> 779.                     key = self.stream.current.value</font>
<font color="red"> 780.                     self.stream.skip(2)</font>
<font color="red"> 781.                     value = self.parse_expression()</font>
<font color="red"> 782.                     kwargs.append(nodes.Keyword(key, value,</font>
<font color="red"> 783.                                                 lineno=value.lineno))</font>
<font color="black"> 784.                 else:</font>
<font color="red"> 785.                     ensure(not kwargs)</font>
<font color="red"> 786.                     args.append(self.parse_expression())</font>
<font color="black"> 787. </font>
<font color="red"> 788.             require_comma = True</font>
<font color="red"> 789.         self.stream.expect('rparen')</font>
<font color="black"> 790. </font>
<font color="red"> 791.         if node is None:</font>
<font color="red"> 792.             return args, kwargs, dyn_args, dyn_kwargs</font>
<font color="red"> 793.         return nodes.Call(node, args, kwargs, dyn_args, dyn_kwargs,</font>
<font color="red"> 794.                           lineno=token.lineno)</font>
<font color="black"> 795. </font>
<font color="green"> 796.     def parse_filter(self, node, start_inline=False):</font>
<font color="red"> 797.         while self.stream.current.type == 'pipe' or start_inline:</font>
<font color="red"> 798.             if not start_inline:</font>
<font color="red"> 799.                 next(self.stream)</font>
<font color="red"> 800.             token = self.stream.expect('name')</font>
<font color="red"> 801.             name = token.value</font>
<font color="red"> 802.             while self.stream.current.type == 'dot':</font>
<font color="red"> 803.                 next(self.stream)</font>
<font color="red"> 804.                 name += '.' + self.stream.expect('name').value</font>
<font color="red"> 805.             if self.stream.current.type == 'lparen':</font>
<font color="red"> 806.                 args, kwargs, dyn_args, dyn_kwargs = self.parse_call(None)</font>
<font color="black"> 807.             else:</font>
<font color="red"> 808.                 args = []</font>
<font color="red"> 809.                 kwargs = []</font>
<font color="red"> 810.                 dyn_args = dyn_kwargs = None</font>
<font color="red"> 811.             node = nodes.Filter(node, name, args, kwargs, dyn_args,</font>
<font color="red"> 812.                                 dyn_kwargs, lineno=token.lineno)</font>
<font color="red"> 813.             start_inline = False</font>
<font color="red"> 814.         return node</font>
<font color="black"> 815. </font>
<font color="green"> 816.     def parse_test(self, node):</font>
<font color="red"> 817.         token = next(self.stream)</font>
<font color="red"> 818.         if self.stream.current.test('name:not'):</font>
<font color="red"> 819.             next(self.stream)</font>
<font color="red"> 820.             negated = True</font>
<font color="black"> 821.         else:</font>
<font color="red"> 822.             negated = False</font>
<font color="red"> 823.         name = self.stream.expect('name').value</font>
<font color="red"> 824.         while self.stream.current.type == 'dot':</font>
<font color="red"> 825.             next(self.stream)</font>
<font color="red"> 826.             name += '.' + self.stream.expect('name').value</font>
<font color="red"> 827.         dyn_args = dyn_kwargs = None</font>
<font color="red"> 828.         kwargs = []</font>
<font color="red"> 829.         if self.stream.current.type == 'lparen':</font>
<font color="red"> 830.             args, kwargs, dyn_args, dyn_kwargs = self.parse_call(None)</font>
<font color="red"> 831.         elif (self.stream.current.type in ('name', 'string', 'integer',</font>
<font color="black"> 832.                                            'float', 'lparen', 'lbracket',</font>
<font color="red"> 833.                                            'lbrace') and not</font>
<font color="red"> 834.               self.stream.current.test_any('name:else', 'name:or',</font>
<font color="red"> 835.                                            'name:and')):</font>
<font color="red"> 836.             if self.stream.current.test('name:is'):</font>
<font color="red"> 837.                 self.fail('You cannot chain multiple tests with is')</font>
<font color="red"> 838.             args = [self.parse_expression()]</font>
<font color="black"> 839.         else:</font>
<font color="red"> 840.             args = []</font>
<font color="red"> 841.         node = nodes.Test(node, name, args, kwargs, dyn_args,</font>
<font color="red"> 842.                           dyn_kwargs, lineno=token.lineno)</font>
<font color="red"> 843.         if negated:</font>
<font color="red"> 844.             node = nodes.Not(node, lineno=token.lineno)</font>
<font color="red"> 845.         return node</font>
<font color="black"> 846. </font>
<font color="green"> 847.     def subparse(self, end_tokens=None):</font>
<font color="red"> 848.         body = []</font>
<font color="red"> 849.         data_buffer = []</font>
<font color="red"> 850.         add_data = data_buffer.append</font>
<font color="black"> 851. </font>
<font color="red"> 852.         if end_tokens is not None:</font>
<font color="red"> 853.             self._end_token_stack.append(end_tokens)</font>
<font color="black"> 854. </font>
<font color="red"> 855.         def flush_data():</font>
<font color="red"> 856.             if data_buffer:</font>
<font color="red"> 857.                 lineno = data_buffer[0].lineno</font>
<font color="red"> 858.                 body.append(nodes.Output(data_buffer[:], lineno=lineno))</font>
<font color="red"> 859.                 del data_buffer[:]</font>
<font color="black"> 860. </font>
<font color="red"> 861.         try:</font>
<font color="red"> 862.             while self.stream:</font>
<font color="red"> 863.                 token = self.stream.current</font>
<font color="red"> 864.                 if token.type == 'data':</font>
<font color="red"> 865.                     if token.value:</font>
<font color="red"> 866.                         add_data(nodes.TemplateData(token.value,</font>
<font color="red"> 867.                                                     lineno=token.lineno))</font>
<font color="red"> 868.                     next(self.stream)</font>
<font color="red"> 869.                 elif token.type == 'variable_begin':</font>
<font color="red"> 870.                     next(self.stream)</font>
<font color="red"> 871.                     add_data(self.parse_tuple(with_condexpr=True))</font>
<font color="red"> 872.                     self.stream.expect('variable_end')</font>
<font color="red"> 873.                 elif token.type == 'block_begin':</font>
<font color="red"> 874.                     flush_data()</font>
<font color="red"> 875.                     next(self.stream)</font>
<font color="red"> 876.                     if end_tokens is not None and \</font>
<font color="red"> 877.                        self.stream.current.test_any(*end_tokens):</font>
<font color="red"> 878.                         return body</font>
<font color="red"> 879.                     rv = self.parse_statement()</font>
<font color="red"> 880.                     if isinstance(rv, list):</font>
<font color="red"> 881.                         body.extend(rv)</font>
<font color="black"> 882.                     else:</font>
<font color="red"> 883.                         body.append(rv)</font>
<font color="red"> 884.                     self.stream.expect('block_end')</font>
<font color="black"> 885.                 else:</font>
<font color="red"> 886.                     raise AssertionError('internal parsing error')</font>
<font color="black"> 887. </font>
<font color="red"> 888.             flush_data()</font>
<font color="black"> 889.         finally:</font>
<font color="red"> 890.             if end_tokens is not None:</font>
<font color="red"> 891.                 self._end_token_stack.pop()</font>
<font color="black"> 892. </font>
<font color="red"> 893.         return body</font>
<font color="black"> 894. </font>
<font color="green"> 895.     def parse(self):</font>
<font color="black"> 896.         &quot;&quot;&quot;Parse the whole template into a `Template` node.&quot;&quot;&quot;</font>
<font color="red"> 897.         result = nodes.Template(self.subparse(), lineno=1)</font>
<font color="red"> 898.         result.set_environment(self.environment)</font>
<font color="red"> 899.         return result</font>
</pre>

