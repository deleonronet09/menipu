source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/mail/message.py</b><br>


file stats: <b>279 lines, 76 executed: 27.2% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import mimetypes</font>
<font color="green">   4. import os</font>
<font color="green">   5. import random</font>
<font color="green">   6. import time</font>
<font color="green">   7. from email import (</font>
<font color="black">   8.     charset as Charset, encoders as Encoders, generator, message_from_string,</font>
<font color="black">   9. )</font>
<font color="green">  10. from email.header import Header</font>
<font color="green">  11. from email.message import Message</font>
<font color="green">  12. from email.mime.base import MIMEBase</font>
<font color="green">  13. from email.mime.message import MIMEMessage</font>
<font color="green">  14. from email.mime.multipart import MIMEMultipart</font>
<font color="green">  15. from email.mime.text import MIMEText</font>
<font color="green">  16. from email.utils import formataddr, formatdate, getaddresses, parseaddr</font>
<font color="green">  17. from io import BytesIO</font>
<font color="black">  18. </font>
<font color="green">  19. from django.conf import settings</font>
<font color="green">  20. from django.core.mail.utils import DNS_NAME</font>
<font color="green">  21. from django.utils import six</font>
<font color="green">  22. from django.utils.encoding import force_text</font>
<font color="black">  23. </font>
<font color="black">  24. # Don't BASE64-encode UTF-8 messages so that we avoid unwanted attention from</font>
<font color="black">  25. # some spam filters.</font>
<font color="green">  26. utf8_charset = Charset.Charset('utf-8')</font>
<font color="green">  27. utf8_charset.body_encoding = None  # Python defaults to BASE64</font>
<font color="black">  28. </font>
<font color="black">  29. # Default MIME type to use on attachments (if it is not explicitly given</font>
<font color="black">  30. # and cannot be guessed).</font>
<font color="green">  31. DEFAULT_ATTACHMENT_MIME_TYPE = 'application/octet-stream'</font>
<font color="black">  32. </font>
<font color="black">  33. </font>
<font color="green">  34. class BadHeaderError(ValueError):</font>
<font color="green">  35.     pass</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="black">  38. # Copied from Python 3.2+ standard library, with the following modifications:</font>
<font color="black">  39. # * Used cached hostname for performance.</font>
<font color="black">  40. # TODO: replace with email.utils.make_msgid(.., domain=DNS_NAME) when dropping</font>
<font color="black">  41. # Python 2 (Python 2's version doesn't have domain parameter) (#23905).</font>
<font color="green">  42. def make_msgid(idstring=None, domain=None):</font>
<font color="black">  43.     &quot;&quot;&quot;Returns a string suitable for RFC 2822 compliant Message-ID, e.g:</font>
<font color="black">  44. </font>
<font color="black">  45.     &lt;20020201195627.33539.96671@nightshade.la.mastaler.com&gt;</font>
<font color="black">  46. </font>
<font color="black">  47.     Optional idstring if given is a string used to strengthen the</font>
<font color="black">  48.     uniqueness of the message id.  Optional domain if given provides the</font>
<font color="black">  49.     portion of the message id after the '@'.  It defaults to the locally</font>
<font color="black">  50.     defined hostname.</font>
<font color="black">  51.     &quot;&quot;&quot;</font>
<font color="red">  52.     timeval = time.time()</font>
<font color="red">  53.     utcdate = time.strftime('%Y%m%d%H%M%S', time.gmtime(timeval))</font>
<font color="red">  54.     pid = os.getpid()</font>
<font color="red">  55.     randint = random.randrange(100000)</font>
<font color="red">  56.     if idstring is None:</font>
<font color="red">  57.         idstring = ''</font>
<font color="black">  58.     else:</font>
<font color="red">  59.         idstring = '.' + idstring</font>
<font color="red">  60.     if domain is None:</font>
<font color="black">  61.         # stdlib uses socket.getfqdn() here instead</font>
<font color="red">  62.         domain = DNS_NAME</font>
<font color="red">  63.     msgid = '&lt;%s.%s.%s%s@%s&gt;' % (utcdate, pid, randint, idstring, domain)</font>
<font color="red">  64.     return msgid</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="black">  67. # Header names that contain structured address data (RFC #5322)</font>
<font color="black">  68. ADDRESS_HEADERS = {</font>
<font color="green">  69.     'from',</font>
<font color="green">  70.     'sender',</font>
<font color="green">  71.     'reply-to',</font>
<font color="green">  72.     'to',</font>
<font color="green">  73.     'cc',</font>
<font color="green">  74.     'bcc',</font>
<font color="green">  75.     'resent-from',</font>
<font color="green">  76.     'resent-sender',</font>
<font color="green">  77.     'resent-to',</font>
<font color="green">  78.     'resent-cc',</font>
<font color="green">  79.     'resent-bcc',</font>
<font color="black">  80. }</font>
<font color="black">  81. </font>
<font color="black">  82. </font>
<font color="green">  83. def forbid_multi_line_headers(name, val, encoding):</font>
<font color="black">  84.     &quot;&quot;&quot;Forbids multi-line headers, to prevent header injection.&quot;&quot;&quot;</font>
<font color="red">  85.     encoding = encoding or settings.DEFAULT_CHARSET</font>
<font color="red">  86.     val = force_text(val)</font>
<font color="red">  87.     if '\n' in val or '\r' in val:</font>
<font color="red">  88.         raise BadHeaderError(&quot;Header values can't contain newlines (got %r for header %r)&quot; % (val, name))</font>
<font color="red">  89.     try:</font>
<font color="red">  90.         val.encode('ascii')</font>
<font color="red">  91.     except UnicodeEncodeError:</font>
<font color="red">  92.         if name.lower() in ADDRESS_HEADERS:</font>
<font color="red">  93.             val = ', '.join(sanitize_address(addr, encoding)</font>
<font color="red">  94.                 for addr in getaddresses((val,)))</font>
<font color="black">  95.         else:</font>
<font color="red">  96.             val = Header(val, encoding).encode()</font>
<font color="black">  97.     else:</font>
<font color="red">  98.         if name.lower() == 'subject':</font>
<font color="red">  99.             val = Header(val).encode()</font>
<font color="red"> 100.     return str(name), val</font>
<font color="black"> 101. </font>
<font color="black"> 102. </font>
<font color="green"> 103. def sanitize_address(addr, encoding):</font>
<font color="red"> 104.     if not isinstance(addr, tuple):</font>
<font color="red"> 105.         addr = parseaddr(force_text(addr))</font>
<font color="red"> 106.     nm, addr = addr</font>
<font color="red"> 107.     nm = Header(nm, encoding).encode()</font>
<font color="red"> 108.     try:</font>
<font color="red"> 109.         addr.encode('ascii')</font>
<font color="red"> 110.     except UnicodeEncodeError:  # IDN</font>
<font color="red"> 111.         if '@' in addr:</font>
<font color="red"> 112.             localpart, domain = addr.split('@', 1)</font>
<font color="red"> 113.             localpart = str(Header(localpart, encoding))</font>
<font color="red"> 114.             domain = domain.encode('idna').decode('ascii')</font>
<font color="red"> 115.             addr = '@'.join([localpart, domain])</font>
<font color="black"> 116.         else:</font>
<font color="red"> 117.             addr = Header(addr, encoding).encode()</font>
<font color="red"> 118.     return formataddr((nm, addr))</font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="green"> 121. class MIMEMixin():</font>
<font color="green"> 122.     def as_string(self, unixfrom=False, linesep='\n'):</font>
<font color="black"> 123.         &quot;&quot;&quot;Return the entire formatted message as a string.</font>
<font color="black"> 124.         Optional `unixfrom' when True, means include the Unix From_ envelope</font>
<font color="black"> 125.         header.</font>
<font color="black"> 126. </font>
<font color="black"> 127.         This overrides the default as_string() implementation to not mangle</font>
<font color="black"> 128.         lines that begin with 'From '. See bug #13433 for details.</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="red"> 130.         fp = six.StringIO()</font>
<font color="red"> 131.         g = generator.Generator(fp, mangle_from_=False)</font>
<font color="red"> 132.         if six.PY2:</font>
<font color="red"> 133.             g.flatten(self, unixfrom=unixfrom)</font>
<font color="black"> 134.         else:</font>
<font color="red"> 135.             g.flatten(self, unixfrom=unixfrom, linesep=linesep)</font>
<font color="red"> 136.         return fp.getvalue()</font>
<font color="black"> 137. </font>
<font color="green"> 138.     if six.PY2:</font>
<font color="green"> 139.         as_bytes = as_string</font>
<font color="black"> 140.     else:</font>
<font color="red"> 141.         def as_bytes(self, unixfrom=False, linesep='\n'):</font>
<font color="black"> 142.             &quot;&quot;&quot;Return the entire formatted message as bytes.</font>
<font color="black"> 143.             Optional `unixfrom' when True, means include the Unix From_ envelope</font>
<font color="black"> 144.             header.</font>
<font color="black"> 145. </font>
<font color="black"> 146.             This overrides the default as_bytes() implementation to not mangle</font>
<font color="black"> 147.             lines that begin with 'From '. See bug #13433 for details.</font>
<font color="black"> 148.             &quot;&quot;&quot;</font>
<font color="red"> 149.             fp = BytesIO()</font>
<font color="red"> 150.             g = generator.BytesGenerator(fp, mangle_from_=False)</font>
<font color="red"> 151.             g.flatten(self, unixfrom=unixfrom, linesep=linesep)</font>
<font color="red"> 152.             return fp.getvalue()</font>
<font color="black"> 153. </font>
<font color="black"> 154. </font>
<font color="green"> 155. class SafeMIMEMessage(MIMEMixin, MIMEMessage):</font>
<font color="black"> 156. </font>
<font color="green"> 157.     def __setitem__(self, name, val):</font>
<font color="black"> 158.         # message/rfc822 attachments must be ASCII</font>
<font color="red"> 159.         name, val = forbid_multi_line_headers(name, val, 'ascii')</font>
<font color="red"> 160.         MIMEMessage.__setitem__(self, name, val)</font>
<font color="black"> 161. </font>
<font color="black"> 162. </font>
<font color="green"> 163. class SafeMIMEText(MIMEMixin, MIMEText):</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def __init__(self, _text, _subtype='plain', _charset=None):</font>
<font color="red"> 166.         self.encoding = _charset</font>
<font color="red"> 167.         if _charset == 'utf-8':</font>
<font color="black"> 168.             # Unfortunately, Python &lt; 3.5 doesn't support setting a Charset instance</font>
<font color="black"> 169.             # as MIMEText init parameter (http://bugs.python.org/issue16324).</font>
<font color="black"> 170.             # We do it manually and trigger re-encoding of the payload.</font>
<font color="red"> 171.             MIMEText.__init__(self, _text, _subtype, None)</font>
<font color="red"> 172.             del self['Content-Transfer-Encoding']</font>
<font color="red"> 173.             self.set_payload(_text, utf8_charset)</font>
<font color="red"> 174.             self.replace_header('Content-Type', 'text/%s; charset=&quot;%s&quot;' % (_subtype, _charset))</font>
<font color="red"> 175.         elif _charset is None:</font>
<font color="black"> 176.             # the default value of '_charset' is 'us-ascii' on Python 2</font>
<font color="red"> 177.             MIMEText.__init__(self, _text, _subtype)</font>
<font color="black"> 178.         else:</font>
<font color="red"> 179.             MIMEText.__init__(self, _text, _subtype, _charset)</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def __setitem__(self, name, val):</font>
<font color="red"> 182.         name, val = forbid_multi_line_headers(name, val, self.encoding)</font>
<font color="red"> 183.         MIMEText.__setitem__(self, name, val)</font>
<font color="black"> 184. </font>
<font color="black"> 185. </font>
<font color="green"> 186. class SafeMIMEMultipart(MIMEMixin, MIMEMultipart):</font>
<font color="black"> 187. </font>
<font color="green"> 188.     def __init__(self, _subtype='mixed', boundary=None, _subparts=None, encoding=None, **_params):</font>
<font color="red"> 189.         self.encoding = encoding</font>
<font color="red"> 190.         MIMEMultipart.__init__(self, _subtype, boundary, _subparts, **_params)</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def __setitem__(self, name, val):</font>
<font color="red"> 193.         name, val = forbid_multi_line_headers(name, val, self.encoding)</font>
<font color="red"> 194.         MIMEMultipart.__setitem__(self, name, val)</font>
<font color="black"> 195. </font>
<font color="black"> 196. </font>
<font color="green"> 197. class EmailMessage(object):</font>
<font color="black"> 198.     &quot;&quot;&quot;</font>
<font color="black"> 199.     A container for email information.</font>
<font color="green"> 200.     &quot;&quot;&quot;</font>
<font color="green"> 201.     content_subtype = 'plain'</font>
<font color="green"> 202.     mixed_subtype = 'mixed'</font>
<font color="green"> 203.     encoding = None     # None =&gt; use settings default</font>
<font color="black"> 204. </font>
<font color="green"> 205.     def __init__(self, subject='', body='', from_email=None, to=None, bcc=None,</font>
<font color="green"> 206.                  connection=None, attachments=None, headers=None, cc=None,</font>
<font color="green"> 207.                  reply_to=None):</font>
<font color="black"> 208.         &quot;&quot;&quot;</font>
<font color="black"> 209.         Initialize a single email message (which can be sent to multiple</font>
<font color="black"> 210.         recipients).</font>
<font color="black"> 211. </font>
<font color="black"> 212.         All strings used to create the message can be unicode strings</font>
<font color="black"> 213.         (or UTF-8 bytestrings). The SafeMIMEText class will handle any</font>
<font color="black"> 214.         necessary encoding conversions.</font>
<font color="black"> 215.         &quot;&quot;&quot;</font>
<font color="red"> 216.         if to:</font>
<font color="red"> 217.             if isinstance(to, six.string_types):</font>
<font color="red"> 218.                 raise TypeError('&quot;to&quot; argument must be a list or tuple')</font>
<font color="red"> 219.             self.to = list(to)</font>
<font color="black"> 220.         else:</font>
<font color="red"> 221.             self.to = []</font>
<font color="red"> 222.         if cc:</font>
<font color="red"> 223.             if isinstance(cc, six.string_types):</font>
<font color="red"> 224.                 raise TypeError('&quot;cc&quot; argument must be a list or tuple')</font>
<font color="red"> 225.             self.cc = list(cc)</font>
<font color="black"> 226.         else:</font>
<font color="red"> 227.             self.cc = []</font>
<font color="red"> 228.         if bcc:</font>
<font color="red"> 229.             if isinstance(bcc, six.string_types):</font>
<font color="red"> 230.                 raise TypeError('&quot;bcc&quot; argument must be a list or tuple')</font>
<font color="red"> 231.             self.bcc = list(bcc)</font>
<font color="black"> 232.         else:</font>
<font color="red"> 233.             self.bcc = []</font>
<font color="red"> 234.         if reply_to:</font>
<font color="red"> 235.             if isinstance(reply_to, six.string_types):</font>
<font color="red"> 236.                 raise TypeError('&quot;reply_to&quot; argument must be a list or tuple')</font>
<font color="red"> 237.             self.reply_to = list(reply_to)</font>
<font color="black"> 238.         else:</font>
<font color="red"> 239.             self.reply_to = []</font>
<font color="red"> 240.         self.from_email = from_email or settings.DEFAULT_FROM_EMAIL</font>
<font color="red"> 241.         self.subject = subject</font>
<font color="red"> 242.         self.body = body</font>
<font color="red"> 243.         self.attachments = attachments or []</font>
<font color="red"> 244.         self.extra_headers = headers or {}</font>
<font color="red"> 245.         self.connection = connection</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def get_connection(self, fail_silently=False):</font>
<font color="red"> 248.         from django.core.mail import get_connection</font>
<font color="red"> 249.         if not self.connection:</font>
<font color="red"> 250.             self.connection = get_connection(fail_silently=fail_silently)</font>
<font color="red"> 251.         return self.connection</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def message(self):</font>
<font color="red"> 254.         encoding = self.encoding or settings.DEFAULT_CHARSET</font>
<font color="red"> 255.         msg = SafeMIMEText(self.body, self.content_subtype, encoding)</font>
<font color="red"> 256.         msg = self._create_message(msg)</font>
<font color="red"> 257.         msg['Subject'] = self.subject</font>
<font color="red"> 258.         msg['From'] = self.extra_headers.get('From', self.from_email)</font>
<font color="red"> 259.         msg['To'] = self.extra_headers.get('To', ', '.join(map(force_text, self.to)))</font>
<font color="red"> 260.         if self.cc:</font>
<font color="red"> 261.             msg['Cc'] = ', '.join(map(force_text, self.cc))</font>
<font color="red"> 262.         if self.reply_to:</font>
<font color="red"> 263.             msg['Reply-To'] = self.extra_headers.get('Reply-To', ', '.join(map(force_text, self.reply_to)))</font>
<font color="black"> 264. </font>
<font color="black"> 265.         # Email header names are case-insensitive (RFC 2045), so we have to</font>
<font color="black"> 266.         # accommodate that when doing comparisons.</font>
<font color="red"> 267.         header_names = [key.lower() for key in self.extra_headers]</font>
<font color="red"> 268.         if 'date' not in header_names:</font>
<font color="red"> 269.             msg['Date'] = formatdate()</font>
<font color="red"> 270.         if 'message-id' not in header_names:</font>
<font color="black"> 271.             # Use cached DNS_NAME for performance</font>
<font color="red"> 272.             msg['Message-ID'] = make_msgid(domain=DNS_NAME)</font>
<font color="red"> 273.         for name, value in self.extra_headers.items():</font>
<font color="red"> 274.             if name.lower() in ('from', 'to'):  # From and To are already handled</font>
<font color="red"> 275.                 continue</font>
<font color="red"> 276.             msg[name] = value</font>
<font color="red"> 277.         return msg</font>
<font color="black"> 278. </font>
<font color="green"> 279.     def recipients(self):</font>
<font color="black"> 280.         &quot;&quot;&quot;</font>
<font color="black"> 281.         Returns a list of all recipients of the email (includes direct</font>
<font color="black"> 282.         addressees as well as Cc and Bcc entries).</font>
<font color="black"> 283.         &quot;&quot;&quot;</font>
<font color="red"> 284.         return self.to + self.cc + self.bcc</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def send(self, fail_silently=False):</font>
<font color="black"> 287.         &quot;&quot;&quot;Sends the email message.&quot;&quot;&quot;</font>
<font color="red"> 288.         if not self.recipients():</font>
<font color="black"> 289.             # Don't bother creating the network connection if there's nobody to</font>
<font color="black"> 290.             # send to.</font>
<font color="red"> 291.             return 0</font>
<font color="red"> 292.         return self.get_connection(fail_silently).send_messages([self])</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def attach(self, filename=None, content=None, mimetype=None):</font>
<font color="black"> 295.         &quot;&quot;&quot;</font>
<font color="black"> 296.         Attaches a file with the given filename and content. The filename can</font>
<font color="black"> 297.         be omitted and the mimetype is guessed, if not provided.</font>
<font color="black"> 298. </font>
<font color="black"> 299.         If the first parameter is a MIMEBase subclass it is inserted directly</font>
<font color="black"> 300.         into the resulting message attachments.</font>
<font color="black"> 301.         &quot;&quot;&quot;</font>
<font color="red"> 302.         if isinstance(filename, MIMEBase):</font>
<font color="red"> 303.             assert content is None</font>
<font color="red"> 304.             assert mimetype is None</font>
<font color="red"> 305.             self.attachments.append(filename)</font>
<font color="black"> 306.         else:</font>
<font color="red"> 307.             assert content is not None</font>
<font color="red"> 308.             self.attachments.append((filename, content, mimetype))</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def attach_file(self, path, mimetype=None):</font>
<font color="black"> 311.         &quot;&quot;&quot;</font>
<font color="black"> 312.         Attaches a file from the filesystem.</font>
<font color="black"> 313. </font>
<font color="black"> 314.         The mimetype will be set to the DEFAULT_ATTACHMENT_MIME_TYPE if it is</font>
<font color="black"> 315.         not specified and cannot be guessed or (PY3 only) if it suggests</font>
<font color="black"> 316.         text/* for a binary file.</font>
<font color="black"> 317.         &quot;&quot;&quot;</font>
<font color="red"> 318.         filename = os.path.basename(path)</font>
<font color="red"> 319.         if not mimetype:</font>
<font color="red"> 320.             mimetype, _ = mimetypes.guess_type(filename)</font>
<font color="red"> 321.             if not mimetype:</font>
<font color="red"> 322.                 mimetype = DEFAULT_ATTACHMENT_MIME_TYPE</font>
<font color="red"> 323.         basetype, subtype = mimetype.split('/', 1)</font>
<font color="red"> 324.         read_mode = 'r' if basetype == 'text' else 'rb'</font>
<font color="red"> 325.         content = None</font>
<font color="black"> 326. </font>
<font color="red"> 327.         with open(path, read_mode) as f:</font>
<font color="red"> 328.             try:</font>
<font color="red"> 329.                 content = f.read()</font>
<font color="red"> 330.             except UnicodeDecodeError:</font>
<font color="black"> 331.                 # If mimetype suggests the file is text but it's actually</font>
<font color="black"> 332.                 # binary, read() will raise a UnicodeDecodeError on Python 3.</font>
<font color="red"> 333.                 pass</font>
<font color="black"> 334. </font>
<font color="black"> 335.         # If the previous read in text mode failed, try binary mode.</font>
<font color="red"> 336.         if content is None:</font>
<font color="red"> 337.             with open(path, 'rb') as f:</font>
<font color="red"> 338.                 content = f.read()</font>
<font color="red"> 339.                 mimetype = DEFAULT_ATTACHMENT_MIME_TYPE</font>
<font color="black"> 340. </font>
<font color="red"> 341.         self.attach(filename, content, mimetype)</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def _create_message(self, msg):</font>
<font color="red"> 344.         return self._create_attachments(msg)</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def _create_attachments(self, msg):</font>
<font color="red"> 347.         if self.attachments:</font>
<font color="red"> 348.             encoding = self.encoding or settings.DEFAULT_CHARSET</font>
<font color="red"> 349.             body_msg = msg</font>
<font color="red"> 350.             msg = SafeMIMEMultipart(_subtype=self.mixed_subtype, encoding=encoding)</font>
<font color="red"> 351.             if self.body:</font>
<font color="red"> 352.                 msg.attach(body_msg)</font>
<font color="red"> 353.             for attachment in self.attachments:</font>
<font color="red"> 354.                 if isinstance(attachment, MIMEBase):</font>
<font color="red"> 355.                     msg.attach(attachment)</font>
<font color="black"> 356.                 else:</font>
<font color="red"> 357.                     msg.attach(self._create_attachment(*attachment))</font>
<font color="red"> 358.         return msg</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def _create_mime_attachment(self, content, mimetype):</font>
<font color="black"> 361.         &quot;&quot;&quot;</font>
<font color="black"> 362.         Converts the content, mimetype pair into a MIME attachment object.</font>
<font color="black"> 363. </font>
<font color="black"> 364.         If the mimetype is message/rfc822, content may be an</font>
<font color="black"> 365.         email.Message or EmailMessage object, as well as a str.</font>
<font color="black"> 366.         &quot;&quot;&quot;</font>
<font color="red"> 367.         basetype, subtype = mimetype.split('/', 1)</font>
<font color="red"> 368.         if basetype == 'text':</font>
<font color="red"> 369.             encoding = self.encoding or settings.DEFAULT_CHARSET</font>
<font color="red"> 370.             attachment = SafeMIMEText(content, subtype, encoding)</font>
<font color="red"> 371.         elif basetype == 'message' and subtype == 'rfc822':</font>
<font color="black"> 372.             # Bug #18967: per RFC2046 s5.2.1, message/rfc822 attachments</font>
<font color="black"> 373.             # must not be base64 encoded.</font>
<font color="red"> 374.             if isinstance(content, EmailMessage):</font>
<font color="black"> 375.                 # convert content into an email.Message first</font>
<font color="red"> 376.                 content = content.message()</font>
<font color="red"> 377.             elif not isinstance(content, Message):</font>
<font color="black"> 378.                 # For compatibility with existing code, parse the message</font>
<font color="black"> 379.                 # into an email.Message object if it is not one already.</font>
<font color="red"> 380.                 content = message_from_string(content)</font>
<font color="black"> 381. </font>
<font color="red"> 382.             attachment = SafeMIMEMessage(content, subtype)</font>
<font color="black"> 383.         else:</font>
<font color="black"> 384.             # Encode non-text attachments with base64.</font>
<font color="red"> 385.             attachment = MIMEBase(basetype, subtype)</font>
<font color="red"> 386.             attachment.set_payload(content)</font>
<font color="red"> 387.             Encoders.encode_base64(attachment)</font>
<font color="red"> 388.         return attachment</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def _create_attachment(self, filename, content, mimetype=None):</font>
<font color="black"> 391.         &quot;&quot;&quot;</font>
<font color="black"> 392.         Converts the filename, content, mimetype triple into a MIME attachment</font>
<font color="black"> 393.         object.</font>
<font color="black"> 394.         &quot;&quot;&quot;</font>
<font color="red"> 395.         if mimetype is None:</font>
<font color="red"> 396.             mimetype, _ = mimetypes.guess_type(filename)</font>
<font color="red"> 397.             if mimetype is None:</font>
<font color="red"> 398.                 mimetype = DEFAULT_ATTACHMENT_MIME_TYPE</font>
<font color="red"> 399.         attachment = self._create_mime_attachment(content, mimetype)</font>
<font color="red"> 400.         if filename:</font>
<font color="red"> 401.             try:</font>
<font color="red"> 402.                 filename.encode('ascii')</font>
<font color="red"> 403.             except UnicodeEncodeError:</font>
<font color="red"> 404.                 if six.PY2:</font>
<font color="red"> 405.                     filename = filename.encode('utf-8')</font>
<font color="red"> 406.                 filename = ('utf-8', '', filename)</font>
<font color="red"> 407.             attachment.add_header('Content-Disposition', 'attachment',</font>
<font color="red"> 408.                                   filename=filename)</font>
<font color="red"> 409.         return attachment</font>
<font color="black"> 410. </font>
<font color="black"> 411. </font>
<font color="green"> 412. class EmailMultiAlternatives(EmailMessage):</font>
<font color="black"> 413.     &quot;&quot;&quot;</font>
<font color="black"> 414.     A version of EmailMessage that makes it easy to send multipart/alternative</font>
<font color="black"> 415.     messages. For example, including text and HTML versions of the text is</font>
<font color="black"> 416.     made easier.</font>
<font color="green"> 417.     &quot;&quot;&quot;</font>
<font color="green"> 418.     alternative_subtype = 'alternative'</font>
<font color="black"> 419. </font>
<font color="green"> 420.     def __init__(self, subject='', body='', from_email=None, to=None, bcc=None,</font>
<font color="green"> 421.             connection=None, attachments=None, headers=None, alternatives=None,</font>
<font color="green"> 422.             cc=None, reply_to=None):</font>
<font color="black"> 423.         &quot;&quot;&quot;</font>
<font color="black"> 424.         Initialize a single email message (which can be sent to multiple</font>
<font color="black"> 425.         recipients).</font>
<font color="black"> 426. </font>
<font color="black"> 427.         All strings used to create the message can be unicode strings (or UTF-8</font>
<font color="black"> 428.         bytestrings). The SafeMIMEText class will handle any necessary encoding</font>
<font color="black"> 429.         conversions.</font>
<font color="black"> 430.         &quot;&quot;&quot;</font>
<font color="red"> 431.         super(EmailMultiAlternatives, self).__init__(</font>
<font color="red"> 432.             subject, body, from_email, to, bcc, connection, attachments,</font>
<font color="red"> 433.             headers, cc, reply_to,</font>
<font color="black"> 434.         )</font>
<font color="red"> 435.         self.alternatives = alternatives or []</font>
<font color="black"> 436. </font>
<font color="green"> 437.     def attach_alternative(self, content, mimetype):</font>
<font color="black"> 438.         &quot;&quot;&quot;Attach an alternative content representation.&quot;&quot;&quot;</font>
<font color="red"> 439.         assert content is not None</font>
<font color="red"> 440.         assert mimetype is not None</font>
<font color="red"> 441.         self.alternatives.append((content, mimetype))</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def _create_message(self, msg):</font>
<font color="red"> 444.         return self._create_attachments(self._create_alternatives(msg))</font>
<font color="black"> 445. </font>
<font color="green"> 446.     def _create_alternatives(self, msg):</font>
<font color="red"> 447.         encoding = self.encoding or settings.DEFAULT_CHARSET</font>
<font color="red"> 448.         if self.alternatives:</font>
<font color="red"> 449.             body_msg = msg</font>
<font color="red"> 450.             msg = SafeMIMEMultipart(_subtype=self.alternative_subtype, encoding=encoding)</font>
<font color="red"> 451.             if self.body:</font>
<font color="red"> 452.                 msg.attach(body_msg)</font>
<font color="red"> 453.             for alternative in self.alternatives:</font>
<font color="red"> 454.                 msg.attach(self._create_mime_attachment(*alternative))</font>
<font color="red"> 455.         return msg</font>
</pre>

