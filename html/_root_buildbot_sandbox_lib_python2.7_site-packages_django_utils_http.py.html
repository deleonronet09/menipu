source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/http.py</b><br>


file stats: <b>142 lines, 51 executed: 35.9% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import base64</font>
<font color="green">   4. import calendar</font>
<font color="green">   5. import datetime</font>
<font color="green">   6. import re</font>
<font color="green">   7. import sys</font>
<font color="green">   8. import unicodedata</font>
<font color="green">   9. from binascii import Error as BinasciiError</font>
<font color="green">  10. from email.utils import formatdate</font>
<font color="black">  11. </font>
<font color="green">  12. from django.utils import six</font>
<font color="green">  13. from django.utils.datastructures import MultiValueDict</font>
<font color="green">  14. from django.utils.encoding import force_bytes, force_str, force_text</font>
<font color="green">  15. from django.utils.functional import allow_lazy</font>
<font color="green">  16. from django.utils.six.moves.urllib.parse import (</font>
<font color="black">  17.     quote, quote_plus, unquote, unquote_plus, urlencode as original_urlencode,</font>
<font color="black">  18.     urlparse,</font>
<font color="black">  19. )</font>
<font color="black">  20. </font>
<font color="green">  21. ETAG_MATCH = re.compile(r'(?:W/)?&quot;((?:\\.|[^&quot;])*)&quot;')</font>
<font color="black">  22. </font>
<font color="green">  23. MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()</font>
<font color="green">  24. __D = r'(?P&lt;day&gt;\d{2})'</font>
<font color="green">  25. __D2 = r'(?P&lt;day&gt;[ \d]\d)'</font>
<font color="green">  26. __M = r'(?P&lt;mon&gt;\w{3})'</font>
<font color="green">  27. __Y = r'(?P&lt;year&gt;\d{4})'</font>
<font color="green">  28. __Y2 = r'(?P&lt;year&gt;\d{2})'</font>
<font color="green">  29. __T = r'(?P&lt;hour&gt;\d{2}):(?P&lt;min&gt;\d{2}):(?P&lt;sec&gt;\d{2})'</font>
<font color="green">  30. RFC1123_DATE = re.compile(r'^\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))</font>
<font color="green">  31. RFC850_DATE = re.compile(r'^\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))</font>
<font color="green">  32. ASCTIME_DATE = re.compile(r'^\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))</font>
<font color="black">  33. </font>
<font color="green">  34. RFC3986_GENDELIMS = str(&quot;:/?#[]@&quot;)</font>
<font color="green">  35. RFC3986_SUBDELIMS = str(&quot;!$&amp;'()*+,;=&quot;)</font>
<font color="black">  36. </font>
<font color="green">  37. PROTOCOL_TO_PORT = {</font>
<font color="green">  38.     'http': 80,</font>
<font color="green">  39.     'https': 443,</font>
<font color="black">  40. }</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. def urlquote(url, safe='/'):</font>
<font color="black">  44.     &quot;&quot;&quot;</font>
<font color="black">  45.     A version of Python's urllib.quote() function that can operate on unicode</font>
<font color="black">  46.     strings. The url is first UTF-8 encoded before quoting. The returned string</font>
<font color="black">  47.     can safely be used as part of an argument to a subsequent iri_to_uri() call</font>
<font color="black">  48.     without double-quoting occurring.</font>
<font color="black">  49.     &quot;&quot;&quot;</font>
<font color="red">  50.     return force_text(quote(force_str(url), force_str(safe)))</font>
<font color="green">  51. urlquote = allow_lazy(urlquote, six.text_type)</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. def urlquote_plus(url, safe=''):</font>
<font color="black">  55.     &quot;&quot;&quot;</font>
<font color="black">  56.     A version of Python's urllib.quote_plus() function that can operate on</font>
<font color="black">  57.     unicode strings. The url is first UTF-8 encoded before quoting. The</font>
<font color="black">  58.     returned string can safely be used as part of an argument to a subsequent</font>
<font color="black">  59.     iri_to_uri() call without double-quoting occurring.</font>
<font color="black">  60.     &quot;&quot;&quot;</font>
<font color="red">  61.     return force_text(quote_plus(force_str(url), force_str(safe)))</font>
<font color="green">  62. urlquote_plus = allow_lazy(urlquote_plus, six.text_type)</font>
<font color="black">  63. </font>
<font color="black">  64. </font>
<font color="green">  65. def urlunquote(quoted_url):</font>
<font color="black">  66.     &quot;&quot;&quot;</font>
<font color="black">  67.     A wrapper for Python's urllib.unquote() function that can operate on</font>
<font color="black">  68.     the result of django.utils.http.urlquote().</font>
<font color="black">  69.     &quot;&quot;&quot;</font>
<font color="red">  70.     return force_text(unquote(force_str(quoted_url)))</font>
<font color="green">  71. urlunquote = allow_lazy(urlunquote, six.text_type)</font>
<font color="black">  72. </font>
<font color="black">  73. </font>
<font color="green">  74. def urlunquote_plus(quoted_url):</font>
<font color="black">  75.     &quot;&quot;&quot;</font>
<font color="black">  76.     A wrapper for Python's urllib.unquote_plus() function that can operate on</font>
<font color="black">  77.     the result of django.utils.http.urlquote_plus().</font>
<font color="black">  78.     &quot;&quot;&quot;</font>
<font color="red">  79.     return force_text(unquote_plus(force_str(quoted_url)))</font>
<font color="green">  80. urlunquote_plus = allow_lazy(urlunquote_plus, six.text_type)</font>
<font color="black">  81. </font>
<font color="black">  82. </font>
<font color="green">  83. def urlencode(query, doseq=0):</font>
<font color="black">  84.     &quot;&quot;&quot;</font>
<font color="black">  85.     A version of Python's urllib.urlencode() function that can operate on</font>
<font color="black">  86.     unicode strings. The parameters are first cast to UTF-8 encoded strings and</font>
<font color="black">  87.     then encoded as per normal.</font>
<font color="black">  88.     &quot;&quot;&quot;</font>
<font color="red">  89.     if isinstance(query, MultiValueDict):</font>
<font color="red">  90.         query = query.lists()</font>
<font color="red">  91.     elif hasattr(query, 'items'):</font>
<font color="red">  92.         query = query.items()</font>
<font color="red">  93.     return original_urlencode(</font>
<font color="red">  94.         [(force_str(k),</font>
<font color="black">  95.          [force_str(i) for i in v] if isinstance(v, (list, tuple)) else force_str(v))</font>
<font color="red">  96.             for k, v in query],</font>
<font color="red">  97.         doseq)</font>
<font color="black">  98. </font>
<font color="black">  99. </font>
<font color="green"> 100. def cookie_date(epoch_seconds=None):</font>
<font color="black"> 101.     &quot;&quot;&quot;</font>
<font color="black"> 102.     Formats the time to ensure compatibility with Netscape's cookie standard.</font>
<font color="black"> 103. </font>
<font color="black"> 104.     Accepts a floating point number expressed in seconds since the epoch, in</font>
<font color="black"> 105.     UTC - such as that outputted by time.time(). If set to None, defaults to</font>
<font color="black"> 106.     the current time.</font>
<font color="black"> 107. </font>
<font color="black"> 108.     Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.</font>
<font color="black"> 109.     &quot;&quot;&quot;</font>
<font color="red"> 110.     rfcdate = formatdate(epoch_seconds)</font>
<font color="red"> 111.     return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])</font>
<font color="black"> 112. </font>
<font color="black"> 113. </font>
<font color="green"> 114. def http_date(epoch_seconds=None):</font>
<font color="black"> 115.     &quot;&quot;&quot;</font>
<font color="black"> 116.     Formats the time to match the RFC1123 date format as specified by HTTP</font>
<font color="black"> 117.     RFC2616 section 3.3.1.</font>
<font color="black"> 118. </font>
<font color="black"> 119.     Accepts a floating point number expressed in seconds since the epoch, in</font>
<font color="black"> 120.     UTC - such as that outputted by time.time(). If set to None, defaults to</font>
<font color="black"> 121.     the current time.</font>
<font color="black"> 122. </font>
<font color="black"> 123.     Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.</font>
<font color="black"> 124.     &quot;&quot;&quot;</font>
<font color="red"> 125.     return formatdate(epoch_seconds, usegmt=True)</font>
<font color="black"> 126. </font>
<font color="black"> 127. </font>
<font color="green"> 128. def parse_http_date(date):</font>
<font color="black"> 129.     &quot;&quot;&quot;</font>
<font color="black"> 130.     Parses a date format as specified by HTTP RFC2616 section 3.3.1.</font>
<font color="black"> 131. </font>
<font color="black"> 132.     The three formats allowed by the RFC are accepted, even if only the first</font>
<font color="black"> 133.     one is still in widespread use.</font>
<font color="black"> 134. </font>
<font color="black"> 135.     Returns an integer expressed in seconds since the epoch, in UTC.</font>
<font color="black"> 136.     &quot;&quot;&quot;</font>
<font color="black"> 137.     # emails.Util.parsedate does the job for RFC1123 dates; unfortunately</font>
<font color="black"> 138.     # RFC2616 makes it mandatory to support RFC850 dates too. So we roll</font>
<font color="black"> 139.     # our own RFC-compliant parsing.</font>
<font color="red"> 140.     for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:</font>
<font color="red"> 141.         m = regex.match(date)</font>
<font color="red"> 142.         if m is not None:</font>
<font color="red"> 143.             break</font>
<font color="black"> 144.     else:</font>
<font color="red"> 145.         raise ValueError(&quot;%r is not in a valid HTTP date format&quot; % date)</font>
<font color="red"> 146.     try:</font>
<font color="red"> 147.         year = int(m.group('year'))</font>
<font color="red"> 148.         if year &lt; 100:</font>
<font color="red"> 149.             if year &lt; 70:</font>
<font color="red"> 150.                 year += 2000</font>
<font color="black"> 151.             else:</font>
<font color="red"> 152.                 year += 1900</font>
<font color="red"> 153.         month = MONTHS.index(m.group('mon').lower()) + 1</font>
<font color="red"> 154.         day = int(m.group('day'))</font>
<font color="red"> 155.         hour = int(m.group('hour'))</font>
<font color="red"> 156.         min = int(m.group('min'))</font>
<font color="red"> 157.         sec = int(m.group('sec'))</font>
<font color="red"> 158.         result = datetime.datetime(year, month, day, hour, min, sec)</font>
<font color="red"> 159.         return calendar.timegm(result.utctimetuple())</font>
<font color="red"> 160.     except Exception:</font>
<font color="red"> 161.         six.reraise(ValueError, ValueError(&quot;%r is not a valid date&quot; % date), sys.exc_info()[2])</font>
<font color="black"> 162. </font>
<font color="black"> 163. </font>
<font color="green"> 164. def parse_http_date_safe(date):</font>
<font color="black"> 165.     &quot;&quot;&quot;</font>
<font color="black"> 166.     Same as parse_http_date, but returns None if the input is invalid.</font>
<font color="black"> 167.     &quot;&quot;&quot;</font>
<font color="red"> 168.     try:</font>
<font color="red"> 169.         return parse_http_date(date)</font>
<font color="red"> 170.     except Exception:</font>
<font color="red"> 171.         pass</font>
<font color="black"> 172. </font>
<font color="black"> 173. </font>
<font color="black"> 174. # Base 36 functions: useful for generating compact URLs</font>
<font color="black"> 175. </font>
<font color="green"> 176. def base36_to_int(s):</font>
<font color="black"> 177.     &quot;&quot;&quot;</font>
<font color="black"> 178.     Converts a base 36 string to an ``int``. Raises ``ValueError` if the</font>
<font color="black"> 179.     input won't fit into an int.</font>
<font color="black"> 180.     &quot;&quot;&quot;</font>
<font color="black"> 181.     # To prevent overconsumption of server resources, reject any</font>
<font color="black"> 182.     # base36 string that is long than 13 base36 digits (13 digits</font>
<font color="black"> 183.     # is sufficient to base36-encode any 64-bit integer)</font>
<font color="red"> 184.     if len(s) &gt; 13:</font>
<font color="red"> 185.         raise ValueError(&quot;Base36 input too large&quot;)</font>
<font color="red"> 186.     value = int(s, 36)</font>
<font color="black"> 187.     # ... then do a final check that the value will fit into an int to avoid</font>
<font color="black"> 188.     # returning a long (#15067). The long type was removed in Python 3.</font>
<font color="red"> 189.     if six.PY2 and value &gt; sys.maxint:</font>
<font color="red"> 190.         raise ValueError(&quot;Base36 input too large&quot;)</font>
<font color="red"> 191.     return value</font>
<font color="black"> 192. </font>
<font color="black"> 193. </font>
<font color="green"> 194. def int_to_base36(i):</font>
<font color="black"> 195.     &quot;&quot;&quot;</font>
<font color="black"> 196.     Converts an integer to a base36 string</font>
<font color="black"> 197.     &quot;&quot;&quot;</font>
<font color="red"> 198.     char_set = '0123456789abcdefghijklmnopqrstuvwxyz'</font>
<font color="red"> 199.     if i &lt; 0:</font>
<font color="red"> 200.         raise ValueError(&quot;Negative base36 conversion input.&quot;)</font>
<font color="red"> 201.     if six.PY2:</font>
<font color="red"> 202.         if not isinstance(i, six.integer_types):</font>
<font color="red"> 203.             raise TypeError(&quot;Non-integer base36 conversion input.&quot;)</font>
<font color="red"> 204.         if i &gt; sys.maxint:</font>
<font color="red"> 205.             raise ValueError(&quot;Base36 conversion input too large.&quot;)</font>
<font color="red"> 206.     if i &lt; 36:</font>
<font color="red"> 207.         return char_set[i]</font>
<font color="red"> 208.     b36 = ''</font>
<font color="red"> 209.     while i != 0:</font>
<font color="red"> 210.         i, n = divmod(i, 36)</font>
<font color="red"> 211.         b36 = char_set[n] + b36</font>
<font color="red"> 212.     return b36</font>
<font color="black"> 213. </font>
<font color="black"> 214. </font>
<font color="green"> 215. def urlsafe_base64_encode(s):</font>
<font color="black"> 216.     &quot;&quot;&quot;</font>
<font color="black"> 217.     Encodes a bytestring in base64 for use in URLs, stripping any trailing</font>
<font color="black"> 218.     equal signs.</font>
<font color="black"> 219.     &quot;&quot;&quot;</font>
<font color="red"> 220.     return base64.urlsafe_b64encode(s).rstrip(b'\n=')</font>
<font color="black"> 221. </font>
<font color="black"> 222. </font>
<font color="green"> 223. def urlsafe_base64_decode(s):</font>
<font color="black"> 224.     &quot;&quot;&quot;</font>
<font color="black"> 225.     Decodes a base64 encoded string, adding back any trailing equal signs that</font>
<font color="black"> 226.     might have been stripped.</font>
<font color="black"> 227.     &quot;&quot;&quot;</font>
<font color="red"> 228.     s = force_bytes(s)</font>
<font color="red"> 229.     try:</font>
<font color="red"> 230.         return base64.urlsafe_b64decode(s.ljust(len(s) + len(s) % 4, b'='))</font>
<font color="red"> 231.     except (LookupError, BinasciiError) as e:</font>
<font color="red"> 232.         raise ValueError(e)</font>
<font color="black"> 233. </font>
<font color="black"> 234. </font>
<font color="green"> 235. def parse_etags(etag_str):</font>
<font color="black"> 236.     &quot;&quot;&quot;</font>
<font color="black"> 237.     Parses a string with one or several etags passed in If-None-Match and</font>
<font color="black"> 238.     If-Match headers by the rules in RFC 2616. Returns a list of etags</font>
<font color="black"> 239.     without surrounding double quotes (&quot;) and unescaped from \&lt;CHAR&gt;.</font>
<font color="black"> 240.     &quot;&quot;&quot;</font>
<font color="red"> 241.     etags = ETAG_MATCH.findall(etag_str)</font>
<font color="red"> 242.     if not etags:</font>
<font color="black"> 243.         # etag_str has wrong format, treat it as an opaque string then</font>
<font color="red"> 244.         return [etag_str]</font>
<font color="red"> 245.     etags = [e.encode('ascii').decode('unicode_escape') for e in etags]</font>
<font color="red"> 246.     return etags</font>
<font color="black"> 247. </font>
<font color="black"> 248. </font>
<font color="green"> 249. def quote_etag(etag):</font>
<font color="black"> 250.     &quot;&quot;&quot;</font>
<font color="black"> 251.     Wraps a string in double quotes escaping contents as necessary.</font>
<font color="black"> 252.     &quot;&quot;&quot;</font>
<font color="red"> 253.     return '&quot;%s&quot;' % etag.replace('\\', '\\\\').replace('&quot;', '\\&quot;')</font>
<font color="black"> 254. </font>
<font color="black"> 255. </font>
<font color="green"> 256. def is_same_domain(host, pattern):</font>
<font color="black"> 257.     &quot;&quot;&quot;</font>
<font color="black"> 258.     Return ``True`` if the host is either an exact match or a match</font>
<font color="black"> 259.     to the wildcard pattern.</font>
<font color="black"> 260. </font>
<font color="black"> 261.     Any pattern beginning with a period matches a domain and all of its</font>
<font color="black"> 262.     subdomains. (e.g. ``.example.com`` matches ``example.com`` and</font>
<font color="black"> 263.     ``foo.example.com``). Anything else is an exact string match.</font>
<font color="black"> 264.     &quot;&quot;&quot;</font>
<font color="red"> 265.     if not pattern:</font>
<font color="red"> 266.         return False</font>
<font color="black"> 267. </font>
<font color="red"> 268.     pattern = pattern.lower()</font>
<font color="black"> 269.     return (</font>
<font color="red"> 270.         pattern[0] == '.' and (host.endswith(pattern) or host == pattern[1:]) or</font>
<font color="red"> 271.         pattern == host</font>
<font color="black"> 272.     )</font>
<font color="black"> 273. </font>
<font color="black"> 274. </font>
<font color="green"> 275. def is_safe_url(url, host=None):</font>
<font color="black"> 276.     &quot;&quot;&quot;</font>
<font color="black"> 277.     Return ``True`` if the url is a safe redirection (i.e. it doesn't point to</font>
<font color="black"> 278.     a different host and uses a safe scheme).</font>
<font color="black"> 279. </font>
<font color="black"> 280.     Always returns ``False`` on an empty url.</font>
<font color="black"> 281.     &quot;&quot;&quot;</font>
<font color="red"> 282.     if url is not None:</font>
<font color="red"> 283.         url = url.strip()</font>
<font color="red"> 284.     if not url:</font>
<font color="red"> 285.         return False</font>
<font color="black"> 286.     # Chrome treats \ completely as /</font>
<font color="red"> 287.     url = url.replace('\\', '/')</font>
<font color="black"> 288.     # Chrome considers any URL with more than two slashes to be absolute, but</font>
<font color="black"> 289.     # urlparse is not so flexible. Treat any url with three slashes as unsafe.</font>
<font color="red"> 290.     if url.startswith('///'):</font>
<font color="red"> 291.         return False</font>
<font color="red"> 292.     url_info = urlparse(url)</font>
<font color="black"> 293.     # Forbid URLs like http:///example.com - with a scheme, but without a hostname.</font>
<font color="black"> 294.     # In that URL, example.com is not the hostname but, a path component. However,</font>
<font color="black"> 295.     # Chrome will still consider example.com to be the hostname, so we must not</font>
<font color="black"> 296.     # allow this syntax.</font>
<font color="red"> 297.     if not url_info.netloc and url_info.scheme:</font>
<font color="red"> 298.         return False</font>
<font color="black"> 299.     # Forbid URLs that start with control characters. Some browsers (like</font>
<font color="black"> 300.     # Chrome) ignore quite a few control characters at the start of a</font>
<font color="black"> 301.     # URL and might consider the URL as scheme relative.</font>
<font color="red"> 302.     if unicodedata.category(url[0])[0] == 'C':</font>
<font color="red"> 303.         return False</font>
<font color="red"> 304.     return ((not url_info.netloc or url_info.netloc == host) and</font>
<font color="red"> 305.             (not url_info.scheme or url_info.scheme in ['http', 'https']))</font>
</pre>

