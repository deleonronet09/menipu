source file: <b>/usr/lib/python2.7/email/quoprimime.py</b><br>


file stats: <b>152 lines, 40 executed: 26.3% covered</b>
<pre>
<font color="black">   1. # Copyright (C) 2001-2006 Python Software Foundation</font>
<font color="black">   2. # Author: Ben Gertzfield</font>
<font color="black">   3. # Contact: email-sig@python.org</font>
<font color="black">   4. </font>
<font color="black">   5. &quot;&quot;&quot;Quoted-printable content transfer encoding per RFCs 2045-2047.</font>
<font color="black">   6. </font>
<font color="black">   7. This module handles the content transfer encoding method defined in RFC 2045</font>
<font color="black">   8. to encode US ASCII-like 8-bit data called `quoted-printable'.  It is used to</font>
<font color="black">   9. safely encode text that is in a character set similar to the 7-bit US ASCII</font>
<font color="black">  10. character set, but that includes some 8-bit characters that are normally not</font>
<font color="black">  11. allowed in email bodies or headers.</font>
<font color="black">  12. </font>
<font color="black">  13. Quoted-printable is very space-inefficient for encoding binary files; use the</font>
<font color="black">  14. email.base64mime module for that instead.</font>
<font color="black">  15. </font>
<font color="black">  16. This module provides an interface to encode and decode both headers and bodies</font>
<font color="black">  17. with quoted-printable encoding.</font>
<font color="black">  18. </font>
<font color="black">  19. RFC 2045 defines a method for including character set information in an</font>
<font color="black">  20. `encoded-word' in a header.  This method is commonly used for 8-bit real names</font>
<font color="black">  21. in To:/From:/Cc: etc. fields, as well as Subject: lines.</font>
<font color="black">  22. </font>
<font color="black">  23. This module does not do the line wrapping or end-of-line character</font>
<font color="black">  24. conversion necessary for proper internationalized headers; it only</font>
<font color="black">  25. does dumb encoding and decoding.  To deal with the various line</font>
<font color="black">  26. wrapping issues, use the email.header module.</font>
<font color="green">  27. &quot;&quot;&quot;</font>
<font color="black">  28. </font>
<font color="black">  29. __all__ = [</font>
<font color="green">  30.     'body_decode',</font>
<font color="green">  31.     'body_encode',</font>
<font color="green">  32.     'body_quopri_check',</font>
<font color="green">  33.     'body_quopri_len',</font>
<font color="green">  34.     'decode',</font>
<font color="green">  35.     'decodestring',</font>
<font color="green">  36.     'encode',</font>
<font color="green">  37.     'encodestring',</font>
<font color="green">  38.     'header_decode',</font>
<font color="green">  39.     'header_encode',</font>
<font color="green">  40.     'header_quopri_check',</font>
<font color="green">  41.     'header_quopri_len',</font>
<font color="green">  42.     'quote',</font>
<font color="green">  43.     'unquote',</font>
<font color="black">  44.     ]</font>
<font color="black">  45. </font>
<font color="green">  46. import re</font>
<font color="black">  47. </font>
<font color="green">  48. from string import hexdigits</font>
<font color="green">  49. from email.utils import fix_eols</font>
<font color="black">  50. </font>
<font color="green">  51. CRLF = '\r\n'</font>
<font color="green">  52. NL = '\n'</font>
<font color="black">  53. </font>
<font color="black">  54. # See also Charset.py</font>
<font color="green">  55. MISC_LEN = 7</font>
<font color="black">  56. </font>
<font color="green">  57. hqre = re.compile(r'[^-a-zA-Z0-9!*+/ ]')</font>
<font color="green">  58. bqre = re.compile(r'[^ !-&lt;&gt;-~\t]')</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="black">  61. </font>
<font color="black">  62. # Helpers</font>
<font color="green">  63. def header_quopri_check(c):</font>
<font color="black">  64.     &quot;&quot;&quot;Return True if the character should be escaped with header quopri.&quot;&quot;&quot;</font>
<font color="red">  65.     return bool(hqre.match(c))</font>
<font color="black">  66. </font>
<font color="black">  67. </font>
<font color="green">  68. def body_quopri_check(c):</font>
<font color="black">  69.     &quot;&quot;&quot;Return True if the character should be escaped with body quopri.&quot;&quot;&quot;</font>
<font color="red">  70.     return bool(bqre.match(c))</font>
<font color="black">  71. </font>
<font color="black">  72. </font>
<font color="green">  73. def header_quopri_len(s):</font>
<font color="black">  74.     &quot;&quot;&quot;Return the length of str when it is encoded with header quopri.&quot;&quot;&quot;</font>
<font color="red">  75.     count = 0</font>
<font color="red">  76.     for c in s:</font>
<font color="red">  77.         if hqre.match(c):</font>
<font color="red">  78.             count += 3</font>
<font color="black">  79.         else:</font>
<font color="red">  80.             count += 1</font>
<font color="red">  81.     return count</font>
<font color="black">  82. </font>
<font color="black">  83. </font>
<font color="green">  84. def body_quopri_len(str):</font>
<font color="black">  85.     &quot;&quot;&quot;Return the length of str when it is encoded with body quopri.&quot;&quot;&quot;</font>
<font color="red">  86.     count = 0</font>
<font color="red">  87.     for c in str:</font>
<font color="red">  88.         if bqre.match(c):</font>
<font color="red">  89.             count += 3</font>
<font color="black">  90.         else:</font>
<font color="red">  91.             count += 1</font>
<font color="red">  92.     return count</font>
<font color="black">  93. </font>
<font color="black">  94. </font>
<font color="green">  95. def _max_append(L, s, maxlen, extra=''):</font>
<font color="red">  96.     if not L:</font>
<font color="red">  97.         L.append(s.lstrip())</font>
<font color="red">  98.     elif len(L[-1]) + len(s) &lt;= maxlen:</font>
<font color="red">  99.         L[-1] += extra + s</font>
<font color="black"> 100.     else:</font>
<font color="red"> 101.         L.append(s.lstrip())</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. def unquote(s):</font>
<font color="black"> 105.     &quot;&quot;&quot;Turn a string in the form =AB to the ASCII character with value 0xab&quot;&quot;&quot;</font>
<font color="red"> 106.     return chr(int(s[1:3], 16))</font>
<font color="black"> 107. </font>
<font color="black"> 108. </font>
<font color="green"> 109. def quote(c):</font>
<font color="red"> 110.     return &quot;=%02X&quot; % ord(c)</font>
<font color="black"> 111. </font>
<font color="black"> 112. </font>
<font color="black"> 113. </font>
<font color="green"> 114. def header_encode(header, charset=&quot;iso-8859-1&quot;, keep_eols=False,</font>
<font color="green"> 115.                   maxlinelen=76, eol=NL):</font>
<font color="black"> 116.     &quot;&quot;&quot;Encode a single header line with quoted-printable (like) encoding.</font>
<font color="black"> 117. </font>
<font color="black"> 118.     Defined in RFC 2045, this `Q' encoding is similar to quoted-printable, but</font>
<font color="black"> 119.     used specifically for email header fields to allow charsets with mostly 7</font>
<font color="black"> 120.     bit characters (and some 8 bit) to remain more or less readable in non-RFC</font>
<font color="black"> 121.     2045 aware mail clients.</font>
<font color="black"> 122. </font>
<font color="black"> 123.     charset names the character set to use to encode the header.  It defaults</font>
<font color="black"> 124.     to iso-8859-1.</font>
<font color="black"> 125. </font>
<font color="black"> 126.     The resulting string will be in the form:</font>
<font color="black"> 127. </font>
<font color="black"> 128.     &quot;=?charset?q?I_f=E2rt_in_your_g=E8n=E8ral_dire=E7tion?\\n</font>
<font color="black"> 129.       =?charset?q?Silly_=C8nglish_Kn=EEghts?=&quot;</font>
<font color="black"> 130. </font>
<font color="black"> 131.     with each line wrapped safely at, at most, maxlinelen characters (defaults</font>
<font color="black"> 132.     to 76 characters).  If maxlinelen is None, the entire string is encoded in</font>
<font color="black"> 133.     one chunk with no splitting.</font>
<font color="black"> 134. </font>
<font color="black"> 135.     End-of-line characters (\\r, \\n, \\r\\n) will be automatically converted</font>
<font color="black"> 136.     to the canonical email line separator \\r\\n unless the keep_eols</font>
<font color="black"> 137.     parameter is True (the default is False).</font>
<font color="black"> 138. </font>
<font color="black"> 139.     Each line of the header will be terminated in the value of eol, which</font>
<font color="black"> 140.     defaults to &quot;\\n&quot;.  Set this to &quot;\\r\\n&quot; if you are using the result of</font>
<font color="black"> 141.     this function directly in email.</font>
<font color="black"> 142.     &quot;&quot;&quot;</font>
<font color="black"> 143.     # Return empty headers unchanged</font>
<font color="red"> 144.     if not header:</font>
<font color="red"> 145.         return header</font>
<font color="black"> 146. </font>
<font color="red"> 147.     if not keep_eols:</font>
<font color="red"> 148.         header = fix_eols(header)</font>
<font color="black"> 149. </font>
<font color="black"> 150.     # Quopri encode each line, in encoded chunks no greater than maxlinelen in</font>
<font color="black"> 151.     # length, after the RFC chrome is added in.</font>
<font color="red"> 152.     quoted = []</font>
<font color="red"> 153.     if maxlinelen is None:</font>
<font color="black"> 154.         # An obnoxiously large number that's good enough</font>
<font color="red"> 155.         max_encoded = 100000</font>
<font color="black"> 156.     else:</font>
<font color="red"> 157.         max_encoded = maxlinelen - len(charset) - MISC_LEN - 1</font>
<font color="black"> 158. </font>
<font color="red"> 159.     for c in header:</font>
<font color="black"> 160.         # Space may be represented as _ instead of =20 for readability</font>
<font color="red"> 161.         if c == ' ':</font>
<font color="red"> 162.             _max_append(quoted, '_', max_encoded)</font>
<font color="black"> 163.         # These characters can be included verbatim</font>
<font color="red"> 164.         elif not hqre.match(c):</font>
<font color="red"> 165.             _max_append(quoted, c, max_encoded)</font>
<font color="black"> 166.         # Otherwise, replace with hex value like =E2</font>
<font color="black"> 167.         else:</font>
<font color="red"> 168.             _max_append(quoted, &quot;=%02X&quot; % ord(c), max_encoded)</font>
<font color="black"> 169. </font>
<font color="black"> 170.     # Now add the RFC chrome to each encoded chunk and glue the chunks</font>
<font color="black"> 171.     # together.  BAW: should we be able to specify the leading whitespace in</font>
<font color="black"> 172.     # the joiner?</font>
<font color="red"> 173.     joiner = eol + ' '</font>
<font color="red"> 174.     return joiner.join(['=?%s?q?%s?=' % (charset, line) for line in quoted])</font>
<font color="black"> 175. </font>
<font color="black"> 176. </font>
<font color="black"> 177. </font>
<font color="green"> 178. def encode(body, binary=False, maxlinelen=76, eol=NL):</font>
<font color="black"> 179.     &quot;&quot;&quot;Encode with quoted-printable, wrapping at maxlinelen characters.</font>
<font color="black"> 180. </font>
<font color="black"> 181.     If binary is False (the default), end-of-line characters will be converted</font>
<font color="black"> 182.     to the canonical email end-of-line sequence \\r\\n.  Otherwise they will</font>
<font color="black"> 183.     be left verbatim.</font>
<font color="black"> 184. </font>
<font color="black"> 185.     Each line of encoded text will end with eol, which defaults to &quot;\\n&quot;.  Set</font>
<font color="black"> 186.     this to &quot;\\r\\n&quot; if you will be using the result of this function directly</font>
<font color="black"> 187.     in an email.</font>
<font color="black"> 188. </font>
<font color="black"> 189.     Each line will be wrapped at, at most, maxlinelen characters (defaults to</font>
<font color="black"> 190.     76 characters).  Long lines will have the `soft linefeed' quoted-printable</font>
<font color="black"> 191.     character &quot;=&quot; appended to them, so the decoded text will be identical to</font>
<font color="black"> 192.     the original text.</font>
<font color="black"> 193.     &quot;&quot;&quot;</font>
<font color="red"> 194.     if not body:</font>
<font color="red"> 195.         return body</font>
<font color="black"> 196. </font>
<font color="red"> 197.     if not binary:</font>
<font color="red"> 198.         body = fix_eols(body)</font>
<font color="black"> 199. </font>
<font color="black"> 200.     # BAW: We're accumulating the body text by string concatenation.  That</font>
<font color="black"> 201.     # can't be very efficient, but I don't have time now to rewrite it.  It</font>
<font color="black"> 202.     # just feels like this algorithm could be more efficient.</font>
<font color="red"> 203.     encoded_body = ''</font>
<font color="red"> 204.     lineno = -1</font>
<font color="black"> 205.     # Preserve line endings here so we can check later to see an eol needs to</font>
<font color="black"> 206.     # be added to the output later.</font>
<font color="red"> 207.     lines = body.splitlines(1)</font>
<font color="red"> 208.     for line in lines:</font>
<font color="black"> 209.         # But strip off line-endings for processing this line.</font>
<font color="red"> 210.         if line.endswith(CRLF):</font>
<font color="red"> 211.             line = line[:-2]</font>
<font color="red"> 212.         elif line[-1] in CRLF:</font>
<font color="red"> 213.             line = line[:-1]</font>
<font color="black"> 214. </font>
<font color="red"> 215.         lineno += 1</font>
<font color="red"> 216.         encoded_line = ''</font>
<font color="red"> 217.         prev = None</font>
<font color="red"> 218.         linelen = len(line)</font>
<font color="black"> 219.         # Now we need to examine every character to see if it needs to be</font>
<font color="black"> 220.         # quopri encoded.  BAW: again, string concatenation is inefficient.</font>
<font color="red"> 221.         for j in range(linelen):</font>
<font color="red"> 222.             c = line[j]</font>
<font color="red"> 223.             prev = c</font>
<font color="red"> 224.             if bqre.match(c):</font>
<font color="red"> 225.                 c = quote(c)</font>
<font color="red"> 226.             elif j+1 == linelen:</font>
<font color="black"> 227.                 # Check for whitespace at end of line; special case</font>
<font color="red"> 228.                 if c not in ' \t':</font>
<font color="red"> 229.                     encoded_line += c</font>
<font color="red"> 230.                 prev = c</font>
<font color="red"> 231.                 continue</font>
<font color="black"> 232.             # Check to see to see if the line has reached its maximum length</font>
<font color="red"> 233.             if len(encoded_line) + len(c) &gt;= maxlinelen:</font>
<font color="red"> 234.                 encoded_body += encoded_line + '=' + eol</font>
<font color="red"> 235.                 encoded_line = ''</font>
<font color="red"> 236.             encoded_line += c</font>
<font color="black"> 237.         # Now at end of line..</font>
<font color="red"> 238.         if prev and prev in ' \t':</font>
<font color="black"> 239.             # Special case for whitespace at end of file</font>
<font color="red"> 240.             if lineno + 1 == len(lines):</font>
<font color="red"> 241.                 prev = quote(prev)</font>
<font color="red"> 242.                 if len(encoded_line) + len(prev) &gt; maxlinelen:</font>
<font color="red"> 243.                     encoded_body += encoded_line + '=' + eol + prev</font>
<font color="black"> 244.                 else:</font>
<font color="red"> 245.                     encoded_body += encoded_line + prev</font>
<font color="black"> 246.             # Just normal whitespace at end of line</font>
<font color="black"> 247.             else:</font>
<font color="red"> 248.                 encoded_body += encoded_line + prev + '=' + eol</font>
<font color="red"> 249.             encoded_line = ''</font>
<font color="black"> 250.         # Now look at the line we just finished and it has a line ending, we</font>
<font color="black"> 251.         # need to add eol to the end of the line.</font>
<font color="red"> 252.         if lines[lineno].endswith(CRLF) or lines[lineno][-1] in CRLF:</font>
<font color="red"> 253.             encoded_body += encoded_line + eol</font>
<font color="black"> 254.         else:</font>
<font color="red"> 255.             encoded_body += encoded_line</font>
<font color="red"> 256.         encoded_line = ''</font>
<font color="red"> 257.     return encoded_body</font>
<font color="black"> 258. </font>
<font color="black"> 259. </font>
<font color="black"> 260. # For convenience and backwards compatibility w/ standard base64 module</font>
<font color="green"> 261. body_encode = encode</font>
<font color="green"> 262. encodestring = encode</font>
<font color="black"> 263. </font>
<font color="black"> 264. </font>
<font color="black"> 265. </font>
<font color="black"> 266. # BAW: I'm not sure if the intent was for the signature of this function to be</font>
<font color="black"> 267. # the same as base64MIME.decode() or not...</font>
<font color="green"> 268. def decode(encoded, eol=NL):</font>
<font color="black"> 269.     &quot;&quot;&quot;Decode a quoted-printable string.</font>
<font color="black"> 270. </font>
<font color="black"> 271.     Lines are separated with eol, which defaults to \\n.</font>
<font color="black"> 272.     &quot;&quot;&quot;</font>
<font color="red"> 273.     if not encoded:</font>
<font color="red"> 274.         return encoded</font>
<font color="black"> 275.     # BAW: see comment in encode() above.  Again, we're building up the</font>
<font color="black"> 276.     # decoded string with string concatenation, which could be done much more</font>
<font color="black"> 277.     # efficiently.</font>
<font color="red"> 278.     decoded = ''</font>
<font color="black"> 279. </font>
<font color="red"> 280.     for line in encoded.splitlines():</font>
<font color="red"> 281.         line = line.rstrip()</font>
<font color="red"> 282.         if not line:</font>
<font color="red"> 283.             decoded += eol</font>
<font color="red"> 284.             continue</font>
<font color="black"> 285. </font>
<font color="red"> 286.         i = 0</font>
<font color="red"> 287.         n = len(line)</font>
<font color="red"> 288.         while i &lt; n:</font>
<font color="red"> 289.             c = line[i]</font>
<font color="red"> 290.             if c != '=':</font>
<font color="red"> 291.                 decoded += c</font>
<font color="red"> 292.                 i += 1</font>
<font color="black"> 293.             # Otherwise, c == &quot;=&quot;.  Are we at the end of the line?  If so, add</font>
<font color="black"> 294.             # a soft line break.</font>
<font color="red"> 295.             elif i+1 == n:</font>
<font color="red"> 296.                 i += 1</font>
<font color="red"> 297.                 continue</font>
<font color="black"> 298.             # Decode if in form =AB</font>
<font color="red"> 299.             elif i+2 &lt; n and line[i+1] in hexdigits and line[i+2] in hexdigits:</font>
<font color="red"> 300.                 decoded += unquote(line[i:i+3])</font>
<font color="red"> 301.                 i += 3</font>
<font color="black"> 302.             # Otherwise, not in form =AB, pass literally</font>
<font color="black"> 303.             else:</font>
<font color="red"> 304.                 decoded += c</font>
<font color="red"> 305.                 i += 1</font>
<font color="black"> 306. </font>
<font color="red"> 307.             if i == n:</font>
<font color="red"> 308.                 decoded += eol</font>
<font color="black"> 309.     # Special case if original string did not end with eol</font>
<font color="red"> 310.     if not encoded.endswith(eol) and decoded.endswith(eol):</font>
<font color="red"> 311.         decoded = decoded[:-1]</font>
<font color="red"> 312.     return decoded</font>
<font color="black"> 313. </font>
<font color="black"> 314. </font>
<font color="black"> 315. # For convenience and backwards compatibility w/ standard base64 module</font>
<font color="green"> 316. body_decode = decode</font>
<font color="green"> 317. decodestring = decode</font>
<font color="black"> 318. </font>
<font color="black"> 319. </font>
<font color="black"> 320. </font>
<font color="green"> 321. def _unquote_match(match):</font>
<font color="black"> 322.     &quot;&quot;&quot;Turn a match in the form =AB to the ASCII character with value 0xab&quot;&quot;&quot;</font>
<font color="red"> 323.     s = match.group(0)</font>
<font color="red"> 324.     return unquote(s)</font>
<font color="black"> 325. </font>
<font color="black"> 326. </font>
<font color="black"> 327. # Header decoding is done a bit differently</font>
<font color="green"> 328. def header_decode(s):</font>
<font color="black"> 329.     &quot;&quot;&quot;Decode a string encoded with RFC 2045 MIME header `Q' encoding.</font>
<font color="black"> 330. </font>
<font color="black"> 331.     This function does not parse a full MIME header value encoded with</font>
<font color="black"> 332.     quoted-printable (like =?iso-8895-1?q?Hello_World?=) -- please use</font>
<font color="black"> 333.     the high level email.header class for that functionality.</font>
<font color="black"> 334.     &quot;&quot;&quot;</font>
<font color="red"> 335.     s = s.replace('_', ' ')</font>
<font color="red"> 336.     return re.sub(r'=[a-fA-F0-9]{2}', _unquote_match, s)</font>
</pre>

