source file: <b>/usr/lib/python2.7/tempfile.py</b><br>


file stats: <b>335 lines, 94 executed: 28.1% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Temporary files.</font>
<font color="black">   2. </font>
<font color="black">   3. This module provides generic, low- and high-level interfaces for</font>
<font color="black">   4. creating temporary files and directories.  The interfaces listed</font>
<font color="black">   5. as &quot;safe&quot; just below can be used without fear of race conditions.</font>
<font color="black">   6. Those listed as &quot;unsafe&quot; cannot, and are provided for backward</font>
<font color="black">   7. compatibility only.</font>
<font color="black">   8. </font>
<font color="black">   9. This module also provides some data items to the user:</font>
<font color="black">  10. </font>
<font color="black">  11.   TMP_MAX  - maximum number of names that will be tried before</font>
<font color="black">  12.              giving up.</font>
<font color="black">  13.   template - the default prefix for all temporary names.</font>
<font color="black">  14.              You may change this to control the default prefix.</font>
<font color="black">  15.   tempdir  - If this is set to a string before the first use of</font>
<font color="black">  16.              any routine from this module, it will be considered as</font>
<font color="black">  17.              another candidate location to store temporary files.</font>
<font color="green">  18. &quot;&quot;&quot;</font>
<font color="black">  19. </font>
<font color="black">  20. __all__ = [</font>
<font color="green">  21.     &quot;NamedTemporaryFile&quot;, &quot;TemporaryFile&quot;, # high level safe interfaces</font>
<font color="green">  22.     &quot;SpooledTemporaryFile&quot;,</font>
<font color="green">  23.     &quot;mkstemp&quot;, &quot;mkdtemp&quot;,                  # low level safe interfaces</font>
<font color="green">  24.     &quot;mktemp&quot;,                              # deprecated unsafe interface</font>
<font color="green">  25.     &quot;TMP_MAX&quot;, &quot;gettempprefix&quot;,            # constants</font>
<font color="green">  26.     &quot;tempdir&quot;, &quot;gettempdir&quot;</font>
<font color="black">  27.    ]</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="black">  30. # Imports.</font>
<font color="black">  31. </font>
<font color="green">  32. import io as _io</font>
<font color="green">  33. import os as _os</font>
<font color="green">  34. import errno as _errno</font>
<font color="green">  35. from random import Random as _Random</font>
<font color="black">  36. </font>
<font color="green">  37. try:</font>
<font color="green">  38.     from cStringIO import StringIO as _StringIO</font>
<font color="red">  39. except ImportError:</font>
<font color="red">  40.     from StringIO import StringIO as _StringIO</font>
<font color="black">  41. </font>
<font color="green">  42. try:</font>
<font color="green">  43.     import fcntl as _fcntl</font>
<font color="red">  44. except ImportError:</font>
<font color="red">  45.     def _set_cloexec(fd):</font>
<font color="red">  46.         pass</font>
<font color="black">  47. else:</font>
<font color="green">  48.     def _set_cloexec(fd):</font>
<font color="red">  49.         try:</font>
<font color="red">  50.             flags = _fcntl.fcntl(fd, _fcntl.F_GETFD, 0)</font>
<font color="red">  51.         except IOError:</font>
<font color="red">  52.             pass</font>
<font color="black">  53.         else:</font>
<font color="black">  54.             # flags read successfully, modify</font>
<font color="red">  55.             flags |= _fcntl.FD_CLOEXEC</font>
<font color="red">  56.             _fcntl.fcntl(fd, _fcntl.F_SETFD, flags)</font>
<font color="black">  57. </font>
<font color="black">  58. </font>
<font color="green">  59. try:</font>
<font color="green">  60.     import thread as _thread</font>
<font color="red">  61. except ImportError:</font>
<font color="red">  62.     import dummy_thread as _thread</font>
<font color="green">  63. _allocate_lock = _thread.allocate_lock</font>
<font color="black">  64. </font>
<font color="green">  65. _text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL</font>
<font color="green">  66. if hasattr(_os, 'O_NOINHERIT'):</font>
<font color="red">  67.     _text_openflags |= _os.O_NOINHERIT</font>
<font color="green">  68. if hasattr(_os, 'O_NOFOLLOW'):</font>
<font color="green">  69.     _text_openflags |= _os.O_NOFOLLOW</font>
<font color="black">  70. </font>
<font color="green">  71. _bin_openflags = _text_openflags</font>
<font color="green">  72. if hasattr(_os, 'O_BINARY'):</font>
<font color="red">  73.     _bin_openflags |= _os.O_BINARY</font>
<font color="black">  74. </font>
<font color="green">  75. if hasattr(_os, 'TMP_MAX'):</font>
<font color="green">  76.     TMP_MAX = _os.TMP_MAX</font>
<font color="black">  77. else:</font>
<font color="red">  78.     TMP_MAX = 10000</font>
<font color="black">  79. </font>
<font color="green">  80. template = &quot;tmp&quot;</font>
<font color="black">  81. </font>
<font color="black">  82. # Internal routines.</font>
<font color="black">  83. </font>
<font color="green">  84. _once_lock = _allocate_lock()</font>
<font color="black">  85. </font>
<font color="green">  86. if hasattr(_os, &quot;lstat&quot;):</font>
<font color="green">  87.     _stat = _os.lstat</font>
<font color="red">  88. elif hasattr(_os, &quot;stat&quot;):</font>
<font color="red">  89.     _stat = _os.stat</font>
<font color="black">  90. else:</font>
<font color="black">  91.     # Fallback.  All we need is something that raises os.error if the</font>
<font color="black">  92.     # file doesn't exist.</font>
<font color="red">  93.     def _stat(fn):</font>
<font color="red">  94.         try:</font>
<font color="red">  95.             f = open(fn)</font>
<font color="red">  96.         except IOError:</font>
<font color="red">  97.             raise _os.error</font>
<font color="red">  98.         f.close()</font>
<font color="black">  99. </font>
<font color="green"> 100. def _exists(fn):</font>
<font color="red"> 101.     try:</font>
<font color="red"> 102.         _stat(fn)</font>
<font color="red"> 103.     except _os.error:</font>
<font color="red"> 104.         return False</font>
<font color="black"> 105.     else:</font>
<font color="red"> 106.         return True</font>
<font color="black"> 107. </font>
<font color="green"> 108. class _RandomNameSequence:</font>
<font color="black"> 109.     &quot;&quot;&quot;An instance of _RandomNameSequence generates an endless</font>
<font color="black"> 110.     sequence of unpredictable strings which can safely be incorporated</font>
<font color="black"> 111.     into file names.  Each string is six characters long.  Multiple</font>
<font color="black"> 112.     threads can safely use the same instance at the same time.</font>
<font color="black"> 113. </font>
<font color="green"> 114.     _RandomNameSequence is an iterator.&quot;&quot;&quot;</font>
<font color="black"> 115. </font>
<font color="black"> 116.     characters = (&quot;abcdefghijklmnopqrstuvwxyz&quot; +</font>
<font color="green"> 117.                   &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; +</font>
<font color="green"> 118.                   &quot;0123456789_&quot;)</font>
<font color="black"> 119. </font>
<font color="green"> 120.     def __init__(self):</font>
<font color="red"> 121.         self.mutex = _allocate_lock()</font>
<font color="red"> 122.         self.normcase = _os.path.normcase</font>
<font color="black"> 123. </font>
<font color="green"> 124.     @property</font>
<font color="black"> 125.     def rng(self):</font>
<font color="red"> 126.         cur_pid = _os.getpid()</font>
<font color="red"> 127.         if cur_pid != getattr(self, '_rng_pid', None):</font>
<font color="red"> 128.             self._rng = _Random()</font>
<font color="red"> 129.             self._rng_pid = cur_pid</font>
<font color="red"> 130.         return self._rng</font>
<font color="black"> 131. </font>
<font color="green"> 132.     def __iter__(self):</font>
<font color="red"> 133.         return self</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def next(self):</font>
<font color="red"> 136.         m = self.mutex</font>
<font color="red"> 137.         c = self.characters</font>
<font color="red"> 138.         choose = self.rng.choice</font>
<font color="black"> 139. </font>
<font color="red"> 140.         m.acquire()</font>
<font color="red"> 141.         try:</font>
<font color="red"> 142.             letters = [choose(c) for dummy in &quot;123456&quot;]</font>
<font color="black"> 143.         finally:</font>
<font color="red"> 144.             m.release()</font>
<font color="black"> 145. </font>
<font color="red"> 146.         return self.normcase(''.join(letters))</font>
<font color="black"> 147. </font>
<font color="green"> 148. def _candidate_tempdir_list():</font>
<font color="black"> 149.     &quot;&quot;&quot;Generate a list of candidate temporary directories which</font>
<font color="black"> 150.     _get_default_tempdir will try.&quot;&quot;&quot;</font>
<font color="black"> 151. </font>
<font color="red"> 152.     dirlist = []</font>
<font color="black"> 153. </font>
<font color="black"> 154.     # First, try the environment.</font>
<font color="red"> 155.     for envname in 'TMPDIR', 'TEMP', 'TMP':</font>
<font color="red"> 156.         dirname = _os.getenv(envname)</font>
<font color="red"> 157.         if dirname: dirlist.append(dirname)</font>
<font color="black"> 158. </font>
<font color="black"> 159.     # Failing that, try OS-specific locations.</font>
<font color="red"> 160.     if _os.name == 'riscos':</font>
<font color="red"> 161.         dirname = _os.getenv('Wimp$ScrapDir')</font>
<font color="red"> 162.         if dirname: dirlist.append(dirname)</font>
<font color="red"> 163.     elif _os.name == 'nt':</font>
<font color="red"> 164.         dirlist.extend([ r'c:\temp', r'c:\tmp', r'\temp', r'\tmp' ])</font>
<font color="black"> 165.     else:</font>
<font color="red"> 166.         dirlist.extend([ '/tmp', '/var/tmp', '/usr/tmp' ])</font>
<font color="black"> 167. </font>
<font color="black"> 168.     # As a last resort, the current directory.</font>
<font color="red"> 169.     try:</font>
<font color="red"> 170.         dirlist.append(_os.getcwd())</font>
<font color="red"> 171.     except (AttributeError, _os.error):</font>
<font color="red"> 172.         dirlist.append(_os.curdir)</font>
<font color="black"> 173. </font>
<font color="red"> 174.     return dirlist</font>
<font color="black"> 175. </font>
<font color="green"> 176. def _get_default_tempdir():</font>
<font color="black"> 177.     &quot;&quot;&quot;Calculate the default directory to use for temporary files.</font>
<font color="black"> 178.     This routine should be called exactly once.</font>
<font color="black"> 179. </font>
<font color="black"> 180.     We determine whether or not a candidate temp dir is usable by</font>
<font color="black"> 181.     trying to create and write to a file in that directory.  If this</font>
<font color="black"> 182.     is successful, the test file is deleted.  To prevent denial of</font>
<font color="black"> 183.     service, the name of the test file must be randomized.&quot;&quot;&quot;</font>
<font color="black"> 184. </font>
<font color="red"> 185.     namer = _RandomNameSequence()</font>
<font color="red"> 186.     dirlist = _candidate_tempdir_list()</font>
<font color="red"> 187.     flags = _text_openflags</font>
<font color="black"> 188. </font>
<font color="red"> 189.     for dir in dirlist:</font>
<font color="red"> 190.         if dir != _os.curdir:</font>
<font color="red"> 191.             dir = _os.path.normcase(_os.path.abspath(dir))</font>
<font color="black"> 192.         # Try only a few names per directory.</font>
<font color="red"> 193.         for seq in xrange(100):</font>
<font color="red"> 194.             name = namer.next()</font>
<font color="red"> 195.             filename = _os.path.join(dir, name)</font>
<font color="red"> 196.             try:</font>
<font color="red"> 197.                 fd = _os.open(filename, flags, 0o600)</font>
<font color="red"> 198.                 try:</font>
<font color="red"> 199.                     try:</font>
<font color="red"> 200.                         with _io.open(fd, 'wb', closefd=False) as fp:</font>
<font color="red"> 201.                             fp.write(b'blat')</font>
<font color="black"> 202.                     finally:</font>
<font color="red"> 203.                         _os.close(fd)</font>
<font color="black"> 204.                 finally:</font>
<font color="red"> 205.                     _os.unlink(filename)</font>
<font color="red"> 206.                 return dir</font>
<font color="red"> 207.             except (OSError, IOError) as e:</font>
<font color="red"> 208.                 if e.args[0] != _errno.EEXIST:</font>
<font color="red"> 209.                     break # no point trying more names in this directory</font>
<font color="red"> 210.                 pass</font>
<font color="red"> 211.     raise IOError, (_errno.ENOENT,</font>
<font color="red"> 212.                     (&quot;No usable temporary directory found in %s&quot; % dirlist))</font>
<font color="black"> 213. </font>
<font color="green"> 214. _name_sequence = None</font>
<font color="black"> 215. </font>
<font color="green"> 216. def _get_candidate_names():</font>
<font color="black"> 217.     &quot;&quot;&quot;Common setup sequence for all user-callable interfaces.&quot;&quot;&quot;</font>
<font color="black"> 218. </font>
<font color="black"> 219.     global _name_sequence</font>
<font color="red"> 220.     if _name_sequence is None:</font>
<font color="red"> 221.         _once_lock.acquire()</font>
<font color="red"> 222.         try:</font>
<font color="red"> 223.             if _name_sequence is None:</font>
<font color="red"> 224.                 _name_sequence = _RandomNameSequence()</font>
<font color="black"> 225.         finally:</font>
<font color="red"> 226.             _once_lock.release()</font>
<font color="red"> 227.     return _name_sequence</font>
<font color="black"> 228. </font>
<font color="black"> 229. </font>
<font color="green"> 230. def _mkstemp_inner(dir, pre, suf, flags):</font>
<font color="black"> 231.     &quot;&quot;&quot;Code common to mkstemp, TemporaryFile, and NamedTemporaryFile.&quot;&quot;&quot;</font>
<font color="black"> 232. </font>
<font color="red"> 233.     names = _get_candidate_names()</font>
<font color="black"> 234. </font>
<font color="red"> 235.     for seq in xrange(TMP_MAX):</font>
<font color="red"> 236.         name = names.next()</font>
<font color="red"> 237.         file = _os.path.join(dir, pre + name + suf)</font>
<font color="red"> 238.         try:</font>
<font color="red"> 239.             fd = _os.open(file, flags, 0600)</font>
<font color="red"> 240.             _set_cloexec(fd)</font>
<font color="red"> 241.             return (fd, _os.path.abspath(file))</font>
<font color="red"> 242.         except OSError, e:</font>
<font color="red"> 243.             if e.errno == _errno.EEXIST:</font>
<font color="red"> 244.                 continue # try again</font>
<font color="red"> 245.             if _os.name == 'nt' and e.errno == _errno.EACCES:</font>
<font color="black"> 246.                 # On windows, when a directory with the chosen name already</font>
<font color="black"> 247.                 # exists, EACCES error code is returned instead of EEXIST.</font>
<font color="red"> 248.                 continue</font>
<font color="red"> 249.             raise</font>
<font color="black"> 250. </font>
<font color="red"> 251.     raise IOError, (_errno.EEXIST, &quot;No usable temporary file name found&quot;)</font>
<font color="black"> 252. </font>
<font color="black"> 253. </font>
<font color="black"> 254. # User visible interfaces.</font>
<font color="black"> 255. </font>
<font color="green"> 256. def gettempprefix():</font>
<font color="black"> 257.     &quot;&quot;&quot;Accessor for tempdir.template.&quot;&quot;&quot;</font>
<font color="red"> 258.     return template</font>
<font color="black"> 259. </font>
<font color="green"> 260. tempdir = None</font>
<font color="black"> 261. </font>
<font color="green"> 262. def gettempdir():</font>
<font color="black"> 263.     &quot;&quot;&quot;Accessor for tempfile.tempdir.&quot;&quot;&quot;</font>
<font color="black"> 264.     global tempdir</font>
<font color="red"> 265.     if tempdir is None:</font>
<font color="red"> 266.         _once_lock.acquire()</font>
<font color="red"> 267.         try:</font>
<font color="red"> 268.             if tempdir is None:</font>
<font color="red"> 269.                 tempdir = _get_default_tempdir()</font>
<font color="black"> 270.         finally:</font>
<font color="red"> 271.             _once_lock.release()</font>
<font color="red"> 272.     return tempdir</font>
<font color="black"> 273. </font>
<font color="green"> 274. def mkstemp(suffix=&quot;&quot;, prefix=template, dir=None, text=False):</font>
<font color="black"> 275.     &quot;&quot;&quot;User-callable function to create and return a unique temporary</font>
<font color="black"> 276.     file.  The return value is a pair (fd, name) where fd is the</font>
<font color="black"> 277.     file descriptor returned by os.open, and name is the filename.</font>
<font color="black"> 278. </font>
<font color="black"> 279.     If 'suffix' is specified, the file name will end with that suffix,</font>
<font color="black"> 280.     otherwise there will be no suffix.</font>
<font color="black"> 281. </font>
<font color="black"> 282.     If 'prefix' is specified, the file name will begin with that prefix,</font>
<font color="black"> 283.     otherwise a default prefix is used.</font>
<font color="black"> 284. </font>
<font color="black"> 285.     If 'dir' is specified, the file will be created in that directory,</font>
<font color="black"> 286.     otherwise a default directory is used.</font>
<font color="black"> 287. </font>
<font color="black"> 288.     If 'text' is specified and true, the file is opened in text</font>
<font color="black"> 289.     mode.  Else (the default) the file is opened in binary mode.  On</font>
<font color="black"> 290.     some operating systems, this makes no difference.</font>
<font color="black"> 291. </font>
<font color="black"> 292.     The file is readable and writable only by the creating user ID.</font>
<font color="black"> 293.     If the operating system uses permission bits to indicate whether a</font>
<font color="black"> 294.     file is executable, the file is executable by no one. The file</font>
<font color="black"> 295.     descriptor is not inherited by children of this process.</font>
<font color="black"> 296. </font>
<font color="black"> 297.     Caller is responsible for deleting the file when done with it.</font>
<font color="black"> 298.     &quot;&quot;&quot;</font>
<font color="black"> 299. </font>
<font color="red"> 300.     if dir is None:</font>
<font color="red"> 301.         dir = gettempdir()</font>
<font color="black"> 302. </font>
<font color="red"> 303.     if text:</font>
<font color="red"> 304.         flags = _text_openflags</font>
<font color="black"> 305.     else:</font>
<font color="red"> 306.         flags = _bin_openflags</font>
<font color="black"> 307. </font>
<font color="red"> 308.     return _mkstemp_inner(dir, prefix, suffix, flags)</font>
<font color="black"> 309. </font>
<font color="black"> 310. </font>
<font color="green"> 311. def mkdtemp(suffix=&quot;&quot;, prefix=template, dir=None):</font>
<font color="black"> 312.     &quot;&quot;&quot;User-callable function to create and return a unique temporary</font>
<font color="black"> 313.     directory.  The return value is the pathname of the directory.</font>
<font color="black"> 314. </font>
<font color="black"> 315.     Arguments are as for mkstemp, except that the 'text' argument is</font>
<font color="black"> 316.     not accepted.</font>
<font color="black"> 317. </font>
<font color="black"> 318.     The directory is readable, writable, and searchable only by the</font>
<font color="black"> 319.     creating user.</font>
<font color="black"> 320. </font>
<font color="black"> 321.     Caller is responsible for deleting the directory when done with it.</font>
<font color="black"> 322.     &quot;&quot;&quot;</font>
<font color="black"> 323. </font>
<font color="red"> 324.     if dir is None:</font>
<font color="red"> 325.         dir = gettempdir()</font>
<font color="black"> 326. </font>
<font color="red"> 327.     names = _get_candidate_names()</font>
<font color="black"> 328. </font>
<font color="red"> 329.     for seq in xrange(TMP_MAX):</font>
<font color="red"> 330.         name = names.next()</font>
<font color="red"> 331.         file = _os.path.join(dir, prefix + name + suffix)</font>
<font color="red"> 332.         try:</font>
<font color="red"> 333.             _os.mkdir(file, 0700)</font>
<font color="red"> 334.             return file</font>
<font color="red"> 335.         except OSError, e:</font>
<font color="red"> 336.             if e.errno == _errno.EEXIST:</font>
<font color="red"> 337.                 continue # try again</font>
<font color="red"> 338.             raise</font>
<font color="black"> 339. </font>
<font color="red"> 340.     raise IOError, (_errno.EEXIST, &quot;No usable temporary directory name found&quot;)</font>
<font color="black"> 341. </font>
<font color="green"> 342. def mktemp(suffix=&quot;&quot;, prefix=template, dir=None):</font>
<font color="black"> 343.     &quot;&quot;&quot;User-callable function to return a unique temporary file name.  The</font>
<font color="black"> 344.     file is not created.</font>
<font color="black"> 345. </font>
<font color="black"> 346.     Arguments are as for mkstemp, except that the 'text' argument is</font>
<font color="black"> 347.     not accepted.</font>
<font color="black"> 348. </font>
<font color="black"> 349.     This function is unsafe and should not be used.  The file name</font>
<font color="black"> 350.     refers to a file that did not exist at some point, but by the time</font>
<font color="black"> 351.     you get around to creating it, someone else may have beaten you to</font>
<font color="black"> 352.     the punch.</font>
<font color="black"> 353.     &quot;&quot;&quot;</font>
<font color="black"> 354. </font>
<font color="black"> 355. ##    from warnings import warn as _warn</font>
<font color="black"> 356. ##    _warn(&quot;mktemp is a potential security risk to your program&quot;,</font>
<font color="black"> 357. ##          RuntimeWarning, stacklevel=2)</font>
<font color="black"> 358. </font>
<font color="red"> 359.     if dir is None:</font>
<font color="red"> 360.         dir = gettempdir()</font>
<font color="black"> 361. </font>
<font color="red"> 362.     names = _get_candidate_names()</font>
<font color="red"> 363.     for seq in xrange(TMP_MAX):</font>
<font color="red"> 364.         name = names.next()</font>
<font color="red"> 365.         file = _os.path.join(dir, prefix + name + suffix)</font>
<font color="red"> 366.         if not _exists(file):</font>
<font color="red"> 367.             return file</font>
<font color="black"> 368. </font>
<font color="red"> 369.     raise IOError, (_errno.EEXIST, &quot;No usable temporary filename found&quot;)</font>
<font color="black"> 370. </font>
<font color="black"> 371. </font>
<font color="green"> 372. class _TemporaryFileWrapper:</font>
<font color="black"> 373.     &quot;&quot;&quot;Temporary file wrapper</font>
<font color="black"> 374. </font>
<font color="black"> 375.     This class provides a wrapper around files opened for</font>
<font color="black"> 376.     temporary use.  In particular, it seeks to automatically</font>
<font color="black"> 377.     remove the file when it is no longer needed.</font>
<font color="green"> 378.     &quot;&quot;&quot;</font>
<font color="black"> 379. </font>
<font color="green"> 380.     def __init__(self, file, name, delete=True):</font>
<font color="red"> 381.         self.file = file</font>
<font color="red"> 382.         self.name = name</font>
<font color="red"> 383.         self.close_called = False</font>
<font color="red"> 384.         self.delete = delete</font>
<font color="black"> 385. </font>
<font color="green"> 386.     def __getattr__(self, name):</font>
<font color="black"> 387.         # Attribute lookups are delegated to the underlying file</font>
<font color="black"> 388.         # and cached for non-numeric results</font>
<font color="black"> 389.         # (i.e. methods are cached, closed and friends are not)</font>
<font color="red"> 390.         file = self.__dict__['file']</font>
<font color="red"> 391.         a = getattr(file, name)</font>
<font color="red"> 392.         if not issubclass(type(a), type(0)):</font>
<font color="red"> 393.             setattr(self, name, a)</font>
<font color="red"> 394.         return a</font>
<font color="black"> 395. </font>
<font color="black"> 396.     # The underlying __enter__ method returns the wrong object</font>
<font color="black"> 397.     # (self.file) so override it to return the wrapper</font>
<font color="green"> 398.     def __enter__(self):</font>
<font color="red"> 399.         self.file.__enter__()</font>
<font color="red"> 400.         return self</font>
<font color="black"> 401. </font>
<font color="black"> 402.     # NT provides delete-on-close as a primitive, so we don't need</font>
<font color="black"> 403.     # the wrapper to do anything special.  We still use it so that</font>
<font color="black"> 404.     # file.name is useful (i.e. not &quot;(fdopen)&quot;) with NamedTemporaryFile.</font>
<font color="green"> 405.     if _os.name != 'nt':</font>
<font color="black"> 406.         # Cache the unlinker so we don't get spurious errors at</font>
<font color="black"> 407.         # shutdown when the module-level &quot;os&quot; is None'd out.  Note</font>
<font color="black"> 408.         # that this must be referenced as self.unlink, because the</font>
<font color="black"> 409.         # name TemporaryFileWrapper may also get None'd out before</font>
<font color="black"> 410.         # __del__ is called.</font>
<font color="green"> 411.         unlink = _os.unlink</font>
<font color="black"> 412. </font>
<font color="green"> 413.         def close(self):</font>
<font color="red"> 414.             if not self.close_called:</font>
<font color="red"> 415.                 self.close_called = True</font>
<font color="red"> 416.                 self.file.close()</font>
<font color="red"> 417.                 if self.delete:</font>
<font color="red"> 418.                     self.unlink(self.name)</font>
<font color="black"> 419. </font>
<font color="green"> 420.         def __del__(self):</font>
<font color="red"> 421.             self.close()</font>
<font color="black"> 422. </font>
<font color="black"> 423.         # Need to trap __exit__ as well to ensure the file gets</font>
<font color="black"> 424.         # deleted when used in a with statement</font>
<font color="green"> 425.         def __exit__(self, exc, value, tb):</font>
<font color="red"> 426.             result = self.file.__exit__(exc, value, tb)</font>
<font color="red"> 427.             self.close()</font>
<font color="red"> 428.             return result</font>
<font color="black"> 429.     else:</font>
<font color="red"> 430.         def __exit__(self, exc, value, tb):</font>
<font color="red"> 431.             self.file.__exit__(exc, value, tb)</font>
<font color="black"> 432. </font>
<font color="black"> 433. </font>
<font color="green"> 434. def NamedTemporaryFile(mode='w+b', bufsize=-1, suffix=&quot;&quot;,</font>
<font color="green"> 435.                        prefix=template, dir=None, delete=True):</font>
<font color="black"> 436.     &quot;&quot;&quot;Create and return a temporary file.</font>
<font color="black"> 437.     Arguments:</font>
<font color="black"> 438.     'prefix', 'suffix', 'dir' -- as for mkstemp.</font>
<font color="black"> 439.     'mode' -- the mode argument to os.fdopen (default &quot;w+b&quot;).</font>
<font color="black"> 440.     'bufsize' -- the buffer size argument to os.fdopen (default -1).</font>
<font color="black"> 441.     'delete' -- whether the file is deleted on close (default True).</font>
<font color="black"> 442.     The file is created as mkstemp() would do it.</font>
<font color="black"> 443. </font>
<font color="black"> 444.     Returns an object with a file-like interface; the name of the file</font>
<font color="black"> 445.     is accessible as file.name.  The file will be automatically deleted</font>
<font color="black"> 446.     when it is closed unless the 'delete' argument is set to False.</font>
<font color="black"> 447.     &quot;&quot;&quot;</font>
<font color="black"> 448. </font>
<font color="red"> 449.     if dir is None:</font>
<font color="red"> 450.         dir = gettempdir()</font>
<font color="black"> 451. </font>
<font color="red"> 452.     if 'b' in mode:</font>
<font color="red"> 453.         flags = _bin_openflags</font>
<font color="black"> 454.     else:</font>
<font color="red"> 455.         flags = _text_openflags</font>
<font color="black"> 456. </font>
<font color="black"> 457.     # Setting O_TEMPORARY in the flags causes the OS to delete</font>
<font color="black"> 458.     # the file when it is closed.  This is only supported by Windows.</font>
<font color="red"> 459.     if _os.name == 'nt' and delete:</font>
<font color="red"> 460.         flags |= _os.O_TEMPORARY</font>
<font color="black"> 461. </font>
<font color="red"> 462.     (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags)</font>
<font color="red"> 463.     file = _os.fdopen(fd, mode, bufsize)</font>
<font color="red"> 464.     return _TemporaryFileWrapper(file, name, delete)</font>
<font color="black"> 465. </font>
<font color="green"> 466. if _os.name != 'posix' or _os.sys.platform == 'cygwin':</font>
<font color="black"> 467.     # On non-POSIX and Cygwin systems, assume that we cannot unlink a file</font>
<font color="black"> 468.     # while it is open.</font>
<font color="red"> 469.     TemporaryFile = NamedTemporaryFile</font>
<font color="black"> 470. </font>
<font color="black"> 471. else:</font>
<font color="green"> 472.     def TemporaryFile(mode='w+b', bufsize=-1, suffix=&quot;&quot;,</font>
<font color="green"> 473.                       prefix=template, dir=None):</font>
<font color="black"> 474.         &quot;&quot;&quot;Create and return a temporary file.</font>
<font color="black"> 475.         Arguments:</font>
<font color="black"> 476.         'prefix', 'suffix', 'dir' -- as for mkstemp.</font>
<font color="black"> 477.         'mode' -- the mode argument to os.fdopen (default &quot;w+b&quot;).</font>
<font color="black"> 478.         'bufsize' -- the buffer size argument to os.fdopen (default -1).</font>
<font color="black"> 479.         The file is created as mkstemp() would do it.</font>
<font color="black"> 480. </font>
<font color="black"> 481.         Returns an object with a file-like interface.  The file has no</font>
<font color="black"> 482.         name, and will cease to exist when it is closed.</font>
<font color="black"> 483.         &quot;&quot;&quot;</font>
<font color="black"> 484. </font>
<font color="red"> 485.         if dir is None:</font>
<font color="red"> 486.             dir = gettempdir()</font>
<font color="black"> 487. </font>
<font color="red"> 488.         if 'b' in mode:</font>
<font color="red"> 489.             flags = _bin_openflags</font>
<font color="black"> 490.         else:</font>
<font color="red"> 491.             flags = _text_openflags</font>
<font color="black"> 492. </font>
<font color="red"> 493.         (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags)</font>
<font color="red"> 494.         try:</font>
<font color="red"> 495.             _os.unlink(name)</font>
<font color="red"> 496.             return _os.fdopen(fd, mode, bufsize)</font>
<font color="red"> 497.         except:</font>
<font color="red"> 498.             _os.close(fd)</font>
<font color="red"> 499.             raise</font>
<font color="black"> 500. </font>
<font color="green"> 501. class SpooledTemporaryFile:</font>
<font color="black"> 502.     &quot;&quot;&quot;Temporary file wrapper, specialized to switch from</font>
<font color="black"> 503.     StringIO to a real file when it exceeds a certain size or</font>
<font color="black"> 504.     when a fileno is needed.</font>
<font color="green"> 505.     &quot;&quot;&quot;</font>
<font color="green"> 506.     _rolled = False</font>
<font color="black"> 507. </font>
<font color="green"> 508.     def __init__(self, max_size=0, mode='w+b', bufsize=-1,</font>
<font color="green"> 509.                  suffix=&quot;&quot;, prefix=template, dir=None):</font>
<font color="red"> 510.         self._file = _StringIO()</font>
<font color="red"> 511.         self._max_size = max_size</font>
<font color="red"> 512.         self._rolled = False</font>
<font color="red"> 513.         self._TemporaryFileArgs = (mode, bufsize, suffix, prefix, dir)</font>
<font color="black"> 514. </font>
<font color="green"> 515.     def _check(self, file):</font>
<font color="red"> 516.         if self._rolled: return</font>
<font color="red"> 517.         max_size = self._max_size</font>
<font color="red"> 518.         if max_size and file.tell() &gt; max_size:</font>
<font color="red"> 519.             self.rollover()</font>
<font color="black"> 520. </font>
<font color="green"> 521.     def rollover(self):</font>
<font color="red"> 522.         if self._rolled: return</font>
<font color="red"> 523.         file = self._file</font>
<font color="red"> 524.         newfile = self._file = TemporaryFile(*self._TemporaryFileArgs)</font>
<font color="red"> 525.         del self._TemporaryFileArgs</font>
<font color="black"> 526. </font>
<font color="red"> 527.         newfile.write(file.getvalue())</font>
<font color="red"> 528.         newfile.seek(file.tell(), 0)</font>
<font color="black"> 529. </font>
<font color="red"> 530.         self._rolled = True</font>
<font color="black"> 531. </font>
<font color="black"> 532.     # The method caching trick from NamedTemporaryFile</font>
<font color="black"> 533.     # won't work here, because _file may change from a</font>
<font color="black"> 534.     # _StringIO instance to a real file. So we list</font>
<font color="black"> 535.     # all the methods directly.</font>
<font color="black"> 536. </font>
<font color="black"> 537.     # Context management protocol</font>
<font color="green"> 538.     def __enter__(self):</font>
<font color="red"> 539.         if self._file.closed:</font>
<font color="red"> 540.             raise ValueError(&quot;Cannot enter context with closed file&quot;)</font>
<font color="red"> 541.         return self</font>
<font color="black"> 542. </font>
<font color="green"> 543.     def __exit__(self, exc, value, tb):</font>
<font color="red"> 544.         self._file.close()</font>
<font color="black"> 545. </font>
<font color="black"> 546.     # file protocol</font>
<font color="green"> 547.     def __iter__(self):</font>
<font color="red"> 548.         return self._file.__iter__()</font>
<font color="black"> 549. </font>
<font color="green"> 550.     def close(self):</font>
<font color="red"> 551.         self._file.close()</font>
<font color="black"> 552. </font>
<font color="green"> 553.     @property</font>
<font color="black"> 554.     def closed(self):</font>
<font color="red"> 555.         return self._file.closed</font>
<font color="black"> 556. </font>
<font color="green"> 557.     def fileno(self):</font>
<font color="red"> 558.         self.rollover()</font>
<font color="red"> 559.         return self._file.fileno()</font>
<font color="black"> 560. </font>
<font color="green"> 561.     def flush(self):</font>
<font color="red"> 562.         self._file.flush()</font>
<font color="black"> 563. </font>
<font color="green"> 564.     def isatty(self):</font>
<font color="red"> 565.         return self._file.isatty()</font>
<font color="black"> 566. </font>
<font color="green"> 567.     @property</font>
<font color="black"> 568.     def mode(self):</font>
<font color="red"> 569.         try:</font>
<font color="red"> 570.             return self._file.mode</font>
<font color="red"> 571.         except AttributeError:</font>
<font color="red"> 572.             return self._TemporaryFileArgs[0]</font>
<font color="black"> 573. </font>
<font color="green"> 574.     @property</font>
<font color="black"> 575.     def name(self):</font>
<font color="red"> 576.         try:</font>
<font color="red"> 577.             return self._file.name</font>
<font color="red"> 578.         except AttributeError:</font>
<font color="red"> 579.             return None</font>
<font color="black"> 580. </font>
<font color="green"> 581.     def next(self):</font>
<font color="red"> 582.         return self._file.next</font>
<font color="black"> 583. </font>
<font color="green"> 584.     def read(self, *args):</font>
<font color="red"> 585.         return self._file.read(*args)</font>
<font color="black"> 586. </font>
<font color="green"> 587.     def readline(self, *args):</font>
<font color="red"> 588.         return self._file.readline(*args)</font>
<font color="black"> 589. </font>
<font color="green"> 590.     def readlines(self, *args):</font>
<font color="red"> 591.         return self._file.readlines(*args)</font>
<font color="black"> 592. </font>
<font color="green"> 593.     def seek(self, *args):</font>
<font color="red"> 594.         self._file.seek(*args)</font>
<font color="black"> 595. </font>
<font color="green"> 596.     @property</font>
<font color="black"> 597.     def softspace(self):</font>
<font color="red"> 598.         return self._file.softspace</font>
<font color="black"> 599. </font>
<font color="green"> 600.     def tell(self):</font>
<font color="red"> 601.         return self._file.tell()</font>
<font color="black"> 602. </font>
<font color="green"> 603.     def truncate(self):</font>
<font color="red"> 604.         self._file.truncate()</font>
<font color="black"> 605. </font>
<font color="green"> 606.     def write(self, s):</font>
<font color="red"> 607.         file = self._file</font>
<font color="red"> 608.         rv = file.write(s)</font>
<font color="red"> 609.         self._check(file)</font>
<font color="red"> 610.         return rv</font>
<font color="black"> 611. </font>
<font color="green"> 612.     def writelines(self, iterable):</font>
<font color="red"> 613.         file = self._file</font>
<font color="red"> 614.         rv = file.writelines(iterable)</font>
<font color="red"> 615.         self._check(file)</font>
<font color="red"> 616.         return rv</font>
<font color="black"> 617. </font>
<font color="green"> 618.     def xreadlines(self, *args):</font>
<font color="red"> 619.         if hasattr(self._file, 'xreadlines'):  # real file</font>
<font color="red"> 620.             return iter(self._file)</font>
<font color="black"> 621.         else:  # StringIO()</font>
<font color="red"> 622.             return iter(self._file.readlines(*args))</font>
</pre>

