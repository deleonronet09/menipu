source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/options.py</b><br>


file stats: <b>452 lines, 313 executed: 69.2% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import warnings</font>
<font color="green">   4. from bisect import bisect</font>
<font color="green">   5. from collections import OrderedDict, defaultdict</font>
<font color="green">   6. from itertools import chain</font>
<font color="black">   7. </font>
<font color="green">   8. from django.apps import apps</font>
<font color="green">   9. from django.conf import settings</font>
<font color="green">  10. from django.core.exceptions import FieldDoesNotExist</font>
<font color="green">  11. from django.db import connections</font>
<font color="green">  12. from django.db.models.fields import AutoField</font>
<font color="green">  13. from django.db.models.fields.proxy import OrderWrt</font>
<font color="green">  14. from django.db.models.fields.related import ManyToManyField</font>
<font color="green">  15. from django.utils import six</font>
<font color="green">  16. from django.utils.datastructures import ImmutableList, OrderedSet</font>
<font color="green">  17. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  18. from django.utils.encoding import (</font>
<font color="black">  19.     force_text, python_2_unicode_compatible, smart_text,</font>
<font color="black">  20. )</font>
<font color="green">  21. from django.utils.functional import cached_property</font>
<font color="green">  22. from django.utils.lru_cache import lru_cache</font>
<font color="green">  23. from django.utils.text import camel_case_to_spaces</font>
<font color="green">  24. from django.utils.translation import override, string_concat</font>
<font color="black">  25. </font>
<font color="green">  26. PROXY_PARENTS = object()</font>
<font color="black">  27. </font>
<font color="green">  28. EMPTY_RELATION_TREE = tuple()</font>
<font color="black">  29. </font>
<font color="black">  30. IMMUTABLE_WARNING = (</font>
<font color="green">  31.     &quot;The return type of '%s' should never be mutated. If you want to manipulate this list &quot;</font>
<font color="black">  32.     &quot;for your own use, make a copy first.&quot;</font>
<font color="black">  33. )</font>
<font color="black">  34. </font>
<font color="black">  35. DEFAULT_NAMES = ('verbose_name', 'verbose_name_plural', 'db_table', 'ordering',</font>
<font color="black">  36.                  'unique_together', 'permissions', 'get_latest_by',</font>
<font color="black">  37.                  'order_with_respect_to', 'app_label', 'db_tablespace',</font>
<font color="black">  38.                  'abstract', 'managed', 'proxy', 'swappable', 'auto_created',</font>
<font color="black">  39.                  'index_together', 'apps', 'default_permissions',</font>
<font color="black">  40.                  'select_on_save', 'default_related_name',</font>
<font color="green">  41.                  'required_db_features', 'required_db_vendor')</font>
<font color="black">  42. </font>
<font color="black">  43. </font>
<font color="green">  44. class raise_deprecation(object):</font>
<font color="green">  45.     def __init__(self, suggested_alternative):</font>
<font color="green">  46.         self.suggested_alternative = suggested_alternative</font>
<font color="black">  47. </font>
<font color="green">  48.     def __call__(self, fn):</font>
<font color="green">  49.         def wrapper(*args, **kwargs):</font>
<font color="red">  50.             warnings.warn(</font>
<font color="red">  51.                 &quot;'%s is an unofficial API that has been deprecated. &quot;</font>
<font color="black">  52.                 &quot;You may be able to replace it with '%s'&quot; % (</font>
<font color="red">  53.                     fn.__name__,</font>
<font color="red">  54.                     self.suggested_alternative,</font>
<font color="black">  55.                 ),</font>
<font color="red">  56.                 RemovedInDjango110Warning, stacklevel=2</font>
<font color="black">  57.             )</font>
<font color="red">  58.             return fn(*args, **kwargs)</font>
<font color="green">  59.         return wrapper</font>
<font color="black">  60. </font>
<font color="black">  61. </font>
<font color="green">  62. def normalize_together(option_together):</font>
<font color="black">  63.     &quot;&quot;&quot;</font>
<font color="black">  64.     option_together can be either a tuple of tuples, or a single</font>
<font color="black">  65.     tuple of two strings. Normalize it to a tuple of tuples, so that</font>
<font color="black">  66.     calling code can uniformly expect that.</font>
<font color="black">  67.     &quot;&quot;&quot;</font>
<font color="green">  68.     try:</font>
<font color="green">  69.         if not option_together:</font>
<font color="green">  70.             return ()</font>
<font color="green">  71.         if not isinstance(option_together, (tuple, list)):</font>
<font color="green">  72.             raise TypeError</font>
<font color="green">  73.         first_element = next(iter(option_together))</font>
<font color="green">  74.         if not isinstance(first_element, (tuple, list)):</font>
<font color="green">  75.             option_together = (option_together,)</font>
<font color="black">  76.         # Normalize everything to tuples</font>
<font color="green">  77.         return tuple(tuple(ot) for ot in option_together)</font>
<font color="green">  78.     except TypeError:</font>
<font color="black">  79.         # If the value of option_together isn't valid, return it</font>
<font color="black">  80.         # verbatim; this will be picked up by the check framework later.</font>
<font color="green">  81.         return option_together</font>
<font color="black">  82. </font>
<font color="black">  83. </font>
<font color="green">  84. def make_immutable_fields_list(name, data):</font>
<font color="green">  85.     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)</font>
<font color="black">  86. </font>
<font color="black">  87. </font>
<font color="green">  88. @python_2_unicode_compatible</font>
<font color="green">  89. class Options(object):</font>
<font color="black">  90.     FORWARD_PROPERTIES = ('fields', 'many_to_many', 'concrete_fields',</font>
<font color="green">  91.                           'local_concrete_fields', '_forward_fields_map')</font>
<font color="green">  92.     REVERSE_PROPERTIES = ('related_objects', 'fields_map', '_relation_tree')</font>
<font color="black">  93. </font>
<font color="green">  94.     def __init__(self, meta, app_label=None):</font>
<font color="green">  95.         self._get_fields_cache = {}</font>
<font color="green">  96.         self.proxied_children = []</font>
<font color="green">  97.         self.local_fields = []</font>
<font color="green">  98.         self.local_many_to_many = []</font>
<font color="green">  99.         self.virtual_fields = []</font>
<font color="green"> 100.         self.model_name = None</font>
<font color="green"> 101.         self.verbose_name = None</font>
<font color="green"> 102.         self.verbose_name_plural = None</font>
<font color="green"> 103.         self.db_table = ''</font>
<font color="green"> 104.         self.ordering = []</font>
<font color="green"> 105.         self._ordering_clash = False</font>
<font color="green"> 106.         self.unique_together = []</font>
<font color="green"> 107.         self.index_together = []</font>
<font color="green"> 108.         self.select_on_save = False</font>
<font color="green"> 109.         self.default_permissions = ('add', 'change', 'delete')</font>
<font color="green"> 110.         self.permissions = []</font>
<font color="green"> 111.         self.object_name = None</font>
<font color="green"> 112.         self.app_label = app_label</font>
<font color="green"> 113.         self.get_latest_by = None</font>
<font color="green"> 114.         self.order_with_respect_to = None</font>
<font color="green"> 115.         self.db_tablespace = settings.DEFAULT_TABLESPACE</font>
<font color="green"> 116.         self.required_db_features = []</font>
<font color="green"> 117.         self.required_db_vendor = None</font>
<font color="green"> 118.         self.meta = meta</font>
<font color="green"> 119.         self.pk = None</font>
<font color="green"> 120.         self.has_auto_field = False</font>
<font color="green"> 121.         self.auto_field = None</font>
<font color="green"> 122.         self.abstract = False</font>
<font color="green"> 123.         self.managed = True</font>
<font color="green"> 124.         self.proxy = False</font>
<font color="black"> 125.         # For any class that is a proxy (including automatically created</font>
<font color="black"> 126.         # classes for deferred object loading), proxy_for_model tells us</font>
<font color="black"> 127.         # which class this model is proxying. Note that proxy_for_model</font>
<font color="black"> 128.         # can create a chain of proxy models. For non-proxy models, the</font>
<font color="black"> 129.         # variable is always None.</font>
<font color="green"> 130.         self.proxy_for_model = None</font>
<font color="black"> 131.         # For any non-abstract class, the concrete class is the model</font>
<font color="black"> 132.         # in the end of the proxy_for_model chain. In particular, for</font>
<font color="black"> 133.         # concrete models, the concrete_model is always the class itself.</font>
<font color="green"> 134.         self.concrete_model = None</font>
<font color="green"> 135.         self.swappable = None</font>
<font color="green"> 136.         self.parents = OrderedDict()</font>
<font color="green"> 137.         self.auto_created = False</font>
<font color="black"> 138. </font>
<font color="black"> 139.         # To handle various inheritance situations, we need to track where</font>
<font color="black"> 140.         # managers came from (concrete or abstract base classes). `managers`</font>
<font color="black"> 141.         # keeps a list of 3-tuples of the form:</font>
<font color="black"> 142.         # (creation_counter, instance, abstract(=True))</font>
<font color="green"> 143.         self.managers = []</font>
<font color="black"> 144. </font>
<font color="black"> 145.         # List of all lookups defined in ForeignKey 'limit_choices_to' options</font>
<font color="black"> 146.         # from *other* models. Needed for some admin checks. Internal use only.</font>
<font color="green"> 147.         self.related_fkey_lookups = []</font>
<font color="black"> 148. </font>
<font color="black"> 149.         # A custom app registry to use, if you're making a separate model set.</font>
<font color="green"> 150.         self.apps = apps</font>
<font color="black"> 151. </font>
<font color="green"> 152.         self.default_related_name = None</font>
<font color="black"> 153. </font>
<font color="green"> 154.     @lru_cache(maxsize=None)</font>
<font color="black"> 155.     def _map_model(self, link):</font>
<font color="black"> 156.         # This helper function is used to allow backwards compatibility with</font>
<font color="black"> 157.         # the previous API. No future methods should use this function.</font>
<font color="black"> 158.         # It maps a field to (field, model or related_model,) depending on the</font>
<font color="black"> 159.         # field type.</font>
<font color="red"> 160.         model = link.model._meta.concrete_model</font>
<font color="red"> 161.         if model is self.model:</font>
<font color="red"> 162.             model = None</font>
<font color="red"> 163.         return link, model</font>
<font color="black"> 164. </font>
<font color="green"> 165.     @lru_cache(maxsize=None)</font>
<font color="black"> 166.     def _map_model_details(self, link):</font>
<font color="black"> 167.         # This helper function is used to allow backwards compatibility with</font>
<font color="black"> 168.         # the previous API. No future methods should use this function.</font>
<font color="black"> 169.         # This function maps a field to a tuple of:</font>
<font color="black"> 170.         #  (field, model or related_model, direct, is_m2m) depending on the</font>
<font color="black"> 171.         # field type.</font>
<font color="red"> 172.         direct = not link.auto_created or link.concrete</font>
<font color="red"> 173.         model = link.model._meta.concrete_model</font>
<font color="red"> 174.         if model is self.model:</font>
<font color="red"> 175.             model = None</font>
<font color="red"> 176.         m2m = link.is_relation and link.many_to_many</font>
<font color="red"> 177.         return link, model, direct, m2m</font>
<font color="black"> 178. </font>
<font color="green"> 179.     @property</font>
<font color="black"> 180.     def label(self):</font>
<font color="green"> 181.         return '%s.%s' % (self.app_label, self.object_name)</font>
<font color="black"> 182. </font>
<font color="green"> 183.     @property</font>
<font color="black"> 184.     def label_lower(self):</font>
<font color="green"> 185.         return '%s.%s' % (self.app_label, self.model_name)</font>
<font color="black"> 186. </font>
<font color="green"> 187.     @property</font>
<font color="black"> 188.     def app_config(self):</font>
<font color="black"> 189.         # Don't go through get_app_config to avoid triggering imports.</font>
<font color="red"> 190.         return self.apps.app_configs.get(self.app_label)</font>
<font color="black"> 191. </font>
<font color="green"> 192.     @property</font>
<font color="black"> 193.     def installed(self):</font>
<font color="red"> 194.         return self.app_config is not None</font>
<font color="black"> 195. </font>
<font color="green"> 196.     @property</font>
<font color="black"> 197.     def abstract_managers(self):</font>
<font color="black"> 198.         return [</font>
<font color="green"> 199.             (counter, instance.name, instance) for counter, instance, abstract</font>
<font color="green"> 200.             in self.managers if abstract</font>
<font color="black"> 201.         ]</font>
<font color="black"> 202. </font>
<font color="green"> 203.     @property</font>
<font color="black"> 204.     def concrete_managers(self):</font>
<font color="black"> 205.         return [</font>
<font color="red"> 206.             (counter, instance.name, instance) for counter, instance, abstract</font>
<font color="red"> 207.             in self.managers if not abstract</font>
<font color="black"> 208.         ]</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def contribute_to_class(self, cls, name):</font>
<font color="green"> 211.         from django.db import connection</font>
<font color="green"> 212.         from django.db.backends.utils import truncate_name</font>
<font color="black"> 213. </font>
<font color="green"> 214.         cls._meta = self</font>
<font color="green"> 215.         self.model = cls</font>
<font color="black"> 216.         # First, construct the default values for these options.</font>
<font color="green"> 217.         self.object_name = cls.__name__</font>
<font color="green"> 218.         self.model_name = self.object_name.lower()</font>
<font color="green"> 219.         self.verbose_name = camel_case_to_spaces(self.object_name)</font>
<font color="black"> 220. </font>
<font color="black"> 221.         # Store the original user-defined values for each option,</font>
<font color="black"> 222.         # for use when serializing the model definition</font>
<font color="green"> 223.         self.original_attrs = {}</font>
<font color="black"> 224. </font>
<font color="black"> 225.         # Next, apply any overridden values from 'class Meta'.</font>
<font color="green"> 226.         if self.meta:</font>
<font color="green"> 227.             meta_attrs = self.meta.__dict__.copy()</font>
<font color="green"> 228.             for name in self.meta.__dict__:</font>
<font color="black"> 229.                 # Ignore any private attributes that Django doesn't care about.</font>
<font color="black"> 230.                 # NOTE: We can't modify a dictionary's contents while looping</font>
<font color="black"> 231.                 # over it, so we loop over the *original* dictionary instead.</font>
<font color="green"> 232.                 if name.startswith('_'):</font>
<font color="green"> 233.                     del meta_attrs[name]</font>
<font color="green"> 234.             for attr_name in DEFAULT_NAMES:</font>
<font color="green"> 235.                 if attr_name in meta_attrs:</font>
<font color="green"> 236.                     setattr(self, attr_name, meta_attrs.pop(attr_name))</font>
<font color="green"> 237.                     self.original_attrs[attr_name] = getattr(self, attr_name)</font>
<font color="green"> 238.                 elif hasattr(self.meta, attr_name):</font>
<font color="green"> 239.                     setattr(self, attr_name, getattr(self.meta, attr_name))</font>
<font color="green"> 240.                     self.original_attrs[attr_name] = getattr(self, attr_name)</font>
<font color="black"> 241. </font>
<font color="green"> 242.             self.unique_together = normalize_together(self.unique_together)</font>
<font color="green"> 243.             self.index_together = normalize_together(self.index_together)</font>
<font color="black"> 244. </font>
<font color="black"> 245.             # verbose_name_plural is a special case because it uses a 's'</font>
<font color="black"> 246.             # by default.</font>
<font color="green"> 247.             if self.verbose_name_plural is None:</font>
<font color="green"> 248.                 self.verbose_name_plural = string_concat(self.verbose_name, 's')</font>
<font color="black"> 249. </font>
<font color="black"> 250.             # order_with_respect_and ordering are mutually exclusive.</font>
<font color="green"> 251.             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)</font>
<font color="black"> 252. </font>
<font color="black"> 253.             # Any leftover attributes must be invalid.</font>
<font color="green"> 254.             if meta_attrs != {}:</font>
<font color="red"> 255.                 raise TypeError(&quot;'class Meta' got invalid attribute(s): %s&quot; % ','.join(meta_attrs.keys()))</font>
<font color="black"> 256.         else:</font>
<font color="red"> 257.             self.verbose_name_plural = string_concat(self.verbose_name, 's')</font>
<font color="green"> 258.         del self.meta</font>
<font color="black"> 259. </font>
<font color="black"> 260.         # If the db_table wasn't provided, use the app_label + model_name.</font>
<font color="green"> 261.         if not self.db_table:</font>
<font color="green"> 262.             self.db_table = &quot;%s_%s&quot; % (self.app_label, self.model_name)</font>
<font color="green"> 263.             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def _prepare(self, model):</font>
<font color="green"> 266.         if self.order_with_respect_to:</font>
<font color="black"> 267.             # The app registry will not be ready at this point, so we cannot</font>
<font color="black"> 268.             # use get_field().</font>
<font color="red"> 269.             query = self.order_with_respect_to</font>
<font color="red"> 270.             try:</font>
<font color="red"> 271.                 self.order_with_respect_to = next(</font>
<font color="red"> 272.                     f for f in self._get_fields(reverse=False)</font>
<font color="red"> 273.                     if f.name == query or f.attname == query</font>
<font color="black"> 274.                 )</font>
<font color="red"> 275.             except StopIteration:</font>
<font color="red"> 276.                 raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, query))</font>
<font color="black"> 277. </font>
<font color="red"> 278.             self.ordering = ('_order',)</font>
<font color="red"> 279.             if not any(isinstance(field, OrderWrt) for field in model._meta.local_fields):</font>
<font color="red"> 280.                 model.add_to_class('_order', OrderWrt())</font>
<font color="black"> 281.         else:</font>
<font color="green"> 282.             self.order_with_respect_to = None</font>
<font color="black"> 283. </font>
<font color="green"> 284.         if self.pk is None:</font>
<font color="green"> 285.             if self.parents:</font>
<font color="black"> 286.                 # Promote the first parent link in lieu of adding yet another</font>
<font color="black"> 287.                 # field.</font>
<font color="red"> 288.                 field = next(six.itervalues(self.parents))</font>
<font color="black"> 289.                 # Look for a local field with the same name as the</font>
<font color="black"> 290.                 # first parent link. If a local field has already been</font>
<font color="black"> 291.                 # created, use it instead of promoting the parent</font>
<font color="red"> 292.                 already_created = [fld for fld in self.local_fields if fld.name == field.name]</font>
<font color="red"> 293.                 if already_created:</font>
<font color="red"> 294.                     field = already_created[0]</font>
<font color="red"> 295.                 field.primary_key = True</font>
<font color="red"> 296.                 self.setup_pk(field)</font>
<font color="black"> 297.             else:</font>
<font color="green"> 298.                 auto = AutoField(verbose_name='ID', primary_key=True,</font>
<font color="green"> 299.                         auto_created=True)</font>
<font color="green"> 300.                 model.add_to_class('id', auto)</font>
<font color="black"> 301. </font>
<font color="green"> 302.     def add_field(self, field, virtual=False):</font>
<font color="black"> 303.         # Insert the given field in the order in which it was created, using</font>
<font color="black"> 304.         # the &quot;creation_counter&quot; attribute of the field.</font>
<font color="black"> 305.         # Move many-to-many related fields from self.fields into</font>
<font color="black"> 306.         # self.many_to_many.</font>
<font color="green"> 307.         if virtual:</font>
<font color="red"> 308.             self.virtual_fields.append(field)</font>
<font color="green"> 309.         elif field.is_relation and field.many_to_many:</font>
<font color="green"> 310.             self.local_many_to_many.insert(bisect(self.local_many_to_many, field), field)</font>
<font color="black"> 311.         else:</font>
<font color="green"> 312.             self.local_fields.insert(bisect(self.local_fields, field), field)</font>
<font color="green"> 313.             self.setup_pk(field)</font>
<font color="black"> 314. </font>
<font color="black"> 315.         # If the field being added is a relation to another known field,</font>
<font color="black"> 316.         # expire the cache on this field and the forward cache on the field</font>
<font color="black"> 317.         # being referenced, because there will be new relationships in the</font>
<font color="black"> 318.         # cache. Otherwise, expire the cache of references *to* this field.</font>
<font color="black"> 319.         # The mechanism for getting at the related model is slightly odd -</font>
<font color="black"> 320.         # ideally, we'd just ask for field.related_model. However, related_model</font>
<font color="black"> 321.         # is a cached property, and all the models haven't been loaded yet, so</font>
<font color="black"> 322.         # we need to make sure we don't cache a string reference.</font>
<font color="green"> 323.         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:</font>
<font color="green"> 324.             try:</font>
<font color="green"> 325.                 field.remote_field.model._meta._expire_cache(forward=False)</font>
<font color="green"> 326.             except AttributeError:</font>
<font color="green"> 327.                 pass</font>
<font color="green"> 328.             self._expire_cache()</font>
<font color="black"> 329.         else:</font>
<font color="green"> 330.             self._expire_cache(reverse=False)</font>
<font color="black"> 331. </font>
<font color="green"> 332.     def setup_pk(self, field):</font>
<font color="green"> 333.         if not self.pk and field.primary_key:</font>
<font color="green"> 334.             self.pk = field</font>
<font color="green"> 335.             field.serialize = False</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def setup_proxy(self, target):</font>
<font color="black"> 338.         &quot;&quot;&quot;</font>
<font color="black"> 339.         Does the internal setup so that the current model is a proxy for</font>
<font color="black"> 340.         &quot;target&quot;.</font>
<font color="black"> 341.         &quot;&quot;&quot;</font>
<font color="red"> 342.         self.pk = target._meta.pk</font>
<font color="red"> 343.         self.proxy_for_model = target</font>
<font color="red"> 344.         self.db_table = target._meta.db_table</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def __repr__(self):</font>
<font color="red"> 347.         return '&lt;Options for %s&gt;' % self.object_name</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def __str__(self):</font>
<font color="green"> 350.         return &quot;%s.%s&quot; % (smart_text(self.app_label), smart_text(self.model_name))</font>
<font color="black"> 351. </font>
<font color="green"> 352.     def can_migrate(self, connection):</font>
<font color="black"> 353.         &quot;&quot;&quot;</font>
<font color="black"> 354.         Return True if the model can/should be migrated on the `connection`.</font>
<font color="black"> 355.         `connection` can be either a real connection or a connection alias.</font>
<font color="black"> 356.         &quot;&quot;&quot;</font>
<font color="green"> 357.         if self.proxy or self.swapped or not self.managed:</font>
<font color="red"> 358.             return False</font>
<font color="green"> 359.         if isinstance(connection, six.string_types):</font>
<font color="green"> 360.             connection = connections[connection]</font>
<font color="green"> 361.         if self.required_db_vendor:</font>
<font color="red"> 362.             return self.required_db_vendor == connection.vendor</font>
<font color="green"> 363.         if self.required_db_features:</font>
<font color="red"> 364.             return all(getattr(connection.features, feat, False)</font>
<font color="red"> 365.                        for feat in self.required_db_features)</font>
<font color="green"> 366.         return True</font>
<font color="black"> 367. </font>
<font color="green"> 368.     @property</font>
<font color="black"> 369.     def verbose_name_raw(self):</font>
<font color="black"> 370.         &quot;&quot;&quot;</font>
<font color="black"> 371.         There are a few places where the untranslated verbose name is needed</font>
<font color="black"> 372.         (so that we get the same value regardless of currently active</font>
<font color="black"> 373.         locale).</font>
<font color="black"> 374.         &quot;&quot;&quot;</font>
<font color="green"> 375.         with override(None):</font>
<font color="green"> 376.             return force_text(self.verbose_name)</font>
<font color="black"> 377. </font>
<font color="green"> 378.     @property</font>
<font color="black"> 379.     def swapped(self):</font>
<font color="black"> 380.         &quot;&quot;&quot;</font>
<font color="black"> 381.         Has this model been swapped out for another? If so, return the model</font>
<font color="black"> 382.         name of the replacement; otherwise, return None.</font>
<font color="black"> 383. </font>
<font color="black"> 384.         For historical reasons, model name lookups using get_model() are</font>
<font color="black"> 385.         case insensitive, so we make sure we are case insensitive here.</font>
<font color="black"> 386.         &quot;&quot;&quot;</font>
<font color="green"> 387.         if self.swappable:</font>
<font color="green"> 388.             swapped_for = getattr(settings, self.swappable, None)</font>
<font color="green"> 389.             if swapped_for:</font>
<font color="green"> 390.                 try:</font>
<font color="green"> 391.                     swapped_label, swapped_object = swapped_for.split('.')</font>
<font color="red"> 392.                 except ValueError:</font>
<font color="black"> 393.                     # setting not in the format app_label.model_name</font>
<font color="black"> 394.                     # raising ImproperlyConfigured here causes problems with</font>
<font color="black"> 395.                     # test cleanup code - instead it is raised in get_user_model</font>
<font color="black"> 396.                     # or as part of validation.</font>
<font color="red"> 397.                     return swapped_for</font>
<font color="black"> 398. </font>
<font color="green"> 399.                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:</font>
<font color="red"> 400.                     return swapped_for</font>
<font color="green"> 401.         return None</font>
<font color="black"> 402. </font>
<font color="green"> 403.     @cached_property</font>
<font color="black"> 404.     def fields(self):</font>
<font color="black"> 405.         &quot;&quot;&quot;</font>
<font color="black"> 406.         Returns a list of all forward fields on the model and its parents,</font>
<font color="black"> 407.         excluding ManyToManyFields.</font>
<font color="black"> 408. </font>
<font color="black"> 409.         Private API intended only to be used by Django itself; get_fields()</font>
<font color="black"> 410.         combined with filtering of field properties is the public API for</font>
<font color="black"> 411.         obtaining this field list.</font>
<font color="black"> 412.         &quot;&quot;&quot;</font>
<font color="black"> 413.         # For legacy reasons, the fields property should only contain forward</font>
<font color="black"> 414.         # fields that are not virtual or with a m2m cardinality. Therefore we</font>
<font color="black"> 415.         # pass these three filters as filters to the generator.</font>
<font color="black"> 416.         # The third lambda is a longwinded way of checking f.related_model - we don't</font>
<font color="black"> 417.         # use that property directly because related_model is a cached property,</font>
<font color="black"> 418.         # and all the models may not have been loaded yet; we don't want to cache</font>
<font color="black"> 419.         # the string reference to the related_model.</font>
<font color="green"> 420.         is_not_an_m2m_field = lambda f: not (f.is_relation and f.many_to_many)</font>
<font color="green"> 421.         is_not_a_generic_relation = lambda f: not (f.is_relation and f.one_to_many)</font>
<font color="green"> 422.         is_not_a_generic_foreign_key = lambda f: not (</font>
<font color="green"> 423.             f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)</font>
<font color="black"> 424.         )</font>
<font color="green"> 425.         return make_immutable_fields_list(</font>
<font color="green"> 426.             &quot;fields&quot;,</font>
<font color="green"> 427.             (f for f in self._get_fields(reverse=False) if</font>
<font color="green"> 428.             is_not_an_m2m_field(f) and is_not_a_generic_relation(f)</font>
<font color="green"> 429.             and is_not_a_generic_foreign_key(f))</font>
<font color="black"> 430.         )</font>
<font color="black"> 431. </font>
<font color="green"> 432.     @cached_property</font>
<font color="black"> 433.     def concrete_fields(self):</font>
<font color="black"> 434.         &quot;&quot;&quot;</font>
<font color="black"> 435.         Returns a list of all concrete fields on the model and its parents.</font>
<font color="black"> 436. </font>
<font color="black"> 437.         Private API intended only to be used by Django itself; get_fields()</font>
<font color="black"> 438.         combined with filtering of field properties is the public API for</font>
<font color="black"> 439.         obtaining this field list.</font>
<font color="black"> 440.         &quot;&quot;&quot;</font>
<font color="green"> 441.         return make_immutable_fields_list(</font>
<font color="green"> 442.             &quot;concrete_fields&quot;, (f for f in self.fields if f.concrete)</font>
<font color="black"> 443.         )</font>
<font color="black"> 444. </font>
<font color="green"> 445.     @cached_property</font>
<font color="black"> 446.     def local_concrete_fields(self):</font>
<font color="black"> 447.         &quot;&quot;&quot;</font>
<font color="black"> 448.         Returns a list of all concrete fields on the model.</font>
<font color="black"> 449. </font>
<font color="black"> 450.         Private API intended only to be used by Django itself; get_fields()</font>
<font color="black"> 451.         combined with filtering of field properties is the public API for</font>
<font color="black"> 452.         obtaining this field list.</font>
<font color="black"> 453.         &quot;&quot;&quot;</font>
<font color="green"> 454.         return make_immutable_fields_list(</font>
<font color="green"> 455.             &quot;local_concrete_fields&quot;, (f for f in self.local_fields if f.concrete)</font>
<font color="black"> 456.         )</font>
<font color="black"> 457. </font>
<font color="green"> 458.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="black"> 459.     def get_fields_with_model(self):</font>
<font color="red"> 460.         return [self._map_model(f) for f in self.get_fields()]</font>
<font color="black"> 461. </font>
<font color="green"> 462.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="black"> 463.     def get_concrete_fields_with_model(self):</font>
<font color="red"> 464.         return [self._map_model(f) for f in self.concrete_fields]</font>
<font color="black"> 465. </font>
<font color="green"> 466.     @cached_property</font>
<font color="black"> 467.     def many_to_many(self):</font>
<font color="black"> 468.         &quot;&quot;&quot;</font>
<font color="black"> 469.         Returns a list of all many to many fields on the model and its parents.</font>
<font color="black"> 470. </font>
<font color="black"> 471.         Private API intended only to be used by Django itself; get_fields()</font>
<font color="black"> 472.         combined with filtering of field properties is the public API for</font>
<font color="black"> 473.         obtaining this list.</font>
<font color="black"> 474.         &quot;&quot;&quot;</font>
<font color="green"> 475.         return make_immutable_fields_list(</font>
<font color="green"> 476.             &quot;many_to_many&quot;,</font>
<font color="green"> 477.             (f for f in self._get_fields(reverse=False)</font>
<font color="green"> 478.             if f.is_relation and f.many_to_many)</font>
<font color="black"> 479.         )</font>
<font color="black"> 480. </font>
<font color="green"> 481.     @cached_property</font>
<font color="black"> 482.     def related_objects(self):</font>
<font color="black"> 483.         &quot;&quot;&quot;</font>
<font color="black"> 484.         Returns all related objects pointing to the current model. The related</font>
<font color="black"> 485.         objects can come from a one-to-one, one-to-many, or many-to-many field</font>
<font color="black"> 486.         relation type.</font>
<font color="black"> 487. </font>
<font color="black"> 488.         Private API intended only to be used by Django itself; get_fields()</font>
<font color="black"> 489.         combined with filtering of field properties is the public API for</font>
<font color="black"> 490.         obtaining this field list.</font>
<font color="black"> 491.         &quot;&quot;&quot;</font>
<font color="red"> 492.         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)</font>
<font color="red"> 493.         return make_immutable_fields_list(</font>
<font color="red"> 494.             &quot;related_objects&quot;,</font>
<font color="red"> 495.             (obj for obj in all_related_fields</font>
<font color="red"> 496.             if not obj.hidden or obj.field.many_to_many)</font>
<font color="black"> 497.         )</font>
<font color="black"> 498. </font>
<font color="green"> 499.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="black"> 500.     def get_m2m_with_model(self):</font>
<font color="red"> 501.         return [self._map_model(f) for f in self.many_to_many]</font>
<font color="black"> 502. </font>
<font color="green"> 503.     @cached_property</font>
<font color="black"> 504.     def _forward_fields_map(self):</font>
<font color="green"> 505.         res = {}</font>
<font color="green"> 506.         fields = self._get_fields(reverse=False)</font>
<font color="green"> 507.         for field in fields:</font>
<font color="green"> 508.             res[field.name] = field</font>
<font color="black"> 509.             # Due to the way Django's internals work, get_field() should also</font>
<font color="black"> 510.             # be able to fetch a field by attname. In the case of a concrete</font>
<font color="black"> 511.             # field with relation, includes the *_id name too</font>
<font color="green"> 512.             try:</font>
<font color="green"> 513.                 res[field.attname] = field</font>
<font color="red"> 514.             except AttributeError:</font>
<font color="red"> 515.                 pass</font>
<font color="green"> 516.         return res</font>
<font color="black"> 517. </font>
<font color="green"> 518.     @cached_property</font>
<font color="black"> 519.     def fields_map(self):</font>
<font color="green"> 520.         res = {}</font>
<font color="green"> 521.         fields = self._get_fields(forward=False, include_hidden=True)</font>
<font color="green"> 522.         for field in fields:</font>
<font color="green"> 523.             res[field.name] = field</font>
<font color="black"> 524.             # Due to the way Django's internals work, get_field() should also</font>
<font color="black"> 525.             # be able to fetch a field by attname. In the case of a concrete</font>
<font color="black"> 526.             # field with relation, includes the *_id name too</font>
<font color="green"> 527.             try:</font>
<font color="green"> 528.                 res[field.attname] = field</font>
<font color="green"> 529.             except AttributeError:</font>
<font color="green"> 530.                 pass</font>
<font color="green"> 531.         return res</font>
<font color="black"> 532. </font>
<font color="green"> 533.     def get_field(self, field_name, many_to_many=None):</font>
<font color="black"> 534.         &quot;&quot;&quot;</font>
<font color="black"> 535.         Returns a field instance given a field name. The field can be either a</font>
<font color="black"> 536.         forward or reverse field, unless many_to_many is specified; if it is,</font>
<font color="black"> 537.         only forward fields will be returned.</font>
<font color="black"> 538. </font>
<font color="black"> 539.         The many_to_many argument exists for backwards compatibility reasons;</font>
<font color="black"> 540.         it has been deprecated and will be removed in Django 1.10.</font>
<font color="black"> 541.         &quot;&quot;&quot;</font>
<font color="green"> 542.         m2m_in_kwargs = many_to_many is not None</font>
<font color="green"> 543.         if m2m_in_kwargs:</font>
<font color="black"> 544.             # Always throw a warning if many_to_many is used regardless of</font>
<font color="black"> 545.             # whether it alters the return type or not.</font>
<font color="red"> 546.             warnings.warn(</font>
<font color="red"> 547.                 &quot;The 'many_to_many' argument on get_field() is deprecated; &quot;</font>
<font color="black"> 548.                 &quot;use a filter on field.many_to_many instead.&quot;,</font>
<font color="red"> 549.                 RemovedInDjango110Warning</font>
<font color="black"> 550.             )</font>
<font color="black"> 551. </font>
<font color="green"> 552.         try:</font>
<font color="black"> 553.             # In order to avoid premature loading of the relation tree</font>
<font color="black"> 554.             # (expensive) we prefer checking if the field is a forward field.</font>
<font color="green"> 555.             field = self._forward_fields_map[field_name]</font>
<font color="black"> 556. </font>
<font color="green"> 557.             if many_to_many is False and field.many_to_many:</font>
<font color="red"> 558.                 raise FieldDoesNotExist(</font>
<font color="red"> 559.                     '%s has no field named %r' % (self.object_name, field_name)</font>
<font color="black"> 560.                 )</font>
<font color="black"> 561. </font>
<font color="green"> 562.             return field</font>
<font color="green"> 563.         except KeyError:</font>
<font color="black"> 564.             # If the app registry is not ready, reverse fields are</font>
<font color="black"> 565.             # unavailable, therefore we throw a FieldDoesNotExist exception.</font>
<font color="green"> 566.             if not self.apps.models_ready:</font>
<font color="red"> 567.                 raise FieldDoesNotExist(</font>
<font color="red"> 568.                     &quot;%s has no field named %r. The app cache isn't ready yet, &quot;</font>
<font color="black"> 569.                     &quot;so if this is an auto-created related field, it won't &quot;</font>
<font color="red"> 570.                     &quot;be available yet.&quot; % (self.object_name, field_name)</font>
<font color="black"> 571.                 )</font>
<font color="black"> 572. </font>
<font color="green"> 573.         try:</font>
<font color="green"> 574.             if m2m_in_kwargs:</font>
<font color="black"> 575.                 # Previous API does not allow searching reverse fields.</font>
<font color="red"> 576.                 raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, field_name))</font>
<font color="black"> 577. </font>
<font color="black"> 578.             # Retrieve field instance by name from cached or just-computed</font>
<font color="black"> 579.             # field map.</font>
<font color="green"> 580.             return self.fields_map[field_name]</font>
<font color="green"> 581.         except KeyError:</font>
<font color="green"> 582.             raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, field_name))</font>
<font color="black"> 583. </font>
<font color="green"> 584.     @raise_deprecation(suggested_alternative=&quot;get_field()&quot;)</font>
<font color="black"> 585.     def get_field_by_name(self, name):</font>
<font color="red"> 586.         return self._map_model_details(self.get_field(name))</font>
<font color="black"> 587. </font>
<font color="green"> 588.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="black"> 589.     def get_all_field_names(self):</font>
<font color="red"> 590.         names = set()</font>
<font color="red"> 591.         fields = self.get_fields()</font>
<font color="red"> 592.         for field in fields:</font>
<font color="black"> 593.             # For backwards compatibility GenericForeignKey should not be</font>
<font color="black"> 594.             # included in the results.</font>
<font color="red"> 595.             if field.is_relation and field.many_to_one and field.related_model is None:</font>
<font color="red"> 596.                 continue</font>
<font color="black"> 597.             # Relations to child proxy models should not be included.</font>
<font color="red"> 598.             if (field.model != self.model and</font>
<font color="red"> 599.                     field.model._meta.concrete_model == self.concrete_model):</font>
<font color="red"> 600.                 continue</font>
<font color="black"> 601. </font>
<font color="red"> 602.             names.add(field.name)</font>
<font color="red"> 603.             if hasattr(field, 'attname'):</font>
<font color="red"> 604.                 names.add(field.attname)</font>
<font color="red"> 605.         return list(names)</font>
<font color="black"> 606. </font>
<font color="green"> 607.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="green"> 608.     def get_all_related_objects(self, local_only=False, include_hidden=False,</font>
<font color="green"> 609.                                 include_proxy_eq=False):</font>
<font color="black"> 610. </font>
<font color="red"> 611.         include_parents = True if local_only is False else PROXY_PARENTS</font>
<font color="red"> 612.         fields = self._get_fields(</font>
<font color="red"> 613.             forward=False, reverse=True,</font>
<font color="red"> 614.             include_parents=include_parents,</font>
<font color="red"> 615.             include_hidden=include_hidden,</font>
<font color="black"> 616.         )</font>
<font color="red"> 617.         fields = (obj for obj in fields if not isinstance(obj.field, ManyToManyField))</font>
<font color="red"> 618.         if include_proxy_eq:</font>
<font color="red"> 619.             children = chain.from_iterable(c._relation_tree</font>
<font color="red"> 620.                                            for c in self.concrete_model._meta.proxied_children</font>
<font color="red"> 621.                                            if c is not self)</font>
<font color="red"> 622.             relations = (f.remote_field for f in children</font>
<font color="red"> 623.                          if include_hidden or not f.remote_field.field.remote_field.is_hidden())</font>
<font color="red"> 624.             fields = chain(fields, relations)</font>
<font color="red"> 625.         return list(fields)</font>
<font color="black"> 626. </font>
<font color="green"> 627.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="green"> 628.     def get_all_related_objects_with_model(self, local_only=False, include_hidden=False,</font>
<font color="green"> 629.                                            include_proxy_eq=False):</font>
<font color="black"> 630.         return [</font>
<font color="red"> 631.             self._map_model(f) for f in self.get_all_related_objects(</font>
<font color="red"> 632.                 local_only=local_only,</font>
<font color="red"> 633.                 include_hidden=include_hidden,</font>
<font color="red"> 634.                 include_proxy_eq=include_proxy_eq,</font>
<font color="black"> 635.             )</font>
<font color="black"> 636.         ]</font>
<font color="black"> 637. </font>
<font color="green"> 638.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="green"> 639.     def get_all_related_many_to_many_objects(self, local_only=False):</font>
<font color="red"> 640.         include_parents = True if local_only is not True else PROXY_PARENTS</font>
<font color="red"> 641.         fields = self._get_fields(</font>
<font color="red"> 642.             forward=False, reverse=True,</font>
<font color="red"> 643.             include_parents=include_parents, include_hidden=True</font>
<font color="black"> 644.         )</font>
<font color="red"> 645.         return [obj for obj in fields if isinstance(obj.field, ManyToManyField)]</font>
<font color="black"> 646. </font>
<font color="green"> 647.     @raise_deprecation(suggested_alternative=&quot;get_fields()&quot;)</font>
<font color="black"> 648.     def get_all_related_m2m_objects_with_model(self):</font>
<font color="red"> 649.         fields = self._get_fields(forward=False, reverse=True, include_hidden=True)</font>
<font color="red"> 650.         return [self._map_model(obj) for obj in fields if isinstance(obj.field, ManyToManyField)]</font>
<font color="black"> 651. </font>
<font color="green"> 652.     def get_base_chain(self, model):</font>
<font color="black"> 653.         &quot;&quot;&quot;</font>
<font color="black"> 654.         Return a list of parent classes leading to `model` (ordered from</font>
<font color="black"> 655.         closest to most distant ancestor). This has to handle the case where</font>
<font color="black"> 656.         `model` is a grandparent or even more distant relation.</font>
<font color="black"> 657.         &quot;&quot;&quot;</font>
<font color="red"> 658.         if not self.parents:</font>
<font color="red"> 659.             return []</font>
<font color="red"> 660.         if model in self.parents:</font>
<font color="red"> 661.             return [model]</font>
<font color="red"> 662.         for parent in self.parents:</font>
<font color="red"> 663.             res = parent._meta.get_base_chain(model)</font>
<font color="red"> 664.             if res:</font>
<font color="red"> 665.                 res.insert(0, parent)</font>
<font color="red"> 666.                 return res</font>
<font color="red"> 667.         return []</font>
<font color="black"> 668. </font>
<font color="green"> 669.     def get_parent_list(self):</font>
<font color="black"> 670.         &quot;&quot;&quot;</font>
<font color="black"> 671.         Returns all the ancestors of this model as a list ordered by MRO.</font>
<font color="black"> 672.         Useful for determining if something is an ancestor, regardless of lineage.</font>
<font color="black"> 673.         &quot;&quot;&quot;</font>
<font color="green"> 674.         result = OrderedSet(self.parents)</font>
<font color="green"> 675.         for parent in self.parents:</font>
<font color="red"> 676.             for ancestor in parent._meta.get_parent_list():</font>
<font color="red"> 677.                 result.add(ancestor)</font>
<font color="green"> 678.         return list(result)</font>
<font color="black"> 679. </font>
<font color="green"> 680.     def get_ancestor_link(self, ancestor):</font>
<font color="black"> 681.         &quot;&quot;&quot;</font>
<font color="black"> 682.         Returns the field on the current model which points to the given</font>
<font color="black"> 683.         &quot;ancestor&quot;. This is possible an indirect link (a pointer to a parent</font>
<font color="black"> 684.         model, which points, eventually, to the ancestor). Used when</font>
<font color="black"> 685.         constructing table joins for model inheritance.</font>
<font color="black"> 686. </font>
<font color="black"> 687.         Returns None if the model isn't an ancestor of this one.</font>
<font color="black"> 688.         &quot;&quot;&quot;</font>
<font color="red"> 689.         if ancestor in self.parents:</font>
<font color="red"> 690.             return self.parents[ancestor]</font>
<font color="red"> 691.         for parent in self.parents:</font>
<font color="black"> 692.             # Tries to get a link field from the immediate parent</font>
<font color="red"> 693.             parent_link = parent._meta.get_ancestor_link(ancestor)</font>
<font color="red"> 694.             if parent_link:</font>
<font color="black"> 695.                 # In case of a proxied model, the first link</font>
<font color="black"> 696.                 # of the chain to the ancestor is that parent</font>
<font color="black"> 697.                 # links</font>
<font color="red"> 698.                 return self.parents[parent] or parent_link</font>
<font color="black"> 699. </font>
<font color="green"> 700.     def _populate_directed_relation_graph(self):</font>
<font color="black"> 701.         &quot;&quot;&quot;</font>
<font color="black"> 702.         This method is used by each model to find its reverse objects. As this</font>
<font color="black"> 703.         method is very expensive and is accessed frequently (it looks up every</font>
<font color="black"> 704.         field in a model, in every app), it is computed on first access and then</font>
<font color="black"> 705.         is set as a property on every model.</font>
<font color="black"> 706.         &quot;&quot;&quot;</font>
<font color="green"> 707.         related_objects_graph = defaultdict(list)</font>
<font color="black"> 708. </font>
<font color="green"> 709.         all_models = self.apps.get_models(include_auto_created=True)</font>
<font color="green"> 710.         for model in all_models:</font>
<font color="black"> 711.             # Abstract model's fields are copied to child models, hence we will</font>
<font color="black"> 712.             # see the fields from the child models.</font>
<font color="green"> 713.             if model._meta.abstract:</font>
<font color="red"> 714.                 continue</font>
<font color="black"> 715.             fields_with_relations = (</font>
<font color="green"> 716.                 f for f in model._meta._get_fields(reverse=False, include_parents=False)</font>
<font color="green"> 717.                 if f.is_relation and f.related_model is not None</font>
<font color="black"> 718.             )</font>
<font color="green"> 719.             for f in fields_with_relations:</font>
<font color="green"> 720.                 if not isinstance(f.remote_field.model, six.string_types):</font>
<font color="green"> 721.                     related_objects_graph[f.remote_field.model._meta].append(f)</font>
<font color="black"> 722. </font>
<font color="green"> 723.         for model in all_models:</font>
<font color="black"> 724.             # Set the relation_tree using the internal __dict__. In this way</font>
<font color="black"> 725.             # we avoid calling the cached property. In attribute lookup,</font>
<font color="black"> 726.             # __dict__ takes precedence over a data descriptor (such as</font>
<font color="black"> 727.             # @cached_property). This means that the _meta._relation_tree is</font>
<font color="black"> 728.             # only called if related_objects is not in __dict__.</font>
<font color="green"> 729.             related_objects = related_objects_graph[model._meta]</font>
<font color="green"> 730.             model._meta.__dict__['_relation_tree'] = related_objects</font>
<font color="black"> 731.         # It seems it is possible that self is not in all_models, so guard</font>
<font color="black"> 732.         # against that with default for get().</font>
<font color="green"> 733.         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)</font>
<font color="black"> 734. </font>
<font color="green"> 735.     @cached_property</font>
<font color="black"> 736.     def _relation_tree(self):</font>
<font color="green"> 737.         return self._populate_directed_relation_graph()</font>
<font color="black"> 738. </font>
<font color="green"> 739.     def _expire_cache(self, forward=True, reverse=True):</font>
<font color="black"> 740.         # This method is usually called by apps.cache_clear(), when the</font>
<font color="black"> 741.         # registry is finalized, or when a new field is added.</font>
<font color="green"> 742.         properties_to_expire = []</font>
<font color="green"> 743.         if forward:</font>
<font color="green"> 744.             properties_to_expire.extend(self.FORWARD_PROPERTIES)</font>
<font color="green"> 745.         if reverse and not self.abstract:</font>
<font color="green"> 746.             properties_to_expire.extend(self.REVERSE_PROPERTIES)</font>
<font color="black"> 747. </font>
<font color="green"> 748.         for cache_key in properties_to_expire:</font>
<font color="green"> 749.             try:</font>
<font color="green"> 750.                 delattr(self, cache_key)</font>
<font color="green"> 751.             except AttributeError:</font>
<font color="green"> 752.                 pass</font>
<font color="black"> 753. </font>
<font color="green"> 754.         self._get_fields_cache = {}</font>
<font color="black"> 755. </font>
<font color="green"> 756.     def get_fields(self, include_parents=True, include_hidden=False):</font>
<font color="black"> 757.         &quot;&quot;&quot;</font>
<font color="black"> 758.         Returns a list of fields associated to the model. By default, includes</font>
<font color="black"> 759.         forward and reverse fields, fields derived from inheritance, but not</font>
<font color="black"> 760.         hidden fields. The returned fields can be changed using the parameters:</font>
<font color="black"> 761. </font>
<font color="black"> 762.         - include_parents: include fields derived from inheritance</font>
<font color="black"> 763.         - include_hidden:  include fields that have a related_name that</font>
<font color="black"> 764.                            starts with a &quot;+&quot;</font>
<font color="black"> 765.         &quot;&quot;&quot;</font>
<font color="green"> 766.         if include_parents is False:</font>
<font color="red"> 767.             include_parents = PROXY_PARENTS</font>
<font color="green"> 768.         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)</font>
<font color="black"> 769. </font>
<font color="green"> 770.     def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False,</font>
<font color="green"> 771.                     seen_models=None):</font>
<font color="black"> 772.         &quot;&quot;&quot;</font>
<font color="black"> 773.         Internal helper function to return fields of the model.</font>
<font color="black"> 774.         * If forward=True, then fields defined on this model are returned.</font>
<font color="black"> 775.         * If reverse=True, then relations pointing to this model are returned.</font>
<font color="black"> 776.         * If include_hidden=True, then fields with is_hidden=True are returned.</font>
<font color="black"> 777.         * The include_parents argument toggles if fields from parent models</font>
<font color="black"> 778.           should be included. It has three values: True, False, and</font>
<font color="black"> 779.           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all</font>
<font color="black"> 780.           fields defined for the current model or any of its parents in the</font>
<font color="black"> 781.           parent chain to the model's concrete model.</font>
<font color="black"> 782.         &quot;&quot;&quot;</font>
<font color="green"> 783.         if include_parents not in (True, False, PROXY_PARENTS):</font>
<font color="red"> 784.             raise TypeError(&quot;Invalid argument for include_parents: %s&quot; % (include_parents,))</font>
<font color="black"> 785.         # This helper function is used to allow recursion in ``get_fields()``</font>
<font color="black"> 786.         # implementation and to provide a fast way for Django's internals to</font>
<font color="black"> 787.         # access specific subsets of fields.</font>
<font color="black"> 788. </font>
<font color="black"> 789.         # We must keep track of which models we have already seen. Otherwise we</font>
<font color="black"> 790.         # could include the same field multiple times from different models.</font>
<font color="green"> 791.         topmost_call = False</font>
<font color="green"> 792.         if seen_models is None:</font>
<font color="green"> 793.             seen_models = set()</font>
<font color="green"> 794.             topmost_call = True</font>
<font color="green"> 795.         seen_models.add(self.model)</font>
<font color="black"> 796. </font>
<font color="black"> 797.         # Creates a cache key composed of all arguments</font>
<font color="green"> 798.         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)</font>
<font color="black"> 799. </font>
<font color="green"> 800.         try:</font>
<font color="black"> 801.             # In order to avoid list manipulation. Always return a shallow copy</font>
<font color="black"> 802.             # of the results.</font>
<font color="green"> 803.             return self._get_fields_cache[cache_key]</font>
<font color="green"> 804.         except KeyError:</font>
<font color="green"> 805.             pass</font>
<font color="black"> 806. </font>
<font color="green"> 807.         fields = []</font>
<font color="black"> 808.         # Recursively call _get_fields() on each parent, with the same</font>
<font color="black"> 809.         # options provided in this call.</font>
<font color="green"> 810.         if include_parents is not False:</font>
<font color="green"> 811.             for parent in self.parents:</font>
<font color="black"> 812.                 # In diamond inheritance it is possible that we see the same</font>
<font color="black"> 813.                 # model from two different routes. In that case, avoid adding</font>
<font color="black"> 814.                 # fields from the same parent again.</font>
<font color="red"> 815.                 if parent in seen_models:</font>
<font color="red"> 816.                     continue</font>
<font color="red"> 817.                 if (parent._meta.concrete_model != self.concrete_model and</font>
<font color="red"> 818.                         include_parents == PROXY_PARENTS):</font>
<font color="red"> 819.                     continue</font>
<font color="red"> 820.                 for obj in parent._meta._get_fields(</font>
<font color="red"> 821.                         forward=forward, reverse=reverse, include_parents=include_parents,</font>
<font color="red"> 822.                         include_hidden=include_hidden, seen_models=seen_models):</font>
<font color="red"> 823.                     if hasattr(obj, 'parent_link') and obj.parent_link:</font>
<font color="red"> 824.                         continue</font>
<font color="red"> 825.                     fields.append(obj)</font>
<font color="green"> 826.         if reverse:</font>
<font color="black"> 827.             # Tree is computed once and cached until the app cache is expired.</font>
<font color="black"> 828.             # It is composed of a list of fields pointing to the current model</font>
<font color="black"> 829.             # from other models.</font>
<font color="green"> 830.             all_fields = self._relation_tree</font>
<font color="green"> 831.             for field in all_fields:</font>
<font color="black"> 832.                 # If hidden fields should be included or the relation is not</font>
<font color="black"> 833.                 # intentionally hidden, add to the fields dict.</font>
<font color="green"> 834.                 if include_hidden or not field.remote_field.hidden:</font>
<font color="green"> 835.                     fields.append(field.remote_field)</font>
<font color="black"> 836. </font>
<font color="green"> 837.         if forward:</font>
<font color="green"> 838.             fields.extend(</font>
<font color="green"> 839.                 field for field in chain(self.local_fields, self.local_many_to_many)</font>
<font color="black"> 840.             )</font>
<font color="black"> 841.             # Virtual fields are recopied to each child model, and they get a</font>
<font color="black"> 842.             # different model as field.model in each child. Hence we have to</font>
<font color="black"> 843.             # add the virtual fields separately from the topmost call. If we</font>
<font color="black"> 844.             # did this recursively similar to local_fields, we would get field</font>
<font color="black"> 845.             # instances with field.model != self.model.</font>
<font color="green"> 846.             if topmost_call:</font>
<font color="green"> 847.                 fields.extend(</font>
<font color="green"> 848.                     f for f in self.virtual_fields</font>
<font color="black"> 849.                 )</font>
<font color="black"> 850. </font>
<font color="black"> 851.         # In order to avoid list manipulation. Always</font>
<font color="black"> 852.         # return a shallow copy of the results</font>
<font color="green"> 853.         fields = make_immutable_fields_list(&quot;get_fields()&quot;, fields)</font>
<font color="black"> 854. </font>
<font color="black"> 855.         # Store result into cache for later access</font>
<font color="green"> 856.         self._get_fields_cache[cache_key] = fields</font>
<font color="green"> 857.         return fields</font>
</pre>

