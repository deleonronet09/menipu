source file: <b>/usr/lib/python2.7/StringIO.py</b><br>


file stats: <b>178 lines, 46 executed: 25.8% covered</b>
<pre>
<font color="black">   1. r&quot;&quot;&quot;File-like objects that read from or write to a string buffer.</font>
<font color="black">   2. </font>
<font color="black">   3. This implements (nearly) all stdio methods.</font>
<font color="black">   4. </font>
<font color="black">   5. f = StringIO()      # ready for writing</font>
<font color="black">   6. f = StringIO(buf)   # ready for reading</font>
<font color="black">   7. f.close()           # explicitly release resources held</font>
<font color="black">   8. flag = f.isatty()   # always false</font>
<font color="black">   9. pos = f.tell()      # get current position</font>
<font color="black">  10. f.seek(pos)         # set current position</font>
<font color="black">  11. f.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF</font>
<font color="black">  12. buf = f.read()      # read until EOF</font>
<font color="black">  13. buf = f.read(n)     # read up to n bytes</font>
<font color="black">  14. buf = f.readline()  # read until end of line ('\n') or EOF</font>
<font color="black">  15. list = f.readlines()# list of f.readline() results until EOF</font>
<font color="black">  16. f.truncate([size])  # truncate file at to at most size (default: current pos)</font>
<font color="black">  17. f.write(buf)        # write at current position</font>
<font color="black">  18. f.writelines(list)  # for line in list: f.write(line)</font>
<font color="black">  19. f.getvalue()        # return whole file's contents as a string</font>
<font color="black">  20. </font>
<font color="black">  21. Notes:</font>
<font color="black">  22. - Using a real file is often faster (but less convenient).</font>
<font color="black">  23. - There's also a much faster implementation in C, called cStringIO, but</font>
<font color="black">  24.   it's not subclassable.</font>
<font color="black">  25. - fileno() is left unimplemented so that code which uses it triggers</font>
<font color="black">  26.   an exception early.</font>
<font color="black">  27. - Seeking far beyond EOF and then writing will insert real null</font>
<font color="black">  28.   bytes that occupy space in the buffer.</font>
<font color="black">  29. - There's a simple test set (see end of this file).</font>
<font color="green">  30. &quot;&quot;&quot;</font>
<font color="green">  31. try:</font>
<font color="green">  32.     from errno import EINVAL</font>
<font color="red">  33. except ImportError:</font>
<font color="red">  34.     EINVAL = 22</font>
<font color="black">  35. </font>
<font color="green">  36. __all__ = [&quot;StringIO&quot;]</font>
<font color="black">  37. </font>
<font color="green">  38. def _complain_ifclosed(closed):</font>
<font color="green">  39.     if closed:</font>
<font color="red">  40.         raise ValueError, &quot;I/O operation on closed file&quot;</font>
<font color="black">  41. </font>
<font color="green">  42. class StringIO:</font>
<font color="black">  43.     &quot;&quot;&quot;class StringIO([buffer])</font>
<font color="black">  44. </font>
<font color="black">  45.     When a StringIO object is created, it can be initialized to an existing</font>
<font color="black">  46.     string by passing the string to the constructor. If no string is given,</font>
<font color="black">  47.     the StringIO will start empty.</font>
<font color="black">  48. </font>
<font color="black">  49.     The StringIO object can accept either Unicode or 8-bit strings, but</font>
<font color="black">  50.     mixing the two may take some care. If both are used, 8-bit strings that</font>
<font color="black">  51.     cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause</font>
<font color="black">  52.     a UnicodeError to be raised when getvalue() is called.</font>
<font color="green">  53.     &quot;&quot;&quot;</font>
<font color="green">  54.     def __init__(self, buf = ''):</font>
<font color="black">  55.         # Force self.buf to be a string or unicode</font>
<font color="green">  56.         if not isinstance(buf, basestring):</font>
<font color="red">  57.             buf = str(buf)</font>
<font color="green">  58.         self.buf = buf</font>
<font color="green">  59.         self.len = len(buf)</font>
<font color="green">  60.         self.buflist = []</font>
<font color="green">  61.         self.pos = 0</font>
<font color="green">  62.         self.closed = False</font>
<font color="green">  63.         self.softspace = 0</font>
<font color="black">  64. </font>
<font color="green">  65.     def __iter__(self):</font>
<font color="red">  66.         return self</font>
<font color="black">  67. </font>
<font color="green">  68.     def next(self):</font>
<font color="black">  69.         &quot;&quot;&quot;A file object is its own iterator, for example iter(f) returns f</font>
<font color="black">  70.         (unless f is closed). When a file is used as an iterator, typically</font>
<font color="black">  71.         in a for loop (for example, for line in f: print line), the next()</font>
<font color="black">  72.         method is called repeatedly. This method returns the next input line,</font>
<font color="black">  73.         or raises StopIteration when EOF is hit.</font>
<font color="black">  74.         &quot;&quot;&quot;</font>
<font color="red">  75.         _complain_ifclosed(self.closed)</font>
<font color="red">  76.         r = self.readline()</font>
<font color="red">  77.         if not r:</font>
<font color="red">  78.             raise StopIteration</font>
<font color="red">  79.         return r</font>
<font color="black">  80. </font>
<font color="green">  81.     def close(self):</font>
<font color="black">  82.         &quot;&quot;&quot;Free the memory buffer.</font>
<font color="black">  83.         &quot;&quot;&quot;</font>
<font color="red">  84.         if not self.closed:</font>
<font color="red">  85.             self.closed = True</font>
<font color="red">  86.             del self.buf, self.pos</font>
<font color="black">  87. </font>
<font color="green">  88.     def isatty(self):</font>
<font color="black">  89.         &quot;&quot;&quot;Returns False because StringIO objects are not connected to a</font>
<font color="black">  90.         tty-like device.</font>
<font color="black">  91.         &quot;&quot;&quot;</font>
<font color="red">  92.         _complain_ifclosed(self.closed)</font>
<font color="red">  93.         return False</font>
<font color="black">  94. </font>
<font color="green">  95.     def seek(self, pos, mode = 0):</font>
<font color="black">  96.         &quot;&quot;&quot;Set the file's current position.</font>
<font color="black">  97. </font>
<font color="black">  98.         The mode argument is optional and defaults to 0 (absolute file</font>
<font color="black">  99.         positioning); other values are 1 (seek relative to the current</font>
<font color="black"> 100.         position) and 2 (seek relative to the file's end).</font>
<font color="black"> 101. </font>
<font color="black"> 102.         There is no return value.</font>
<font color="black"> 103.         &quot;&quot;&quot;</font>
<font color="red"> 104.         _complain_ifclosed(self.closed)</font>
<font color="red"> 105.         if self.buflist:</font>
<font color="red"> 106.             self.buf += ''.join(self.buflist)</font>
<font color="red"> 107.             self.buflist = []</font>
<font color="red"> 108.         if mode == 1:</font>
<font color="red"> 109.             pos += self.pos</font>
<font color="red"> 110.         elif mode == 2:</font>
<font color="red"> 111.             pos += self.len</font>
<font color="red"> 112.         self.pos = max(0, pos)</font>
<font color="black"> 113. </font>
<font color="green"> 114.     def tell(self):</font>
<font color="black"> 115.         &quot;&quot;&quot;Return the file's current position.&quot;&quot;&quot;</font>
<font color="red"> 116.         _complain_ifclosed(self.closed)</font>
<font color="red"> 117.         return self.pos</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def read(self, n = -1):</font>
<font color="black"> 120.         &quot;&quot;&quot;Read at most size bytes from the file</font>
<font color="black"> 121.         (less if the read hits EOF before obtaining size bytes).</font>
<font color="black"> 122. </font>
<font color="black"> 123.         If the size argument is negative or omitted, read all data until EOF</font>
<font color="black"> 124.         is reached. The bytes are returned as a string object. An empty</font>
<font color="black"> 125.         string is returned when EOF is encountered immediately.</font>
<font color="black"> 126.         &quot;&quot;&quot;</font>
<font color="red"> 127.         _complain_ifclosed(self.closed)</font>
<font color="red"> 128.         if self.buflist:</font>
<font color="red"> 129.             self.buf += ''.join(self.buflist)</font>
<font color="red"> 130.             self.buflist = []</font>
<font color="red"> 131.         if n is None or n &lt; 0:</font>
<font color="red"> 132.             newpos = self.len</font>
<font color="black"> 133.         else:</font>
<font color="red"> 134.             newpos = min(self.pos+n, self.len)</font>
<font color="red"> 135.         r = self.buf[self.pos:newpos]</font>
<font color="red"> 136.         self.pos = newpos</font>
<font color="red"> 137.         return r</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def readline(self, length=None):</font>
<font color="black"> 140.         r&quot;&quot;&quot;Read one entire line from the file.</font>
<font color="black"> 141. </font>
<font color="black"> 142.         A trailing newline character is kept in the string (but may be absent</font>
<font color="black"> 143.         when a file ends with an incomplete line). If the size argument is</font>
<font color="black"> 144.         present and non-negative, it is a maximum byte count (including the</font>
<font color="black"> 145.         trailing newline) and an incomplete line may be returned.</font>
<font color="black"> 146. </font>
<font color="black"> 147.         An empty string is returned only when EOF is encountered immediately.</font>
<font color="black"> 148. </font>
<font color="black"> 149.         Note: Unlike stdio's fgets(), the returned string contains null</font>
<font color="black"> 150.         characters ('\0') if they occurred in the input.</font>
<font color="black"> 151.         &quot;&quot;&quot;</font>
<font color="red"> 152.         _complain_ifclosed(self.closed)</font>
<font color="red"> 153.         if self.buflist:</font>
<font color="red"> 154.             self.buf += ''.join(self.buflist)</font>
<font color="red"> 155.             self.buflist = []</font>
<font color="red"> 156.         i = self.buf.find('\n', self.pos)</font>
<font color="red"> 157.         if i &lt; 0:</font>
<font color="red"> 158.             newpos = self.len</font>
<font color="black"> 159.         else:</font>
<font color="red"> 160.             newpos = i+1</font>
<font color="red"> 161.         if length is not None and length &gt;= 0:</font>
<font color="red"> 162.             if self.pos + length &lt; newpos:</font>
<font color="red"> 163.                 newpos = self.pos + length</font>
<font color="red"> 164.         r = self.buf[self.pos:newpos]</font>
<font color="red"> 165.         self.pos = newpos</font>
<font color="red"> 166.         return r</font>
<font color="black"> 167. </font>
<font color="green"> 168.     def readlines(self, sizehint = 0):</font>
<font color="black"> 169.         &quot;&quot;&quot;Read until EOF using readline() and return a list containing the</font>
<font color="black"> 170.         lines thus read.</font>
<font color="black"> 171. </font>
<font color="black"> 172.         If the optional sizehint argument is present, instead of reading up</font>
<font color="black"> 173.         to EOF, whole lines totalling approximately sizehint bytes (or more</font>
<font color="black"> 174.         to accommodate a final whole line).</font>
<font color="black"> 175.         &quot;&quot;&quot;</font>
<font color="red"> 176.         total = 0</font>
<font color="red"> 177.         lines = []</font>
<font color="red"> 178.         line = self.readline()</font>
<font color="red"> 179.         while line:</font>
<font color="red"> 180.             lines.append(line)</font>
<font color="red"> 181.             total += len(line)</font>
<font color="red"> 182.             if 0 &lt; sizehint &lt;= total:</font>
<font color="red"> 183.                 break</font>
<font color="red"> 184.             line = self.readline()</font>
<font color="red"> 185.         return lines</font>
<font color="black"> 186. </font>
<font color="green"> 187.     def truncate(self, size=None):</font>
<font color="black"> 188.         &quot;&quot;&quot;Truncate the file's size.</font>
<font color="black"> 189. </font>
<font color="black"> 190.         If the optional size argument is present, the file is truncated to</font>
<font color="black"> 191.         (at most) that size. The size defaults to the current position.</font>
<font color="black"> 192.         The current file position is not changed unless the position</font>
<font color="black"> 193.         is beyond the new file size.</font>
<font color="black"> 194. </font>
<font color="black"> 195.         If the specified size exceeds the file's current size, the</font>
<font color="black"> 196.         file remains unchanged.</font>
<font color="black"> 197.         &quot;&quot;&quot;</font>
<font color="red"> 198.         _complain_ifclosed(self.closed)</font>
<font color="red"> 199.         if size is None:</font>
<font color="red"> 200.             size = self.pos</font>
<font color="red"> 201.         elif size &lt; 0:</font>
<font color="red"> 202.             raise IOError(EINVAL, &quot;Negative size not allowed&quot;)</font>
<font color="red"> 203.         elif size &lt; self.pos:</font>
<font color="red"> 204.             self.pos = size</font>
<font color="red"> 205.         self.buf = self.getvalue()[:size]</font>
<font color="red"> 206.         self.len = size</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def write(self, s):</font>
<font color="black"> 209.         &quot;&quot;&quot;Write a string to the file.</font>
<font color="black"> 210. </font>
<font color="black"> 211.         There is no return value.</font>
<font color="black"> 212.         &quot;&quot;&quot;</font>
<font color="green"> 213.         _complain_ifclosed(self.closed)</font>
<font color="green"> 214.         if not s: return</font>
<font color="black"> 215.         # Force s to be a string or unicode</font>
<font color="green"> 216.         if not isinstance(s, basestring):</font>
<font color="red"> 217.             s = str(s)</font>
<font color="green"> 218.         spos = self.pos</font>
<font color="green"> 219.         slen = self.len</font>
<font color="green"> 220.         if spos == slen:</font>
<font color="green"> 221.             self.buflist.append(s)</font>
<font color="green"> 222.             self.len = self.pos = spos + len(s)</font>
<font color="green"> 223.             return</font>
<font color="red"> 224.         if spos &gt; slen:</font>
<font color="red"> 225.             self.buflist.append('\0'*(spos - slen))</font>
<font color="red"> 226.             slen = spos</font>
<font color="red"> 227.         newpos = spos + len(s)</font>
<font color="red"> 228.         if spos &lt; slen:</font>
<font color="red"> 229.             if self.buflist:</font>
<font color="red"> 230.                 self.buf += ''.join(self.buflist)</font>
<font color="red"> 231.             self.buflist = [self.buf[:spos], s, self.buf[newpos:]]</font>
<font color="red"> 232.             self.buf = ''</font>
<font color="red"> 233.             if newpos &gt; slen:</font>
<font color="red"> 234.                 slen = newpos</font>
<font color="black"> 235.         else:</font>
<font color="red"> 236.             self.buflist.append(s)</font>
<font color="red"> 237.             slen = newpos</font>
<font color="red"> 238.         self.len = slen</font>
<font color="red"> 239.         self.pos = newpos</font>
<font color="black"> 240. </font>
<font color="green"> 241.     def writelines(self, iterable):</font>
<font color="black"> 242.         &quot;&quot;&quot;Write a sequence of strings to the file. The sequence can be any</font>
<font color="black"> 243.         iterable object producing strings, typically a list of strings. There</font>
<font color="black"> 244.         is no return value.</font>
<font color="black"> 245. </font>
<font color="black"> 246.         (The name is intended to match readlines(); writelines() does not add</font>
<font color="black"> 247.         line separators.)</font>
<font color="black"> 248.         &quot;&quot;&quot;</font>
<font color="red"> 249.         write = self.write</font>
<font color="red"> 250.         for line in iterable:</font>
<font color="red"> 251.             write(line)</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def flush(self):</font>
<font color="black"> 254.         &quot;&quot;&quot;Flush the internal buffer</font>
<font color="black"> 255.         &quot;&quot;&quot;</font>
<font color="red"> 256.         _complain_ifclosed(self.closed)</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def getvalue(self):</font>
<font color="black"> 259.         &quot;&quot;&quot;</font>
<font color="black"> 260.         Retrieve the entire contents of the &quot;file&quot; at any time before</font>
<font color="black"> 261.         the StringIO object's close() method is called.</font>
<font color="black"> 262. </font>
<font color="black"> 263.         The StringIO object can accept either Unicode or 8-bit strings,</font>
<font color="black"> 264.         but mixing the two may take some care. If both are used, 8-bit</font>
<font color="black"> 265.         strings that cannot be interpreted as 7-bit ASCII (that use the</font>
<font color="black"> 266.         8th bit) will cause a UnicodeError to be raised when getvalue()</font>
<font color="black"> 267.         is called.</font>
<font color="black"> 268.         &quot;&quot;&quot;</font>
<font color="green"> 269.         _complain_ifclosed(self.closed)</font>
<font color="green"> 270.         if self.buflist:</font>
<font color="green"> 271.             self.buf += ''.join(self.buflist)</font>
<font color="green"> 272.             self.buflist = []</font>
<font color="green"> 273.         return self.buf</font>
<font color="black"> 274. </font>
<font color="black"> 275. </font>
<font color="black"> 276. # A little test suite</font>
<font color="black"> 277. </font>
<font color="green"> 278. def test():</font>
<font color="red"> 279.     import sys</font>
<font color="red"> 280.     if sys.argv[1:]:</font>
<font color="red"> 281.         file = sys.argv[1]</font>
<font color="black"> 282.     else:</font>
<font color="red"> 283.         file = '/etc/passwd'</font>
<font color="red"> 284.     lines = open(file, 'r').readlines()</font>
<font color="red"> 285.     text = open(file, 'r').read()</font>
<font color="red"> 286.     f = StringIO()</font>
<font color="red"> 287.     for line in lines[:-2]:</font>
<font color="red"> 288.         f.write(line)</font>
<font color="red"> 289.     f.writelines(lines[-2:])</font>
<font color="red"> 290.     if f.getvalue() != text:</font>
<font color="red"> 291.         raise RuntimeError, 'write failed'</font>
<font color="red"> 292.     length = f.tell()</font>
<font color="red"> 293.     print 'File length =', length</font>
<font color="red"> 294.     f.seek(len(lines[0]))</font>
<font color="red"> 295.     f.write(lines[1])</font>
<font color="red"> 296.     f.seek(0)</font>
<font color="red"> 297.     print 'First line =', repr(f.readline())</font>
<font color="red"> 298.     print 'Position =', f.tell()</font>
<font color="red"> 299.     line = f.readline()</font>
<font color="red"> 300.     print 'Second line =', repr(line)</font>
<font color="red"> 301.     f.seek(-len(line), 1)</font>
<font color="red"> 302.     line2 = f.read(len(line))</font>
<font color="red"> 303.     if line != line2:</font>
<font color="red"> 304.         raise RuntimeError, 'bad result after seek back'</font>
<font color="red"> 305.     f.seek(len(line2), 1)</font>
<font color="red"> 306.     list = f.readlines()</font>
<font color="red"> 307.     line = list[-1]</font>
<font color="red"> 308.     f.seek(f.tell() - len(line))</font>
<font color="red"> 309.     line2 = f.read()</font>
<font color="red"> 310.     if line != line2:</font>
<font color="red"> 311.         raise RuntimeError, 'bad result after seek back from EOF'</font>
<font color="red"> 312.     print 'Read', len(list), 'more lines'</font>
<font color="red"> 313.     print 'File length =', f.tell()</font>
<font color="red"> 314.     if f.tell() != length:</font>
<font color="red"> 315.         raise RuntimeError, 'bad length'</font>
<font color="red"> 316.     f.truncate(length/2)</font>
<font color="red"> 317.     f.seek(0, 2)</font>
<font color="red"> 318.     print 'Truncated length =', f.tell()</font>
<font color="red"> 319.     if f.tell() != length/2:</font>
<font color="red"> 320.         raise RuntimeError, 'truncate did not adjust length'</font>
<font color="red"> 321.     f.close()</font>
<font color="black"> 322. </font>
<font color="green"> 323. if __name__ == '__main__':</font>
<font color="red"> 324.     test()</font>
</pre>

