source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/migrations/writer.py</b><br>


file stats: <b>373 lines, 49 executed: 13.1% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import collections</font>
<font color="green">   4. import datetime</font>
<font color="green">   5. import decimal</font>
<font color="green">   6. import functools</font>
<font color="green">   7. import math</font>
<font color="green">   8. import os</font>
<font color="green">   9. import re</font>
<font color="green">  10. import types</font>
<font color="green">  11. from importlib import import_module</font>
<font color="black">  12. </font>
<font color="green">  13. from django import get_version</font>
<font color="green">  14. from django.apps import apps</font>
<font color="green">  15. from django.db import migrations, models</font>
<font color="green">  16. from django.db.migrations.loader import MigrationLoader</font>
<font color="green">  17. from django.db.migrations.operations.base import Operation</font>
<font color="green">  18. from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject</font>
<font color="green">  19. from django.utils import datetime_safe, six</font>
<font color="green">  20. from django.utils._os import upath</font>
<font color="green">  21. from django.utils.encoding import force_text</font>
<font color="green">  22. from django.utils.functional import LazyObject, Promise</font>
<font color="green">  23. from django.utils.inspect import get_func_args</font>
<font color="green">  24. from django.utils.module_loading import module_dir</font>
<font color="green">  25. from django.utils.timezone import now, utc</font>
<font color="green">  26. from django.utils.version import get_docs_version</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. class SettingsReference(str):</font>
<font color="black">  30.     &quot;&quot;&quot;</font>
<font color="black">  31.     Special subclass of string which actually references a current settings</font>
<font color="black">  32.     value. It's treated as the value in memory, but serializes out to a</font>
<font color="black">  33.     settings.NAME attribute reference.</font>
<font color="green">  34.     &quot;&quot;&quot;</font>
<font color="black">  35. </font>
<font color="green">  36.     def __new__(self, value, setting_name):</font>
<font color="green">  37.         return str.__new__(self, value)</font>
<font color="black">  38. </font>
<font color="green">  39.     def __init__(self, value, setting_name):</font>
<font color="green">  40.         self.setting_name = setting_name</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. class OperationWriter(object):</font>
<font color="green">  44.     def __init__(self, operation, indentation=2):</font>
<font color="red">  45.         self.operation = operation</font>
<font color="red">  46.         self.buff = []</font>
<font color="red">  47.         self.indentation = indentation</font>
<font color="black">  48. </font>
<font color="green">  49.     def serialize(self):</font>
<font color="black">  50. </font>
<font color="red">  51.         def _write(_arg_name, _arg_value):</font>
<font color="red">  52.             if (_arg_name in self.operation.serialization_expand_args and</font>
<font color="red">  53.                     isinstance(_arg_value, (list, tuple, dict))):</font>
<font color="red">  54.                 if isinstance(_arg_value, dict):</font>
<font color="red">  55.                     self.feed('%s={' % _arg_name)</font>
<font color="red">  56.                     self.indent()</font>
<font color="red">  57.                     for key, value in _arg_value.items():</font>
<font color="red">  58.                         key_string, key_imports = MigrationWriter.serialize(key)</font>
<font color="red">  59.                         arg_string, arg_imports = MigrationWriter.serialize(value)</font>
<font color="red">  60.                         args = arg_string.splitlines()</font>
<font color="red">  61.                         if len(args) &gt; 1:</font>
<font color="red">  62.                             self.feed('%s: %s' % (key_string, args[0]))</font>
<font color="red">  63.                             for arg in args[1:-1]:</font>
<font color="red">  64.                                 self.feed(arg)</font>
<font color="red">  65.                             self.feed('%s,' % args[-1])</font>
<font color="black">  66.                         else:</font>
<font color="red">  67.                             self.feed('%s: %s,' % (key_string, arg_string))</font>
<font color="red">  68.                         imports.update(key_imports)</font>
<font color="red">  69.                         imports.update(arg_imports)</font>
<font color="red">  70.                     self.unindent()</font>
<font color="red">  71.                     self.feed('},')</font>
<font color="black">  72.                 else:</font>
<font color="red">  73.                     self.feed('%s=[' % _arg_name)</font>
<font color="red">  74.                     self.indent()</font>
<font color="red">  75.                     for item in _arg_value:</font>
<font color="red">  76.                         arg_string, arg_imports = MigrationWriter.serialize(item)</font>
<font color="red">  77.                         args = arg_string.splitlines()</font>
<font color="red">  78.                         if len(args) &gt; 1:</font>
<font color="red">  79.                             for arg in args[:-1]:</font>
<font color="red">  80.                                 self.feed(arg)</font>
<font color="red">  81.                             self.feed('%s,' % args[-1])</font>
<font color="black">  82.                         else:</font>
<font color="red">  83.                             self.feed('%s,' % arg_string)</font>
<font color="red">  84.                         imports.update(arg_imports)</font>
<font color="red">  85.                     self.unindent()</font>
<font color="red">  86.                     self.feed('],')</font>
<font color="black">  87.             else:</font>
<font color="red">  88.                 arg_string, arg_imports = MigrationWriter.serialize(_arg_value)</font>
<font color="red">  89.                 args = arg_string.splitlines()</font>
<font color="red">  90.                 if len(args) &gt; 1:</font>
<font color="red">  91.                     self.feed('%s=%s' % (_arg_name, args[0]))</font>
<font color="red">  92.                     for arg in args[1:-1]:</font>
<font color="red">  93.                         self.feed(arg)</font>
<font color="red">  94.                     self.feed('%s,' % args[-1])</font>
<font color="black">  95.                 else:</font>
<font color="red">  96.                     self.feed('%s=%s,' % (_arg_name, arg_string))</font>
<font color="red">  97.                 imports.update(arg_imports)</font>
<font color="black">  98. </font>
<font color="red">  99.         imports = set()</font>
<font color="red"> 100.         name, args, kwargs = self.operation.deconstruct()</font>
<font color="red"> 101.         operation_args = get_func_args(self.operation.__init__)</font>
<font color="black"> 102. </font>
<font color="black"> 103.         # See if this operation is in django.db.migrations. If it is,</font>
<font color="black"> 104.         # We can just use the fact we already have that imported,</font>
<font color="black"> 105.         # otherwise, we need to add an import for the operation class.</font>
<font color="red"> 106.         if getattr(migrations, name, None) == self.operation.__class__:</font>
<font color="red"> 107.             self.feed('migrations.%s(' % name)</font>
<font color="black"> 108.         else:</font>
<font color="red"> 109.             imports.add('import %s' % (self.operation.__class__.__module__))</font>
<font color="red"> 110.             self.feed('%s.%s(' % (self.operation.__class__.__module__, name))</font>
<font color="black"> 111. </font>
<font color="red"> 112.         self.indent()</font>
<font color="black"> 113. </font>
<font color="red"> 114.         for i, arg in enumerate(args):</font>
<font color="red"> 115.             arg_value = arg</font>
<font color="red"> 116.             arg_name = operation_args[i]</font>
<font color="red"> 117.             _write(arg_name, arg_value)</font>
<font color="black"> 118. </font>
<font color="red"> 119.         i = len(args)</font>
<font color="black"> 120.         # Only iterate over remaining arguments</font>
<font color="red"> 121.         for arg_name in operation_args[i:]:</font>
<font color="red"> 122.             if arg_name in kwargs:  # Don't sort to maintain signature order</font>
<font color="red"> 123.                 arg_value = kwargs[arg_name]</font>
<font color="red"> 124.                 _write(arg_name, arg_value)</font>
<font color="black"> 125. </font>
<font color="red"> 126.         self.unindent()</font>
<font color="red"> 127.         self.feed('),')</font>
<font color="red"> 128.         return self.render(), imports</font>
<font color="black"> 129. </font>
<font color="green"> 130.     def indent(self):</font>
<font color="red"> 131.         self.indentation += 1</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def unindent(self):</font>
<font color="red"> 134.         self.indentation -= 1</font>
<font color="black"> 135. </font>
<font color="green"> 136.     def feed(self, line):</font>
<font color="red"> 137.         self.buff.append(' ' * (self.indentation * 4) + line)</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def render(self):</font>
<font color="red"> 140.         return '\n'.join(self.buff)</font>
<font color="black"> 141. </font>
<font color="black"> 142. </font>
<font color="green"> 143. class MigrationWriter(object):</font>
<font color="black"> 144.     &quot;&quot;&quot;</font>
<font color="black"> 145.     Takes a Migration instance and is able to produce the contents</font>
<font color="black"> 146.     of the migration file from it.</font>
<font color="green"> 147.     &quot;&quot;&quot;</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def __init__(self, migration):</font>
<font color="red"> 150.         self.migration = migration</font>
<font color="red"> 151.         self.needs_manual_porting = False</font>
<font color="black"> 152. </font>
<font color="green"> 153.     def as_string(self):</font>
<font color="black"> 154.         &quot;&quot;&quot;</font>
<font color="black"> 155.         Returns a string of the file contents.</font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="red"> 157.         items = {</font>
<font color="red"> 158.             &quot;replaces_str&quot;: &quot;&quot;,</font>
<font color="red"> 159.             &quot;initial_str&quot;: &quot;&quot;,</font>
<font color="black"> 160.         }</font>
<font color="black"> 161. </font>
<font color="red"> 162.         imports = set()</font>
<font color="black"> 163. </font>
<font color="black"> 164.         # Deconstruct operations</font>
<font color="red"> 165.         operations = []</font>
<font color="red"> 166.         for operation in self.migration.operations:</font>
<font color="red"> 167.             operation_string, operation_imports = OperationWriter(operation).serialize()</font>
<font color="red"> 168.             imports.update(operation_imports)</font>
<font color="red"> 169.             operations.append(operation_string)</font>
<font color="red"> 170.         items[&quot;operations&quot;] = &quot;\n&quot;.join(operations) + &quot;\n&quot; if operations else &quot;&quot;</font>
<font color="black"> 171. </font>
<font color="black"> 172.         # Format dependencies and write out swappable dependencies right</font>
<font color="red"> 173.         dependencies = []</font>
<font color="red"> 174.         for dependency in self.migration.dependencies:</font>
<font color="red"> 175.             if dependency[0] == &quot;__setting__&quot;:</font>
<font color="red"> 176.                 dependencies.append(&quot;        migrations.swappable_dependency(settings.%s),&quot; % dependency[1])</font>
<font color="red"> 177.                 imports.add(&quot;from django.conf import settings&quot;)</font>
<font color="black"> 178.             else:</font>
<font color="black"> 179.                 # No need to output bytestrings for dependencies</font>
<font color="red"> 180.                 dependency = tuple(force_text(s) for s in dependency)</font>
<font color="red"> 181.                 dependencies.append(&quot;        %s,&quot; % self.serialize(dependency)[0])</font>
<font color="red"> 182.         items[&quot;dependencies&quot;] = &quot;\n&quot;.join(dependencies) + &quot;\n&quot; if dependencies else &quot;&quot;</font>
<font color="black"> 183. </font>
<font color="black"> 184.         # Format imports nicely, swapping imports of functions from migration files</font>
<font color="black"> 185.         # for comments</font>
<font color="red"> 186.         migration_imports = set()</font>
<font color="red"> 187.         for line in list(imports):</font>
<font color="red"> 188.             if re.match(&quot;^import (.*)\.\d+[^\s]*$&quot;, line):</font>
<font color="red"> 189.                 migration_imports.add(line.split(&quot;import&quot;)[1].strip())</font>
<font color="red"> 190.                 imports.remove(line)</font>
<font color="red"> 191.                 self.needs_manual_porting = True</font>
<font color="black"> 192. </font>
<font color="black"> 193.         # django.db.migrations is always used, but models import may not be.</font>
<font color="black"> 194.         # If models import exists, merge it with migrations import.</font>
<font color="red"> 195.         if &quot;from django.db import models&quot; in imports:</font>
<font color="red"> 196.             imports.discard(&quot;from django.db import models&quot;)</font>
<font color="red"> 197.             imports.add(&quot;from django.db import migrations, models&quot;)</font>
<font color="black"> 198.         else:</font>
<font color="red"> 199.             imports.add(&quot;from django.db import migrations&quot;)</font>
<font color="black"> 200. </font>
<font color="black"> 201.         # Sort imports by the package / module to be imported (the part after</font>
<font color="black"> 202.         # &quot;from&quot; in &quot;from ... import ...&quot; or after &quot;import&quot; in &quot;import ...&quot;).</font>
<font color="red"> 203.         sorted_imports = sorted(imports, key=lambda i: i.split()[1])</font>
<font color="red"> 204.         items[&quot;imports&quot;] = &quot;\n&quot;.join(sorted_imports) + &quot;\n&quot; if imports else &quot;&quot;</font>
<font color="red"> 205.         if migration_imports:</font>
<font color="red"> 206.             items[&quot;imports&quot;] += (</font>
<font color="red"> 207.                 &quot;\n\n# Functions from the following migrations need manual &quot;</font>
<font color="black"> 208.                 &quot;copying.\n# Move them and any dependencies into this file, &quot;</font>
<font color="black"> 209.                 &quot;then update the\n# RunPython operations to refer to the local &quot;</font>
<font color="black"> 210.                 &quot;versions:\n# %s&quot;</font>
<font color="red"> 211.             ) % &quot;\n# &quot;.join(sorted(migration_imports))</font>
<font color="black"> 212.         # If there's a replaces, make a string for it</font>
<font color="red"> 213.         if self.migration.replaces:</font>
<font color="red"> 214.             items['replaces_str'] = &quot;\n    replaces = %s\n&quot; % self.serialize(self.migration.replaces)[0]</font>
<font color="black"> 215.         # Hinting that goes into comment</font>
<font color="red"> 216.         items.update(</font>
<font color="red"> 217.             version=get_version(),</font>
<font color="red"> 218.             timestamp=now().strftime(&quot;%Y-%m-%d %H:%M&quot;),</font>
<font color="black"> 219.         )</font>
<font color="black"> 220. </font>
<font color="red"> 221.         if self.migration.initial:</font>
<font color="red"> 222.             items['initial_str'] = &quot;\n    initial = True\n&quot;</font>
<font color="black"> 223. </font>
<font color="red"> 224.         return (MIGRATION_TEMPLATE % items).encode(&quot;utf8&quot;)</font>
<font color="black"> 225. </font>
<font color="green"> 226.     @staticmethod</font>
<font color="black"> 227.     def serialize_datetime(value):</font>
<font color="black"> 228.         &quot;&quot;&quot;</font>
<font color="black"> 229.         Returns a serialized version of a datetime object that is valid,</font>
<font color="black"> 230.         executable python code. It converts timezone-aware values to utc with</font>
<font color="black"> 231.         an 'executable' utc representation of tzinfo.</font>
<font color="black"> 232.         &quot;&quot;&quot;</font>
<font color="red"> 233.         if value.tzinfo is not None and value.tzinfo != utc:</font>
<font color="red"> 234.             value = value.astimezone(utc)</font>
<font color="red"> 235.         value_repr = repr(value).replace(&quot;&lt;UTC&gt;&quot;, &quot;utc&quot;)</font>
<font color="red"> 236.         if isinstance(value, datetime_safe.datetime):</font>
<font color="red"> 237.             value_repr = &quot;datetime.%s&quot; % value_repr</font>
<font color="red"> 238.         return value_repr</font>
<font color="black"> 239. </font>
<font color="green"> 240.     @property</font>
<font color="black"> 241.     def basedir(self):</font>
<font color="red"> 242.         migrations_package_name = MigrationLoader.migrations_module(self.migration.app_label)</font>
<font color="black"> 243. </font>
<font color="red"> 244.         if migrations_package_name is None:</font>
<font color="red"> 245.             raise ValueError(</font>
<font color="red"> 246.                 &quot;Django can't create migrations for app '%s' because &quot;</font>
<font color="black"> 247.                 &quot;migrations have been disabled via the MIGRATION_MODULES &quot;</font>
<font color="red"> 248.                 &quot;setting.&quot; % self.migration.app_label</font>
<font color="black"> 249.             )</font>
<font color="black"> 250. </font>
<font color="black"> 251.         # See if we can import the migrations module directly</font>
<font color="red"> 252.         try:</font>
<font color="red"> 253.             migrations_module = import_module(migrations_package_name)</font>
<font color="red"> 254.         except ImportError:</font>
<font color="red"> 255.             pass</font>
<font color="black"> 256.         else:</font>
<font color="red"> 257.             try:</font>
<font color="red"> 258.                 return upath(module_dir(migrations_module))</font>
<font color="red"> 259.             except ValueError:</font>
<font color="red"> 260.                 pass</font>
<font color="black"> 261. </font>
<font color="black"> 262.         # Alright, see if it's a direct submodule of the app</font>
<font color="red"> 263.         app_config = apps.get_app_config(self.migration.app_label)</font>
<font color="red"> 264.         maybe_app_name, _, migrations_package_basename = migrations_package_name.rpartition(&quot;.&quot;)</font>
<font color="red"> 265.         if app_config.name == maybe_app_name:</font>
<font color="red"> 266.             return os.path.join(app_config.path, migrations_package_basename)</font>
<font color="black"> 267. </font>
<font color="black"> 268.         # In case of using MIGRATION_MODULES setting and the custom package</font>
<font color="black"> 269.         # doesn't exist, create one, starting from an existing package</font>
<font color="red"> 270.         existing_dirs, missing_dirs = migrations_package_name.split(&quot;.&quot;), []</font>
<font color="red"> 271.         while existing_dirs:</font>
<font color="red"> 272.             missing_dirs.insert(0, existing_dirs.pop(-1))</font>
<font color="red"> 273.             try:</font>
<font color="red"> 274.                 base_module = import_module(&quot;.&quot;.join(existing_dirs))</font>
<font color="red"> 275.             except ImportError:</font>
<font color="red"> 276.                 continue</font>
<font color="black"> 277.             else:</font>
<font color="red"> 278.                 try:</font>
<font color="red"> 279.                     base_dir = upath(module_dir(base_module))</font>
<font color="red"> 280.                 except ValueError:</font>
<font color="red"> 281.                     continue</font>
<font color="black"> 282.                 else:</font>
<font color="red"> 283.                     break</font>
<font color="black"> 284.         else:</font>
<font color="red"> 285.             raise ValueError(</font>
<font color="red"> 286.                 &quot;Could not locate an appropriate location to create &quot;</font>
<font color="black"> 287.                 &quot;migrations package %s. Make sure the toplevel &quot;</font>
<font color="black"> 288.                 &quot;package exists and can be imported.&quot; %</font>
<font color="red"> 289.                 migrations_package_name)</font>
<font color="black"> 290. </font>
<font color="red"> 291.         final_dir = os.path.join(base_dir, *missing_dirs)</font>
<font color="red"> 292.         if not os.path.isdir(final_dir):</font>
<font color="red"> 293.             os.makedirs(final_dir)</font>
<font color="red"> 294.         for missing_dir in missing_dirs:</font>
<font color="red"> 295.             base_dir = os.path.join(base_dir, missing_dir)</font>
<font color="red"> 296.             with open(os.path.join(base_dir, &quot;__init__.py&quot;), &quot;w&quot;):</font>
<font color="red"> 297.                 pass</font>
<font color="black"> 298. </font>
<font color="red"> 299.         return final_dir</font>
<font color="black"> 300. </font>
<font color="green"> 301.     @property</font>
<font color="black"> 302.     def filename(self):</font>
<font color="red"> 303.         return &quot;%s.py&quot; % self.migration.name</font>
<font color="black"> 304. </font>
<font color="green"> 305.     @property</font>
<font color="black"> 306.     def path(self):</font>
<font color="red"> 307.         return os.path.join(self.basedir, self.filename)</font>
<font color="black"> 308. </font>
<font color="green"> 309.     @classmethod</font>
<font color="black"> 310.     def serialize_deconstructed(cls, path, args, kwargs):</font>
<font color="red"> 311.         name, imports = cls._serialize_path(path)</font>
<font color="red"> 312.         strings = []</font>
<font color="red"> 313.         for arg in args:</font>
<font color="red"> 314.             arg_string, arg_imports = cls.serialize(arg)</font>
<font color="red"> 315.             strings.append(arg_string)</font>
<font color="red"> 316.             imports.update(arg_imports)</font>
<font color="red"> 317.         for kw, arg in sorted(kwargs.items()):</font>
<font color="red"> 318.             arg_string, arg_imports = cls.serialize(arg)</font>
<font color="red"> 319.             imports.update(arg_imports)</font>
<font color="red"> 320.             strings.append(&quot;%s=%s&quot; % (kw, arg_string))</font>
<font color="red"> 321.         return &quot;%s(%s)&quot; % (name, &quot;, &quot;.join(strings)), imports</font>
<font color="black"> 322. </font>
<font color="green"> 323.     @classmethod</font>
<font color="black"> 324.     def _serialize_path(cls, path):</font>
<font color="red"> 325.         module, name = path.rsplit(&quot;.&quot;, 1)</font>
<font color="red"> 326.         if module == &quot;django.db.models&quot;:</font>
<font color="red"> 327.             imports = {&quot;from django.db import models&quot;}</font>
<font color="red"> 328.             name = &quot;models.%s&quot; % name</font>
<font color="black"> 329.         else:</font>
<font color="red"> 330.             imports = {&quot;import %s&quot; % module}</font>
<font color="red"> 331.             name = path</font>
<font color="red"> 332.         return name, imports</font>
<font color="black"> 333. </font>
<font color="green"> 334.     @classmethod</font>
<font color="black"> 335.     def serialize(cls, value):</font>
<font color="black"> 336.         &quot;&quot;&quot;</font>
<font color="black"> 337.         Serializes the value to a string that's parsable by Python, along</font>
<font color="black"> 338.         with any needed imports to make that string work.</font>
<font color="black"> 339.         More advanced than repr() as it can encode things</font>
<font color="black"> 340.         like datetime.datetime.now.</font>
<font color="black"> 341.         &quot;&quot;&quot;</font>
<font color="black"> 342.         # FIXME: Ideally Promise would be reconstructible, but for now we</font>
<font color="black"> 343.         # use force_text on them and defer to the normal string serialization</font>
<font color="black"> 344.         # process.</font>
<font color="red"> 345.         if isinstance(value, Promise):</font>
<font color="red"> 346.             value = force_text(value)</font>
<font color="red"> 347.         elif isinstance(value, LazyObject):</font>
<font color="black"> 348.             # The unwrapped value is returned as the first item of the</font>
<font color="black"> 349.             # arguments tuple.</font>
<font color="red"> 350.             value = value.__reduce__()[1][0]</font>
<font color="black"> 351. </font>
<font color="black"> 352.         # Sequences</font>
<font color="red"> 353.         if isinstance(value, (frozenset, list, set, tuple)):</font>
<font color="red"> 354.             imports = set()</font>
<font color="red"> 355.             strings = []</font>
<font color="red"> 356.             for item in value:</font>
<font color="red"> 357.                 item_string, item_imports = cls.serialize(item)</font>
<font color="red"> 358.                 imports.update(item_imports)</font>
<font color="red"> 359.                 strings.append(item_string)</font>
<font color="red"> 360.             if isinstance(value, set):</font>
<font color="black"> 361.                 # Don't use the literal &quot;{%s}&quot; as it doesn't support empty set</font>
<font color="red"> 362.                 format = &quot;set([%s])&quot;</font>
<font color="red"> 363.             elif isinstance(value, frozenset):</font>
<font color="red"> 364.                 format = &quot;frozenset([%s])&quot;</font>
<font color="red"> 365.             elif isinstance(value, tuple):</font>
<font color="black"> 366.                 # When len(value)==0, the empty tuple should be serialized as</font>
<font color="black"> 367.                 # &quot;()&quot;, not &quot;(,)&quot; because (,) is invalid Python syntax.</font>
<font color="red"> 368.                 format = &quot;(%s)&quot; if len(value) != 1 else &quot;(%s,)&quot;</font>
<font color="black"> 369.             else:</font>
<font color="red"> 370.                 format = &quot;[%s]&quot;</font>
<font color="red"> 371.             return format % (&quot;, &quot;.join(strings)), imports</font>
<font color="black"> 372.         # Dictionaries</font>
<font color="red"> 373.         elif isinstance(value, dict):</font>
<font color="red"> 374.             imports = set()</font>
<font color="red"> 375.             strings = []</font>
<font color="red"> 376.             for k, v in sorted(value.items()):</font>
<font color="red"> 377.                 k_string, k_imports = cls.serialize(k)</font>
<font color="red"> 378.                 v_string, v_imports = cls.serialize(v)</font>
<font color="red"> 379.                 imports.update(k_imports)</font>
<font color="red"> 380.                 imports.update(v_imports)</font>
<font color="red"> 381.                 strings.append((k_string, v_string))</font>
<font color="red"> 382.             return &quot;{%s}&quot; % (&quot;, &quot;.join(&quot;%s: %s&quot; % (k, v) for k, v in strings)), imports</font>
<font color="black"> 383.         # Datetimes</font>
<font color="red"> 384.         elif isinstance(value, datetime.datetime):</font>
<font color="red"> 385.             value_repr = cls.serialize_datetime(value)</font>
<font color="red"> 386.             imports = [&quot;import datetime&quot;]</font>
<font color="red"> 387.             if value.tzinfo is not None:</font>
<font color="red"> 388.                 imports.append(&quot;from django.utils.timezone import utc&quot;)</font>
<font color="red"> 389.             return value_repr, set(imports)</font>
<font color="black"> 390.         # Dates</font>
<font color="red"> 391.         elif isinstance(value, datetime.date):</font>
<font color="red"> 392.             value_repr = repr(value)</font>
<font color="red"> 393.             if isinstance(value, datetime_safe.date):</font>
<font color="red"> 394.                 value_repr = &quot;datetime.%s&quot; % value_repr</font>
<font color="red"> 395.             return value_repr, {&quot;import datetime&quot;}</font>
<font color="black"> 396.         # Times</font>
<font color="red"> 397.         elif isinstance(value, datetime.time):</font>
<font color="red"> 398.             value_repr = repr(value)</font>
<font color="red"> 399.             if isinstance(value, datetime_safe.time):</font>
<font color="red"> 400.                 value_repr = &quot;datetime.%s&quot; % value_repr</font>
<font color="red"> 401.             return value_repr, {&quot;import datetime&quot;}</font>
<font color="black"> 402.         # Timedeltas</font>
<font color="red"> 403.         elif isinstance(value, datetime.timedelta):</font>
<font color="red"> 404.             return repr(value), {&quot;import datetime&quot;}</font>
<font color="black"> 405.         # Settings references</font>
<font color="red"> 406.         elif isinstance(value, SettingsReference):</font>
<font color="red"> 407.             return &quot;settings.%s&quot; % value.setting_name, {&quot;from django.conf import settings&quot;}</font>
<font color="black"> 408.         # Simple types</font>
<font color="red"> 409.         elif isinstance(value, float):</font>
<font color="red"> 410.             if math.isnan(value) or math.isinf(value):</font>
<font color="red"> 411.                 return 'float(&quot;{}&quot;)'.format(value), set()</font>
<font color="red"> 412.             return repr(value), set()</font>
<font color="red"> 413.         elif isinstance(value, six.integer_types + (bool, type(None))):</font>
<font color="red"> 414.             return repr(value), set()</font>
<font color="red"> 415.         elif isinstance(value, six.binary_type):</font>
<font color="red"> 416.             value_repr = repr(value)</font>
<font color="red"> 417.             if six.PY2:</font>
<font color="black"> 418.                 # Prepend the `b` prefix since we're importing unicode_literals</font>
<font color="red"> 419.                 value_repr = 'b' + value_repr</font>
<font color="red"> 420.             return value_repr, set()</font>
<font color="red"> 421.         elif isinstance(value, six.text_type):</font>
<font color="red"> 422.             value_repr = repr(value)</font>
<font color="red"> 423.             if six.PY2:</font>
<font color="black"> 424.                 # Strip the `u` prefix since we're importing unicode_literals</font>
<font color="red"> 425.                 value_repr = value_repr[1:]</font>
<font color="red"> 426.             return value_repr, set()</font>
<font color="black"> 427.         # Decimal</font>
<font color="red"> 428.         elif isinstance(value, decimal.Decimal):</font>
<font color="red"> 429.             return repr(value), {&quot;from decimal import Decimal&quot;}</font>
<font color="black"> 430.         # Django fields</font>
<font color="red"> 431.         elif isinstance(value, models.Field):</font>
<font color="red"> 432.             attr_name, path, args, kwargs = value.deconstruct()</font>
<font color="red"> 433.             return cls.serialize_deconstructed(path, args, kwargs)</font>
<font color="black"> 434.         # Classes</font>
<font color="red"> 435.         elif isinstance(value, type):</font>
<font color="black"> 436.             special_cases = [</font>
<font color="red"> 437.                 (models.Model, &quot;models.Model&quot;, []),</font>
<font color="black"> 438.             ]</font>
<font color="red"> 439.             for case, string, imports in special_cases:</font>
<font color="red"> 440.                 if case is value:</font>
<font color="red"> 441.                     return string, set(imports)</font>
<font color="red"> 442.             if hasattr(value, &quot;__module__&quot;):</font>
<font color="red"> 443.                 module = value.__module__</font>
<font color="red"> 444.                 if module == six.moves.builtins.__name__:</font>
<font color="red"> 445.                     return value.__name__, set()</font>
<font color="black"> 446.                 else:</font>
<font color="red"> 447.                     return &quot;%s.%s&quot; % (module, value.__name__), {&quot;import %s&quot; % module}</font>
<font color="red"> 448.         elif isinstance(value, models.manager.BaseManager):</font>
<font color="red"> 449.             as_manager, manager_path, qs_path, args, kwargs = value.deconstruct()</font>
<font color="red"> 450.             if as_manager:</font>
<font color="red"> 451.                 name, imports = cls._serialize_path(qs_path)</font>
<font color="red"> 452.                 return &quot;%s.as_manager()&quot; % name, imports</font>
<font color="black"> 453.             else:</font>
<font color="red"> 454.                 return cls.serialize_deconstructed(manager_path, args, kwargs)</font>
<font color="red"> 455.         elif isinstance(value, Operation):</font>
<font color="red"> 456.             string, imports = OperationWriter(value, indentation=0).serialize()</font>
<font color="black"> 457.             # Nested operation, trailing comma is handled in upper OperationWriter._write()</font>
<font color="red"> 458.             return string.rstrip(','), imports</font>
<font color="red"> 459.         elif isinstance(value, functools.partial):</font>
<font color="red"> 460.             imports = {'import functools'}</font>
<font color="black"> 461.             # Serialize functools.partial() arguments</font>
<font color="red"> 462.             func_string, func_imports = cls.serialize(value.func)</font>
<font color="red"> 463.             args_string, args_imports = cls.serialize(value.args)</font>
<font color="red"> 464.             keywords_string, keywords_imports = cls.serialize(value.keywords)</font>
<font color="black"> 465.             # Add any imports needed by arguments</font>
<font color="red"> 466.             imports.update(func_imports)</font>
<font color="red"> 467.             imports.update(args_imports)</font>
<font color="red"> 468.             imports.update(keywords_imports)</font>
<font color="black"> 469.             return (</font>
<font color="red"> 470.                 &quot;functools.partial(%s, *%s, **%s)&quot; % (</font>
<font color="red"> 471.                     func_string, args_string, keywords_string,</font>
<font color="black"> 472.                 ),</font>
<font color="red"> 473.                 imports,</font>
<font color="black"> 474.             )</font>
<font color="black"> 475.         # Anything that knows how to deconstruct itself.</font>
<font color="red"> 476.         elif hasattr(value, 'deconstruct'):</font>
<font color="red"> 477.             return cls.serialize_deconstructed(*value.deconstruct())</font>
<font color="black"> 478.         # Functions</font>
<font color="red"> 479.         elif isinstance(value, (types.FunctionType, types.BuiltinFunctionType)):</font>
<font color="black"> 480.             # @classmethod?</font>
<font color="red"> 481.             if getattr(value, &quot;__self__&quot;, None) and isinstance(value.__self__, type):</font>
<font color="red"> 482.                 klass = value.__self__</font>
<font color="red"> 483.                 module = klass.__module__</font>
<font color="red"> 484.                 return &quot;%s.%s.%s&quot; % (module, klass.__name__, value.__name__), {&quot;import %s&quot; % module}</font>
<font color="black"> 485.             # Further error checking</font>
<font color="red"> 486.             if value.__name__ == '&lt;lambda&gt;':</font>
<font color="red"> 487.                 raise ValueError(&quot;Cannot serialize function: lambda&quot;)</font>
<font color="red"> 488.             if value.__module__ is None:</font>
<font color="red"> 489.                 raise ValueError(&quot;Cannot serialize function %r: No module&quot; % value)</font>
<font color="black"> 490.             # Python 3 is a lot easier, and only uses this branch if it's not local.</font>
<font color="red"> 491.             if getattr(value, &quot;__qualname__&quot;, None) and getattr(value, &quot;__module__&quot;, None):</font>
<font color="red"> 492.                 if &quot;&lt;&quot; not in value.__qualname__:  # Qualname can include &lt;locals&gt;</font>
<font color="red"> 493.                     return &quot;%s.%s&quot; % (value.__module__, value.__qualname__), {&quot;import %s&quot; % value.__module__}</font>
<font color="black"> 494.             # Python 2/fallback version</font>
<font color="red"> 495.             module_name = value.__module__</font>
<font color="black"> 496.             # Make sure it's actually there and not an unbound method</font>
<font color="red"> 497.             module = import_module(module_name)</font>
<font color="red"> 498.             if not hasattr(module, value.__name__):</font>
<font color="red"> 499.                 raise ValueError(</font>
<font color="red"> 500.                     &quot;Could not find function %s in %s.\n&quot;</font>
<font color="black"> 501.                     &quot;Please note that due to Python 2 limitations, you cannot &quot;</font>
<font color="black"> 502.                     &quot;serialize unbound method functions (e.g. a method &quot;</font>
<font color="black"> 503.                     &quot;declared and used in the same class body). Please move &quot;</font>
<font color="black"> 504.                     &quot;the function into the main module body to use migrations.\n&quot;</font>
<font color="black"> 505.                     &quot;For more information, see &quot;</font>
<font color="black"> 506.                     &quot;https://docs.djangoproject.com/en/%s/topics/migrations/#serializing-values&quot;</font>
<font color="red"> 507.                     % (value.__name__, module_name, get_docs_version()))</font>
<font color="black"> 508.             # Needed on Python 2 only</font>
<font color="red"> 509.             if module_name == '__builtin__':</font>
<font color="red"> 510.                 return value.__name__, set()</font>
<font color="red"> 511.             return &quot;%s.%s&quot; % (module_name, value.__name__), {&quot;import %s&quot; % module_name}</font>
<font color="black"> 512.         # Other iterables</font>
<font color="red"> 513.         elif isinstance(value, collections.Iterable):</font>
<font color="red"> 514.             imports = set()</font>
<font color="red"> 515.             strings = []</font>
<font color="red"> 516.             for item in value:</font>
<font color="red"> 517.                 item_string, item_imports = cls.serialize(item)</font>
<font color="red"> 518.                 imports.update(item_imports)</font>
<font color="red"> 519.                 strings.append(item_string)</font>
<font color="black"> 520.             # When len(strings)==0, the empty iterable should be serialized as</font>
<font color="black"> 521.             # &quot;()&quot;, not &quot;(,)&quot; because (,) is invalid Python syntax.</font>
<font color="red"> 522.             format = &quot;(%s)&quot; if len(strings) != 1 else &quot;(%s,)&quot;</font>
<font color="red"> 523.             return format % (&quot;, &quot;.join(strings)), imports</font>
<font color="black"> 524.         # Compiled regex</font>
<font color="red"> 525.         elif isinstance(value, (COMPILED_REGEX_TYPE, RegexObject)):</font>
<font color="red"> 526.             imports = {&quot;import re&quot;}</font>
<font color="red"> 527.             regex_pattern, pattern_imports = cls.serialize(value.pattern)</font>
<font color="red"> 528.             regex_flags, flag_imports = cls.serialize(value.flags)</font>
<font color="red"> 529.             imports.update(pattern_imports)</font>
<font color="red"> 530.             imports.update(flag_imports)</font>
<font color="red"> 531.             args = [regex_pattern]</font>
<font color="red"> 532.             if value.flags:</font>
<font color="red"> 533.                 args.append(regex_flags)</font>
<font color="red"> 534.             return &quot;re.compile(%s)&quot; % ', '.join(args), imports</font>
<font color="black"> 535.         # Uh oh.</font>
<font color="black"> 536.         else:</font>
<font color="red"> 537.             raise ValueError(</font>
<font color="red"> 538.                 &quot;Cannot serialize: %r\nThere are some values Django cannot serialize into &quot;</font>
<font color="black"> 539.                 &quot;migration files.\nFor more, see https://docs.djangoproject.com/en/%s/&quot;</font>
<font color="red"> 540.                 &quot;topics/migrations/#migration-serializing&quot; % (value, get_docs_version())</font>
<font color="black"> 541.             )</font>
<font color="black"> 542. </font>
<font color="black"> 543. </font>
<font color="black"> 544. MIGRATION_TEMPLATE = &quot;&quot;&quot;\</font>
<font color="black"> 545. # -*- coding: utf-8 -*-</font>
<font color="black"> 546. # Generated by Django %(version)s on %(timestamp)s</font>
<font color="black"> 547. from __future__ import unicode_literals</font>
<font color="black"> 548. </font>
<font color="black"> 549. %(imports)s</font>
<font color="black"> 550. </font>
<font color="black"> 551. class Migration(migrations.Migration):</font>
<font color="black"> 552. %(replaces_str)s%(initial_str)s</font>
<font color="black"> 553.     dependencies = [</font>
<font color="black"> 554. %(dependencies)s\</font>
<font color="black"> 555.     ]</font>
<font color="black"> 556. </font>
<font color="black"> 557.     operations = [</font>
<font color="black"> 558. %(operations)s\</font>
<font color="black"> 559.     ]</font>
<font color="green"> 560. &quot;&quot;&quot;</font>
</pre>

