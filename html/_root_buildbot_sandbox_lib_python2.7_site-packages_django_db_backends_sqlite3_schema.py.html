source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/sqlite3/schema.py</b><br>


file stats: <b>161 lines, 95 executed: 59.0% covered</b>
<pre>
<font color="green">   1. import codecs</font>
<font color="green">   2. import contextlib</font>
<font color="green">   3. import copy</font>
<font color="green">   4. from decimal import Decimal</font>
<font color="black">   5. </font>
<font color="green">   6. from django.apps.registry import Apps</font>
<font color="green">   7. from django.db.backends.base.schema import BaseDatabaseSchemaEditor</font>
<font color="green">   8. from django.utils import six</font>
<font color="black">   9. </font>
<font color="black">  10. </font>
<font color="green">  11. class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):</font>
<font color="black">  12. </font>
<font color="green">  13.     sql_delete_table = &quot;DROP TABLE %(table)s&quot;</font>
<font color="green">  14.     sql_create_inline_fk = &quot;REFERENCES %(to_table)s (%(to_column)s)&quot;</font>
<font color="green">  15.     sql_create_unique = &quot;CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)&quot;</font>
<font color="green">  16.     sql_delete_unique = &quot;DROP INDEX %(name)s&quot;</font>
<font color="black">  17. </font>
<font color="green">  18.     def __enter__(self):</font>
<font color="green">  19.         with self.connection.cursor() as c:</font>
<font color="black">  20.             # Some SQLite schema alterations need foreign key constraints to be</font>
<font color="black">  21.             # disabled. This is the default in SQLite but can be changed with a</font>
<font color="black">  22.             # build flag and might change in future, so can't be relied upon.</font>
<font color="black">  23.             # We enforce it here for the duration of the transaction.</font>
<font color="green">  24.             c.execute('PRAGMA foreign_keys')</font>
<font color="green">  25.             self._initial_pragma_fk = c.fetchone()[0]</font>
<font color="green">  26.             c.execute('PRAGMA foreign_keys = 0')</font>
<font color="green">  27.         return super(DatabaseSchemaEditor, self).__enter__()</font>
<font color="black">  28. </font>
<font color="green">  29.     def __exit__(self, exc_type, exc_value, traceback):</font>
<font color="green">  30.         super(DatabaseSchemaEditor, self).__exit__(exc_type, exc_value, traceback)</font>
<font color="green">  31.         with self.connection.cursor() as c:</font>
<font color="black">  32.             # Restore initial FK setting - PRAGMA values can't be parametrized</font>
<font color="green">  33.             c.execute('PRAGMA foreign_keys = %s' % int(self._initial_pragma_fk))</font>
<font color="black">  34. </font>
<font color="green">  35.     def quote_value(self, value):</font>
<font color="black">  36.         # The backend &quot;mostly works&quot; without this function and there are use</font>
<font color="black">  37.         # cases for compiling Python without the sqlite3 libraries (e.g.</font>
<font color="black">  38.         # security hardening).</font>
<font color="red">  39.         import sqlite3</font>
<font color="red">  40.         try:</font>
<font color="red">  41.             value = sqlite3.adapt(value)</font>
<font color="red">  42.         except sqlite3.ProgrammingError:</font>
<font color="red">  43.             pass</font>
<font color="black">  44.         # Manual emulation of SQLite parameter quoting</font>
<font color="red">  45.         if isinstance(value, type(True)):</font>
<font color="red">  46.             return str(int(value))</font>
<font color="red">  47.         elif isinstance(value, (Decimal, float)):</font>
<font color="red">  48.             return str(value)</font>
<font color="red">  49.         elif isinstance(value, six.integer_types):</font>
<font color="red">  50.             return str(value)</font>
<font color="red">  51.         elif isinstance(value, six.string_types):</font>
<font color="red">  52.             return &quot;'%s'&quot; % six.text_type(value).replace(&quot;\'&quot;, &quot;\'\'&quot;)</font>
<font color="red">  53.         elif value is None:</font>
<font color="red">  54.             return &quot;NULL&quot;</font>
<font color="red">  55.         elif isinstance(value, (bytes, bytearray, six.memoryview)):</font>
<font color="black">  56.             # Bytes are only allowed for BLOB fields, encoded as string</font>
<font color="black">  57.             # literals containing hexadecimal data and preceded by a single &quot;X&quot;</font>
<font color="black">  58.             # character:</font>
<font color="black">  59.             # value = b'\x01\x02' =&gt; value_hex = b'0102' =&gt; return X'0102'</font>
<font color="red">  60.             value = bytes(value)</font>
<font color="red">  61.             hex_encoder = codecs.getencoder('hex_codec')</font>
<font color="red">  62.             value_hex, _length = hex_encoder(value)</font>
<font color="black">  63.             # Use 'ascii' encoding for b'01' =&gt; '01', no need to use force_text here.</font>
<font color="red">  64.             return &quot;X'%s'&quot; % value_hex.decode('ascii')</font>
<font color="black">  65.         else:</font>
<font color="red">  66.             raise ValueError(&quot;Cannot quote parameter value %r of type %s&quot; % (value, type(value)))</font>
<font color="black">  67. </font>
<font color="green">  68.     def _remake_table(self, model, create_fields=[], delete_fields=[], alter_fields=[], override_uniques=None,</font>
<font color="green">  69.                       override_indexes=None):</font>
<font color="black">  70.         &quot;&quot;&quot;</font>
<font color="black">  71.         Shortcut to transform a model from old_model into new_model</font>
<font color="black">  72. </font>
<font color="black">  73.         The essential steps are:</font>
<font color="black">  74.           1. rename the model's existing table, e.g. &quot;app_model&quot; to &quot;app_model__old&quot;</font>
<font color="black">  75.           2. create a table with the updated definition called &quot;app_model&quot;</font>
<font color="black">  76.           3. copy the data from the old renamed table to the new table</font>
<font color="black">  77.           4. delete the &quot;app_model__old&quot; table</font>
<font color="black">  78.         &quot;&quot;&quot;</font>
<font color="black">  79.         # Work out the new fields dict / mapping</font>
<font color="green">  80.         body = {f.name: f for f in model._meta.local_concrete_fields}</font>
<font color="black">  81.         # Since mapping might mix column names and default values,</font>
<font color="black">  82.         # its values must be already quoted.</font>
<font color="green">  83.         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}</font>
<font color="black">  84.         # This maps field names (not columns) for things like unique_together</font>
<font color="green">  85.         rename_mapping = {}</font>
<font color="black">  86.         # If any of the new or altered fields is introducing a new PK,</font>
<font color="black">  87.         # remove the old one</font>
<font color="green">  88.         restore_pk_field = None</font>
<font color="green">  89.         if any(f.primary_key for f in create_fields) or any(n.primary_key for o, n in alter_fields):</font>
<font color="red">  90.             for name, field in list(body.items()):</font>
<font color="red">  91.                 if field.primary_key:</font>
<font color="red">  92.                     field.primary_key = False</font>
<font color="red">  93.                     restore_pk_field = field</font>
<font color="red">  94.                     if field.auto_created:</font>
<font color="red">  95.                         del body[name]</font>
<font color="red">  96.                         del mapping[field.column]</font>
<font color="black">  97.         # Add in any created fields</font>
<font color="green">  98.         for field in create_fields:</font>
<font color="red">  99.             body[field.name] = field</font>
<font color="black"> 100.             # Choose a default and insert it into the copy map</font>
<font color="red"> 101.             if not field.many_to_many and field.concrete:</font>
<font color="red"> 102.                 mapping[field.column] = self.quote_value(</font>
<font color="red"> 103.                     self.effective_default(field)</font>
<font color="black"> 104.                 )</font>
<font color="black"> 105.         # Add in any altered fields</font>
<font color="green"> 106.         for (old_field, new_field) in alter_fields:</font>
<font color="green"> 107.             body.pop(old_field.name, None)</font>
<font color="green"> 108.             mapping.pop(old_field.column, None)</font>
<font color="green"> 109.             body[new_field.name] = new_field</font>
<font color="green"> 110.             if old_field.null and not new_field.null:</font>
<font color="red"> 111.                 case_sql = &quot;coalesce(%(col)s, %(default)s)&quot; % {</font>
<font color="red"> 112.                     'col': self.quote_name(old_field.column),</font>
<font color="red"> 113.                     'default': self.quote_value(self.effective_default(new_field))</font>
<font color="black"> 114.                 }</font>
<font color="red"> 115.                 mapping[new_field.column] = case_sql</font>
<font color="black"> 116.             else:</font>
<font color="green"> 117.                 mapping[new_field.column] = self.quote_name(old_field.column)</font>
<font color="green"> 118.             rename_mapping[old_field.name] = new_field.name</font>
<font color="black"> 119.         # Remove any deleted fields</font>
<font color="green"> 120.         for field in delete_fields:</font>
<font color="green"> 121.             del body[field.name]</font>
<font color="green"> 122.             del mapping[field.column]</font>
<font color="black"> 123.             # Remove any implicit M2M tables</font>
<font color="green"> 124.             if field.many_to_many and field.remote_field.through._meta.auto_created:</font>
<font color="red"> 125.                 return self.delete_model(field.remote_field.through)</font>
<font color="black"> 126.         # Work inside a new app registry</font>
<font color="green"> 127.         apps = Apps()</font>
<font color="black"> 128. </font>
<font color="black"> 129.         # Provide isolated instances of the fields to the new model body so</font>
<font color="black"> 130.         # that the existing model's internals aren't interfered with when</font>
<font color="black"> 131.         # the dummy model is constructed.</font>
<font color="green"> 132.         body = copy.deepcopy(body)</font>
<font color="black"> 133. </font>
<font color="black"> 134.         # Work out the new value of unique_together, taking renames into</font>
<font color="black"> 135.         # account</font>
<font color="green"> 136.         if override_uniques is None:</font>
<font color="black"> 137.             override_uniques = [</font>
<font color="green"> 138.                 [rename_mapping.get(n, n) for n in unique]</font>
<font color="green"> 139.                 for unique in model._meta.unique_together</font>
<font color="black"> 140.             ]</font>
<font color="black"> 141. </font>
<font color="black"> 142.         # Work out the new value for index_together, taking renames into</font>
<font color="black"> 143.         # account</font>
<font color="green"> 144.         if override_indexes is None:</font>
<font color="black"> 145.             override_indexes = [</font>
<font color="green"> 146.                 [rename_mapping.get(n, n) for n in index]</font>
<font color="green"> 147.                 for index in model._meta.index_together</font>
<font color="black"> 148.             ]</font>
<font color="black"> 149. </font>
<font color="black"> 150.         # Construct a new model for the new state</font>
<font color="green"> 151.         meta_contents = {</font>
<font color="green"> 152.             'app_label': model._meta.app_label,</font>
<font color="green"> 153.             'db_table': model._meta.db_table,</font>
<font color="green"> 154.             'unique_together': override_uniques,</font>
<font color="green"> 155.             'index_together': override_indexes,</font>
<font color="green"> 156.             'apps': apps,</font>
<font color="black"> 157.         }</font>
<font color="green"> 158.         meta = type(&quot;Meta&quot;, tuple(), meta_contents)</font>
<font color="green"> 159.         body['Meta'] = meta</font>
<font color="green"> 160.         body['__module__'] = model.__module__</font>
<font color="black"> 161. </font>
<font color="green"> 162.         temp_model = type(model._meta.object_name, model.__bases__, body)</font>
<font color="black"> 163. </font>
<font color="black"> 164.         # We need to modify model._meta.db_table, but everything explodes</font>
<font color="black"> 165.         # if the change isn't reversed before the end of this method. This</font>
<font color="black"> 166.         # context manager helps us avoid that situation.</font>
<font color="green"> 167.         @contextlib.contextmanager</font>
<font color="black"> 168.         def altered_table_name(model, temporary_table_name):</font>
<font color="green"> 169.             original_table_name = model._meta.db_table</font>
<font color="green"> 170.             model._meta.db_table = temporary_table_name</font>
<font color="green"> 171.             yield</font>
<font color="green"> 172.             model._meta.db_table = original_table_name</font>
<font color="black"> 173. </font>
<font color="green"> 174.         with altered_table_name(model, model._meta.db_table + &quot;__old&quot;):</font>
<font color="black"> 175.             # Rename the old table to make way for the new</font>
<font color="green"> 176.             self.alter_db_table(model, temp_model._meta.db_table, model._meta.db_table)</font>
<font color="black"> 177. </font>
<font color="black"> 178.             # Create a new table with the updated schema. We remove things</font>
<font color="black"> 179.             # from the deferred SQL that match our table name, too</font>
<font color="green"> 180.             self.deferred_sql = [x for x in self.deferred_sql if temp_model._meta.db_table not in x]</font>
<font color="green"> 181.             self.create_model(temp_model)</font>
<font color="black"> 182. </font>
<font color="black"> 183.             # Copy data from the old table into the new table</font>
<font color="green"> 184.             field_maps = list(mapping.items())</font>
<font color="green"> 185.             self.execute(&quot;INSERT INTO %s (%s) SELECT %s FROM %s&quot; % (</font>
<font color="green"> 186.                 self.quote_name(temp_model._meta.db_table),</font>
<font color="green"> 187.                 ', '.join(self.quote_name(x) for x, y in field_maps),</font>
<font color="green"> 188.                 ', '.join(y for x, y in field_maps),</font>
<font color="green"> 189.                 self.quote_name(model._meta.db_table),</font>
<font color="black"> 190.             ))</font>
<font color="black"> 191. </font>
<font color="black"> 192.             # Delete the old table</font>
<font color="green"> 193.             self.delete_model(model, handle_autom2m=False)</font>
<font color="black"> 194. </font>
<font color="black"> 195.         # Run deferred SQL on correct table</font>
<font color="green"> 196.         for sql in self.deferred_sql:</font>
<font color="green"> 197.             self.execute(sql)</font>
<font color="green"> 198.         self.deferred_sql = []</font>
<font color="black"> 199.         # Fix any PK-removed field</font>
<font color="green"> 200.         if restore_pk_field:</font>
<font color="red"> 201.             restore_pk_field.primary_key = True</font>
<font color="black"> 202. </font>
<font color="green"> 203.     def delete_model(self, model, handle_autom2m=True):</font>
<font color="green"> 204.         if handle_autom2m:</font>
<font color="red"> 205.             super(DatabaseSchemaEditor, self).delete_model(model)</font>
<font color="black"> 206.         else:</font>
<font color="black"> 207.             # Delete the table (and only that)</font>
<font color="green"> 208.             self.execute(self.sql_delete_table % {</font>
<font color="green"> 209.                 &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="black"> 210.             })</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def add_field(self, model, field):</font>
<font color="black"> 213.         &quot;&quot;&quot;</font>
<font color="black"> 214.         Creates a field on a model.</font>
<font color="black"> 215.         Usually involves adding a column, but may involve adding a</font>
<font color="black"> 216.         table instead (for M2M fields)</font>
<font color="black"> 217.         &quot;&quot;&quot;</font>
<font color="black"> 218.         # Special-case implicit M2M tables</font>
<font color="red"> 219.         if field.many_to_many and field.remote_field.through._meta.auto_created:</font>
<font color="red"> 220.             return self.create_model(field.remote_field.through)</font>
<font color="red"> 221.         self._remake_table(model, create_fields=[field])</font>
<font color="black"> 222. </font>
<font color="green"> 223.     def remove_field(self, model, field):</font>
<font color="black"> 224.         &quot;&quot;&quot;</font>
<font color="black"> 225.         Removes a field from a model. Usually involves deleting a column,</font>
<font color="black"> 226.         but for M2Ms may involve deleting a table.</font>
<font color="black"> 227.         &quot;&quot;&quot;</font>
<font color="black"> 228.         # M2M fields are a special case</font>
<font color="green"> 229.         if field.many_to_many:</font>
<font color="black"> 230.             # For implicit M2M tables, delete the auto-created table</font>
<font color="red"> 231.             if field.remote_field.through._meta.auto_created:</font>
<font color="red"> 232.                 self.delete_model(field.remote_field.through)</font>
<font color="black"> 233.             # For explicit &quot;through&quot; M2M fields, do nothing</font>
<font color="black"> 234.         # For everything else, remake.</font>
<font color="black"> 235.         else:</font>
<font color="black"> 236.             # It might not actually have a column behind it</font>
<font color="green"> 237.             if field.db_parameters(connection=self.connection)['type'] is None:</font>
<font color="red"> 238.                 return</font>
<font color="green"> 239.             self._remake_table(model, delete_fields=[field])</font>
<font color="black"> 240. </font>
<font color="black"> 241.     def _alter_field(self, model, old_field, new_field, old_type, new_type,</font>
<font color="green"> 242.                      old_db_params, new_db_params, strict=False):</font>
<font color="black"> 243.         &quot;&quot;&quot;Actually perform a &quot;physical&quot; (non-ManyToMany) field update.&quot;&quot;&quot;</font>
<font color="black"> 244.         # Alter by remaking table</font>
<font color="green"> 245.         self._remake_table(model, alter_fields=[(old_field, new_field)])</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def alter_index_together(self, model, old_index_together, new_index_together):</font>
<font color="black"> 248.         &quot;&quot;&quot;</font>
<font color="black"> 249.         Deals with a model changing its index_together.</font>
<font color="black"> 250.         Note: The input index_togethers must be doubly-nested, not the single-</font>
<font color="black"> 251.         nested [&quot;foo&quot;, &quot;bar&quot;] format.</font>
<font color="black"> 252.         &quot;&quot;&quot;</font>
<font color="red"> 253.         self._remake_table(model, override_indexes=new_index_together)</font>
<font color="black"> 254. </font>
<font color="green"> 255.     def alter_unique_together(self, model, old_unique_together, new_unique_together):</font>
<font color="black"> 256.         &quot;&quot;&quot;</font>
<font color="black"> 257.         Deals with a model changing its unique_together.</font>
<font color="black"> 258.         Note: The input unique_togethers must be doubly-nested, not the single-</font>
<font color="black"> 259.         nested [&quot;foo&quot;, &quot;bar&quot;] format.</font>
<font color="black"> 260.         &quot;&quot;&quot;</font>
<font color="green"> 261.         self._remake_table(model, override_uniques=new_unique_together)</font>
<font color="black"> 262. </font>
<font color="green"> 263.     def _alter_many_to_many(self, model, old_field, new_field, strict):</font>
<font color="black"> 264.         &quot;&quot;&quot;</font>
<font color="black"> 265.         Alters M2Ms to repoint their to= endpoints.</font>
<font color="black"> 266.         &quot;&quot;&quot;</font>
<font color="red"> 267.         if old_field.remote_field.through._meta.db_table == new_field.remote_field.through._meta.db_table:</font>
<font color="black"> 268.             # The field name didn't change, but some options did; we have to propagate this altering.</font>
<font color="red"> 269.             self._remake_table(</font>
<font color="red"> 270.                 old_field.remote_field.through,</font>
<font color="black"> 271.                 alter_fields=[(</font>
<font color="black"> 272.                     # We need the field that points to the target model, so we can tell alter_field to change it -</font>
<font color="black"> 273.                     # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)</font>
<font color="red"> 274.                     old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),</font>
<font color="red"> 275.                     new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),</font>
<font color="black"> 276.                 )],</font>
<font color="red"> 277.                 override_uniques=(new_field.m2m_field_name(), new_field.m2m_reverse_field_name()),</font>
<font color="black"> 278.             )</font>
<font color="red"> 279.             return</font>
<font color="black"> 280. </font>
<font color="black"> 281.         # Make a new through table</font>
<font color="red"> 282.         self.create_model(new_field.remote_field.through)</font>
<font color="black"> 283.         # Copy the data across</font>
<font color="red"> 284.         self.execute(&quot;INSERT INTO %s (%s) SELECT %s FROM %s&quot; % (</font>
<font color="red"> 285.             self.quote_name(new_field.remote_field.through._meta.db_table),</font>
<font color="red"> 286.             ', '.join([</font>
<font color="red"> 287.                 &quot;id&quot;,</font>
<font color="red"> 288.                 new_field.m2m_column_name(),</font>
<font color="red"> 289.                 new_field.m2m_reverse_name(),</font>
<font color="black"> 290.             ]),</font>
<font color="red"> 291.             ', '.join([</font>
<font color="red"> 292.                 &quot;id&quot;,</font>
<font color="red"> 293.                 old_field.m2m_column_name(),</font>
<font color="red"> 294.                 old_field.m2m_reverse_name(),</font>
<font color="black"> 295.             ]),</font>
<font color="red"> 296.             self.quote_name(old_field.remote_field.through._meta.db_table),</font>
<font color="black"> 297.         ))</font>
<font color="black"> 298.         # Delete the old through table</font>
<font color="red"> 299.         self.delete_model(old_field.remote_field.through)</font>
</pre>

