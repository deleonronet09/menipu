source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/sqlite3/base.py</b><br>


file stats: <b>292 lines, 176 executed: 60.3% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. SQLite3 backend for django.</font>
<font color="black">   3. </font>
<font color="black">   4. Works with either the pysqlite2 module or the sqlite3 module in the</font>
<font color="black">   5. standard library.</font>
<font color="green">   6. &quot;&quot;&quot;</font>
<font color="green">   7. from __future__ import unicode_literals</font>
<font color="black">   8. </font>
<font color="green">   9. import datetime</font>
<font color="green">  10. import decimal</font>
<font color="green">  11. import re</font>
<font color="green">  12. import warnings</font>
<font color="black">  13. </font>
<font color="green">  14. from django.conf import settings</font>
<font color="green">  15. from django.db import utils</font>
<font color="green">  16. from django.db.backends import utils as backend_utils</font>
<font color="green">  17. from django.db.backends.base.base import BaseDatabaseWrapper</font>
<font color="green">  18. from django.db.backends.base.validation import BaseDatabaseValidation</font>
<font color="green">  19. from django.utils import six, timezone</font>
<font color="green">  20. from django.utils.dateparse import (</font>
<font color="black">  21.     parse_date, parse_datetime, parse_duration, parse_time,</font>
<font color="black">  22. )</font>
<font color="green">  23. from django.utils.deprecation import RemovedInDjango20Warning</font>
<font color="green">  24. from django.utils.encoding import force_text</font>
<font color="green">  25. from django.utils.safestring import SafeBytes</font>
<font color="black">  26. </font>
<font color="green">  27. try:</font>
<font color="green">  28.     import pytz</font>
<font color="green">  29. except ImportError:</font>
<font color="green">  30.     pytz = None</font>
<font color="black">  31. </font>
<font color="green">  32. try:</font>
<font color="green">  33.     try:</font>
<font color="green">  34.         from pysqlite2 import dbapi2 as Database</font>
<font color="green">  35.     except ImportError:</font>
<font color="green">  36.         from sqlite3 import dbapi2 as Database</font>
<font color="red">  37. except ImportError as exc:</font>
<font color="red">  38.     from django.core.exceptions import ImproperlyConfigured</font>
<font color="red">  39.     raise ImproperlyConfigured(&quot;Error loading either pysqlite2 or sqlite3 modules (tried in that order): %s&quot; % exc)</font>
<font color="black">  40. </font>
<font color="black">  41. # Some of these import sqlite3, so import them after checking if it's installed.</font>
<font color="green">  42. from .client import DatabaseClient                          # isort:skip</font>
<font color="green">  43. from .creation import DatabaseCreation                      # isort:skip</font>
<font color="green">  44. from .features import DatabaseFeatures                      # isort:skip</font>
<font color="green">  45. from .introspection import DatabaseIntrospection            # isort:skip</font>
<font color="green">  46. from .operations import DatabaseOperations                  # isort:skip</font>
<font color="green">  47. from .schema import DatabaseSchemaEditor                    # isort:skip</font>
<font color="black">  48. </font>
<font color="green">  49. DatabaseError = Database.DatabaseError</font>
<font color="green">  50. IntegrityError = Database.IntegrityError</font>
<font color="black">  51. </font>
<font color="black">  52. </font>
<font color="green">  53. def adapt_datetime_warn_on_aware_datetime(value):</font>
<font color="black">  54.     # Remove this function and rely on the default adapter in Django 2.0.</font>
<font color="red">  55.     if settings.USE_TZ and timezone.is_aware(value):</font>
<font color="red">  56.         warnings.warn(</font>
<font color="red">  57.             &quot;The SQLite database adapter received an aware datetime (%s), &quot;</font>
<font color="black">  58.             &quot;probably from cursor.execute(). Update your code to pass a &quot;</font>
<font color="black">  59.             &quot;naive datetime in the database connection's time zone (UTC by &quot;</font>
<font color="red">  60.             &quot;default).&quot;, RemovedInDjango20Warning)</font>
<font color="black">  61.         # This doesn't account for the database connection's timezone,</font>
<font color="black">  62.         # which isn't known. (That's why this adapter is deprecated.)</font>
<font color="red">  63.         value = value.astimezone(timezone.utc).replace(tzinfo=None)</font>
<font color="red">  64.     return value.isoformat(str(&quot; &quot;))</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="green">  67. def decoder(conv_func):</font>
<font color="black">  68.     &quot;&quot;&quot; The Python sqlite3 interface returns always byte strings.</font>
<font color="black">  69.         This function converts the received value to a regular string before</font>
<font color="black">  70.         passing it to the receiver function.</font>
<font color="black">  71.     &quot;&quot;&quot;</font>
<font color="green">  72.     return lambda s: conv_func(s.decode('utf-8'))</font>
<font color="black">  73. </font>
<font color="green">  74. Database.register_converter(str(&quot;bool&quot;), decoder(lambda s: s == '1'))</font>
<font color="green">  75. Database.register_converter(str(&quot;time&quot;), decoder(parse_time))</font>
<font color="green">  76. Database.register_converter(str(&quot;date&quot;), decoder(parse_date))</font>
<font color="green">  77. Database.register_converter(str(&quot;datetime&quot;), decoder(parse_datetime))</font>
<font color="green">  78. Database.register_converter(str(&quot;timestamp&quot;), decoder(parse_datetime))</font>
<font color="green">  79. Database.register_converter(str(&quot;TIMESTAMP&quot;), decoder(parse_datetime))</font>
<font color="green">  80. Database.register_converter(str(&quot;decimal&quot;), decoder(backend_utils.typecast_decimal))</font>
<font color="black">  81. </font>
<font color="green">  82. Database.register_adapter(datetime.datetime, adapt_datetime_warn_on_aware_datetime)</font>
<font color="green">  83. Database.register_adapter(decimal.Decimal, backend_utils.rev_typecast_decimal)</font>
<font color="green">  84. if six.PY2:</font>
<font color="green">  85.     Database.register_adapter(str, lambda s: s.decode('utf-8'))</font>
<font color="green">  86.     Database.register_adapter(SafeBytes, lambda s: s.decode('utf-8'))</font>
<font color="black">  87. </font>
<font color="black">  88. </font>
<font color="green">  89. class DatabaseWrapper(BaseDatabaseWrapper):</font>
<font color="green">  90.     vendor = 'sqlite'</font>
<font color="black">  91.     # SQLite doesn't actually support most of these types, but it &quot;does the right</font>
<font color="black">  92.     # thing&quot; given more verbose field definitions, so leave them as is so that</font>
<font color="black">  93.     # schema inspection is more useful.</font>
<font color="green">  94.     data_types = {</font>
<font color="green">  95.         'AutoField': 'integer',</font>
<font color="green">  96.         'BinaryField': 'BLOB',</font>
<font color="green">  97.         'BooleanField': 'bool',</font>
<font color="green">  98.         'CharField': 'varchar(%(max_length)s)',</font>
<font color="green">  99.         'CommaSeparatedIntegerField': 'varchar(%(max_length)s)',</font>
<font color="green"> 100.         'DateField': 'date',</font>
<font color="green"> 101.         'DateTimeField': 'datetime',</font>
<font color="green"> 102.         'DecimalField': 'decimal',</font>
<font color="green"> 103.         'DurationField': 'bigint',</font>
<font color="green"> 104.         'FileField': 'varchar(%(max_length)s)',</font>
<font color="green"> 105.         'FilePathField': 'varchar(%(max_length)s)',</font>
<font color="green"> 106.         'FloatField': 'real',</font>
<font color="green"> 107.         'IntegerField': 'integer',</font>
<font color="green"> 108.         'BigIntegerField': 'bigint',</font>
<font color="green"> 109.         'IPAddressField': 'char(15)',</font>
<font color="green"> 110.         'GenericIPAddressField': 'char(39)',</font>
<font color="green"> 111.         'NullBooleanField': 'bool',</font>
<font color="green"> 112.         'OneToOneField': 'integer',</font>
<font color="green"> 113.         'PositiveIntegerField': 'integer unsigned',</font>
<font color="green"> 114.         'PositiveSmallIntegerField': 'smallint unsigned',</font>
<font color="green"> 115.         'SlugField': 'varchar(%(max_length)s)',</font>
<font color="green"> 116.         'SmallIntegerField': 'smallint',</font>
<font color="green"> 117.         'TextField': 'text',</font>
<font color="green"> 118.         'TimeField': 'time',</font>
<font color="green"> 119.         'UUIDField': 'char(32)',</font>
<font color="black"> 120.     }</font>
<font color="green"> 121.     data_types_suffix = {</font>
<font color="green"> 122.         'AutoField': 'AUTOINCREMENT',</font>
<font color="black"> 123.     }</font>
<font color="black"> 124.     # SQLite requires LIKE statements to include an ESCAPE clause if the value</font>
<font color="black"> 125.     # being escaped has a percent or underscore in it.</font>
<font color="black"> 126.     # See http://www.sqlite.org/lang_expr.html for an explanation.</font>
<font color="green"> 127.     operators = {</font>
<font color="green"> 128.         'exact': '= %s',</font>
<font color="green"> 129.         'iexact': &quot;LIKE %s ESCAPE '\\'&quot;,</font>
<font color="green"> 130.         'contains': &quot;LIKE %s ESCAPE '\\'&quot;,</font>
<font color="green"> 131.         'icontains': &quot;LIKE %s ESCAPE '\\'&quot;,</font>
<font color="green"> 132.         'regex': 'REGEXP %s',</font>
<font color="green"> 133.         'iregex': &quot;REGEXP '(?i)' || %s&quot;,</font>
<font color="green"> 134.         'gt': '&gt; %s',</font>
<font color="green"> 135.         'gte': '&gt;= %s',</font>
<font color="green"> 136.         'lt': '&lt; %s',</font>
<font color="green"> 137.         'lte': '&lt;= %s',</font>
<font color="green"> 138.         'startswith': &quot;LIKE %s ESCAPE '\\'&quot;,</font>
<font color="green"> 139.         'endswith': &quot;LIKE %s ESCAPE '\\'&quot;,</font>
<font color="green"> 140.         'istartswith': &quot;LIKE %s ESCAPE '\\'&quot;,</font>
<font color="green"> 141.         'iendswith': &quot;LIKE %s ESCAPE '\\'&quot;,</font>
<font color="black"> 142.     }</font>
<font color="black"> 143. </font>
<font color="black"> 144.     # The patterns below are used to generate SQL pattern lookup clauses when</font>
<font color="black"> 145.     # the right-hand side of the lookup isn't a raw string (it might be an expression</font>
<font color="black"> 146.     # or the result of a bilateral transformation).</font>
<font color="black"> 147.     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be</font>
<font color="black"> 148.     # escaped on database side.</font>
<font color="black"> 149.     #</font>
<font color="black"> 150.     # Note: we use str.format() here for readability as '%' is used as a wildcard for</font>
<font color="black"> 151.     # the LIKE operator.</font>
<font color="green"> 152.     pattern_esc = r&quot;REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')&quot;</font>
<font color="green"> 153.     pattern_ops = {</font>
<font color="green"> 154.         'contains': r&quot;LIKE '%%' || {} || '%%' ESCAPE '\'&quot;,</font>
<font color="green"> 155.         'icontains': r&quot;LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'&quot;,</font>
<font color="green"> 156.         'startswith': r&quot;LIKE {} || '%%' ESCAPE '\'&quot;,</font>
<font color="green"> 157.         'istartswith': r&quot;LIKE UPPER({}) || '%%' ESCAPE '\'&quot;,</font>
<font color="green"> 158.         'endswith': r&quot;LIKE '%%' || {} ESCAPE '\'&quot;,</font>
<font color="green"> 159.         'iendswith': r&quot;LIKE '%%' || UPPER({}) ESCAPE '\'&quot;,</font>
<font color="black"> 160.     }</font>
<font color="black"> 161. </font>
<font color="green"> 162.     Database = Database</font>
<font color="green"> 163.     SchemaEditorClass = DatabaseSchemaEditor</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def __init__(self, *args, **kwargs):</font>
<font color="green"> 166.         super(DatabaseWrapper, self).__init__(*args, **kwargs)</font>
<font color="black"> 167. </font>
<font color="green"> 168.         self.features = DatabaseFeatures(self)</font>
<font color="green"> 169.         self.ops = DatabaseOperations(self)</font>
<font color="green"> 170.         self.client = DatabaseClient(self)</font>
<font color="green"> 171.         self.creation = DatabaseCreation(self)</font>
<font color="green"> 172.         self.introspection = DatabaseIntrospection(self)</font>
<font color="green"> 173.         self.validation = BaseDatabaseValidation(self)</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def get_connection_params(self):</font>
<font color="green"> 176.         settings_dict = self.settings_dict</font>
<font color="green"> 177.         if not settings_dict['NAME']:</font>
<font color="red"> 178.             from django.core.exceptions import ImproperlyConfigured</font>
<font color="red"> 179.             raise ImproperlyConfigured(</font>
<font color="red"> 180.                 &quot;settings.DATABASES is improperly configured. &quot;</font>
<font color="black"> 181.                 &quot;Please supply the NAME value.&quot;)</font>
<font color="green"> 182.         kwargs = {</font>
<font color="green"> 183.             'database': settings_dict['NAME'],</font>
<font color="green"> 184.             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,</font>
<font color="black"> 185.         }</font>
<font color="green"> 186.         kwargs.update(settings_dict['OPTIONS'])</font>
<font color="black"> 187.         # Always allow the underlying SQLite connection to be shareable</font>
<font color="black"> 188.         # between multiple threads. The safe-guarding will be handled at a</font>
<font color="black"> 189.         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`</font>
<font color="black"> 190.         # property. This is necessary as the shareability is disabled by</font>
<font color="black"> 191.         # default in pysqlite and it cannot be changed once a connection is</font>
<font color="black"> 192.         # opened.</font>
<font color="green"> 193.         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:</font>
<font color="red"> 194.             warnings.warn(</font>
<font color="red"> 195.                 'The `check_same_thread` option was provided and set to '</font>
<font color="black"> 196.                 'True. It will be overridden with False. Use the '</font>
<font color="black"> 197.                 '`DatabaseWrapper.allow_thread_sharing` property instead '</font>
<font color="black"> 198.                 'for controlling thread shareability.',</font>
<font color="red"> 199.                 RuntimeWarning</font>
<font color="black"> 200.             )</font>
<font color="green"> 201.         kwargs.update({'check_same_thread': False})</font>
<font color="green"> 202.         if self.features.can_share_in_memory_db:</font>
<font color="red"> 203.             kwargs.update({'uri': True})</font>
<font color="green"> 204.         return kwargs</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def get_new_connection(self, conn_params):</font>
<font color="green"> 207.         conn = Database.connect(**conn_params)</font>
<font color="green"> 208.         conn.create_function(&quot;django_date_extract&quot;, 2, _sqlite_date_extract)</font>
<font color="green"> 209.         conn.create_function(&quot;django_date_trunc&quot;, 2, _sqlite_date_trunc)</font>
<font color="green"> 210.         conn.create_function(&quot;django_datetime_cast_date&quot;, 2, _sqlite_datetime_cast_date)</font>
<font color="green"> 211.         conn.create_function(&quot;django_datetime_extract&quot;, 3, _sqlite_datetime_extract)</font>
<font color="green"> 212.         conn.create_function(&quot;django_datetime_trunc&quot;, 3, _sqlite_datetime_trunc)</font>
<font color="green"> 213.         conn.create_function(&quot;django_time_extract&quot;, 2, _sqlite_time_extract)</font>
<font color="green"> 214.         conn.create_function(&quot;regexp&quot;, 2, _sqlite_regexp)</font>
<font color="green"> 215.         conn.create_function(&quot;django_format_dtdelta&quot;, 3, _sqlite_format_dtdelta)</font>
<font color="green"> 216.         conn.create_function(&quot;django_power&quot;, 2, _sqlite_power)</font>
<font color="green"> 217.         return conn</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def init_connection_state(self):</font>
<font color="green"> 220.         pass</font>
<font color="black"> 221. </font>
<font color="green"> 222.     def create_cursor(self):</font>
<font color="green"> 223.         return self.connection.cursor(factory=SQLiteCursorWrapper)</font>
<font color="black"> 224. </font>
<font color="green"> 225.     def close(self):</font>
<font color="green"> 226.         self.validate_thread_sharing()</font>
<font color="black"> 227.         # If database is in memory, closing the connection destroys the</font>
<font color="black"> 228.         # database. To prevent accidental data loss, ignore close requests on</font>
<font color="black"> 229.         # an in-memory db.</font>
<font color="green"> 230.         if not self.is_in_memory_db(self.settings_dict['NAME']):</font>
<font color="green"> 231.             BaseDatabaseWrapper.close(self)</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def _savepoint_allowed(self):</font>
<font color="black"> 234.         # Two conditions are required here:</font>
<font color="black"> 235.         # - A sufficiently recent version of SQLite to support savepoints,</font>
<font color="black"> 236.         # - Being in a transaction, which can only happen inside 'atomic'.</font>
<font color="black"> 237. </font>
<font color="black"> 238.         # When 'isolation_level' is not None, sqlite3 commits before each</font>
<font color="black"> 239.         # savepoint; it's a bug. When it is None, savepoints don't make sense</font>
<font color="black"> 240.         # because autocommit is enabled. The only exception is inside 'atomic'</font>
<font color="black"> 241.         # blocks. To work around that bug, on SQLite, 'atomic' starts a</font>
<font color="black"> 242.         # transaction explicitly rather than simply disable autocommit.</font>
<font color="green"> 243.         return self.features.uses_savepoints and self.in_atomic_block</font>
<font color="black"> 244. </font>
<font color="green"> 245.     def _set_autocommit(self, autocommit):</font>
<font color="green"> 246.         if autocommit:</font>
<font color="green"> 247.             level = None</font>
<font color="black"> 248.         else:</font>
<font color="black"> 249.             # sqlite3's internal default is ''. It's different from None.</font>
<font color="black"> 250.             # See Modules/_sqlite/connection.c.</font>
<font color="red"> 251.             level = ''</font>
<font color="black"> 252.         # 'isolation_level' is a misleading API.</font>
<font color="black"> 253.         # SQLite always runs at the SERIALIZABLE isolation level.</font>
<font color="green"> 254.         with self.wrap_database_errors:</font>
<font color="green"> 255.             self.connection.isolation_level = level</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def check_constraints(self, table_names=None):</font>
<font color="black"> 258.         &quot;&quot;&quot;</font>
<font color="black"> 259.         Checks each table name in `table_names` for rows with invalid foreign</font>
<font color="black"> 260.         key references. This method is intended to be used in conjunction with</font>
<font color="black"> 261.         `disable_constraint_checking()` and `enable_constraint_checking()`, to</font>
<font color="black"> 262.         determine if rows with invalid references were entered while constraint</font>
<font color="black"> 263.         checks were off.</font>
<font color="black"> 264. </font>
<font color="black"> 265.         Raises an IntegrityError on the first invalid foreign key reference</font>
<font color="black"> 266.         encountered (if any) and provides detailed information about the</font>
<font color="black"> 267.         invalid reference in the error message.</font>
<font color="black"> 268. </font>
<font color="black"> 269.         Backends can override this method if they can more directly apply</font>
<font color="black"> 270.         constraint checking (e.g. via &quot;SET CONSTRAINTS ALL IMMEDIATE&quot;)</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="red"> 272.         cursor = self.cursor()</font>
<font color="red"> 273.         if table_names is None:</font>
<font color="red"> 274.             table_names = self.introspection.table_names(cursor)</font>
<font color="red"> 275.         for table_name in table_names:</font>
<font color="red"> 276.             primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)</font>
<font color="red"> 277.             if not primary_key_column_name:</font>
<font color="red"> 278.                 continue</font>
<font color="red"> 279.             key_columns = self.introspection.get_key_columns(cursor, table_name)</font>
<font color="red"> 280.             for column_name, referenced_table_name, referenced_column_name in key_columns:</font>
<font color="red"> 281.                 cursor.execute(&quot;&quot;&quot;</font>
<font color="black"> 282.                     SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING</font>
<font color="black"> 283.                     LEFT JOIN `%s` as REFERRED</font>
<font color="black"> 284.                     ON (REFERRING.`%s` = REFERRED.`%s`)</font>
<font color="red"> 285.                     WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL&quot;&quot;&quot;</font>
<font color="red"> 286.                     % (primary_key_column_name, column_name, table_name, referenced_table_name,</font>
<font color="red"> 287.                     column_name, referenced_column_name, column_name, referenced_column_name))</font>
<font color="red"> 288.                 for bad_row in cursor.fetchall():</font>
<font color="red"> 289.                     raise utils.IntegrityError(&quot;The row in table '%s' with primary key '%s' has an invalid &quot;</font>
<font color="black"> 290.                         &quot;foreign key: %s.%s contains a value '%s' that does not have a corresponding value in %s.%s.&quot;</font>
<font color="red"> 291.                         % (table_name, bad_row[0], table_name, column_name, bad_row[1],</font>
<font color="red"> 292.                         referenced_table_name, referenced_column_name))</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def is_usable(self):</font>
<font color="red"> 295.         return True</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def _start_transaction_under_autocommit(self):</font>
<font color="black"> 298.         &quot;&quot;&quot;</font>
<font color="black"> 299.         Start a transaction explicitly in autocommit mode.</font>
<font color="black"> 300. </font>
<font color="black"> 301.         Staying in autocommit mode works around a bug of sqlite3 that breaks</font>
<font color="black"> 302.         savepoints when autocommit is disabled.</font>
<font color="black"> 303.         &quot;&quot;&quot;</font>
<font color="green"> 304.         self.cursor().execute(&quot;BEGIN&quot;)</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def is_in_memory_db(self, name):</font>
<font color="green"> 307.         return name == &quot;:memory:&quot; or &quot;mode=memory&quot; in force_text(name)</font>
<font color="black"> 308. </font>
<font color="black"> 309. </font>
<font color="green"> 310. FORMAT_QMARK_REGEX = re.compile(r'(?&lt;!%)%s')</font>
<font color="black"> 311. </font>
<font color="black"> 312. </font>
<font color="green"> 313. class SQLiteCursorWrapper(Database.Cursor):</font>
<font color="black"> 314.     &quot;&quot;&quot;</font>
<font color="black"> 315.     Django uses &quot;format&quot; style placeholders, but pysqlite2 uses &quot;qmark&quot; style.</font>
<font color="black"> 316.     This fixes it -- but note that if you want to use a literal &quot;%s&quot; in a query,</font>
<font color="black"> 317.     you'll need to use &quot;%%s&quot;.</font>
<font color="green"> 318.     &quot;&quot;&quot;</font>
<font color="green"> 319.     def execute(self, query, params=None):</font>
<font color="green"> 320.         if params is None:</font>
<font color="green"> 321.             return Database.Cursor.execute(self, query)</font>
<font color="green"> 322.         query = self.convert_query(query)</font>
<font color="green"> 323.         return Database.Cursor.execute(self, query, params)</font>
<font color="black"> 324. </font>
<font color="green"> 325.     def executemany(self, query, param_list):</font>
<font color="red"> 326.         query = self.convert_query(query)</font>
<font color="red"> 327.         return Database.Cursor.executemany(self, query, param_list)</font>
<font color="black"> 328. </font>
<font color="green"> 329.     def convert_query(self, query):</font>
<font color="green"> 330.         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')</font>
<font color="black"> 331. </font>
<font color="black"> 332. </font>
<font color="green"> 333. def _sqlite_date_extract(lookup_type, dt):</font>
<font color="red"> 334.     if dt is None:</font>
<font color="red"> 335.         return None</font>
<font color="red"> 336.     try:</font>
<font color="red"> 337.         dt = backend_utils.typecast_timestamp(dt)</font>
<font color="red"> 338.     except (ValueError, TypeError):</font>
<font color="red"> 339.         return None</font>
<font color="red"> 340.     if lookup_type == 'week_day':</font>
<font color="red"> 341.         return (dt.isoweekday() % 7) + 1</font>
<font color="black"> 342.     else:</font>
<font color="red"> 343.         return getattr(dt, lookup_type)</font>
<font color="black"> 344. </font>
<font color="black"> 345. </font>
<font color="green"> 346. def _sqlite_date_trunc(lookup_type, dt):</font>
<font color="red"> 347.     try:</font>
<font color="red"> 348.         dt = backend_utils.typecast_timestamp(dt)</font>
<font color="red"> 349.     except (ValueError, TypeError):</font>
<font color="red"> 350.         return None</font>
<font color="red"> 351.     if lookup_type == 'year':</font>
<font color="red"> 352.         return &quot;%i-01-01&quot; % dt.year</font>
<font color="red"> 353.     elif lookup_type == 'month':</font>
<font color="red"> 354.         return &quot;%i-%02i-01&quot; % (dt.year, dt.month)</font>
<font color="red"> 355.     elif lookup_type == 'day':</font>
<font color="red"> 356.         return &quot;%i-%02i-%02i&quot; % (dt.year, dt.month, dt.day)</font>
<font color="black"> 357. </font>
<font color="black"> 358. </font>
<font color="green"> 359. def _sqlite_datetime_parse(dt, tzname):</font>
<font color="red"> 360.     if dt is None:</font>
<font color="red"> 361.         return None</font>
<font color="red"> 362.     try:</font>
<font color="red"> 363.         dt = backend_utils.typecast_timestamp(dt)</font>
<font color="red"> 364.     except (ValueError, TypeError):</font>
<font color="red"> 365.         return None</font>
<font color="red"> 366.     if tzname is not None:</font>
<font color="red"> 367.         dt = timezone.localtime(dt, pytz.timezone(tzname))</font>
<font color="red"> 368.     return dt</font>
<font color="black"> 369. </font>
<font color="black"> 370. </font>
<font color="green"> 371. def _sqlite_datetime_cast_date(dt, tzname):</font>
<font color="red"> 372.     dt = _sqlite_datetime_parse(dt, tzname)</font>
<font color="red"> 373.     if dt is None:</font>
<font color="red"> 374.         return None</font>
<font color="red"> 375.     return dt.date().isoformat()</font>
<font color="black"> 376. </font>
<font color="black"> 377. </font>
<font color="green"> 378. def _sqlite_datetime_extract(lookup_type, dt, tzname):</font>
<font color="red"> 379.     dt = _sqlite_datetime_parse(dt, tzname)</font>
<font color="red"> 380.     if dt is None:</font>
<font color="red"> 381.         return None</font>
<font color="red"> 382.     if lookup_type == 'week_day':</font>
<font color="red"> 383.         return (dt.isoweekday() % 7) + 1</font>
<font color="black"> 384.     else:</font>
<font color="red"> 385.         return getattr(dt, lookup_type)</font>
<font color="black"> 386. </font>
<font color="black"> 387. </font>
<font color="green"> 388. def _sqlite_datetime_trunc(lookup_type, dt, tzname):</font>
<font color="red"> 389.     dt = _sqlite_datetime_parse(dt, tzname)</font>
<font color="red"> 390.     if dt is None:</font>
<font color="red"> 391.         return None</font>
<font color="red"> 392.     if lookup_type == 'year':</font>
<font color="red"> 393.         return &quot;%i-01-01 00:00:00&quot; % dt.year</font>
<font color="red"> 394.     elif lookup_type == 'month':</font>
<font color="red"> 395.         return &quot;%i-%02i-01 00:00:00&quot; % (dt.year, dt.month)</font>
<font color="red"> 396.     elif lookup_type == 'day':</font>
<font color="red"> 397.         return &quot;%i-%02i-%02i 00:00:00&quot; % (dt.year, dt.month, dt.day)</font>
<font color="red"> 398.     elif lookup_type == 'hour':</font>
<font color="red"> 399.         return &quot;%i-%02i-%02i %02i:00:00&quot; % (dt.year, dt.month, dt.day, dt.hour)</font>
<font color="red"> 400.     elif lookup_type == 'minute':</font>
<font color="red"> 401.         return &quot;%i-%02i-%02i %02i:%02i:00&quot; % (dt.year, dt.month, dt.day, dt.hour, dt.minute)</font>
<font color="red"> 402.     elif lookup_type == 'second':</font>
<font color="red"> 403.         return &quot;%i-%02i-%02i %02i:%02i:%02i&quot; % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)</font>
<font color="black"> 404. </font>
<font color="black"> 405. </font>
<font color="green"> 406. def _sqlite_time_extract(lookup_type, dt):</font>
<font color="red"> 407.     if dt is None:</font>
<font color="red"> 408.         return None</font>
<font color="red"> 409.     try:</font>
<font color="red"> 410.         dt = backend_utils.typecast_time(dt)</font>
<font color="red"> 411.     except (ValueError, TypeError):</font>
<font color="red"> 412.         return None</font>
<font color="red"> 413.     return getattr(dt, lookup_type)</font>
<font color="black"> 414. </font>
<font color="black"> 415. </font>
<font color="green"> 416. def _sqlite_format_dtdelta(conn, lhs, rhs):</font>
<font color="black"> 417.     &quot;&quot;&quot;</font>
<font color="black"> 418.     LHS and RHS can be either:</font>
<font color="black"> 419.         - An integer number of microseconds</font>
<font color="black"> 420.         - A string representing a timedelta object</font>
<font color="black"> 421.         - A string representing a datetime</font>
<font color="black"> 422.     &quot;&quot;&quot;</font>
<font color="red"> 423.     try:</font>
<font color="red"> 424.         if isinstance(lhs, six.integer_types):</font>
<font color="red"> 425.             lhs = str(decimal.Decimal(lhs) / decimal.Decimal(1000000))</font>
<font color="red"> 426.         real_lhs = parse_duration(lhs)</font>
<font color="red"> 427.         if real_lhs is None:</font>
<font color="red"> 428.             real_lhs = backend_utils.typecast_timestamp(lhs)</font>
<font color="red"> 429.         if isinstance(rhs, six.integer_types):</font>
<font color="red"> 430.             rhs = str(decimal.Decimal(rhs) / decimal.Decimal(1000000))</font>
<font color="red"> 431.         real_rhs = parse_duration(rhs)</font>
<font color="red"> 432.         if real_rhs is None:</font>
<font color="red"> 433.             real_rhs = backend_utils.typecast_timestamp(rhs)</font>
<font color="red"> 434.         if conn.strip() == '+':</font>
<font color="red"> 435.             out = real_lhs + real_rhs</font>
<font color="black"> 436.         else:</font>
<font color="red"> 437.             out = real_lhs - real_rhs</font>
<font color="red"> 438.     except (ValueError, TypeError):</font>
<font color="red"> 439.         return None</font>
<font color="black"> 440.     # typecast_timestamp returns a date or a datetime without timezone.</font>
<font color="black"> 441.     # It will be formatted as &quot;%Y-%m-%d&quot; or &quot;%Y-%m-%d %H:%M:%S[.%f]&quot;</font>
<font color="red"> 442.     return str(out)</font>
<font color="black"> 443. </font>
<font color="black"> 444. </font>
<font color="green"> 445. def _sqlite_regexp(re_pattern, re_string):</font>
<font color="red"> 446.     return bool(re.search(re_pattern, force_text(re_string))) if re_string is not None else False</font>
<font color="black"> 447. </font>
<font color="black"> 448. </font>
<font color="green"> 449. def _sqlite_power(x, y):</font>
<font color="red"> 450.     return x ** y</font>
</pre>

