source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/serializers/xml_serializer.py</b><br>


file stats: <b>240 lines, 56 executed: 23.3% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. XML serializer.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. from __future__ import unicode_literals</font>
<font color="black">   6. </font>
<font color="green">   7. from collections import OrderedDict</font>
<font color="green">   8. from xml.dom import pulldom</font>
<font color="green">   9. from xml.sax import handler</font>
<font color="green">  10. from xml.sax.expatreader import ExpatParser as _ExpatParser</font>
<font color="black">  11. </font>
<font color="green">  12. from django.apps import apps</font>
<font color="green">  13. from django.conf import settings</font>
<font color="green">  14. from django.core.serializers import base</font>
<font color="green">  15. from django.db import DEFAULT_DB_ALIAS, models</font>
<font color="green">  16. from django.utils.encoding import smart_text</font>
<font color="green">  17. from django.utils.xmlutils import (</font>
<font color="black">  18.     SimplerXMLGenerator, UnserializableContentError,</font>
<font color="black">  19. )</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class Serializer(base.Serializer):</font>
<font color="black">  23.     &quot;&quot;&quot;</font>
<font color="black">  24.     Serializes a QuerySet to XML.</font>
<font color="green">  25.     &quot;&quot;&quot;</font>
<font color="black">  26. </font>
<font color="green">  27.     def indent(self, level):</font>
<font color="red">  28.         if self.options.get('indent') is not None:</font>
<font color="red">  29.             self.xml.ignorableWhitespace('\n' + ' ' * self.options.get('indent') * level)</font>
<font color="black">  30. </font>
<font color="green">  31.     def start_serialization(self):</font>
<font color="black">  32.         &quot;&quot;&quot;</font>
<font color="black">  33.         Start serialization -- open the XML document and the root element.</font>
<font color="black">  34.         &quot;&quot;&quot;</font>
<font color="red">  35.         self.xml = SimplerXMLGenerator(self.stream, self.options.get(&quot;encoding&quot;, settings.DEFAULT_CHARSET))</font>
<font color="red">  36.         self.xml.startDocument()</font>
<font color="red">  37.         self.xml.startElement(&quot;django-objects&quot;, {&quot;version&quot;: &quot;1.0&quot;})</font>
<font color="black">  38. </font>
<font color="green">  39.     def end_serialization(self):</font>
<font color="black">  40.         &quot;&quot;&quot;</font>
<font color="black">  41.         End serialization -- end the document.</font>
<font color="black">  42.         &quot;&quot;&quot;</font>
<font color="red">  43.         self.indent(0)</font>
<font color="red">  44.         self.xml.endElement(&quot;django-objects&quot;)</font>
<font color="red">  45.         self.xml.endDocument()</font>
<font color="black">  46. </font>
<font color="green">  47.     def start_object(self, obj):</font>
<font color="black">  48.         &quot;&quot;&quot;</font>
<font color="black">  49.         Called as each object is handled.</font>
<font color="black">  50.         &quot;&quot;&quot;</font>
<font color="red">  51.         if not hasattr(obj, &quot;_meta&quot;):</font>
<font color="red">  52.             raise base.SerializationError(&quot;Non-model object (%s) encountered during serialization&quot; % type(obj))</font>
<font color="black">  53. </font>
<font color="red">  54.         self.indent(1)</font>
<font color="red">  55.         model = obj._meta.proxy_for_model if obj._deferred else obj.__class__</font>
<font color="red">  56.         attrs = OrderedDict([(&quot;model&quot;, smart_text(model._meta))])</font>
<font color="red">  57.         if not self.use_natural_primary_keys or not hasattr(obj, 'natural_key'):</font>
<font color="red">  58.             obj_pk = obj._get_pk_val()</font>
<font color="red">  59.             if obj_pk is not None:</font>
<font color="red">  60.                 attrs['pk'] = smart_text(obj_pk)</font>
<font color="black">  61. </font>
<font color="red">  62.         self.xml.startElement(&quot;object&quot;, attrs)</font>
<font color="black">  63. </font>
<font color="green">  64.     def end_object(self, obj):</font>
<font color="black">  65.         &quot;&quot;&quot;</font>
<font color="black">  66.         Called after handling all fields for an object.</font>
<font color="black">  67.         &quot;&quot;&quot;</font>
<font color="red">  68.         self.indent(1)</font>
<font color="red">  69.         self.xml.endElement(&quot;object&quot;)</font>
<font color="black">  70. </font>
<font color="green">  71.     def handle_field(self, obj, field):</font>
<font color="black">  72.         &quot;&quot;&quot;</font>
<font color="black">  73.         Called to handle each field on an object (except for ForeignKeys and</font>
<font color="black">  74.         ManyToManyFields)</font>
<font color="black">  75.         &quot;&quot;&quot;</font>
<font color="red">  76.         self.indent(2)</font>
<font color="red">  77.         self.xml.startElement(&quot;field&quot;, OrderedDict([</font>
<font color="red">  78.             (&quot;name&quot;, field.name),</font>
<font color="red">  79.             (&quot;type&quot;, field.get_internal_type()),</font>
<font color="black">  80.         ]))</font>
<font color="black">  81. </font>
<font color="black">  82.         # Get a &quot;string version&quot; of the object's data.</font>
<font color="red">  83.         if getattr(obj, field.name) is not None:</font>
<font color="red">  84.             try:</font>
<font color="red">  85.                 self.xml.characters(field.value_to_string(obj))</font>
<font color="red">  86.             except UnserializableContentError:</font>
<font color="red">  87.                 raise ValueError(&quot;%s.%s (pk:%s) contains unserializable characters&quot; % (</font>
<font color="red">  88.                     obj.__class__.__name__, field.name, obj._get_pk_val()))</font>
<font color="black">  89.         else:</font>
<font color="red">  90.             self.xml.addQuickElement(&quot;None&quot;)</font>
<font color="black">  91. </font>
<font color="red">  92.         self.xml.endElement(&quot;field&quot;)</font>
<font color="black">  93. </font>
<font color="green">  94.     def handle_fk_field(self, obj, field):</font>
<font color="black">  95.         &quot;&quot;&quot;</font>
<font color="black">  96.         Called to handle a ForeignKey (we need to treat them slightly</font>
<font color="black">  97.         differently from regular fields).</font>
<font color="black">  98.         &quot;&quot;&quot;</font>
<font color="red">  99.         self._start_relational_field(field)</font>
<font color="red"> 100.         related_att = getattr(obj, field.get_attname())</font>
<font color="red"> 101.         if related_att is not None:</font>
<font color="red"> 102.             if self.use_natural_foreign_keys and hasattr(field.remote_field.model, 'natural_key'):</font>
<font color="red"> 103.                 related = getattr(obj, field.name)</font>
<font color="black"> 104.                 # If related object has a natural key, use it</font>
<font color="red"> 105.                 related = related.natural_key()</font>
<font color="black"> 106.                 # Iterable natural keys are rolled out as subelements</font>
<font color="red"> 107.                 for key_value in related:</font>
<font color="red"> 108.                     self.xml.startElement(&quot;natural&quot;, {})</font>
<font color="red"> 109.                     self.xml.characters(smart_text(key_value))</font>
<font color="red"> 110.                     self.xml.endElement(&quot;natural&quot;)</font>
<font color="black"> 111.             else:</font>
<font color="red"> 112.                 self.xml.characters(smart_text(related_att))</font>
<font color="black"> 113.         else:</font>
<font color="red"> 114.             self.xml.addQuickElement(&quot;None&quot;)</font>
<font color="red"> 115.         self.xml.endElement(&quot;field&quot;)</font>
<font color="black"> 116. </font>
<font color="green"> 117.     def handle_m2m_field(self, obj, field):</font>
<font color="black"> 118.         &quot;&quot;&quot;</font>
<font color="black"> 119.         Called to handle a ManyToManyField. Related objects are only</font>
<font color="black"> 120.         serialized as references to the object's PK (i.e. the related *data*</font>
<font color="black"> 121.         is not dumped, just the relation).</font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="red"> 123.         if field.remote_field.through._meta.auto_created:</font>
<font color="red"> 124.             self._start_relational_field(field)</font>
<font color="red"> 125.             if self.use_natural_foreign_keys and hasattr(field.remote_field.model, 'natural_key'):</font>
<font color="black"> 126.                 # If the objects in the m2m have a natural key, use it</font>
<font color="red"> 127.                 def handle_m2m(value):</font>
<font color="red"> 128.                     natural = value.natural_key()</font>
<font color="black"> 129.                     # Iterable natural keys are rolled out as subelements</font>
<font color="red"> 130.                     self.xml.startElement(&quot;object&quot;, {})</font>
<font color="red"> 131.                     for key_value in natural:</font>
<font color="red"> 132.                         self.xml.startElement(&quot;natural&quot;, {})</font>
<font color="red"> 133.                         self.xml.characters(smart_text(key_value))</font>
<font color="red"> 134.                         self.xml.endElement(&quot;natural&quot;)</font>
<font color="red"> 135.                     self.xml.endElement(&quot;object&quot;)</font>
<font color="black"> 136.             else:</font>
<font color="red"> 137.                 def handle_m2m(value):</font>
<font color="red"> 138.                     self.xml.addQuickElement(&quot;object&quot;, attrs={</font>
<font color="red"> 139.                         'pk': smart_text(value._get_pk_val())</font>
<font color="black"> 140.                     })</font>
<font color="red"> 141.             for relobj in getattr(obj, field.name).iterator():</font>
<font color="red"> 142.                 handle_m2m(relobj)</font>
<font color="black"> 143. </font>
<font color="red"> 144.             self.xml.endElement(&quot;field&quot;)</font>
<font color="black"> 145. </font>
<font color="green"> 146.     def _start_relational_field(self, field):</font>
<font color="black"> 147.         &quot;&quot;&quot;</font>
<font color="black"> 148.         Helper to output the &lt;field&gt; element for relational fields</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="red"> 150.         self.indent(2)</font>
<font color="red"> 151.         self.xml.startElement(&quot;field&quot;, OrderedDict([</font>
<font color="red"> 152.             (&quot;name&quot;, field.name),</font>
<font color="red"> 153.             (&quot;rel&quot;, field.remote_field.__class__.__name__),</font>
<font color="red"> 154.             (&quot;to&quot;, smart_text(field.remote_field.model._meta)),</font>
<font color="black"> 155.         ]))</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="green"> 158. class Deserializer(base.Deserializer):</font>
<font color="black"> 159.     &quot;&quot;&quot;</font>
<font color="black"> 160.     Deserialize XML.</font>
<font color="green"> 161.     &quot;&quot;&quot;</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def __init__(self, stream_or_string, **options):</font>
<font color="red"> 164.         super(Deserializer, self).__init__(stream_or_string, **options)</font>
<font color="red"> 165.         self.event_stream = pulldom.parse(self.stream, self._make_parser())</font>
<font color="red"> 166.         self.db = options.pop('using', DEFAULT_DB_ALIAS)</font>
<font color="red"> 167.         self.ignore = options.pop('ignorenonexistent', False)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def _make_parser(self):</font>
<font color="black"> 170.         &quot;&quot;&quot;Create a hardened XML parser (no custom/external entities).&quot;&quot;&quot;</font>
<font color="red"> 171.         return DefusedExpatParser()</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def __next__(self):</font>
<font color="red"> 174.         for event, node in self.event_stream:</font>
<font color="red"> 175.             if event == &quot;START_ELEMENT&quot; and node.nodeName == &quot;object&quot;:</font>
<font color="red"> 176.                 self.event_stream.expandNode(node)</font>
<font color="red"> 177.                 return self._handle_object(node)</font>
<font color="red"> 178.         raise StopIteration</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def _handle_object(self, node):</font>
<font color="black"> 181.         &quot;&quot;&quot;</font>
<font color="black"> 182.         Convert an &lt;object&gt; node to a DeserializedObject.</font>
<font color="black"> 183.         &quot;&quot;&quot;</font>
<font color="black"> 184.         # Look up the model using the model loading mechanism. If this fails,</font>
<font color="black"> 185.         # bail.</font>
<font color="red"> 186.         Model = self._get_model_from_node(node, &quot;model&quot;)</font>
<font color="black"> 187. </font>
<font color="black"> 188.         # Start building a data dictionary from the object.</font>
<font color="red"> 189.         data = {}</font>
<font color="red"> 190.         if node.hasAttribute('pk'):</font>
<font color="red"> 191.             data[Model._meta.pk.attname] = Model._meta.pk.to_python(</font>
<font color="red"> 192.                 node.getAttribute('pk'))</font>
<font color="black"> 193. </font>
<font color="black"> 194.         # Also start building a dict of m2m data (this is saved as</font>
<font color="black"> 195.         # {m2m_accessor_attribute : [list_of_related_objects]})</font>
<font color="red"> 196.         m2m_data = {}</font>
<font color="black"> 197. </font>
<font color="red"> 198.         field_names = {f.name for f in Model._meta.get_fields()}</font>
<font color="black"> 199.         # Deserialize each field.</font>
<font color="red"> 200.         for field_node in node.getElementsByTagName(&quot;field&quot;):</font>
<font color="black"> 201.             # If the field is missing the name attribute, bail (are you</font>
<font color="black"> 202.             # sensing a pattern here?)</font>
<font color="red"> 203.             field_name = field_node.getAttribute(&quot;name&quot;)</font>
<font color="red"> 204.             if not field_name:</font>
<font color="red"> 205.                 raise base.DeserializationError(&quot;&lt;field&gt; node is missing the 'name' attribute&quot;)</font>
<font color="black"> 206. </font>
<font color="black"> 207.             # Get the field from the Model. This will raise a</font>
<font color="black"> 208.             # FieldDoesNotExist if, well, the field doesn't exist, which will</font>
<font color="black"> 209.             # be propagated correctly unless ignorenonexistent=True is used.</font>
<font color="red"> 210.             if self.ignore and field_name not in field_names:</font>
<font color="red"> 211.                 continue</font>
<font color="red"> 212.             field = Model._meta.get_field(field_name)</font>
<font color="black"> 213. </font>
<font color="black"> 214.             # As is usually the case, relation fields get the special treatment.</font>
<font color="red"> 215.             if field.remote_field and isinstance(field.remote_field, models.ManyToManyRel):</font>
<font color="red"> 216.                 m2m_data[field.name] = self._handle_m2m_field_node(field_node, field)</font>
<font color="red"> 217.             elif field.remote_field and isinstance(field.remote_field, models.ManyToOneRel):</font>
<font color="red"> 218.                 data[field.attname] = self._handle_fk_field_node(field_node, field)</font>
<font color="black"> 219.             else:</font>
<font color="red"> 220.                 if field_node.getElementsByTagName('None'):</font>
<font color="red"> 221.                     value = None</font>
<font color="black"> 222.                 else:</font>
<font color="red"> 223.                     value = field.to_python(getInnerText(field_node).strip())</font>
<font color="red"> 224.                 data[field.name] = value</font>
<font color="black"> 225. </font>
<font color="red"> 226.         obj = base.build_instance(Model, data, self.db)</font>
<font color="black"> 227. </font>
<font color="black"> 228.         # Return a DeserializedObject so that the m2m data has a place to live.</font>
<font color="red"> 229.         return base.DeserializedObject(obj, m2m_data)</font>
<font color="black"> 230. </font>
<font color="green"> 231.     def _handle_fk_field_node(self, node, field):</font>
<font color="black"> 232.         &quot;&quot;&quot;</font>
<font color="black"> 233.         Handle a &lt;field&gt; node for a ForeignKey</font>
<font color="black"> 234.         &quot;&quot;&quot;</font>
<font color="black"> 235.         # Check if there is a child node named 'None', returning None if so.</font>
<font color="red"> 236.         if node.getElementsByTagName('None'):</font>
<font color="red"> 237.             return None</font>
<font color="black"> 238.         else:</font>
<font color="red"> 239.             model = field.remote_field.model</font>
<font color="red"> 240.             if hasattr(model._default_manager, 'get_by_natural_key'):</font>
<font color="red"> 241.                 keys = node.getElementsByTagName('natural')</font>
<font color="red"> 242.                 if keys:</font>
<font color="black"> 243.                     # If there are 'natural' subelements, it must be a natural key</font>
<font color="red"> 244.                     field_value = [getInnerText(k).strip() for k in keys]</font>
<font color="red"> 245.                     obj = model._default_manager.db_manager(self.db).get_by_natural_key(*field_value)</font>
<font color="red"> 246.                     obj_pk = getattr(obj, field.remote_field.field_name)</font>
<font color="black"> 247.                     # If this is a natural foreign key to an object that</font>
<font color="black"> 248.                     # has a FK/O2O as the foreign key, use the FK value</font>
<font color="red"> 249.                     if field.remote_field.model._meta.pk.remote_field:</font>
<font color="red"> 250.                         obj_pk = obj_pk.pk</font>
<font color="black"> 251.                 else:</font>
<font color="black"> 252.                     # Otherwise, treat like a normal PK</font>
<font color="red"> 253.                     field_value = getInnerText(node).strip()</font>
<font color="red"> 254.                     obj_pk = model._meta.get_field(field.remote_field.field_name).to_python(field_value)</font>
<font color="red"> 255.                 return obj_pk</font>
<font color="black"> 256.             else:</font>
<font color="red"> 257.                 field_value = getInnerText(node).strip()</font>
<font color="red"> 258.                 return model._meta.get_field(field.remote_field.field_name).to_python(field_value)</font>
<font color="black"> 259. </font>
<font color="green"> 260.     def _handle_m2m_field_node(self, node, field):</font>
<font color="black"> 261.         &quot;&quot;&quot;</font>
<font color="black"> 262.         Handle a &lt;field&gt; node for a ManyToManyField.</font>
<font color="black"> 263.         &quot;&quot;&quot;</font>
<font color="red"> 264.         model = field.remote_field.model</font>
<font color="red"> 265.         default_manager = model._default_manager</font>
<font color="red"> 266.         if hasattr(default_manager, 'get_by_natural_key'):</font>
<font color="red"> 267.             def m2m_convert(n):</font>
<font color="red"> 268.                 keys = n.getElementsByTagName('natural')</font>
<font color="red"> 269.                 if keys:</font>
<font color="black"> 270.                     # If there are 'natural' subelements, it must be a natural key</font>
<font color="red"> 271.                     field_value = [getInnerText(k).strip() for k in keys]</font>
<font color="red"> 272.                     obj_pk = default_manager.db_manager(self.db).get_by_natural_key(*field_value).pk</font>
<font color="black"> 273.                 else:</font>
<font color="black"> 274.                     # Otherwise, treat like a normal PK value.</font>
<font color="red"> 275.                     obj_pk = model._meta.pk.to_python(n.getAttribute('pk'))</font>
<font color="red"> 276.                 return obj_pk</font>
<font color="black"> 277.         else:</font>
<font color="red"> 278.             m2m_convert = lambda n: model._meta.pk.to_python(n.getAttribute('pk'))</font>
<font color="red"> 279.         return [m2m_convert(c) for c in node.getElementsByTagName(&quot;object&quot;)]</font>
<font color="black"> 280. </font>
<font color="green"> 281.     def _get_model_from_node(self, node, attr):</font>
<font color="black"> 282.         &quot;&quot;&quot;</font>
<font color="black"> 283.         Helper to look up a model from a &lt;object model=...&gt; or a &lt;field</font>
<font color="black"> 284.         rel=... to=...&gt; node.</font>
<font color="black"> 285.         &quot;&quot;&quot;</font>
<font color="red"> 286.         model_identifier = node.getAttribute(attr)</font>
<font color="red"> 287.         if not model_identifier:</font>
<font color="red"> 288.             raise base.DeserializationError(</font>
<font color="red"> 289.                 &quot;&lt;%s&gt; node is missing the required '%s' attribute&quot;</font>
<font color="red"> 290.                 % (node.nodeName, attr))</font>
<font color="red"> 291.         try:</font>
<font color="red"> 292.             return apps.get_model(model_identifier)</font>
<font color="red"> 293.         except (LookupError, TypeError):</font>
<font color="red"> 294.             raise base.DeserializationError(</font>
<font color="red"> 295.                 &quot;&lt;%s&gt; node has invalid model identifier: '%s'&quot;</font>
<font color="red"> 296.                 % (node.nodeName, model_identifier))</font>
<font color="black"> 297. </font>
<font color="black"> 298. </font>
<font color="green"> 299. def getInnerText(node):</font>
<font color="black"> 300.     &quot;&quot;&quot;</font>
<font color="black"> 301.     Get all the inner text of a DOM node (recursively).</font>
<font color="black"> 302.     &quot;&quot;&quot;</font>
<font color="black"> 303.     # inspired by http://mail.python.org/pipermail/xml-sig/2005-March/011022.html</font>
<font color="red"> 304.     inner_text = []</font>
<font color="red"> 305.     for child in node.childNodes:</font>
<font color="red"> 306.         if child.nodeType == child.TEXT_NODE or child.nodeType == child.CDATA_SECTION_NODE:</font>
<font color="red"> 307.             inner_text.append(child.data)</font>
<font color="red"> 308.         elif child.nodeType == child.ELEMENT_NODE:</font>
<font color="red"> 309.             inner_text.extend(getInnerText(child))</font>
<font color="black"> 310.         else:</font>
<font color="red"> 311.             pass</font>
<font color="red"> 312.     return &quot;&quot;.join(inner_text)</font>
<font color="black"> 313. </font>
<font color="black"> 314. </font>
<font color="black"> 315. # Below code based on Christian Heimes' defusedxml</font>
<font color="black"> 316. </font>
<font color="black"> 317. </font>
<font color="green"> 318. class DefusedExpatParser(_ExpatParser):</font>
<font color="black"> 319.     &quot;&quot;&quot;</font>
<font color="black"> 320.     An expat parser hardened against XML bomb attacks.</font>
<font color="black"> 321. </font>
<font color="black"> 322.     Forbids DTDs, external entity references</font>
<font color="green"> 323.     &quot;&quot;&quot;</font>
<font color="green"> 324.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 325.         _ExpatParser.__init__(self, *args, **kwargs)</font>
<font color="red"> 326.         self.setFeature(handler.feature_external_ges, False)</font>
<font color="red"> 327.         self.setFeature(handler.feature_external_pes, False)</font>
<font color="black"> 328. </font>
<font color="green"> 329.     def start_doctype_decl(self, name, sysid, pubid, has_internal_subset):</font>
<font color="red"> 330.         raise DTDForbidden(name, sysid, pubid)</font>
<font color="black"> 331. </font>
<font color="green"> 332.     def entity_decl(self, name, is_parameter_entity, value, base,</font>
<font color="black"> 333.                     sysid, pubid, notation_name):</font>
<font color="red"> 334.         raise EntitiesForbidden(name, value, base, sysid, pubid, notation_name)</font>
<font color="black"> 335. </font>
<font color="green"> 336.     def unparsed_entity_decl(self, name, base, sysid, pubid, notation_name):</font>
<font color="black"> 337.         # expat 1.2</font>
<font color="red"> 338.         raise EntitiesForbidden(name, None, base, sysid, pubid, notation_name)</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def external_entity_ref_handler(self, context, base, sysid, pubid):</font>
<font color="red"> 341.         raise ExternalReferenceForbidden(context, base, sysid, pubid)</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def reset(self):</font>
<font color="red"> 344.         _ExpatParser.reset(self)</font>
<font color="red"> 345.         parser = self._parser</font>
<font color="red"> 346.         parser.StartDoctypeDeclHandler = self.start_doctype_decl</font>
<font color="red"> 347.         parser.EntityDeclHandler = self.entity_decl</font>
<font color="red"> 348.         parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl</font>
<font color="red"> 349.         parser.ExternalEntityRefHandler = self.external_entity_ref_handler</font>
<font color="black"> 350. </font>
<font color="black"> 351. </font>
<font color="green"> 352. class DefusedXmlException(ValueError):</font>
<font color="green"> 353.     &quot;&quot;&quot;Base exception.&quot;&quot;&quot;</font>
<font color="green"> 354.     def __repr__(self):</font>
<font color="red"> 355.         return str(self)</font>
<font color="black"> 356. </font>
<font color="black"> 357. </font>
<font color="green"> 358. class DTDForbidden(DefusedXmlException):</font>
<font color="green"> 359.     &quot;&quot;&quot;Document type definition is forbidden.&quot;&quot;&quot;</font>
<font color="green"> 360.     def __init__(self, name, sysid, pubid):</font>
<font color="red"> 361.         super(DTDForbidden, self).__init__()</font>
<font color="red"> 362.         self.name = name</font>
<font color="red"> 363.         self.sysid = sysid</font>
<font color="red"> 364.         self.pubid = pubid</font>
<font color="black"> 365. </font>
<font color="green"> 366.     def __str__(self):</font>
<font color="red"> 367.         tpl = &quot;DTDForbidden(name='{}', system_id={!r}, public_id={!r})&quot;</font>
<font color="red"> 368.         return tpl.format(self.name, self.sysid, self.pubid)</font>
<font color="black"> 369. </font>
<font color="black"> 370. </font>
<font color="green"> 371. class EntitiesForbidden(DefusedXmlException):</font>
<font color="green"> 372.     &quot;&quot;&quot;Entity definition is forbidden.&quot;&quot;&quot;</font>
<font color="green"> 373.     def __init__(self, name, value, base, sysid, pubid, notation_name):</font>
<font color="red"> 374.         super(EntitiesForbidden, self).__init__()</font>
<font color="red"> 375.         self.name = name</font>
<font color="red"> 376.         self.value = value</font>
<font color="red"> 377.         self.base = base</font>
<font color="red"> 378.         self.sysid = sysid</font>
<font color="red"> 379.         self.pubid = pubid</font>
<font color="red"> 380.         self.notation_name = notation_name</font>
<font color="black"> 381. </font>
<font color="green"> 382.     def __str__(self):</font>
<font color="red"> 383.         tpl = &quot;EntitiesForbidden(name='{}', system_id={!r}, public_id={!r})&quot;</font>
<font color="red"> 384.         return tpl.format(self.name, self.sysid, self.pubid)</font>
<font color="black"> 385. </font>
<font color="black"> 386. </font>
<font color="green"> 387. class ExternalReferenceForbidden(DefusedXmlException):</font>
<font color="green"> 388.     &quot;&quot;&quot;Resolving an external reference is forbidden.&quot;&quot;&quot;</font>
<font color="green"> 389.     def __init__(self, context, base, sysid, pubid):</font>
<font color="red"> 390.         super(ExternalReferenceForbidden, self).__init__()</font>
<font color="red"> 391.         self.context = context</font>
<font color="red"> 392.         self.base = base</font>
<font color="red"> 393.         self.sysid = sysid</font>
<font color="red"> 394.         self.pubid = pubid</font>
<font color="black"> 395. </font>
<font color="green"> 396.     def __str__(self):</font>
<font color="red"> 397.         tpl = &quot;ExternalReferenceForbidden(system_id='{}', public_id={})&quot;</font>
<font color="red"> 398.         return tpl.format(self.sysid, self.pubid)</font>
</pre>

