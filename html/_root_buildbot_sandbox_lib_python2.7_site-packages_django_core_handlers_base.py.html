source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/handlers/base.py</b><br>


file stats: <b>197 lines, 32 executed: 16.2% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import logging</font>
<font color="green">   4. import sys</font>
<font color="green">   5. import types</font>
<font color="green">   6. import warnings</font>
<font color="black">   7. </font>
<font color="green">   8. from django import http</font>
<font color="green">   9. from django.conf import settings</font>
<font color="green">  10. from django.core import signals, urlresolvers</font>
<font color="green">  11. from django.core.exceptions import (</font>
<font color="black">  12.     MiddlewareNotUsed, PermissionDenied, SuspiciousOperation,</font>
<font color="black">  13. )</font>
<font color="green">  14. from django.db import connections, transaction</font>
<font color="green">  15. from django.http.multipartparser import MultiPartParserError</font>
<font color="green">  16. from django.utils import six</font>
<font color="green">  17. from django.utils.deprecation import RemovedInDjango20Warning</font>
<font color="green">  18. from django.utils.encoding import force_text</font>
<font color="green">  19. from django.utils.module_loading import import_string</font>
<font color="green">  20. from django.views import debug</font>
<font color="black">  21. </font>
<font color="green">  22. logger = logging.getLogger('django.request')</font>
<font color="black">  23. </font>
<font color="black">  24. </font>
<font color="green">  25. class BaseHandler(object):</font>
<font color="black">  26.     # Changes that are always applied to a response (in this order).</font>
<font color="black">  27.     response_fixes = [</font>
<font color="green">  28.         http.conditional_content_removal,</font>
<font color="black">  29.     ]</font>
<font color="black">  30. </font>
<font color="green">  31.     def __init__(self):</font>
<font color="green">  32.         self._request_middleware = None</font>
<font color="green">  33.         self._view_middleware = None</font>
<font color="green">  34.         self._template_response_middleware = None</font>
<font color="green">  35.         self._response_middleware = None</font>
<font color="green">  36.         self._exception_middleware = None</font>
<font color="black">  37. </font>
<font color="green">  38.     def load_middleware(self):</font>
<font color="black">  39.         &quot;&quot;&quot;</font>
<font color="black">  40.         Populate middleware lists from settings.MIDDLEWARE_CLASSES.</font>
<font color="black">  41. </font>
<font color="black">  42.         Must be called after the environment is fixed (see __call__ in subclasses).</font>
<font color="black">  43.         &quot;&quot;&quot;</font>
<font color="red">  44.         self._view_middleware = []</font>
<font color="red">  45.         self._template_response_middleware = []</font>
<font color="red">  46.         self._response_middleware = []</font>
<font color="red">  47.         self._exception_middleware = []</font>
<font color="black">  48. </font>
<font color="red">  49.         request_middleware = []</font>
<font color="red">  50.         for middleware_path in settings.MIDDLEWARE_CLASSES:</font>
<font color="red">  51.             mw_class = import_string(middleware_path)</font>
<font color="red">  52.             try:</font>
<font color="red">  53.                 mw_instance = mw_class()</font>
<font color="red">  54.             except MiddlewareNotUsed as exc:</font>
<font color="red">  55.                 if settings.DEBUG:</font>
<font color="red">  56.                     if six.text_type(exc):</font>
<font color="red">  57.                         logger.debug('MiddlewareNotUsed(%r): %s', middleware_path, exc)</font>
<font color="black">  58.                     else:</font>
<font color="red">  59.                         logger.debug('MiddlewareNotUsed: %r', middleware_path)</font>
<font color="red">  60.                 continue</font>
<font color="black">  61. </font>
<font color="red">  62.             if hasattr(mw_instance, 'process_request'):</font>
<font color="red">  63.                 request_middleware.append(mw_instance.process_request)</font>
<font color="red">  64.             if hasattr(mw_instance, 'process_view'):</font>
<font color="red">  65.                 self._view_middleware.append(mw_instance.process_view)</font>
<font color="red">  66.             if hasattr(mw_instance, 'process_template_response'):</font>
<font color="red">  67.                 self._template_response_middleware.insert(0, mw_instance.process_template_response)</font>
<font color="red">  68.             if hasattr(mw_instance, 'process_response'):</font>
<font color="red">  69.                 self._response_middleware.insert(0, mw_instance.process_response)</font>
<font color="red">  70.             if hasattr(mw_instance, 'process_exception'):</font>
<font color="red">  71.                 self._exception_middleware.insert(0, mw_instance.process_exception)</font>
<font color="black">  72. </font>
<font color="black">  73.         # We only assign to this when initialization is complete as it is used</font>
<font color="black">  74.         # as a flag for initialization being complete.</font>
<font color="red">  75.         self._request_middleware = request_middleware</font>
<font color="black">  76. </font>
<font color="green">  77.     def make_view_atomic(self, view):</font>
<font color="red">  78.         non_atomic_requests = getattr(view, '_non_atomic_requests', set())</font>
<font color="red">  79.         for db in connections.all():</font>
<font color="red">  80.             if (db.settings_dict['ATOMIC_REQUESTS']</font>
<font color="red">  81.                     and db.alias not in non_atomic_requests):</font>
<font color="red">  82.                 view = transaction.atomic(using=db.alias)(view)</font>
<font color="red">  83.         return view</font>
<font color="black">  84. </font>
<font color="green">  85.     def get_exception_response(self, request, resolver, status_code, exception):</font>
<font color="red">  86.         try:</font>
<font color="red">  87.             callback, param_dict = resolver.resolve_error_handler(status_code)</font>
<font color="black">  88.             # Unfortunately, inspect.getargspec result is not trustable enough</font>
<font color="black">  89.             # depending on the callback wrapping in decorators (frequent for handlers).</font>
<font color="black">  90.             # Falling back on try/except:</font>
<font color="red">  91.             try:</font>
<font color="red">  92.                 response = callback(request, **dict(param_dict, exception=exception))</font>
<font color="red">  93.             except TypeError:</font>
<font color="red">  94.                 warnings.warn(</font>
<font color="red">  95.                     &quot;Error handlers should accept an exception parameter. Update &quot;</font>
<font color="black">  96.                     &quot;your code as this parameter will be required in Django 2.0&quot;,</font>
<font color="red">  97.                     RemovedInDjango20Warning, stacklevel=2</font>
<font color="black">  98.                 )</font>
<font color="red">  99.                 response = callback(request, **param_dict)</font>
<font color="red"> 100.         except:</font>
<font color="red"> 101.             signals.got_request_exception.send(sender=self.__class__, request=request)</font>
<font color="red"> 102.             response = self.handle_uncaught_exception(request, resolver, sys.exc_info())</font>
<font color="black"> 103. </font>
<font color="red"> 104.         return response</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def get_response(self, request):</font>
<font color="black"> 107.         &quot;Returns an HttpResponse object for the given HttpRequest&quot;</font>
<font color="black"> 108. </font>
<font color="black"> 109.         # Setup default url resolver for this thread, this code is outside</font>
<font color="black"> 110.         # the try/except so we don't get a spurious &quot;unbound local</font>
<font color="black"> 111.         # variable&quot; exception in the event an exception is raised before</font>
<font color="black"> 112.         # resolver is set</font>
<font color="red"> 113.         urlconf = settings.ROOT_URLCONF</font>
<font color="red"> 114.         urlresolvers.set_urlconf(urlconf)</font>
<font color="red"> 115.         resolver = urlresolvers.get_resolver(urlconf)</font>
<font color="black"> 116.         # Use a flag to check if the response was rendered to prevent</font>
<font color="black"> 117.         # multiple renderings or to force rendering if necessary.</font>
<font color="red"> 118.         response_is_rendered = False</font>
<font color="red"> 119.         try:</font>
<font color="red"> 120.             response = None</font>
<font color="black"> 121.             # Apply request middleware</font>
<font color="red"> 122.             for middleware_method in self._request_middleware:</font>
<font color="red"> 123.                 response = middleware_method(request)</font>
<font color="red"> 124.                 if response:</font>
<font color="red"> 125.                     break</font>
<font color="black"> 126. </font>
<font color="red"> 127.             if response is None:</font>
<font color="red"> 128.                 if hasattr(request, 'urlconf'):</font>
<font color="black"> 129.                     # Reset url resolver with a custom URLconf.</font>
<font color="red"> 130.                     urlconf = request.urlconf</font>
<font color="red"> 131.                     urlresolvers.set_urlconf(urlconf)</font>
<font color="red"> 132.                     resolver = urlresolvers.get_resolver(urlconf)</font>
<font color="black"> 133. </font>
<font color="red"> 134.                 resolver_match = resolver.resolve(request.path_info)</font>
<font color="red"> 135.                 callback, callback_args, callback_kwargs = resolver_match</font>
<font color="red"> 136.                 request.resolver_match = resolver_match</font>
<font color="black"> 137. </font>
<font color="black"> 138.                 # Apply view middleware</font>
<font color="red"> 139.                 for middleware_method in self._view_middleware:</font>
<font color="red"> 140.                     response = middleware_method(request, callback, callback_args, callback_kwargs)</font>
<font color="red"> 141.                     if response:</font>
<font color="red"> 142.                         break</font>
<font color="black"> 143. </font>
<font color="red"> 144.             if response is None:</font>
<font color="red"> 145.                 wrapped_callback = self.make_view_atomic(callback)</font>
<font color="red"> 146.                 try:</font>
<font color="red"> 147.                     response = wrapped_callback(request, *callback_args, **callback_kwargs)</font>
<font color="red"> 148.                 except Exception as e:</font>
<font color="red"> 149.                     response = self.process_exception_by_middleware(e, request)</font>
<font color="black"> 150. </font>
<font color="black"> 151.             # Complain if the view returned None (a common error).</font>
<font color="red"> 152.             if response is None:</font>
<font color="red"> 153.                 if isinstance(callback, types.FunctionType):    # FBV</font>
<font color="red"> 154.                     view_name = callback.__name__</font>
<font color="black"> 155.                 else:                                           # CBV</font>
<font color="red"> 156.                     view_name = callback.__class__.__name__ + '.__call__'</font>
<font color="red"> 157.                 raise ValueError(&quot;The view %s.%s didn't return an HttpResponse object. It returned None instead.&quot;</font>
<font color="red"> 158.                                  % (callback.__module__, view_name))</font>
<font color="black"> 159. </font>
<font color="black"> 160.             # If the response supports deferred rendering, apply template</font>
<font color="black"> 161.             # response middleware and then render the response</font>
<font color="red"> 162.             if hasattr(response, 'render') and callable(response.render):</font>
<font color="red"> 163.                 for middleware_method in self._template_response_middleware:</font>
<font color="red"> 164.                     response = middleware_method(request, response)</font>
<font color="black"> 165.                     # Complain if the template response middleware returned None (a common error).</font>
<font color="red"> 166.                     if response is None:</font>
<font color="red"> 167.                         raise ValueError(</font>
<font color="red"> 168.                             &quot;%s.process_template_response didn't return an &quot;</font>
<font color="black"> 169.                             &quot;HttpResponse object. It returned None instead.&quot;</font>
<font color="red"> 170.                             % (middleware_method.__self__.__class__.__name__))</font>
<font color="red"> 171.                 try:</font>
<font color="red"> 172.                     response = response.render()</font>
<font color="red"> 173.                 except Exception as e:</font>
<font color="red"> 174.                     response = self.process_exception_by_middleware(e, request)</font>
<font color="black"> 175. </font>
<font color="red"> 176.                 response_is_rendered = True</font>
<font color="black"> 177. </font>
<font color="red"> 178.         except http.Http404 as exc:</font>
<font color="red"> 179.             logger.warning('Not Found: %s', request.path,</font>
<font color="red"> 180.                         extra={</font>
<font color="red"> 181.                             'status_code': 404,</font>
<font color="red"> 182.                             'request': request</font>
<font color="black"> 183.                         })</font>
<font color="red"> 184.             if settings.DEBUG:</font>
<font color="red"> 185.                 response = debug.technical_404_response(request, exc)</font>
<font color="black"> 186.             else:</font>
<font color="red"> 187.                 response = self.get_exception_response(request, resolver, 404, exc)</font>
<font color="black"> 188. </font>
<font color="red"> 189.         except PermissionDenied as exc:</font>
<font color="red"> 190.             logger.warning(</font>
<font color="red"> 191.                 'Forbidden (Permission denied): %s', request.path,</font>
<font color="red"> 192.                 extra={</font>
<font color="red"> 193.                     'status_code': 403,</font>
<font color="red"> 194.                     'request': request</font>
<font color="black"> 195.                 })</font>
<font color="red"> 196.             response = self.get_exception_response(request, resolver, 403, exc)</font>
<font color="black"> 197. </font>
<font color="red"> 198.         except MultiPartParserError as exc:</font>
<font color="red"> 199.             logger.warning(</font>
<font color="red"> 200.                 'Bad request (Unable to parse request body): %s', request.path,</font>
<font color="red"> 201.                 extra={</font>
<font color="red"> 202.                     'status_code': 400,</font>
<font color="red"> 203.                     'request': request</font>
<font color="black"> 204.                 })</font>
<font color="red"> 205.             response = self.get_exception_response(request, resolver, 400, exc)</font>
<font color="black"> 206. </font>
<font color="red"> 207.         except SuspiciousOperation as exc:</font>
<font color="black"> 208.             # The request logger receives events for any problematic request</font>
<font color="black"> 209.             # The security logger receives events for all SuspiciousOperations</font>
<font color="red"> 210.             security_logger = logging.getLogger('django.security.%s' %</font>
<font color="red"> 211.                             exc.__class__.__name__)</font>
<font color="red"> 212.             security_logger.error(</font>
<font color="red"> 213.                 force_text(exc),</font>
<font color="red"> 214.                 extra={</font>
<font color="red"> 215.                     'status_code': 400,</font>
<font color="red"> 216.                     'request': request</font>
<font color="black"> 217.                 })</font>
<font color="red"> 218.             if settings.DEBUG:</font>
<font color="red"> 219.                 return debug.technical_500_response(request, *sys.exc_info(), status_code=400)</font>
<font color="black"> 220. </font>
<font color="red"> 221.             response = self.get_exception_response(request, resolver, 400, exc)</font>
<font color="black"> 222. </font>
<font color="red"> 223.         except SystemExit:</font>
<font color="black"> 224.             # Allow sys.exit() to actually exit. See tickets #1023 and #4701</font>
<font color="red"> 225.             raise</font>
<font color="black"> 226. </font>
<font color="red"> 227.         except:  # Handle everything else.</font>
<font color="black"> 228.             # Get the exception info now, in case another exception is thrown later.</font>
<font color="red"> 229.             signals.got_request_exception.send(sender=self.__class__, request=request)</font>
<font color="red"> 230.             response = self.handle_uncaught_exception(request, resolver, sys.exc_info())</font>
<font color="black"> 231. </font>
<font color="red"> 232.         try:</font>
<font color="black"> 233.             # Apply response middleware, regardless of the response</font>
<font color="red"> 234.             for middleware_method in self._response_middleware:</font>
<font color="red"> 235.                 response = middleware_method(request, response)</font>
<font color="black"> 236.                 # Complain if the response middleware returned None (a common error).</font>
<font color="red"> 237.                 if response is None:</font>
<font color="red"> 238.                     raise ValueError(</font>
<font color="red"> 239.                         &quot;%s.process_response didn't return an &quot;</font>
<font color="black"> 240.                         &quot;HttpResponse object. It returned None instead.&quot;</font>
<font color="red"> 241.                         % (middleware_method.__self__.__class__.__name__))</font>
<font color="red"> 242.             response = self.apply_response_fixes(request, response)</font>
<font color="red"> 243.         except:  # Any exception should be gathered and handled</font>
<font color="red"> 244.             signals.got_request_exception.send(sender=self.__class__, request=request)</font>
<font color="red"> 245.             response = self.handle_uncaught_exception(request, resolver, sys.exc_info())</font>
<font color="black"> 246. </font>
<font color="red"> 247.         response._closable_objects.append(request)</font>
<font color="black"> 248. </font>
<font color="black"> 249.         # If the exception handler returns a TemplateResponse that has not</font>
<font color="black"> 250.         # been rendered, force it to be rendered.</font>
<font color="red"> 251.         if not response_is_rendered and callable(getattr(response, 'render', None)):</font>
<font color="red"> 252.             response = response.render()</font>
<font color="black"> 253. </font>
<font color="red"> 254.         return response</font>
<font color="black"> 255. </font>
<font color="green"> 256.     def process_exception_by_middleware(self, exception, request):</font>
<font color="black"> 257.         &quot;&quot;&quot;</font>
<font color="black"> 258.         Pass the exception to the exception middleware. If no middleware</font>
<font color="black"> 259.         return a response for this exception, raise it.</font>
<font color="black"> 260.         &quot;&quot;&quot;</font>
<font color="red"> 261.         for middleware_method in self._exception_middleware:</font>
<font color="red"> 262.             response = middleware_method(request, exception)</font>
<font color="red"> 263.             if response:</font>
<font color="red"> 264.                 return response</font>
<font color="red"> 265.         raise</font>
<font color="black"> 266. </font>
<font color="green"> 267.     def handle_uncaught_exception(self, request, resolver, exc_info):</font>
<font color="black"> 268.         &quot;&quot;&quot;</font>
<font color="black"> 269.         Processing for any otherwise uncaught exceptions (those that will</font>
<font color="black"> 270.         generate HTTP 500 responses). Can be overridden by subclasses who want</font>
<font color="black"> 271.         customised 500 handling.</font>
<font color="black"> 272. </font>
<font color="black"> 273.         Be *very* careful when overriding this because the error could be</font>
<font color="black"> 274.         caused by anything, so assuming something like the database is always</font>
<font color="black"> 275.         available would be an error.</font>
<font color="black"> 276.         &quot;&quot;&quot;</font>
<font color="red"> 277.         if settings.DEBUG_PROPAGATE_EXCEPTIONS:</font>
<font color="red"> 278.             raise</font>
<font color="black"> 279. </font>
<font color="red"> 280.         logger.error('Internal Server Error: %s', request.path,</font>
<font color="red"> 281.             exc_info=exc_info,</font>
<font color="red"> 282.             extra={</font>
<font color="red"> 283.                 'status_code': 500,</font>
<font color="red"> 284.                 'request': request</font>
<font color="black"> 285.             }</font>
<font color="black"> 286.         )</font>
<font color="black"> 287. </font>
<font color="red"> 288.         if settings.DEBUG:</font>
<font color="red"> 289.             return debug.technical_500_response(request, *exc_info)</font>
<font color="black"> 290. </font>
<font color="black"> 291.         # If Http500 handler is not installed, re-raise last exception</font>
<font color="red"> 292.         if resolver.urlconf_module is None:</font>
<font color="red"> 293.             six.reraise(*exc_info)</font>
<font color="black"> 294.         # Return an HttpResponse that displays a friendly error message.</font>
<font color="red"> 295.         callback, param_dict = resolver.resolve_error_handler(500)</font>
<font color="red"> 296.         return callback(request, **param_dict)</font>
<font color="black"> 297. </font>
<font color="green"> 298.     def apply_response_fixes(self, request, response):</font>
<font color="black"> 299.         &quot;&quot;&quot;</font>
<font color="black"> 300.         Applies each of the functions in self.response_fixes to the request and</font>
<font color="black"> 301.         response, modifying the response in the process. Returns the new</font>
<font color="black"> 302.         response.</font>
<font color="black"> 303.         &quot;&quot;&quot;</font>
<font color="red"> 304.         for func in self.response_fixes:</font>
<font color="red"> 305.             response = func(request, response)</font>
<font color="red"> 306.         return response</font>
</pre>

