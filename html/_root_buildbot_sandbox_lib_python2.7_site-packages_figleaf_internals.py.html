source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/figleaf/internals.py</b><br>


file stats: <b>127 lines, 2 executed: 1.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Coverage tracking internals.</font>
<font color="red">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="red">   5. import sys</font>
<font color="red">   6. import threading</font>
<font color="black">   7. </font>
<font color="red">   8. err = sys.stderr</font>
<font color="black">   9. </font>
<font color="red">  10. import types, symbol</font>
<font color="black">  11. </font>
<font color="black">  12. # use builtin sets if in &gt;= 2.4, otherwise use 'sets' module.</font>
<font color="red">  13. try:</font>
<font color="red">  14.     set()</font>
<font color="red">  15. except NameError:</font>
<font color="red">  16.     from sets import Set as set</font>
<font color="black">  17. </font>
<font color="red">  18. def get_interesting_lines(code):</font>
<font color="black">  19.     &quot;&quot;&quot;</font>
<font color="black">  20.     Count 'interesting' lines of Python in a code object, where</font>
<font color="black">  21.     'interesting' is defined as 'lines that could possibly be</font>
<font color="black">  22.     executed'.</font>
<font color="black">  23. </font>
<font color="black">  24.     This is done by dissassembling the code objecte and returning</font>
<font color="black">  25.     line numbers.</font>
<font color="black">  26.     &quot;&quot;&quot;</font>
<font color="black">  27. </font>
<font color="black">  28.     # clean up weird end-of-file issues</font>
<font color="black">  29. </font>
<font color="red">  30.     lines = set([ l for (o, l) in findlinestarts(code) ])</font>
<font color="red">  31.     for const in code.co_consts:</font>
<font color="red">  32.         if type(const) == types.CodeType:</font>
<font color="red">  33.             lines.update(get_interesting_lines(const))</font>
<font color="black">  34. </font>
<font color="red">  35.     return lines</font>
<font color="black">  36. </font>
<font color="red">  37. def findlinestarts(code):</font>
<font color="black">  38.     &quot;&quot;&quot;Find the offsets in a byte code which are start of lines in the source.</font>
<font color="black">  39. </font>
<font color="black">  40.     Generate pairs (offset, lineno) as described in Python/compile.c.</font>
<font color="black">  41. </font>
<font color="black">  42.     CTB -- swiped from Python 2.5, module 'dis', so that earlier versions</font>
<font color="black">  43.     of Python could use the function, too.</font>
<font color="black">  44.     &quot;&quot;&quot;</font>
<font color="red">  45.     byte_increments = [ord(c) for c in code.co_lnotab[0::2]]</font>
<font color="red">  46.     line_increments = [ord(c) for c in code.co_lnotab[1::2]]</font>
<font color="black">  47. </font>
<font color="red">  48.     lastlineno = None</font>
<font color="red">  49.     lineno = code.co_firstlineno</font>
<font color="red">  50.     addr = 0</font>
<font color="red">  51.     for byte_incr, line_incr in zip(byte_increments, line_increments):</font>
<font color="red">  52.         if byte_incr:</font>
<font color="red">  53.             if lineno != lastlineno:</font>
<font color="red">  54.                 yield (addr, lineno)</font>
<font color="red">  55.                 lastlineno = lineno</font>
<font color="red">  56.             addr += byte_incr</font>
<font color="red">  57.         lineno += line_incr</font>
<font color="red">  58.     if lineno != lastlineno:</font>
<font color="red">  59.         yield (addr, lineno)</font>
<font color="black">  60. </font>
<font color="red">  61. class CodeTracer:</font>
<font color="black">  62.     &quot;&quot;&quot;</font>
<font color="black">  63.     Basic mechanisms for code coverage tracking, using sys.settrace.</font>
<font color="red">  64.     &quot;&quot;&quot;</font>
<font color="red">  65.     def __init__(self, exclude_prefix, include_only_prefix):</font>
<font color="red">  66.         self.common = self.c = set()</font>
<font color="red">  67.         self.section_name = None</font>
<font color="red">  68.         self.sections = {}</font>
<font color="black">  69. </font>
<font color="red">  70.         self.started = False</font>
<font color="black">  71. </font>
<font color="red">  72.         assert not (exclude_prefix and include_only_prefix), \</font>
<font color="red">  73.                &quot;mutually exclusive&quot;</font>
<font color="black">  74. </font>
<font color="red">  75.         self.excl = exclude_prefix</font>
<font color="red">  76.         self.incl = include_only_prefix</font>
<font color="black">  77. </font>
<font color="red">  78.     def start(self):</font>
<font color="black">  79.         &quot;&quot;&quot;</font>
<font color="black">  80.         Start recording.</font>
<font color="black">  81.         &quot;&quot;&quot;</font>
<font color="red">  82.         if not self.started:</font>
<font color="red">  83.             self.started = True</font>
<font color="black">  84. </font>
<font color="red">  85.             if self.excl and not self.incl:</font>
<font color="red">  86.                 global_trace_fn = self.g1</font>
<font color="red">  87.             elif self.incl and not self.excl:</font>
<font color="red">  88.                 global_trace_fn = self.g2</font>
<font color="black">  89.             else:</font>
<font color="red">  90.                 global_trace_fn = self.g0</font>
<font color="black">  91. </font>
<font color="red">  92.             sys.settrace(global_trace_fn)</font>
<font color="black">  93. </font>
<font color="red">  94.             if hasattr(threading, 'settrace'):</font>
<font color="red">  95.                 threading.settrace(global_trace_fn)</font>
<font color="black">  96. </font>
<font color="red">  97.     def stop(self):</font>
<font color="green">  98.         if self.started:</font>
<font color="green">  99.             sys.settrace(None)</font>
<font color="black"> 100. </font>
<font color="red"> 101.             if hasattr(threading, 'settrace'):</font>
<font color="red"> 102.                 threading.settrace(None)</font>
<font color="black"> 103. </font>
<font color="red"> 104.             self.started = False</font>
<font color="red"> 105.             self.stop_section()</font>
<font color="black"> 106. </font>
<font color="red"> 107.     def g0(self, f, e, a):</font>
<font color="black"> 108.         &quot;&quot;&quot;</font>
<font color="black"> 109.         global trace function, no exclude/include info.</font>
<font color="black"> 110. </font>
<font color="black"> 111.         f == frame, e == event, a == arg        .</font>
<font color="black"> 112.         &quot;&quot;&quot;</font>
<font color="red"> 113.         if e == 'call':</font>
<font color="red"> 114.             return self.t</font>
<font color="black"> 115. </font>
<font color="red"> 116.     def g1(self, f, e, a):</font>
<font color="black"> 117.         &quot;&quot;&quot;</font>
<font color="black"> 118.         global trace function like g0, but ignores files starting with</font>
<font color="black"> 119.         'self.excl'.</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="red"> 121.         if e == 'call':</font>
<font color="red"> 122.             excl = self.excl</font>
<font color="red"> 123.             path = f.f_globals.get('__file__')</font>
<font color="red"> 124.             if path is None:</font>
<font color="red"> 125.                 path = f.f_code.co_filename</font>
<font color="black"> 126. </font>
<font color="red"> 127.             if excl and path.startswith(excl):</font>
<font color="red"> 128.                 return</font>
<font color="black"> 129. </font>
<font color="red"> 130.             return self.t</font>
<font color="black"> 131. </font>
<font color="red"> 132.     def g2(self, f, e, a):</font>
<font color="black"> 133.         &quot;&quot;&quot;</font>
<font color="black"> 134.         global trace function like g0, but only records files starting with</font>
<font color="black"> 135.         'self.incl'.</font>
<font color="black"> 136.         &quot;&quot;&quot;</font>
<font color="red"> 137.         if e == 'call':</font>
<font color="red"> 138.             incl = self.incl</font>
<font color="red"> 139.             if incl and f.f_code.co_filename.startswith(incl):</font>
<font color="red"> 140.                 return self.t</font>
<font color="black"> 141. </font>
<font color="red"> 142.     def t(self, f, e, a):</font>
<font color="black"> 143.         &quot;&quot;&quot;</font>
<font color="black"> 144.         local trace function.</font>
<font color="black"> 145.         &quot;&quot;&quot;</font>
<font color="red"> 146.         if e is 'line':</font>
<font color="red"> 147.             self.c.add((f.f_code.co_filename, f.f_lineno))</font>
<font color="red"> 148.         return self.t</font>
<font color="black"> 149. </font>
<font color="red"> 150.     def clear(self):</font>
<font color="black"> 151.         &quot;&quot;&quot;</font>
<font color="black"> 152.         wipe out coverage info</font>
<font color="black"> 153.         &quot;&quot;&quot;</font>
<font color="black"> 154. </font>
<font color="red"> 155.         self.c = {}</font>
<font color="black"> 156. </font>
<font color="red"> 157.     def start_section(self, name):</font>
<font color="red"> 158.         self.stop_section()</font>
<font color="black"> 159. </font>
<font color="red"> 160.         self.section_name = name</font>
<font color="red"> 161.         self.c = self.sections.get(name, set())</font>
<font color="black"> 162. </font>
<font color="red"> 163.     def stop_section(self):</font>
<font color="red"> 164.         if self.section_name:</font>
<font color="red"> 165.             self.sections[self.section_name] = self.c</font>
<font color="red"> 166.             self.section_name = None</font>
<font color="red"> 167.             self.c = self.common</font>
<font color="black"> 168. </font>
<font color="red"> 169. class CoverageData:</font>
<font color="black"> 170.     &quot;&quot;&quot;</font>
<font color="black"> 171.     A class to manipulate and combine data from the CodeTracer object.</font>
<font color="black"> 172. </font>
<font color="black"> 173.     In general, do not pickle this object; it's simpler and more</font>
<font color="black"> 174.     straightforward to just pass the basic Python objects around</font>
<font color="black"> 175.     (e.g. CoverageData.common, a set, and CoverageData.sections, a</font>
<font color="black"> 176.     dictionary of sets).</font>
<font color="red"> 177.     &quot;&quot;&quot;</font>
<font color="red"> 178.     def __init__(self, trace_obj=None):</font>
<font color="red"> 179.         self.common = set()</font>
<font color="red"> 180.         self.sections = {}</font>
<font color="black"> 181. </font>
<font color="red"> 182.         if trace_obj:</font>
<font color="red"> 183.             self.update(trace_obj)</font>
<font color="black"> 184. </font>
<font color="red"> 185.     def update(self, trace_obj):</font>
<font color="black"> 186.         # transfer common-block code coverage -- if no sections are set,</font>
<font color="black"> 187.         # this will be all of the code coverage info.</font>
<font color="red"> 188.         self.common.update(trace_obj.common)</font>
<font color="black"> 189. </font>
<font color="black"> 190.         # update our internal section dictionary with the (filename, line_no)</font>
<font color="black"> 191.         # pairs from the section coverage as well.</font>
<font color="black"> 192. </font>
<font color="red"> 193.         for section_name, section_d in trace_obj.sections.items():</font>
<font color="red"> 194.             section_set = self.sections.get(section_name, set())</font>
<font color="red"> 195.             section_set.update(section_d)</font>
<font color="red"> 196.             self.sections[section_name] = section_set</font>
<font color="black"> 197. </font>
<font color="red"> 198.     def gather_files(self, name=None):</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="black"> 200.         Return the dictionary of lines of executed code; the dict</font>
<font color="black"> 201.         keys are filenames and values are sets containing individual</font>
<font color="black"> 202.         (integer) line numbers.</font>
<font color="black"> 203. </font>
<font color="black"> 204.         'name', if set, is the desired section name from which to gather</font>
<font color="black"> 205.         coverage info.</font>
<font color="black"> 206.         &quot;&quot;&quot;</font>
<font color="red"> 207.         cov = set()</font>
<font color="red"> 208.         cov.update(self.common)</font>
<font color="black"> 209. </font>
<font color="red"> 210.         if name is None:</font>
<font color="red"> 211.             for section_name, coverage_set in self.sections.items():</font>
<font color="red"> 212.                 cov.update(coverage_set)</font>
<font color="black"> 213.         else:</font>
<font color="red"> 214.             coverage_set = self.sections.get(name, set())</font>
<font color="red"> 215.             cov.update(coverage_set)</font>
<font color="black"> 216. </font>
<font color="black"> 217. #        cov = list(cov)</font>
<font color="black"> 218. #        cov.sort()</font>
<font color="black"> 219. </font>
<font color="red"> 220.         files = {}</font>
<font color="red"> 221.         for (filename, line) in cov:    # @CTB could optimize</font>
<font color="red"> 222.             d = files.get(filename, set())</font>
<font color="red"> 223.             d.add(line)</font>
<font color="red"> 224.             files[filename] = d</font>
<font color="black"> 225. </font>
<font color="red"> 226.         return files</font>
<font color="black"> 227. </font>
<font color="red"> 228.     def gather_sections(self, file):</font>
<font color="black"> 229.         &quot;&quot;&quot;</font>
<font color="black"> 230.         Return a dictionary of sets containing section coverage information for</font>
<font color="black"> 231.         a specific file.  Dict keys are sections, and the dict values are</font>
<font color="black"> 232.         sets containing (integer) line numbers.</font>
<font color="black"> 233.         &quot;&quot;&quot;</font>
<font color="red"> 234.         sections = {}</font>
<font color="red"> 235.         for k, c in self.sections.items():</font>
<font color="red"> 236.             s = set()</font>
<font color="red"> 237.             for (filename, line) in c.keys():</font>
<font color="red"> 238.                 if filename == file:</font>
<font color="red"> 239.                     s.add(line)</font>
<font color="red"> 240.             sections[k] = s</font>
<font color="red"> 241.         return sections</font>
</pre>

