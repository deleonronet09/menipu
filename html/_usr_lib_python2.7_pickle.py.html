source file: <b>/usr/lib/python2.7/pickle.py</b><br>


file stats: <b>880 lines, 272 executed: 30.9% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Create portable serialized representations of Python objects.</font>
<font color="black">   2. </font>
<font color="black">   3. See module cPickle for a (much) faster implementation.</font>
<font color="black">   4. See module copy_reg for a mechanism for registering custom picklers.</font>
<font color="black">   5. See module pickletools source for extensive comments.</font>
<font color="black">   6. </font>
<font color="black">   7. Classes:</font>
<font color="black">   8. </font>
<font color="black">   9.     Pickler</font>
<font color="black">  10.     Unpickler</font>
<font color="black">  11. </font>
<font color="black">  12. Functions:</font>
<font color="black">  13. </font>
<font color="black">  14.     dump(object, file)</font>
<font color="black">  15.     dumps(object) -&gt; string</font>
<font color="black">  16.     load(file) -&gt; object</font>
<font color="black">  17.     loads(string) -&gt; object</font>
<font color="black">  18. </font>
<font color="black">  19. Misc variables:</font>
<font color="black">  20. </font>
<font color="black">  21.     __version__</font>
<font color="black">  22.     format_version</font>
<font color="black">  23.     compatible_formats</font>
<font color="black">  24. </font>
<font color="green">  25. &quot;&quot;&quot;</font>
<font color="black">  26. </font>
<font color="green">  27. __version__ = &quot;$Revision: 72223 $&quot;       # Code version</font>
<font color="black">  28. </font>
<font color="green">  29. from types import *</font>
<font color="green">  30. from copy_reg import dispatch_table</font>
<font color="green">  31. from copy_reg import _extension_registry, _inverted_registry, _extension_cache</font>
<font color="green">  32. import marshal</font>
<font color="green">  33. import sys</font>
<font color="green">  34. import struct</font>
<font color="green">  35. import re</font>
<font color="black">  36. </font>
<font color="green">  37. __all__ = [&quot;PickleError&quot;, &quot;PicklingError&quot;, &quot;UnpicklingError&quot;, &quot;Pickler&quot;,</font>
<font color="green">  38.            &quot;Unpickler&quot;, &quot;dump&quot;, &quot;dumps&quot;, &quot;load&quot;, &quot;loads&quot;]</font>
<font color="black">  39. </font>
<font color="black">  40. # These are purely informational; no code uses these.</font>
<font color="green">  41. format_version = &quot;2.0&quot;                  # File format version we write</font>
<font color="green">  42. compatible_formats = [&quot;1.0&quot;,            # Original protocol 0</font>
<font color="green">  43.                       &quot;1.1&quot;,            # Protocol 0 with INST added</font>
<font color="green">  44.                       &quot;1.2&quot;,            # Original protocol 1</font>
<font color="green">  45.                       &quot;1.3&quot;,            # Protocol 1 with BINFLOAT added</font>
<font color="green">  46.                       &quot;2.0&quot;,            # Protocol 2</font>
<font color="black">  47.                       ]                 # Old format versions we can read</font>
<font color="black">  48. </font>
<font color="black">  49. # Keep in synch with cPickle.  This is the highest protocol number we</font>
<font color="black">  50. # know how to read.</font>
<font color="green">  51. HIGHEST_PROTOCOL = 2</font>
<font color="black">  52. </font>
<font color="black">  53. # Why use struct.pack() for pickling but marshal.loads() for</font>
<font color="black">  54. # unpickling?  struct.pack() is 40% faster than marshal.dumps(), but</font>
<font color="black">  55. # marshal.loads() is twice as fast as struct.unpack()!</font>
<font color="green">  56. mloads = marshal.loads</font>
<font color="black">  57. </font>
<font color="green">  58. class PickleError(Exception):</font>
<font color="green">  59.     &quot;&quot;&quot;A common base class for the other pickling exceptions.&quot;&quot;&quot;</font>
<font color="green">  60.     pass</font>
<font color="black">  61. </font>
<font color="green">  62. class PicklingError(PickleError):</font>
<font color="black">  63.     &quot;&quot;&quot;This exception is raised when an unpicklable object is passed to the</font>
<font color="black">  64.     dump() method.</font>
<font color="black">  65. </font>
<font color="green">  66.     &quot;&quot;&quot;</font>
<font color="green">  67.     pass</font>
<font color="black">  68. </font>
<font color="green">  69. class UnpicklingError(PickleError):</font>
<font color="black">  70.     &quot;&quot;&quot;This exception is raised when there is a problem unpickling an object,</font>
<font color="black">  71.     such as a security violation.</font>
<font color="black">  72. </font>
<font color="black">  73.     Note that other exceptions may also be raised during unpickling, including</font>
<font color="black">  74.     (but not necessarily limited to) AttributeError, EOFError, ImportError,</font>
<font color="black">  75.     and IndexError.</font>
<font color="black">  76. </font>
<font color="green">  77.     &quot;&quot;&quot;</font>
<font color="green">  78.     pass</font>
<font color="black">  79. </font>
<font color="black">  80. # An instance of _Stop is raised by Unpickler.load_stop() in response to</font>
<font color="black">  81. # the STOP opcode, passing the object that is the result of unpickling.</font>
<font color="green">  82. class _Stop(Exception):</font>
<font color="green">  83.     def __init__(self, value):</font>
<font color="red">  84.         self.value = value</font>
<font color="black">  85. </font>
<font color="black">  86. # Jython has PyStringMap; it's a dict subclass with string keys</font>
<font color="green">  87. try:</font>
<font color="green">  88.     from org.python.core import PyStringMap</font>
<font color="green">  89. except ImportError:</font>
<font color="green">  90.     PyStringMap = None</font>
<font color="black">  91. </font>
<font color="black">  92. # UnicodeType may or may not be exported (normally imported from types)</font>
<font color="green">  93. try:</font>
<font color="green">  94.     UnicodeType</font>
<font color="red">  95. except NameError:</font>
<font color="red">  96.     UnicodeType = None</font>
<font color="black">  97. </font>
<font color="black">  98. # Pickle opcodes.  See pickletools.py for extensive docs.  The listing</font>
<font color="black">  99. # here is in kind-of alphabetical order of 1-character pickle code.</font>
<font color="black"> 100. # pickletools groups them by purpose.</font>
<font color="black"> 101. </font>
<font color="green"> 102. MARK            = '('   # push special markobject on stack</font>
<font color="green"> 103. STOP            = '.'   # every pickle ends with STOP</font>
<font color="green"> 104. POP             = '0'   # discard topmost stack item</font>
<font color="green"> 105. POP_MARK        = '1'   # discard stack top through topmost markobject</font>
<font color="green"> 106. DUP             = '2'   # duplicate top stack item</font>
<font color="green"> 107. FLOAT           = 'F'   # push float object; decimal string argument</font>
<font color="green"> 108. INT             = 'I'   # push integer or bool; decimal string argument</font>
<font color="green"> 109. BININT          = 'J'   # push four-byte signed int</font>
<font color="green"> 110. BININT1         = 'K'   # push 1-byte unsigned int</font>
<font color="green"> 111. LONG            = 'L'   # push long; decimal string argument</font>
<font color="green"> 112. BININT2         = 'M'   # push 2-byte unsigned int</font>
<font color="green"> 113. NONE            = 'N'   # push None</font>
<font color="green"> 114. PERSID          = 'P'   # push persistent object; id is taken from string arg</font>
<font color="green"> 115. BINPERSID       = 'Q'   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stack</font>
<font color="green"> 116. REDUCE          = 'R'   # apply callable to argtuple, both on stack</font>
<font color="green"> 117. STRING          = 'S'   # push string; NL-terminated string argument</font>
<font color="green"> 118. BINSTRING       = 'T'   # push string; counted binary string argument</font>
<font color="green"> 119. SHORT_BINSTRING = 'U'   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes</font>
<font color="green"> 120. UNICODE         = 'V'   # push Unicode string; raw-unicode-escaped'd argument</font>
<font color="green"> 121. BINUNICODE      = 'X'   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argument</font>
<font color="green"> 122. APPEND          = 'a'   # append stack top to list below it</font>
<font color="green"> 123. BUILD           = 'b'   # call __setstate__ or __dict__.update()</font>
<font color="green"> 124. GLOBAL          = 'c'   # push self.find_class(modname, name); 2 string args</font>
<font color="green"> 125. DICT            = 'd'   # build a dict from stack items</font>
<font color="green"> 126. EMPTY_DICT      = '}'   # push empty dict</font>
<font color="green"> 127. APPENDS         = 'e'   # extend list on stack by topmost stack slice</font>
<font color="green"> 128. GET             = 'g'   # push item from memo on stack; index is string arg</font>
<font color="green"> 129. BINGET          = 'h'   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte arg</font>
<font color="green"> 130. INST            = 'i'   # build &amp; push class instance</font>
<font color="green"> 131. LONG_BINGET     = 'j'   # push item from memo on stack; index is 4-byte arg</font>
<font color="green"> 132. LIST            = 'l'   # build list from topmost stack items</font>
<font color="green"> 133. EMPTY_LIST      = ']'   # push empty list</font>
<font color="green"> 134. OBJ             = 'o'   # build &amp; push class instance</font>
<font color="green"> 135. PUT             = 'p'   # store stack top in memo; index is string arg</font>
<font color="green"> 136. BINPUT          = 'q'   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg</font>
<font color="green"> 137. LONG_BINPUT     = 'r'   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte arg</font>
<font color="green"> 138. SETITEM         = 's'   # add key+value pair to dict</font>
<font color="green"> 139. TUPLE           = 't'   # build tuple from topmost stack items</font>
<font color="green"> 140. EMPTY_TUPLE     = ')'   # push empty tuple</font>
<font color="green"> 141. SETITEMS        = 'u'   # modify dict by adding topmost key+value pairs</font>
<font color="green"> 142. BINFLOAT        = 'G'   # push float; arg is 8-byte float encoding</font>
<font color="black"> 143. </font>
<font color="green"> 144. TRUE            = 'I01\n'  # not an opcode; see INT docs in pickletools.py</font>
<font color="green"> 145. FALSE           = 'I00\n'  # not an opcode; see INT docs in pickletools.py</font>
<font color="black"> 146. </font>
<font color="black"> 147. # Protocol 2</font>
<font color="black"> 148. </font>
<font color="green"> 149. PROTO           = '\x80'  # identify pickle protocol</font>
<font color="green"> 150. NEWOBJ          = '\x81'  # build object by applying cls.__new__ to argtuple</font>
<font color="green"> 151. EXT1            = '\x82'  # push object from extension registry; 1-byte index</font>
<font color="green"> 152. EXT2            = '\x83'  # ditto, but 2-byte index</font>
<font color="green"> 153. EXT4            = '\x84'  # ditto, but 4-byte index</font>
<font color="green"> 154. TUPLE1          = '\x85'  # build 1-tuple from stack top</font>
<font color="green"> 155. TUPLE2          = '\x86'  # build 2-tuple from two topmost stack items</font>
<font color="green"> 156. TUPLE3          = '\x87'  # build 3-tuple from three topmost stack items</font>
<font color="green"> 157. NEWTRUE         = '\x88'  # push True</font>
<font color="green"> 158. NEWFALSE        = '\x89'  # push False</font>
<font color="green"> 159. LONG1           = '\x8a'  # push long from &lt; 256 bytes</font>
<font color="green"> 160. LONG4           = '\x8b'  # push really big long</font>
<font color="black"> 161. </font>
<font color="green"> 162. _tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]</font>
<font color="black"> 163. </font>
<font color="black"> 164. </font>
<font color="green"> 165. __all__.extend([x for x in dir() if re.match(&quot;[A-Z][A-Z0-9_]+$&quot;,x)])</font>
<font color="green"> 166. del x</font>
<font color="black"> 167. </font>
<font color="black"> 168. </font>
<font color="black"> 169. # Pickling machinery</font>
<font color="black"> 170. </font>
<font color="green"> 171. class Pickler:</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def __init__(self, file, protocol=None):</font>
<font color="black"> 174.         &quot;&quot;&quot;This takes a file-like object for writing a pickle data stream.</font>
<font color="black"> 175. </font>
<font color="black"> 176.         The optional protocol argument tells the pickler to use the</font>
<font color="black"> 177.         given protocol; supported protocols are 0, 1, 2.  The default</font>
<font color="black"> 178.         protocol is 0, to be backwards compatible.  (Protocol 0 is the</font>
<font color="black"> 179.         only protocol that can be written to a file opened in text</font>
<font color="black"> 180.         mode and read back successfully.  When using a protocol higher</font>
<font color="black"> 181.         than 0, make sure the file is opened in binary mode, both when</font>
<font color="black"> 182.         pickling and unpickling.)</font>
<font color="black"> 183. </font>
<font color="black"> 184.         Protocol 1 is more efficient than protocol 0; protocol 2 is</font>
<font color="black"> 185.         more efficient than protocol 1.</font>
<font color="black"> 186. </font>
<font color="black"> 187.         Specifying a negative protocol version selects the highest</font>
<font color="black"> 188.         protocol version supported.  The higher the protocol used, the</font>
<font color="black"> 189.         more recent the version of Python needed to read the pickle</font>
<font color="black"> 190.         produced.</font>
<font color="black"> 191. </font>
<font color="black"> 192.         The file parameter must have a write() method that accepts a single</font>
<font color="black"> 193.         string argument.  It can thus be an open file object, a StringIO</font>
<font color="black"> 194.         object, or any other custom object that meets this interface.</font>
<font color="black"> 195. </font>
<font color="black"> 196.         &quot;&quot;&quot;</font>
<font color="red"> 197.         if protocol is None:</font>
<font color="red"> 198.             protocol = 0</font>
<font color="red"> 199.         if protocol &lt; 0:</font>
<font color="red"> 200.             protocol = HIGHEST_PROTOCOL</font>
<font color="red"> 201.         elif not 0 &lt;= protocol &lt;= HIGHEST_PROTOCOL:</font>
<font color="red"> 202.             raise ValueError(&quot;pickle protocol must be &lt;= %d&quot; % HIGHEST_PROTOCOL)</font>
<font color="red"> 203.         self.write = file.write</font>
<font color="red"> 204.         self.memo = {}</font>
<font color="red"> 205.         self.proto = int(protocol)</font>
<font color="red"> 206.         self.bin = protocol &gt;= 1</font>
<font color="red"> 207.         self.fast = 0</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def clear_memo(self):</font>
<font color="black"> 210.         &quot;&quot;&quot;Clears the pickler's &quot;memo&quot;.</font>
<font color="black"> 211. </font>
<font color="black"> 212.         The memo is the data structure that remembers which objects the</font>
<font color="black"> 213.         pickler has already seen, so that shared or recursive objects are</font>
<font color="black"> 214.         pickled by reference and not by value.  This method is useful when</font>
<font color="black"> 215.         re-using picklers.</font>
<font color="black"> 216. </font>
<font color="black"> 217.         &quot;&quot;&quot;</font>
<font color="red"> 218.         self.memo.clear()</font>
<font color="black"> 219. </font>
<font color="green"> 220.     def dump(self, obj):</font>
<font color="black"> 221.         &quot;&quot;&quot;Write a pickled representation of obj to the open file.&quot;&quot;&quot;</font>
<font color="red"> 222.         if self.proto &gt;= 2:</font>
<font color="red"> 223.             self.write(PROTO + chr(self.proto))</font>
<font color="red"> 224.         self.save(obj)</font>
<font color="red"> 225.         self.write(STOP)</font>
<font color="black"> 226. </font>
<font color="green"> 227.     def memoize(self, obj):</font>
<font color="black"> 228.         &quot;&quot;&quot;Store an object in the memo.&quot;&quot;&quot;</font>
<font color="black"> 229. </font>
<font color="black"> 230.         # The Pickler memo is a dictionary mapping object ids to 2-tuples</font>
<font color="black"> 231.         # that contain the Unpickler memo key and the object being memoized.</font>
<font color="black"> 232.         # The memo key is written to the pickle and will become</font>
<font color="black"> 233.         # the key in the Unpickler's memo.  The object is stored in the</font>
<font color="black"> 234.         # Pickler memo so that transient objects are kept alive during</font>
<font color="black"> 235.         # pickling.</font>
<font color="black"> 236. </font>
<font color="black"> 237.         # The use of the Unpickler memo length as the memo key is just a</font>
<font color="black"> 238.         # convention.  The only requirement is that the memo values be unique.</font>
<font color="black"> 239.         # But there appears no advantage to any other scheme, and this</font>
<font color="black"> 240.         # scheme allows the Unpickler memo to be implemented as a plain (but</font>
<font color="black"> 241.         # growable) array, indexed by memo key.</font>
<font color="red"> 242.         if self.fast:</font>
<font color="red"> 243.             return</font>
<font color="red"> 244.         assert id(obj) not in self.memo</font>
<font color="red"> 245.         memo_len = len(self.memo)</font>
<font color="red"> 246.         self.write(self.put(memo_len))</font>
<font color="red"> 247.         self.memo[id(obj)] = memo_len, obj</font>
<font color="black"> 248. </font>
<font color="black"> 249.     # Return a PUT (BINPUT, LONG_BINPUT) opcode string, with argument i.</font>
<font color="green"> 250.     def put(self, i, pack=struct.pack):</font>
<font color="red"> 251.         if self.bin:</font>
<font color="red"> 252.             if i &lt; 256:</font>
<font color="red"> 253.                 return BINPUT + chr(i)</font>
<font color="black"> 254.             else:</font>
<font color="red"> 255.                 return LONG_BINPUT + pack(&quot;&lt;i&quot;, i)</font>
<font color="black"> 256. </font>
<font color="red"> 257.         return PUT + repr(i) + '\n'</font>
<font color="black"> 258. </font>
<font color="black"> 259.     # Return a GET (BINGET, LONG_BINGET) opcode string, with argument i.</font>
<font color="green"> 260.     def get(self, i, pack=struct.pack):</font>
<font color="red"> 261.         if self.bin:</font>
<font color="red"> 262.             if i &lt; 256:</font>
<font color="red"> 263.                 return BINGET + chr(i)</font>
<font color="black"> 264.             else:</font>
<font color="red"> 265.                 return LONG_BINGET + pack(&quot;&lt;i&quot;, i)</font>
<font color="black"> 266. </font>
<font color="red"> 267.         return GET + repr(i) + '\n'</font>
<font color="black"> 268. </font>
<font color="green"> 269.     def save(self, obj):</font>
<font color="black"> 270.         # Check for persistent id (defined by a subclass)</font>
<font color="red"> 271.         pid = self.persistent_id(obj)</font>
<font color="red"> 272.         if pid is not None:</font>
<font color="red"> 273.             self.save_pers(pid)</font>
<font color="red"> 274.             return</font>
<font color="black"> 275. </font>
<font color="black"> 276.         # Check the memo</font>
<font color="red"> 277.         x = self.memo.get(id(obj))</font>
<font color="red"> 278.         if x:</font>
<font color="red"> 279.             self.write(self.get(x[0]))</font>
<font color="red"> 280.             return</font>
<font color="black"> 281. </font>
<font color="black"> 282.         # Check the type dispatch table</font>
<font color="red"> 283.         t = type(obj)</font>
<font color="red"> 284.         f = self.dispatch.get(t)</font>
<font color="red"> 285.         if f:</font>
<font color="red"> 286.             f(self, obj) # Call unbound method with explicit self</font>
<font color="red"> 287.             return</font>
<font color="black"> 288. </font>
<font color="black"> 289.         # Check copy_reg.dispatch_table</font>
<font color="red"> 290.         reduce = dispatch_table.get(t)</font>
<font color="red"> 291.         if reduce:</font>
<font color="red"> 292.             rv = reduce(obj)</font>
<font color="black"> 293.         else:</font>
<font color="black"> 294.             # Check for a class with a custom metaclass; treat as regular class</font>
<font color="red"> 295.             try:</font>
<font color="red"> 296.                 issc = issubclass(t, TypeType)</font>
<font color="red"> 297.             except TypeError: # t is not a class (old Boost; see SF #502085)</font>
<font color="red"> 298.                 issc = 0</font>
<font color="red"> 299.             if issc:</font>
<font color="red"> 300.                 self.save_global(obj)</font>
<font color="red"> 301.                 return</font>
<font color="black"> 302. </font>
<font color="black"> 303.             # Check for a __reduce_ex__ method, fall back to __reduce__</font>
<font color="red"> 304.             reduce = getattr(obj, &quot;__reduce_ex__&quot;, None)</font>
<font color="red"> 305.             if reduce:</font>
<font color="red"> 306.                 rv = reduce(self.proto)</font>
<font color="black"> 307.             else:</font>
<font color="red"> 308.                 reduce = getattr(obj, &quot;__reduce__&quot;, None)</font>
<font color="red"> 309.                 if reduce:</font>
<font color="red"> 310.                     rv = reduce()</font>
<font color="black"> 311.                 else:</font>
<font color="red"> 312.                     raise PicklingError(&quot;Can't pickle %r object: %r&quot; %</font>
<font color="red"> 313.                                         (t.__name__, obj))</font>
<font color="black"> 314. </font>
<font color="black"> 315.         # Check for string returned by reduce(), meaning &quot;save as global&quot;</font>
<font color="red"> 316.         if type(rv) is StringType:</font>
<font color="red"> 317.             self.save_global(obj, rv)</font>
<font color="red"> 318.             return</font>
<font color="black"> 319. </font>
<font color="black"> 320.         # Assert that reduce() returned a tuple</font>
<font color="red"> 321.         if type(rv) is not TupleType:</font>
<font color="red"> 322.             raise PicklingError(&quot;%s must return string or tuple&quot; % reduce)</font>
<font color="black"> 323. </font>
<font color="black"> 324.         # Assert that it returned an appropriately sized tuple</font>
<font color="red"> 325.         l = len(rv)</font>
<font color="red"> 326.         if not (2 &lt;= l &lt;= 5):</font>
<font color="red"> 327.             raise PicklingError(&quot;Tuple returned by %s must have &quot;</font>
<font color="red"> 328.                                 &quot;two to five elements&quot; % reduce)</font>
<font color="black"> 329. </font>
<font color="black"> 330.         # Save the reduce() output and finally memoize the object</font>
<font color="red"> 331.         self.save_reduce(obj=obj, *rv)</font>
<font color="black"> 332. </font>
<font color="green"> 333.     def persistent_id(self, obj):</font>
<font color="black"> 334.         # This exists so a subclass can override it</font>
<font color="red"> 335.         return None</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def save_pers(self, pid):</font>
<font color="black"> 338.         # Save a persistent id reference</font>
<font color="red"> 339.         if self.bin:</font>
<font color="red"> 340.             self.save(pid)</font>
<font color="red"> 341.             self.write(BINPERSID)</font>
<font color="black"> 342.         else:</font>
<font color="red"> 343.             self.write(PERSID + str(pid) + '\n')</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def save_reduce(self, func, args, state=None,</font>
<font color="green"> 346.                     listitems=None, dictitems=None, obj=None):</font>
<font color="black"> 347.         # This API is called by some subclasses</font>
<font color="black"> 348. </font>
<font color="black"> 349.         # Assert that args is a tuple or None</font>
<font color="red"> 350.         if not isinstance(args, TupleType):</font>
<font color="red"> 351.             raise PicklingError(&quot;args from reduce() should be a tuple&quot;)</font>
<font color="black"> 352. </font>
<font color="black"> 353.         # Assert that func is callable</font>
<font color="red"> 354.         if not hasattr(func, '__call__'):</font>
<font color="red"> 355.             raise PicklingError(&quot;func from reduce should be callable&quot;)</font>
<font color="black"> 356. </font>
<font color="red"> 357.         save = self.save</font>
<font color="red"> 358.         write = self.write</font>
<font color="black"> 359. </font>
<font color="black"> 360.         # Protocol 2 special case: if func's name is __newobj__, use NEWOBJ</font>
<font color="red"> 361.         if self.proto &gt;= 2 and getattr(func, &quot;__name__&quot;, &quot;&quot;) == &quot;__newobj__&quot;:</font>
<font color="black"> 362.             # A __reduce__ implementation can direct protocol 2 to</font>
<font color="black"> 363.             # use the more efficient NEWOBJ opcode, while still</font>
<font color="black"> 364.             # allowing protocol 0 and 1 to work normally.  For this to</font>
<font color="black"> 365.             # work, the function returned by __reduce__ should be</font>
<font color="black"> 366.             # called __newobj__, and its first argument should be a</font>
<font color="black"> 367.             # new-style class.  The implementation for __newobj__</font>
<font color="black"> 368.             # should be as follows, although pickle has no way to</font>
<font color="black"> 369.             # verify this:</font>
<font color="black"> 370.             #</font>
<font color="black"> 371.             # def __newobj__(cls, *args):</font>
<font color="black"> 372.             #     return cls.__new__(cls, *args)</font>
<font color="black"> 373.             #</font>
<font color="black"> 374.             # Protocols 0 and 1 will pickle a reference to __newobj__,</font>
<font color="black"> 375.             # while protocol 2 (and above) will pickle a reference to</font>
<font color="black"> 376.             # cls, the remaining args tuple, and the NEWOBJ code,</font>
<font color="black"> 377.             # which calls cls.__new__(cls, *args) at unpickling time</font>
<font color="black"> 378.             # (see load_newobj below).  If __reduce__ returns a</font>
<font color="black"> 379.             # three-tuple, the state from the third tuple item will be</font>
<font color="black"> 380.             # pickled regardless of the protocol, calling __setstate__</font>
<font color="black"> 381.             # at unpickling time (see load_build below).</font>
<font color="black"> 382.             #</font>
<font color="black"> 383.             # Note that no standard __newobj__ implementation exists;</font>
<font color="black"> 384.             # you have to provide your own.  This is to enforce</font>
<font color="black"> 385.             # compatibility with Python 2.2 (pickles written using</font>
<font color="black"> 386.             # protocol 0 or 1 in Python 2.3 should be unpicklable by</font>
<font color="black"> 387.             # Python 2.2).</font>
<font color="red"> 388.             cls = args[0]</font>
<font color="red"> 389.             if not hasattr(cls, &quot;__new__&quot;):</font>
<font color="red"> 390.                 raise PicklingError(</font>
<font color="red"> 391.                     &quot;args[0] from __newobj__ args has no __new__&quot;)</font>
<font color="red"> 392.             if obj is not None and cls is not obj.__class__:</font>
<font color="red"> 393.                 raise PicklingError(</font>
<font color="red"> 394.                     &quot;args[0] from __newobj__ args has the wrong class&quot;)</font>
<font color="red"> 395.             args = args[1:]</font>
<font color="red"> 396.             save(cls)</font>
<font color="red"> 397.             save(args)</font>
<font color="red"> 398.             write(NEWOBJ)</font>
<font color="black"> 399.         else:</font>
<font color="red"> 400.             save(func)</font>
<font color="red"> 401.             save(args)</font>
<font color="red"> 402.             write(REDUCE)</font>
<font color="black"> 403. </font>
<font color="red"> 404.         if obj is not None:</font>
<font color="red"> 405.             self.memoize(obj)</font>
<font color="black"> 406. </font>
<font color="black"> 407.         # More new special cases (that work with older protocols as</font>
<font color="black"> 408.         # well): when __reduce__ returns a tuple with 4 or 5 items,</font>
<font color="black"> 409.         # the 4th and 5th item should be iterators that provide list</font>
<font color="black"> 410.         # items and dict items (as (key, value) tuples), or None.</font>
<font color="black"> 411. </font>
<font color="red"> 412.         if listitems is not None:</font>
<font color="red"> 413.             self._batch_appends(listitems)</font>
<font color="black"> 414. </font>
<font color="red"> 415.         if dictitems is not None:</font>
<font color="red"> 416.             self._batch_setitems(dictitems)</font>
<font color="black"> 417. </font>
<font color="red"> 418.         if state is not None:</font>
<font color="red"> 419.             save(state)</font>
<font color="red"> 420.             write(BUILD)</font>
<font color="black"> 421. </font>
<font color="black"> 422.     # Methods below this point are dispatched through the dispatch table</font>
<font color="black"> 423. </font>
<font color="green"> 424.     dispatch = {}</font>
<font color="black"> 425. </font>
<font color="green"> 426.     def save_none(self, obj):</font>
<font color="red"> 427.         self.write(NONE)</font>
<font color="green"> 428.     dispatch[NoneType] = save_none</font>
<font color="black"> 429. </font>
<font color="green"> 430.     def save_bool(self, obj):</font>
<font color="red"> 431.         if self.proto &gt;= 2:</font>
<font color="red"> 432.             self.write(obj and NEWTRUE or NEWFALSE)</font>
<font color="black"> 433.         else:</font>
<font color="red"> 434.             self.write(obj and TRUE or FALSE)</font>
<font color="green"> 435.     dispatch[bool] = save_bool</font>
<font color="black"> 436. </font>
<font color="green"> 437.     def save_int(self, obj, pack=struct.pack):</font>
<font color="red"> 438.         if self.bin:</font>
<font color="black"> 439.             # If the int is small enough to fit in a signed 4-byte 2's-comp</font>
<font color="black"> 440.             # format, we can store it more efficiently than the general</font>
<font color="black"> 441.             # case.</font>
<font color="black"> 442.             # First one- and two-byte unsigned ints:</font>
<font color="red"> 443.             if obj &gt;= 0:</font>
<font color="red"> 444.                 if obj &lt;= 0xff:</font>
<font color="red"> 445.                     self.write(BININT1 + chr(obj))</font>
<font color="red"> 446.                     return</font>
<font color="red"> 447.                 if obj &lt;= 0xffff:</font>
<font color="red"> 448.                     self.write(&quot;%c%c%c&quot; % (BININT2, obj&amp;0xff, obj&gt;&gt;8))</font>
<font color="red"> 449.                     return</font>
<font color="black"> 450.             # Next check for 4-byte signed ints:</font>
<font color="red"> 451.             high_bits = obj &gt;&gt; 31  # note that Python shift sign-extends</font>
<font color="red"> 452.             if high_bits == 0 or high_bits == -1:</font>
<font color="black"> 453.                 # All high bits are copies of bit 2**31, so the value</font>
<font color="black"> 454.                 # fits in a 4-byte signed int.</font>
<font color="red"> 455.                 self.write(BININT + pack(&quot;&lt;i&quot;, obj))</font>
<font color="red"> 456.                 return</font>
<font color="black"> 457.         # Text pickle, or int too big to fit in signed 4-byte format.</font>
<font color="red"> 458.         self.write(INT + repr(obj) + '\n')</font>
<font color="green"> 459.     dispatch[IntType] = save_int</font>
<font color="black"> 460. </font>
<font color="green"> 461.     def save_long(self, obj, pack=struct.pack):</font>
<font color="red"> 462.         if self.proto &gt;= 2:</font>
<font color="red"> 463.             bytes = encode_long(obj)</font>
<font color="red"> 464.             n = len(bytes)</font>
<font color="red"> 465.             if n &lt; 256:</font>
<font color="red"> 466.                 self.write(LONG1 + chr(n) + bytes)</font>
<font color="black"> 467.             else:</font>
<font color="red"> 468.                 self.write(LONG4 + pack(&quot;&lt;i&quot;, n) + bytes)</font>
<font color="red"> 469.             return</font>
<font color="red"> 470.         self.write(LONG + repr(obj) + '\n')</font>
<font color="green"> 471.     dispatch[LongType] = save_long</font>
<font color="black"> 472. </font>
<font color="green"> 473.     def save_float(self, obj, pack=struct.pack):</font>
<font color="red"> 474.         if self.bin:</font>
<font color="red"> 475.             self.write(BINFLOAT + pack('&gt;d', obj))</font>
<font color="black"> 476.         else:</font>
<font color="red"> 477.             self.write(FLOAT + repr(obj) + '\n')</font>
<font color="green"> 478.     dispatch[FloatType] = save_float</font>
<font color="black"> 479. </font>
<font color="green"> 480.     def save_string(self, obj, pack=struct.pack):</font>
<font color="red"> 481.         if self.bin:</font>
<font color="red"> 482.             n = len(obj)</font>
<font color="red"> 483.             if n &lt; 256:</font>
<font color="red"> 484.                 self.write(SHORT_BINSTRING + chr(n) + obj)</font>
<font color="black"> 485.             else:</font>
<font color="red"> 486.                 self.write(BINSTRING + pack(&quot;&lt;i&quot;, n) + obj)</font>
<font color="black"> 487.         else:</font>
<font color="red"> 488.             self.write(STRING + repr(obj) + '\n')</font>
<font color="red"> 489.         self.memoize(obj)</font>
<font color="green"> 490.     dispatch[StringType] = save_string</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def save_unicode(self, obj, pack=struct.pack):</font>
<font color="red"> 493.         if self.bin:</font>
<font color="red"> 494.             encoding = obj.encode('utf-8')</font>
<font color="red"> 495.             n = len(encoding)</font>
<font color="red"> 496.             self.write(BINUNICODE + pack(&quot;&lt;i&quot;, n) + encoding)</font>
<font color="black"> 497.         else:</font>
<font color="red"> 498.             obj = obj.replace(&quot;\\&quot;, &quot;\\u005c&quot;)</font>
<font color="red"> 499.             obj = obj.replace(&quot;\n&quot;, &quot;\\u000a&quot;)</font>
<font color="red"> 500.             self.write(UNICODE + obj.encode('raw-unicode-escape') + '\n')</font>
<font color="red"> 501.         self.memoize(obj)</font>
<font color="green"> 502.     dispatch[UnicodeType] = save_unicode</font>
<font color="black"> 503. </font>
<font color="green"> 504.     if StringType is UnicodeType:</font>
<font color="black"> 505.         # This is true for Jython</font>
<font color="red"> 506.         def save_string(self, obj, pack=struct.pack):</font>
<font color="red"> 507.             unicode = obj.isunicode()</font>
<font color="black"> 508. </font>
<font color="red"> 509.             if self.bin:</font>
<font color="red"> 510.                 if unicode:</font>
<font color="red"> 511.                     obj = obj.encode(&quot;utf-8&quot;)</font>
<font color="red"> 512.                 l = len(obj)</font>
<font color="red"> 513.                 if l &lt; 256 and not unicode:</font>
<font color="red"> 514.                     self.write(SHORT_BINSTRING + chr(l) + obj)</font>
<font color="black"> 515.                 else:</font>
<font color="red"> 516.                     s = pack(&quot;&lt;i&quot;, l)</font>
<font color="red"> 517.                     if unicode:</font>
<font color="red"> 518.                         self.write(BINUNICODE + s + obj)</font>
<font color="black"> 519.                     else:</font>
<font color="red"> 520.                         self.write(BINSTRING + s + obj)</font>
<font color="black"> 521.             else:</font>
<font color="red"> 522.                 if unicode:</font>
<font color="red"> 523.                     obj = obj.replace(&quot;\\&quot;, &quot;\\u005c&quot;)</font>
<font color="red"> 524.                     obj = obj.replace(&quot;\n&quot;, &quot;\\u000a&quot;)</font>
<font color="red"> 525.                     obj = obj.encode('raw-unicode-escape')</font>
<font color="red"> 526.                     self.write(UNICODE + obj + '\n')</font>
<font color="black"> 527.                 else:</font>
<font color="red"> 528.                     self.write(STRING + repr(obj) + '\n')</font>
<font color="red"> 529.             self.memoize(obj)</font>
<font color="red"> 530.         dispatch[StringType] = save_string</font>
<font color="black"> 531. </font>
<font color="green"> 532.     def save_tuple(self, obj):</font>
<font color="red"> 533.         write = self.write</font>
<font color="red"> 534.         proto = self.proto</font>
<font color="black"> 535. </font>
<font color="red"> 536.         n = len(obj)</font>
<font color="red"> 537.         if n == 0:</font>
<font color="red"> 538.             if proto:</font>
<font color="red"> 539.                 write(EMPTY_TUPLE)</font>
<font color="black"> 540.             else:</font>
<font color="red"> 541.                 write(MARK + TUPLE)</font>
<font color="red"> 542.             return</font>
<font color="black"> 543. </font>
<font color="red"> 544.         save = self.save</font>
<font color="red"> 545.         memo = self.memo</font>
<font color="red"> 546.         if n &lt;= 3 and proto &gt;= 2:</font>
<font color="red"> 547.             for element in obj:</font>
<font color="red"> 548.                 save(element)</font>
<font color="black"> 549.             # Subtle.  Same as in the big comment below.</font>
<font color="red"> 550.             if id(obj) in memo:</font>
<font color="red"> 551.                 get = self.get(memo[id(obj)][0])</font>
<font color="red"> 552.                 write(POP * n + get)</font>
<font color="black"> 553.             else:</font>
<font color="red"> 554.                 write(_tuplesize2code[n])</font>
<font color="red"> 555.                 self.memoize(obj)</font>
<font color="red"> 556.             return</font>
<font color="black"> 557. </font>
<font color="black"> 558.         # proto 0 or proto 1 and tuple isn't empty, or proto &gt; 1 and tuple</font>
<font color="black"> 559.         # has more than 3 elements.</font>
<font color="red"> 560.         write(MARK)</font>
<font color="red"> 561.         for element in obj:</font>
<font color="red"> 562.             save(element)</font>
<font color="black"> 563. </font>
<font color="red"> 564.         if id(obj) in memo:</font>
<font color="black"> 565.             # Subtle.  d was not in memo when we entered save_tuple(), so</font>
<font color="black"> 566.             # the process of saving the tuple's elements must have saved</font>
<font color="black"> 567.             # the tuple itself:  the tuple is recursive.  The proper action</font>
<font color="black"> 568.             # now is to throw away everything we put on the stack, and</font>
<font color="black"> 569.             # simply GET the tuple (it's already constructed).  This check</font>
<font color="black"> 570.             # could have been done in the &quot;for element&quot; loop instead, but</font>
<font color="black"> 571.             # recursive tuples are a rare thing.</font>
<font color="red"> 572.             get = self.get(memo[id(obj)][0])</font>
<font color="red"> 573.             if proto:</font>
<font color="red"> 574.                 write(POP_MARK + get)</font>
<font color="black"> 575.             else:   # proto 0 -- POP_MARK not available</font>
<font color="red"> 576.                 write(POP * (n+1) + get)</font>
<font color="red"> 577.             return</font>
<font color="black"> 578. </font>
<font color="black"> 579.         # No recursion.</font>
<font color="red"> 580.         self.write(TUPLE)</font>
<font color="red"> 581.         self.memoize(obj)</font>
<font color="black"> 582. </font>
<font color="green"> 583.     dispatch[TupleType] = save_tuple</font>
<font color="black"> 584. </font>
<font color="black"> 585.     # save_empty_tuple() isn't used by anything in Python 2.3.  However, I</font>
<font color="black"> 586.     # found a Pickler subclass in Zope3 that calls it, so it's not harmless</font>
<font color="black"> 587.     # to remove it.</font>
<font color="green"> 588.     def save_empty_tuple(self, obj):</font>
<font color="red"> 589.         self.write(EMPTY_TUPLE)</font>
<font color="black"> 590. </font>
<font color="green"> 591.     def save_list(self, obj):</font>
<font color="red"> 592.         write = self.write</font>
<font color="black"> 593. </font>
<font color="red"> 594.         if self.bin:</font>
<font color="red"> 595.             write(EMPTY_LIST)</font>
<font color="black"> 596.         else:   # proto 0 -- can't use EMPTY_LIST</font>
<font color="red"> 597.             write(MARK + LIST)</font>
<font color="black"> 598. </font>
<font color="red"> 599.         self.memoize(obj)</font>
<font color="red"> 600.         self._batch_appends(iter(obj))</font>
<font color="black"> 601. </font>
<font color="green"> 602.     dispatch[ListType] = save_list</font>
<font color="black"> 603. </font>
<font color="black"> 604.     # Keep in synch with cPickle's BATCHSIZE.  Nothing will break if it gets</font>
<font color="black"> 605.     # out of synch, though.</font>
<font color="green"> 606.     _BATCHSIZE = 1000</font>
<font color="black"> 607. </font>
<font color="green"> 608.     def _batch_appends(self, items):</font>
<font color="black"> 609.         # Helper to batch up APPENDS sequences</font>
<font color="red"> 610.         save = self.save</font>
<font color="red"> 611.         write = self.write</font>
<font color="black"> 612. </font>
<font color="red"> 613.         if not self.bin:</font>
<font color="red"> 614.             for x in items:</font>
<font color="red"> 615.                 save(x)</font>
<font color="red"> 616.                 write(APPEND)</font>
<font color="red"> 617.             return</font>
<font color="black"> 618. </font>
<font color="red"> 619.         r = xrange(self._BATCHSIZE)</font>
<font color="red"> 620.         while items is not None:</font>
<font color="red"> 621.             tmp = []</font>
<font color="red"> 622.             for i in r:</font>
<font color="red"> 623.                 try:</font>
<font color="red"> 624.                     x = items.next()</font>
<font color="red"> 625.                     tmp.append(x)</font>
<font color="red"> 626.                 except StopIteration:</font>
<font color="red"> 627.                     items = None</font>
<font color="red"> 628.                     break</font>
<font color="red"> 629.             n = len(tmp)</font>
<font color="red"> 630.             if n &gt; 1:</font>
<font color="red"> 631.                 write(MARK)</font>
<font color="red"> 632.                 for x in tmp:</font>
<font color="red"> 633.                     save(x)</font>
<font color="red"> 634.                 write(APPENDS)</font>
<font color="red"> 635.             elif n:</font>
<font color="red"> 636.                 save(tmp[0])</font>
<font color="red"> 637.                 write(APPEND)</font>
<font color="black"> 638.             # else tmp is empty, and we're done</font>
<font color="black"> 639. </font>
<font color="green"> 640.     def save_dict(self, obj):</font>
<font color="red"> 641.         write = self.write</font>
<font color="black"> 642. </font>
<font color="red"> 643.         if self.bin:</font>
<font color="red"> 644.             write(EMPTY_DICT)</font>
<font color="black"> 645.         else:   # proto 0 -- can't use EMPTY_DICT</font>
<font color="red"> 646.             write(MARK + DICT)</font>
<font color="black"> 647. </font>
<font color="red"> 648.         self.memoize(obj)</font>
<font color="red"> 649.         self._batch_setitems(obj.iteritems())</font>
<font color="black"> 650. </font>
<font color="green"> 651.     dispatch[DictionaryType] = save_dict</font>
<font color="green"> 652.     if not PyStringMap is None:</font>
<font color="red"> 653.         dispatch[PyStringMap] = save_dict</font>
<font color="black"> 654. </font>
<font color="green"> 655.     def _batch_setitems(self, items):</font>
<font color="black"> 656.         # Helper to batch up SETITEMS sequences; proto &gt;= 1 only</font>
<font color="red"> 657.         save = self.save</font>
<font color="red"> 658.         write = self.write</font>
<font color="black"> 659. </font>
<font color="red"> 660.         if not self.bin:</font>
<font color="red"> 661.             for k, v in items:</font>
<font color="red"> 662.                 save(k)</font>
<font color="red"> 663.                 save(v)</font>
<font color="red"> 664.                 write(SETITEM)</font>
<font color="red"> 665.             return</font>
<font color="black"> 666. </font>
<font color="red"> 667.         r = xrange(self._BATCHSIZE)</font>
<font color="red"> 668.         while items is not None:</font>
<font color="red"> 669.             tmp = []</font>
<font color="red"> 670.             for i in r:</font>
<font color="red"> 671.                 try:</font>
<font color="red"> 672.                     tmp.append(items.next())</font>
<font color="red"> 673.                 except StopIteration:</font>
<font color="red"> 674.                     items = None</font>
<font color="red"> 675.                     break</font>
<font color="red"> 676.             n = len(tmp)</font>
<font color="red"> 677.             if n &gt; 1:</font>
<font color="red"> 678.                 write(MARK)</font>
<font color="red"> 679.                 for k, v in tmp:</font>
<font color="red"> 680.                     save(k)</font>
<font color="red"> 681.                     save(v)</font>
<font color="red"> 682.                 write(SETITEMS)</font>
<font color="red"> 683.             elif n:</font>
<font color="red"> 684.                 k, v = tmp[0]</font>
<font color="red"> 685.                 save(k)</font>
<font color="red"> 686.                 save(v)</font>
<font color="red"> 687.                 write(SETITEM)</font>
<font color="black"> 688.             # else tmp is empty, and we're done</font>
<font color="black"> 689. </font>
<font color="green"> 690.     def save_inst(self, obj):</font>
<font color="red"> 691.         cls = obj.__class__</font>
<font color="black"> 692. </font>
<font color="red"> 693.         memo  = self.memo</font>
<font color="red"> 694.         write = self.write</font>
<font color="red"> 695.         save  = self.save</font>
<font color="black"> 696. </font>
<font color="red"> 697.         if hasattr(obj, '__getinitargs__'):</font>
<font color="red"> 698.             args = obj.__getinitargs__()</font>
<font color="red"> 699.             len(args) # XXX Assert it's a sequence</font>
<font color="red"> 700.             _keep_alive(args, memo)</font>
<font color="black"> 701.         else:</font>
<font color="red"> 702.             args = ()</font>
<font color="black"> 703. </font>
<font color="red"> 704.         write(MARK)</font>
<font color="black"> 705. </font>
<font color="red"> 706.         if self.bin:</font>
<font color="red"> 707.             save(cls)</font>
<font color="red"> 708.             for arg in args:</font>
<font color="red"> 709.                 save(arg)</font>
<font color="red"> 710.             write(OBJ)</font>
<font color="black"> 711.         else:</font>
<font color="red"> 712.             for arg in args:</font>
<font color="red"> 713.                 save(arg)</font>
<font color="red"> 714.             write(INST + cls.__module__ + '\n' + cls.__name__ + '\n')</font>
<font color="black"> 715. </font>
<font color="red"> 716.         self.memoize(obj)</font>
<font color="black"> 717. </font>
<font color="red"> 718.         try:</font>
<font color="red"> 719.             getstate = obj.__getstate__</font>
<font color="red"> 720.         except AttributeError:</font>
<font color="red"> 721.             stuff = obj.__dict__</font>
<font color="black"> 722.         else:</font>
<font color="red"> 723.             stuff = getstate()</font>
<font color="red"> 724.             _keep_alive(stuff, memo)</font>
<font color="red"> 725.         save(stuff)</font>
<font color="red"> 726.         write(BUILD)</font>
<font color="black"> 727. </font>
<font color="green"> 728.     dispatch[InstanceType] = save_inst</font>
<font color="black"> 729. </font>
<font color="green"> 730.     def save_global(self, obj, name=None, pack=struct.pack):</font>
<font color="red"> 731.         write = self.write</font>
<font color="red"> 732.         memo = self.memo</font>
<font color="black"> 733. </font>
<font color="red"> 734.         if name is None:</font>
<font color="red"> 735.             name = obj.__name__</font>
<font color="black"> 736. </font>
<font color="red"> 737.         module = getattr(obj, &quot;__module__&quot;, None)</font>
<font color="red"> 738.         if module is None:</font>
<font color="red"> 739.             module = whichmodule(obj, name)</font>
<font color="black"> 740. </font>
<font color="red"> 741.         try:</font>
<font color="red"> 742.             __import__(module)</font>
<font color="red"> 743.             mod = sys.modules[module]</font>
<font color="red"> 744.             klass = getattr(mod, name)</font>
<font color="red"> 745.         except (ImportError, KeyError, AttributeError):</font>
<font color="red"> 746.             raise PicklingError(</font>
<font color="red"> 747.                 &quot;Can't pickle %r: it's not found as %s.%s&quot; %</font>
<font color="red"> 748.                 (obj, module, name))</font>
<font color="black"> 749.         else:</font>
<font color="red"> 750.             if klass is not obj:</font>
<font color="red"> 751.                 raise PicklingError(</font>
<font color="red"> 752.                     &quot;Can't pickle %r: it's not the same object as %s.%s&quot; %</font>
<font color="red"> 753.                     (obj, module, name))</font>
<font color="black"> 754. </font>
<font color="red"> 755.         if self.proto &gt;= 2:</font>
<font color="red"> 756.             code = _extension_registry.get((module, name))</font>
<font color="red"> 757.             if code:</font>
<font color="red"> 758.                 assert code &gt; 0</font>
<font color="red"> 759.                 if code &lt;= 0xff:</font>
<font color="red"> 760.                     write(EXT1 + chr(code))</font>
<font color="red"> 761.                 elif code &lt;= 0xffff:</font>
<font color="red"> 762.                     write(&quot;%c%c%c&quot; % (EXT2, code&amp;0xff, code&gt;&gt;8))</font>
<font color="black"> 763.                 else:</font>
<font color="red"> 764.                     write(EXT4 + pack(&quot;&lt;i&quot;, code))</font>
<font color="red"> 765.                 return</font>
<font color="black"> 766. </font>
<font color="red"> 767.         write(GLOBAL + module + '\n' + name + '\n')</font>
<font color="red"> 768.         self.memoize(obj)</font>
<font color="black"> 769. </font>
<font color="green"> 770.     dispatch[ClassType] = save_global</font>
<font color="green"> 771.     dispatch[FunctionType] = save_global</font>
<font color="green"> 772.     dispatch[BuiltinFunctionType] = save_global</font>
<font color="green"> 773.     dispatch[TypeType] = save_global</font>
<font color="black"> 774. </font>
<font color="black"> 775. # Pickling helpers</font>
<font color="black"> 776. </font>
<font color="green"> 777. def _keep_alive(x, memo):</font>
<font color="black"> 778.     &quot;&quot;&quot;Keeps a reference to the object x in the memo.</font>
<font color="black"> 779. </font>
<font color="black"> 780.     Because we remember objects by their id, we have</font>
<font color="black"> 781.     to assure that possibly temporary objects are kept</font>
<font color="black"> 782.     alive by referencing them.</font>
<font color="black"> 783.     We store a reference at the id of the memo, which should</font>
<font color="black"> 784.     normally not be used unless someone tries to deepcopy</font>
<font color="black"> 785.     the memo itself...</font>
<font color="black"> 786.     &quot;&quot;&quot;</font>
<font color="red"> 787.     try:</font>
<font color="red"> 788.         memo[id(memo)].append(x)</font>
<font color="red"> 789.     except KeyError:</font>
<font color="black"> 790.         # aha, this is the first one :-)</font>
<font color="red"> 791.         memo[id(memo)]=[x]</font>
<font color="black"> 792. </font>
<font color="black"> 793. </font>
<font color="black"> 794. # A cache for whichmodule(), mapping a function object to the name of</font>
<font color="black"> 795. # the module in which the function was found.</font>
<font color="black"> 796. </font>
<font color="green"> 797. classmap = {} # called classmap for backwards compatibility</font>
<font color="black"> 798. </font>
<font color="green"> 799. def whichmodule(func, funcname):</font>
<font color="black"> 800.     &quot;&quot;&quot;Figure out the module in which a function occurs.</font>
<font color="black"> 801. </font>
<font color="black"> 802.     Search sys.modules for the module.</font>
<font color="black"> 803.     Cache in classmap.</font>
<font color="black"> 804.     Return a module name.</font>
<font color="black"> 805.     If the function cannot be found, return &quot;__main__&quot;.</font>
<font color="black"> 806.     &quot;&quot;&quot;</font>
<font color="black"> 807.     # Python functions should always get an __module__ from their globals.</font>
<font color="red"> 808.     mod = getattr(func, &quot;__module__&quot;, None)</font>
<font color="red"> 809.     if mod is not None:</font>
<font color="red"> 810.         return mod</font>
<font color="red"> 811.     if func in classmap:</font>
<font color="red"> 812.         return classmap[func]</font>
<font color="black"> 813. </font>
<font color="red"> 814.     for name, module in sys.modules.items():</font>
<font color="red"> 815.         if module is None:</font>
<font color="red"> 816.             continue # skip dummy package entries</font>
<font color="red"> 817.         if name != '__main__' and getattr(module, funcname, None) is func:</font>
<font color="red"> 818.             break</font>
<font color="black"> 819.     else:</font>
<font color="red"> 820.         name = '__main__'</font>
<font color="red"> 821.     classmap[func] = name</font>
<font color="red"> 822.     return name</font>
<font color="black"> 823. </font>
<font color="black"> 824. </font>
<font color="black"> 825. # Unpickling machinery</font>
<font color="black"> 826. </font>
<font color="green"> 827. class Unpickler:</font>
<font color="black"> 828. </font>
<font color="green"> 829.     def __init__(self, file):</font>
<font color="black"> 830.         &quot;&quot;&quot;This takes a file-like object for reading a pickle data stream.</font>
<font color="black"> 831. </font>
<font color="black"> 832.         The protocol version of the pickle is detected automatically, so no</font>
<font color="black"> 833.         proto argument is needed.</font>
<font color="black"> 834. </font>
<font color="black"> 835.         The file-like object must have two methods, a read() method that</font>
<font color="black"> 836.         takes an integer argument, and a readline() method that requires no</font>
<font color="black"> 837.         arguments.  Both methods should return a string.  Thus file-like</font>
<font color="black"> 838.         object can be a file object opened for reading, a StringIO object,</font>
<font color="black"> 839.         or any other custom object that meets this interface.</font>
<font color="black"> 840.         &quot;&quot;&quot;</font>
<font color="red"> 841.         self.readline = file.readline</font>
<font color="red"> 842.         self.read = file.read</font>
<font color="red"> 843.         self.memo = {}</font>
<font color="black"> 844. </font>
<font color="green"> 845.     def load(self):</font>
<font color="black"> 846.         &quot;&quot;&quot;Read a pickled object representation from the open file.</font>
<font color="black"> 847. </font>
<font color="black"> 848.         Return the reconstituted object hierarchy specified in the file.</font>
<font color="black"> 849.         &quot;&quot;&quot;</font>
<font color="red"> 850.         self.mark = object() # any new unique object</font>
<font color="red"> 851.         self.stack = []</font>
<font color="red"> 852.         self.append = self.stack.append</font>
<font color="red"> 853.         read = self.read</font>
<font color="red"> 854.         dispatch = self.dispatch</font>
<font color="red"> 855.         try:</font>
<font color="red"> 856.             while 1:</font>
<font color="red"> 857.                 key = read(1)</font>
<font color="red"> 858.                 dispatch[key](self)</font>
<font color="red"> 859.         except _Stop, stopinst:</font>
<font color="red"> 860.             return stopinst.value</font>
<font color="black"> 861. </font>
<font color="black"> 862.     # Return largest index k such that self.stack[k] is self.mark.</font>
<font color="black"> 863.     # If the stack doesn't contain a mark, eventually raises IndexError.</font>
<font color="black"> 864.     # This could be sped by maintaining another stack, of indices at which</font>
<font color="black"> 865.     # the mark appears.  For that matter, the latter stack would suffice,</font>
<font color="black"> 866.     # and we wouldn't need to push mark objects on self.stack at all.</font>
<font color="black"> 867.     # Doing so is probably a good thing, though, since if the pickle is</font>
<font color="black"> 868.     # corrupt (or hostile) we may get a clue from finding self.mark embedded</font>
<font color="black"> 869.     # in unpickled objects.</font>
<font color="green"> 870.     def marker(self):</font>
<font color="red"> 871.         stack = self.stack</font>
<font color="red"> 872.         mark = self.mark</font>
<font color="red"> 873.         k = len(stack)-1</font>
<font color="red"> 874.         while stack[k] is not mark: k = k-1</font>
<font color="red"> 875.         return k</font>
<font color="black"> 876. </font>
<font color="green"> 877.     dispatch = {}</font>
<font color="black"> 878. </font>
<font color="green"> 879.     def load_eof(self):</font>
<font color="red"> 880.         raise EOFError</font>
<font color="green"> 881.     dispatch[''] = load_eof</font>
<font color="black"> 882. </font>
<font color="green"> 883.     def load_proto(self):</font>
<font color="red"> 884.         proto = ord(self.read(1))</font>
<font color="red"> 885.         if not 0 &lt;= proto &lt;= 2:</font>
<font color="red"> 886.             raise ValueError, &quot;unsupported pickle protocol: %d&quot; % proto</font>
<font color="green"> 887.     dispatch[PROTO] = load_proto</font>
<font color="black"> 888. </font>
<font color="green"> 889.     def load_persid(self):</font>
<font color="red"> 890.         pid = self.readline()[:-1]</font>
<font color="red"> 891.         self.append(self.persistent_load(pid))</font>
<font color="green"> 892.     dispatch[PERSID] = load_persid</font>
<font color="black"> 893. </font>
<font color="green"> 894.     def load_binpersid(self):</font>
<font color="red"> 895.         pid = self.stack.pop()</font>
<font color="red"> 896.         self.append(self.persistent_load(pid))</font>
<font color="green"> 897.     dispatch[BINPERSID] = load_binpersid</font>
<font color="black"> 898. </font>
<font color="green"> 899.     def load_none(self):</font>
<font color="red"> 900.         self.append(None)</font>
<font color="green"> 901.     dispatch[NONE] = load_none</font>
<font color="black"> 902. </font>
<font color="green"> 903.     def load_false(self):</font>
<font color="red"> 904.         self.append(False)</font>
<font color="green"> 905.     dispatch[NEWFALSE] = load_false</font>
<font color="black"> 906. </font>
<font color="green"> 907.     def load_true(self):</font>
<font color="red"> 908.         self.append(True)</font>
<font color="green"> 909.     dispatch[NEWTRUE] = load_true</font>
<font color="black"> 910. </font>
<font color="green"> 911.     def load_int(self):</font>
<font color="red"> 912.         data = self.readline()</font>
<font color="red"> 913.         if data == FALSE[1:]:</font>
<font color="red"> 914.             val = False</font>
<font color="red"> 915.         elif data == TRUE[1:]:</font>
<font color="red"> 916.             val = True</font>
<font color="black"> 917.         else:</font>
<font color="red"> 918.             try:</font>
<font color="red"> 919.                 val = int(data)</font>
<font color="red"> 920.             except ValueError:</font>
<font color="red"> 921.                 val = long(data)</font>
<font color="red"> 922.         self.append(val)</font>
<font color="green"> 923.     dispatch[INT] = load_int</font>
<font color="black"> 924. </font>
<font color="green"> 925.     def load_binint(self):</font>
<font color="red"> 926.         self.append(mloads('i' + self.read(4)))</font>
<font color="green"> 927.     dispatch[BININT] = load_binint</font>
<font color="black"> 928. </font>
<font color="green"> 929.     def load_binint1(self):</font>
<font color="red"> 930.         self.append(ord(self.read(1)))</font>
<font color="green"> 931.     dispatch[BININT1] = load_binint1</font>
<font color="black"> 932. </font>
<font color="green"> 933.     def load_binint2(self):</font>
<font color="red"> 934.         self.append(mloads('i' + self.read(2) + '\000\000'))</font>
<font color="green"> 935.     dispatch[BININT2] = load_binint2</font>
<font color="black"> 936. </font>
<font color="green"> 937.     def load_long(self):</font>
<font color="red"> 938.         self.append(long(self.readline()[:-1], 0))</font>
<font color="green"> 939.     dispatch[LONG] = load_long</font>
<font color="black"> 940. </font>
<font color="green"> 941.     def load_long1(self):</font>
<font color="red"> 942.         n = ord(self.read(1))</font>
<font color="red"> 943.         bytes = self.read(n)</font>
<font color="red"> 944.         self.append(decode_long(bytes))</font>
<font color="green"> 945.     dispatch[LONG1] = load_long1</font>
<font color="black"> 946. </font>
<font color="green"> 947.     def load_long4(self):</font>
<font color="red"> 948.         n = mloads('i' + self.read(4))</font>
<font color="red"> 949.         bytes = self.read(n)</font>
<font color="red"> 950.         self.append(decode_long(bytes))</font>
<font color="green"> 951.     dispatch[LONG4] = load_long4</font>
<font color="black"> 952. </font>
<font color="green"> 953.     def load_float(self):</font>
<font color="red"> 954.         self.append(float(self.readline()[:-1]))</font>
<font color="green"> 955.     dispatch[FLOAT] = load_float</font>
<font color="black"> 956. </font>
<font color="green"> 957.     def load_binfloat(self, unpack=struct.unpack):</font>
<font color="red"> 958.         self.append(unpack('&gt;d', self.read(8))[0])</font>
<font color="green"> 959.     dispatch[BINFLOAT] = load_binfloat</font>
<font color="black"> 960. </font>
<font color="green"> 961.     def load_string(self):</font>
<font color="red"> 962.         rep = self.readline()[:-1]</font>
<font color="red"> 963.         for q in &quot;\&quot;'&quot;: # double or single quote</font>
<font color="red"> 964.             if rep.startswith(q):</font>
<font color="red"> 965.                 if len(rep) &lt; 2 or not rep.endswith(q):</font>
<font color="red"> 966.                     raise ValueError, &quot;insecure string pickle&quot;</font>
<font color="red"> 967.                 rep = rep[len(q):-len(q)]</font>
<font color="red"> 968.                 break</font>
<font color="black"> 969.         else:</font>
<font color="red"> 970.             raise ValueError, &quot;insecure string pickle&quot;</font>
<font color="red"> 971.         self.append(rep.decode(&quot;string-escape&quot;))</font>
<font color="green"> 972.     dispatch[STRING] = load_string</font>
<font color="black"> 973. </font>
<font color="green"> 974.     def load_binstring(self):</font>
<font color="red"> 975.         len = mloads('i' + self.read(4))</font>
<font color="red"> 976.         self.append(self.read(len))</font>
<font color="green"> 977.     dispatch[BINSTRING] = load_binstring</font>
<font color="black"> 978. </font>
<font color="green"> 979.     def load_unicode(self):</font>
<font color="red"> 980.         self.append(unicode(self.readline()[:-1],'raw-unicode-escape'))</font>
<font color="green"> 981.     dispatch[UNICODE] = load_unicode</font>
<font color="black"> 982. </font>
<font color="green"> 983.     def load_binunicode(self):</font>
<font color="red"> 984.         len = mloads('i' + self.read(4))</font>
<font color="red"> 985.         self.append(unicode(self.read(len),'utf-8'))</font>
<font color="green"> 986.     dispatch[BINUNICODE] = load_binunicode</font>
<font color="black"> 987. </font>
<font color="green"> 988.     def load_short_binstring(self):</font>
<font color="red"> 989.         len = ord(self.read(1))</font>
<font color="red"> 990.         self.append(self.read(len))</font>
<font color="green"> 991.     dispatch[SHORT_BINSTRING] = load_short_binstring</font>
<font color="black"> 992. </font>
<font color="green"> 993.     def load_tuple(self):</font>
<font color="red"> 994.         k = self.marker()</font>
<font color="red"> 995.         self.stack[k:] = [tuple(self.stack[k+1:])]</font>
<font color="green"> 996.     dispatch[TUPLE] = load_tuple</font>
<font color="black"> 997. </font>
<font color="green"> 998.     def load_empty_tuple(self):</font>
<font color="red"> 999.         self.stack.append(())</font>
<font color="green">1000.     dispatch[EMPTY_TUPLE] = load_empty_tuple</font>
<font color="black">1001. </font>
<font color="green">1002.     def load_tuple1(self):</font>
<font color="red">1003.         self.stack[-1] = (self.stack[-1],)</font>
<font color="green">1004.     dispatch[TUPLE1] = load_tuple1</font>
<font color="black">1005. </font>
<font color="green">1006.     def load_tuple2(self):</font>
<font color="red">1007.         self.stack[-2:] = [(self.stack[-2], self.stack[-1])]</font>
<font color="green">1008.     dispatch[TUPLE2] = load_tuple2</font>
<font color="black">1009. </font>
<font color="green">1010.     def load_tuple3(self):</font>
<font color="red">1011.         self.stack[-3:] = [(self.stack[-3], self.stack[-2], self.stack[-1])]</font>
<font color="green">1012.     dispatch[TUPLE3] = load_tuple3</font>
<font color="black">1013. </font>
<font color="green">1014.     def load_empty_list(self):</font>
<font color="red">1015.         self.stack.append([])</font>
<font color="green">1016.     dispatch[EMPTY_LIST] = load_empty_list</font>
<font color="black">1017. </font>
<font color="green">1018.     def load_empty_dictionary(self):</font>
<font color="red">1019.         self.stack.append({})</font>
<font color="green">1020.     dispatch[EMPTY_DICT] = load_empty_dictionary</font>
<font color="black">1021. </font>
<font color="green">1022.     def load_list(self):</font>
<font color="red">1023.         k = self.marker()</font>
<font color="red">1024.         self.stack[k:] = [self.stack[k+1:]]</font>
<font color="green">1025.     dispatch[LIST] = load_list</font>
<font color="black">1026. </font>
<font color="green">1027.     def load_dict(self):</font>
<font color="red">1028.         k = self.marker()</font>
<font color="red">1029.         d = {}</font>
<font color="red">1030.         items = self.stack[k+1:]</font>
<font color="red">1031.         for i in range(0, len(items), 2):</font>
<font color="red">1032.             key = items[i]</font>
<font color="red">1033.             value = items[i+1]</font>
<font color="red">1034.             d[key] = value</font>
<font color="red">1035.         self.stack[k:] = [d]</font>
<font color="green">1036.     dispatch[DICT] = load_dict</font>
<font color="black">1037. </font>
<font color="black">1038.     # INST and OBJ differ only in how they get a class object.  It's not</font>
<font color="black">1039.     # only sensible to do the rest in a common routine, the two routines</font>
<font color="black">1040.     # previously diverged and grew different bugs.</font>
<font color="black">1041.     # klass is the class to instantiate, and k points to the topmost mark</font>
<font color="black">1042.     # object, following which are the arguments for klass.__init__.</font>
<font color="green">1043.     def _instantiate(self, klass, k):</font>
<font color="red">1044.         args = tuple(self.stack[k+1:])</font>
<font color="red">1045.         del self.stack[k:]</font>
<font color="red">1046.         instantiated = 0</font>
<font color="red">1047.         if (not args and</font>
<font color="red">1048.                 type(klass) is ClassType and</font>
<font color="red">1049.                 not hasattr(klass, &quot;__getinitargs__&quot;)):</font>
<font color="red">1050.             try:</font>
<font color="red">1051.                 value = _EmptyClass()</font>
<font color="red">1052.                 value.__class__ = klass</font>
<font color="red">1053.                 instantiated = 1</font>
<font color="red">1054.             except RuntimeError:</font>
<font color="black">1055.                 # In restricted execution, assignment to inst.__class__ is</font>
<font color="black">1056.                 # prohibited</font>
<font color="red">1057.                 pass</font>
<font color="red">1058.         if not instantiated:</font>
<font color="red">1059.             try:</font>
<font color="red">1060.                 value = klass(*args)</font>
<font color="red">1061.             except TypeError, err:</font>
<font color="red">1062.                 raise TypeError, &quot;in constructor for %s: %s&quot; % (</font>
<font color="red">1063.                     klass.__name__, str(err)), sys.exc_info()[2]</font>
<font color="red">1064.         self.append(value)</font>
<font color="black">1065. </font>
<font color="green">1066.     def load_inst(self):</font>
<font color="red">1067.         module = self.readline()[:-1]</font>
<font color="red">1068.         name = self.readline()[:-1]</font>
<font color="red">1069.         klass = self.find_class(module, name)</font>
<font color="red">1070.         self._instantiate(klass, self.marker())</font>
<font color="green">1071.     dispatch[INST] = load_inst</font>
<font color="black">1072. </font>
<font color="green">1073.     def load_obj(self):</font>
<font color="black">1074.         # Stack is ... markobject classobject arg1 arg2 ...</font>
<font color="red">1075.         k = self.marker()</font>
<font color="red">1076.         klass = self.stack.pop(k+1)</font>
<font color="red">1077.         self._instantiate(klass, k)</font>
<font color="green">1078.     dispatch[OBJ] = load_obj</font>
<font color="black">1079. </font>
<font color="green">1080.     def load_newobj(self):</font>
<font color="red">1081.         args = self.stack.pop()</font>
<font color="red">1082.         cls = self.stack[-1]</font>
<font color="red">1083.         obj = cls.__new__(cls, *args)</font>
<font color="red">1084.         self.stack[-1] = obj</font>
<font color="green">1085.     dispatch[NEWOBJ] = load_newobj</font>
<font color="black">1086. </font>
<font color="green">1087.     def load_global(self):</font>
<font color="red">1088.         module = self.readline()[:-1]</font>
<font color="red">1089.         name = self.readline()[:-1]</font>
<font color="red">1090.         klass = self.find_class(module, name)</font>
<font color="red">1091.         self.append(klass)</font>
<font color="green">1092.     dispatch[GLOBAL] = load_global</font>
<font color="black">1093. </font>
<font color="green">1094.     def load_ext1(self):</font>
<font color="red">1095.         code = ord(self.read(1))</font>
<font color="red">1096.         self.get_extension(code)</font>
<font color="green">1097.     dispatch[EXT1] = load_ext1</font>
<font color="black">1098. </font>
<font color="green">1099.     def load_ext2(self):</font>
<font color="red">1100.         code = mloads('i' + self.read(2) + '\000\000')</font>
<font color="red">1101.         self.get_extension(code)</font>
<font color="green">1102.     dispatch[EXT2] = load_ext2</font>
<font color="black">1103. </font>
<font color="green">1104.     def load_ext4(self):</font>
<font color="red">1105.         code = mloads('i' + self.read(4))</font>
<font color="red">1106.         self.get_extension(code)</font>
<font color="green">1107.     dispatch[EXT4] = load_ext4</font>
<font color="black">1108. </font>
<font color="green">1109.     def get_extension(self, code):</font>
<font color="red">1110.         nil = []</font>
<font color="red">1111.         obj = _extension_cache.get(code, nil)</font>
<font color="red">1112.         if obj is not nil:</font>
<font color="red">1113.             self.append(obj)</font>
<font color="red">1114.             return</font>
<font color="red">1115.         key = _inverted_registry.get(code)</font>
<font color="red">1116.         if not key:</font>
<font color="red">1117.             raise ValueError(&quot;unregistered extension code %d&quot; % code)</font>
<font color="red">1118.         obj = self.find_class(*key)</font>
<font color="red">1119.         _extension_cache[code] = obj</font>
<font color="red">1120.         self.append(obj)</font>
<font color="black">1121. </font>
<font color="green">1122.     def find_class(self, module, name):</font>
<font color="black">1123.         # Subclasses may override this</font>
<font color="red">1124.         __import__(module)</font>
<font color="red">1125.         mod = sys.modules[module]</font>
<font color="red">1126.         klass = getattr(mod, name)</font>
<font color="red">1127.         return klass</font>
<font color="black">1128. </font>
<font color="green">1129.     def load_reduce(self):</font>
<font color="red">1130.         stack = self.stack</font>
<font color="red">1131.         args = stack.pop()</font>
<font color="red">1132.         func = stack[-1]</font>
<font color="red">1133.         value = func(*args)</font>
<font color="red">1134.         stack[-1] = value</font>
<font color="green">1135.     dispatch[REDUCE] = load_reduce</font>
<font color="black">1136. </font>
<font color="green">1137.     def load_pop(self):</font>
<font color="red">1138.         del self.stack[-1]</font>
<font color="green">1139.     dispatch[POP] = load_pop</font>
<font color="black">1140. </font>
<font color="green">1141.     def load_pop_mark(self):</font>
<font color="red">1142.         k = self.marker()</font>
<font color="red">1143.         del self.stack[k:]</font>
<font color="green">1144.     dispatch[POP_MARK] = load_pop_mark</font>
<font color="black">1145. </font>
<font color="green">1146.     def load_dup(self):</font>
<font color="red">1147.         self.append(self.stack[-1])</font>
<font color="green">1148.     dispatch[DUP] = load_dup</font>
<font color="black">1149. </font>
<font color="green">1150.     def load_get(self):</font>
<font color="red">1151.         self.append(self.memo[self.readline()[:-1]])</font>
<font color="green">1152.     dispatch[GET] = load_get</font>
<font color="black">1153. </font>
<font color="green">1154.     def load_binget(self):</font>
<font color="red">1155.         i = ord(self.read(1))</font>
<font color="red">1156.         self.append(self.memo[repr(i)])</font>
<font color="green">1157.     dispatch[BINGET] = load_binget</font>
<font color="black">1158. </font>
<font color="green">1159.     def load_long_binget(self):</font>
<font color="red">1160.         i = mloads('i' + self.read(4))</font>
<font color="red">1161.         self.append(self.memo[repr(i)])</font>
<font color="green">1162.     dispatch[LONG_BINGET] = load_long_binget</font>
<font color="black">1163. </font>
<font color="green">1164.     def load_put(self):</font>
<font color="red">1165.         self.memo[self.readline()[:-1]] = self.stack[-1]</font>
<font color="green">1166.     dispatch[PUT] = load_put</font>
<font color="black">1167. </font>
<font color="green">1168.     def load_binput(self):</font>
<font color="red">1169.         i = ord(self.read(1))</font>
<font color="red">1170.         self.memo[repr(i)] = self.stack[-1]</font>
<font color="green">1171.     dispatch[BINPUT] = load_binput</font>
<font color="black">1172. </font>
<font color="green">1173.     def load_long_binput(self):</font>
<font color="red">1174.         i = mloads('i' + self.read(4))</font>
<font color="red">1175.         self.memo[repr(i)] = self.stack[-1]</font>
<font color="green">1176.     dispatch[LONG_BINPUT] = load_long_binput</font>
<font color="black">1177. </font>
<font color="green">1178.     def load_append(self):</font>
<font color="red">1179.         stack = self.stack</font>
<font color="red">1180.         value = stack.pop()</font>
<font color="red">1181.         list = stack[-1]</font>
<font color="red">1182.         list.append(value)</font>
<font color="green">1183.     dispatch[APPEND] = load_append</font>
<font color="black">1184. </font>
<font color="green">1185.     def load_appends(self):</font>
<font color="red">1186.         stack = self.stack</font>
<font color="red">1187.         mark = self.marker()</font>
<font color="red">1188.         list = stack[mark - 1]</font>
<font color="red">1189.         list.extend(stack[mark + 1:])</font>
<font color="red">1190.         del stack[mark:]</font>
<font color="green">1191.     dispatch[APPENDS] = load_appends</font>
<font color="black">1192. </font>
<font color="green">1193.     def load_setitem(self):</font>
<font color="red">1194.         stack = self.stack</font>
<font color="red">1195.         value = stack.pop()</font>
<font color="red">1196.         key = stack.pop()</font>
<font color="red">1197.         dict = stack[-1]</font>
<font color="red">1198.         dict[key] = value</font>
<font color="green">1199.     dispatch[SETITEM] = load_setitem</font>
<font color="black">1200. </font>
<font color="green">1201.     def load_setitems(self):</font>
<font color="red">1202.         stack = self.stack</font>
<font color="red">1203.         mark = self.marker()</font>
<font color="red">1204.         dict = stack[mark - 1]</font>
<font color="red">1205.         for i in range(mark + 1, len(stack), 2):</font>
<font color="red">1206.             dict[stack[i]] = stack[i + 1]</font>
<font color="black">1207. </font>
<font color="red">1208.         del stack[mark:]</font>
<font color="green">1209.     dispatch[SETITEMS] = load_setitems</font>
<font color="black">1210. </font>
<font color="green">1211.     def load_build(self):</font>
<font color="red">1212.         stack = self.stack</font>
<font color="red">1213.         state = stack.pop()</font>
<font color="red">1214.         inst = stack[-1]</font>
<font color="red">1215.         setstate = getattr(inst, &quot;__setstate__&quot;, None)</font>
<font color="red">1216.         if setstate:</font>
<font color="red">1217.             setstate(state)</font>
<font color="red">1218.             return</font>
<font color="red">1219.         slotstate = None</font>
<font color="red">1220.         if isinstance(state, tuple) and len(state) == 2:</font>
<font color="red">1221.             state, slotstate = state</font>
<font color="red">1222.         if state:</font>
<font color="red">1223.             try:</font>
<font color="red">1224.                 d = inst.__dict__</font>
<font color="red">1225.                 try:</font>
<font color="red">1226.                     for k, v in state.iteritems():</font>
<font color="red">1227.                         d[intern(k)] = v</font>
<font color="black">1228.                 # keys in state don't have to be strings</font>
<font color="black">1229.                 # don't blow up, but don't go out of our way</font>
<font color="red">1230.                 except TypeError:</font>
<font color="red">1231.                     d.update(state)</font>
<font color="black">1232. </font>
<font color="red">1233.             except RuntimeError:</font>
<font color="black">1234.                 # XXX In restricted execution, the instance's __dict__</font>
<font color="black">1235.                 # is not accessible.  Use the old way of unpickling</font>
<font color="black">1236.                 # the instance variables.  This is a semantic</font>
<font color="black">1237.                 # difference when unpickling in restricted</font>
<font color="black">1238.                 # vs. unrestricted modes.</font>
<font color="black">1239.                 # Note, however, that cPickle has never tried to do the</font>
<font color="black">1240.                 # .update() business, and always uses</font>
<font color="black">1241.                 #     PyObject_SetItem(inst.__dict__, key, value) in a</font>
<font color="black">1242.                 # loop over state.items().</font>
<font color="red">1243.                 for k, v in state.items():</font>
<font color="red">1244.                     setattr(inst, k, v)</font>
<font color="red">1245.         if slotstate:</font>
<font color="red">1246.             for k, v in slotstate.items():</font>
<font color="red">1247.                 setattr(inst, k, v)</font>
<font color="green">1248.     dispatch[BUILD] = load_build</font>
<font color="black">1249. </font>
<font color="green">1250.     def load_mark(self):</font>
<font color="red">1251.         self.append(self.mark)</font>
<font color="green">1252.     dispatch[MARK] = load_mark</font>
<font color="black">1253. </font>
<font color="green">1254.     def load_stop(self):</font>
<font color="red">1255.         value = self.stack.pop()</font>
<font color="red">1256.         raise _Stop(value)</font>
<font color="green">1257.     dispatch[STOP] = load_stop</font>
<font color="black">1258. </font>
<font color="black">1259. # Helper class for load_inst/load_obj</font>
<font color="black">1260. </font>
<font color="green">1261. class _EmptyClass:</font>
<font color="green">1262.     pass</font>
<font color="black">1263. </font>
<font color="black">1264. # Encode/decode longs in linear time.</font>
<font color="black">1265. </font>
<font color="green">1266. import binascii as _binascii</font>
<font color="black">1267. </font>
<font color="green">1268. def encode_long(x):</font>
<font color="black">1269.     r&quot;&quot;&quot;Encode a long to a two's complement little-endian binary string.</font>
<font color="black">1270.     Note that 0L is a special case, returning an empty string, to save a</font>
<font color="black">1271.     byte in the LONG1 pickling context.</font>
<font color="black">1272. </font>
<font color="black">1273.     &gt;&gt;&gt; encode_long(0L)</font>
<font color="black">1274.     ''</font>
<font color="black">1275.     &gt;&gt;&gt; encode_long(255L)</font>
<font color="black">1276.     '\xff\x00'</font>
<font color="black">1277.     &gt;&gt;&gt; encode_long(32767L)</font>
<font color="black">1278.     '\xff\x7f'</font>
<font color="black">1279.     &gt;&gt;&gt; encode_long(-256L)</font>
<font color="black">1280.     '\x00\xff'</font>
<font color="black">1281.     &gt;&gt;&gt; encode_long(-32768L)</font>
<font color="black">1282.     '\x00\x80'</font>
<font color="black">1283.     &gt;&gt;&gt; encode_long(-128L)</font>
<font color="black">1284.     '\x80'</font>
<font color="black">1285.     &gt;&gt;&gt; encode_long(127L)</font>
<font color="black">1286.     '\x7f'</font>
<font color="black">1287.     &gt;&gt;&gt;</font>
<font color="black">1288.     &quot;&quot;&quot;</font>
<font color="black">1289. </font>
<font color="red">1290.     if x == 0:</font>
<font color="red">1291.         return ''</font>
<font color="red">1292.     if x &gt; 0:</font>
<font color="red">1293.         ashex = hex(x)</font>
<font color="red">1294.         assert ashex.startswith(&quot;0x&quot;)</font>
<font color="red">1295.         njunkchars = 2 + ashex.endswith('L')</font>
<font color="red">1296.         nibbles = len(ashex) - njunkchars</font>
<font color="red">1297.         if nibbles &amp; 1:</font>
<font color="black">1298.             # need an even # of nibbles for unhexlify</font>
<font color="red">1299.             ashex = &quot;0x0&quot; + ashex[2:]</font>
<font color="red">1300.         elif int(ashex[2], 16) &gt;= 8:</font>
<font color="black">1301.             # &quot;looks negative&quot;, so need a byte of sign bits</font>
<font color="red">1302.             ashex = &quot;0x00&quot; + ashex[2:]</font>
<font color="black">1303.     else:</font>
<font color="black">1304.         # Build the 256's-complement:  (1L &lt;&lt; nbytes) + x.  The trick is</font>
<font color="black">1305.         # to find the number of bytes in linear time (although that should</font>
<font color="black">1306.         # really be a constant-time task).</font>
<font color="red">1307.         ashex = hex(-x)</font>
<font color="red">1308.         assert ashex.startswith(&quot;0x&quot;)</font>
<font color="red">1309.         njunkchars = 2 + ashex.endswith('L')</font>
<font color="red">1310.         nibbles = len(ashex) - njunkchars</font>
<font color="red">1311.         if nibbles &amp; 1:</font>
<font color="black">1312.             # Extend to a full byte.</font>
<font color="red">1313.             nibbles += 1</font>
<font color="red">1314.         nbits = nibbles * 4</font>
<font color="red">1315.         x += 1L &lt;&lt; nbits</font>
<font color="red">1316.         assert x &gt; 0</font>
<font color="red">1317.         ashex = hex(x)</font>
<font color="red">1318.         njunkchars = 2 + ashex.endswith('L')</font>
<font color="red">1319.         newnibbles = len(ashex) - njunkchars</font>
<font color="red">1320.         if newnibbles &lt; nibbles:</font>
<font color="red">1321.             ashex = &quot;0x&quot; + &quot;0&quot; * (nibbles - newnibbles) + ashex[2:]</font>
<font color="red">1322.         if int(ashex[2], 16) &lt; 8:</font>
<font color="black">1323.             # &quot;looks positive&quot;, so need a byte of sign bits</font>
<font color="red">1324.             ashex = &quot;0xff&quot; + ashex[2:]</font>
<font color="black">1325. </font>
<font color="red">1326.     if ashex.endswith('L'):</font>
<font color="red">1327.         ashex = ashex[2:-1]</font>
<font color="black">1328.     else:</font>
<font color="red">1329.         ashex = ashex[2:]</font>
<font color="red">1330.     assert len(ashex) &amp; 1 == 0, (x, ashex)</font>
<font color="red">1331.     binary = _binascii.unhexlify(ashex)</font>
<font color="red">1332.     return binary[::-1]</font>
<font color="black">1333. </font>
<font color="green">1334. def decode_long(data):</font>
<font color="black">1335.     r&quot;&quot;&quot;Decode a long from a two's complement little-endian binary string.</font>
<font color="black">1336. </font>
<font color="black">1337.     &gt;&gt;&gt; decode_long('')</font>
<font color="black">1338.     0L</font>
<font color="black">1339.     &gt;&gt;&gt; decode_long(&quot;\xff\x00&quot;)</font>
<font color="black">1340.     255L</font>
<font color="black">1341.     &gt;&gt;&gt; decode_long(&quot;\xff\x7f&quot;)</font>
<font color="black">1342.     32767L</font>
<font color="black">1343.     &gt;&gt;&gt; decode_long(&quot;\x00\xff&quot;)</font>
<font color="black">1344.     -256L</font>
<font color="black">1345.     &gt;&gt;&gt; decode_long(&quot;\x00\x80&quot;)</font>
<font color="black">1346.     -32768L</font>
<font color="black">1347.     &gt;&gt;&gt; decode_long(&quot;\x80&quot;)</font>
<font color="black">1348.     -128L</font>
<font color="black">1349.     &gt;&gt;&gt; decode_long(&quot;\x7f&quot;)</font>
<font color="black">1350.     127L</font>
<font color="black">1351.     &quot;&quot;&quot;</font>
<font color="black">1352. </font>
<font color="red">1353.     nbytes = len(data)</font>
<font color="red">1354.     if nbytes == 0:</font>
<font color="red">1355.         return 0L</font>
<font color="red">1356.     ashex = _binascii.hexlify(data[::-1])</font>
<font color="red">1357.     n = long(ashex, 16) # quadratic time before Python 2.3; linear now</font>
<font color="red">1358.     if data[-1] &gt;= '\x80':</font>
<font color="red">1359.         n -= 1L &lt;&lt; (nbytes * 8)</font>
<font color="red">1360.     return n</font>
<font color="black">1361. </font>
<font color="black">1362. # Shorthands</font>
<font color="black">1363. </font>
<font color="green">1364. try:</font>
<font color="green">1365.     from cStringIO import StringIO</font>
<font color="red">1366. except ImportError:</font>
<font color="red">1367.     from StringIO import StringIO</font>
<font color="black">1368. </font>
<font color="green">1369. def dump(obj, file, protocol=None):</font>
<font color="red">1370.     Pickler(file, protocol).dump(obj)</font>
<font color="black">1371. </font>
<font color="green">1372. def dumps(obj, protocol=None):</font>
<font color="red">1373.     file = StringIO()</font>
<font color="red">1374.     Pickler(file, protocol).dump(obj)</font>
<font color="red">1375.     return file.getvalue()</font>
<font color="black">1376. </font>
<font color="green">1377. def load(file):</font>
<font color="red">1378.     return Unpickler(file).load()</font>
<font color="black">1379. </font>
<font color="green">1380. def loads(str):</font>
<font color="red">1381.     file = StringIO(str)</font>
<font color="red">1382.     return Unpickler(file).load()</font>
<font color="black">1383. </font>
<font color="black">1384. # Doctest</font>
<font color="black">1385. </font>
<font color="green">1386. def _test():</font>
<font color="red">1387.     import doctest</font>
<font color="red">1388.     return doctest.testmod()</font>
<font color="black">1389. </font>
<font color="green">1390. if __name__ == &quot;__main__&quot;:</font>
<font color="red">1391.     _test()</font>
</pre>

