source file: <b>/usr/lib/python2.7/decimal.py</b><br>


file stats: <b>2616 lines, 414 executed: 15.8% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2004 Python Software Foundation.</font>
<font color="black">   2. # All rights reserved.</font>
<font color="black">   3. </font>
<font color="black">   4. # Written by Eric Price &lt;eprice at tjhsst.edu&gt;</font>
<font color="black">   5. #    and Facundo Batista &lt;facundo at taniquetil.com.ar&gt;</font>
<font color="black">   6. #    and Raymond Hettinger &lt;python at rcn.com&gt;</font>
<font color="black">   7. #    and Aahz &lt;aahz at pobox.com&gt;</font>
<font color="black">   8. #    and Tim Peters</font>
<font color="black">   9. </font>
<font color="black">  10. # This module is currently Py2.3 compatible and should be kept that way</font>
<font color="black">  11. # unless a major compelling advantage arises.  IOW, 2.3 compatibility is</font>
<font color="black">  12. # strongly preferred, but not guaranteed.</font>
<font color="black">  13. </font>
<font color="black">  14. # Also, this module should be kept in sync with the latest updates of</font>
<font color="black">  15. # the IBM specification as it evolves.  Those updates will be treated</font>
<font color="black">  16. # as bug fixes (deviation from the spec is a compatibility, usability</font>
<font color="black">  17. # bug) and will be backported.  At this point the spec is stabilizing</font>
<font color="black">  18. # and the updates are becoming fewer, smaller, and less significant.</font>
<font color="black">  19. </font>
<font color="black">  20. &quot;&quot;&quot;</font>
<font color="black">  21. This is a Py2.3 implementation of decimal floating point arithmetic based on</font>
<font color="black">  22. the General Decimal Arithmetic Specification:</font>
<font color="black">  23. </font>
<font color="black">  24.     http://speleotrove.com/decimal/decarith.html</font>
<font color="black">  25. </font>
<font color="black">  26. and IEEE standard 854-1987:</font>
<font color="black">  27. </font>
<font color="black">  28.     http://en.wikipedia.org/wiki/IEEE_854-1987</font>
<font color="black">  29. </font>
<font color="black">  30. Decimal floating point has finite precision with arbitrarily large bounds.</font>
<font color="black">  31. </font>
<font color="black">  32. The purpose of this module is to support arithmetic using familiar</font>
<font color="black">  33. &quot;schoolhouse&quot; rules and to avoid some of the tricky representation</font>
<font color="black">  34. issues associated with binary floating point.  The package is especially</font>
<font color="black">  35. useful for financial applications or for contexts where users have</font>
<font color="black">  36. expectations that are at odds with binary floating point (for instance,</font>
<font color="black">  37. in binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead</font>
<font color="black">  38. of the expected Decimal('0.00') returned by decimal floating point).</font>
<font color="black">  39. </font>
<font color="black">  40. Here are some examples of using the decimal module:</font>
<font color="black">  41. </font>
<font color="black">  42. &gt;&gt;&gt; from decimal import *</font>
<font color="black">  43. &gt;&gt;&gt; setcontext(ExtendedContext)</font>
<font color="black">  44. &gt;&gt;&gt; Decimal(0)</font>
<font color="black">  45. Decimal('0')</font>
<font color="black">  46. &gt;&gt;&gt; Decimal('1')</font>
<font color="black">  47. Decimal('1')</font>
<font color="black">  48. &gt;&gt;&gt; Decimal('-.0123')</font>
<font color="black">  49. Decimal('-0.0123')</font>
<font color="black">  50. &gt;&gt;&gt; Decimal(123456)</font>
<font color="black">  51. Decimal('123456')</font>
<font color="black">  52. &gt;&gt;&gt; Decimal('123.45e12345678901234567890')</font>
<font color="black">  53. Decimal('1.2345E+12345678901234567892')</font>
<font color="black">  54. &gt;&gt;&gt; Decimal('1.33') + Decimal('1.27')</font>
<font color="black">  55. Decimal('2.60')</font>
<font color="black">  56. &gt;&gt;&gt; Decimal('12.34') + Decimal('3.87') - Decimal('18.41')</font>
<font color="black">  57. Decimal('-2.20')</font>
<font color="black">  58. &gt;&gt;&gt; dig = Decimal(1)</font>
<font color="black">  59. &gt;&gt;&gt; print dig / Decimal(3)</font>
<font color="black">  60. 0.333333333</font>
<font color="black">  61. &gt;&gt;&gt; getcontext().prec = 18</font>
<font color="black">  62. &gt;&gt;&gt; print dig / Decimal(3)</font>
<font color="black">  63. 0.333333333333333333</font>
<font color="black">  64. &gt;&gt;&gt; print dig.sqrt()</font>
<font color="black">  65. 1</font>
<font color="black">  66. &gt;&gt;&gt; print Decimal(3).sqrt()</font>
<font color="black">  67. 1.73205080756887729</font>
<font color="black">  68. &gt;&gt;&gt; print Decimal(3) ** 123</font>
<font color="black">  69. 4.85192780976896427E+58</font>
<font color="black">  70. &gt;&gt;&gt; inf = Decimal(1) / Decimal(0)</font>
<font color="black">  71. &gt;&gt;&gt; print inf</font>
<font color="black">  72. Infinity</font>
<font color="black">  73. &gt;&gt;&gt; neginf = Decimal(-1) / Decimal(0)</font>
<font color="black">  74. &gt;&gt;&gt; print neginf</font>
<font color="black">  75. -Infinity</font>
<font color="black">  76. &gt;&gt;&gt; print neginf + inf</font>
<font color="black">  77. NaN</font>
<font color="black">  78. &gt;&gt;&gt; print neginf * inf</font>
<font color="black">  79. -Infinity</font>
<font color="black">  80. &gt;&gt;&gt; print dig / 0</font>
<font color="black">  81. Infinity</font>
<font color="black">  82. &gt;&gt;&gt; getcontext().traps[DivisionByZero] = 1</font>
<font color="black">  83. &gt;&gt;&gt; print dig / 0</font>
<font color="black">  84. Traceback (most recent call last):</font>
<font color="black">  85.   ...</font>
<font color="black">  86.   ...</font>
<font color="black">  87.   ...</font>
<font color="black">  88. DivisionByZero: x / 0</font>
<font color="black">  89. &gt;&gt;&gt; c = Context()</font>
<font color="black">  90. &gt;&gt;&gt; c.traps[InvalidOperation] = 0</font>
<font color="black">  91. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">  92. 0</font>
<font color="black">  93. &gt;&gt;&gt; c.divide(Decimal(0), Decimal(0))</font>
<font color="black">  94. Decimal('NaN')</font>
<font color="black">  95. &gt;&gt;&gt; c.traps[InvalidOperation] = 1</font>
<font color="black">  96. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">  97. 1</font>
<font color="black">  98. &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black">  99. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black"> 100. 0</font>
<font color="black"> 101. &gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))</font>
<font color="black"> 102. Traceback (most recent call last):</font>
<font color="black"> 103.   ...</font>
<font color="black"> 104.   ...</font>
<font color="black"> 105.   ...</font>
<font color="black"> 106. InvalidOperation: 0 / 0</font>
<font color="black"> 107. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black"> 108. 1</font>
<font color="black"> 109. &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black"> 110. &gt;&gt;&gt; c.traps[InvalidOperation] = 0</font>
<font color="black"> 111. &gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))</font>
<font color="black"> 112. NaN</font>
<font color="black"> 113. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black"> 114. 1</font>
<font color="black"> 115. &gt;&gt;&gt;</font>
<font color="green"> 116. &quot;&quot;&quot;</font>
<font color="black"> 117. </font>
<font color="black"> 118. __all__ = [</font>
<font color="black"> 119.     # Two major classes</font>
<font color="green"> 120.     'Decimal', 'Context',</font>
<font color="black"> 121. </font>
<font color="black"> 122.     # Contexts</font>
<font color="green"> 123.     'DefaultContext', 'BasicContext', 'ExtendedContext',</font>
<font color="black"> 124. </font>
<font color="black"> 125.     # Exceptions</font>
<font color="green"> 126.     'DecimalException', 'Clamped', 'InvalidOperation', 'DivisionByZero',</font>
<font color="green"> 127.     'Inexact', 'Rounded', 'Subnormal', 'Overflow', 'Underflow',</font>
<font color="black"> 128. </font>
<font color="black"> 129.     # Constants for use in setting up contexts</font>
<font color="green"> 130.     'ROUND_DOWN', 'ROUND_HALF_UP', 'ROUND_HALF_EVEN', 'ROUND_CEILING',</font>
<font color="green"> 131.     'ROUND_FLOOR', 'ROUND_UP', 'ROUND_HALF_DOWN', 'ROUND_05UP',</font>
<font color="black"> 132. </font>
<font color="black"> 133.     # Functions for manipulating contexts</font>
<font color="green"> 134.     'setcontext', 'getcontext', 'localcontext'</font>
<font color="black"> 135. ]</font>
<font color="black"> 136. </font>
<font color="green"> 137. __version__ = '1.70'    # Highest version of the spec this complies with</font>
<font color="black"> 138. </font>
<font color="green"> 139. import copy as _copy</font>
<font color="green"> 140. import math as _math</font>
<font color="green"> 141. import numbers as _numbers</font>
<font color="black"> 142. </font>
<font color="green"> 143. try:</font>
<font color="green"> 144.     from collections import namedtuple as _namedtuple</font>
<font color="green"> 145.     DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')</font>
<font color="red"> 146. except ImportError:</font>
<font color="red"> 147.     DecimalTuple = lambda *args: args</font>
<font color="black"> 148. </font>
<font color="black"> 149. # Rounding</font>
<font color="green"> 150. ROUND_DOWN = 'ROUND_DOWN'</font>
<font color="green"> 151. ROUND_HALF_UP = 'ROUND_HALF_UP'</font>
<font color="green"> 152. ROUND_HALF_EVEN = 'ROUND_HALF_EVEN'</font>
<font color="green"> 153. ROUND_CEILING = 'ROUND_CEILING'</font>
<font color="green"> 154. ROUND_FLOOR = 'ROUND_FLOOR'</font>
<font color="green"> 155. ROUND_UP = 'ROUND_UP'</font>
<font color="green"> 156. ROUND_HALF_DOWN = 'ROUND_HALF_DOWN'</font>
<font color="green"> 157. ROUND_05UP = 'ROUND_05UP'</font>
<font color="black"> 158. </font>
<font color="black"> 159. # Errors</font>
<font color="black"> 160. </font>
<font color="green"> 161. class DecimalException(ArithmeticError):</font>
<font color="black"> 162.     &quot;&quot;&quot;Base exception class.</font>
<font color="black"> 163. </font>
<font color="black"> 164.     Used exceptions derive from this.</font>
<font color="black"> 165.     If an exception derives from another exception besides this (such as</font>
<font color="black"> 166.     Underflow (Inexact, Rounded, Subnormal) that indicates that it is only</font>
<font color="black"> 167.     called if the others are present.  This isn't actually used for</font>
<font color="black"> 168.     anything, though.</font>
<font color="black"> 169. </font>
<font color="black"> 170.     handle  -- Called when context._raise_error is called and the</font>
<font color="black"> 171.                trap_enabler is not set.  First argument is self, second is the</font>
<font color="black"> 172.                context.  More arguments can be given, those being after</font>
<font color="black"> 173.                the explanation in _raise_error (For example,</font>
<font color="black"> 174.                context._raise_error(NewError, '(-x)!', self._sign) would</font>
<font color="black"> 175.                call NewError().handle(context, self._sign).)</font>
<font color="black"> 176. </font>
<font color="black"> 177.     To define a new exception, it should be sufficient to have it derive</font>
<font color="black"> 178.     from DecimalException.</font>
<font color="green"> 179.     &quot;&quot;&quot;</font>
<font color="green"> 180.     def handle(self, context, *args):</font>
<font color="red"> 181.         pass</font>
<font color="black"> 182. </font>
<font color="black"> 183. </font>
<font color="green"> 184. class Clamped(DecimalException):</font>
<font color="black"> 185.     &quot;&quot;&quot;Exponent of a 0 changed to fit bounds.</font>
<font color="black"> 186. </font>
<font color="black"> 187.     This occurs and signals clamped if the exponent of a result has been</font>
<font color="black"> 188.     altered in order to fit the constraints of a specific concrete</font>
<font color="black"> 189.     representation.  This may occur when the exponent of a zero result would</font>
<font color="black"> 190.     be outside the bounds of a representation, or when a large normal</font>
<font color="black"> 191.     number would have an encoded exponent that cannot be represented.  In</font>
<font color="black"> 192.     this latter case, the exponent is reduced to fit and the corresponding</font>
<font color="black"> 193.     number of zero digits are appended to the coefficient (&quot;fold-down&quot;).</font>
<font color="green"> 194.     &quot;&quot;&quot;</font>
<font color="black"> 195. </font>
<font color="green"> 196. class InvalidOperation(DecimalException):</font>
<font color="black"> 197.     &quot;&quot;&quot;An invalid operation was performed.</font>
<font color="black"> 198. </font>
<font color="black"> 199.     Various bad things cause this:</font>
<font color="black"> 200. </font>
<font color="black"> 201.     Something creates a signaling NaN</font>
<font color="black"> 202.     -INF + INF</font>
<font color="black"> 203.     0 * (+-)INF</font>
<font color="black"> 204.     (+-)INF / (+-)INF</font>
<font color="black"> 205.     x % 0</font>
<font color="black"> 206.     (+-)INF % x</font>
<font color="black"> 207.     x._rescale( non-integer )</font>
<font color="black"> 208.     sqrt(-x) , x &gt; 0</font>
<font color="black"> 209.     0 ** 0</font>
<font color="black"> 210.     x ** (non-integer)</font>
<font color="black"> 211.     x ** (+-)INF</font>
<font color="black"> 212.     An operand is invalid</font>
<font color="black"> 213. </font>
<font color="black"> 214.     The result of the operation after these is a quiet positive NaN,</font>
<font color="black"> 215.     except when the cause is a signaling NaN, in which case the result is</font>
<font color="black"> 216.     also a quiet NaN, but with the original sign, and an optional</font>
<font color="black"> 217.     diagnostic information.</font>
<font color="green"> 218.     &quot;&quot;&quot;</font>
<font color="green"> 219.     def handle(self, context, *args):</font>
<font color="red"> 220.         if args:</font>
<font color="red"> 221.             ans = _dec_from_triple(args[0]._sign, args[0]._int, 'n', True)</font>
<font color="red"> 222.             return ans._fix_nan(context)</font>
<font color="red"> 223.         return _NaN</font>
<font color="black"> 224. </font>
<font color="green"> 225. class ConversionSyntax(InvalidOperation):</font>
<font color="black"> 226.     &quot;&quot;&quot;Trying to convert badly formed string.</font>
<font color="black"> 227. </font>
<font color="black"> 228.     This occurs and signals invalid-operation if an string is being</font>
<font color="black"> 229.     converted to a number and it does not conform to the numeric string</font>
<font color="black"> 230.     syntax.  The result is [0,qNaN].</font>
<font color="green"> 231.     &quot;&quot;&quot;</font>
<font color="green"> 232.     def handle(self, context, *args):</font>
<font color="red"> 233.         return _NaN</font>
<font color="black"> 234. </font>
<font color="green"> 235. class DivisionByZero(DecimalException, ZeroDivisionError):</font>
<font color="black"> 236.     &quot;&quot;&quot;Division by 0.</font>
<font color="black"> 237. </font>
<font color="black"> 238.     This occurs and signals division-by-zero if division of a finite number</font>
<font color="black"> 239.     by zero was attempted (during a divide-integer or divide operation, or a</font>
<font color="black"> 240.     power operation with negative right-hand operand), and the dividend was</font>
<font color="black"> 241.     not zero.</font>
<font color="black"> 242. </font>
<font color="black"> 243.     The result of the operation is [sign,inf], where sign is the exclusive</font>
<font color="black"> 244.     or of the signs of the operands for divide, or is 1 for an odd power of</font>
<font color="black"> 245.     -0, for power.</font>
<font color="green"> 246.     &quot;&quot;&quot;</font>
<font color="black"> 247. </font>
<font color="green"> 248.     def handle(self, context, sign, *args):</font>
<font color="red"> 249.         return _SignedInfinity[sign]</font>
<font color="black"> 250. </font>
<font color="green"> 251. class DivisionImpossible(InvalidOperation):</font>
<font color="black"> 252.     &quot;&quot;&quot;Cannot perform the division adequately.</font>
<font color="black"> 253. </font>
<font color="black"> 254.     This occurs and signals invalid-operation if the integer result of a</font>
<font color="black"> 255.     divide-integer or remainder operation had too many digits (would be</font>
<font color="black"> 256.     longer than precision).  The result is [0,qNaN].</font>
<font color="green"> 257.     &quot;&quot;&quot;</font>
<font color="black"> 258. </font>
<font color="green"> 259.     def handle(self, context, *args):</font>
<font color="red"> 260.         return _NaN</font>
<font color="black"> 261. </font>
<font color="green"> 262. class DivisionUndefined(InvalidOperation, ZeroDivisionError):</font>
<font color="black"> 263.     &quot;&quot;&quot;Undefined result of division.</font>
<font color="black"> 264. </font>
<font color="black"> 265.     This occurs and signals invalid-operation if division by zero was</font>
<font color="black"> 266.     attempted (during a divide-integer, divide, or remainder operation), and</font>
<font color="black"> 267.     the dividend is also zero.  The result is [0,qNaN].</font>
<font color="green"> 268.     &quot;&quot;&quot;</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def handle(self, context, *args):</font>
<font color="red"> 271.         return _NaN</font>
<font color="black"> 272. </font>
<font color="green"> 273. class Inexact(DecimalException):</font>
<font color="black"> 274.     &quot;&quot;&quot;Had to round, losing information.</font>
<font color="black"> 275. </font>
<font color="black"> 276.     This occurs and signals inexact whenever the result of an operation is</font>
<font color="black"> 277.     not exact (that is, it needed to be rounded and any discarded digits</font>
<font color="black"> 278.     were non-zero), or if an overflow or underflow condition occurs.  The</font>
<font color="black"> 279.     result in all cases is unchanged.</font>
<font color="black"> 280. </font>
<font color="black"> 281.     The inexact signal may be tested (or trapped) to determine if a given</font>
<font color="black"> 282.     operation (or sequence of operations) was inexact.</font>
<font color="green"> 283.     &quot;&quot;&quot;</font>
<font color="black"> 284. </font>
<font color="green"> 285. class InvalidContext(InvalidOperation):</font>
<font color="black"> 286.     &quot;&quot;&quot;Invalid context.  Unknown rounding, for example.</font>
<font color="black"> 287. </font>
<font color="black"> 288.     This occurs and signals invalid-operation if an invalid context was</font>
<font color="black"> 289.     detected during an operation.  This can occur if contexts are not checked</font>
<font color="black"> 290.     on creation and either the precision exceeds the capability of the</font>
<font color="black"> 291.     underlying concrete representation or an unknown or unsupported rounding</font>
<font color="black"> 292.     was specified.  These aspects of the context need only be checked when</font>
<font color="black"> 293.     the values are required to be used.  The result is [0,qNaN].</font>
<font color="green"> 294.     &quot;&quot;&quot;</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def handle(self, context, *args):</font>
<font color="red"> 297.         return _NaN</font>
<font color="black"> 298. </font>
<font color="green"> 299. class Rounded(DecimalException):</font>
<font color="black"> 300.     &quot;&quot;&quot;Number got rounded (not  necessarily changed during rounding).</font>
<font color="black"> 301. </font>
<font color="black"> 302.     This occurs and signals rounded whenever the result of an operation is</font>
<font color="black"> 303.     rounded (that is, some zero or non-zero digits were discarded from the</font>
<font color="black"> 304.     coefficient), or if an overflow or underflow condition occurs.  The</font>
<font color="black"> 305.     result in all cases is unchanged.</font>
<font color="black"> 306. </font>
<font color="black"> 307.     The rounded signal may be tested (or trapped) to determine if a given</font>
<font color="black"> 308.     operation (or sequence of operations) caused a loss of precision.</font>
<font color="green"> 309.     &quot;&quot;&quot;</font>
<font color="black"> 310. </font>
<font color="green"> 311. class Subnormal(DecimalException):</font>
<font color="black"> 312.     &quot;&quot;&quot;Exponent &lt; Emin before rounding.</font>
<font color="black"> 313. </font>
<font color="black"> 314.     This occurs and signals subnormal whenever the result of a conversion or</font>
<font color="black"> 315.     operation is subnormal (that is, its adjusted exponent is less than</font>
<font color="black"> 316.     Emin, before any rounding).  The result in all cases is unchanged.</font>
<font color="black"> 317. </font>
<font color="black"> 318.     The subnormal signal may be tested (or trapped) to determine if a given</font>
<font color="black"> 319.     or operation (or sequence of operations) yielded a subnormal result.</font>
<font color="green"> 320.     &quot;&quot;&quot;</font>
<font color="black"> 321. </font>
<font color="green"> 322. class Overflow(Inexact, Rounded):</font>
<font color="black"> 323.     &quot;&quot;&quot;Numerical overflow.</font>
<font color="black"> 324. </font>
<font color="black"> 325.     This occurs and signals overflow if the adjusted exponent of a result</font>
<font color="black"> 326.     (from a conversion or from an operation that is not an attempt to divide</font>
<font color="black"> 327.     by zero), after rounding, would be greater than the largest value that</font>
<font color="black"> 328.     can be handled by the implementation (the value Emax).</font>
<font color="black"> 329. </font>
<font color="black"> 330.     The result depends on the rounding mode:</font>
<font color="black"> 331. </font>
<font color="black"> 332.     For round-half-up and round-half-even (and for round-half-down and</font>
<font color="black"> 333.     round-up, if implemented), the result of the operation is [sign,inf],</font>
<font color="black"> 334.     where sign is the sign of the intermediate result.  For round-down, the</font>
<font color="black"> 335.     result is the largest finite number that can be represented in the</font>
<font color="black"> 336.     current precision, with the sign of the intermediate result.  For</font>
<font color="black"> 337.     round-ceiling, the result is the same as for round-down if the sign of</font>
<font color="black"> 338.     the intermediate result is 1, or is [0,inf] otherwise.  For round-floor,</font>
<font color="black"> 339.     the result is the same as for round-down if the sign of the intermediate</font>
<font color="black"> 340.     result is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded</font>
<font color="black"> 341.     will also be raised.</font>
<font color="green"> 342.     &quot;&quot;&quot;</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def handle(self, context, sign, *args):</font>
<font color="red"> 345.         if context.rounding in (ROUND_HALF_UP, ROUND_HALF_EVEN,</font>
<font color="red"> 346.                                 ROUND_HALF_DOWN, ROUND_UP):</font>
<font color="red"> 347.             return _SignedInfinity[sign]</font>
<font color="red"> 348.         if sign == 0:</font>
<font color="red"> 349.             if context.rounding == ROUND_CEILING:</font>
<font color="red"> 350.                 return _SignedInfinity[sign]</font>
<font color="red"> 351.             return _dec_from_triple(sign, '9'*context.prec,</font>
<font color="red"> 352.                             context.Emax-context.prec+1)</font>
<font color="red"> 353.         if sign == 1:</font>
<font color="red"> 354.             if context.rounding == ROUND_FLOOR:</font>
<font color="red"> 355.                 return _SignedInfinity[sign]</font>
<font color="red"> 356.             return _dec_from_triple(sign, '9'*context.prec,</font>
<font color="red"> 357.                              context.Emax-context.prec+1)</font>
<font color="black"> 358. </font>
<font color="black"> 359. </font>
<font color="green"> 360. class Underflow(Inexact, Rounded, Subnormal):</font>
<font color="black"> 361.     &quot;&quot;&quot;Numerical underflow with result rounded to 0.</font>
<font color="black"> 362. </font>
<font color="black"> 363.     This occurs and signals underflow if a result is inexact and the</font>
<font color="black"> 364.     adjusted exponent of the result would be smaller (more negative) than</font>
<font color="black"> 365.     the smallest value that can be handled by the implementation (the value</font>
<font color="black"> 366.     Emin).  That is, the result is both inexact and subnormal.</font>
<font color="black"> 367. </font>
<font color="black"> 368.     The result after an underflow will be a subnormal number rounded, if</font>
<font color="black"> 369.     necessary, so that its exponent is not less than Etiny.  This may result</font>
<font color="black"> 370.     in 0 with the sign of the intermediate result and an exponent of Etiny.</font>
<font color="black"> 371. </font>
<font color="black"> 372.     In all cases, Inexact, Rounded, and Subnormal will also be raised.</font>
<font color="green"> 373.     &quot;&quot;&quot;</font>
<font color="black"> 374. </font>
<font color="black"> 375. # List of public traps and flags</font>
<font color="green"> 376. _signals = [Clamped, DivisionByZero, Inexact, Overflow, Rounded,</font>
<font color="green"> 377.            Underflow, InvalidOperation, Subnormal]</font>
<font color="black"> 378. </font>
<font color="black"> 379. # Map conditions (per the spec) to signals</font>
<font color="green"> 380. _condition_map = {ConversionSyntax:InvalidOperation,</font>
<font color="green"> 381.                   DivisionImpossible:InvalidOperation,</font>
<font color="green"> 382.                   DivisionUndefined:InvalidOperation,</font>
<font color="green"> 383.                   InvalidContext:InvalidOperation}</font>
<font color="black"> 384. </font>
<font color="black"> 385. ##### Context Functions ##################################################</font>
<font color="black"> 386. </font>
<font color="black"> 387. # The getcontext() and setcontext() function manage access to a thread-local</font>
<font color="black"> 388. # current context.  Py2.4 offers direct support for thread locals.  If that</font>
<font color="black"> 389. # is not available, use threading.currentThread() which is slower but will</font>
<font color="black"> 390. # work for older Pythons.  If threads are not part of the build, create a</font>
<font color="black"> 391. # mock threading object with threading.local() returning the module namespace.</font>
<font color="black"> 392. </font>
<font color="green"> 393. try:</font>
<font color="green"> 394.     import threading</font>
<font color="red"> 395. except ImportError:</font>
<font color="black"> 396.     # Python was compiled without threads; create a mock object instead</font>
<font color="red"> 397.     import sys</font>
<font color="red"> 398.     class MockThreading(object):</font>
<font color="red"> 399.         def local(self, sys=sys):</font>
<font color="red"> 400.             return sys.modules[__name__]</font>
<font color="red"> 401.     threading = MockThreading()</font>
<font color="red"> 402.     del sys, MockThreading</font>
<font color="black"> 403. </font>
<font color="green"> 404. try:</font>
<font color="green"> 405.     threading.local</font>
<font color="black"> 406. </font>
<font color="red"> 407. except AttributeError:</font>
<font color="black"> 408. </font>
<font color="black"> 409.     # To fix reloading, force it to create a new context</font>
<font color="black"> 410.     # Old contexts have different exceptions in their dicts, making problems.</font>
<font color="red"> 411.     if hasattr(threading.currentThread(), '__decimal_context__'):</font>
<font color="red"> 412.         del threading.currentThread().__decimal_context__</font>
<font color="black"> 413. </font>
<font color="red"> 414.     def setcontext(context):</font>
<font color="black"> 415.         &quot;&quot;&quot;Set this thread's context to context.&quot;&quot;&quot;</font>
<font color="red"> 416.         if context in (DefaultContext, BasicContext, ExtendedContext):</font>
<font color="red"> 417.             context = context.copy()</font>
<font color="red"> 418.             context.clear_flags()</font>
<font color="red"> 419.         threading.currentThread().__decimal_context__ = context</font>
<font color="black"> 420. </font>
<font color="red"> 421.     def getcontext():</font>
<font color="black"> 422.         &quot;&quot;&quot;Returns this thread's context.</font>
<font color="black"> 423. </font>
<font color="black"> 424.         If this thread does not yet have a context, returns</font>
<font color="black"> 425.         a new context and sets this thread's context.</font>
<font color="black"> 426.         New contexts are copies of DefaultContext.</font>
<font color="black"> 427.         &quot;&quot;&quot;</font>
<font color="red"> 428.         try:</font>
<font color="red"> 429.             return threading.currentThread().__decimal_context__</font>
<font color="red"> 430.         except AttributeError:</font>
<font color="red"> 431.             context = Context()</font>
<font color="red"> 432.             threading.currentThread().__decimal_context__ = context</font>
<font color="red"> 433.             return context</font>
<font color="black"> 434. </font>
<font color="black"> 435. else:</font>
<font color="black"> 436. </font>
<font color="green"> 437.     local = threading.local()</font>
<font color="green"> 438.     if hasattr(local, '__decimal_context__'):</font>
<font color="red"> 439.         del local.__decimal_context__</font>
<font color="black"> 440. </font>
<font color="green"> 441.     def getcontext(_local=local):</font>
<font color="black"> 442.         &quot;&quot;&quot;Returns this thread's context.</font>
<font color="black"> 443. </font>
<font color="black"> 444.         If this thread does not yet have a context, returns</font>
<font color="black"> 445.         a new context and sets this thread's context.</font>
<font color="black"> 446.         New contexts are copies of DefaultContext.</font>
<font color="black"> 447.         &quot;&quot;&quot;</font>
<font color="red"> 448.         try:</font>
<font color="red"> 449.             return _local.__decimal_context__</font>
<font color="red"> 450.         except AttributeError:</font>
<font color="red"> 451.             context = Context()</font>
<font color="red"> 452.             _local.__decimal_context__ = context</font>
<font color="red"> 453.             return context</font>
<font color="black"> 454. </font>
<font color="green"> 455.     def setcontext(context, _local=local):</font>
<font color="black"> 456.         &quot;&quot;&quot;Set this thread's context to context.&quot;&quot;&quot;</font>
<font color="red"> 457.         if context in (DefaultContext, BasicContext, ExtendedContext):</font>
<font color="red"> 458.             context = context.copy()</font>
<font color="red"> 459.             context.clear_flags()</font>
<font color="red"> 460.         _local.__decimal_context__ = context</font>
<font color="black"> 461. </font>
<font color="green"> 462.     del threading, local        # Don't contaminate the namespace</font>
<font color="black"> 463. </font>
<font color="green"> 464. def localcontext(ctx=None):</font>
<font color="black"> 465.     &quot;&quot;&quot;Return a context manager for a copy of the supplied context</font>
<font color="black"> 466. </font>
<font color="black"> 467.     Uses a copy of the current context if no context is specified</font>
<font color="black"> 468.     The returned context manager creates a local decimal context</font>
<font color="black"> 469.     in a with statement:</font>
<font color="black"> 470.         def sin(x):</font>
<font color="black"> 471.              with localcontext() as ctx:</font>
<font color="black"> 472.                  ctx.prec += 2</font>
<font color="black"> 473.                  # Rest of sin calculation algorithm</font>
<font color="black"> 474.                  # uses a precision 2 greater than normal</font>
<font color="black"> 475.              return +s  # Convert result to normal precision</font>
<font color="black"> 476. </font>
<font color="black"> 477.          def sin(x):</font>
<font color="black"> 478.              with localcontext(ExtendedContext):</font>
<font color="black"> 479.                  # Rest of sin calculation algorithm</font>
<font color="black"> 480.                  # uses the Extended Context from the</font>
<font color="black"> 481.                  # General Decimal Arithmetic Specification</font>
<font color="black"> 482.              return +s  # Convert result to normal context</font>
<font color="black"> 483. </font>
<font color="black"> 484.     &gt;&gt;&gt; setcontext(DefaultContext)</font>
<font color="black"> 485.     &gt;&gt;&gt; print getcontext().prec</font>
<font color="black"> 486.     28</font>
<font color="black"> 487.     &gt;&gt;&gt; with localcontext():</font>
<font color="black"> 488.     ...     ctx = getcontext()</font>
<font color="black"> 489.     ...     ctx.prec += 2</font>
<font color="black"> 490.     ...     print ctx.prec</font>
<font color="black"> 491.     ...</font>
<font color="black"> 492.     30</font>
<font color="black"> 493.     &gt;&gt;&gt; with localcontext(ExtendedContext):</font>
<font color="black"> 494.     ...     print getcontext().prec</font>
<font color="black"> 495.     ...</font>
<font color="black"> 496.     9</font>
<font color="black"> 497.     &gt;&gt;&gt; print getcontext().prec</font>
<font color="black"> 498.     28</font>
<font color="black"> 499.     &quot;&quot;&quot;</font>
<font color="red"> 500.     if ctx is None: ctx = getcontext()</font>
<font color="red"> 501.     return _ContextManager(ctx)</font>
<font color="black"> 502. </font>
<font color="black"> 503. </font>
<font color="black"> 504. ##### Decimal class #######################################################</font>
<font color="black"> 505. </font>
<font color="green"> 506. class Decimal(object):</font>
<font color="green"> 507.     &quot;&quot;&quot;Floating point class for decimal arithmetic.&quot;&quot;&quot;</font>
<font color="black"> 508. </font>
<font color="green"> 509.     __slots__ = ('_exp','_int','_sign', '_is_special')</font>
<font color="black"> 510.     # Generally, the value of the Decimal instance is given by</font>
<font color="black"> 511.     #  (-1)**_sign * _int * 10**_exp</font>
<font color="black"> 512.     # Special values are signified by _is_special == True</font>
<font color="black"> 513. </font>
<font color="black"> 514.     # We're immutable, so use __new__ not __init__</font>
<font color="green"> 515.     def __new__(cls, value=&quot;0&quot;, context=None):</font>
<font color="black"> 516.         &quot;&quot;&quot;Create a decimal point instance.</font>
<font color="black"> 517. </font>
<font color="black"> 518.         &gt;&gt;&gt; Decimal('3.14')              # string input</font>
<font color="black"> 519.         Decimal('3.14')</font>
<font color="black"> 520.         &gt;&gt;&gt; Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)</font>
<font color="black"> 521.         Decimal('3.14')</font>
<font color="black"> 522.         &gt;&gt;&gt; Decimal(314)                 # int or long</font>
<font color="black"> 523.         Decimal('314')</font>
<font color="black"> 524.         &gt;&gt;&gt; Decimal(Decimal(314))        # another decimal instance</font>
<font color="black"> 525.         Decimal('314')</font>
<font color="black"> 526.         &gt;&gt;&gt; Decimal('  3.14  \\n')        # leading and trailing whitespace okay</font>
<font color="black"> 527.         Decimal('3.14')</font>
<font color="black"> 528.         &quot;&quot;&quot;</font>
<font color="black"> 529. </font>
<font color="black"> 530.         # Note that the coefficient, self._int, is actually stored as</font>
<font color="black"> 531.         # a string rather than as a tuple of digits.  This speeds up</font>
<font color="black"> 532.         # the &quot;digits to integer&quot; and &quot;integer to digits&quot; conversions</font>
<font color="black"> 533.         # that are used in almost every arithmetic operation on</font>
<font color="black"> 534.         # Decimals.  This is an internal detail: the as_tuple function</font>
<font color="black"> 535.         # and the Decimal constructor still deal with tuples of</font>
<font color="black"> 536.         # digits.</font>
<font color="black"> 537. </font>
<font color="green"> 538.         self = object.__new__(cls)</font>
<font color="black"> 539. </font>
<font color="black"> 540.         # From a string</font>
<font color="black"> 541.         # REs insist on real strings, so we can too.</font>
<font color="green"> 542.         if isinstance(value, basestring):</font>
<font color="green"> 543.             m = _parser(value.strip())</font>
<font color="green"> 544.             if m is None:</font>
<font color="red"> 545.                 if context is None:</font>
<font color="red"> 546.                     context = getcontext()</font>
<font color="red"> 547.                 return context._raise_error(ConversionSyntax,</font>
<font color="red"> 548.                                 &quot;Invalid literal for Decimal: %r&quot; % value)</font>
<font color="black"> 549. </font>
<font color="green"> 550.             if m.group('sign') == &quot;-&quot;:</font>
<font color="green"> 551.                 self._sign = 1</font>
<font color="black"> 552.             else:</font>
<font color="green"> 553.                 self._sign = 0</font>
<font color="green"> 554.             intpart = m.group('int')</font>
<font color="green"> 555.             if intpart is not None:</font>
<font color="black"> 556.                 # finite number</font>
<font color="red"> 557.                 fracpart = m.group('frac') or ''</font>
<font color="red"> 558.                 exp = int(m.group('exp') or '0')</font>
<font color="red"> 559.                 self._int = str(int(intpart+fracpart))</font>
<font color="red"> 560.                 self._exp = exp - len(fracpart)</font>
<font color="red"> 561.                 self._is_special = False</font>
<font color="black"> 562.             else:</font>
<font color="green"> 563.                 diag = m.group('diag')</font>
<font color="green"> 564.                 if diag is not None:</font>
<font color="black"> 565.                     # NaN</font>
<font color="green"> 566.                     self._int = str(int(diag or '0')).lstrip('0')</font>
<font color="green"> 567.                     if m.group('signal'):</font>
<font color="red"> 568.                         self._exp = 'N'</font>
<font color="black"> 569.                     else:</font>
<font color="green"> 570.                         self._exp = 'n'</font>
<font color="black"> 571.                 else:</font>
<font color="black"> 572.                     # infinity</font>
<font color="green"> 573.                     self._int = '0'</font>
<font color="green"> 574.                     self._exp = 'F'</font>
<font color="green"> 575.                 self._is_special = True</font>
<font color="green"> 576.             return self</font>
<font color="black"> 577. </font>
<font color="black"> 578.         # From an integer</font>
<font color="green"> 579.         if isinstance(value, (int,long)):</font>
<font color="green"> 580.             if value &gt;= 0:</font>
<font color="green"> 581.                 self._sign = 0</font>
<font color="black"> 582.             else:</font>
<font color="green"> 583.                 self._sign = 1</font>
<font color="green"> 584.             self._exp = 0</font>
<font color="green"> 585.             self._int = str(abs(value))</font>
<font color="green"> 586.             self._is_special = False</font>
<font color="green"> 587.             return self</font>
<font color="black"> 588. </font>
<font color="black"> 589.         # From another decimal</font>
<font color="red"> 590.         if isinstance(value, Decimal):</font>
<font color="red"> 591.             self._exp  = value._exp</font>
<font color="red"> 592.             self._sign = value._sign</font>
<font color="red"> 593.             self._int  = value._int</font>
<font color="red"> 594.             self._is_special  = value._is_special</font>
<font color="red"> 595.             return self</font>
<font color="black"> 596. </font>
<font color="black"> 597.         # From an internal working value</font>
<font color="red"> 598.         if isinstance(value, _WorkRep):</font>
<font color="red"> 599.             self._sign = value.sign</font>
<font color="red"> 600.             self._int = str(value.int)</font>
<font color="red"> 601.             self._exp = int(value.exp)</font>
<font color="red"> 602.             self._is_special = False</font>
<font color="red"> 603.             return self</font>
<font color="black"> 604. </font>
<font color="black"> 605.         # tuple/list conversion (possibly from as_tuple())</font>
<font color="red"> 606.         if isinstance(value, (list,tuple)):</font>
<font color="red"> 607.             if len(value) != 3:</font>
<font color="red"> 608.                 raise ValueError('Invalid tuple size in creation of Decimal '</font>
<font color="black"> 609.                                  'from list or tuple.  The list or tuple '</font>
<font color="black"> 610.                                  'should have exactly three elements.')</font>
<font color="black"> 611.             # process sign.  The isinstance test rejects floats</font>
<font color="red"> 612.             if not (isinstance(value[0], (int, long)) and value[0] in (0,1)):</font>
<font color="red"> 613.                 raise ValueError(&quot;Invalid sign.  The first value in the tuple &quot;</font>
<font color="black"> 614.                                  &quot;should be an integer; either 0 for a &quot;</font>
<font color="black"> 615.                                  &quot;positive number or 1 for a negative number.&quot;)</font>
<font color="red"> 616.             self._sign = value[0]</font>
<font color="red"> 617.             if value[2] == 'F':</font>
<font color="black"> 618.                 # infinity: value[1] is ignored</font>
<font color="red"> 619.                 self._int = '0'</font>
<font color="red"> 620.                 self._exp = value[2]</font>
<font color="red"> 621.                 self._is_special = True</font>
<font color="black"> 622.             else:</font>
<font color="black"> 623.                 # process and validate the digits in value[1]</font>
<font color="red"> 624.                 digits = []</font>
<font color="red"> 625.                 for digit in value[1]:</font>
<font color="red"> 626.                     if isinstance(digit, (int, long)) and 0 &lt;= digit &lt;= 9:</font>
<font color="black"> 627.                         # skip leading zeros</font>
<font color="red"> 628.                         if digits or digit != 0:</font>
<font color="red"> 629.                             digits.append(digit)</font>
<font color="black"> 630.                     else:</font>
<font color="red"> 631.                         raise ValueError(&quot;The second value in the tuple must &quot;</font>
<font color="black"> 632.                                          &quot;be composed of integers in the range &quot;</font>
<font color="black"> 633.                                          &quot;0 through 9.&quot;)</font>
<font color="red"> 634.                 if value[2] in ('n', 'N'):</font>
<font color="black"> 635.                     # NaN: digits form the diagnostic</font>
<font color="red"> 636.                     self._int = ''.join(map(str, digits))</font>
<font color="red"> 637.                     self._exp = value[2]</font>
<font color="red"> 638.                     self._is_special = True</font>
<font color="red"> 639.                 elif isinstance(value[2], (int, long)):</font>
<font color="black"> 640.                     # finite number: digits give the coefficient</font>
<font color="red"> 641.                     self._int = ''.join(map(str, digits or [0]))</font>
<font color="red"> 642.                     self._exp = value[2]</font>
<font color="red"> 643.                     self._is_special = False</font>
<font color="black"> 644.                 else:</font>
<font color="red"> 645.                     raise ValueError(&quot;The third value in the tuple must &quot;</font>
<font color="black"> 646.                                      &quot;be an integer, or one of the &quot;</font>
<font color="black"> 647.                                      &quot;strings 'F', 'n', 'N'.&quot;)</font>
<font color="red"> 648.             return self</font>
<font color="black"> 649. </font>
<font color="red"> 650.         if isinstance(value, float):</font>
<font color="red"> 651.             value = Decimal.from_float(value)</font>
<font color="red"> 652.             self._exp  = value._exp</font>
<font color="red"> 653.             self._sign = value._sign</font>
<font color="red"> 654.             self._int  = value._int</font>
<font color="red"> 655.             self._is_special  = value._is_special</font>
<font color="red"> 656.             return self</font>
<font color="black"> 657. </font>
<font color="red"> 658.         raise TypeError(&quot;Cannot convert %r to Decimal&quot; % value)</font>
<font color="black"> 659. </font>
<font color="black"> 660.     # @classmethod, but @decorator is not valid Python 2.3 syntax, so</font>
<font color="black"> 661.     # don't use it (see notes on Py2.3 compatibility at top of file)</font>
<font color="green"> 662.     def from_float(cls, f):</font>
<font color="black"> 663.         &quot;&quot;&quot;Converts a float to a decimal number, exactly.</font>
<font color="black"> 664. </font>
<font color="black"> 665.         Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').</font>
<font color="black"> 666.         Since 0.1 is not exactly representable in binary floating point, the</font>
<font color="black"> 667.         value is stored as the nearest representable value which is</font>
<font color="black"> 668.         0x1.999999999999ap-4.  The exact equivalent of the value in decimal</font>
<font color="black"> 669.         is 0.1000000000000000055511151231257827021181583404541015625.</font>
<font color="black"> 670. </font>
<font color="black"> 671.         &gt;&gt;&gt; Decimal.from_float(0.1)</font>
<font color="black"> 672.         Decimal('0.1000000000000000055511151231257827021181583404541015625')</font>
<font color="black"> 673.         &gt;&gt;&gt; Decimal.from_float(float('nan'))</font>
<font color="black"> 674.         Decimal('NaN')</font>
<font color="black"> 675.         &gt;&gt;&gt; Decimal.from_float(float('inf'))</font>
<font color="black"> 676.         Decimal('Infinity')</font>
<font color="black"> 677.         &gt;&gt;&gt; Decimal.from_float(-float('inf'))</font>
<font color="black"> 678.         Decimal('-Infinity')</font>
<font color="black"> 679.         &gt;&gt;&gt; Decimal.from_float(-0.0)</font>
<font color="black"> 680.         Decimal('-0')</font>
<font color="black"> 681. </font>
<font color="black"> 682.         &quot;&quot;&quot;</font>
<font color="red"> 683.         if isinstance(f, (int, long)):        # handle integer inputs</font>
<font color="red"> 684.             return cls(f)</font>
<font color="red"> 685.         if _math.isinf(f) or _math.isnan(f):  # raises TypeError if not a float</font>
<font color="red"> 686.             return cls(repr(f))</font>
<font color="red"> 687.         if _math.copysign(1.0, f) == 1.0:</font>
<font color="red"> 688.             sign = 0</font>
<font color="black"> 689.         else:</font>
<font color="red"> 690.             sign = 1</font>
<font color="red"> 691.         n, d = abs(f).as_integer_ratio()</font>
<font color="red"> 692.         k = d.bit_length() - 1</font>
<font color="red"> 693.         result = _dec_from_triple(sign, str(n*5**k), -k)</font>
<font color="red"> 694.         if cls is Decimal:</font>
<font color="red"> 695.             return result</font>
<font color="black"> 696.         else:</font>
<font color="red"> 697.             return cls(result)</font>
<font color="green"> 698.     from_float = classmethod(from_float)</font>
<font color="black"> 699. </font>
<font color="green"> 700.     def _isnan(self):</font>
<font color="black"> 701.         &quot;&quot;&quot;Returns whether the number is not actually one.</font>
<font color="black"> 702. </font>
<font color="black"> 703.         0 if a number</font>
<font color="black"> 704.         1 if NaN</font>
<font color="black"> 705.         2 if sNaN</font>
<font color="black"> 706.         &quot;&quot;&quot;</font>
<font color="red"> 707.         if self._is_special:</font>
<font color="red"> 708.             exp = self._exp</font>
<font color="red"> 709.             if exp == 'n':</font>
<font color="red"> 710.                 return 1</font>
<font color="red"> 711.             elif exp == 'N':</font>
<font color="red"> 712.                 return 2</font>
<font color="red"> 713.         return 0</font>
<font color="black"> 714. </font>
<font color="green"> 715.     def _isinfinity(self):</font>
<font color="black"> 716.         &quot;&quot;&quot;Returns whether the number is infinite</font>
<font color="black"> 717. </font>
<font color="black"> 718.         0 if finite or not a number</font>
<font color="black"> 719.         1 if +INF</font>
<font color="black"> 720.         -1 if -INF</font>
<font color="black"> 721.         &quot;&quot;&quot;</font>
<font color="red"> 722.         if self._exp == 'F':</font>
<font color="red"> 723.             if self._sign:</font>
<font color="red"> 724.                 return -1</font>
<font color="red"> 725.             return 1</font>
<font color="red"> 726.         return 0</font>
<font color="black"> 727. </font>
<font color="green"> 728.     def _check_nans(self, other=None, context=None):</font>
<font color="black"> 729.         &quot;&quot;&quot;Returns whether the number is not actually one.</font>
<font color="black"> 730. </font>
<font color="black"> 731.         if self, other are sNaN, signal</font>
<font color="black"> 732.         if self, other are NaN return nan</font>
<font color="black"> 733.         return 0</font>
<font color="black"> 734. </font>
<font color="black"> 735.         Done before operations.</font>
<font color="black"> 736.         &quot;&quot;&quot;</font>
<font color="black"> 737. </font>
<font color="red"> 738.         self_is_nan = self._isnan()</font>
<font color="red"> 739.         if other is None:</font>
<font color="red"> 740.             other_is_nan = False</font>
<font color="black"> 741.         else:</font>
<font color="red"> 742.             other_is_nan = other._isnan()</font>
<font color="black"> 743. </font>
<font color="red"> 744.         if self_is_nan or other_is_nan:</font>
<font color="red"> 745.             if context is None:</font>
<font color="red"> 746.                 context = getcontext()</font>
<font color="black"> 747. </font>
<font color="red"> 748.             if self_is_nan == 2:</font>
<font color="red"> 749.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red"> 750.                                         self)</font>
<font color="red"> 751.             if other_is_nan == 2:</font>
<font color="red"> 752.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red"> 753.                                         other)</font>
<font color="red"> 754.             if self_is_nan:</font>
<font color="red"> 755.                 return self._fix_nan(context)</font>
<font color="black"> 756. </font>
<font color="red"> 757.             return other._fix_nan(context)</font>
<font color="red"> 758.         return 0</font>
<font color="black"> 759. </font>
<font color="green"> 760.     def _compare_check_nans(self, other, context):</font>
<font color="black"> 761.         &quot;&quot;&quot;Version of _check_nans used for the signaling comparisons</font>
<font color="black"> 762.         compare_signal, __le__, __lt__, __ge__, __gt__.</font>
<font color="black"> 763. </font>
<font color="black"> 764.         Signal InvalidOperation if either self or other is a (quiet</font>
<font color="black"> 765.         or signaling) NaN.  Signaling NaNs take precedence over quiet</font>
<font color="black"> 766.         NaNs.</font>
<font color="black"> 767. </font>
<font color="black"> 768.         Return 0 if neither operand is a NaN.</font>
<font color="black"> 769. </font>
<font color="black"> 770.         &quot;&quot;&quot;</font>
<font color="red"> 771.         if context is None:</font>
<font color="red"> 772.             context = getcontext()</font>
<font color="black"> 773. </font>
<font color="red"> 774.         if self._is_special or other._is_special:</font>
<font color="red"> 775.             if self.is_snan():</font>
<font color="red"> 776.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 777.                                             'comparison involving sNaN',</font>
<font color="red"> 778.                                             self)</font>
<font color="red"> 779.             elif other.is_snan():</font>
<font color="red"> 780.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 781.                                             'comparison involving sNaN',</font>
<font color="red"> 782.                                             other)</font>
<font color="red"> 783.             elif self.is_qnan():</font>
<font color="red"> 784.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 785.                                             'comparison involving NaN',</font>
<font color="red"> 786.                                             self)</font>
<font color="red"> 787.             elif other.is_qnan():</font>
<font color="red"> 788.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 789.                                             'comparison involving NaN',</font>
<font color="red"> 790.                                             other)</font>
<font color="red"> 791.         return 0</font>
<font color="black"> 792. </font>
<font color="green"> 793.     def __nonzero__(self):</font>
<font color="black"> 794.         &quot;&quot;&quot;Return True if self is nonzero; otherwise return False.</font>
<font color="black"> 795. </font>
<font color="black"> 796.         NaNs and infinities are considered nonzero.</font>
<font color="black"> 797.         &quot;&quot;&quot;</font>
<font color="red"> 798.         return self._is_special or self._int != '0'</font>
<font color="black"> 799. </font>
<font color="green"> 800.     def _cmp(self, other):</font>
<font color="black"> 801.         &quot;&quot;&quot;Compare the two non-NaN decimal instances self and other.</font>
<font color="black"> 802. </font>
<font color="black"> 803.         Returns -1 if self &lt; other, 0 if self == other and 1</font>
<font color="black"> 804.         if self &gt; other.  This routine is for internal use only.&quot;&quot;&quot;</font>
<font color="black"> 805. </font>
<font color="red"> 806.         if self._is_special or other._is_special:</font>
<font color="red"> 807.             self_inf = self._isinfinity()</font>
<font color="red"> 808.             other_inf = other._isinfinity()</font>
<font color="red"> 809.             if self_inf == other_inf:</font>
<font color="red"> 810.                 return 0</font>
<font color="red"> 811.             elif self_inf &lt; other_inf:</font>
<font color="red"> 812.                 return -1</font>
<font color="black"> 813.             else:</font>
<font color="red"> 814.                 return 1</font>
<font color="black"> 815. </font>
<font color="black"> 816.         # check for zeros;  Decimal('0') == Decimal('-0')</font>
<font color="red"> 817.         if not self:</font>
<font color="red"> 818.             if not other:</font>
<font color="red"> 819.                 return 0</font>
<font color="black"> 820.             else:</font>
<font color="red"> 821.                 return -((-1)**other._sign)</font>
<font color="red"> 822.         if not other:</font>
<font color="red"> 823.             return (-1)**self._sign</font>
<font color="black"> 824. </font>
<font color="black"> 825.         # If different signs, neg one is less</font>
<font color="red"> 826.         if other._sign &lt; self._sign:</font>
<font color="red"> 827.             return -1</font>
<font color="red"> 828.         if self._sign &lt; other._sign:</font>
<font color="red"> 829.             return 1</font>
<font color="black"> 830. </font>
<font color="red"> 831.         self_adjusted = self.adjusted()</font>
<font color="red"> 832.         other_adjusted = other.adjusted()</font>
<font color="red"> 833.         if self_adjusted == other_adjusted:</font>
<font color="red"> 834.             self_padded = self._int + '0'*(self._exp - other._exp)</font>
<font color="red"> 835.             other_padded = other._int + '0'*(other._exp - self._exp)</font>
<font color="red"> 836.             if self_padded == other_padded:</font>
<font color="red"> 837.                 return 0</font>
<font color="red"> 838.             elif self_padded &lt; other_padded:</font>
<font color="red"> 839.                 return -(-1)**self._sign</font>
<font color="black"> 840.             else:</font>
<font color="red"> 841.                 return (-1)**self._sign</font>
<font color="red"> 842.         elif self_adjusted &gt; other_adjusted:</font>
<font color="red"> 843.             return (-1)**self._sign</font>
<font color="black"> 844.         else: # self_adjusted &lt; other_adjusted</font>
<font color="red"> 845.             return -((-1)**self._sign)</font>
<font color="black"> 846. </font>
<font color="black"> 847.     # Note: The Decimal standard doesn't cover rich comparisons for</font>
<font color="black"> 848.     # Decimals.  In particular, the specification is silent on the</font>
<font color="black"> 849.     # subject of what should happen for a comparison involving a NaN.</font>
<font color="black"> 850.     # We take the following approach:</font>
<font color="black"> 851.     #</font>
<font color="black"> 852.     #   == comparisons involving a quiet NaN always return False</font>
<font color="black"> 853.     #   != comparisons involving a quiet NaN always return True</font>
<font color="black"> 854.     #   == or != comparisons involving a signaling NaN signal</font>
<font color="black"> 855.     #      InvalidOperation, and return False or True as above if the</font>
<font color="black"> 856.     #      InvalidOperation is not trapped.</font>
<font color="black"> 857.     #   &lt;, &gt;, &lt;= and &gt;= comparisons involving a (quiet or signaling)</font>
<font color="black"> 858.     #      NaN signal InvalidOperation, and return False if the</font>
<font color="black"> 859.     #      InvalidOperation is not trapped.</font>
<font color="black"> 860.     #</font>
<font color="black"> 861.     # This behavior is designed to conform as closely as possible to</font>
<font color="black"> 862.     # that specified by IEEE 754.</font>
<font color="black"> 863. </font>
<font color="green"> 864.     def __eq__(self, other, context=None):</font>
<font color="red"> 865.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 866.         if other is NotImplemented:</font>
<font color="red"> 867.             return other</font>
<font color="red"> 868.         if self._check_nans(other, context):</font>
<font color="red"> 869.             return False</font>
<font color="red"> 870.         return self._cmp(other) == 0</font>
<font color="black"> 871. </font>
<font color="green"> 872.     def __ne__(self, other, context=None):</font>
<font color="red"> 873.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 874.         if other is NotImplemented:</font>
<font color="red"> 875.             return other</font>
<font color="red"> 876.         if self._check_nans(other, context):</font>
<font color="red"> 877.             return True</font>
<font color="red"> 878.         return self._cmp(other) != 0</font>
<font color="black"> 879. </font>
<font color="green"> 880.     def __lt__(self, other, context=None):</font>
<font color="red"> 881.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 882.         if other is NotImplemented:</font>
<font color="red"> 883.             return other</font>
<font color="red"> 884.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 885.         if ans:</font>
<font color="red"> 886.             return False</font>
<font color="red"> 887.         return self._cmp(other) &lt; 0</font>
<font color="black"> 888. </font>
<font color="green"> 889.     def __le__(self, other, context=None):</font>
<font color="red"> 890.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 891.         if other is NotImplemented:</font>
<font color="red"> 892.             return other</font>
<font color="red"> 893.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 894.         if ans:</font>
<font color="red"> 895.             return False</font>
<font color="red"> 896.         return self._cmp(other) &lt;= 0</font>
<font color="black"> 897. </font>
<font color="green"> 898.     def __gt__(self, other, context=None):</font>
<font color="red"> 899.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 900.         if other is NotImplemented:</font>
<font color="red"> 901.             return other</font>
<font color="red"> 902.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 903.         if ans:</font>
<font color="red"> 904.             return False</font>
<font color="red"> 905.         return self._cmp(other) &gt; 0</font>
<font color="black"> 906. </font>
<font color="green"> 907.     def __ge__(self, other, context=None):</font>
<font color="red"> 908.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 909.         if other is NotImplemented:</font>
<font color="red"> 910.             return other</font>
<font color="red"> 911.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 912.         if ans:</font>
<font color="red"> 913.             return False</font>
<font color="red"> 914.         return self._cmp(other) &gt;= 0</font>
<font color="black"> 915. </font>
<font color="green"> 916.     def compare(self, other, context=None):</font>
<font color="black"> 917.         &quot;&quot;&quot;Compares one to another.</font>
<font color="black"> 918. </font>
<font color="black"> 919.         -1 =&gt; a &lt; b</font>
<font color="black"> 920.         0  =&gt; a = b</font>
<font color="black"> 921.         1  =&gt; a &gt; b</font>
<font color="black"> 922.         NaN =&gt; one is NaN</font>
<font color="black"> 923.         Like __cmp__, but returns Decimal instances.</font>
<font color="black"> 924.         &quot;&quot;&quot;</font>
<font color="red"> 925.         other = _convert_other(other, raiseit=True)</font>
<font color="black"> 926. </font>
<font color="black"> 927.         # Compare(NaN, NaN) = NaN</font>
<font color="red"> 928.         if (self._is_special or other and other._is_special):</font>
<font color="red"> 929.             ans = self._check_nans(other, context)</font>
<font color="red"> 930.             if ans:</font>
<font color="red"> 931.                 return ans</font>
<font color="black"> 932. </font>
<font color="red"> 933.         return Decimal(self._cmp(other))</font>
<font color="black"> 934. </font>
<font color="green"> 935.     def __hash__(self):</font>
<font color="black"> 936.         &quot;&quot;&quot;x.__hash__() &lt;==&gt; hash(x)&quot;&quot;&quot;</font>
<font color="black"> 937.         # Decimal integers must hash the same as the ints</font>
<font color="black"> 938.         #</font>
<font color="black"> 939.         # The hash of a nonspecial noninteger Decimal must depend only</font>
<font color="black"> 940.         # on the value of that Decimal, and not on its representation.</font>
<font color="black"> 941.         # For example: hash(Decimal('100E-1')) == hash(Decimal('10')).</font>
<font color="black"> 942. </font>
<font color="black"> 943.         # Equality comparisons involving signaling nans can raise an</font>
<font color="black"> 944.         # exception; since equality checks are implicitly and</font>
<font color="black"> 945.         # unpredictably used when checking set and dict membership, we</font>
<font color="black"> 946.         # prevent signaling nans from being used as set elements or</font>
<font color="black"> 947.         # dict keys by making __hash__ raise an exception.</font>
<font color="red"> 948.         if self._is_special:</font>
<font color="red"> 949.             if self.is_snan():</font>
<font color="red"> 950.                 raise TypeError('Cannot hash a signaling NaN value.')</font>
<font color="red"> 951.             elif self.is_nan():</font>
<font color="black"> 952.                 # 0 to match hash(float('nan'))</font>
<font color="red"> 953.                 return 0</font>
<font color="black"> 954.             else:</font>
<font color="black"> 955.                 # values chosen to match hash(float('inf')) and</font>
<font color="black"> 956.                 # hash(float('-inf')).</font>
<font color="red"> 957.                 if self._sign:</font>
<font color="red"> 958.                     return -271828</font>
<font color="black"> 959.                 else:</font>
<font color="red"> 960.                     return 314159</font>
<font color="black"> 961. </font>
<font color="black"> 962.         # In Python 2.7, we're allowing comparisons (but not</font>
<font color="black"> 963.         # arithmetic operations) between floats and Decimals;  so if</font>
<font color="black"> 964.         # a Decimal instance is exactly representable as a float then</font>
<font color="black"> 965.         # its hash should match that of the float.</font>
<font color="red"> 966.         self_as_float = float(self)</font>
<font color="red"> 967.         if Decimal.from_float(self_as_float) == self:</font>
<font color="red"> 968.             return hash(self_as_float)</font>
<font color="black"> 969. </font>
<font color="red"> 970.         if self._isinteger():</font>
<font color="red"> 971.             op = _WorkRep(self.to_integral_value())</font>
<font color="black"> 972.             # to make computation feasible for Decimals with large</font>
<font color="black"> 973.             # exponent, we use the fact that hash(n) == hash(m) for</font>
<font color="black"> 974.             # any two nonzero integers n and m such that (i) n and m</font>
<font color="black"> 975.             # have the same sign, and (ii) n is congruent to m modulo</font>
<font color="black"> 976.             # 2**64-1.  So we can replace hash((-1)**s*c*10**e) with</font>
<font color="black"> 977.             # hash((-1)**s*c*pow(10, e, 2**64-1).</font>
<font color="red"> 978.             return hash((-1)**op.sign*op.int*pow(10, op.exp, 2**64-1))</font>
<font color="black"> 979.         # The value of a nonzero nonspecial Decimal instance is</font>
<font color="black"> 980.         # faithfully represented by the triple consisting of its sign,</font>
<font color="black"> 981.         # its adjusted exponent, and its coefficient with trailing</font>
<font color="black"> 982.         # zeros removed.</font>
<font color="red"> 983.         return hash((self._sign,</font>
<font color="red"> 984.                      self._exp+len(self._int),</font>
<font color="red"> 985.                      self._int.rstrip('0')))</font>
<font color="black"> 986. </font>
<font color="green"> 987.     def as_tuple(self):</font>
<font color="black"> 988.         &quot;&quot;&quot;Represents the number as a triple tuple.</font>
<font color="black"> 989. </font>
<font color="black"> 990.         To show the internals exactly as they are.</font>
<font color="black"> 991.         &quot;&quot;&quot;</font>
<font color="red"> 992.         return DecimalTuple(self._sign, tuple(map(int, self._int)), self._exp)</font>
<font color="black"> 993. </font>
<font color="green"> 994.     def __repr__(self):</font>
<font color="black"> 995.         &quot;&quot;&quot;Represents the number as an instance of Decimal.&quot;&quot;&quot;</font>
<font color="black"> 996.         # Invariant:  eval(repr(d)) == d</font>
<font color="red"> 997.         return &quot;Decimal('%s')&quot; % str(self)</font>
<font color="black"> 998. </font>
<font color="green"> 999.     def __str__(self, eng=False, context=None):</font>
<font color="black">1000.         &quot;&quot;&quot;Return string representation of the number in scientific notation.</font>
<font color="black">1001. </font>
<font color="black">1002.         Captures all of the information in the underlying representation.</font>
<font color="black">1003.         &quot;&quot;&quot;</font>
<font color="black">1004. </font>
<font color="red">1005.         sign = ['', '-'][self._sign]</font>
<font color="red">1006.         if self._is_special:</font>
<font color="red">1007.             if self._exp == 'F':</font>
<font color="red">1008.                 return sign + 'Infinity'</font>
<font color="red">1009.             elif self._exp == 'n':</font>
<font color="red">1010.                 return sign + 'NaN' + self._int</font>
<font color="black">1011.             else: # self._exp == 'N'</font>
<font color="red">1012.                 return sign + 'sNaN' + self._int</font>
<font color="black">1013. </font>
<font color="black">1014.         # number of digits of self._int to left of decimal point</font>
<font color="red">1015.         leftdigits = self._exp + len(self._int)</font>
<font color="black">1016. </font>
<font color="black">1017.         # dotplace is number of digits of self._int to the left of the</font>
<font color="black">1018.         # decimal point in the mantissa of the output string (that is,</font>
<font color="black">1019.         # after adjusting the exponent)</font>
<font color="red">1020.         if self._exp &lt;= 0 and leftdigits &gt; -6:</font>
<font color="black">1021.             # no exponent required</font>
<font color="red">1022.             dotplace = leftdigits</font>
<font color="red">1023.         elif not eng:</font>
<font color="black">1024.             # usual scientific notation: 1 digit on left of the point</font>
<font color="red">1025.             dotplace = 1</font>
<font color="red">1026.         elif self._int == '0':</font>
<font color="black">1027.             # engineering notation, zero</font>
<font color="red">1028.             dotplace = (leftdigits + 1) % 3 - 1</font>
<font color="black">1029.         else:</font>
<font color="black">1030.             # engineering notation, nonzero</font>
<font color="red">1031.             dotplace = (leftdigits - 1) % 3 + 1</font>
<font color="black">1032. </font>
<font color="red">1033.         if dotplace &lt;= 0:</font>
<font color="red">1034.             intpart = '0'</font>
<font color="red">1035.             fracpart = '.' + '0'*(-dotplace) + self._int</font>
<font color="red">1036.         elif dotplace &gt;= len(self._int):</font>
<font color="red">1037.             intpart = self._int+'0'*(dotplace-len(self._int))</font>
<font color="red">1038.             fracpart = ''</font>
<font color="black">1039.         else:</font>
<font color="red">1040.             intpart = self._int[:dotplace]</font>
<font color="red">1041.             fracpart = '.' + self._int[dotplace:]</font>
<font color="red">1042.         if leftdigits == dotplace:</font>
<font color="red">1043.             exp = ''</font>
<font color="black">1044.         else:</font>
<font color="red">1045.             if context is None:</font>
<font color="red">1046.                 context = getcontext()</font>
<font color="red">1047.             exp = ['e', 'E'][context.capitals] + &quot;%+d&quot; % (leftdigits-dotplace)</font>
<font color="black">1048. </font>
<font color="red">1049.         return sign + intpart + fracpart + exp</font>
<font color="black">1050. </font>
<font color="green">1051.     def to_eng_string(self, context=None):</font>
<font color="black">1052.         &quot;&quot;&quot;Convert to engineering-type string.</font>
<font color="black">1053. </font>
<font color="black">1054.         Engineering notation has an exponent which is a multiple of 3, so there</font>
<font color="black">1055.         are up to 3 digits left of the decimal place.</font>
<font color="black">1056. </font>
<font color="black">1057.         Same rules for when in exponential and when as a value as in __str__.</font>
<font color="black">1058.         &quot;&quot;&quot;</font>
<font color="red">1059.         return self.__str__(eng=True, context=context)</font>
<font color="black">1060. </font>
<font color="green">1061.     def __neg__(self, context=None):</font>
<font color="black">1062.         &quot;&quot;&quot;Returns a copy with the sign switched.</font>
<font color="black">1063. </font>
<font color="black">1064.         Rounds, if it has reason.</font>
<font color="black">1065.         &quot;&quot;&quot;</font>
<font color="red">1066.         if self._is_special:</font>
<font color="red">1067.             ans = self._check_nans(context=context)</font>
<font color="red">1068.             if ans:</font>
<font color="red">1069.                 return ans</font>
<font color="black">1070. </font>
<font color="red">1071.         if context is None:</font>
<font color="red">1072.             context = getcontext()</font>
<font color="black">1073. </font>
<font color="red">1074.         if not self and context.rounding != ROUND_FLOOR:</font>
<font color="black">1075.             # -Decimal('0') is Decimal('0'), not Decimal('-0'), except</font>
<font color="black">1076.             # in ROUND_FLOOR rounding mode.</font>
<font color="red">1077.             ans = self.copy_abs()</font>
<font color="black">1078.         else:</font>
<font color="red">1079.             ans = self.copy_negate()</font>
<font color="black">1080. </font>
<font color="red">1081.         return ans._fix(context)</font>
<font color="black">1082. </font>
<font color="green">1083.     def __pos__(self, context=None):</font>
<font color="black">1084.         &quot;&quot;&quot;Returns a copy, unless it is a sNaN.</font>
<font color="black">1085. </font>
<font color="black">1086.         Rounds the number (if more then precision digits)</font>
<font color="black">1087.         &quot;&quot;&quot;</font>
<font color="red">1088.         if self._is_special:</font>
<font color="red">1089.             ans = self._check_nans(context=context)</font>
<font color="red">1090.             if ans:</font>
<font color="red">1091.                 return ans</font>
<font color="black">1092. </font>
<font color="red">1093.         if context is None:</font>
<font color="red">1094.             context = getcontext()</font>
<font color="black">1095. </font>
<font color="red">1096.         if not self and context.rounding != ROUND_FLOOR:</font>
<font color="black">1097.             # + (-0) = 0, except in ROUND_FLOOR rounding mode.</font>
<font color="red">1098.             ans = self.copy_abs()</font>
<font color="black">1099.         else:</font>
<font color="red">1100.             ans = Decimal(self)</font>
<font color="black">1101. </font>
<font color="red">1102.         return ans._fix(context)</font>
<font color="black">1103. </font>
<font color="green">1104.     def __abs__(self, round=True, context=None):</font>
<font color="black">1105.         &quot;&quot;&quot;Returns the absolute value of self.</font>
<font color="black">1106. </font>
<font color="black">1107.         If the keyword argument 'round' is false, do not round.  The</font>
<font color="black">1108.         expression self.__abs__(round=False) is equivalent to</font>
<font color="black">1109.         self.copy_abs().</font>
<font color="black">1110.         &quot;&quot;&quot;</font>
<font color="red">1111.         if not round:</font>
<font color="red">1112.             return self.copy_abs()</font>
<font color="black">1113. </font>
<font color="red">1114.         if self._is_special:</font>
<font color="red">1115.             ans = self._check_nans(context=context)</font>
<font color="red">1116.             if ans:</font>
<font color="red">1117.                 return ans</font>
<font color="black">1118. </font>
<font color="red">1119.         if self._sign:</font>
<font color="red">1120.             ans = self.__neg__(context=context)</font>
<font color="black">1121.         else:</font>
<font color="red">1122.             ans = self.__pos__(context=context)</font>
<font color="black">1123. </font>
<font color="red">1124.         return ans</font>
<font color="black">1125. </font>
<font color="green">1126.     def __add__(self, other, context=None):</font>
<font color="black">1127.         &quot;&quot;&quot;Returns self + other.</font>
<font color="black">1128. </font>
<font color="black">1129.         -INF + INF (or the reverse) cause InvalidOperation errors.</font>
<font color="black">1130.         &quot;&quot;&quot;</font>
<font color="red">1131.         other = _convert_other(other)</font>
<font color="red">1132.         if other is NotImplemented:</font>
<font color="red">1133.             return other</font>
<font color="black">1134. </font>
<font color="red">1135.         if context is None:</font>
<font color="red">1136.             context = getcontext()</font>
<font color="black">1137. </font>
<font color="red">1138.         if self._is_special or other._is_special:</font>
<font color="red">1139.             ans = self._check_nans(other, context)</font>
<font color="red">1140.             if ans:</font>
<font color="red">1141.                 return ans</font>
<font color="black">1142. </font>
<font color="red">1143.             if self._isinfinity():</font>
<font color="black">1144.                 # If both INF, same sign =&gt; same as both, opposite =&gt; error.</font>
<font color="red">1145.                 if self._sign != other._sign and other._isinfinity():</font>
<font color="red">1146.                     return context._raise_error(InvalidOperation, '-INF + INF')</font>
<font color="red">1147.                 return Decimal(self)</font>
<font color="red">1148.             if other._isinfinity():</font>
<font color="red">1149.                 return Decimal(other)  # Can't both be infinity here</font>
<font color="black">1150. </font>
<font color="red">1151.         exp = min(self._exp, other._exp)</font>
<font color="red">1152.         negativezero = 0</font>
<font color="red">1153.         if context.rounding == ROUND_FLOOR and self._sign != other._sign:</font>
<font color="black">1154.             # If the answer is 0, the sign should be negative, in this case.</font>
<font color="red">1155.             negativezero = 1</font>
<font color="black">1156. </font>
<font color="red">1157.         if not self and not other:</font>
<font color="red">1158.             sign = min(self._sign, other._sign)</font>
<font color="red">1159.             if negativezero:</font>
<font color="red">1160.                 sign = 1</font>
<font color="red">1161.             ans = _dec_from_triple(sign, '0', exp)</font>
<font color="red">1162.             ans = ans._fix(context)</font>
<font color="red">1163.             return ans</font>
<font color="red">1164.         if not self:</font>
<font color="red">1165.             exp = max(exp, other._exp - context.prec-1)</font>
<font color="red">1166.             ans = other._rescale(exp, context.rounding)</font>
<font color="red">1167.             ans = ans._fix(context)</font>
<font color="red">1168.             return ans</font>
<font color="red">1169.         if not other:</font>
<font color="red">1170.             exp = max(exp, self._exp - context.prec-1)</font>
<font color="red">1171.             ans = self._rescale(exp, context.rounding)</font>
<font color="red">1172.             ans = ans._fix(context)</font>
<font color="red">1173.             return ans</font>
<font color="black">1174. </font>
<font color="red">1175.         op1 = _WorkRep(self)</font>
<font color="red">1176.         op2 = _WorkRep(other)</font>
<font color="red">1177.         op1, op2 = _normalize(op1, op2, context.prec)</font>
<font color="black">1178. </font>
<font color="red">1179.         result = _WorkRep()</font>
<font color="red">1180.         if op1.sign != op2.sign:</font>
<font color="black">1181.             # Equal and opposite</font>
<font color="red">1182.             if op1.int == op2.int:</font>
<font color="red">1183.                 ans = _dec_from_triple(negativezero, '0', exp)</font>
<font color="red">1184.                 ans = ans._fix(context)</font>
<font color="red">1185.                 return ans</font>
<font color="red">1186.             if op1.int &lt; op2.int:</font>
<font color="red">1187.                 op1, op2 = op2, op1</font>
<font color="black">1188.                 # OK, now abs(op1) &gt; abs(op2)</font>
<font color="red">1189.             if op1.sign == 1:</font>
<font color="red">1190.                 result.sign = 1</font>
<font color="red">1191.                 op1.sign, op2.sign = op2.sign, op1.sign</font>
<font color="black">1192.             else:</font>
<font color="red">1193.                 result.sign = 0</font>
<font color="black">1194.                 # So we know the sign, and op1 &gt; 0.</font>
<font color="red">1195.         elif op1.sign == 1:</font>
<font color="red">1196.             result.sign = 1</font>
<font color="red">1197.             op1.sign, op2.sign = (0, 0)</font>
<font color="black">1198.         else:</font>
<font color="red">1199.             result.sign = 0</font>
<font color="black">1200.         # Now, op1 &gt; abs(op2) &gt; 0</font>
<font color="black">1201. </font>
<font color="red">1202.         if op2.sign == 0:</font>
<font color="red">1203.             result.int = op1.int + op2.int</font>
<font color="black">1204.         else:</font>
<font color="red">1205.             result.int = op1.int - op2.int</font>
<font color="black">1206. </font>
<font color="red">1207.         result.exp = op1.exp</font>
<font color="red">1208.         ans = Decimal(result)</font>
<font color="red">1209.         ans = ans._fix(context)</font>
<font color="red">1210.         return ans</font>
<font color="black">1211. </font>
<font color="green">1212.     __radd__ = __add__</font>
<font color="black">1213. </font>
<font color="green">1214.     def __sub__(self, other, context=None):</font>
<font color="black">1215.         &quot;&quot;&quot;Return self - other&quot;&quot;&quot;</font>
<font color="red">1216.         other = _convert_other(other)</font>
<font color="red">1217.         if other is NotImplemented:</font>
<font color="red">1218.             return other</font>
<font color="black">1219. </font>
<font color="red">1220.         if self._is_special or other._is_special:</font>
<font color="red">1221.             ans = self._check_nans(other, context=context)</font>
<font color="red">1222.             if ans:</font>
<font color="red">1223.                 return ans</font>
<font color="black">1224. </font>
<font color="black">1225.         # self - other is computed as self + other.copy_negate()</font>
<font color="red">1226.         return self.__add__(other.copy_negate(), context=context)</font>
<font color="black">1227. </font>
<font color="green">1228.     def __rsub__(self, other, context=None):</font>
<font color="black">1229.         &quot;&quot;&quot;Return other - self&quot;&quot;&quot;</font>
<font color="red">1230.         other = _convert_other(other)</font>
<font color="red">1231.         if other is NotImplemented:</font>
<font color="red">1232.             return other</font>
<font color="black">1233. </font>
<font color="red">1234.         return other.__sub__(self, context=context)</font>
<font color="black">1235. </font>
<font color="green">1236.     def __mul__(self, other, context=None):</font>
<font color="black">1237.         &quot;&quot;&quot;Return self * other.</font>
<font color="black">1238. </font>
<font color="black">1239.         (+-) INF * 0 (or its reverse) raise InvalidOperation.</font>
<font color="black">1240.         &quot;&quot;&quot;</font>
<font color="red">1241.         other = _convert_other(other)</font>
<font color="red">1242.         if other is NotImplemented:</font>
<font color="red">1243.             return other</font>
<font color="black">1244. </font>
<font color="red">1245.         if context is None:</font>
<font color="red">1246.             context = getcontext()</font>
<font color="black">1247. </font>
<font color="red">1248.         resultsign = self._sign ^ other._sign</font>
<font color="black">1249. </font>
<font color="red">1250.         if self._is_special or other._is_special:</font>
<font color="red">1251.             ans = self._check_nans(other, context)</font>
<font color="red">1252.             if ans:</font>
<font color="red">1253.                 return ans</font>
<font color="black">1254. </font>
<font color="red">1255.             if self._isinfinity():</font>
<font color="red">1256.                 if not other:</font>
<font color="red">1257.                     return context._raise_error(InvalidOperation, '(+-)INF * 0')</font>
<font color="red">1258.                 return _SignedInfinity[resultsign]</font>
<font color="black">1259. </font>
<font color="red">1260.             if other._isinfinity():</font>
<font color="red">1261.                 if not self:</font>
<font color="red">1262.                     return context._raise_error(InvalidOperation, '0 * (+-)INF')</font>
<font color="red">1263.                 return _SignedInfinity[resultsign]</font>
<font color="black">1264. </font>
<font color="red">1265.         resultexp = self._exp + other._exp</font>
<font color="black">1266. </font>
<font color="black">1267.         # Special case for multiplying by zero</font>
<font color="red">1268.         if not self or not other:</font>
<font color="red">1269.             ans = _dec_from_triple(resultsign, '0', resultexp)</font>
<font color="black">1270.             # Fixing in case the exponent is out of bounds</font>
<font color="red">1271.             ans = ans._fix(context)</font>
<font color="red">1272.             return ans</font>
<font color="black">1273. </font>
<font color="black">1274.         # Special case for multiplying by power of 10</font>
<font color="red">1275.         if self._int == '1':</font>
<font color="red">1276.             ans = _dec_from_triple(resultsign, other._int, resultexp)</font>
<font color="red">1277.             ans = ans._fix(context)</font>
<font color="red">1278.             return ans</font>
<font color="red">1279.         if other._int == '1':</font>
<font color="red">1280.             ans = _dec_from_triple(resultsign, self._int, resultexp)</font>
<font color="red">1281.             ans = ans._fix(context)</font>
<font color="red">1282.             return ans</font>
<font color="black">1283. </font>
<font color="red">1284.         op1 = _WorkRep(self)</font>
<font color="red">1285.         op2 = _WorkRep(other)</font>
<font color="black">1286. </font>
<font color="red">1287.         ans = _dec_from_triple(resultsign, str(op1.int * op2.int), resultexp)</font>
<font color="red">1288.         ans = ans._fix(context)</font>
<font color="black">1289. </font>
<font color="red">1290.         return ans</font>
<font color="green">1291.     __rmul__ = __mul__</font>
<font color="black">1292. </font>
<font color="green">1293.     def __truediv__(self, other, context=None):</font>
<font color="black">1294.         &quot;&quot;&quot;Return self / other.&quot;&quot;&quot;</font>
<font color="red">1295.         other = _convert_other(other)</font>
<font color="red">1296.         if other is NotImplemented:</font>
<font color="red">1297.             return NotImplemented</font>
<font color="black">1298. </font>
<font color="red">1299.         if context is None:</font>
<font color="red">1300.             context = getcontext()</font>
<font color="black">1301. </font>
<font color="red">1302.         sign = self._sign ^ other._sign</font>
<font color="black">1303. </font>
<font color="red">1304.         if self._is_special or other._is_special:</font>
<font color="red">1305.             ans = self._check_nans(other, context)</font>
<font color="red">1306.             if ans:</font>
<font color="red">1307.                 return ans</font>
<font color="black">1308. </font>
<font color="red">1309.             if self._isinfinity() and other._isinfinity():</font>
<font color="red">1310.                 return context._raise_error(InvalidOperation, '(+-)INF/(+-)INF')</font>
<font color="black">1311. </font>
<font color="red">1312.             if self._isinfinity():</font>
<font color="red">1313.                 return _SignedInfinity[sign]</font>
<font color="black">1314. </font>
<font color="red">1315.             if other._isinfinity():</font>
<font color="red">1316.                 context._raise_error(Clamped, 'Division by infinity')</font>
<font color="red">1317.                 return _dec_from_triple(sign, '0', context.Etiny())</font>
<font color="black">1318. </font>
<font color="black">1319.         # Special cases for zeroes</font>
<font color="red">1320.         if not other:</font>
<font color="red">1321.             if not self:</font>
<font color="red">1322.                 return context._raise_error(DivisionUndefined, '0 / 0')</font>
<font color="red">1323.             return context._raise_error(DivisionByZero, 'x / 0', sign)</font>
<font color="black">1324. </font>
<font color="red">1325.         if not self:</font>
<font color="red">1326.             exp = self._exp - other._exp</font>
<font color="red">1327.             coeff = 0</font>
<font color="black">1328.         else:</font>
<font color="black">1329.             # OK, so neither = 0, INF or NaN</font>
<font color="red">1330.             shift = len(other._int) - len(self._int) + context.prec + 1</font>
<font color="red">1331.             exp = self._exp - other._exp - shift</font>
<font color="red">1332.             op1 = _WorkRep(self)</font>
<font color="red">1333.             op2 = _WorkRep(other)</font>
<font color="red">1334.             if shift &gt;= 0:</font>
<font color="red">1335.                 coeff, remainder = divmod(op1.int * 10**shift, op2.int)</font>
<font color="black">1336.             else:</font>
<font color="red">1337.                 coeff, remainder = divmod(op1.int, op2.int * 10**-shift)</font>
<font color="red">1338.             if remainder:</font>
<font color="black">1339.                 # result is not exact; adjust to ensure correct rounding</font>
<font color="red">1340.                 if coeff % 5 == 0:</font>
<font color="red">1341.                     coeff += 1</font>
<font color="black">1342.             else:</font>
<font color="black">1343.                 # result is exact; get as close to ideal exponent as possible</font>
<font color="red">1344.                 ideal_exp = self._exp - other._exp</font>
<font color="red">1345.                 while exp &lt; ideal_exp and coeff % 10 == 0:</font>
<font color="red">1346.                     coeff //= 10</font>
<font color="red">1347.                     exp += 1</font>
<font color="black">1348. </font>
<font color="red">1349.         ans = _dec_from_triple(sign, str(coeff), exp)</font>
<font color="red">1350.         return ans._fix(context)</font>
<font color="black">1351. </font>
<font color="green">1352.     def _divide(self, other, context):</font>
<font color="black">1353.         &quot;&quot;&quot;Return (self // other, self % other), to context.prec precision.</font>
<font color="black">1354. </font>
<font color="black">1355.         Assumes that neither self nor other is a NaN, that self is not</font>
<font color="black">1356.         infinite and that other is nonzero.</font>
<font color="black">1357.         &quot;&quot;&quot;</font>
<font color="red">1358.         sign = self._sign ^ other._sign</font>
<font color="red">1359.         if other._isinfinity():</font>
<font color="red">1360.             ideal_exp = self._exp</font>
<font color="black">1361.         else:</font>
<font color="red">1362.             ideal_exp = min(self._exp, other._exp)</font>
<font color="black">1363. </font>
<font color="red">1364.         expdiff = self.adjusted() - other.adjusted()</font>
<font color="red">1365.         if not self or other._isinfinity() or expdiff &lt;= -2:</font>
<font color="red">1366.             return (_dec_from_triple(sign, '0', 0),</font>
<font color="red">1367.                     self._rescale(ideal_exp, context.rounding))</font>
<font color="red">1368.         if expdiff &lt;= context.prec:</font>
<font color="red">1369.             op1 = _WorkRep(self)</font>
<font color="red">1370.             op2 = _WorkRep(other)</font>
<font color="red">1371.             if op1.exp &gt;= op2.exp:</font>
<font color="red">1372.                 op1.int *= 10**(op1.exp - op2.exp)</font>
<font color="black">1373.             else:</font>
<font color="red">1374.                 op2.int *= 10**(op2.exp - op1.exp)</font>
<font color="red">1375.             q, r = divmod(op1.int, op2.int)</font>
<font color="red">1376.             if q &lt; 10**context.prec:</font>
<font color="red">1377.                 return (_dec_from_triple(sign, str(q), 0),</font>
<font color="red">1378.                         _dec_from_triple(self._sign, str(r), ideal_exp))</font>
<font color="black">1379. </font>
<font color="black">1380.         # Here the quotient is too large to be representable</font>
<font color="red">1381.         ans = context._raise_error(DivisionImpossible,</font>
<font color="red">1382.                                    'quotient too large in //, % or divmod')</font>
<font color="red">1383.         return ans, ans</font>
<font color="black">1384. </font>
<font color="green">1385.     def __rtruediv__(self, other, context=None):</font>
<font color="black">1386.         &quot;&quot;&quot;Swaps self/other and returns __truediv__.&quot;&quot;&quot;</font>
<font color="red">1387.         other = _convert_other(other)</font>
<font color="red">1388.         if other is NotImplemented:</font>
<font color="red">1389.             return other</font>
<font color="red">1390.         return other.__truediv__(self, context=context)</font>
<font color="black">1391. </font>
<font color="green">1392.     __div__ = __truediv__</font>
<font color="green">1393.     __rdiv__ = __rtruediv__</font>
<font color="black">1394. </font>
<font color="green">1395.     def __divmod__(self, other, context=None):</font>
<font color="black">1396.         &quot;&quot;&quot;</font>
<font color="black">1397.         Return (self // other, self % other)</font>
<font color="black">1398.         &quot;&quot;&quot;</font>
<font color="red">1399.         other = _convert_other(other)</font>
<font color="red">1400.         if other is NotImplemented:</font>
<font color="red">1401.             return other</font>
<font color="black">1402. </font>
<font color="red">1403.         if context is None:</font>
<font color="red">1404.             context = getcontext()</font>
<font color="black">1405. </font>
<font color="red">1406.         ans = self._check_nans(other, context)</font>
<font color="red">1407.         if ans:</font>
<font color="red">1408.             return (ans, ans)</font>
<font color="black">1409. </font>
<font color="red">1410.         sign = self._sign ^ other._sign</font>
<font color="red">1411.         if self._isinfinity():</font>
<font color="red">1412.             if other._isinfinity():</font>
<font color="red">1413.                 ans = context._raise_error(InvalidOperation, 'divmod(INF, INF)')</font>
<font color="red">1414.                 return ans, ans</font>
<font color="black">1415.             else:</font>
<font color="red">1416.                 return (_SignedInfinity[sign],</font>
<font color="red">1417.                         context._raise_error(InvalidOperation, 'INF % x'))</font>
<font color="black">1418. </font>
<font color="red">1419.         if not other:</font>
<font color="red">1420.             if not self:</font>
<font color="red">1421.                 ans = context._raise_error(DivisionUndefined, 'divmod(0, 0)')</font>
<font color="red">1422.                 return ans, ans</font>
<font color="black">1423.             else:</font>
<font color="red">1424.                 return (context._raise_error(DivisionByZero, 'x // 0', sign),</font>
<font color="red">1425.                         context._raise_error(InvalidOperation, 'x % 0'))</font>
<font color="black">1426. </font>
<font color="red">1427.         quotient, remainder = self._divide(other, context)</font>
<font color="red">1428.         remainder = remainder._fix(context)</font>
<font color="red">1429.         return quotient, remainder</font>
<font color="black">1430. </font>
<font color="green">1431.     def __rdivmod__(self, other, context=None):</font>
<font color="black">1432.         &quot;&quot;&quot;Swaps self/other and returns __divmod__.&quot;&quot;&quot;</font>
<font color="red">1433.         other = _convert_other(other)</font>
<font color="red">1434.         if other is NotImplemented:</font>
<font color="red">1435.             return other</font>
<font color="red">1436.         return other.__divmod__(self, context=context)</font>
<font color="black">1437. </font>
<font color="green">1438.     def __mod__(self, other, context=None):</font>
<font color="black">1439.         &quot;&quot;&quot;</font>
<font color="black">1440.         self % other</font>
<font color="black">1441.         &quot;&quot;&quot;</font>
<font color="red">1442.         other = _convert_other(other)</font>
<font color="red">1443.         if other is NotImplemented:</font>
<font color="red">1444.             return other</font>
<font color="black">1445. </font>
<font color="red">1446.         if context is None:</font>
<font color="red">1447.             context = getcontext()</font>
<font color="black">1448. </font>
<font color="red">1449.         ans = self._check_nans(other, context)</font>
<font color="red">1450.         if ans:</font>
<font color="red">1451.             return ans</font>
<font color="black">1452. </font>
<font color="red">1453.         if self._isinfinity():</font>
<font color="red">1454.             return context._raise_error(InvalidOperation, 'INF % x')</font>
<font color="red">1455.         elif not other:</font>
<font color="red">1456.             if self:</font>
<font color="red">1457.                 return context._raise_error(InvalidOperation, 'x % 0')</font>
<font color="black">1458.             else:</font>
<font color="red">1459.                 return context._raise_error(DivisionUndefined, '0 % 0')</font>
<font color="black">1460. </font>
<font color="red">1461.         remainder = self._divide(other, context)[1]</font>
<font color="red">1462.         remainder = remainder._fix(context)</font>
<font color="red">1463.         return remainder</font>
<font color="black">1464. </font>
<font color="green">1465.     def __rmod__(self, other, context=None):</font>
<font color="black">1466.         &quot;&quot;&quot;Swaps self/other and returns __mod__.&quot;&quot;&quot;</font>
<font color="red">1467.         other = _convert_other(other)</font>
<font color="red">1468.         if other is NotImplemented:</font>
<font color="red">1469.             return other</font>
<font color="red">1470.         return other.__mod__(self, context=context)</font>
<font color="black">1471. </font>
<font color="green">1472.     def remainder_near(self, other, context=None):</font>
<font color="black">1473.         &quot;&quot;&quot;</font>
<font color="black">1474.         Remainder nearest to 0-  abs(remainder-near) &lt;= other/2</font>
<font color="black">1475.         &quot;&quot;&quot;</font>
<font color="red">1476.         if context is None:</font>
<font color="red">1477.             context = getcontext()</font>
<font color="black">1478. </font>
<font color="red">1479.         other = _convert_other(other, raiseit=True)</font>
<font color="black">1480. </font>
<font color="red">1481.         ans = self._check_nans(other, context)</font>
<font color="red">1482.         if ans:</font>
<font color="red">1483.             return ans</font>
<font color="black">1484. </font>
<font color="black">1485.         # self == +/-infinity -&gt; InvalidOperation</font>
<font color="red">1486.         if self._isinfinity():</font>
<font color="red">1487.             return context._raise_error(InvalidOperation,</font>
<font color="red">1488.                                         'remainder_near(infinity, x)')</font>
<font color="black">1489. </font>
<font color="black">1490.         # other == 0 -&gt; either InvalidOperation or DivisionUndefined</font>
<font color="red">1491.         if not other:</font>
<font color="red">1492.             if self:</font>
<font color="red">1493.                 return context._raise_error(InvalidOperation,</font>
<font color="red">1494.                                             'remainder_near(x, 0)')</font>
<font color="black">1495.             else:</font>
<font color="red">1496.                 return context._raise_error(DivisionUndefined,</font>
<font color="red">1497.                                             'remainder_near(0, 0)')</font>
<font color="black">1498. </font>
<font color="black">1499.         # other = +/-infinity -&gt; remainder = self</font>
<font color="red">1500.         if other._isinfinity():</font>
<font color="red">1501.             ans = Decimal(self)</font>
<font color="red">1502.             return ans._fix(context)</font>
<font color="black">1503. </font>
<font color="black">1504.         # self = 0 -&gt; remainder = self, with ideal exponent</font>
<font color="red">1505.         ideal_exponent = min(self._exp, other._exp)</font>
<font color="red">1506.         if not self:</font>
<font color="red">1507.             ans = _dec_from_triple(self._sign, '0', ideal_exponent)</font>
<font color="red">1508.             return ans._fix(context)</font>
<font color="black">1509. </font>
<font color="black">1510.         # catch most cases of large or small quotient</font>
<font color="red">1511.         expdiff = self.adjusted() - other.adjusted()</font>
<font color="red">1512.         if expdiff &gt;= context.prec + 1:</font>
<font color="black">1513.             # expdiff &gt;= prec+1 =&gt; abs(self/other) &gt; 10**prec</font>
<font color="red">1514.             return context._raise_error(DivisionImpossible)</font>
<font color="red">1515.         if expdiff &lt;= -2:</font>
<font color="black">1516.             # expdiff &lt;= -2 =&gt; abs(self/other) &lt; 0.1</font>
<font color="red">1517.             ans = self._rescale(ideal_exponent, context.rounding)</font>
<font color="red">1518.             return ans._fix(context)</font>
<font color="black">1519. </font>
<font color="black">1520.         # adjust both arguments to have the same exponent, then divide</font>
<font color="red">1521.         op1 = _WorkRep(self)</font>
<font color="red">1522.         op2 = _WorkRep(other)</font>
<font color="red">1523.         if op1.exp &gt;= op2.exp:</font>
<font color="red">1524.             op1.int *= 10**(op1.exp - op2.exp)</font>
<font color="black">1525.         else:</font>
<font color="red">1526.             op2.int *= 10**(op2.exp - op1.exp)</font>
<font color="red">1527.         q, r = divmod(op1.int, op2.int)</font>
<font color="black">1528.         # remainder is r*10**ideal_exponent; other is +/-op2.int *</font>
<font color="black">1529.         # 10**ideal_exponent.   Apply correction to ensure that</font>
<font color="black">1530.         # abs(remainder) &lt;= abs(other)/2</font>
<font color="red">1531.         if 2*r + (q&amp;1) &gt; op2.int:</font>
<font color="red">1532.             r -= op2.int</font>
<font color="red">1533.             q += 1</font>
<font color="black">1534. </font>
<font color="red">1535.         if q &gt;= 10**context.prec:</font>
<font color="red">1536.             return context._raise_error(DivisionImpossible)</font>
<font color="black">1537. </font>
<font color="black">1538.         # result has same sign as self unless r is negative</font>
<font color="red">1539.         sign = self._sign</font>
<font color="red">1540.         if r &lt; 0:</font>
<font color="red">1541.             sign = 1-sign</font>
<font color="red">1542.             r = -r</font>
<font color="black">1543. </font>
<font color="red">1544.         ans = _dec_from_triple(sign, str(r), ideal_exponent)</font>
<font color="red">1545.         return ans._fix(context)</font>
<font color="black">1546. </font>
<font color="green">1547.     def __floordiv__(self, other, context=None):</font>
<font color="black">1548.         &quot;&quot;&quot;self // other&quot;&quot;&quot;</font>
<font color="red">1549.         other = _convert_other(other)</font>
<font color="red">1550.         if other is NotImplemented:</font>
<font color="red">1551.             return other</font>
<font color="black">1552. </font>
<font color="red">1553.         if context is None:</font>
<font color="red">1554.             context = getcontext()</font>
<font color="black">1555. </font>
<font color="red">1556.         ans = self._check_nans(other, context)</font>
<font color="red">1557.         if ans:</font>
<font color="red">1558.             return ans</font>
<font color="black">1559. </font>
<font color="red">1560.         if self._isinfinity():</font>
<font color="red">1561.             if other._isinfinity():</font>
<font color="red">1562.                 return context._raise_error(InvalidOperation, 'INF // INF')</font>
<font color="black">1563.             else:</font>
<font color="red">1564.                 return _SignedInfinity[self._sign ^ other._sign]</font>
<font color="black">1565. </font>
<font color="red">1566.         if not other:</font>
<font color="red">1567.             if self:</font>
<font color="red">1568.                 return context._raise_error(DivisionByZero, 'x // 0',</font>
<font color="red">1569.                                             self._sign ^ other._sign)</font>
<font color="black">1570.             else:</font>
<font color="red">1571.                 return context._raise_error(DivisionUndefined, '0 // 0')</font>
<font color="black">1572. </font>
<font color="red">1573.         return self._divide(other, context)[0]</font>
<font color="black">1574. </font>
<font color="green">1575.     def __rfloordiv__(self, other, context=None):</font>
<font color="black">1576.         &quot;&quot;&quot;Swaps self/other and returns __floordiv__.&quot;&quot;&quot;</font>
<font color="red">1577.         other = _convert_other(other)</font>
<font color="red">1578.         if other is NotImplemented:</font>
<font color="red">1579.             return other</font>
<font color="red">1580.         return other.__floordiv__(self, context=context)</font>
<font color="black">1581. </font>
<font color="green">1582.     def __float__(self):</font>
<font color="black">1583.         &quot;&quot;&quot;Float representation.&quot;&quot;&quot;</font>
<font color="red">1584.         if self._isnan():</font>
<font color="red">1585.             if self.is_snan():</font>
<font color="red">1586.                 raise ValueError(&quot;Cannot convert signaling NaN to float&quot;)</font>
<font color="red">1587.             s = &quot;-nan&quot; if self._sign else &quot;nan&quot;</font>
<font color="black">1588.         else:</font>
<font color="red">1589.             s = str(self)</font>
<font color="red">1590.         return float(s)</font>
<font color="black">1591. </font>
<font color="green">1592.     def __int__(self):</font>
<font color="black">1593.         &quot;&quot;&quot;Converts self to an int, truncating if necessary.&quot;&quot;&quot;</font>
<font color="red">1594.         if self._is_special:</font>
<font color="red">1595.             if self._isnan():</font>
<font color="red">1596.                 raise ValueError(&quot;Cannot convert NaN to integer&quot;)</font>
<font color="red">1597.             elif self._isinfinity():</font>
<font color="red">1598.                 raise OverflowError(&quot;Cannot convert infinity to integer&quot;)</font>
<font color="red">1599.         s = (-1)**self._sign</font>
<font color="red">1600.         if self._exp &gt;= 0:</font>
<font color="red">1601.             return s*int(self._int)*10**self._exp</font>
<font color="black">1602.         else:</font>
<font color="red">1603.             return s*int(self._int[:self._exp] or '0')</font>
<font color="black">1604. </font>
<font color="green">1605.     __trunc__ = __int__</font>
<font color="black">1606. </font>
<font color="green">1607.     def real(self):</font>
<font color="red">1608.         return self</font>
<font color="green">1609.     real = property(real)</font>
<font color="black">1610. </font>
<font color="green">1611.     def imag(self):</font>
<font color="red">1612.         return Decimal(0)</font>
<font color="green">1613.     imag = property(imag)</font>
<font color="black">1614. </font>
<font color="green">1615.     def conjugate(self):</font>
<font color="red">1616.         return self</font>
<font color="black">1617. </font>
<font color="green">1618.     def __complex__(self):</font>
<font color="red">1619.         return complex(float(self))</font>
<font color="black">1620. </font>
<font color="green">1621.     def __long__(self):</font>
<font color="black">1622.         &quot;&quot;&quot;Converts to a long.</font>
<font color="black">1623. </font>
<font color="black">1624.         Equivalent to long(int(self))</font>
<font color="black">1625.         &quot;&quot;&quot;</font>
<font color="red">1626.         return long(self.__int__())</font>
<font color="black">1627. </font>
<font color="green">1628.     def _fix_nan(self, context):</font>
<font color="black">1629.         &quot;&quot;&quot;Decapitate the payload of a NaN to fit the context&quot;&quot;&quot;</font>
<font color="red">1630.         payload = self._int</font>
<font color="black">1631. </font>
<font color="black">1632.         # maximum length of payload is precision if _clamp=0,</font>
<font color="black">1633.         # precision-1 if _clamp=1.</font>
<font color="red">1634.         max_payload_len = context.prec - context._clamp</font>
<font color="red">1635.         if len(payload) &gt; max_payload_len:</font>
<font color="red">1636.             payload = payload[len(payload)-max_payload_len:].lstrip('0')</font>
<font color="red">1637.             return _dec_from_triple(self._sign, payload, self._exp, True)</font>
<font color="red">1638.         return Decimal(self)</font>
<font color="black">1639. </font>
<font color="green">1640.     def _fix(self, context):</font>
<font color="black">1641.         &quot;&quot;&quot;Round if it is necessary to keep self within prec precision.</font>
<font color="black">1642. </font>
<font color="black">1643.         Rounds and fixes the exponent.  Does not raise on a sNaN.</font>
<font color="black">1644. </font>
<font color="black">1645.         Arguments:</font>
<font color="black">1646.         self - Decimal instance</font>
<font color="black">1647.         context - context used.</font>
<font color="black">1648.         &quot;&quot;&quot;</font>
<font color="black">1649. </font>
<font color="red">1650.         if self._is_special:</font>
<font color="red">1651.             if self._isnan():</font>
<font color="black">1652.                 # decapitate payload if necessary</font>
<font color="red">1653.                 return self._fix_nan(context)</font>
<font color="black">1654.             else:</font>
<font color="black">1655.                 # self is +/-Infinity; return unaltered</font>
<font color="red">1656.                 return Decimal(self)</font>
<font color="black">1657. </font>
<font color="black">1658.         # if self is zero then exponent should be between Etiny and</font>
<font color="black">1659.         # Emax if _clamp==0, and between Etiny and Etop if _clamp==1.</font>
<font color="red">1660.         Etiny = context.Etiny()</font>
<font color="red">1661.         Etop = context.Etop()</font>
<font color="red">1662.         if not self:</font>
<font color="red">1663.             exp_max = [context.Emax, Etop][context._clamp]</font>
<font color="red">1664.             new_exp = min(max(self._exp, Etiny), exp_max)</font>
<font color="red">1665.             if new_exp != self._exp:</font>
<font color="red">1666.                 context._raise_error(Clamped)</font>
<font color="red">1667.                 return _dec_from_triple(self._sign, '0', new_exp)</font>
<font color="black">1668.             else:</font>
<font color="red">1669.                 return Decimal(self)</font>
<font color="black">1670. </font>
<font color="black">1671.         # exp_min is the smallest allowable exponent of the result,</font>
<font color="black">1672.         # equal to max(self.adjusted()-context.prec+1, Etiny)</font>
<font color="red">1673.         exp_min = len(self._int) + self._exp - context.prec</font>
<font color="red">1674.         if exp_min &gt; Etop:</font>
<font color="black">1675.             # overflow: exp_min &gt; Etop iff self.adjusted() &gt; Emax</font>
<font color="red">1676.             ans = context._raise_error(Overflow, 'above Emax', self._sign)</font>
<font color="red">1677.             context._raise_error(Inexact)</font>
<font color="red">1678.             context._raise_error(Rounded)</font>
<font color="red">1679.             return ans</font>
<font color="black">1680. </font>
<font color="red">1681.         self_is_subnormal = exp_min &lt; Etiny</font>
<font color="red">1682.         if self_is_subnormal:</font>
<font color="red">1683.             exp_min = Etiny</font>
<font color="black">1684. </font>
<font color="black">1685.         # round if self has too many digits</font>
<font color="red">1686.         if self._exp &lt; exp_min:</font>
<font color="red">1687.             digits = len(self._int) + self._exp - exp_min</font>
<font color="red">1688.             if digits &lt; 0:</font>
<font color="red">1689.                 self = _dec_from_triple(self._sign, '1', exp_min-1)</font>
<font color="red">1690.                 digits = 0</font>
<font color="red">1691.             rounding_method = self._pick_rounding_function[context.rounding]</font>
<font color="red">1692.             changed = rounding_method(self, digits)</font>
<font color="red">1693.             coeff = self._int[:digits] or '0'</font>
<font color="red">1694.             if changed &gt; 0:</font>
<font color="red">1695.                 coeff = str(int(coeff)+1)</font>
<font color="red">1696.                 if len(coeff) &gt; context.prec:</font>
<font color="red">1697.                     coeff = coeff[:-1]</font>
<font color="red">1698.                     exp_min += 1</font>
<font color="black">1699. </font>
<font color="black">1700.             # check whether the rounding pushed the exponent out of range</font>
<font color="red">1701.             if exp_min &gt; Etop:</font>
<font color="red">1702.                 ans = context._raise_error(Overflow, 'above Emax', self._sign)</font>
<font color="black">1703.             else:</font>
<font color="red">1704.                 ans = _dec_from_triple(self._sign, coeff, exp_min)</font>
<font color="black">1705. </font>
<font color="black">1706.             # raise the appropriate signals, taking care to respect</font>
<font color="black">1707.             # the precedence described in the specification</font>
<font color="red">1708.             if changed and self_is_subnormal:</font>
<font color="red">1709.                 context._raise_error(Underflow)</font>
<font color="red">1710.             if self_is_subnormal:</font>
<font color="red">1711.                 context._raise_error(Subnormal)</font>
<font color="red">1712.             if changed:</font>
<font color="red">1713.                 context._raise_error(Inexact)</font>
<font color="red">1714.             context._raise_error(Rounded)</font>
<font color="red">1715.             if not ans:</font>
<font color="black">1716.                 # raise Clamped on underflow to 0</font>
<font color="red">1717.                 context._raise_error(Clamped)</font>
<font color="red">1718.             return ans</font>
<font color="black">1719. </font>
<font color="red">1720.         if self_is_subnormal:</font>
<font color="red">1721.             context._raise_error(Subnormal)</font>
<font color="black">1722. </font>
<font color="black">1723.         # fold down if _clamp == 1 and self has too few digits</font>
<font color="red">1724.         if context._clamp == 1 and self._exp &gt; Etop:</font>
<font color="red">1725.             context._raise_error(Clamped)</font>
<font color="red">1726.             self_padded = self._int + '0'*(self._exp - Etop)</font>
<font color="red">1727.             return _dec_from_triple(self._sign, self_padded, Etop)</font>
<font color="black">1728. </font>
<font color="black">1729.         # here self was representable to begin with; return unchanged</font>
<font color="red">1730.         return Decimal(self)</font>
<font color="black">1731. </font>
<font color="black">1732.     # for each of the rounding functions below:</font>
<font color="black">1733.     #   self is a finite, nonzero Decimal</font>
<font color="black">1734.     #   prec is an integer satisfying 0 &lt;= prec &lt; len(self._int)</font>
<font color="black">1735.     #</font>
<font color="black">1736.     # each function returns either -1, 0, or 1, as follows:</font>
<font color="black">1737.     #   1 indicates that self should be rounded up (away from zero)</font>
<font color="black">1738.     #   0 indicates that self should be truncated, and that all the</font>
<font color="black">1739.     #     digits to be truncated are zeros (so the value is unchanged)</font>
<font color="black">1740.     #  -1 indicates that there are nonzero digits to be truncated</font>
<font color="black">1741. </font>
<font color="green">1742.     def _round_down(self, prec):</font>
<font color="black">1743.         &quot;&quot;&quot;Also known as round-towards-0, truncate.&quot;&quot;&quot;</font>
<font color="red">1744.         if _all_zeros(self._int, prec):</font>
<font color="red">1745.             return 0</font>
<font color="black">1746.         else:</font>
<font color="red">1747.             return -1</font>
<font color="black">1748. </font>
<font color="green">1749.     def _round_up(self, prec):</font>
<font color="black">1750.         &quot;&quot;&quot;Rounds away from 0.&quot;&quot;&quot;</font>
<font color="red">1751.         return -self._round_down(prec)</font>
<font color="black">1752. </font>
<font color="green">1753.     def _round_half_up(self, prec):</font>
<font color="black">1754.         &quot;&quot;&quot;Rounds 5 up (away from 0)&quot;&quot;&quot;</font>
<font color="red">1755.         if self._int[prec] in '56789':</font>
<font color="red">1756.             return 1</font>
<font color="red">1757.         elif _all_zeros(self._int, prec):</font>
<font color="red">1758.             return 0</font>
<font color="black">1759.         else:</font>
<font color="red">1760.             return -1</font>
<font color="black">1761. </font>
<font color="green">1762.     def _round_half_down(self, prec):</font>
<font color="black">1763.         &quot;&quot;&quot;Round 5 down&quot;&quot;&quot;</font>
<font color="red">1764.         if _exact_half(self._int, prec):</font>
<font color="red">1765.             return -1</font>
<font color="black">1766.         else:</font>
<font color="red">1767.             return self._round_half_up(prec)</font>
<font color="black">1768. </font>
<font color="green">1769.     def _round_half_even(self, prec):</font>
<font color="black">1770.         &quot;&quot;&quot;Round 5 to even, rest to nearest.&quot;&quot;&quot;</font>
<font color="red">1771.         if _exact_half(self._int, prec) and \</font>
<font color="red">1772.                 (prec == 0 or self._int[prec-1] in '02468'):</font>
<font color="red">1773.             return -1</font>
<font color="black">1774.         else:</font>
<font color="red">1775.             return self._round_half_up(prec)</font>
<font color="black">1776. </font>
<font color="green">1777.     def _round_ceiling(self, prec):</font>
<font color="black">1778.         &quot;&quot;&quot;Rounds up (not away from 0 if negative.)&quot;&quot;&quot;</font>
<font color="red">1779.         if self._sign:</font>
<font color="red">1780.             return self._round_down(prec)</font>
<font color="black">1781.         else:</font>
<font color="red">1782.             return -self._round_down(prec)</font>
<font color="black">1783. </font>
<font color="green">1784.     def _round_floor(self, prec):</font>
<font color="black">1785.         &quot;&quot;&quot;Rounds down (not towards 0 if negative)&quot;&quot;&quot;</font>
<font color="red">1786.         if not self._sign:</font>
<font color="red">1787.             return self._round_down(prec)</font>
<font color="black">1788.         else:</font>
<font color="red">1789.             return -self._round_down(prec)</font>
<font color="black">1790. </font>
<font color="green">1791.     def _round_05up(self, prec):</font>
<font color="black">1792.         &quot;&quot;&quot;Round down unless digit prec-1 is 0 or 5.&quot;&quot;&quot;</font>
<font color="red">1793.         if prec and self._int[prec-1] not in '05':</font>
<font color="red">1794.             return self._round_down(prec)</font>
<font color="black">1795.         else:</font>
<font color="red">1796.             return -self._round_down(prec)</font>
<font color="black">1797. </font>
<font color="green">1798.     _pick_rounding_function = dict(</font>
<font color="green">1799.         ROUND_DOWN = _round_down,</font>
<font color="green">1800.         ROUND_UP = _round_up,</font>
<font color="green">1801.         ROUND_HALF_UP = _round_half_up,</font>
<font color="green">1802.         ROUND_HALF_DOWN = _round_half_down,</font>
<font color="green">1803.         ROUND_HALF_EVEN = _round_half_even,</font>
<font color="green">1804.         ROUND_CEILING = _round_ceiling,</font>
<font color="green">1805.         ROUND_FLOOR = _round_floor,</font>
<font color="green">1806.         ROUND_05UP = _round_05up,</font>
<font color="black">1807.     )</font>
<font color="black">1808. </font>
<font color="green">1809.     def fma(self, other, third, context=None):</font>
<font color="black">1810.         &quot;&quot;&quot;Fused multiply-add.</font>
<font color="black">1811. </font>
<font color="black">1812.         Returns self*other+third with no rounding of the intermediate</font>
<font color="black">1813.         product self*other.</font>
<font color="black">1814. </font>
<font color="black">1815.         self and other are multiplied together, with no rounding of</font>
<font color="black">1816.         the result.  The third operand is then added to the result,</font>
<font color="black">1817.         and a single final rounding is performed.</font>
<font color="black">1818.         &quot;&quot;&quot;</font>
<font color="black">1819. </font>
<font color="red">1820.         other = _convert_other(other, raiseit=True)</font>
<font color="black">1821. </font>
<font color="black">1822.         # compute product; raise InvalidOperation if either operand is</font>
<font color="black">1823.         # a signaling NaN or if the product is zero times infinity.</font>
<font color="red">1824.         if self._is_special or other._is_special:</font>
<font color="red">1825.             if context is None:</font>
<font color="red">1826.                 context = getcontext()</font>
<font color="red">1827.             if self._exp == 'N':</font>
<font color="red">1828.                 return context._raise_error(InvalidOperation, 'sNaN', self)</font>
<font color="red">1829.             if other._exp == 'N':</font>
<font color="red">1830.                 return context._raise_error(InvalidOperation, 'sNaN', other)</font>
<font color="red">1831.             if self._exp == 'n':</font>
<font color="red">1832.                 product = self</font>
<font color="red">1833.             elif other._exp == 'n':</font>
<font color="red">1834.                 product = other</font>
<font color="red">1835.             elif self._exp == 'F':</font>
<font color="red">1836.                 if not other:</font>
<font color="red">1837.                     return context._raise_error(InvalidOperation,</font>
<font color="red">1838.                                                 'INF * 0 in fma')</font>
<font color="red">1839.                 product = _SignedInfinity[self._sign ^ other._sign]</font>
<font color="red">1840.             elif other._exp == 'F':</font>
<font color="red">1841.                 if not self:</font>
<font color="red">1842.                     return context._raise_error(InvalidOperation,</font>
<font color="red">1843.                                                 '0 * INF in fma')</font>
<font color="red">1844.                 product = _SignedInfinity[self._sign ^ other._sign]</font>
<font color="black">1845.         else:</font>
<font color="red">1846.             product = _dec_from_triple(self._sign ^ other._sign,</font>
<font color="red">1847.                                        str(int(self._int) * int(other._int)),</font>
<font color="red">1848.                                        self._exp + other._exp)</font>
<font color="black">1849. </font>
<font color="red">1850.         third = _convert_other(third, raiseit=True)</font>
<font color="red">1851.         return product.__add__(third, context)</font>
<font color="black">1852. </font>
<font color="green">1853.     def _power_modulo(self, other, modulo, context=None):</font>
<font color="black">1854.         &quot;&quot;&quot;Three argument version of __pow__&quot;&quot;&quot;</font>
<font color="black">1855. </font>
<font color="black">1856.         # if can't convert other and modulo to Decimal, raise</font>
<font color="black">1857.         # TypeError; there's no point returning NotImplemented (no</font>
<font color="black">1858.         # equivalent of __rpow__ for three argument pow)</font>
<font color="red">1859.         other = _convert_other(other, raiseit=True)</font>
<font color="red">1860.         modulo = _convert_other(modulo, raiseit=True)</font>
<font color="black">1861. </font>
<font color="red">1862.         if context is None:</font>
<font color="red">1863.             context = getcontext()</font>
<font color="black">1864. </font>
<font color="black">1865.         # deal with NaNs: if there are any sNaNs then first one wins,</font>
<font color="black">1866.         # (i.e. behaviour for NaNs is identical to that of fma)</font>
<font color="red">1867.         self_is_nan = self._isnan()</font>
<font color="red">1868.         other_is_nan = other._isnan()</font>
<font color="red">1869.         modulo_is_nan = modulo._isnan()</font>
<font color="red">1870.         if self_is_nan or other_is_nan or modulo_is_nan:</font>
<font color="red">1871.             if self_is_nan == 2:</font>
<font color="red">1872.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red">1873.                                         self)</font>
<font color="red">1874.             if other_is_nan == 2:</font>
<font color="red">1875.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red">1876.                                         other)</font>
<font color="red">1877.             if modulo_is_nan == 2:</font>
<font color="red">1878.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red">1879.                                         modulo)</font>
<font color="red">1880.             if self_is_nan:</font>
<font color="red">1881.                 return self._fix_nan(context)</font>
<font color="red">1882.             if other_is_nan:</font>
<font color="red">1883.                 return other._fix_nan(context)</font>
<font color="red">1884.             return modulo._fix_nan(context)</font>
<font color="black">1885. </font>
<font color="black">1886.         # check inputs: we apply same restrictions as Python's pow()</font>
<font color="red">1887.         if not (self._isinteger() and</font>
<font color="red">1888.                 other._isinteger() and</font>
<font color="red">1889.                 modulo._isinteger()):</font>
<font color="red">1890.             return context._raise_error(InvalidOperation,</font>
<font color="red">1891.                                         'pow() 3rd argument not allowed '</font>
<font color="black">1892.                                         'unless all arguments are integers')</font>
<font color="red">1893.         if other &lt; 0:</font>
<font color="red">1894.             return context._raise_error(InvalidOperation,</font>
<font color="red">1895.                                         'pow() 2nd argument cannot be '</font>
<font color="black">1896.                                         'negative when 3rd argument specified')</font>
<font color="red">1897.         if not modulo:</font>
<font color="red">1898.             return context._raise_error(InvalidOperation,</font>
<font color="red">1899.                                         'pow() 3rd argument cannot be 0')</font>
<font color="black">1900. </font>
<font color="black">1901.         # additional restriction for decimal: the modulus must be less</font>
<font color="black">1902.         # than 10**prec in absolute value</font>
<font color="red">1903.         if modulo.adjusted() &gt;= context.prec:</font>
<font color="red">1904.             return context._raise_error(InvalidOperation,</font>
<font color="red">1905.                                         'insufficient precision: pow() 3rd '</font>
<font color="black">1906.                                         'argument must not have more than '</font>
<font color="black">1907.                                         'precision digits')</font>
<font color="black">1908. </font>
<font color="black">1909.         # define 0**0 == NaN, for consistency with two-argument pow</font>
<font color="black">1910.         # (even though it hurts!)</font>
<font color="red">1911.         if not other and not self:</font>
<font color="red">1912.             return context._raise_error(InvalidOperation,</font>
<font color="red">1913.                                         'at least one of pow() 1st argument '</font>
<font color="black">1914.                                         'and 2nd argument must be nonzero ;'</font>
<font color="black">1915.                                         '0**0 is not defined')</font>
<font color="black">1916. </font>
<font color="black">1917.         # compute sign of result</font>
<font color="red">1918.         if other._iseven():</font>
<font color="red">1919.             sign = 0</font>
<font color="black">1920.         else:</font>
<font color="red">1921.             sign = self._sign</font>
<font color="black">1922. </font>
<font color="black">1923.         # convert modulo to a Python integer, and self and other to</font>
<font color="black">1924.         # Decimal integers (i.e. force their exponents to be &gt;= 0)</font>
<font color="red">1925.         modulo = abs(int(modulo))</font>
<font color="red">1926.         base = _WorkRep(self.to_integral_value())</font>
<font color="red">1927.         exponent = _WorkRep(other.to_integral_value())</font>
<font color="black">1928. </font>
<font color="black">1929.         # compute result using integer pow()</font>
<font color="red">1930.         base = (base.int % modulo * pow(10, base.exp, modulo)) % modulo</font>
<font color="red">1931.         for i in xrange(exponent.exp):</font>
<font color="red">1932.             base = pow(base, 10, modulo)</font>
<font color="red">1933.         base = pow(base, exponent.int, modulo)</font>
<font color="black">1934. </font>
<font color="red">1935.         return _dec_from_triple(sign, str(base), 0)</font>
<font color="black">1936. </font>
<font color="green">1937.     def _power_exact(self, other, p):</font>
<font color="black">1938.         &quot;&quot;&quot;Attempt to compute self**other exactly.</font>
<font color="black">1939. </font>
<font color="black">1940.         Given Decimals self and other and an integer p, attempt to</font>
<font color="black">1941.         compute an exact result for the power self**other, with p</font>
<font color="black">1942.         digits of precision.  Return None if self**other is not</font>
<font color="black">1943.         exactly representable in p digits.</font>
<font color="black">1944. </font>
<font color="black">1945.         Assumes that elimination of special cases has already been</font>
<font color="black">1946.         performed: self and other must both be nonspecial; self must</font>
<font color="black">1947.         be positive and not numerically equal to 1; other must be</font>
<font color="black">1948.         nonzero.  For efficiency, other._exp should not be too large,</font>
<font color="black">1949.         so that 10**abs(other._exp) is a feasible calculation.&quot;&quot;&quot;</font>
<font color="black">1950. </font>
<font color="black">1951.         # In the comments below, we write x for the value of self and y for the</font>
<font color="black">1952.         # value of other.  Write x = xc*10**xe and abs(y) = yc*10**ye, with xc</font>
<font color="black">1953.         # and yc positive integers not divisible by 10.</font>
<font color="black">1954. </font>
<font color="black">1955.         # The main purpose of this method is to identify the *failure*</font>
<font color="black">1956.         # of x**y to be exactly representable with as little effort as</font>
<font color="black">1957.         # possible.  So we look for cheap and easy tests that</font>
<font color="black">1958.         # eliminate the possibility of x**y being exact.  Only if all</font>
<font color="black">1959.         # these tests are passed do we go on to actually compute x**y.</font>
<font color="black">1960. </font>
<font color="black">1961.         # Here's the main idea.  Express y as a rational number m/n, with m and</font>
<font color="black">1962.         # n relatively prime and n&gt;0.  Then for x**y to be exactly</font>
<font color="black">1963.         # representable (at *any* precision), xc must be the nth power of a</font>
<font color="black">1964.         # positive integer and xe must be divisible by n.  If y is negative</font>
<font color="black">1965.         # then additionally xc must be a power of either 2 or 5, hence a power</font>
<font color="black">1966.         # of 2**n or 5**n.</font>
<font color="black">1967.         #</font>
<font color="black">1968.         # There's a limit to how small |y| can be: if y=m/n as above</font>
<font color="black">1969.         # then:</font>
<font color="black">1970.         #</font>
<font color="black">1971.         #  (1) if xc != 1 then for the result to be representable we</font>
<font color="black">1972.         #      need xc**(1/n) &gt;= 2, and hence also xc**|y| &gt;= 2.  So</font>
<font color="black">1973.         #      if |y| &lt;= 1/nbits(xc) then xc &lt; 2**nbits(xc) &lt;=</font>
<font color="black">1974.         #      2**(1/|y|), hence xc**|y| &lt; 2 and the result is not</font>
<font color="black">1975.         #      representable.</font>
<font color="black">1976.         #</font>
<font color="black">1977.         #  (2) if xe != 0, |xe|*(1/n) &gt;= 1, so |xe|*|y| &gt;= 1.  Hence if</font>
<font color="black">1978.         #      |y| &lt; 1/|xe| then the result is not representable.</font>
<font color="black">1979.         #</font>
<font color="black">1980.         # Note that since x is not equal to 1, at least one of (1) and</font>
<font color="black">1981.         # (2) must apply.  Now |y| &lt; 1/nbits(xc) iff |yc|*nbits(xc) &lt;</font>
<font color="black">1982.         # 10**-ye iff len(str(|yc|*nbits(xc)) &lt;= -ye.</font>
<font color="black">1983.         #</font>
<font color="black">1984.         # There's also a limit to how large y can be, at least if it's</font>
<font color="black">1985.         # positive: the normalized result will have coefficient xc**y,</font>
<font color="black">1986.         # so if it's representable then xc**y &lt; 10**p, and y &lt;</font>
<font color="black">1987.         # p/log10(xc).  Hence if y*log10(xc) &gt;= p then the result is</font>
<font color="black">1988.         # not exactly representable.</font>
<font color="black">1989. </font>
<font color="black">1990.         # if len(str(abs(yc*xe)) &lt;= -ye then abs(yc*xe) &lt; 10**-ye,</font>
<font color="black">1991.         # so |y| &lt; 1/xe and the result is not representable.</font>
<font color="black">1992.         # Similarly, len(str(abs(yc)*xc_bits)) &lt;= -ye implies |y|</font>
<font color="black">1993.         # &lt; 1/nbits(xc).</font>
<font color="black">1994. </font>
<font color="red">1995.         x = _WorkRep(self)</font>
<font color="red">1996.         xc, xe = x.int, x.exp</font>
<font color="red">1997.         while xc % 10 == 0:</font>
<font color="red">1998.             xc //= 10</font>
<font color="red">1999.             xe += 1</font>
<font color="black">2000. </font>
<font color="red">2001.         y = _WorkRep(other)</font>
<font color="red">2002.         yc, ye = y.int, y.exp</font>
<font color="red">2003.         while yc % 10 == 0:</font>
<font color="red">2004.             yc //= 10</font>
<font color="red">2005.             ye += 1</font>
<font color="black">2006. </font>
<font color="black">2007.         # case where xc == 1: result is 10**(xe*y), with xe*y</font>
<font color="black">2008.         # required to be an integer</font>
<font color="red">2009.         if xc == 1:</font>
<font color="red">2010.             xe *= yc</font>
<font color="black">2011.             # result is now 10**(xe * 10**ye);  xe * 10**ye must be integral</font>
<font color="red">2012.             while xe % 10 == 0:</font>
<font color="red">2013.                 xe //= 10</font>
<font color="red">2014.                 ye += 1</font>
<font color="red">2015.             if ye &lt; 0:</font>
<font color="red">2016.                 return None</font>
<font color="red">2017.             exponent = xe * 10**ye</font>
<font color="red">2018.             if y.sign == 1:</font>
<font color="red">2019.                 exponent = -exponent</font>
<font color="black">2020.             # if other is a nonnegative integer, use ideal exponent</font>
<font color="red">2021.             if other._isinteger() and other._sign == 0:</font>
<font color="red">2022.                 ideal_exponent = self._exp*int(other)</font>
<font color="red">2023.                 zeros = min(exponent-ideal_exponent, p-1)</font>
<font color="black">2024.             else:</font>
<font color="red">2025.                 zeros = 0</font>
<font color="red">2026.             return _dec_from_triple(0, '1' + '0'*zeros, exponent-zeros)</font>
<font color="black">2027. </font>
<font color="black">2028.         # case where y is negative: xc must be either a power</font>
<font color="black">2029.         # of 2 or a power of 5.</font>
<font color="red">2030.         if y.sign == 1:</font>
<font color="red">2031.             last_digit = xc % 10</font>
<font color="red">2032.             if last_digit in (2,4,6,8):</font>
<font color="black">2033.                 # quick test for power of 2</font>
<font color="red">2034.                 if xc &amp; -xc != xc:</font>
<font color="red">2035.                     return None</font>
<font color="black">2036.                 # now xc is a power of 2; e is its exponent</font>
<font color="red">2037.                 e = _nbits(xc)-1</font>
<font color="black">2038. </font>
<font color="black">2039.                 # We now have:</font>
<font color="black">2040.                 #</font>
<font color="black">2041.                 #   x = 2**e * 10**xe, e &gt; 0, and y &lt; 0.</font>
<font color="black">2042.                 #</font>
<font color="black">2043.                 # The exact result is:</font>
<font color="black">2044.                 #</font>
<font color="black">2045.                 #   x**y = 5**(-e*y) * 10**(e*y + xe*y)</font>
<font color="black">2046.                 #</font>
<font color="black">2047.                 # provided that both e*y and xe*y are integers.  Note that if</font>
<font color="black">2048.                 # 5**(-e*y) &gt;= 10**p, then the result can't be expressed</font>
<font color="black">2049.                 # exactly with p digits of precision.</font>
<font color="black">2050.                 #</font>
<font color="black">2051.                 # Using the above, we can guard against large values of ye.</font>
<font color="black">2052.                 # 93/65 is an upper bound for log(10)/log(5), so if</font>
<font color="black">2053.                 #</font>
<font color="black">2054.                 #   ye &gt;= len(str(93*p//65))</font>
<font color="black">2055.                 #</font>
<font color="black">2056.                 # then</font>
<font color="black">2057.                 #</font>
<font color="black">2058.                 #   -e*y &gt;= -y &gt;= 10**ye &gt; 93*p/65 &gt; p*log(10)/log(5),</font>
<font color="black">2059.                 #</font>
<font color="black">2060.                 # so 5**(-e*y) &gt;= 10**p, and the coefficient of the result</font>
<font color="black">2061.                 # can't be expressed in p digits.</font>
<font color="black">2062. </font>
<font color="black">2063.                 # emax &gt;= largest e such that 5**e &lt; 10**p.</font>
<font color="red">2064.                 emax = p*93//65</font>
<font color="red">2065.                 if ye &gt;= len(str(emax)):</font>
<font color="red">2066.                     return None</font>
<font color="black">2067. </font>
<font color="black">2068.                 # Find -e*y and -xe*y; both must be integers</font>
<font color="red">2069.                 e = _decimal_lshift_exact(e * yc, ye)</font>
<font color="red">2070.                 xe = _decimal_lshift_exact(xe * yc, ye)</font>
<font color="red">2071.                 if e is None or xe is None:</font>
<font color="red">2072.                     return None</font>
<font color="black">2073. </font>
<font color="red">2074.                 if e &gt; emax:</font>
<font color="red">2075.                     return None</font>
<font color="red">2076.                 xc = 5**e</font>
<font color="black">2077. </font>
<font color="red">2078.             elif last_digit == 5:</font>
<font color="black">2079.                 # e &gt;= log_5(xc) if xc is a power of 5; we have</font>
<font color="black">2080.                 # equality all the way up to xc=5**2658</font>
<font color="red">2081.                 e = _nbits(xc)*28//65</font>
<font color="red">2082.                 xc, remainder = divmod(5**e, xc)</font>
<font color="red">2083.                 if remainder:</font>
<font color="red">2084.                     return None</font>
<font color="red">2085.                 while xc % 5 == 0:</font>
<font color="red">2086.                     xc //= 5</font>
<font color="red">2087.                     e -= 1</font>
<font color="black">2088. </font>
<font color="black">2089.                 # Guard against large values of ye, using the same logic as in</font>
<font color="black">2090.                 # the 'xc is a power of 2' branch.  10/3 is an upper bound for</font>
<font color="black">2091.                 # log(10)/log(2).</font>
<font color="red">2092.                 emax = p*10//3</font>
<font color="red">2093.                 if ye &gt;= len(str(emax)):</font>
<font color="red">2094.                     return None</font>
<font color="black">2095. </font>
<font color="red">2096.                 e = _decimal_lshift_exact(e * yc, ye)</font>
<font color="red">2097.                 xe = _decimal_lshift_exact(xe * yc, ye)</font>
<font color="red">2098.                 if e is None or xe is None:</font>
<font color="red">2099.                     return None</font>
<font color="black">2100. </font>
<font color="red">2101.                 if e &gt; emax:</font>
<font color="red">2102.                     return None</font>
<font color="red">2103.                 xc = 2**e</font>
<font color="black">2104.             else:</font>
<font color="red">2105.                 return None</font>
<font color="black">2106. </font>
<font color="red">2107.             if xc &gt;= 10**p:</font>
<font color="red">2108.                 return None</font>
<font color="red">2109.             xe = -e-xe</font>
<font color="red">2110.             return _dec_from_triple(0, str(xc), xe)</font>
<font color="black">2111. </font>
<font color="black">2112.         # now y is positive; find m and n such that y = m/n</font>
<font color="red">2113.         if ye &gt;= 0:</font>
<font color="red">2114.             m, n = yc*10**ye, 1</font>
<font color="black">2115.         else:</font>
<font color="red">2116.             if xe != 0 and len(str(abs(yc*xe))) &lt;= -ye:</font>
<font color="red">2117.                 return None</font>
<font color="red">2118.             xc_bits = _nbits(xc)</font>
<font color="red">2119.             if xc != 1 and len(str(abs(yc)*xc_bits)) &lt;= -ye:</font>
<font color="red">2120.                 return None</font>
<font color="red">2121.             m, n = yc, 10**(-ye)</font>
<font color="red">2122.             while m % 2 == n % 2 == 0:</font>
<font color="red">2123.                 m //= 2</font>
<font color="red">2124.                 n //= 2</font>
<font color="red">2125.             while m % 5 == n % 5 == 0:</font>
<font color="red">2126.                 m //= 5</font>
<font color="red">2127.                 n //= 5</font>
<font color="black">2128. </font>
<font color="black">2129.         # compute nth root of xc*10**xe</font>
<font color="red">2130.         if n &gt; 1:</font>
<font color="black">2131.             # if 1 &lt; xc &lt; 2**n then xc isn't an nth power</font>
<font color="red">2132.             if xc != 1 and xc_bits &lt;= n:</font>
<font color="red">2133.                 return None</font>
<font color="black">2134. </font>
<font color="red">2135.             xe, rem = divmod(xe, n)</font>
<font color="red">2136.             if rem != 0:</font>
<font color="red">2137.                 return None</font>
<font color="black">2138. </font>
<font color="black">2139.             # compute nth root of xc using Newton's method</font>
<font color="red">2140.             a = 1L &lt;&lt; -(-_nbits(xc)//n) # initial estimate</font>
<font color="red">2141.             while True:</font>
<font color="red">2142.                 q, r = divmod(xc, a**(n-1))</font>
<font color="red">2143.                 if a &lt;= q:</font>
<font color="red">2144.                     break</font>
<font color="black">2145.                 else:</font>
<font color="red">2146.                     a = (a*(n-1) + q)//n</font>
<font color="red">2147.             if not (a == q and r == 0):</font>
<font color="red">2148.                 return None</font>
<font color="red">2149.             xc = a</font>
<font color="black">2150. </font>
<font color="black">2151.         # now xc*10**xe is the nth root of the original xc*10**xe</font>
<font color="black">2152.         # compute mth power of xc*10**xe</font>
<font color="black">2153. </font>
<font color="black">2154.         # if m &gt; p*100//_log10_lb(xc) then m &gt; p/log10(xc), hence xc**m &gt;</font>
<font color="black">2155.         # 10**p and the result is not representable.</font>
<font color="red">2156.         if xc &gt; 1 and m &gt; p*100//_log10_lb(xc):</font>
<font color="red">2157.             return None</font>
<font color="red">2158.         xc = xc**m</font>
<font color="red">2159.         xe *= m</font>
<font color="red">2160.         if xc &gt; 10**p:</font>
<font color="red">2161.             return None</font>
<font color="black">2162. </font>
<font color="black">2163.         # by this point the result *is* exactly representable</font>
<font color="black">2164.         # adjust the exponent to get as close as possible to the ideal</font>
<font color="black">2165.         # exponent, if necessary</font>
<font color="red">2166.         str_xc = str(xc)</font>
<font color="red">2167.         if other._isinteger() and other._sign == 0:</font>
<font color="red">2168.             ideal_exponent = self._exp*int(other)</font>
<font color="red">2169.             zeros = min(xe-ideal_exponent, p-len(str_xc))</font>
<font color="black">2170.         else:</font>
<font color="red">2171.             zeros = 0</font>
<font color="red">2172.         return _dec_from_triple(0, str_xc+'0'*zeros, xe-zeros)</font>
<font color="black">2173. </font>
<font color="green">2174.     def __pow__(self, other, modulo=None, context=None):</font>
<font color="black">2175.         &quot;&quot;&quot;Return self ** other [ % modulo].</font>
<font color="black">2176. </font>
<font color="black">2177.         With two arguments, compute self**other.</font>
<font color="black">2178. </font>
<font color="black">2179.         With three arguments, compute (self**other) % modulo.  For the</font>
<font color="black">2180.         three argument form, the following restrictions on the</font>
<font color="black">2181.         arguments hold:</font>
<font color="black">2182. </font>
<font color="black">2183.          - all three arguments must be integral</font>
<font color="black">2184.          - other must be nonnegative</font>
<font color="black">2185.          - either self or other (or both) must be nonzero</font>
<font color="black">2186.          - modulo must be nonzero and must have at most p digits,</font>
<font color="black">2187.            where p is the context precision.</font>
<font color="black">2188. </font>
<font color="black">2189.         If any of these restrictions is violated the InvalidOperation</font>
<font color="black">2190.         flag is raised.</font>
<font color="black">2191. </font>
<font color="black">2192.         The result of pow(self, other, modulo) is identical to the</font>
<font color="black">2193.         result that would be obtained by computing (self**other) %</font>
<font color="black">2194.         modulo with unbounded precision, but is computed more</font>
<font color="black">2195.         efficiently.  It is always exact.</font>
<font color="black">2196.         &quot;&quot;&quot;</font>
<font color="black">2197. </font>
<font color="red">2198.         if modulo is not None:</font>
<font color="red">2199.             return self._power_modulo(other, modulo, context)</font>
<font color="black">2200. </font>
<font color="red">2201.         other = _convert_other(other)</font>
<font color="red">2202.         if other is NotImplemented:</font>
<font color="red">2203.             return other</font>
<font color="black">2204. </font>
<font color="red">2205.         if context is None:</font>
<font color="red">2206.             context = getcontext()</font>
<font color="black">2207. </font>
<font color="black">2208.         # either argument is a NaN =&gt; result is NaN</font>
<font color="red">2209.         ans = self._check_nans(other, context)</font>
<font color="red">2210.         if ans:</font>
<font color="red">2211.             return ans</font>
<font color="black">2212. </font>
<font color="black">2213.         # 0**0 = NaN (!), x**0 = 1 for nonzero x (including +/-Infinity)</font>
<font color="red">2214.         if not other:</font>
<font color="red">2215.             if not self:</font>
<font color="red">2216.                 return context._raise_error(InvalidOperation, '0 ** 0')</font>
<font color="black">2217.             else:</font>
<font color="red">2218.                 return _One</font>
<font color="black">2219. </font>
<font color="black">2220.         # result has sign 1 iff self._sign is 1 and other is an odd integer</font>
<font color="red">2221.         result_sign = 0</font>
<font color="red">2222.         if self._sign == 1:</font>
<font color="red">2223.             if other._isinteger():</font>
<font color="red">2224.                 if not other._iseven():</font>
<font color="red">2225.                     result_sign = 1</font>
<font color="black">2226.             else:</font>
<font color="black">2227.                 # -ve**noninteger = NaN</font>
<font color="black">2228.                 # (-0)**noninteger = 0**noninteger</font>
<font color="red">2229.                 if self:</font>
<font color="red">2230.                     return context._raise_error(InvalidOperation,</font>
<font color="red">2231.                         'x ** y with x negative and y not an integer')</font>
<font color="black">2232.             # negate self, without doing any unwanted rounding</font>
<font color="red">2233.             self = self.copy_negate()</font>
<font color="black">2234. </font>
<font color="black">2235.         # 0**(+ve or Inf)= 0; 0**(-ve or -Inf) = Infinity</font>
<font color="red">2236.         if not self:</font>
<font color="red">2237.             if other._sign == 0:</font>
<font color="red">2238.                 return _dec_from_triple(result_sign, '0', 0)</font>
<font color="black">2239.             else:</font>
<font color="red">2240.                 return _SignedInfinity[result_sign]</font>
<font color="black">2241. </font>
<font color="black">2242.         # Inf**(+ve or Inf) = Inf; Inf**(-ve or -Inf) = 0</font>
<font color="red">2243.         if self._isinfinity():</font>
<font color="red">2244.             if other._sign == 0:</font>
<font color="red">2245.                 return _SignedInfinity[result_sign]</font>
<font color="black">2246.             else:</font>
<font color="red">2247.                 return _dec_from_triple(result_sign, '0', 0)</font>
<font color="black">2248. </font>
<font color="black">2249.         # 1**other = 1, but the choice of exponent and the flags</font>
<font color="black">2250.         # depend on the exponent of self, and on whether other is a</font>
<font color="black">2251.         # positive integer, a negative integer, or neither</font>
<font color="red">2252.         if self == _One:</font>
<font color="red">2253.             if other._isinteger():</font>
<font color="black">2254.                 # exp = max(self._exp*max(int(other), 0),</font>
<font color="black">2255.                 # 1-context.prec) but evaluating int(other) directly</font>
<font color="black">2256.                 # is dangerous until we know other is small (other</font>
<font color="black">2257.                 # could be 1e999999999)</font>
<font color="red">2258.                 if other._sign == 1:</font>
<font color="red">2259.                     multiplier = 0</font>
<font color="red">2260.                 elif other &gt; context.prec:</font>
<font color="red">2261.                     multiplier = context.prec</font>
<font color="black">2262.                 else:</font>
<font color="red">2263.                     multiplier = int(other)</font>
<font color="black">2264. </font>
<font color="red">2265.                 exp = self._exp * multiplier</font>
<font color="red">2266.                 if exp &lt; 1-context.prec:</font>
<font color="red">2267.                     exp = 1-context.prec</font>
<font color="red">2268.                     context._raise_error(Rounded)</font>
<font color="black">2269.             else:</font>
<font color="red">2270.                 context._raise_error(Inexact)</font>
<font color="red">2271.                 context._raise_error(Rounded)</font>
<font color="red">2272.                 exp = 1-context.prec</font>
<font color="black">2273. </font>
<font color="red">2274.             return _dec_from_triple(result_sign, '1'+'0'*-exp, exp)</font>
<font color="black">2275. </font>
<font color="black">2276.         # compute adjusted exponent of self</font>
<font color="red">2277.         self_adj = self.adjusted()</font>
<font color="black">2278. </font>
<font color="black">2279.         # self ** infinity is infinity if self &gt; 1, 0 if self &lt; 1</font>
<font color="black">2280.         # self ** -infinity is infinity if self &lt; 1, 0 if self &gt; 1</font>
<font color="red">2281.         if other._isinfinity():</font>
<font color="red">2282.             if (other._sign == 0) == (self_adj &lt; 0):</font>
<font color="red">2283.                 return _dec_from_triple(result_sign, '0', 0)</font>
<font color="black">2284.             else:</font>
<font color="red">2285.                 return _SignedInfinity[result_sign]</font>
<font color="black">2286. </font>
<font color="black">2287.         # from here on, the result always goes through the call</font>
<font color="black">2288.         # to _fix at the end of this function.</font>
<font color="red">2289.         ans = None</font>
<font color="red">2290.         exact = False</font>
<font color="black">2291. </font>
<font color="black">2292.         # crude test to catch cases of extreme overflow/underflow.  If</font>
<font color="black">2293.         # log10(self)*other &gt;= 10**bound and bound &gt;= len(str(Emax))</font>
<font color="black">2294.         # then 10**bound &gt;= 10**len(str(Emax)) &gt;= Emax+1 and hence</font>
<font color="black">2295.         # self**other &gt;= 10**(Emax+1), so overflow occurs.  The test</font>
<font color="black">2296.         # for underflow is similar.</font>
<font color="red">2297.         bound = self._log10_exp_bound() + other.adjusted()</font>
<font color="red">2298.         if (self_adj &gt;= 0) == (other._sign == 0):</font>
<font color="black">2299.             # self &gt; 1 and other +ve, or self &lt; 1 and other -ve</font>
<font color="black">2300.             # possibility of overflow</font>
<font color="red">2301.             if bound &gt;= len(str(context.Emax)):</font>
<font color="red">2302.                 ans = _dec_from_triple(result_sign, '1', context.Emax+1)</font>
<font color="black">2303.         else:</font>
<font color="black">2304.             # self &gt; 1 and other -ve, or self &lt; 1 and other +ve</font>
<font color="black">2305.             # possibility of underflow to 0</font>
<font color="red">2306.             Etiny = context.Etiny()</font>
<font color="red">2307.             if bound &gt;= len(str(-Etiny)):</font>
<font color="red">2308.                 ans = _dec_from_triple(result_sign, '1', Etiny-1)</font>
<font color="black">2309. </font>
<font color="black">2310.         # try for an exact result with precision +1</font>
<font color="red">2311.         if ans is None:</font>
<font color="red">2312.             ans = self._power_exact(other, context.prec + 1)</font>
<font color="red">2313.             if ans is not None:</font>
<font color="red">2314.                 if result_sign == 1:</font>
<font color="red">2315.                     ans = _dec_from_triple(1, ans._int, ans._exp)</font>
<font color="red">2316.                 exact = True</font>
<font color="black">2317. </font>
<font color="black">2318.         # usual case: inexact result, x**y computed directly as exp(y*log(x))</font>
<font color="red">2319.         if ans is None:</font>
<font color="red">2320.             p = context.prec</font>
<font color="red">2321.             x = _WorkRep(self)</font>
<font color="red">2322.             xc, xe = x.int, x.exp</font>
<font color="red">2323.             y = _WorkRep(other)</font>
<font color="red">2324.             yc, ye = y.int, y.exp</font>
<font color="red">2325.             if y.sign == 1:</font>
<font color="red">2326.                 yc = -yc</font>
<font color="black">2327. </font>
<font color="black">2328.             # compute correctly rounded result:  start with precision +3,</font>
<font color="black">2329.             # then increase precision until result is unambiguously roundable</font>
<font color="red">2330.             extra = 3</font>
<font color="red">2331.             while True:</font>
<font color="red">2332.                 coeff, exp = _dpower(xc, xe, yc, ye, p+extra)</font>
<font color="red">2333.                 if coeff % (5*10**(len(str(coeff))-p-1)):</font>
<font color="red">2334.                     break</font>
<font color="red">2335.                 extra += 3</font>
<font color="black">2336. </font>
<font color="red">2337.             ans = _dec_from_triple(result_sign, str(coeff), exp)</font>
<font color="black">2338. </font>
<font color="black">2339.         # unlike exp, ln and log10, the power function respects the</font>
<font color="black">2340.         # rounding mode; no need to switch to ROUND_HALF_EVEN here</font>
<font color="black">2341. </font>
<font color="black">2342.         # There's a difficulty here when 'other' is not an integer and</font>
<font color="black">2343.         # the result is exact.  In this case, the specification</font>
<font color="black">2344.         # requires that the Inexact flag be raised (in spite of</font>
<font color="black">2345.         # exactness), but since the result is exact _fix won't do this</font>
<font color="black">2346.         # for us.  (Correspondingly, the Underflow signal should also</font>
<font color="black">2347.         # be raised for subnormal results.)  We can't directly raise</font>
<font color="black">2348.         # these signals either before or after calling _fix, since</font>
<font color="black">2349.         # that would violate the precedence for signals.  So we wrap</font>
<font color="black">2350.         # the ._fix call in a temporary context, and reraise</font>
<font color="black">2351.         # afterwards.</font>
<font color="red">2352.         if exact and not other._isinteger():</font>
<font color="black">2353.             # pad with zeros up to length context.prec+1 if necessary; this</font>
<font color="black">2354.             # ensures that the Rounded signal will be raised.</font>
<font color="red">2355.             if len(ans._int) &lt;= context.prec:</font>
<font color="red">2356.                 expdiff = context.prec + 1 - len(ans._int)</font>
<font color="red">2357.                 ans = _dec_from_triple(ans._sign, ans._int+'0'*expdiff,</font>
<font color="red">2358.                                        ans._exp-expdiff)</font>
<font color="black">2359. </font>
<font color="black">2360.             # create a copy of the current context, with cleared flags/traps</font>
<font color="red">2361.             newcontext = context.copy()</font>
<font color="red">2362.             newcontext.clear_flags()</font>
<font color="red">2363.             for exception in _signals:</font>
<font color="red">2364.                 newcontext.traps[exception] = 0</font>
<font color="black">2365. </font>
<font color="black">2366.             # round in the new context</font>
<font color="red">2367.             ans = ans._fix(newcontext)</font>
<font color="black">2368. </font>
<font color="black">2369.             # raise Inexact, and if necessary, Underflow</font>
<font color="red">2370.             newcontext._raise_error(Inexact)</font>
<font color="red">2371.             if newcontext.flags[Subnormal]:</font>
<font color="red">2372.                 newcontext._raise_error(Underflow)</font>
<font color="black">2373. </font>
<font color="black">2374.             # propagate signals to the original context; _fix could</font>
<font color="black">2375.             # have raised any of Overflow, Underflow, Subnormal,</font>
<font color="black">2376.             # Inexact, Rounded, Clamped.  Overflow needs the correct</font>
<font color="black">2377.             # arguments.  Note that the order of the exceptions is</font>
<font color="black">2378.             # important here.</font>
<font color="red">2379.             if newcontext.flags[Overflow]:</font>
<font color="red">2380.                 context._raise_error(Overflow, 'above Emax', ans._sign)</font>
<font color="red">2381.             for exception in Underflow, Subnormal, Inexact, Rounded, Clamped:</font>
<font color="red">2382.                 if newcontext.flags[exception]:</font>
<font color="red">2383.                     context._raise_error(exception)</font>
<font color="black">2384. </font>
<font color="black">2385.         else:</font>
<font color="red">2386.             ans = ans._fix(context)</font>
<font color="black">2387. </font>
<font color="red">2388.         return ans</font>
<font color="black">2389. </font>
<font color="green">2390.     def __rpow__(self, other, context=None):</font>
<font color="black">2391.         &quot;&quot;&quot;Swaps self/other and returns __pow__.&quot;&quot;&quot;</font>
<font color="red">2392.         other = _convert_other(other)</font>
<font color="red">2393.         if other is NotImplemented:</font>
<font color="red">2394.             return other</font>
<font color="red">2395.         return other.__pow__(self, context=context)</font>
<font color="black">2396. </font>
<font color="green">2397.     def normalize(self, context=None):</font>
<font color="black">2398.         &quot;&quot;&quot;Normalize- strip trailing 0s, change anything equal to 0 to 0e0&quot;&quot;&quot;</font>
<font color="black">2399. </font>
<font color="red">2400.         if context is None:</font>
<font color="red">2401.             context = getcontext()</font>
<font color="black">2402. </font>
<font color="red">2403.         if self._is_special:</font>
<font color="red">2404.             ans = self._check_nans(context=context)</font>
<font color="red">2405.             if ans:</font>
<font color="red">2406.                 return ans</font>
<font color="black">2407. </font>
<font color="red">2408.         dup = self._fix(context)</font>
<font color="red">2409.         if dup._isinfinity():</font>
<font color="red">2410.             return dup</font>
<font color="black">2411. </font>
<font color="red">2412.         if not dup:</font>
<font color="red">2413.             return _dec_from_triple(dup._sign, '0', 0)</font>
<font color="red">2414.         exp_max = [context.Emax, context.Etop()][context._clamp]</font>
<font color="red">2415.         end = len(dup._int)</font>
<font color="red">2416.         exp = dup._exp</font>
<font color="red">2417.         while dup._int[end-1] == '0' and exp &lt; exp_max:</font>
<font color="red">2418.             exp += 1</font>
<font color="red">2419.             end -= 1</font>
<font color="red">2420.         return _dec_from_triple(dup._sign, dup._int[:end], exp)</font>
<font color="black">2421. </font>
<font color="green">2422.     def quantize(self, exp, rounding=None, context=None, watchexp=True):</font>
<font color="black">2423.         &quot;&quot;&quot;Quantize self so its exponent is the same as that of exp.</font>
<font color="black">2424. </font>
<font color="black">2425.         Similar to self._rescale(exp._exp) but with error checking.</font>
<font color="black">2426.         &quot;&quot;&quot;</font>
<font color="red">2427.         exp = _convert_other(exp, raiseit=True)</font>
<font color="black">2428. </font>
<font color="red">2429.         if context is None:</font>
<font color="red">2430.             context = getcontext()</font>
<font color="red">2431.         if rounding is None:</font>
<font color="red">2432.             rounding = context.rounding</font>
<font color="black">2433. </font>
<font color="red">2434.         if self._is_special or exp._is_special:</font>
<font color="red">2435.             ans = self._check_nans(exp, context)</font>
<font color="red">2436.             if ans:</font>
<font color="red">2437.                 return ans</font>
<font color="black">2438. </font>
<font color="red">2439.             if exp._isinfinity() or self._isinfinity():</font>
<font color="red">2440.                 if exp._isinfinity() and self._isinfinity():</font>
<font color="red">2441.                     return Decimal(self)  # if both are inf, it is OK</font>
<font color="red">2442.                 return context._raise_error(InvalidOperation,</font>
<font color="red">2443.                                         'quantize with one INF')</font>
<font color="black">2444. </font>
<font color="black">2445.         # if we're not watching exponents, do a simple rescale</font>
<font color="red">2446.         if not watchexp:</font>
<font color="red">2447.             ans = self._rescale(exp._exp, rounding)</font>
<font color="black">2448.             # raise Inexact and Rounded where appropriate</font>
<font color="red">2449.             if ans._exp &gt; self._exp:</font>
<font color="red">2450.                 context._raise_error(Rounded)</font>
<font color="red">2451.                 if ans != self:</font>
<font color="red">2452.                     context._raise_error(Inexact)</font>
<font color="red">2453.             return ans</font>
<font color="black">2454. </font>
<font color="black">2455.         # exp._exp should be between Etiny and Emax</font>
<font color="red">2456.         if not (context.Etiny() &lt;= exp._exp &lt;= context.Emax):</font>
<font color="red">2457.             return context._raise_error(InvalidOperation,</font>
<font color="red">2458.                    'target exponent out of bounds in quantize')</font>
<font color="black">2459. </font>
<font color="red">2460.         if not self:</font>
<font color="red">2461.             ans = _dec_from_triple(self._sign, '0', exp._exp)</font>
<font color="red">2462.             return ans._fix(context)</font>
<font color="black">2463. </font>
<font color="red">2464.         self_adjusted = self.adjusted()</font>
<font color="red">2465.         if self_adjusted &gt; context.Emax:</font>
<font color="red">2466.             return context._raise_error(InvalidOperation,</font>
<font color="red">2467.                                         'exponent of quantize result too large for current context')</font>
<font color="red">2468.         if self_adjusted - exp._exp + 1 &gt; context.prec:</font>
<font color="red">2469.             return context._raise_error(InvalidOperation,</font>
<font color="red">2470.                                         'quantize result has too many digits for current context')</font>
<font color="black">2471. </font>
<font color="red">2472.         ans = self._rescale(exp._exp, rounding)</font>
<font color="red">2473.         if ans.adjusted() &gt; context.Emax:</font>
<font color="red">2474.             return context._raise_error(InvalidOperation,</font>
<font color="red">2475.                                         'exponent of quantize result too large for current context')</font>
<font color="red">2476.         if len(ans._int) &gt; context.prec:</font>
<font color="red">2477.             return context._raise_error(InvalidOperation,</font>
<font color="red">2478.                                         'quantize result has too many digits for current context')</font>
<font color="black">2479. </font>
<font color="black">2480.         # raise appropriate flags</font>
<font color="red">2481.         if ans and ans.adjusted() &lt; context.Emin:</font>
<font color="red">2482.             context._raise_error(Subnormal)</font>
<font color="red">2483.         if ans._exp &gt; self._exp:</font>
<font color="red">2484.             if ans != self:</font>
<font color="red">2485.                 context._raise_error(Inexact)</font>
<font color="red">2486.             context._raise_error(Rounded)</font>
<font color="black">2487. </font>
<font color="black">2488.         # call to fix takes care of any necessary folddown, and</font>
<font color="black">2489.         # signals Clamped if necessary</font>
<font color="red">2490.         ans = ans._fix(context)</font>
<font color="red">2491.         return ans</font>
<font color="black">2492. </font>
<font color="green">2493.     def same_quantum(self, other):</font>
<font color="black">2494.         &quot;&quot;&quot;Return True if self and other have the same exponent; otherwise</font>
<font color="black">2495.         return False.</font>
<font color="black">2496. </font>
<font color="black">2497.         If either operand is a special value, the following rules are used:</font>
<font color="black">2498.            * return True if both operands are infinities</font>
<font color="black">2499.            * return True if both operands are NaNs</font>
<font color="black">2500.            * otherwise, return False.</font>
<font color="black">2501.         &quot;&quot;&quot;</font>
<font color="red">2502.         other = _convert_other(other, raiseit=True)</font>
<font color="red">2503.         if self._is_special or other._is_special:</font>
<font color="red">2504.             return (self.is_nan() and other.is_nan() or</font>
<font color="red">2505.                     self.is_infinite() and other.is_infinite())</font>
<font color="red">2506.         return self._exp == other._exp</font>
<font color="black">2507. </font>
<font color="green">2508.     def _rescale(self, exp, rounding):</font>
<font color="black">2509.         &quot;&quot;&quot;Rescale self so that the exponent is exp, either by padding with zeros</font>
<font color="black">2510.         or by truncating digits, using the given rounding mode.</font>
<font color="black">2511. </font>
<font color="black">2512.         Specials are returned without change.  This operation is</font>
<font color="black">2513.         quiet: it raises no flags, and uses no information from the</font>
<font color="black">2514.         context.</font>
<font color="black">2515. </font>
<font color="black">2516.         exp = exp to scale to (an integer)</font>
<font color="black">2517.         rounding = rounding mode</font>
<font color="black">2518.         &quot;&quot;&quot;</font>
<font color="red">2519.         if self._is_special:</font>
<font color="red">2520.             return Decimal(self)</font>
<font color="red">2521.         if not self:</font>
<font color="red">2522.             return _dec_from_triple(self._sign, '0', exp)</font>
<font color="black">2523. </font>
<font color="red">2524.         if self._exp &gt;= exp:</font>
<font color="black">2525.             # pad answer with zeros if necessary</font>
<font color="red">2526.             return _dec_from_triple(self._sign,</font>
<font color="red">2527.                                         self._int + '0'*(self._exp - exp), exp)</font>
<font color="black">2528. </font>
<font color="black">2529.         # too many digits; round and lose data.  If self.adjusted() &lt;</font>
<font color="black">2530.         # exp-1, replace self by 10**(exp-1) before rounding</font>
<font color="red">2531.         digits = len(self._int) + self._exp - exp</font>
<font color="red">2532.         if digits &lt; 0:</font>
<font color="red">2533.             self = _dec_from_triple(self._sign, '1', exp-1)</font>
<font color="red">2534.             digits = 0</font>
<font color="red">2535.         this_function = self._pick_rounding_function[rounding]</font>
<font color="red">2536.         changed = this_function(self, digits)</font>
<font color="red">2537.         coeff = self._int[:digits] or '0'</font>
<font color="red">2538.         if changed == 1:</font>
<font color="red">2539.             coeff = str(int(coeff)+1)</font>
<font color="red">2540.         return _dec_from_triple(self._sign, coeff, exp)</font>
<font color="black">2541. </font>
<font color="green">2542.     def _round(self, places, rounding):</font>
<font color="black">2543.         &quot;&quot;&quot;Round a nonzero, nonspecial Decimal to a fixed number of</font>
<font color="black">2544.         significant figures, using the given rounding mode.</font>
<font color="black">2545. </font>
<font color="black">2546.         Infinities, NaNs and zeros are returned unaltered.</font>
<font color="black">2547. </font>
<font color="black">2548.         This operation is quiet: it raises no flags, and uses no</font>
<font color="black">2549.         information from the context.</font>
<font color="black">2550. </font>
<font color="black">2551.         &quot;&quot;&quot;</font>
<font color="red">2552.         if places &lt;= 0:</font>
<font color="red">2553.             raise ValueError(&quot;argument should be at least 1 in _round&quot;)</font>
<font color="red">2554.         if self._is_special or not self:</font>
<font color="red">2555.             return Decimal(self)</font>
<font color="red">2556.         ans = self._rescale(self.adjusted()+1-places, rounding)</font>
<font color="black">2557.         # it can happen that the rescale alters the adjusted exponent;</font>
<font color="black">2558.         # for example when rounding 99.97 to 3 significant figures.</font>
<font color="black">2559.         # When this happens we end up with an extra 0 at the end of</font>
<font color="black">2560.         # the number; a second rescale fixes this.</font>
<font color="red">2561.         if ans.adjusted() != self.adjusted():</font>
<font color="red">2562.             ans = ans._rescale(ans.adjusted()+1-places, rounding)</font>
<font color="red">2563.         return ans</font>
<font color="black">2564. </font>
<font color="green">2565.     def to_integral_exact(self, rounding=None, context=None):</font>
<font color="black">2566.         &quot;&quot;&quot;Rounds to a nearby integer.</font>
<font color="black">2567. </font>
<font color="black">2568.         If no rounding mode is specified, take the rounding mode from</font>
<font color="black">2569.         the context.  This method raises the Rounded and Inexact flags</font>
<font color="black">2570.         when appropriate.</font>
<font color="black">2571. </font>
<font color="black">2572.         See also: to_integral_value, which does exactly the same as</font>
<font color="black">2573.         this method except that it doesn't raise Inexact or Rounded.</font>
<font color="black">2574.         &quot;&quot;&quot;</font>
<font color="red">2575.         if self._is_special:</font>
<font color="red">2576.             ans = self._check_nans(context=context)</font>
<font color="red">2577.             if ans:</font>
<font color="red">2578.                 return ans</font>
<font color="red">2579.             return Decimal(self)</font>
<font color="red">2580.         if self._exp &gt;= 0:</font>
<font color="red">2581.             return Decimal(self)</font>
<font color="red">2582.         if not self:</font>
<font color="red">2583.             return _dec_from_triple(self._sign, '0', 0)</font>
<font color="red">2584.         if context is None:</font>
<font color="red">2585.             context = getcontext()</font>
<font color="red">2586.         if rounding is None:</font>
<font color="red">2587.             rounding = context.rounding</font>
<font color="red">2588.         ans = self._rescale(0, rounding)</font>
<font color="red">2589.         if ans != self:</font>
<font color="red">2590.             context._raise_error(Inexact)</font>
<font color="red">2591.         context._raise_error(Rounded)</font>
<font color="red">2592.         return ans</font>
<font color="black">2593. </font>
<font color="green">2594.     def to_integral_value(self, rounding=None, context=None):</font>
<font color="black">2595.         &quot;&quot;&quot;Rounds to the nearest integer, without raising inexact, rounded.&quot;&quot;&quot;</font>
<font color="red">2596.         if context is None:</font>
<font color="red">2597.             context = getcontext()</font>
<font color="red">2598.         if rounding is None:</font>
<font color="red">2599.             rounding = context.rounding</font>
<font color="red">2600.         if self._is_special:</font>
<font color="red">2601.             ans = self._check_nans(context=context)</font>
<font color="red">2602.             if ans:</font>
<font color="red">2603.                 return ans</font>
<font color="red">2604.             return Decimal(self)</font>
<font color="red">2605.         if self._exp &gt;= 0:</font>
<font color="red">2606.             return Decimal(self)</font>
<font color="black">2607.         else:</font>
<font color="red">2608.             return self._rescale(0, rounding)</font>
<font color="black">2609. </font>
<font color="black">2610.     # the method name changed, but we provide also the old one, for compatibility</font>
<font color="green">2611.     to_integral = to_integral_value</font>
<font color="black">2612. </font>
<font color="green">2613.     def sqrt(self, context=None):</font>
<font color="black">2614.         &quot;&quot;&quot;Return the square root of self.&quot;&quot;&quot;</font>
<font color="red">2615.         if context is None:</font>
<font color="red">2616.             context = getcontext()</font>
<font color="black">2617. </font>
<font color="red">2618.         if self._is_special:</font>
<font color="red">2619.             ans = self._check_nans(context=context)</font>
<font color="red">2620.             if ans:</font>
<font color="red">2621.                 return ans</font>
<font color="black">2622. </font>
<font color="red">2623.             if self._isinfinity() and self._sign == 0:</font>
<font color="red">2624.                 return Decimal(self)</font>
<font color="black">2625. </font>
<font color="red">2626.         if not self:</font>
<font color="black">2627.             # exponent = self._exp // 2.  sqrt(-0) = -0</font>
<font color="red">2628.             ans = _dec_from_triple(self._sign, '0', self._exp // 2)</font>
<font color="red">2629.             return ans._fix(context)</font>
<font color="black">2630. </font>
<font color="red">2631.         if self._sign == 1:</font>
<font color="red">2632.             return context._raise_error(InvalidOperation, 'sqrt(-x), x &gt; 0')</font>
<font color="black">2633. </font>
<font color="black">2634.         # At this point self represents a positive number.  Let p be</font>
<font color="black">2635.         # the desired precision and express self in the form c*100**e</font>
<font color="black">2636.         # with c a positive real number and e an integer, c and e</font>
<font color="black">2637.         # being chosen so that 100**(p-1) &lt;= c &lt; 100**p.  Then the</font>
<font color="black">2638.         # (exact) square root of self is sqrt(c)*10**e, and 10**(p-1)</font>
<font color="black">2639.         # &lt;= sqrt(c) &lt; 10**p, so the closest representable Decimal at</font>
<font color="black">2640.         # precision p is n*10**e where n = round_half_even(sqrt(c)),</font>
<font color="black">2641.         # the closest integer to sqrt(c) with the even integer chosen</font>
<font color="black">2642.         # in the case of a tie.</font>
<font color="black">2643.         #</font>
<font color="black">2644.         # To ensure correct rounding in all cases, we use the</font>
<font color="black">2645.         # following trick: we compute the square root to an extra</font>
<font color="black">2646.         # place (precision p+1 instead of precision p), rounding down.</font>
<font color="black">2647.         # Then, if the result is inexact and its last digit is 0 or 5,</font>
<font color="black">2648.         # we increase the last digit to 1 or 6 respectively; if it's</font>
<font color="black">2649.         # exact we leave the last digit alone.  Now the final round to</font>
<font color="black">2650.         # p places (or fewer in the case of underflow) will round</font>
<font color="black">2651.         # correctly and raise the appropriate flags.</font>
<font color="black">2652. </font>
<font color="black">2653.         # use an extra digit of precision</font>
<font color="red">2654.         prec = context.prec+1</font>
<font color="black">2655. </font>
<font color="black">2656.         # write argument in the form c*100**e where e = self._exp//2</font>
<font color="black">2657.         # is the 'ideal' exponent, to be used if the square root is</font>
<font color="black">2658.         # exactly representable.  l is the number of 'digits' of c in</font>
<font color="black">2659.         # base 100, so that 100**(l-1) &lt;= c &lt; 100**l.</font>
<font color="red">2660.         op = _WorkRep(self)</font>
<font color="red">2661.         e = op.exp &gt;&gt; 1</font>
<font color="red">2662.         if op.exp &amp; 1:</font>
<font color="red">2663.             c = op.int * 10</font>
<font color="red">2664.             l = (len(self._int) &gt;&gt; 1) + 1</font>
<font color="black">2665.         else:</font>
<font color="red">2666.             c = op.int</font>
<font color="red">2667.             l = len(self._int)+1 &gt;&gt; 1</font>
<font color="black">2668. </font>
<font color="black">2669.         # rescale so that c has exactly prec base 100 'digits'</font>
<font color="red">2670.         shift = prec-l</font>
<font color="red">2671.         if shift &gt;= 0:</font>
<font color="red">2672.             c *= 100**shift</font>
<font color="red">2673.             exact = True</font>
<font color="black">2674.         else:</font>
<font color="red">2675.             c, remainder = divmod(c, 100**-shift)</font>
<font color="red">2676.             exact = not remainder</font>
<font color="red">2677.         e -= shift</font>
<font color="black">2678. </font>
<font color="black">2679.         # find n = floor(sqrt(c)) using Newton's method</font>
<font color="red">2680.         n = 10**prec</font>
<font color="red">2681.         while True:</font>
<font color="red">2682.             q = c//n</font>
<font color="red">2683.             if n &lt;= q:</font>
<font color="red">2684.                 break</font>
<font color="black">2685.             else:</font>
<font color="red">2686.                 n = n + q &gt;&gt; 1</font>
<font color="red">2687.         exact = exact and n*n == c</font>
<font color="black">2688. </font>
<font color="red">2689.         if exact:</font>
<font color="black">2690.             # result is exact; rescale to use ideal exponent e</font>
<font color="red">2691.             if shift &gt;= 0:</font>
<font color="black">2692.                 # assert n % 10**shift == 0</font>
<font color="red">2693.                 n //= 10**shift</font>
<font color="black">2694.             else:</font>
<font color="red">2695.                 n *= 10**-shift</font>
<font color="red">2696.             e += shift</font>
<font color="black">2697.         else:</font>
<font color="black">2698.             # result is not exact; fix last digit as described above</font>
<font color="red">2699.             if n % 5 == 0:</font>
<font color="red">2700.                 n += 1</font>
<font color="black">2701. </font>
<font color="red">2702.         ans = _dec_from_triple(0, str(n), e)</font>
<font color="black">2703. </font>
<font color="black">2704.         # round, and fit to current context</font>
<font color="red">2705.         context = context._shallow_copy()</font>
<font color="red">2706.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">2707.         ans = ans._fix(context)</font>
<font color="red">2708.         context.rounding = rounding</font>
<font color="black">2709. </font>
<font color="red">2710.         return ans</font>
<font color="black">2711. </font>
<font color="green">2712.     def max(self, other, context=None):</font>
<font color="black">2713.         &quot;&quot;&quot;Returns the larger value.</font>
<font color="black">2714. </font>
<font color="black">2715.         Like max(self, other) except if one is not a number, returns</font>
<font color="black">2716.         NaN (and signals if one is sNaN).  Also rounds.</font>
<font color="black">2717.         &quot;&quot;&quot;</font>
<font color="red">2718.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2719. </font>
<font color="red">2720.         if context is None:</font>
<font color="red">2721.             context = getcontext()</font>
<font color="black">2722. </font>
<font color="red">2723.         if self._is_special or other._is_special:</font>
<font color="black">2724.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">2725.             # number is always returned</font>
<font color="red">2726.             sn = self._isnan()</font>
<font color="red">2727.             on = other._isnan()</font>
<font color="red">2728.             if sn or on:</font>
<font color="red">2729.                 if on == 1 and sn == 0:</font>
<font color="red">2730.                     return self._fix(context)</font>
<font color="red">2731.                 if sn == 1 and on == 0:</font>
<font color="red">2732.                     return other._fix(context)</font>
<font color="red">2733.                 return self._check_nans(other, context)</font>
<font color="black">2734. </font>
<font color="red">2735.         c = self._cmp(other)</font>
<font color="red">2736.         if c == 0:</font>
<font color="black">2737.             # If both operands are finite and equal in numerical value</font>
<font color="black">2738.             # then an ordering is applied:</font>
<font color="black">2739.             #</font>
<font color="black">2740.             # If the signs differ then max returns the operand with the</font>
<font color="black">2741.             # positive sign and min returns the operand with the negative sign</font>
<font color="black">2742.             #</font>
<font color="black">2743.             # If the signs are the same then the exponent is used to select</font>
<font color="black">2744.             # the result.  This is exactly the ordering used in compare_total.</font>
<font color="red">2745.             c = self.compare_total(other)</font>
<font color="black">2746. </font>
<font color="red">2747.         if c == -1:</font>
<font color="red">2748.             ans = other</font>
<font color="black">2749.         else:</font>
<font color="red">2750.             ans = self</font>
<font color="black">2751. </font>
<font color="red">2752.         return ans._fix(context)</font>
<font color="black">2753. </font>
<font color="green">2754.     def min(self, other, context=None):</font>
<font color="black">2755.         &quot;&quot;&quot;Returns the smaller value.</font>
<font color="black">2756. </font>
<font color="black">2757.         Like min(self, other) except if one is not a number, returns</font>
<font color="black">2758.         NaN (and signals if one is sNaN).  Also rounds.</font>
<font color="black">2759.         &quot;&quot;&quot;</font>
<font color="red">2760.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2761. </font>
<font color="red">2762.         if context is None:</font>
<font color="red">2763.             context = getcontext()</font>
<font color="black">2764. </font>
<font color="red">2765.         if self._is_special or other._is_special:</font>
<font color="black">2766.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">2767.             # number is always returned</font>
<font color="red">2768.             sn = self._isnan()</font>
<font color="red">2769.             on = other._isnan()</font>
<font color="red">2770.             if sn or on:</font>
<font color="red">2771.                 if on == 1 and sn == 0:</font>
<font color="red">2772.                     return self._fix(context)</font>
<font color="red">2773.                 if sn == 1 and on == 0:</font>
<font color="red">2774.                     return other._fix(context)</font>
<font color="red">2775.                 return self._check_nans(other, context)</font>
<font color="black">2776. </font>
<font color="red">2777.         c = self._cmp(other)</font>
<font color="red">2778.         if c == 0:</font>
<font color="red">2779.             c = self.compare_total(other)</font>
<font color="black">2780. </font>
<font color="red">2781.         if c == -1:</font>
<font color="red">2782.             ans = self</font>
<font color="black">2783.         else:</font>
<font color="red">2784.             ans = other</font>
<font color="black">2785. </font>
<font color="red">2786.         return ans._fix(context)</font>
<font color="black">2787. </font>
<font color="green">2788.     def _isinteger(self):</font>
<font color="black">2789.         &quot;&quot;&quot;Returns whether self is an integer&quot;&quot;&quot;</font>
<font color="red">2790.         if self._is_special:</font>
<font color="red">2791.             return False</font>
<font color="red">2792.         if self._exp &gt;= 0:</font>
<font color="red">2793.             return True</font>
<font color="red">2794.         rest = self._int[self._exp:]</font>
<font color="red">2795.         return rest == '0'*len(rest)</font>
<font color="black">2796. </font>
<font color="green">2797.     def _iseven(self):</font>
<font color="black">2798.         &quot;&quot;&quot;Returns True if self is even.  Assumes self is an integer.&quot;&quot;&quot;</font>
<font color="red">2799.         if not self or self._exp &gt; 0:</font>
<font color="red">2800.             return True</font>
<font color="red">2801.         return self._int[-1+self._exp] in '02468'</font>
<font color="black">2802. </font>
<font color="green">2803.     def adjusted(self):</font>
<font color="black">2804.         &quot;&quot;&quot;Return the adjusted exponent of self&quot;&quot;&quot;</font>
<font color="red">2805.         try:</font>
<font color="red">2806.             return self._exp + len(self._int) - 1</font>
<font color="black">2807.         # If NaN or Infinity, self._exp is string</font>
<font color="red">2808.         except TypeError:</font>
<font color="red">2809.             return 0</font>
<font color="black">2810. </font>
<font color="green">2811.     def canonical(self, context=None):</font>
<font color="black">2812.         &quot;&quot;&quot;Returns the same Decimal object.</font>
<font color="black">2813. </font>
<font color="black">2814.         As we do not have different encodings for the same number, the</font>
<font color="black">2815.         received object already is in its canonical form.</font>
<font color="black">2816.         &quot;&quot;&quot;</font>
<font color="red">2817.         return self</font>
<font color="black">2818. </font>
<font color="green">2819.     def compare_signal(self, other, context=None):</font>
<font color="black">2820.         &quot;&quot;&quot;Compares self to the other operand numerically.</font>
<font color="black">2821. </font>
<font color="black">2822.         It's pretty much like compare(), but all NaNs signal, with signaling</font>
<font color="black">2823.         NaNs taking precedence over quiet NaNs.</font>
<font color="black">2824.         &quot;&quot;&quot;</font>
<font color="red">2825.         other = _convert_other(other, raiseit = True)</font>
<font color="red">2826.         ans = self._compare_check_nans(other, context)</font>
<font color="red">2827.         if ans:</font>
<font color="red">2828.             return ans</font>
<font color="red">2829.         return self.compare(other, context=context)</font>
<font color="black">2830. </font>
<font color="green">2831.     def compare_total(self, other):</font>
<font color="black">2832.         &quot;&quot;&quot;Compares self to other using the abstract representations.</font>
<font color="black">2833. </font>
<font color="black">2834.         This is not like the standard compare, which use their numerical</font>
<font color="black">2835.         value. Note that a total ordering is defined for all possible abstract</font>
<font color="black">2836.         representations.</font>
<font color="black">2837.         &quot;&quot;&quot;</font>
<font color="red">2838.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2839. </font>
<font color="black">2840.         # if one is negative and the other is positive, it's easy</font>
<font color="red">2841.         if self._sign and not other._sign:</font>
<font color="red">2842.             return _NegativeOne</font>
<font color="red">2843.         if not self._sign and other._sign:</font>
<font color="red">2844.             return _One</font>
<font color="red">2845.         sign = self._sign</font>
<font color="black">2846. </font>
<font color="black">2847.         # let's handle both NaN types</font>
<font color="red">2848.         self_nan = self._isnan()</font>
<font color="red">2849.         other_nan = other._isnan()</font>
<font color="red">2850.         if self_nan or other_nan:</font>
<font color="red">2851.             if self_nan == other_nan:</font>
<font color="black">2852.                 # compare payloads as though they're integers</font>
<font color="red">2853.                 self_key = len(self._int), self._int</font>
<font color="red">2854.                 other_key = len(other._int), other._int</font>
<font color="red">2855.                 if self_key &lt; other_key:</font>
<font color="red">2856.                     if sign:</font>
<font color="red">2857.                         return _One</font>
<font color="black">2858.                     else:</font>
<font color="red">2859.                         return _NegativeOne</font>
<font color="red">2860.                 if self_key &gt; other_key:</font>
<font color="red">2861.                     if sign:</font>
<font color="red">2862.                         return _NegativeOne</font>
<font color="black">2863.                     else:</font>
<font color="red">2864.                         return _One</font>
<font color="red">2865.                 return _Zero</font>
<font color="black">2866. </font>
<font color="red">2867.             if sign:</font>
<font color="red">2868.                 if self_nan == 1:</font>
<font color="red">2869.                     return _NegativeOne</font>
<font color="red">2870.                 if other_nan == 1:</font>
<font color="red">2871.                     return _One</font>
<font color="red">2872.                 if self_nan == 2:</font>
<font color="red">2873.                     return _NegativeOne</font>
<font color="red">2874.                 if other_nan == 2:</font>
<font color="red">2875.                     return _One</font>
<font color="black">2876.             else:</font>
<font color="red">2877.                 if self_nan == 1:</font>
<font color="red">2878.                     return _One</font>
<font color="red">2879.                 if other_nan == 1:</font>
<font color="red">2880.                     return _NegativeOne</font>
<font color="red">2881.                 if self_nan == 2:</font>
<font color="red">2882.                     return _One</font>
<font color="red">2883.                 if other_nan == 2:</font>
<font color="red">2884.                     return _NegativeOne</font>
<font color="black">2885. </font>
<font color="red">2886.         if self &lt; other:</font>
<font color="red">2887.             return _NegativeOne</font>
<font color="red">2888.         if self &gt; other:</font>
<font color="red">2889.             return _One</font>
<font color="black">2890. </font>
<font color="red">2891.         if self._exp &lt; other._exp:</font>
<font color="red">2892.             if sign:</font>
<font color="red">2893.                 return _One</font>
<font color="black">2894.             else:</font>
<font color="red">2895.                 return _NegativeOne</font>
<font color="red">2896.         if self._exp &gt; other._exp:</font>
<font color="red">2897.             if sign:</font>
<font color="red">2898.                 return _NegativeOne</font>
<font color="black">2899.             else:</font>
<font color="red">2900.                 return _One</font>
<font color="red">2901.         return _Zero</font>
<font color="black">2902. </font>
<font color="black">2903. </font>
<font color="green">2904.     def compare_total_mag(self, other):</font>
<font color="black">2905.         &quot;&quot;&quot;Compares self to other using abstract repr., ignoring sign.</font>
<font color="black">2906. </font>
<font color="black">2907.         Like compare_total, but with operand's sign ignored and assumed to be 0.</font>
<font color="black">2908.         &quot;&quot;&quot;</font>
<font color="red">2909.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2910. </font>
<font color="red">2911.         s = self.copy_abs()</font>
<font color="red">2912.         o = other.copy_abs()</font>
<font color="red">2913.         return s.compare_total(o)</font>
<font color="black">2914. </font>
<font color="green">2915.     def copy_abs(self):</font>
<font color="black">2916.         &quot;&quot;&quot;Returns a copy with the sign set to 0. &quot;&quot;&quot;</font>
<font color="red">2917.         return _dec_from_triple(0, self._int, self._exp, self._is_special)</font>
<font color="black">2918. </font>
<font color="green">2919.     def copy_negate(self):</font>
<font color="black">2920.         &quot;&quot;&quot;Returns a copy with the sign inverted.&quot;&quot;&quot;</font>
<font color="red">2921.         if self._sign:</font>
<font color="red">2922.             return _dec_from_triple(0, self._int, self._exp, self._is_special)</font>
<font color="black">2923.         else:</font>
<font color="red">2924.             return _dec_from_triple(1, self._int, self._exp, self._is_special)</font>
<font color="black">2925. </font>
<font color="green">2926.     def copy_sign(self, other):</font>
<font color="black">2927.         &quot;&quot;&quot;Returns self with the sign of other.&quot;&quot;&quot;</font>
<font color="red">2928.         other = _convert_other(other, raiseit=True)</font>
<font color="red">2929.         return _dec_from_triple(other._sign, self._int,</font>
<font color="red">2930.                                 self._exp, self._is_special)</font>
<font color="black">2931. </font>
<font color="green">2932.     def exp(self, context=None):</font>
<font color="black">2933.         &quot;&quot;&quot;Returns e ** self.&quot;&quot;&quot;</font>
<font color="black">2934. </font>
<font color="red">2935.         if context is None:</font>
<font color="red">2936.             context = getcontext()</font>
<font color="black">2937. </font>
<font color="black">2938.         # exp(NaN) = NaN</font>
<font color="red">2939.         ans = self._check_nans(context=context)</font>
<font color="red">2940.         if ans:</font>
<font color="red">2941.             return ans</font>
<font color="black">2942. </font>
<font color="black">2943.         # exp(-Infinity) = 0</font>
<font color="red">2944.         if self._isinfinity() == -1:</font>
<font color="red">2945.             return _Zero</font>
<font color="black">2946. </font>
<font color="black">2947.         # exp(0) = 1</font>
<font color="red">2948.         if not self:</font>
<font color="red">2949.             return _One</font>
<font color="black">2950. </font>
<font color="black">2951.         # exp(Infinity) = Infinity</font>
<font color="red">2952.         if self._isinfinity() == 1:</font>
<font color="red">2953.             return Decimal(self)</font>
<font color="black">2954. </font>
<font color="black">2955.         # the result is now guaranteed to be inexact (the true</font>
<font color="black">2956.         # mathematical result is transcendental). There's no need to</font>
<font color="black">2957.         # raise Rounded and Inexact here---they'll always be raised as</font>
<font color="black">2958.         # a result of the call to _fix.</font>
<font color="red">2959.         p = context.prec</font>
<font color="red">2960.         adj = self.adjusted()</font>
<font color="black">2961. </font>
<font color="black">2962.         # we only need to do any computation for quite a small range</font>
<font color="black">2963.         # of adjusted exponents---for example, -29 &lt;= adj &lt;= 10 for</font>
<font color="black">2964.         # the default context.  For smaller exponent the result is</font>
<font color="black">2965.         # indistinguishable from 1 at the given precision, while for</font>
<font color="black">2966.         # larger exponent the result either overflows or underflows.</font>
<font color="red">2967.         if self._sign == 0 and adj &gt; len(str((context.Emax+1)*3)):</font>
<font color="black">2968.             # overflow</font>
<font color="red">2969.             ans = _dec_from_triple(0, '1', context.Emax+1)</font>
<font color="red">2970.         elif self._sign == 1 and adj &gt; len(str((-context.Etiny()+1)*3)):</font>
<font color="black">2971.             # underflow to 0</font>
<font color="red">2972.             ans = _dec_from_triple(0, '1', context.Etiny()-1)</font>
<font color="red">2973.         elif self._sign == 0 and adj &lt; -p:</font>
<font color="black">2974.             # p+1 digits; final round will raise correct flags</font>
<font color="red">2975.             ans = _dec_from_triple(0, '1' + '0'*(p-1) + '1', -p)</font>
<font color="red">2976.         elif self._sign == 1 and adj &lt; -p-1:</font>
<font color="black">2977.             # p+1 digits; final round will raise correct flags</font>
<font color="red">2978.             ans = _dec_from_triple(0, '9'*(p+1), -p-1)</font>
<font color="black">2979.         # general case</font>
<font color="black">2980.         else:</font>
<font color="red">2981.             op = _WorkRep(self)</font>
<font color="red">2982.             c, e = op.int, op.exp</font>
<font color="red">2983.             if op.sign == 1:</font>
<font color="red">2984.                 c = -c</font>
<font color="black">2985. </font>
<font color="black">2986.             # compute correctly rounded result: increase precision by</font>
<font color="black">2987.             # 3 digits at a time until we get an unambiguously</font>
<font color="black">2988.             # roundable result</font>
<font color="red">2989.             extra = 3</font>
<font color="red">2990.             while True:</font>
<font color="red">2991.                 coeff, exp = _dexp(c, e, p+extra)</font>
<font color="red">2992.                 if coeff % (5*10**(len(str(coeff))-p-1)):</font>
<font color="red">2993.                     break</font>
<font color="red">2994.                 extra += 3</font>
<font color="black">2995. </font>
<font color="red">2996.             ans = _dec_from_triple(0, str(coeff), exp)</font>
<font color="black">2997. </font>
<font color="black">2998.         # at this stage, ans should round correctly with *any*</font>
<font color="black">2999.         # rounding mode, not just with ROUND_HALF_EVEN</font>
<font color="red">3000.         context = context._shallow_copy()</font>
<font color="red">3001.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">3002.         ans = ans._fix(context)</font>
<font color="red">3003.         context.rounding = rounding</font>
<font color="black">3004. </font>
<font color="red">3005.         return ans</font>
<font color="black">3006. </font>
<font color="green">3007.     def is_canonical(self):</font>
<font color="black">3008.         &quot;&quot;&quot;Return True if self is canonical; otherwise return False.</font>
<font color="black">3009. </font>
<font color="black">3010.         Currently, the encoding of a Decimal instance is always</font>
<font color="black">3011.         canonical, so this method returns True for any Decimal.</font>
<font color="black">3012.         &quot;&quot;&quot;</font>
<font color="red">3013.         return True</font>
<font color="black">3014. </font>
<font color="green">3015.     def is_finite(self):</font>
<font color="black">3016.         &quot;&quot;&quot;Return True if self is finite; otherwise return False.</font>
<font color="black">3017. </font>
<font color="black">3018.         A Decimal instance is considered finite if it is neither</font>
<font color="black">3019.         infinite nor a NaN.</font>
<font color="black">3020.         &quot;&quot;&quot;</font>
<font color="red">3021.         return not self._is_special</font>
<font color="black">3022. </font>
<font color="green">3023.     def is_infinite(self):</font>
<font color="black">3024.         &quot;&quot;&quot;Return True if self is infinite; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3025.         return self._exp == 'F'</font>
<font color="black">3026. </font>
<font color="green">3027.     def is_nan(self):</font>
<font color="black">3028.         &quot;&quot;&quot;Return True if self is a qNaN or sNaN; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3029.         return self._exp in ('n', 'N')</font>
<font color="black">3030. </font>
<font color="green">3031.     def is_normal(self, context=None):</font>
<font color="black">3032.         &quot;&quot;&quot;Return True if self is a normal number; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3033.         if self._is_special or not self:</font>
<font color="red">3034.             return False</font>
<font color="red">3035.         if context is None:</font>
<font color="red">3036.             context = getcontext()</font>
<font color="red">3037.         return context.Emin &lt;= self.adjusted()</font>
<font color="black">3038. </font>
<font color="green">3039.     def is_qnan(self):</font>
<font color="black">3040.         &quot;&quot;&quot;Return True if self is a quiet NaN; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3041.         return self._exp == 'n'</font>
<font color="black">3042. </font>
<font color="green">3043.     def is_signed(self):</font>
<font color="black">3044.         &quot;&quot;&quot;Return True if self is negative; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3045.         return self._sign == 1</font>
<font color="black">3046. </font>
<font color="green">3047.     def is_snan(self):</font>
<font color="black">3048.         &quot;&quot;&quot;Return True if self is a signaling NaN; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3049.         return self._exp == 'N'</font>
<font color="black">3050. </font>
<font color="green">3051.     def is_subnormal(self, context=None):</font>
<font color="black">3052.         &quot;&quot;&quot;Return True if self is subnormal; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3053.         if self._is_special or not self:</font>
<font color="red">3054.             return False</font>
<font color="red">3055.         if context is None:</font>
<font color="red">3056.             context = getcontext()</font>
<font color="red">3057.         return self.adjusted() &lt; context.Emin</font>
<font color="black">3058. </font>
<font color="green">3059.     def is_zero(self):</font>
<font color="black">3060.         &quot;&quot;&quot;Return True if self is a zero; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3061.         return not self._is_special and self._int == '0'</font>
<font color="black">3062. </font>
<font color="green">3063.     def _ln_exp_bound(self):</font>
<font color="black">3064.         &quot;&quot;&quot;Compute a lower bound for the adjusted exponent of self.ln().</font>
<font color="black">3065.         In other words, compute r such that self.ln() &gt;= 10**r.  Assumes</font>
<font color="black">3066.         that self is finite and positive and that self != 1.</font>
<font color="black">3067.         &quot;&quot;&quot;</font>
<font color="black">3068. </font>
<font color="black">3069.         # for 0.1 &lt;= x &lt;= 10 we use the inequalities 1-1/x &lt;= ln(x) &lt;= x-1</font>
<font color="red">3070.         adj = self._exp + len(self._int) - 1</font>
<font color="red">3071.         if adj &gt;= 1:</font>
<font color="black">3072.             # argument &gt;= 10; we use 23/10 = 2.3 as a lower bound for ln(10)</font>
<font color="red">3073.             return len(str(adj*23//10)) - 1</font>
<font color="red">3074.         if adj &lt;= -2:</font>
<font color="black">3075.             # argument &lt;= 0.1</font>
<font color="red">3076.             return len(str((-1-adj)*23//10)) - 1</font>
<font color="red">3077.         op = _WorkRep(self)</font>
<font color="red">3078.         c, e = op.int, op.exp</font>
<font color="red">3079.         if adj == 0:</font>
<font color="black">3080.             # 1 &lt; self &lt; 10</font>
<font color="red">3081.             num = str(c-10**-e)</font>
<font color="red">3082.             den = str(c)</font>
<font color="red">3083.             return len(num) - len(den) - (num &lt; den)</font>
<font color="black">3084.         # adj == -1, 0.1 &lt;= self &lt; 1</font>
<font color="red">3085.         return e + len(str(10**-e - c)) - 1</font>
<font color="black">3086. </font>
<font color="black">3087. </font>
<font color="green">3088.     def ln(self, context=None):</font>
<font color="black">3089.         &quot;&quot;&quot;Returns the natural (base e) logarithm of self.&quot;&quot;&quot;</font>
<font color="black">3090. </font>
<font color="red">3091.         if context is None:</font>
<font color="red">3092.             context = getcontext()</font>
<font color="black">3093. </font>
<font color="black">3094.         # ln(NaN) = NaN</font>
<font color="red">3095.         ans = self._check_nans(context=context)</font>
<font color="red">3096.         if ans:</font>
<font color="red">3097.             return ans</font>
<font color="black">3098. </font>
<font color="black">3099.         # ln(0.0) == -Infinity</font>
<font color="red">3100.         if not self:</font>
<font color="red">3101.             return _NegativeInfinity</font>
<font color="black">3102. </font>
<font color="black">3103.         # ln(Infinity) = Infinity</font>
<font color="red">3104.         if self._isinfinity() == 1:</font>
<font color="red">3105.             return _Infinity</font>
<font color="black">3106. </font>
<font color="black">3107.         # ln(1.0) == 0.0</font>
<font color="red">3108.         if self == _One:</font>
<font color="red">3109.             return _Zero</font>
<font color="black">3110. </font>
<font color="black">3111.         # ln(negative) raises InvalidOperation</font>
<font color="red">3112.         if self._sign == 1:</font>
<font color="red">3113.             return context._raise_error(InvalidOperation,</font>
<font color="red">3114.                                         'ln of a negative value')</font>
<font color="black">3115. </font>
<font color="black">3116.         # result is irrational, so necessarily inexact</font>
<font color="red">3117.         op = _WorkRep(self)</font>
<font color="red">3118.         c, e = op.int, op.exp</font>
<font color="red">3119.         p = context.prec</font>
<font color="black">3120. </font>
<font color="black">3121.         # correctly rounded result: repeatedly increase precision by 3</font>
<font color="black">3122.         # until we get an unambiguously roundable result</font>
<font color="red">3123.         places = p - self._ln_exp_bound() + 2 # at least p+3 places</font>
<font color="red">3124.         while True:</font>
<font color="red">3125.             coeff = _dlog(c, e, places)</font>
<font color="black">3126.             # assert len(str(abs(coeff)))-p &gt;= 1</font>
<font color="red">3127.             if coeff % (5*10**(len(str(abs(coeff)))-p-1)):</font>
<font color="red">3128.                 break</font>
<font color="red">3129.             places += 3</font>
<font color="red">3130.         ans = _dec_from_triple(int(coeff&lt;0), str(abs(coeff)), -places)</font>
<font color="black">3131. </font>
<font color="red">3132.         context = context._shallow_copy()</font>
<font color="red">3133.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">3134.         ans = ans._fix(context)</font>
<font color="red">3135.         context.rounding = rounding</font>
<font color="red">3136.         return ans</font>
<font color="black">3137. </font>
<font color="green">3138.     def _log10_exp_bound(self):</font>
<font color="black">3139.         &quot;&quot;&quot;Compute a lower bound for the adjusted exponent of self.log10().</font>
<font color="black">3140.         In other words, find r such that self.log10() &gt;= 10**r.</font>
<font color="black">3141.         Assumes that self is finite and positive and that self != 1.</font>
<font color="black">3142.         &quot;&quot;&quot;</font>
<font color="black">3143. </font>
<font color="black">3144.         # For x &gt;= 10 or x &lt; 0.1 we only need a bound on the integer</font>
<font color="black">3145.         # part of log10(self), and this comes directly from the</font>
<font color="black">3146.         # exponent of x.  For 0.1 &lt;= x &lt;= 10 we use the inequalities</font>
<font color="black">3147.         # 1-1/x &lt;= log(x) &lt;= x-1. If x &gt; 1 we have |log10(x)| &gt;</font>
<font color="black">3148.         # (1-1/x)/2.31 &gt; 0.  If x &lt; 1 then |log10(x)| &gt; (1-x)/2.31 &gt; 0</font>
<font color="black">3149. </font>
<font color="red">3150.         adj = self._exp + len(self._int) - 1</font>
<font color="red">3151.         if adj &gt;= 1:</font>
<font color="black">3152.             # self &gt;= 10</font>
<font color="red">3153.             return len(str(adj))-1</font>
<font color="red">3154.         if adj &lt;= -2:</font>
<font color="black">3155.             # self &lt; 0.1</font>
<font color="red">3156.             return len(str(-1-adj))-1</font>
<font color="red">3157.         op = _WorkRep(self)</font>
<font color="red">3158.         c, e = op.int, op.exp</font>
<font color="red">3159.         if adj == 0:</font>
<font color="black">3160.             # 1 &lt; self &lt; 10</font>
<font color="red">3161.             num = str(c-10**-e)</font>
<font color="red">3162.             den = str(231*c)</font>
<font color="red">3163.             return len(num) - len(den) - (num &lt; den) + 2</font>
<font color="black">3164.         # adj == -1, 0.1 &lt;= self &lt; 1</font>
<font color="red">3165.         num = str(10**-e-c)</font>
<font color="red">3166.         return len(num) + e - (num &lt; &quot;231&quot;) - 1</font>
<font color="black">3167. </font>
<font color="green">3168.     def log10(self, context=None):</font>
<font color="black">3169.         &quot;&quot;&quot;Returns the base 10 logarithm of self.&quot;&quot;&quot;</font>
<font color="black">3170. </font>
<font color="red">3171.         if context is None:</font>
<font color="red">3172.             context = getcontext()</font>
<font color="black">3173. </font>
<font color="black">3174.         # log10(NaN) = NaN</font>
<font color="red">3175.         ans = self._check_nans(context=context)</font>
<font color="red">3176.         if ans:</font>
<font color="red">3177.             return ans</font>
<font color="black">3178. </font>
<font color="black">3179.         # log10(0.0) == -Infinity</font>
<font color="red">3180.         if not self:</font>
<font color="red">3181.             return _NegativeInfinity</font>
<font color="black">3182. </font>
<font color="black">3183.         # log10(Infinity) = Infinity</font>
<font color="red">3184.         if self._isinfinity() == 1:</font>
<font color="red">3185.             return _Infinity</font>
<font color="black">3186. </font>
<font color="black">3187.         # log10(negative or -Infinity) raises InvalidOperation</font>
<font color="red">3188.         if self._sign == 1:</font>
<font color="red">3189.             return context._raise_error(InvalidOperation,</font>
<font color="red">3190.                                         'log10 of a negative value')</font>
<font color="black">3191. </font>
<font color="black">3192.         # log10(10**n) = n</font>
<font color="red">3193.         if self._int[0] == '1' and self._int[1:] == '0'*(len(self._int) - 1):</font>
<font color="black">3194.             # answer may need rounding</font>
<font color="red">3195.             ans = Decimal(self._exp + len(self._int) - 1)</font>
<font color="black">3196.         else:</font>
<font color="black">3197.             # result is irrational, so necessarily inexact</font>
<font color="red">3198.             op = _WorkRep(self)</font>
<font color="red">3199.             c, e = op.int, op.exp</font>
<font color="red">3200.             p = context.prec</font>
<font color="black">3201. </font>
<font color="black">3202.             # correctly rounded result: repeatedly increase precision</font>
<font color="black">3203.             # until result is unambiguously roundable</font>
<font color="red">3204.             places = p-self._log10_exp_bound()+2</font>
<font color="red">3205.             while True:</font>
<font color="red">3206.                 coeff = _dlog10(c, e, places)</font>
<font color="black">3207.                 # assert len(str(abs(coeff)))-p &gt;= 1</font>
<font color="red">3208.                 if coeff % (5*10**(len(str(abs(coeff)))-p-1)):</font>
<font color="red">3209.                     break</font>
<font color="red">3210.                 places += 3</font>
<font color="red">3211.             ans = _dec_from_triple(int(coeff&lt;0), str(abs(coeff)), -places)</font>
<font color="black">3212. </font>
<font color="red">3213.         context = context._shallow_copy()</font>
<font color="red">3214.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">3215.         ans = ans._fix(context)</font>
<font color="red">3216.         context.rounding = rounding</font>
<font color="red">3217.         return ans</font>
<font color="black">3218. </font>
<font color="green">3219.     def logb(self, context=None):</font>
<font color="black">3220.         &quot;&quot;&quot; Returns the exponent of the magnitude of self's MSD.</font>
<font color="black">3221. </font>
<font color="black">3222.         The result is the integer which is the exponent of the magnitude</font>
<font color="black">3223.         of the most significant digit of self (as though it were truncated</font>
<font color="black">3224.         to a single digit while maintaining the value of that digit and</font>
<font color="black">3225.         without limiting the resulting exponent).</font>
<font color="black">3226.         &quot;&quot;&quot;</font>
<font color="black">3227.         # logb(NaN) = NaN</font>
<font color="red">3228.         ans = self._check_nans(context=context)</font>
<font color="red">3229.         if ans:</font>
<font color="red">3230.             return ans</font>
<font color="black">3231. </font>
<font color="red">3232.         if context is None:</font>
<font color="red">3233.             context = getcontext()</font>
<font color="black">3234. </font>
<font color="black">3235.         # logb(+/-Inf) = +Inf</font>
<font color="red">3236.         if self._isinfinity():</font>
<font color="red">3237.             return _Infinity</font>
<font color="black">3238. </font>
<font color="black">3239.         # logb(0) = -Inf, DivisionByZero</font>
<font color="red">3240.         if not self:</font>
<font color="red">3241.             return context._raise_error(DivisionByZero, 'logb(0)', 1)</font>
<font color="black">3242. </font>
<font color="black">3243.         # otherwise, simply return the adjusted exponent of self, as a</font>
<font color="black">3244.         # Decimal.  Note that no attempt is made to fit the result</font>
<font color="black">3245.         # into the current context.</font>
<font color="red">3246.         ans = Decimal(self.adjusted())</font>
<font color="red">3247.         return ans._fix(context)</font>
<font color="black">3248. </font>
<font color="green">3249.     def _islogical(self):</font>
<font color="black">3250.         &quot;&quot;&quot;Return True if self is a logical operand.</font>
<font color="black">3251. </font>
<font color="black">3252.         For being logical, it must be a finite number with a sign of 0,</font>
<font color="black">3253.         an exponent of 0, and a coefficient whose digits must all be</font>
<font color="black">3254.         either 0 or 1.</font>
<font color="black">3255.         &quot;&quot;&quot;</font>
<font color="red">3256.         if self._sign != 0 or self._exp != 0:</font>
<font color="red">3257.             return False</font>
<font color="red">3258.         for dig in self._int:</font>
<font color="red">3259.             if dig not in '01':</font>
<font color="red">3260.                 return False</font>
<font color="red">3261.         return True</font>
<font color="black">3262. </font>
<font color="green">3263.     def _fill_logical(self, context, opa, opb):</font>
<font color="red">3264.         dif = context.prec - len(opa)</font>
<font color="red">3265.         if dif &gt; 0:</font>
<font color="red">3266.             opa = '0'*dif + opa</font>
<font color="red">3267.         elif dif &lt; 0:</font>
<font color="red">3268.             opa = opa[-context.prec:]</font>
<font color="red">3269.         dif = context.prec - len(opb)</font>
<font color="red">3270.         if dif &gt; 0:</font>
<font color="red">3271.             opb = '0'*dif + opb</font>
<font color="red">3272.         elif dif &lt; 0:</font>
<font color="red">3273.             opb = opb[-context.prec:]</font>
<font color="red">3274.         return opa, opb</font>
<font color="black">3275. </font>
<font color="green">3276.     def logical_and(self, other, context=None):</font>
<font color="black">3277.         &quot;&quot;&quot;Applies an 'and' operation between self and other's digits.&quot;&quot;&quot;</font>
<font color="red">3278.         if context is None:</font>
<font color="red">3279.             context = getcontext()</font>
<font color="black">3280. </font>
<font color="red">3281.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3282. </font>
<font color="red">3283.         if not self._islogical() or not other._islogical():</font>
<font color="red">3284.             return context._raise_error(InvalidOperation)</font>
<font color="black">3285. </font>
<font color="black">3286.         # fill to context.prec</font>
<font color="red">3287.         (opa, opb) = self._fill_logical(context, self._int, other._int)</font>
<font color="black">3288. </font>
<font color="black">3289.         # make the operation, and clean starting zeroes</font>
<font color="red">3290.         result = &quot;&quot;.join([str(int(a)&amp;int(b)) for a,b in zip(opa,opb)])</font>
<font color="red">3291.         return _dec_from_triple(0, result.lstrip('0') or '0', 0)</font>
<font color="black">3292. </font>
<font color="green">3293.     def logical_invert(self, context=None):</font>
<font color="black">3294.         &quot;&quot;&quot;Invert all its digits.&quot;&quot;&quot;</font>
<font color="red">3295.         if context is None:</font>
<font color="red">3296.             context = getcontext()</font>
<font color="red">3297.         return self.logical_xor(_dec_from_triple(0,'1'*context.prec,0),</font>
<font color="red">3298.                                 context)</font>
<font color="black">3299. </font>
<font color="green">3300.     def logical_or(self, other, context=None):</font>
<font color="black">3301.         &quot;&quot;&quot;Applies an 'or' operation between self and other's digits.&quot;&quot;&quot;</font>
<font color="red">3302.         if context is None:</font>
<font color="red">3303.             context = getcontext()</font>
<font color="black">3304. </font>
<font color="red">3305.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3306. </font>
<font color="red">3307.         if not self._islogical() or not other._islogical():</font>
<font color="red">3308.             return context._raise_error(InvalidOperation)</font>
<font color="black">3309. </font>
<font color="black">3310.         # fill to context.prec</font>
<font color="red">3311.         (opa, opb) = self._fill_logical(context, self._int, other._int)</font>
<font color="black">3312. </font>
<font color="black">3313.         # make the operation, and clean starting zeroes</font>
<font color="red">3314.         result = &quot;&quot;.join([str(int(a)|int(b)) for a,b in zip(opa,opb)])</font>
<font color="red">3315.         return _dec_from_triple(0, result.lstrip('0') or '0', 0)</font>
<font color="black">3316. </font>
<font color="green">3317.     def logical_xor(self, other, context=None):</font>
<font color="black">3318.         &quot;&quot;&quot;Applies an 'xor' operation between self and other's digits.&quot;&quot;&quot;</font>
<font color="red">3319.         if context is None:</font>
<font color="red">3320.             context = getcontext()</font>
<font color="black">3321. </font>
<font color="red">3322.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3323. </font>
<font color="red">3324.         if not self._islogical() or not other._islogical():</font>
<font color="red">3325.             return context._raise_error(InvalidOperation)</font>
<font color="black">3326. </font>
<font color="black">3327.         # fill to context.prec</font>
<font color="red">3328.         (opa, opb) = self._fill_logical(context, self._int, other._int)</font>
<font color="black">3329. </font>
<font color="black">3330.         # make the operation, and clean starting zeroes</font>
<font color="red">3331.         result = &quot;&quot;.join([str(int(a)^int(b)) for a,b in zip(opa,opb)])</font>
<font color="red">3332.         return _dec_from_triple(0, result.lstrip('0') or '0', 0)</font>
<font color="black">3333. </font>
<font color="green">3334.     def max_mag(self, other, context=None):</font>
<font color="black">3335.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.&quot;&quot;&quot;</font>
<font color="red">3336.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3337. </font>
<font color="red">3338.         if context is None:</font>
<font color="red">3339.             context = getcontext()</font>
<font color="black">3340. </font>
<font color="red">3341.         if self._is_special or other._is_special:</font>
<font color="black">3342.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">3343.             # number is always returned</font>
<font color="red">3344.             sn = self._isnan()</font>
<font color="red">3345.             on = other._isnan()</font>
<font color="red">3346.             if sn or on:</font>
<font color="red">3347.                 if on == 1 and sn == 0:</font>
<font color="red">3348.                     return self._fix(context)</font>
<font color="red">3349.                 if sn == 1 and on == 0:</font>
<font color="red">3350.                     return other._fix(context)</font>
<font color="red">3351.                 return self._check_nans(other, context)</font>
<font color="black">3352. </font>
<font color="red">3353.         c = self.copy_abs()._cmp(other.copy_abs())</font>
<font color="red">3354.         if c == 0:</font>
<font color="red">3355.             c = self.compare_total(other)</font>
<font color="black">3356. </font>
<font color="red">3357.         if c == -1:</font>
<font color="red">3358.             ans = other</font>
<font color="black">3359.         else:</font>
<font color="red">3360.             ans = self</font>
<font color="black">3361. </font>
<font color="red">3362.         return ans._fix(context)</font>
<font color="black">3363. </font>
<font color="green">3364.     def min_mag(self, other, context=None):</font>
<font color="black">3365.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.&quot;&quot;&quot;</font>
<font color="red">3366.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3367. </font>
<font color="red">3368.         if context is None:</font>
<font color="red">3369.             context = getcontext()</font>
<font color="black">3370. </font>
<font color="red">3371.         if self._is_special or other._is_special:</font>
<font color="black">3372.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">3373.             # number is always returned</font>
<font color="red">3374.             sn = self._isnan()</font>
<font color="red">3375.             on = other._isnan()</font>
<font color="red">3376.             if sn or on:</font>
<font color="red">3377.                 if on == 1 and sn == 0:</font>
<font color="red">3378.                     return self._fix(context)</font>
<font color="red">3379.                 if sn == 1 and on == 0:</font>
<font color="red">3380.                     return other._fix(context)</font>
<font color="red">3381.                 return self._check_nans(other, context)</font>
<font color="black">3382. </font>
<font color="red">3383.         c = self.copy_abs()._cmp(other.copy_abs())</font>
<font color="red">3384.         if c == 0:</font>
<font color="red">3385.             c = self.compare_total(other)</font>
<font color="black">3386. </font>
<font color="red">3387.         if c == -1:</font>
<font color="red">3388.             ans = self</font>
<font color="black">3389.         else:</font>
<font color="red">3390.             ans = other</font>
<font color="black">3391. </font>
<font color="red">3392.         return ans._fix(context)</font>
<font color="black">3393. </font>
<font color="green">3394.     def next_minus(self, context=None):</font>
<font color="black">3395.         &quot;&quot;&quot;Returns the largest representable number smaller than itself.&quot;&quot;&quot;</font>
<font color="red">3396.         if context is None:</font>
<font color="red">3397.             context = getcontext()</font>
<font color="black">3398. </font>
<font color="red">3399.         ans = self._check_nans(context=context)</font>
<font color="red">3400.         if ans:</font>
<font color="red">3401.             return ans</font>
<font color="black">3402. </font>
<font color="red">3403.         if self._isinfinity() == -1:</font>
<font color="red">3404.             return _NegativeInfinity</font>
<font color="red">3405.         if self._isinfinity() == 1:</font>
<font color="red">3406.             return _dec_from_triple(0, '9'*context.prec, context.Etop())</font>
<font color="black">3407. </font>
<font color="red">3408.         context = context.copy()</font>
<font color="red">3409.         context._set_rounding(ROUND_FLOOR)</font>
<font color="red">3410.         context._ignore_all_flags()</font>
<font color="red">3411.         new_self = self._fix(context)</font>
<font color="red">3412.         if new_self != self:</font>
<font color="red">3413.             return new_self</font>
<font color="red">3414.         return self.__sub__(_dec_from_triple(0, '1', context.Etiny()-1),</font>
<font color="red">3415.                             context)</font>
<font color="black">3416. </font>
<font color="green">3417.     def next_plus(self, context=None):</font>
<font color="black">3418.         &quot;&quot;&quot;Returns the smallest representable number larger than itself.&quot;&quot;&quot;</font>
<font color="red">3419.         if context is None:</font>
<font color="red">3420.             context = getcontext()</font>
<font color="black">3421. </font>
<font color="red">3422.         ans = self._check_nans(context=context)</font>
<font color="red">3423.         if ans:</font>
<font color="red">3424.             return ans</font>
<font color="black">3425. </font>
<font color="red">3426.         if self._isinfinity() == 1:</font>
<font color="red">3427.             return _Infinity</font>
<font color="red">3428.         if self._isinfinity() == -1:</font>
<font color="red">3429.             return _dec_from_triple(1, '9'*context.prec, context.Etop())</font>
<font color="black">3430. </font>
<font color="red">3431.         context = context.copy()</font>
<font color="red">3432.         context._set_rounding(ROUND_CEILING)</font>
<font color="red">3433.         context._ignore_all_flags()</font>
<font color="red">3434.         new_self = self._fix(context)</font>
<font color="red">3435.         if new_self != self:</font>
<font color="red">3436.             return new_self</font>
<font color="red">3437.         return self.__add__(_dec_from_triple(0, '1', context.Etiny()-1),</font>
<font color="red">3438.                             context)</font>
<font color="black">3439. </font>
<font color="green">3440.     def next_toward(self, other, context=None):</font>
<font color="black">3441.         &quot;&quot;&quot;Returns the number closest to self, in the direction towards other.</font>
<font color="black">3442. </font>
<font color="black">3443.         The result is the closest representable number to self</font>
<font color="black">3444.         (excluding self) that is in the direction towards other,</font>
<font color="black">3445.         unless both have the same value.  If the two operands are</font>
<font color="black">3446.         numerically equal, then the result is a copy of self with the</font>
<font color="black">3447.         sign set to be the same as the sign of other.</font>
<font color="black">3448.         &quot;&quot;&quot;</font>
<font color="red">3449.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3450. </font>
<font color="red">3451.         if context is None:</font>
<font color="red">3452.             context = getcontext()</font>
<font color="black">3453. </font>
<font color="red">3454.         ans = self._check_nans(other, context)</font>
<font color="red">3455.         if ans:</font>
<font color="red">3456.             return ans</font>
<font color="black">3457. </font>
<font color="red">3458.         comparison = self._cmp(other)</font>
<font color="red">3459.         if comparison == 0:</font>
<font color="red">3460.             return self.copy_sign(other)</font>
<font color="black">3461. </font>
<font color="red">3462.         if comparison == -1:</font>
<font color="red">3463.             ans = self.next_plus(context)</font>
<font color="black">3464.         else: # comparison == 1</font>
<font color="red">3465.             ans = self.next_minus(context)</font>
<font color="black">3466. </font>
<font color="black">3467.         # decide which flags to raise using value of ans</font>
<font color="red">3468.         if ans._isinfinity():</font>
<font color="red">3469.             context._raise_error(Overflow,</font>
<font color="red">3470.                                  'Infinite result from next_toward',</font>
<font color="red">3471.                                  ans._sign)</font>
<font color="red">3472.             context._raise_error(Inexact)</font>
<font color="red">3473.             context._raise_error(Rounded)</font>
<font color="red">3474.         elif ans.adjusted() &lt; context.Emin:</font>
<font color="red">3475.             context._raise_error(Underflow)</font>
<font color="red">3476.             context._raise_error(Subnormal)</font>
<font color="red">3477.             context._raise_error(Inexact)</font>
<font color="red">3478.             context._raise_error(Rounded)</font>
<font color="black">3479.             # if precision == 1 then we don't raise Clamped for a</font>
<font color="black">3480.             # result 0E-Etiny.</font>
<font color="red">3481.             if not ans:</font>
<font color="red">3482.                 context._raise_error(Clamped)</font>
<font color="black">3483. </font>
<font color="red">3484.         return ans</font>
<font color="black">3485. </font>
<font color="green">3486.     def number_class(self, context=None):</font>
<font color="black">3487.         &quot;&quot;&quot;Returns an indication of the class of self.</font>
<font color="black">3488. </font>
<font color="black">3489.         The class is one of the following strings:</font>
<font color="black">3490.           sNaN</font>
<font color="black">3491.           NaN</font>
<font color="black">3492.           -Infinity</font>
<font color="black">3493.           -Normal</font>
<font color="black">3494.           -Subnormal</font>
<font color="black">3495.           -Zero</font>
<font color="black">3496.           +Zero</font>
<font color="black">3497.           +Subnormal</font>
<font color="black">3498.           +Normal</font>
<font color="black">3499.           +Infinity</font>
<font color="black">3500.         &quot;&quot;&quot;</font>
<font color="red">3501.         if self.is_snan():</font>
<font color="red">3502.             return &quot;sNaN&quot;</font>
<font color="red">3503.         if self.is_qnan():</font>
<font color="red">3504.             return &quot;NaN&quot;</font>
<font color="red">3505.         inf = self._isinfinity()</font>
<font color="red">3506.         if inf == 1:</font>
<font color="red">3507.             return &quot;+Infinity&quot;</font>
<font color="red">3508.         if inf == -1:</font>
<font color="red">3509.             return &quot;-Infinity&quot;</font>
<font color="red">3510.         if self.is_zero():</font>
<font color="red">3511.             if self._sign:</font>
<font color="red">3512.                 return &quot;-Zero&quot;</font>
<font color="black">3513.             else:</font>
<font color="red">3514.                 return &quot;+Zero&quot;</font>
<font color="red">3515.         if context is None:</font>
<font color="red">3516.             context = getcontext()</font>
<font color="red">3517.         if self.is_subnormal(context=context):</font>
<font color="red">3518.             if self._sign:</font>
<font color="red">3519.                 return &quot;-Subnormal&quot;</font>
<font color="black">3520.             else:</font>
<font color="red">3521.                 return &quot;+Subnormal&quot;</font>
<font color="black">3522.         # just a normal, regular, boring number, :)</font>
<font color="red">3523.         if self._sign:</font>
<font color="red">3524.             return &quot;-Normal&quot;</font>
<font color="black">3525.         else:</font>
<font color="red">3526.             return &quot;+Normal&quot;</font>
<font color="black">3527. </font>
<font color="green">3528.     def radix(self):</font>
<font color="black">3529.         &quot;&quot;&quot;Just returns 10, as this is Decimal, :)&quot;&quot;&quot;</font>
<font color="red">3530.         return Decimal(10)</font>
<font color="black">3531. </font>
<font color="green">3532.     def rotate(self, other, context=None):</font>
<font color="black">3533.         &quot;&quot;&quot;Returns a rotated copy of self, value-of-other times.&quot;&quot;&quot;</font>
<font color="red">3534.         if context is None:</font>
<font color="red">3535.             context = getcontext()</font>
<font color="black">3536. </font>
<font color="red">3537.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3538. </font>
<font color="red">3539.         ans = self._check_nans(other, context)</font>
<font color="red">3540.         if ans:</font>
<font color="red">3541.             return ans</font>
<font color="black">3542. </font>
<font color="red">3543.         if other._exp != 0:</font>
<font color="red">3544.             return context._raise_error(InvalidOperation)</font>
<font color="red">3545.         if not (-context.prec &lt;= int(other) &lt;= context.prec):</font>
<font color="red">3546.             return context._raise_error(InvalidOperation)</font>
<font color="black">3547. </font>
<font color="red">3548.         if self._isinfinity():</font>
<font color="red">3549.             return Decimal(self)</font>
<font color="black">3550. </font>
<font color="black">3551.         # get values, pad if necessary</font>
<font color="red">3552.         torot = int(other)</font>
<font color="red">3553.         rotdig = self._int</font>
<font color="red">3554.         topad = context.prec - len(rotdig)</font>
<font color="red">3555.         if topad &gt; 0:</font>
<font color="red">3556.             rotdig = '0'*topad + rotdig</font>
<font color="red">3557.         elif topad &lt; 0:</font>
<font color="red">3558.             rotdig = rotdig[-topad:]</font>
<font color="black">3559. </font>
<font color="black">3560.         # let's rotate!</font>
<font color="red">3561.         rotated = rotdig[torot:] + rotdig[:torot]</font>
<font color="red">3562.         return _dec_from_triple(self._sign,</font>
<font color="red">3563.                                 rotated.lstrip('0') or '0', self._exp)</font>
<font color="black">3564. </font>
<font color="green">3565.     def scaleb(self, other, context=None):</font>
<font color="black">3566.         &quot;&quot;&quot;Returns self operand after adding the second value to its exp.&quot;&quot;&quot;</font>
<font color="red">3567.         if context is None:</font>
<font color="red">3568.             context = getcontext()</font>
<font color="black">3569. </font>
<font color="red">3570.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3571. </font>
<font color="red">3572.         ans = self._check_nans(other, context)</font>
<font color="red">3573.         if ans:</font>
<font color="red">3574.             return ans</font>
<font color="black">3575. </font>
<font color="red">3576.         if other._exp != 0:</font>
<font color="red">3577.             return context._raise_error(InvalidOperation)</font>
<font color="red">3578.         liminf = -2 * (context.Emax + context.prec)</font>
<font color="red">3579.         limsup =  2 * (context.Emax + context.prec)</font>
<font color="red">3580.         if not (liminf &lt;= int(other) &lt;= limsup):</font>
<font color="red">3581.             return context._raise_error(InvalidOperation)</font>
<font color="black">3582. </font>
<font color="red">3583.         if self._isinfinity():</font>
<font color="red">3584.             return Decimal(self)</font>
<font color="black">3585. </font>
<font color="red">3586.         d = _dec_from_triple(self._sign, self._int, self._exp + int(other))</font>
<font color="red">3587.         d = d._fix(context)</font>
<font color="red">3588.         return d</font>
<font color="black">3589. </font>
<font color="green">3590.     def shift(self, other, context=None):</font>
<font color="black">3591.         &quot;&quot;&quot;Returns a shifted copy of self, value-of-other times.&quot;&quot;&quot;</font>
<font color="red">3592.         if context is None:</font>
<font color="red">3593.             context = getcontext()</font>
<font color="black">3594. </font>
<font color="red">3595.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3596. </font>
<font color="red">3597.         ans = self._check_nans(other, context)</font>
<font color="red">3598.         if ans:</font>
<font color="red">3599.             return ans</font>
<font color="black">3600. </font>
<font color="red">3601.         if other._exp != 0:</font>
<font color="red">3602.             return context._raise_error(InvalidOperation)</font>
<font color="red">3603.         if not (-context.prec &lt;= int(other) &lt;= context.prec):</font>
<font color="red">3604.             return context._raise_error(InvalidOperation)</font>
<font color="black">3605. </font>
<font color="red">3606.         if self._isinfinity():</font>
<font color="red">3607.             return Decimal(self)</font>
<font color="black">3608. </font>
<font color="black">3609.         # get values, pad if necessary</font>
<font color="red">3610.         torot = int(other)</font>
<font color="red">3611.         rotdig = self._int</font>
<font color="red">3612.         topad = context.prec - len(rotdig)</font>
<font color="red">3613.         if topad &gt; 0:</font>
<font color="red">3614.             rotdig = '0'*topad + rotdig</font>
<font color="red">3615.         elif topad &lt; 0:</font>
<font color="red">3616.             rotdig = rotdig[-topad:]</font>
<font color="black">3617. </font>
<font color="black">3618.         # let's shift!</font>
<font color="red">3619.         if torot &lt; 0:</font>
<font color="red">3620.             shifted = rotdig[:torot]</font>
<font color="black">3621.         else:</font>
<font color="red">3622.             shifted = rotdig + '0'*torot</font>
<font color="red">3623.             shifted = shifted[-context.prec:]</font>
<font color="black">3624. </font>
<font color="red">3625.         return _dec_from_triple(self._sign,</font>
<font color="red">3626.                                     shifted.lstrip('0') or '0', self._exp)</font>
<font color="black">3627. </font>
<font color="black">3628.     # Support for pickling, copy, and deepcopy</font>
<font color="green">3629.     def __reduce__(self):</font>
<font color="red">3630.         return (self.__class__, (str(self),))</font>
<font color="black">3631. </font>
<font color="green">3632.     def __copy__(self):</font>
<font color="red">3633.         if type(self) is Decimal:</font>
<font color="red">3634.             return self     # I'm immutable; therefore I am my own clone</font>
<font color="red">3635.         return self.__class__(str(self))</font>
<font color="black">3636. </font>
<font color="green">3637.     def __deepcopy__(self, memo):</font>
<font color="red">3638.         if type(self) is Decimal:</font>
<font color="red">3639.             return self     # My components are also immutable</font>
<font color="red">3640.         return self.__class__(str(self))</font>
<font color="black">3641. </font>
<font color="black">3642.     # PEP 3101 support.  the _localeconv keyword argument should be</font>
<font color="black">3643.     # considered private: it's provided for ease of testing only.</font>
<font color="green">3644.     def __format__(self, specifier, context=None, _localeconv=None):</font>
<font color="black">3645.         &quot;&quot;&quot;Format a Decimal instance according to the given specifier.</font>
<font color="black">3646. </font>
<font color="black">3647.         The specifier should be a standard format specifier, with the</font>
<font color="black">3648.         form described in PEP 3101.  Formatting types 'e', 'E', 'f',</font>
<font color="black">3649.         'F', 'g', 'G', 'n' and '%' are supported.  If the formatting</font>
<font color="black">3650.         type is omitted it defaults to 'g' or 'G', depending on the</font>
<font color="black">3651.         value of context.capitals.</font>
<font color="black">3652.         &quot;&quot;&quot;</font>
<font color="black">3653. </font>
<font color="black">3654.         # Note: PEP 3101 says that if the type is not present then</font>
<font color="black">3655.         # there should be at least one digit after the decimal point.</font>
<font color="black">3656.         # We take the liberty of ignoring this requirement for</font>
<font color="black">3657.         # Decimal---it's presumably there to make sure that</font>
<font color="black">3658.         # format(float, '') behaves similarly to str(float).</font>
<font color="red">3659.         if context is None:</font>
<font color="red">3660.             context = getcontext()</font>
<font color="black">3661. </font>
<font color="red">3662.         spec = _parse_format_specifier(specifier, _localeconv=_localeconv)</font>
<font color="black">3663. </font>
<font color="black">3664.         # special values don't care about the type or precision</font>
<font color="red">3665.         if self._is_special:</font>
<font color="red">3666.             sign = _format_sign(self._sign, spec)</font>
<font color="red">3667.             body = str(self.copy_abs())</font>
<font color="red">3668.             return _format_align(sign, body, spec)</font>
<font color="black">3669. </font>
<font color="black">3670.         # a type of None defaults to 'g' or 'G', depending on context</font>
<font color="red">3671.         if spec['type'] is None:</font>
<font color="red">3672.             spec['type'] = ['g', 'G'][context.capitals]</font>
<font color="black">3673. </font>
<font color="black">3674.         # if type is '%', adjust exponent of self accordingly</font>
<font color="red">3675.         if spec['type'] == '%':</font>
<font color="red">3676.             self = _dec_from_triple(self._sign, self._int, self._exp+2)</font>
<font color="black">3677. </font>
<font color="black">3678.         # round if necessary, taking rounding mode from the context</font>
<font color="red">3679.         rounding = context.rounding</font>
<font color="red">3680.         precision = spec['precision']</font>
<font color="red">3681.         if precision is not None:</font>
<font color="red">3682.             if spec['type'] in 'eE':</font>
<font color="red">3683.                 self = self._round(precision+1, rounding)</font>
<font color="red">3684.             elif spec['type'] in 'fF%':</font>
<font color="red">3685.                 self = self._rescale(-precision, rounding)</font>
<font color="red">3686.             elif spec['type'] in 'gG' and len(self._int) &gt; precision:</font>
<font color="red">3687.                 self = self._round(precision, rounding)</font>
<font color="black">3688.         # special case: zeros with a positive exponent can't be</font>
<font color="black">3689.         # represented in fixed point; rescale them to 0e0.</font>
<font color="red">3690.         if not self and self._exp &gt; 0 and spec['type'] in 'fF%':</font>
<font color="red">3691.             self = self._rescale(0, rounding)</font>
<font color="black">3692. </font>
<font color="black">3693.         # figure out placement of the decimal point</font>
<font color="red">3694.         leftdigits = self._exp + len(self._int)</font>
<font color="red">3695.         if spec['type'] in 'eE':</font>
<font color="red">3696.             if not self and precision is not None:</font>
<font color="red">3697.                 dotplace = 1 - precision</font>
<font color="black">3698.             else:</font>
<font color="red">3699.                 dotplace = 1</font>
<font color="red">3700.         elif spec['type'] in 'fF%':</font>
<font color="red">3701.             dotplace = leftdigits</font>
<font color="red">3702.         elif spec['type'] in 'gG':</font>
<font color="red">3703.             if self._exp &lt;= 0 and leftdigits &gt; -6:</font>
<font color="red">3704.                 dotplace = leftdigits</font>
<font color="black">3705.             else:</font>
<font color="red">3706.                 dotplace = 1</font>
<font color="black">3707. </font>
<font color="black">3708.         # find digits before and after decimal point, and get exponent</font>
<font color="red">3709.         if dotplace &lt; 0:</font>
<font color="red">3710.             intpart = '0'</font>
<font color="red">3711.             fracpart = '0'*(-dotplace) + self._int</font>
<font color="red">3712.         elif dotplace &gt; len(self._int):</font>
<font color="red">3713.             intpart = self._int + '0'*(dotplace-len(self._int))</font>
<font color="red">3714.             fracpart = ''</font>
<font color="black">3715.         else:</font>
<font color="red">3716.             intpart = self._int[:dotplace] or '0'</font>
<font color="red">3717.             fracpart = self._int[dotplace:]</font>
<font color="red">3718.         exp = leftdigits-dotplace</font>
<font color="black">3719. </font>
<font color="black">3720.         # done with the decimal-specific stuff;  hand over the rest</font>
<font color="black">3721.         # of the formatting to the _format_number function</font>
<font color="red">3722.         return _format_number(self._sign, intpart, fracpart, exp, spec)</font>
<font color="black">3723. </font>
<font color="green">3724. def _dec_from_triple(sign, coefficient, exponent, special=False):</font>
<font color="black">3725.     &quot;&quot;&quot;Create a decimal instance directly, without any validation,</font>
<font color="black">3726.     normalization (e.g. removal of leading zeros) or argument</font>
<font color="black">3727.     conversion.</font>
<font color="black">3728. </font>
<font color="black">3729.     This function is for *internal use only*.</font>
<font color="black">3730.     &quot;&quot;&quot;</font>
<font color="black">3731. </font>
<font color="red">3732.     self = object.__new__(Decimal)</font>
<font color="red">3733.     self._sign = sign</font>
<font color="red">3734.     self._int = coefficient</font>
<font color="red">3735.     self._exp = exponent</font>
<font color="red">3736.     self._is_special = special</font>
<font color="black">3737. </font>
<font color="red">3738.     return self</font>
<font color="black">3739. </font>
<font color="black">3740. # Register Decimal as a kind of Number (an abstract base class).</font>
<font color="black">3741. # However, do not register it as Real (because Decimals are not</font>
<font color="black">3742. # interoperable with floats).</font>
<font color="green">3743. _numbers.Number.register(Decimal)</font>
<font color="black">3744. </font>
<font color="black">3745. </font>
<font color="black">3746. ##### Context class #######################################################</font>
<font color="black">3747. </font>
<font color="green">3748. class _ContextManager(object):</font>
<font color="black">3749.     &quot;&quot;&quot;Context manager class to support localcontext().</font>
<font color="black">3750. </font>
<font color="black">3751.       Sets a copy of the supplied context in __enter__() and restores</font>
<font color="black">3752.       the previous decimal context in __exit__()</font>
<font color="green">3753.     &quot;&quot;&quot;</font>
<font color="green">3754.     def __init__(self, new_context):</font>
<font color="red">3755.         self.new_context = new_context.copy()</font>
<font color="green">3756.     def __enter__(self):</font>
<font color="red">3757.         self.saved_context = getcontext()</font>
<font color="red">3758.         setcontext(self.new_context)</font>
<font color="red">3759.         return self.new_context</font>
<font color="green">3760.     def __exit__(self, t, v, tb):</font>
<font color="red">3761.         setcontext(self.saved_context)</font>
<font color="black">3762. </font>
<font color="green">3763. class Context(object):</font>
<font color="black">3764.     &quot;&quot;&quot;Contains the context for a Decimal instance.</font>
<font color="black">3765. </font>
<font color="black">3766.     Contains:</font>
<font color="black">3767.     prec - precision (for use in rounding, division, square roots..)</font>
<font color="black">3768.     rounding - rounding type (how you round)</font>
<font color="black">3769.     traps - If traps[exception] = 1, then the exception is</font>
<font color="black">3770.                     raised when it is caused.  Otherwise, a value is</font>
<font color="black">3771.                     substituted in.</font>
<font color="black">3772.     flags  - When an exception is caused, flags[exception] is set.</font>
<font color="black">3773.              (Whether or not the trap_enabler is set)</font>
<font color="black">3774.              Should be reset by user of Decimal instance.</font>
<font color="black">3775.     Emin -   Minimum exponent</font>
<font color="black">3776.     Emax -   Maximum exponent</font>
<font color="black">3777.     capitals -      If 1, 1*10^1 is printed as 1E+1.</font>
<font color="black">3778.                     If 0, printed as 1e1</font>
<font color="black">3779.     _clamp - If 1, change exponents if too high (Default 0)</font>
<font color="green">3780.     &quot;&quot;&quot;</font>
<font color="black">3781. </font>
<font color="green">3782.     def __init__(self, prec=None, rounding=None,</font>
<font color="green">3783.                  traps=None, flags=None,</font>
<font color="green">3784.                  Emin=None, Emax=None,</font>
<font color="green">3785.                  capitals=None, _clamp=0,</font>
<font color="green">3786.                  _ignored_flags=None):</font>
<font color="black">3787.         # Set defaults; for everything except flags and _ignored_flags,</font>
<font color="black">3788.         # inherit from DefaultContext.</font>
<font color="green">3789.         try:</font>
<font color="green">3790.             dc = DefaultContext</font>
<font color="green">3791.         except NameError:</font>
<font color="green">3792.             pass</font>
<font color="black">3793. </font>
<font color="green">3794.         self.prec = prec if prec is not None else dc.prec</font>
<font color="green">3795.         self.rounding = rounding if rounding is not None else dc.rounding</font>
<font color="green">3796.         self.Emin = Emin if Emin is not None else dc.Emin</font>
<font color="green">3797.         self.Emax = Emax if Emax is not None else dc.Emax</font>
<font color="green">3798.         self.capitals = capitals if capitals is not None else dc.capitals</font>
<font color="green">3799.         self._clamp = _clamp if _clamp is not None else dc._clamp</font>
<font color="black">3800. </font>
<font color="green">3801.         if _ignored_flags is None:</font>
<font color="green">3802.             self._ignored_flags = []</font>
<font color="black">3803.         else:</font>
<font color="red">3804.             self._ignored_flags = _ignored_flags</font>
<font color="black">3805. </font>
<font color="green">3806.         if traps is None:</font>
<font color="red">3807.             self.traps = dc.traps.copy()</font>
<font color="green">3808.         elif not isinstance(traps, dict):</font>
<font color="green">3809.             self.traps = dict((s, int(s in traps)) for s in _signals)</font>
<font color="black">3810.         else:</font>
<font color="red">3811.             self.traps = traps</font>
<font color="black">3812. </font>
<font color="green">3813.         if flags is None:</font>
<font color="red">3814.             self.flags = dict.fromkeys(_signals, 0)</font>
<font color="green">3815.         elif not isinstance(flags, dict):</font>
<font color="green">3816.             self.flags = dict((s, int(s in flags)) for s in _signals)</font>
<font color="black">3817.         else:</font>
<font color="red">3818.             self.flags = flags</font>
<font color="black">3819. </font>
<font color="green">3820.     def __repr__(self):</font>
<font color="black">3821.         &quot;&quot;&quot;Show the current context.&quot;&quot;&quot;</font>
<font color="red">3822.         s = []</font>
<font color="red">3823.         s.append('Context(prec=%(prec)d, rounding=%(rounding)s, '</font>
<font color="black">3824.                  'Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d'</font>
<font color="red">3825.                  % vars(self))</font>
<font color="red">3826.         names = [f.__name__ for f, v in self.flags.items() if v]</font>
<font color="red">3827.         s.append('flags=[' + ', '.join(names) + ']')</font>
<font color="red">3828.         names = [t.__name__ for t, v in self.traps.items() if v]</font>
<font color="red">3829.         s.append('traps=[' + ', '.join(names) + ']')</font>
<font color="red">3830.         return ', '.join(s) + ')'</font>
<font color="black">3831. </font>
<font color="green">3832.     def clear_flags(self):</font>
<font color="black">3833.         &quot;&quot;&quot;Reset all flags to zero&quot;&quot;&quot;</font>
<font color="red">3834.         for flag in self.flags:</font>
<font color="red">3835.             self.flags[flag] = 0</font>
<font color="black">3836. </font>
<font color="green">3837.     def _shallow_copy(self):</font>
<font color="black">3838.         &quot;&quot;&quot;Returns a shallow copy from self.&quot;&quot;&quot;</font>
<font color="red">3839.         nc = Context(self.prec, self.rounding, self.traps,</font>
<font color="red">3840.                      self.flags, self.Emin, self.Emax,</font>
<font color="red">3841.                      self.capitals, self._clamp, self._ignored_flags)</font>
<font color="red">3842.         return nc</font>
<font color="black">3843. </font>
<font color="green">3844.     def copy(self):</font>
<font color="black">3845.         &quot;&quot;&quot;Returns a deep copy from self.&quot;&quot;&quot;</font>
<font color="red">3846.         nc = Context(self.prec, self.rounding, self.traps.copy(),</font>
<font color="red">3847.                      self.flags.copy(), self.Emin, self.Emax,</font>
<font color="red">3848.                      self.capitals, self._clamp, self._ignored_flags)</font>
<font color="red">3849.         return nc</font>
<font color="green">3850.     __copy__ = copy</font>
<font color="black">3851. </font>
<font color="green">3852.     def _raise_error(self, condition, explanation = None, *args):</font>
<font color="black">3853.         &quot;&quot;&quot;Handles an error</font>
<font color="black">3854. </font>
<font color="black">3855.         If the flag is in _ignored_flags, returns the default response.</font>
<font color="black">3856.         Otherwise, it sets the flag, then, if the corresponding</font>
<font color="black">3857.         trap_enabler is set, it reraises the exception.  Otherwise, it returns</font>
<font color="black">3858.         the default value after setting the flag.</font>
<font color="black">3859.         &quot;&quot;&quot;</font>
<font color="red">3860.         error = _condition_map.get(condition, condition)</font>
<font color="red">3861.         if error in self._ignored_flags:</font>
<font color="black">3862.             # Don't touch the flag</font>
<font color="red">3863.             return error().handle(self, *args)</font>
<font color="black">3864. </font>
<font color="red">3865.         self.flags[error] = 1</font>
<font color="red">3866.         if not self.traps[error]:</font>
<font color="black">3867.             # The errors define how to handle themselves.</font>
<font color="red">3868.             return condition().handle(self, *args)</font>
<font color="black">3869. </font>
<font color="black">3870.         # Errors should only be risked on copies of the context</font>
<font color="black">3871.         # self._ignored_flags = []</font>
<font color="red">3872.         raise error(explanation)</font>
<font color="black">3873. </font>
<font color="green">3874.     def _ignore_all_flags(self):</font>
<font color="black">3875.         &quot;&quot;&quot;Ignore all flags, if they are raised&quot;&quot;&quot;</font>
<font color="red">3876.         return self._ignore_flags(*_signals)</font>
<font color="black">3877. </font>
<font color="green">3878.     def _ignore_flags(self, *flags):</font>
<font color="black">3879.         &quot;&quot;&quot;Ignore the flags, if they are raised&quot;&quot;&quot;</font>
<font color="black">3880.         # Do not mutate-- This way, copies of a context leave the original</font>
<font color="black">3881.         # alone.</font>
<font color="red">3882.         self._ignored_flags = (self._ignored_flags + list(flags))</font>
<font color="red">3883.         return list(flags)</font>
<font color="black">3884. </font>
<font color="green">3885.     def _regard_flags(self, *flags):</font>
<font color="black">3886.         &quot;&quot;&quot;Stop ignoring the flags, if they are raised&quot;&quot;&quot;</font>
<font color="red">3887.         if flags and isinstance(flags[0], (tuple,list)):</font>
<font color="red">3888.             flags = flags[0]</font>
<font color="red">3889.         for flag in flags:</font>
<font color="red">3890.             self._ignored_flags.remove(flag)</font>
<font color="black">3891. </font>
<font color="black">3892.     # We inherit object.__hash__, so we must deny this explicitly</font>
<font color="green">3893.     __hash__ = None</font>
<font color="black">3894. </font>
<font color="green">3895.     def Etiny(self):</font>
<font color="black">3896.         &quot;&quot;&quot;Returns Etiny (= Emin - prec + 1)&quot;&quot;&quot;</font>
<font color="red">3897.         return int(self.Emin - self.prec + 1)</font>
<font color="black">3898. </font>
<font color="green">3899.     def Etop(self):</font>
<font color="black">3900.         &quot;&quot;&quot;Returns maximum exponent (= Emax - prec + 1)&quot;&quot;&quot;</font>
<font color="red">3901.         return int(self.Emax - self.prec + 1)</font>
<font color="black">3902. </font>
<font color="green">3903.     def _set_rounding(self, type):</font>
<font color="black">3904.         &quot;&quot;&quot;Sets the rounding type.</font>
<font color="black">3905. </font>
<font color="black">3906.         Sets the rounding type, and returns the current (previous)</font>
<font color="black">3907.         rounding type.  Often used like:</font>
<font color="black">3908. </font>
<font color="black">3909.         context = context.copy()</font>
<font color="black">3910.         # so you don't change the calling context</font>
<font color="black">3911.         # if an error occurs in the middle.</font>
<font color="black">3912.         rounding = context._set_rounding(ROUND_UP)</font>
<font color="black">3913.         val = self.__sub__(other, context=context)</font>
<font color="black">3914.         context._set_rounding(rounding)</font>
<font color="black">3915. </font>
<font color="black">3916.         This will make it round up for that operation.</font>
<font color="black">3917.         &quot;&quot;&quot;</font>
<font color="red">3918.         rounding = self.rounding</font>
<font color="red">3919.         self.rounding= type</font>
<font color="red">3920.         return rounding</font>
<font color="black">3921. </font>
<font color="green">3922.     def create_decimal(self, num='0'):</font>
<font color="black">3923.         &quot;&quot;&quot;Creates a new Decimal instance but using self as context.</font>
<font color="black">3924. </font>
<font color="black">3925.         This method implements the to-number operation of the</font>
<font color="black">3926.         IBM Decimal specification.&quot;&quot;&quot;</font>
<font color="black">3927. </font>
<font color="red">3928.         if isinstance(num, basestring) and num != num.strip():</font>
<font color="red">3929.             return self._raise_error(ConversionSyntax,</font>
<font color="red">3930.                                      &quot;no trailing or leading whitespace is &quot;</font>
<font color="black">3931.                                      &quot;permitted.&quot;)</font>
<font color="black">3932. </font>
<font color="red">3933.         d = Decimal(num, context=self)</font>
<font color="red">3934.         if d._isnan() and len(d._int) &gt; self.prec - self._clamp:</font>
<font color="red">3935.             return self._raise_error(ConversionSyntax,</font>
<font color="red">3936.                                      &quot;diagnostic info too long in NaN&quot;)</font>
<font color="red">3937.         return d._fix(self)</font>
<font color="black">3938. </font>
<font color="green">3939.     def create_decimal_from_float(self, f):</font>
<font color="black">3940.         &quot;&quot;&quot;Creates a new Decimal instance from a float but rounding using self</font>
<font color="black">3941.         as the context.</font>
<font color="black">3942. </font>
<font color="black">3943.         &gt;&gt;&gt; context = Context(prec=5, rounding=ROUND_DOWN)</font>
<font color="black">3944.         &gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)</font>
<font color="black">3945.         Decimal('3.1415')</font>
<font color="black">3946.         &gt;&gt;&gt; context = Context(prec=5, traps=[Inexact])</font>
<font color="black">3947.         &gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)</font>
<font color="black">3948.         Traceback (most recent call last):</font>
<font color="black">3949.             ...</font>
<font color="black">3950.         Inexact: None</font>
<font color="black">3951. </font>
<font color="black">3952.         &quot;&quot;&quot;</font>
<font color="red">3953.         d = Decimal.from_float(f)       # An exact conversion</font>
<font color="red">3954.         return d._fix(self)             # Apply the context rounding</font>
<font color="black">3955. </font>
<font color="black">3956.     # Methods</font>
<font color="green">3957.     def abs(self, a):</font>
<font color="black">3958.         &quot;&quot;&quot;Returns the absolute value of the operand.</font>
<font color="black">3959. </font>
<font color="black">3960.         If the operand is negative, the result is the same as using the minus</font>
<font color="black">3961.         operation on the operand.  Otherwise, the result is the same as using</font>
<font color="black">3962.         the plus operation on the operand.</font>
<font color="black">3963. </font>
<font color="black">3964.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('2.1'))</font>
<font color="black">3965.         Decimal('2.1')</font>
<font color="black">3966.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('-100'))</font>
<font color="black">3967.         Decimal('100')</font>
<font color="black">3968.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('101.5'))</font>
<font color="black">3969.         Decimal('101.5')</font>
<font color="black">3970.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('-101.5'))</font>
<font color="black">3971.         Decimal('101.5')</font>
<font color="black">3972.         &gt;&gt;&gt; ExtendedContext.abs(-1)</font>
<font color="black">3973.         Decimal('1')</font>
<font color="black">3974.         &quot;&quot;&quot;</font>
<font color="red">3975.         a = _convert_other(a, raiseit=True)</font>
<font color="red">3976.         return a.__abs__(context=self)</font>
<font color="black">3977. </font>
<font color="green">3978.     def add(self, a, b):</font>
<font color="black">3979.         &quot;&quot;&quot;Return the sum of the two operands.</font>
<font color="black">3980. </font>
<font color="black">3981.         &gt;&gt;&gt; ExtendedContext.add(Decimal('12'), Decimal('7.00'))</font>
<font color="black">3982.         Decimal('19.00')</font>
<font color="black">3983.         &gt;&gt;&gt; ExtendedContext.add(Decimal('1E+2'), Decimal('1.01E+4'))</font>
<font color="black">3984.         Decimal('1.02E+4')</font>
<font color="black">3985.         &gt;&gt;&gt; ExtendedContext.add(1, Decimal(2))</font>
<font color="black">3986.         Decimal('3')</font>
<font color="black">3987.         &gt;&gt;&gt; ExtendedContext.add(Decimal(8), 5)</font>
<font color="black">3988.         Decimal('13')</font>
<font color="black">3989.         &gt;&gt;&gt; ExtendedContext.add(5, 5)</font>
<font color="black">3990.         Decimal('10')</font>
<font color="black">3991.         &quot;&quot;&quot;</font>
<font color="red">3992.         a = _convert_other(a, raiseit=True)</font>
<font color="red">3993.         r = a.__add__(b, context=self)</font>
<font color="red">3994.         if r is NotImplemented:</font>
<font color="red">3995.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">3996.         else:</font>
<font color="red">3997.             return r</font>
<font color="black">3998. </font>
<font color="green">3999.     def _apply(self, a):</font>
<font color="red">4000.         return str(a._fix(self))</font>
<font color="black">4001. </font>
<font color="green">4002.     def canonical(self, a):</font>
<font color="black">4003.         &quot;&quot;&quot;Returns the same Decimal object.</font>
<font color="black">4004. </font>
<font color="black">4005.         As we do not have different encodings for the same number, the</font>
<font color="black">4006.         received object already is in its canonical form.</font>
<font color="black">4007. </font>
<font color="black">4008.         &gt;&gt;&gt; ExtendedContext.canonical(Decimal('2.50'))</font>
<font color="black">4009.         Decimal('2.50')</font>
<font color="black">4010.         &quot;&quot;&quot;</font>
<font color="red">4011.         return a.canonical(context=self)</font>
<font color="black">4012. </font>
<font color="green">4013.     def compare(self, a, b):</font>
<font color="black">4014.         &quot;&quot;&quot;Compares values numerically.</font>
<font color="black">4015. </font>
<font color="black">4016.         If the signs of the operands differ, a value representing each operand</font>
<font color="black">4017.         ('-1' if the operand is less than zero, '0' if the operand is zero or</font>
<font color="black">4018.         negative zero, or '1' if the operand is greater than zero) is used in</font>
<font color="black">4019.         place of that operand for the comparison instead of the actual</font>
<font color="black">4020.         operand.</font>
<font color="black">4021. </font>
<font color="black">4022.         The comparison is then effected by subtracting the second operand from</font>
<font color="black">4023.         the first and then returning a value according to the result of the</font>
<font color="black">4024.         subtraction: '-1' if the result is less than zero, '0' if the result is</font>
<font color="black">4025.         zero or negative zero, or '1' if the result is greater than zero.</font>
<font color="black">4026. </font>
<font color="black">4027.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('3'))</font>
<font color="black">4028.         Decimal('-1')</font>
<font color="black">4029.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))</font>
<font color="black">4030.         Decimal('0')</font>
<font color="black">4031.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))</font>
<font color="black">4032.         Decimal('0')</font>
<font color="black">4033.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('3'), Decimal('2.1'))</font>
<font color="black">4034.         Decimal('1')</font>
<font color="black">4035.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))</font>
<font color="black">4036.         Decimal('1')</font>
<font color="black">4037.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))</font>
<font color="black">4038.         Decimal('-1')</font>
<font color="black">4039.         &gt;&gt;&gt; ExtendedContext.compare(1, 2)</font>
<font color="black">4040.         Decimal('-1')</font>
<font color="black">4041.         &gt;&gt;&gt; ExtendedContext.compare(Decimal(1), 2)</font>
<font color="black">4042.         Decimal('-1')</font>
<font color="black">4043.         &gt;&gt;&gt; ExtendedContext.compare(1, Decimal(2))</font>
<font color="black">4044.         Decimal('-1')</font>
<font color="black">4045.         &quot;&quot;&quot;</font>
<font color="red">4046.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4047.         return a.compare(b, context=self)</font>
<font color="black">4048. </font>
<font color="green">4049.     def compare_signal(self, a, b):</font>
<font color="black">4050.         &quot;&quot;&quot;Compares the values of the two operands numerically.</font>
<font color="black">4051. </font>
<font color="black">4052.         It's pretty much like compare(), but all NaNs signal, with signaling</font>
<font color="black">4053.         NaNs taking precedence over quiet NaNs.</font>
<font color="black">4054. </font>
<font color="black">4055.         &gt;&gt;&gt; c = ExtendedContext</font>
<font color="black">4056.         &gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('3'))</font>
<font color="black">4057.         Decimal('-1')</font>
<font color="black">4058.         &gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('2.1'))</font>
<font color="black">4059.         Decimal('0')</font>
<font color="black">4060.         &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black">4061.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4062.         0</font>
<font color="black">4063.         &gt;&gt;&gt; c.compare_signal(Decimal('NaN'), Decimal('2.1'))</font>
<font color="black">4064.         Decimal('NaN')</font>
<font color="black">4065.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4066.         1</font>
<font color="black">4067.         &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black">4068.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4069.         0</font>
<font color="black">4070.         &gt;&gt;&gt; c.compare_signal(Decimal('sNaN'), Decimal('2.1'))</font>
<font color="black">4071.         Decimal('NaN')</font>
<font color="black">4072.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4073.         1</font>
<font color="black">4074.         &gt;&gt;&gt; c.compare_signal(-1, 2)</font>
<font color="black">4075.         Decimal('-1')</font>
<font color="black">4076.         &gt;&gt;&gt; c.compare_signal(Decimal(-1), 2)</font>
<font color="black">4077.         Decimal('-1')</font>
<font color="black">4078.         &gt;&gt;&gt; c.compare_signal(-1, Decimal(2))</font>
<font color="black">4079.         Decimal('-1')</font>
<font color="black">4080.         &quot;&quot;&quot;</font>
<font color="red">4081.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4082.         return a.compare_signal(b, context=self)</font>
<font color="black">4083. </font>
<font color="green">4084.     def compare_total(self, a, b):</font>
<font color="black">4085.         &quot;&quot;&quot;Compares two operands using their abstract representation.</font>
<font color="black">4086. </font>
<font color="black">4087.         This is not like the standard compare, which use their numerical</font>
<font color="black">4088.         value. Note that a total ordering is defined for all possible abstract</font>
<font color="black">4089.         representations.</font>
<font color="black">4090. </font>
<font color="black">4091.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))</font>
<font color="black">4092.         Decimal('-1')</font>
<font color="black">4093.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))</font>
<font color="black">4094.         Decimal('-1')</font>
<font color="black">4095.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))</font>
<font color="black">4096.         Decimal('-1')</font>
<font color="black">4097.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))</font>
<font color="black">4098.         Decimal('0')</font>
<font color="black">4099.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))</font>
<font color="black">4100.         Decimal('1')</font>
<font color="black">4101.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))</font>
<font color="black">4102.         Decimal('-1')</font>
<font color="black">4103.         &gt;&gt;&gt; ExtendedContext.compare_total(1, 2)</font>
<font color="black">4104.         Decimal('-1')</font>
<font color="black">4105.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(1), 2)</font>
<font color="black">4106.         Decimal('-1')</font>
<font color="black">4107.         &gt;&gt;&gt; ExtendedContext.compare_total(1, Decimal(2))</font>
<font color="black">4108.         Decimal('-1')</font>
<font color="black">4109.         &quot;&quot;&quot;</font>
<font color="red">4110.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4111.         return a.compare_total(b)</font>
<font color="black">4112. </font>
<font color="green">4113.     def compare_total_mag(self, a, b):</font>
<font color="black">4114.         &quot;&quot;&quot;Compares two operands using their abstract representation ignoring sign.</font>
<font color="black">4115. </font>
<font color="black">4116.         Like compare_total, but with operand's sign ignored and assumed to be 0.</font>
<font color="black">4117.         &quot;&quot;&quot;</font>
<font color="red">4118.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4119.         return a.compare_total_mag(b)</font>
<font color="black">4120. </font>
<font color="green">4121.     def copy_abs(self, a):</font>
<font color="black">4122.         &quot;&quot;&quot;Returns a copy of the operand with the sign set to 0.</font>
<font color="black">4123. </font>
<font color="black">4124.         &gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('2.1'))</font>
<font color="black">4125.         Decimal('2.1')</font>
<font color="black">4126.         &gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('-100'))</font>
<font color="black">4127.         Decimal('100')</font>
<font color="black">4128.         &gt;&gt;&gt; ExtendedContext.copy_abs(-1)</font>
<font color="black">4129.         Decimal('1')</font>
<font color="black">4130.         &quot;&quot;&quot;</font>
<font color="red">4131.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4132.         return a.copy_abs()</font>
<font color="black">4133. </font>
<font color="green">4134.     def copy_decimal(self, a):</font>
<font color="black">4135.         &quot;&quot;&quot;Returns a copy of the decimal object.</font>
<font color="black">4136. </font>
<font color="black">4137.         &gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('2.1'))</font>
<font color="black">4138.         Decimal('2.1')</font>
<font color="black">4139.         &gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('-1.00'))</font>
<font color="black">4140.         Decimal('-1.00')</font>
<font color="black">4141.         &gt;&gt;&gt; ExtendedContext.copy_decimal(1)</font>
<font color="black">4142.         Decimal('1')</font>
<font color="black">4143.         &quot;&quot;&quot;</font>
<font color="red">4144.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4145.         return Decimal(a)</font>
<font color="black">4146. </font>
<font color="green">4147.     def copy_negate(self, a):</font>
<font color="black">4148.         &quot;&quot;&quot;Returns a copy of the operand with the sign inverted.</font>
<font color="black">4149. </font>
<font color="black">4150.         &gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('101.5'))</font>
<font color="black">4151.         Decimal('-101.5')</font>
<font color="black">4152.         &gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('-101.5'))</font>
<font color="black">4153.         Decimal('101.5')</font>
<font color="black">4154.         &gt;&gt;&gt; ExtendedContext.copy_negate(1)</font>
<font color="black">4155.         Decimal('-1')</font>
<font color="black">4156.         &quot;&quot;&quot;</font>
<font color="red">4157.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4158.         return a.copy_negate()</font>
<font color="black">4159. </font>
<font color="green">4160.     def copy_sign(self, a, b):</font>
<font color="black">4161.         &quot;&quot;&quot;Copies the second operand's sign to the first one.</font>
<font color="black">4162. </font>
<font color="black">4163.         In detail, it returns a copy of the first operand with the sign</font>
<font color="black">4164.         equal to the sign of the second operand.</font>
<font color="black">4165. </font>
<font color="black">4166.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('7.33'))</font>
<font color="black">4167.         Decimal('1.50')</font>
<font color="black">4168.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('7.33'))</font>
<font color="black">4169.         Decimal('1.50')</font>
<font color="black">4170.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('-7.33'))</font>
<font color="black">4171.         Decimal('-1.50')</font>
<font color="black">4172.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('-7.33'))</font>
<font color="black">4173.         Decimal('-1.50')</font>
<font color="black">4174.         &gt;&gt;&gt; ExtendedContext.copy_sign(1, -2)</font>
<font color="black">4175.         Decimal('-1')</font>
<font color="black">4176.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal(1), -2)</font>
<font color="black">4177.         Decimal('-1')</font>
<font color="black">4178.         &gt;&gt;&gt; ExtendedContext.copy_sign(1, Decimal(-2))</font>
<font color="black">4179.         Decimal('-1')</font>
<font color="black">4180.         &quot;&quot;&quot;</font>
<font color="red">4181.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4182.         return a.copy_sign(b)</font>
<font color="black">4183. </font>
<font color="green">4184.     def divide(self, a, b):</font>
<font color="black">4185.         &quot;&quot;&quot;Decimal division in a specified context.</font>
<font color="black">4186. </font>
<font color="black">4187.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('3'))</font>
<font color="black">4188.         Decimal('0.333333333')</font>
<font color="black">4189.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('2'), Decimal('3'))</font>
<font color="black">4190.         Decimal('0.666666667')</font>
<font color="black">4191.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('5'), Decimal('2'))</font>
<font color="black">4192.         Decimal('2.5')</font>
<font color="black">4193.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('10'))</font>
<font color="black">4194.         Decimal('0.1')</font>
<font color="black">4195.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('12'), Decimal('12'))</font>
<font color="black">4196.         Decimal('1')</font>
<font color="black">4197.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('8.00'), Decimal('2'))</font>
<font color="black">4198.         Decimal('4.00')</font>
<font color="black">4199.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('2.400'), Decimal('2.0'))</font>
<font color="black">4200.         Decimal('1.20')</font>
<font color="black">4201.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('100'))</font>
<font color="black">4202.         Decimal('10')</font>
<font color="black">4203.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('1'))</font>
<font color="black">4204.         Decimal('1000')</font>
<font color="black">4205.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('2.40E+6'), Decimal('2'))</font>
<font color="black">4206.         Decimal('1.20E+6')</font>
<font color="black">4207.         &gt;&gt;&gt; ExtendedContext.divide(5, 5)</font>
<font color="black">4208.         Decimal('1')</font>
<font color="black">4209.         &gt;&gt;&gt; ExtendedContext.divide(Decimal(5), 5)</font>
<font color="black">4210.         Decimal('1')</font>
<font color="black">4211.         &gt;&gt;&gt; ExtendedContext.divide(5, Decimal(5))</font>
<font color="black">4212.         Decimal('1')</font>
<font color="black">4213.         &quot;&quot;&quot;</font>
<font color="red">4214.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4215.         r = a.__div__(b, context=self)</font>
<font color="red">4216.         if r is NotImplemented:</font>
<font color="red">4217.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4218.         else:</font>
<font color="red">4219.             return r</font>
<font color="black">4220. </font>
<font color="green">4221.     def divide_int(self, a, b):</font>
<font color="black">4222.         &quot;&quot;&quot;Divides two numbers and returns the integer part of the result.</font>
<font color="black">4223. </font>
<font color="black">4224.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal('2'), Decimal('3'))</font>
<font color="black">4225.         Decimal('0')</font>
<font color="black">4226.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal('10'), Decimal('3'))</font>
<font color="black">4227.         Decimal('3')</font>
<font color="black">4228.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal('1'), Decimal('0.3'))</font>
<font color="black">4229.         Decimal('3')</font>
<font color="black">4230.         &gt;&gt;&gt; ExtendedContext.divide_int(10, 3)</font>
<font color="black">4231.         Decimal('3')</font>
<font color="black">4232.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal(10), 3)</font>
<font color="black">4233.         Decimal('3')</font>
<font color="black">4234.         &gt;&gt;&gt; ExtendedContext.divide_int(10, Decimal(3))</font>
<font color="black">4235.         Decimal('3')</font>
<font color="black">4236.         &quot;&quot;&quot;</font>
<font color="red">4237.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4238.         r = a.__floordiv__(b, context=self)</font>
<font color="red">4239.         if r is NotImplemented:</font>
<font color="red">4240.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4241.         else:</font>
<font color="red">4242.             return r</font>
<font color="black">4243. </font>
<font color="green">4244.     def divmod(self, a, b):</font>
<font color="black">4245.         &quot;&quot;&quot;Return (a // b, a % b).</font>
<font color="black">4246. </font>
<font color="black">4247.         &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(3))</font>
<font color="black">4248.         (Decimal('2'), Decimal('2'))</font>
<font color="black">4249.         &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(4))</font>
<font color="black">4250.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4251.         &gt;&gt;&gt; ExtendedContext.divmod(8, 4)</font>
<font color="black">4252.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4253.         &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), 4)</font>
<font color="black">4254.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4255.         &gt;&gt;&gt; ExtendedContext.divmod(8, Decimal(4))</font>
<font color="black">4256.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4257.         &quot;&quot;&quot;</font>
<font color="red">4258.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4259.         r = a.__divmod__(b, context=self)</font>
<font color="red">4260.         if r is NotImplemented:</font>
<font color="red">4261.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4262.         else:</font>
<font color="red">4263.             return r</font>
<font color="black">4264. </font>
<font color="green">4265.     def exp(self, a):</font>
<font color="black">4266.         &quot;&quot;&quot;Returns e ** a.</font>
<font color="black">4267. </font>
<font color="black">4268.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4269.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4270.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4271.         &gt;&gt;&gt; c.exp(Decimal('-Infinity'))</font>
<font color="black">4272.         Decimal('0')</font>
<font color="black">4273.         &gt;&gt;&gt; c.exp(Decimal('-1'))</font>
<font color="black">4274.         Decimal('0.367879441')</font>
<font color="black">4275.         &gt;&gt;&gt; c.exp(Decimal('0'))</font>
<font color="black">4276.         Decimal('1')</font>
<font color="black">4277.         &gt;&gt;&gt; c.exp(Decimal('1'))</font>
<font color="black">4278.         Decimal('2.71828183')</font>
<font color="black">4279.         &gt;&gt;&gt; c.exp(Decimal('0.693147181'))</font>
<font color="black">4280.         Decimal('2.00000000')</font>
<font color="black">4281.         &gt;&gt;&gt; c.exp(Decimal('+Infinity'))</font>
<font color="black">4282.         Decimal('Infinity')</font>
<font color="black">4283.         &gt;&gt;&gt; c.exp(10)</font>
<font color="black">4284.         Decimal('22026.4658')</font>
<font color="black">4285.         &quot;&quot;&quot;</font>
<font color="red">4286.         a =_convert_other(a, raiseit=True)</font>
<font color="red">4287.         return a.exp(context=self)</font>
<font color="black">4288. </font>
<font color="green">4289.     def fma(self, a, b, c):</font>
<font color="black">4290.         &quot;&quot;&quot;Returns a multiplied by b, plus c.</font>
<font color="black">4291. </font>
<font color="black">4292.         The first two operands are multiplied together, using multiply,</font>
<font color="black">4293.         the third operand is then added to the result of that</font>
<font color="black">4294.         multiplication, using add, all with only one final rounding.</font>
<font color="black">4295. </font>
<font color="black">4296.         &gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))</font>
<font color="black">4297.         Decimal('22')</font>
<font color="black">4298.         &gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))</font>
<font color="black">4299.         Decimal('-8')</font>
<font color="black">4300.         &gt;&gt;&gt; ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))</font>
<font color="black">4301.         Decimal('1.38435736E+12')</font>
<font color="black">4302.         &gt;&gt;&gt; ExtendedContext.fma(1, 3, 4)</font>
<font color="black">4303.         Decimal('7')</font>
<font color="black">4304.         &gt;&gt;&gt; ExtendedContext.fma(1, Decimal(3), 4)</font>
<font color="black">4305.         Decimal('7')</font>
<font color="black">4306.         &gt;&gt;&gt; ExtendedContext.fma(1, 3, Decimal(4))</font>
<font color="black">4307.         Decimal('7')</font>
<font color="black">4308.         &quot;&quot;&quot;</font>
<font color="red">4309.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4310.         return a.fma(b, c, context=self)</font>
<font color="black">4311. </font>
<font color="green">4312.     def is_canonical(self, a):</font>
<font color="black">4313.         &quot;&quot;&quot;Return True if the operand is canonical; otherwise return False.</font>
<font color="black">4314. </font>
<font color="black">4315.         Currently, the encoding of a Decimal instance is always</font>
<font color="black">4316.         canonical, so this method returns True for any Decimal.</font>
<font color="black">4317. </font>
<font color="black">4318.         &gt;&gt;&gt; ExtendedContext.is_canonical(Decimal('2.50'))</font>
<font color="black">4319.         True</font>
<font color="black">4320.         &quot;&quot;&quot;</font>
<font color="red">4321.         return a.is_canonical()</font>
<font color="black">4322. </font>
<font color="green">4323.     def is_finite(self, a):</font>
<font color="black">4324.         &quot;&quot;&quot;Return True if the operand is finite; otherwise return False.</font>
<font color="black">4325. </font>
<font color="black">4326.         A Decimal instance is considered finite if it is neither</font>
<font color="black">4327.         infinite nor a NaN.</font>
<font color="black">4328. </font>
<font color="black">4329.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('2.50'))</font>
<font color="black">4330.         True</font>
<font color="black">4331.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('-0.3'))</font>
<font color="black">4332.         True</font>
<font color="black">4333.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('0'))</font>
<font color="black">4334.         True</font>
<font color="black">4335.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('Inf'))</font>
<font color="black">4336.         False</font>
<font color="black">4337.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('NaN'))</font>
<font color="black">4338.         False</font>
<font color="black">4339.         &gt;&gt;&gt; ExtendedContext.is_finite(1)</font>
<font color="black">4340.         True</font>
<font color="black">4341.         &quot;&quot;&quot;</font>
<font color="red">4342.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4343.         return a.is_finite()</font>
<font color="black">4344. </font>
<font color="green">4345.     def is_infinite(self, a):</font>
<font color="black">4346.         &quot;&quot;&quot;Return True if the operand is infinite; otherwise return False.</font>
<font color="black">4347. </font>
<font color="black">4348.         &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('2.50'))</font>
<font color="black">4349.         False</font>
<font color="black">4350.         &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('-Inf'))</font>
<font color="black">4351.         True</font>
<font color="black">4352.         &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('NaN'))</font>
<font color="black">4353.         False</font>
<font color="black">4354.         &gt;&gt;&gt; ExtendedContext.is_infinite(1)</font>
<font color="black">4355.         False</font>
<font color="black">4356.         &quot;&quot;&quot;</font>
<font color="red">4357.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4358.         return a.is_infinite()</font>
<font color="black">4359. </font>
<font color="green">4360.     def is_nan(self, a):</font>
<font color="black">4361.         &quot;&quot;&quot;Return True if the operand is a qNaN or sNaN;</font>
<font color="black">4362.         otherwise return False.</font>
<font color="black">4363. </font>
<font color="black">4364.         &gt;&gt;&gt; ExtendedContext.is_nan(Decimal('2.50'))</font>
<font color="black">4365.         False</font>
<font color="black">4366.         &gt;&gt;&gt; ExtendedContext.is_nan(Decimal('NaN'))</font>
<font color="black">4367.         True</font>
<font color="black">4368.         &gt;&gt;&gt; ExtendedContext.is_nan(Decimal('-sNaN'))</font>
<font color="black">4369.         True</font>
<font color="black">4370.         &gt;&gt;&gt; ExtendedContext.is_nan(1)</font>
<font color="black">4371.         False</font>
<font color="black">4372.         &quot;&quot;&quot;</font>
<font color="red">4373.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4374.         return a.is_nan()</font>
<font color="black">4375. </font>
<font color="green">4376.     def is_normal(self, a):</font>
<font color="black">4377.         &quot;&quot;&quot;Return True if the operand is a normal number;</font>
<font color="black">4378.         otherwise return False.</font>
<font color="black">4379. </font>
<font color="black">4380.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4381.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4382.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4383.         &gt;&gt;&gt; c.is_normal(Decimal('2.50'))</font>
<font color="black">4384.         True</font>
<font color="black">4385.         &gt;&gt;&gt; c.is_normal(Decimal('0.1E-999'))</font>
<font color="black">4386.         False</font>
<font color="black">4387.         &gt;&gt;&gt; c.is_normal(Decimal('0.00'))</font>
<font color="black">4388.         False</font>
<font color="black">4389.         &gt;&gt;&gt; c.is_normal(Decimal('-Inf'))</font>
<font color="black">4390.         False</font>
<font color="black">4391.         &gt;&gt;&gt; c.is_normal(Decimal('NaN'))</font>
<font color="black">4392.         False</font>
<font color="black">4393.         &gt;&gt;&gt; c.is_normal(1)</font>
<font color="black">4394.         True</font>
<font color="black">4395.         &quot;&quot;&quot;</font>
<font color="red">4396.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4397.         return a.is_normal(context=self)</font>
<font color="black">4398. </font>
<font color="green">4399.     def is_qnan(self, a):</font>
<font color="black">4400.         &quot;&quot;&quot;Return True if the operand is a quiet NaN; otherwise return False.</font>
<font color="black">4401. </font>
<font color="black">4402.         &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('2.50'))</font>
<font color="black">4403.         False</font>
<font color="black">4404.         &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('NaN'))</font>
<font color="black">4405.         True</font>
<font color="black">4406.         &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('sNaN'))</font>
<font color="black">4407.         False</font>
<font color="black">4408.         &gt;&gt;&gt; ExtendedContext.is_qnan(1)</font>
<font color="black">4409.         False</font>
<font color="black">4410.         &quot;&quot;&quot;</font>
<font color="red">4411.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4412.         return a.is_qnan()</font>
<font color="black">4413. </font>
<font color="green">4414.     def is_signed(self, a):</font>
<font color="black">4415.         &quot;&quot;&quot;Return True if the operand is negative; otherwise return False.</font>
<font color="black">4416. </font>
<font color="black">4417.         &gt;&gt;&gt; ExtendedContext.is_signed(Decimal('2.50'))</font>
<font color="black">4418.         False</font>
<font color="black">4419.         &gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-12'))</font>
<font color="black">4420.         True</font>
<font color="black">4421.         &gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-0'))</font>
<font color="black">4422.         True</font>
<font color="black">4423.         &gt;&gt;&gt; ExtendedContext.is_signed(8)</font>
<font color="black">4424.         False</font>
<font color="black">4425.         &gt;&gt;&gt; ExtendedContext.is_signed(-8)</font>
<font color="black">4426.         True</font>
<font color="black">4427.         &quot;&quot;&quot;</font>
<font color="red">4428.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4429.         return a.is_signed()</font>
<font color="black">4430. </font>
<font color="green">4431.     def is_snan(self, a):</font>
<font color="black">4432.         &quot;&quot;&quot;Return True if the operand is a signaling NaN;</font>
<font color="black">4433.         otherwise return False.</font>
<font color="black">4434. </font>
<font color="black">4435.         &gt;&gt;&gt; ExtendedContext.is_snan(Decimal('2.50'))</font>
<font color="black">4436.         False</font>
<font color="black">4437.         &gt;&gt;&gt; ExtendedContext.is_snan(Decimal('NaN'))</font>
<font color="black">4438.         False</font>
<font color="black">4439.         &gt;&gt;&gt; ExtendedContext.is_snan(Decimal('sNaN'))</font>
<font color="black">4440.         True</font>
<font color="black">4441.         &gt;&gt;&gt; ExtendedContext.is_snan(1)</font>
<font color="black">4442.         False</font>
<font color="black">4443.         &quot;&quot;&quot;</font>
<font color="red">4444.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4445.         return a.is_snan()</font>
<font color="black">4446. </font>
<font color="green">4447.     def is_subnormal(self, a):</font>
<font color="black">4448.         &quot;&quot;&quot;Return True if the operand is subnormal; otherwise return False.</font>
<font color="black">4449. </font>
<font color="black">4450.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4451.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4452.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4453.         &gt;&gt;&gt; c.is_subnormal(Decimal('2.50'))</font>
<font color="black">4454.         False</font>
<font color="black">4455.         &gt;&gt;&gt; c.is_subnormal(Decimal('0.1E-999'))</font>
<font color="black">4456.         True</font>
<font color="black">4457.         &gt;&gt;&gt; c.is_subnormal(Decimal('0.00'))</font>
<font color="black">4458.         False</font>
<font color="black">4459.         &gt;&gt;&gt; c.is_subnormal(Decimal('-Inf'))</font>
<font color="black">4460.         False</font>
<font color="black">4461.         &gt;&gt;&gt; c.is_subnormal(Decimal('NaN'))</font>
<font color="black">4462.         False</font>
<font color="black">4463.         &gt;&gt;&gt; c.is_subnormal(1)</font>
<font color="black">4464.         False</font>
<font color="black">4465.         &quot;&quot;&quot;</font>
<font color="red">4466.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4467.         return a.is_subnormal(context=self)</font>
<font color="black">4468. </font>
<font color="green">4469.     def is_zero(self, a):</font>
<font color="black">4470.         &quot;&quot;&quot;Return True if the operand is a zero; otherwise return False.</font>
<font color="black">4471. </font>
<font color="black">4472.         &gt;&gt;&gt; ExtendedContext.is_zero(Decimal('0'))</font>
<font color="black">4473.         True</font>
<font color="black">4474.         &gt;&gt;&gt; ExtendedContext.is_zero(Decimal('2.50'))</font>
<font color="black">4475.         False</font>
<font color="black">4476.         &gt;&gt;&gt; ExtendedContext.is_zero(Decimal('-0E+2'))</font>
<font color="black">4477.         True</font>
<font color="black">4478.         &gt;&gt;&gt; ExtendedContext.is_zero(1)</font>
<font color="black">4479.         False</font>
<font color="black">4480.         &gt;&gt;&gt; ExtendedContext.is_zero(0)</font>
<font color="black">4481.         True</font>
<font color="black">4482.         &quot;&quot;&quot;</font>
<font color="red">4483.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4484.         return a.is_zero()</font>
<font color="black">4485. </font>
<font color="green">4486.     def ln(self, a):</font>
<font color="black">4487.         &quot;&quot;&quot;Returns the natural (base e) logarithm of the operand.</font>
<font color="black">4488. </font>
<font color="black">4489.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4490.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4491.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4492.         &gt;&gt;&gt; c.ln(Decimal('0'))</font>
<font color="black">4493.         Decimal('-Infinity')</font>
<font color="black">4494.         &gt;&gt;&gt; c.ln(Decimal('1.000'))</font>
<font color="black">4495.         Decimal('0')</font>
<font color="black">4496.         &gt;&gt;&gt; c.ln(Decimal('2.71828183'))</font>
<font color="black">4497.         Decimal('1.00000000')</font>
<font color="black">4498.         &gt;&gt;&gt; c.ln(Decimal('10'))</font>
<font color="black">4499.         Decimal('2.30258509')</font>
<font color="black">4500.         &gt;&gt;&gt; c.ln(Decimal('+Infinity'))</font>
<font color="black">4501.         Decimal('Infinity')</font>
<font color="black">4502.         &gt;&gt;&gt; c.ln(1)</font>
<font color="black">4503.         Decimal('0')</font>
<font color="black">4504.         &quot;&quot;&quot;</font>
<font color="red">4505.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4506.         return a.ln(context=self)</font>
<font color="black">4507. </font>
<font color="green">4508.     def log10(self, a):</font>
<font color="black">4509.         &quot;&quot;&quot;Returns the base 10 logarithm of the operand.</font>
<font color="black">4510. </font>
<font color="black">4511.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4512.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4513.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4514.         &gt;&gt;&gt; c.log10(Decimal('0'))</font>
<font color="black">4515.         Decimal('-Infinity')</font>
<font color="black">4516.         &gt;&gt;&gt; c.log10(Decimal('0.001'))</font>
<font color="black">4517.         Decimal('-3')</font>
<font color="black">4518.         &gt;&gt;&gt; c.log10(Decimal('1.000'))</font>
<font color="black">4519.         Decimal('0')</font>
<font color="black">4520.         &gt;&gt;&gt; c.log10(Decimal('2'))</font>
<font color="black">4521.         Decimal('0.301029996')</font>
<font color="black">4522.         &gt;&gt;&gt; c.log10(Decimal('10'))</font>
<font color="black">4523.         Decimal('1')</font>
<font color="black">4524.         &gt;&gt;&gt; c.log10(Decimal('70'))</font>
<font color="black">4525.         Decimal('1.84509804')</font>
<font color="black">4526.         &gt;&gt;&gt; c.log10(Decimal('+Infinity'))</font>
<font color="black">4527.         Decimal('Infinity')</font>
<font color="black">4528.         &gt;&gt;&gt; c.log10(0)</font>
<font color="black">4529.         Decimal('-Infinity')</font>
<font color="black">4530.         &gt;&gt;&gt; c.log10(1)</font>
<font color="black">4531.         Decimal('0')</font>
<font color="black">4532.         &quot;&quot;&quot;</font>
<font color="red">4533.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4534.         return a.log10(context=self)</font>
<font color="black">4535. </font>
<font color="green">4536.     def logb(self, a):</font>
<font color="black">4537.         &quot;&quot;&quot; Returns the exponent of the magnitude of the operand's MSD.</font>
<font color="black">4538. </font>
<font color="black">4539.         The result is the integer which is the exponent of the magnitude</font>
<font color="black">4540.         of the most significant digit of the operand (as though the</font>
<font color="black">4541.         operand were truncated to a single digit while maintaining the</font>
<font color="black">4542.         value of that digit and without limiting the resulting exponent).</font>
<font color="black">4543. </font>
<font color="black">4544.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('250'))</font>
<font color="black">4545.         Decimal('2')</font>
<font color="black">4546.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('2.50'))</font>
<font color="black">4547.         Decimal('0')</font>
<font color="black">4548.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('0.03'))</font>
<font color="black">4549.         Decimal('-2')</font>
<font color="black">4550.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('0'))</font>
<font color="black">4551.         Decimal('-Infinity')</font>
<font color="black">4552.         &gt;&gt;&gt; ExtendedContext.logb(1)</font>
<font color="black">4553.         Decimal('0')</font>
<font color="black">4554.         &gt;&gt;&gt; ExtendedContext.logb(10)</font>
<font color="black">4555.         Decimal('1')</font>
<font color="black">4556.         &gt;&gt;&gt; ExtendedContext.logb(100)</font>
<font color="black">4557.         Decimal('2')</font>
<font color="black">4558.         &quot;&quot;&quot;</font>
<font color="red">4559.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4560.         return a.logb(context=self)</font>
<font color="black">4561. </font>
<font color="green">4562.     def logical_and(self, a, b):</font>
<font color="black">4563.         &quot;&quot;&quot;Applies the logical operation 'and' between each operand's digits.</font>
<font color="black">4564. </font>
<font color="black">4565.         The operands must be both logical numbers.</font>
<font color="black">4566. </font>
<font color="black">4567.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('0'))</font>
<font color="black">4568.         Decimal('0')</font>
<font color="black">4569.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('1'))</font>
<font color="black">4570.         Decimal('0')</font>
<font color="black">4571.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('0'))</font>
<font color="black">4572.         Decimal('0')</font>
<font color="black">4573.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('1'))</font>
<font color="black">4574.         Decimal('1')</font>
<font color="black">4575.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1100'), Decimal('1010'))</font>
<font color="black">4576.         Decimal('1000')</font>
<font color="black">4577.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1111'), Decimal('10'))</font>
<font color="black">4578.         Decimal('10')</font>
<font color="black">4579.         &gt;&gt;&gt; ExtendedContext.logical_and(110, 1101)</font>
<font color="black">4580.         Decimal('100')</font>
<font color="black">4581.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(110), 1101)</font>
<font color="black">4582.         Decimal('100')</font>
<font color="black">4583.         &gt;&gt;&gt; ExtendedContext.logical_and(110, Decimal(1101))</font>
<font color="black">4584.         Decimal('100')</font>
<font color="black">4585.         &quot;&quot;&quot;</font>
<font color="red">4586.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4587.         return a.logical_and(b, context=self)</font>
<font color="black">4588. </font>
<font color="green">4589.     def logical_invert(self, a):</font>
<font color="black">4590.         &quot;&quot;&quot;Invert all the digits in the operand.</font>
<font color="black">4591. </font>
<font color="black">4592.         The operand must be a logical number.</font>
<font color="black">4593. </font>
<font color="black">4594.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('0'))</font>
<font color="black">4595.         Decimal('111111111')</font>
<font color="black">4596.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('1'))</font>
<font color="black">4597.         Decimal('111111110')</font>
<font color="black">4598.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('111111111'))</font>
<font color="black">4599.         Decimal('0')</font>
<font color="black">4600.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('101010101'))</font>
<font color="black">4601.         Decimal('10101010')</font>
<font color="black">4602.         &gt;&gt;&gt; ExtendedContext.logical_invert(1101)</font>
<font color="black">4603.         Decimal('111110010')</font>
<font color="black">4604.         &quot;&quot;&quot;</font>
<font color="red">4605.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4606.         return a.logical_invert(context=self)</font>
<font color="black">4607. </font>
<font color="green">4608.     def logical_or(self, a, b):</font>
<font color="black">4609.         &quot;&quot;&quot;Applies the logical operation 'or' between each operand's digits.</font>
<font color="black">4610. </font>
<font color="black">4611.         The operands must be both logical numbers.</font>
<font color="black">4612. </font>
<font color="black">4613.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('0'))</font>
<font color="black">4614.         Decimal('0')</font>
<font color="black">4615.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('1'))</font>
<font color="black">4616.         Decimal('1')</font>
<font color="black">4617.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('0'))</font>
<font color="black">4618.         Decimal('1')</font>
<font color="black">4619.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('1'))</font>
<font color="black">4620.         Decimal('1')</font>
<font color="black">4621.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1100'), Decimal('1010'))</font>
<font color="black">4622.         Decimal('1110')</font>
<font color="black">4623.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1110'), Decimal('10'))</font>
<font color="black">4624.         Decimal('1110')</font>
<font color="black">4625.         &gt;&gt;&gt; ExtendedContext.logical_or(110, 1101)</font>
<font color="black">4626.         Decimal('1111')</font>
<font color="black">4627.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(110), 1101)</font>
<font color="black">4628.         Decimal('1111')</font>
<font color="black">4629.         &gt;&gt;&gt; ExtendedContext.logical_or(110, Decimal(1101))</font>
<font color="black">4630.         Decimal('1111')</font>
<font color="black">4631.         &quot;&quot;&quot;</font>
<font color="red">4632.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4633.         return a.logical_or(b, context=self)</font>
<font color="black">4634. </font>
<font color="green">4635.     def logical_xor(self, a, b):</font>
<font color="black">4636.         &quot;&quot;&quot;Applies the logical operation 'xor' between each operand's digits.</font>
<font color="black">4637. </font>
<font color="black">4638.         The operands must be both logical numbers.</font>
<font color="black">4639. </font>
<font color="black">4640.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('0'))</font>
<font color="black">4641.         Decimal('0')</font>
<font color="black">4642.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('1'))</font>
<font color="black">4643.         Decimal('1')</font>
<font color="black">4644.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('0'))</font>
<font color="black">4645.         Decimal('1')</font>
<font color="black">4646.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('1'))</font>
<font color="black">4647.         Decimal('0')</font>
<font color="black">4648.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1100'), Decimal('1010'))</font>
<font color="black">4649.         Decimal('110')</font>
<font color="black">4650.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1111'), Decimal('10'))</font>
<font color="black">4651.         Decimal('1101')</font>
<font color="black">4652.         &gt;&gt;&gt; ExtendedContext.logical_xor(110, 1101)</font>
<font color="black">4653.         Decimal('1011')</font>
<font color="black">4654.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(110), 1101)</font>
<font color="black">4655.         Decimal('1011')</font>
<font color="black">4656.         &gt;&gt;&gt; ExtendedContext.logical_xor(110, Decimal(1101))</font>
<font color="black">4657.         Decimal('1011')</font>
<font color="black">4658.         &quot;&quot;&quot;</font>
<font color="red">4659.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4660.         return a.logical_xor(b, context=self)</font>
<font color="black">4661. </font>
<font color="green">4662.     def max(self, a, b):</font>
<font color="black">4663.         &quot;&quot;&quot;max compares two values numerically and returns the maximum.</font>
<font color="black">4664. </font>
<font color="black">4665.         If either operand is a NaN then the general rules apply.</font>
<font color="black">4666.         Otherwise, the operands are compared as though by the compare</font>
<font color="black">4667.         operation.  If they are numerically equal then the left-hand operand</font>
<font color="black">4668.         is chosen as the result.  Otherwise the maximum (closer to positive</font>
<font color="black">4669.         infinity) of the two operands is chosen as the result.</font>
<font color="black">4670. </font>
<font color="black">4671.         &gt;&gt;&gt; ExtendedContext.max(Decimal('3'), Decimal('2'))</font>
<font color="black">4672.         Decimal('3')</font>
<font color="black">4673.         &gt;&gt;&gt; ExtendedContext.max(Decimal('-10'), Decimal('3'))</font>
<font color="black">4674.         Decimal('3')</font>
<font color="black">4675.         &gt;&gt;&gt; ExtendedContext.max(Decimal('1.0'), Decimal('1'))</font>
<font color="black">4676.         Decimal('1')</font>
<font color="black">4677.         &gt;&gt;&gt; ExtendedContext.max(Decimal('7'), Decimal('NaN'))</font>
<font color="black">4678.         Decimal('7')</font>
<font color="black">4679.         &gt;&gt;&gt; ExtendedContext.max(1, 2)</font>
<font color="black">4680.         Decimal('2')</font>
<font color="black">4681.         &gt;&gt;&gt; ExtendedContext.max(Decimal(1), 2)</font>
<font color="black">4682.         Decimal('2')</font>
<font color="black">4683.         &gt;&gt;&gt; ExtendedContext.max(1, Decimal(2))</font>
<font color="black">4684.         Decimal('2')</font>
<font color="black">4685.         &quot;&quot;&quot;</font>
<font color="red">4686.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4687.         return a.max(b, context=self)</font>
<font color="black">4688. </font>
<font color="green">4689.     def max_mag(self, a, b):</font>
<font color="black">4690.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.</font>
<font color="black">4691. </font>
<font color="black">4692.         &gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('NaN'))</font>
<font color="black">4693.         Decimal('7')</font>
<font color="black">4694.         &gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('-10'))</font>
<font color="black">4695.         Decimal('-10')</font>
<font color="black">4696.         &gt;&gt;&gt; ExtendedContext.max_mag(1, -2)</font>
<font color="black">4697.         Decimal('-2')</font>
<font color="black">4698.         &gt;&gt;&gt; ExtendedContext.max_mag(Decimal(1), -2)</font>
<font color="black">4699.         Decimal('-2')</font>
<font color="black">4700.         &gt;&gt;&gt; ExtendedContext.max_mag(1, Decimal(-2))</font>
<font color="black">4701.         Decimal('-2')</font>
<font color="black">4702.         &quot;&quot;&quot;</font>
<font color="red">4703.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4704.         return a.max_mag(b, context=self)</font>
<font color="black">4705. </font>
<font color="green">4706.     def min(self, a, b):</font>
<font color="black">4707.         &quot;&quot;&quot;min compares two values numerically and returns the minimum.</font>
<font color="black">4708. </font>
<font color="black">4709.         If either operand is a NaN then the general rules apply.</font>
<font color="black">4710.         Otherwise, the operands are compared as though by the compare</font>
<font color="black">4711.         operation.  If they are numerically equal then the left-hand operand</font>
<font color="black">4712.         is chosen as the result.  Otherwise the minimum (closer to negative</font>
<font color="black">4713.         infinity) of the two operands is chosen as the result.</font>
<font color="black">4714. </font>
<font color="black">4715.         &gt;&gt;&gt; ExtendedContext.min(Decimal('3'), Decimal('2'))</font>
<font color="black">4716.         Decimal('2')</font>
<font color="black">4717.         &gt;&gt;&gt; ExtendedContext.min(Decimal('-10'), Decimal('3'))</font>
<font color="black">4718.         Decimal('-10')</font>
<font color="black">4719.         &gt;&gt;&gt; ExtendedContext.min(Decimal('1.0'), Decimal('1'))</font>
<font color="black">4720.         Decimal('1.0')</font>
<font color="black">4721.         &gt;&gt;&gt; ExtendedContext.min(Decimal('7'), Decimal('NaN'))</font>
<font color="black">4722.         Decimal('7')</font>
<font color="black">4723.         &gt;&gt;&gt; ExtendedContext.min(1, 2)</font>
<font color="black">4724.         Decimal('1')</font>
<font color="black">4725.         &gt;&gt;&gt; ExtendedContext.min(Decimal(1), 2)</font>
<font color="black">4726.         Decimal('1')</font>
<font color="black">4727.         &gt;&gt;&gt; ExtendedContext.min(1, Decimal(29))</font>
<font color="black">4728.         Decimal('1')</font>
<font color="black">4729.         &quot;&quot;&quot;</font>
<font color="red">4730.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4731.         return a.min(b, context=self)</font>
<font color="black">4732. </font>
<font color="green">4733.     def min_mag(self, a, b):</font>
<font color="black">4734.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.</font>
<font color="black">4735. </font>
<font color="black">4736.         &gt;&gt;&gt; ExtendedContext.min_mag(Decimal('3'), Decimal('-2'))</font>
<font color="black">4737.         Decimal('-2')</font>
<font color="black">4738.         &gt;&gt;&gt; ExtendedContext.min_mag(Decimal('-3'), Decimal('NaN'))</font>
<font color="black">4739.         Decimal('-3')</font>
<font color="black">4740.         &gt;&gt;&gt; ExtendedContext.min_mag(1, -2)</font>
<font color="black">4741.         Decimal('1')</font>
<font color="black">4742.         &gt;&gt;&gt; ExtendedContext.min_mag(Decimal(1), -2)</font>
<font color="black">4743.         Decimal('1')</font>
<font color="black">4744.         &gt;&gt;&gt; ExtendedContext.min_mag(1, Decimal(-2))</font>
<font color="black">4745.         Decimal('1')</font>
<font color="black">4746.         &quot;&quot;&quot;</font>
<font color="red">4747.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4748.         return a.min_mag(b, context=self)</font>
<font color="black">4749. </font>
<font color="green">4750.     def minus(self, a):</font>
<font color="black">4751.         &quot;&quot;&quot;Minus corresponds to unary prefix minus in Python.</font>
<font color="black">4752. </font>
<font color="black">4753.         The operation is evaluated using the same rules as subtract; the</font>
<font color="black">4754.         operation minus(a) is calculated as subtract('0', a) where the '0'</font>
<font color="black">4755.         has the same exponent as the operand.</font>
<font color="black">4756. </font>
<font color="black">4757.         &gt;&gt;&gt; ExtendedContext.minus(Decimal('1.3'))</font>
<font color="black">4758.         Decimal('-1.3')</font>
<font color="black">4759.         &gt;&gt;&gt; ExtendedContext.minus(Decimal('-1.3'))</font>
<font color="black">4760.         Decimal('1.3')</font>
<font color="black">4761.         &gt;&gt;&gt; ExtendedContext.minus(1)</font>
<font color="black">4762.         Decimal('-1')</font>
<font color="black">4763.         &quot;&quot;&quot;</font>
<font color="red">4764.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4765.         return a.__neg__(context=self)</font>
<font color="black">4766. </font>
<font color="green">4767.     def multiply(self, a, b):</font>
<font color="black">4768.         &quot;&quot;&quot;multiply multiplies two operands.</font>
<font color="black">4769. </font>
<font color="black">4770.         If either operand is a special value then the general rules apply.</font>
<font color="black">4771.         Otherwise, the operands are multiplied together</font>
<font color="black">4772.         ('long multiplication'), resulting in a number which may be as long as</font>
<font color="black">4773.         the sum of the lengths of the two operands.</font>
<font color="black">4774. </font>
<font color="black">4775.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('1.20'), Decimal('3'))</font>
<font color="black">4776.         Decimal('3.60')</font>
<font color="black">4777.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('7'), Decimal('3'))</font>
<font color="black">4778.         Decimal('21')</font>
<font color="black">4779.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('0.8'))</font>
<font color="black">4780.         Decimal('0.72')</font>
<font color="black">4781.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('-0'))</font>
<font color="black">4782.         Decimal('-0.0')</font>
<font color="black">4783.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('654321'), Decimal('654321'))</font>
<font color="black">4784.         Decimal('4.28135971E+11')</font>
<font color="black">4785.         &gt;&gt;&gt; ExtendedContext.multiply(7, 7)</font>
<font color="black">4786.         Decimal('49')</font>
<font color="black">4787.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal(7), 7)</font>
<font color="black">4788.         Decimal('49')</font>
<font color="black">4789.         &gt;&gt;&gt; ExtendedContext.multiply(7, Decimal(7))</font>
<font color="black">4790.         Decimal('49')</font>
<font color="black">4791.         &quot;&quot;&quot;</font>
<font color="red">4792.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4793.         r = a.__mul__(b, context=self)</font>
<font color="red">4794.         if r is NotImplemented:</font>
<font color="red">4795.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4796.         else:</font>
<font color="red">4797.             return r</font>
<font color="black">4798. </font>
<font color="green">4799.     def next_minus(self, a):</font>
<font color="black">4800.         &quot;&quot;&quot;Returns the largest representable number smaller than a.</font>
<font color="black">4801. </font>
<font color="black">4802.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4803.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4804.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4805.         &gt;&gt;&gt; ExtendedContext.next_minus(Decimal('1'))</font>
<font color="black">4806.         Decimal('0.999999999')</font>
<font color="black">4807.         &gt;&gt;&gt; c.next_minus(Decimal('1E-1007'))</font>
<font color="black">4808.         Decimal('0E-1007')</font>
<font color="black">4809.         &gt;&gt;&gt; ExtendedContext.next_minus(Decimal('-1.00000003'))</font>
<font color="black">4810.         Decimal('-1.00000004')</font>
<font color="black">4811.         &gt;&gt;&gt; c.next_minus(Decimal('Infinity'))</font>
<font color="black">4812.         Decimal('9.99999999E+999')</font>
<font color="black">4813.         &gt;&gt;&gt; c.next_minus(1)</font>
<font color="black">4814.         Decimal('0.999999999')</font>
<font color="black">4815.         &quot;&quot;&quot;</font>
<font color="red">4816.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4817.         return a.next_minus(context=self)</font>
<font color="black">4818. </font>
<font color="green">4819.     def next_plus(self, a):</font>
<font color="black">4820.         &quot;&quot;&quot;Returns the smallest representable number larger than a.</font>
<font color="black">4821. </font>
<font color="black">4822.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4823.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4824.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4825.         &gt;&gt;&gt; ExtendedContext.next_plus(Decimal('1'))</font>
<font color="black">4826.         Decimal('1.00000001')</font>
<font color="black">4827.         &gt;&gt;&gt; c.next_plus(Decimal('-1E-1007'))</font>
<font color="black">4828.         Decimal('-0E-1007')</font>
<font color="black">4829.         &gt;&gt;&gt; ExtendedContext.next_plus(Decimal('-1.00000003'))</font>
<font color="black">4830.         Decimal('-1.00000002')</font>
<font color="black">4831.         &gt;&gt;&gt; c.next_plus(Decimal('-Infinity'))</font>
<font color="black">4832.         Decimal('-9.99999999E+999')</font>
<font color="black">4833.         &gt;&gt;&gt; c.next_plus(1)</font>
<font color="black">4834.         Decimal('1.00000001')</font>
<font color="black">4835.         &quot;&quot;&quot;</font>
<font color="red">4836.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4837.         return a.next_plus(context=self)</font>
<font color="black">4838. </font>
<font color="green">4839.     def next_toward(self, a, b):</font>
<font color="black">4840.         &quot;&quot;&quot;Returns the number closest to a, in direction towards b.</font>
<font color="black">4841. </font>
<font color="black">4842.         The result is the closest representable number from the first</font>
<font color="black">4843.         operand (but not the first operand) that is in the direction</font>
<font color="black">4844.         towards the second operand, unless the operands have the same</font>
<font color="black">4845.         value.</font>
<font color="black">4846. </font>
<font color="black">4847.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4848.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4849.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4850.         &gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('2'))</font>
<font color="black">4851.         Decimal('1.00000001')</font>
<font color="black">4852.         &gt;&gt;&gt; c.next_toward(Decimal('-1E-1007'), Decimal('1'))</font>
<font color="black">4853.         Decimal('-0E-1007')</font>
<font color="black">4854.         &gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('0'))</font>
<font color="black">4855.         Decimal('-1.00000002')</font>
<font color="black">4856.         &gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('0'))</font>
<font color="black">4857.         Decimal('0.999999999')</font>
<font color="black">4858.         &gt;&gt;&gt; c.next_toward(Decimal('1E-1007'), Decimal('-100'))</font>
<font color="black">4859.         Decimal('0E-1007')</font>
<font color="black">4860.         &gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('-10'))</font>
<font color="black">4861.         Decimal('-1.00000004')</font>
<font color="black">4862.         &gt;&gt;&gt; c.next_toward(Decimal('0.00'), Decimal('-0.0000'))</font>
<font color="black">4863.         Decimal('-0.00')</font>
<font color="black">4864.         &gt;&gt;&gt; c.next_toward(0, 1)</font>
<font color="black">4865.         Decimal('1E-1007')</font>
<font color="black">4866.         &gt;&gt;&gt; c.next_toward(Decimal(0), 1)</font>
<font color="black">4867.         Decimal('1E-1007')</font>
<font color="black">4868.         &gt;&gt;&gt; c.next_toward(0, Decimal(1))</font>
<font color="black">4869.         Decimal('1E-1007')</font>
<font color="black">4870.         &quot;&quot;&quot;</font>
<font color="red">4871.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4872.         return a.next_toward(b, context=self)</font>
<font color="black">4873. </font>
<font color="green">4874.     def normalize(self, a):</font>
<font color="black">4875.         &quot;&quot;&quot;normalize reduces an operand to its simplest form.</font>
<font color="black">4876. </font>
<font color="black">4877.         Essentially a plus operation with all trailing zeros removed from the</font>
<font color="black">4878.         result.</font>
<font color="black">4879. </font>
<font color="black">4880.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('2.1'))</font>
<font color="black">4881.         Decimal('2.1')</font>
<font color="black">4882.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('-2.0'))</font>
<font color="black">4883.         Decimal('-2')</font>
<font color="black">4884.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('1.200'))</font>
<font color="black">4885.         Decimal('1.2')</font>
<font color="black">4886.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('-120'))</font>
<font color="black">4887.         Decimal('-1.2E+2')</font>
<font color="black">4888.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('120.00'))</font>
<font color="black">4889.         Decimal('1.2E+2')</font>
<font color="black">4890.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('0.00'))</font>
<font color="black">4891.         Decimal('0')</font>
<font color="black">4892.         &gt;&gt;&gt; ExtendedContext.normalize(6)</font>
<font color="black">4893.         Decimal('6')</font>
<font color="black">4894.         &quot;&quot;&quot;</font>
<font color="red">4895.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4896.         return a.normalize(context=self)</font>
<font color="black">4897. </font>
<font color="green">4898.     def number_class(self, a):</font>
<font color="black">4899.         &quot;&quot;&quot;Returns an indication of the class of the operand.</font>
<font color="black">4900. </font>
<font color="black">4901.         The class is one of the following strings:</font>
<font color="black">4902.           -sNaN</font>
<font color="black">4903.           -NaN</font>
<font color="black">4904.           -Infinity</font>
<font color="black">4905.           -Normal</font>
<font color="black">4906.           -Subnormal</font>
<font color="black">4907.           -Zero</font>
<font color="black">4908.           +Zero</font>
<font color="black">4909.           +Subnormal</font>
<font color="black">4910.           +Normal</font>
<font color="black">4911.           +Infinity</font>
<font color="black">4912. </font>
<font color="black">4913.         &gt;&gt;&gt; c = Context(ExtendedContext)</font>
<font color="black">4914.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4915.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4916.         &gt;&gt;&gt; c.number_class(Decimal('Infinity'))</font>
<font color="black">4917.         '+Infinity'</font>
<font color="black">4918.         &gt;&gt;&gt; c.number_class(Decimal('1E-10'))</font>
<font color="black">4919.         '+Normal'</font>
<font color="black">4920.         &gt;&gt;&gt; c.number_class(Decimal('2.50'))</font>
<font color="black">4921.         '+Normal'</font>
<font color="black">4922.         &gt;&gt;&gt; c.number_class(Decimal('0.1E-999'))</font>
<font color="black">4923.         '+Subnormal'</font>
<font color="black">4924.         &gt;&gt;&gt; c.number_class(Decimal('0'))</font>
<font color="black">4925.         '+Zero'</font>
<font color="black">4926.         &gt;&gt;&gt; c.number_class(Decimal('-0'))</font>
<font color="black">4927.         '-Zero'</font>
<font color="black">4928.         &gt;&gt;&gt; c.number_class(Decimal('-0.1E-999'))</font>
<font color="black">4929.         '-Subnormal'</font>
<font color="black">4930.         &gt;&gt;&gt; c.number_class(Decimal('-1E-10'))</font>
<font color="black">4931.         '-Normal'</font>
<font color="black">4932.         &gt;&gt;&gt; c.number_class(Decimal('-2.50'))</font>
<font color="black">4933.         '-Normal'</font>
<font color="black">4934.         &gt;&gt;&gt; c.number_class(Decimal('-Infinity'))</font>
<font color="black">4935.         '-Infinity'</font>
<font color="black">4936.         &gt;&gt;&gt; c.number_class(Decimal('NaN'))</font>
<font color="black">4937.         'NaN'</font>
<font color="black">4938.         &gt;&gt;&gt; c.number_class(Decimal('-NaN'))</font>
<font color="black">4939.         'NaN'</font>
<font color="black">4940.         &gt;&gt;&gt; c.number_class(Decimal('sNaN'))</font>
<font color="black">4941.         'sNaN'</font>
<font color="black">4942.         &gt;&gt;&gt; c.number_class(123)</font>
<font color="black">4943.         '+Normal'</font>
<font color="black">4944.         &quot;&quot;&quot;</font>
<font color="red">4945.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4946.         return a.number_class(context=self)</font>
<font color="black">4947. </font>
<font color="green">4948.     def plus(self, a):</font>
<font color="black">4949.         &quot;&quot;&quot;Plus corresponds to unary prefix plus in Python.</font>
<font color="black">4950. </font>
<font color="black">4951.         The operation is evaluated using the same rules as add; the</font>
<font color="black">4952.         operation plus(a) is calculated as add('0', a) where the '0'</font>
<font color="black">4953.         has the same exponent as the operand.</font>
<font color="black">4954. </font>
<font color="black">4955.         &gt;&gt;&gt; ExtendedContext.plus(Decimal('1.3'))</font>
<font color="black">4956.         Decimal('1.3')</font>
<font color="black">4957.         &gt;&gt;&gt; ExtendedContext.plus(Decimal('-1.3'))</font>
<font color="black">4958.         Decimal('-1.3')</font>
<font color="black">4959.         &gt;&gt;&gt; ExtendedContext.plus(-1)</font>
<font color="black">4960.         Decimal('-1')</font>
<font color="black">4961.         &quot;&quot;&quot;</font>
<font color="red">4962.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4963.         return a.__pos__(context=self)</font>
<font color="black">4964. </font>
<font color="green">4965.     def power(self, a, b, modulo=None):</font>
<font color="black">4966.         &quot;&quot;&quot;Raises a to the power of b, to modulo if given.</font>
<font color="black">4967. </font>
<font color="black">4968.         With two arguments, compute a**b.  If a is negative then b</font>
<font color="black">4969.         must be integral.  The result will be inexact unless b is</font>
<font color="black">4970.         integral and the result is finite and can be expressed exactly</font>
<font color="black">4971.         in 'precision' digits.</font>
<font color="black">4972. </font>
<font color="black">4973.         With three arguments, compute (a**b) % modulo.  For the</font>
<font color="black">4974.         three argument form, the following restrictions on the</font>
<font color="black">4975.         arguments hold:</font>
<font color="black">4976. </font>
<font color="black">4977.          - all three arguments must be integral</font>
<font color="black">4978.          - b must be nonnegative</font>
<font color="black">4979.          - at least one of a or b must be nonzero</font>
<font color="black">4980.          - modulo must be nonzero and have at most 'precision' digits</font>
<font color="black">4981. </font>
<font color="black">4982.         The result of pow(a, b, modulo) is identical to the result</font>
<font color="black">4983.         that would be obtained by computing (a**b) % modulo with</font>
<font color="black">4984.         unbounded precision, but is computed more efficiently.  It is</font>
<font color="black">4985.         always exact.</font>
<font color="black">4986. </font>
<font color="black">4987.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4988.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4989.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4990.         &gt;&gt;&gt; c.power(Decimal('2'), Decimal('3'))</font>
<font color="black">4991.         Decimal('8')</font>
<font color="black">4992.         &gt;&gt;&gt; c.power(Decimal('-2'), Decimal('3'))</font>
<font color="black">4993.         Decimal('-8')</font>
<font color="black">4994.         &gt;&gt;&gt; c.power(Decimal('2'), Decimal('-3'))</font>
<font color="black">4995.         Decimal('0.125')</font>
<font color="black">4996.         &gt;&gt;&gt; c.power(Decimal('1.7'), Decimal('8'))</font>
<font color="black">4997.         Decimal('69.7575744')</font>
<font color="black">4998.         &gt;&gt;&gt; c.power(Decimal('10'), Decimal('0.301029996'))</font>
<font color="black">4999.         Decimal('2.00000000')</font>
<font color="black">5000.         &gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('-1'))</font>
<font color="black">5001.         Decimal('0')</font>
<font color="black">5002.         &gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('0'))</font>
<font color="black">5003.         Decimal('1')</font>
<font color="black">5004.         &gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('1'))</font>
<font color="black">5005.         Decimal('Infinity')</font>
<font color="black">5006.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('-1'))</font>
<font color="black">5007.         Decimal('-0')</font>
<font color="black">5008.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('0'))</font>
<font color="black">5009.         Decimal('1')</font>
<font color="black">5010.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('1'))</font>
<font color="black">5011.         Decimal('-Infinity')</font>
<font color="black">5012.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('2'))</font>
<font color="black">5013.         Decimal('Infinity')</font>
<font color="black">5014.         &gt;&gt;&gt; c.power(Decimal('0'), Decimal('0'))</font>
<font color="black">5015.         Decimal('NaN')</font>
<font color="black">5016. </font>
<font color="black">5017.         &gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('16'))</font>
<font color="black">5018.         Decimal('11')</font>
<font color="black">5019.         &gt;&gt;&gt; c.power(Decimal('-3'), Decimal('7'), Decimal('16'))</font>
<font color="black">5020.         Decimal('-11')</font>
<font color="black">5021.         &gt;&gt;&gt; c.power(Decimal('-3'), Decimal('8'), Decimal('16'))</font>
<font color="black">5022.         Decimal('1')</font>
<font color="black">5023.         &gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('-16'))</font>
<font color="black">5024.         Decimal('11')</font>
<font color="black">5025.         &gt;&gt;&gt; c.power(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))</font>
<font color="black">5026.         Decimal('11729830')</font>
<font color="black">5027.         &gt;&gt;&gt; c.power(Decimal('-0'), Decimal('17'), Decimal('1729'))</font>
<font color="black">5028.         Decimal('-0')</font>
<font color="black">5029.         &gt;&gt;&gt; c.power(Decimal('-23'), Decimal('0'), Decimal('65537'))</font>
<font color="black">5030.         Decimal('1')</font>
<font color="black">5031.         &gt;&gt;&gt; ExtendedContext.power(7, 7)</font>
<font color="black">5032.         Decimal('823543')</font>
<font color="black">5033.         &gt;&gt;&gt; ExtendedContext.power(Decimal(7), 7)</font>
<font color="black">5034.         Decimal('823543')</font>
<font color="black">5035.         &gt;&gt;&gt; ExtendedContext.power(7, Decimal(7), 2)</font>
<font color="black">5036.         Decimal('1')</font>
<font color="black">5037.         &quot;&quot;&quot;</font>
<font color="red">5038.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5039.         r = a.__pow__(b, modulo, context=self)</font>
<font color="red">5040.         if r is NotImplemented:</font>
<font color="red">5041.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">5042.         else:</font>
<font color="red">5043.             return r</font>
<font color="black">5044. </font>
<font color="green">5045.     def quantize(self, a, b):</font>
<font color="black">5046.         &quot;&quot;&quot;Returns a value equal to 'a' (rounded), having the exponent of 'b'.</font>
<font color="black">5047. </font>
<font color="black">5048.         The coefficient of the result is derived from that of the left-hand</font>
<font color="black">5049.         operand.  It may be rounded using the current rounding setting (if the</font>
<font color="black">5050.         exponent is being increased), multiplied by a positive power of ten (if</font>
<font color="black">5051.         the exponent is being decreased), or is unchanged (if the exponent is</font>
<font color="black">5052.         already equal to that of the right-hand operand).</font>
<font color="black">5053. </font>
<font color="black">5054.         Unlike other operations, if the length of the coefficient after the</font>
<font color="black">5055.         quantize operation would be greater than precision then an Invalid</font>
<font color="black">5056.         operation condition is raised.  This guarantees that, unless there is</font>
<font color="black">5057.         an error condition, the exponent of the result of a quantize is always</font>
<font color="black">5058.         equal to that of the right-hand operand.</font>
<font color="black">5059. </font>
<font color="black">5060.         Also unlike other operations, quantize will never raise Underflow, even</font>
<font color="black">5061.         if the result is subnormal and inexact.</font>
<font color="black">5062. </font>
<font color="black">5063.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))</font>
<font color="black">5064.         Decimal('2.170')</font>
<font color="black">5065.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))</font>
<font color="black">5066.         Decimal('2.17')</font>
<font color="black">5067.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))</font>
<font color="black">5068.         Decimal('2.2')</font>
<font color="black">5069.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))</font>
<font color="black">5070.         Decimal('2')</font>
<font color="black">5071.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))</font>
<font color="black">5072.         Decimal('0E+1')</font>
<font color="black">5073.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-Inf'), Decimal('Infinity'))</font>
<font color="black">5074.         Decimal('-Infinity')</font>
<font color="black">5075.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2'), Decimal('Infinity'))</font>
<font color="black">5076.         Decimal('NaN')</font>
<font color="black">5077.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))</font>
<font color="black">5078.         Decimal('-0')</font>
<font color="black">5079.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))</font>
<font color="black">5080.         Decimal('-0E+5')</font>
<font color="black">5081.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))</font>
<font color="black">5082.         Decimal('NaN')</font>
<font color="black">5083.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))</font>
<font color="black">5084.         Decimal('NaN')</font>
<font color="black">5085.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))</font>
<font color="black">5086.         Decimal('217.0')</font>
<font color="black">5087.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))</font>
<font color="black">5088.         Decimal('217')</font>
<font color="black">5089.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))</font>
<font color="black">5090.         Decimal('2.2E+2')</font>
<font color="black">5091.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))</font>
<font color="black">5092.         Decimal('2E+2')</font>
<font color="black">5093.         &gt;&gt;&gt; ExtendedContext.quantize(1, 2)</font>
<font color="black">5094.         Decimal('1')</font>
<font color="black">5095.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal(1), 2)</font>
<font color="black">5096.         Decimal('1')</font>
<font color="black">5097.         &gt;&gt;&gt; ExtendedContext.quantize(1, Decimal(2))</font>
<font color="black">5098.         Decimal('1')</font>
<font color="black">5099.         &quot;&quot;&quot;</font>
<font color="red">5100.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5101.         return a.quantize(b, context=self)</font>
<font color="black">5102. </font>
<font color="green">5103.     def radix(self):</font>
<font color="black">5104.         &quot;&quot;&quot;Just returns 10, as this is Decimal, :)</font>
<font color="black">5105. </font>
<font color="black">5106.         &gt;&gt;&gt; ExtendedContext.radix()</font>
<font color="black">5107.         Decimal('10')</font>
<font color="black">5108.         &quot;&quot;&quot;</font>
<font color="red">5109.         return Decimal(10)</font>
<font color="black">5110. </font>
<font color="green">5111.     def remainder(self, a, b):</font>
<font color="black">5112.         &quot;&quot;&quot;Returns the remainder from integer division.</font>
<font color="black">5113. </font>
<font color="black">5114.         The result is the residue of the dividend after the operation of</font>
<font color="black">5115.         calculating integer division as described for divide-integer, rounded</font>
<font color="black">5116.         to precision digits if necessary.  The sign of the result, if</font>
<font color="black">5117.         non-zero, is the same as that of the original dividend.</font>
<font color="black">5118. </font>
<font color="black">5119.         This operation will fail under the same conditions as integer division</font>
<font color="black">5120.         (that is, if integer division on the same two operands would fail, the</font>
<font color="black">5121.         remainder cannot be calculated).</font>
<font color="black">5122. </font>
<font color="black">5123.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('2.1'), Decimal('3'))</font>
<font color="black">5124.         Decimal('2.1')</font>
<font color="black">5125.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('3'))</font>
<font color="black">5126.         Decimal('1')</font>
<font color="black">5127.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('-10'), Decimal('3'))</font>
<font color="black">5128.         Decimal('-1')</font>
<font color="black">5129.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('10.2'), Decimal('1'))</font>
<font color="black">5130.         Decimal('0.2')</font>
<font color="black">5131.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('0.3'))</font>
<font color="black">5132.         Decimal('0.1')</font>
<font color="black">5133.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('3.6'), Decimal('1.3'))</font>
<font color="black">5134.         Decimal('1.0')</font>
<font color="black">5135.         &gt;&gt;&gt; ExtendedContext.remainder(22, 6)</font>
<font color="black">5136.         Decimal('4')</font>
<font color="black">5137.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal(22), 6)</font>
<font color="black">5138.         Decimal('4')</font>
<font color="black">5139.         &gt;&gt;&gt; ExtendedContext.remainder(22, Decimal(6))</font>
<font color="black">5140.         Decimal('4')</font>
<font color="black">5141.         &quot;&quot;&quot;</font>
<font color="red">5142.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5143.         r = a.__mod__(b, context=self)</font>
<font color="red">5144.         if r is NotImplemented:</font>
<font color="red">5145.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">5146.         else:</font>
<font color="red">5147.             return r</font>
<font color="black">5148. </font>
<font color="green">5149.     def remainder_near(self, a, b):</font>
<font color="black">5150.         &quot;&quot;&quot;Returns to be &quot;a - b * n&quot;, where n is the integer nearest the exact</font>
<font color="black">5151.         value of &quot;x / b&quot; (if two integers are equally near then the even one</font>
<font color="black">5152.         is chosen).  If the result is equal to 0 then its sign will be the</font>
<font color="black">5153.         sign of a.</font>
<font color="black">5154. </font>
<font color="black">5155.         This operation will fail under the same conditions as integer division</font>
<font color="black">5156.         (that is, if integer division on the same two operands would fail, the</font>
<font color="black">5157.         remainder cannot be calculated).</font>
<font color="black">5158. </font>
<font color="black">5159.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('2.1'), Decimal('3'))</font>
<font color="black">5160.         Decimal('-0.9')</font>
<font color="black">5161.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('6'))</font>
<font color="black">5162.         Decimal('-2')</font>
<font color="black">5163.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('3'))</font>
<font color="black">5164.         Decimal('1')</font>
<font color="black">5165.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('-10'), Decimal('3'))</font>
<font color="black">5166.         Decimal('-1')</font>
<font color="black">5167.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10.2'), Decimal('1'))</font>
<font color="black">5168.         Decimal('0.2')</font>
<font color="black">5169.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('0.3'))</font>
<font color="black">5170.         Decimal('0.1')</font>
<font color="black">5171.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('3.6'), Decimal('1.3'))</font>
<font color="black">5172.         Decimal('-0.3')</font>
<font color="black">5173.         &gt;&gt;&gt; ExtendedContext.remainder_near(3, 11)</font>
<font color="black">5174.         Decimal('3')</font>
<font color="black">5175.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(3), 11)</font>
<font color="black">5176.         Decimal('3')</font>
<font color="black">5177.         &gt;&gt;&gt; ExtendedContext.remainder_near(3, Decimal(11))</font>
<font color="black">5178.         Decimal('3')</font>
<font color="black">5179.         &quot;&quot;&quot;</font>
<font color="red">5180.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5181.         return a.remainder_near(b, context=self)</font>
<font color="black">5182. </font>
<font color="green">5183.     def rotate(self, a, b):</font>
<font color="black">5184.         &quot;&quot;&quot;Returns a rotated copy of a, b times.</font>
<font color="black">5185. </font>
<font color="black">5186.         The coefficient of the result is a rotated copy of the digits in</font>
<font color="black">5187.         the coefficient of the first operand.  The number of places of</font>
<font color="black">5188.         rotation is taken from the absolute value of the second operand,</font>
<font color="black">5189.         with the rotation being to the left if the second operand is</font>
<font color="black">5190.         positive or to the right otherwise.</font>
<font color="black">5191. </font>
<font color="black">5192.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('34'), Decimal('8'))</font>
<font color="black">5193.         Decimal('400000003')</font>
<font color="black">5194.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('12'), Decimal('9'))</font>
<font color="black">5195.         Decimal('12')</font>
<font color="black">5196.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('-2'))</font>
<font color="black">5197.         Decimal('891234567')</font>
<font color="black">5198.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('0'))</font>
<font color="black">5199.         Decimal('123456789')</font>
<font color="black">5200.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('+2'))</font>
<font color="black">5201.         Decimal('345678912')</font>
<font color="black">5202.         &gt;&gt;&gt; ExtendedContext.rotate(1333333, 1)</font>
<font color="black">5203.         Decimal('13333330')</font>
<font color="black">5204.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal(1333333), 1)</font>
<font color="black">5205.         Decimal('13333330')</font>
<font color="black">5206.         &gt;&gt;&gt; ExtendedContext.rotate(1333333, Decimal(1))</font>
<font color="black">5207.         Decimal('13333330')</font>
<font color="black">5208.         &quot;&quot;&quot;</font>
<font color="red">5209.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5210.         return a.rotate(b, context=self)</font>
<font color="black">5211. </font>
<font color="green">5212.     def same_quantum(self, a, b):</font>
<font color="black">5213.         &quot;&quot;&quot;Returns True if the two operands have the same exponent.</font>
<font color="black">5214. </font>
<font color="black">5215.         The result is never affected by either the sign or the coefficient of</font>
<font color="black">5216.         either operand.</font>
<font color="black">5217. </font>
<font color="black">5218.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))</font>
<font color="black">5219.         False</font>
<font color="black">5220.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))</font>
<font color="black">5221.         True</font>
<font color="black">5222.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))</font>
<font color="black">5223.         False</font>
<font color="black">5224.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))</font>
<font color="black">5225.         True</font>
<font color="black">5226.         &gt;&gt;&gt; ExtendedContext.same_quantum(10000, -1)</font>
<font color="black">5227.         True</font>
<font color="black">5228.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(10000), -1)</font>
<font color="black">5229.         True</font>
<font color="black">5230.         &gt;&gt;&gt; ExtendedContext.same_quantum(10000, Decimal(-1))</font>
<font color="black">5231.         True</font>
<font color="black">5232.         &quot;&quot;&quot;</font>
<font color="red">5233.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5234.         return a.same_quantum(b)</font>
<font color="black">5235. </font>
<font color="green">5236.     def scaleb (self, a, b):</font>
<font color="black">5237.         &quot;&quot;&quot;Returns the first operand after adding the second value its exp.</font>
<font color="black">5238. </font>
<font color="black">5239.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))</font>
<font color="black">5240.         Decimal('0.0750')</font>
<font color="black">5241.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))</font>
<font color="black">5242.         Decimal('7.50')</font>
<font color="black">5243.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))</font>
<font color="black">5244.         Decimal('7.50E+3')</font>
<font color="black">5245.         &gt;&gt;&gt; ExtendedContext.scaleb(1, 4)</font>
<font color="black">5246.         Decimal('1E+4')</font>
<font color="black">5247.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal(1), 4)</font>
<font color="black">5248.         Decimal('1E+4')</font>
<font color="black">5249.         &gt;&gt;&gt; ExtendedContext.scaleb(1, Decimal(4))</font>
<font color="black">5250.         Decimal('1E+4')</font>
<font color="black">5251.         &quot;&quot;&quot;</font>
<font color="red">5252.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5253.         return a.scaleb(b, context=self)</font>
<font color="black">5254. </font>
<font color="green">5255.     def shift(self, a, b):</font>
<font color="black">5256.         &quot;&quot;&quot;Returns a shifted copy of a, b times.</font>
<font color="black">5257. </font>
<font color="black">5258.         The coefficient of the result is a shifted copy of the digits</font>
<font color="black">5259.         in the coefficient of the first operand.  The number of places</font>
<font color="black">5260.         to shift is taken from the absolute value of the second operand,</font>
<font color="black">5261.         with the shift being to the left if the second operand is</font>
<font color="black">5262.         positive or to the right otherwise.  Digits shifted into the</font>
<font color="black">5263.         coefficient are zeros.</font>
<font color="black">5264. </font>
<font color="black">5265.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('34'), Decimal('8'))</font>
<font color="black">5266.         Decimal('400000000')</font>
<font color="black">5267.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('12'), Decimal('9'))</font>
<font color="black">5268.         Decimal('0')</font>
<font color="black">5269.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('-2'))</font>
<font color="black">5270.         Decimal('1234567')</font>
<font color="black">5271.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('0'))</font>
<font color="black">5272.         Decimal('123456789')</font>
<font color="black">5273.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('+2'))</font>
<font color="black">5274.         Decimal('345678900')</font>
<font color="black">5275.         &gt;&gt;&gt; ExtendedContext.shift(88888888, 2)</font>
<font color="black">5276.         Decimal('888888800')</font>
<font color="black">5277.         &gt;&gt;&gt; ExtendedContext.shift(Decimal(88888888), 2)</font>
<font color="black">5278.         Decimal('888888800')</font>
<font color="black">5279.         &gt;&gt;&gt; ExtendedContext.shift(88888888, Decimal(2))</font>
<font color="black">5280.         Decimal('888888800')</font>
<font color="black">5281.         &quot;&quot;&quot;</font>
<font color="red">5282.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5283.         return a.shift(b, context=self)</font>
<font color="black">5284. </font>
<font color="green">5285.     def sqrt(self, a):</font>
<font color="black">5286.         &quot;&quot;&quot;Square root of a non-negative number to context precision.</font>
<font color="black">5287. </font>
<font color="black">5288.         If the result must be inexact, it is rounded using the round-half-even</font>
<font color="black">5289.         algorithm.</font>
<font color="black">5290. </font>
<font color="black">5291.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0'))</font>
<font color="black">5292.         Decimal('0')</font>
<font color="black">5293.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('-0'))</font>
<font color="black">5294.         Decimal('-0')</font>
<font color="black">5295.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0.39'))</font>
<font color="black">5296.         Decimal('0.624499800')</font>
<font color="black">5297.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('100'))</font>
<font color="black">5298.         Decimal('10')</font>
<font color="black">5299.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1'))</font>
<font color="black">5300.         Decimal('1')</font>
<font color="black">5301.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.0'))</font>
<font color="black">5302.         Decimal('1.0')</font>
<font color="black">5303.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.00'))</font>
<font color="black">5304.         Decimal('1.0')</font>
<font color="black">5305.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('7'))</font>
<font color="black">5306.         Decimal('2.64575131')</font>
<font color="black">5307.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('10'))</font>
<font color="black">5308.         Decimal('3.16227766')</font>
<font color="black">5309.         &gt;&gt;&gt; ExtendedContext.sqrt(2)</font>
<font color="black">5310.         Decimal('1.41421356')</font>
<font color="black">5311.         &gt;&gt;&gt; ExtendedContext.prec</font>
<font color="black">5312.         9</font>
<font color="black">5313.         &quot;&quot;&quot;</font>
<font color="red">5314.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5315.         return a.sqrt(context=self)</font>
<font color="black">5316. </font>
<font color="green">5317.     def subtract(self, a, b):</font>
<font color="black">5318.         &quot;&quot;&quot;Return the difference between the two operands.</font>
<font color="black">5319. </font>
<font color="black">5320.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.07'))</font>
<font color="black">5321.         Decimal('0.23')</font>
<font color="black">5322.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.30'))</font>
<font color="black">5323.         Decimal('0.00')</font>
<font color="black">5324.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('2.07'))</font>
<font color="black">5325.         Decimal('-0.77')</font>
<font color="black">5326.         &gt;&gt;&gt; ExtendedContext.subtract(8, 5)</font>
<font color="black">5327.         Decimal('3')</font>
<font color="black">5328.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal(8), 5)</font>
<font color="black">5329.         Decimal('3')</font>
<font color="black">5330.         &gt;&gt;&gt; ExtendedContext.subtract(8, Decimal(5))</font>
<font color="black">5331.         Decimal('3')</font>
<font color="black">5332.         &quot;&quot;&quot;</font>
<font color="red">5333.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5334.         r = a.__sub__(b, context=self)</font>
<font color="red">5335.         if r is NotImplemented:</font>
<font color="red">5336.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">5337.         else:</font>
<font color="red">5338.             return r</font>
<font color="black">5339. </font>
<font color="green">5340.     def to_eng_string(self, a):</font>
<font color="black">5341.         &quot;&quot;&quot;Converts a number to a string, using scientific notation.</font>
<font color="black">5342. </font>
<font color="black">5343.         The operation is not affected by the context.</font>
<font color="black">5344.         &quot;&quot;&quot;</font>
<font color="red">5345.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5346.         return a.to_eng_string(context=self)</font>
<font color="black">5347. </font>
<font color="green">5348.     def to_sci_string(self, a):</font>
<font color="black">5349.         &quot;&quot;&quot;Converts a number to a string, using scientific notation.</font>
<font color="black">5350. </font>
<font color="black">5351.         The operation is not affected by the context.</font>
<font color="black">5352.         &quot;&quot;&quot;</font>
<font color="red">5353.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5354.         return a.__str__(context=self)</font>
<font color="black">5355. </font>
<font color="green">5356.     def to_integral_exact(self, a):</font>
<font color="black">5357.         &quot;&quot;&quot;Rounds to an integer.</font>
<font color="black">5358. </font>
<font color="black">5359.         When the operand has a negative exponent, the result is the same</font>
<font color="black">5360.         as using the quantize() operation using the given operand as the</font>
<font color="black">5361.         left-hand-operand, 1E+0 as the right-hand-operand, and the precision</font>
<font color="black">5362.         of the operand as the precision setting; Inexact and Rounded flags</font>
<font color="black">5363.         are allowed in this operation.  The rounding mode is taken from the</font>
<font color="black">5364.         context.</font>
<font color="black">5365. </font>
<font color="black">5366.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('2.1'))</font>
<font color="black">5367.         Decimal('2')</font>
<font color="black">5368.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100'))</font>
<font color="black">5369.         Decimal('100')</font>
<font color="black">5370.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100.0'))</font>
<font color="black">5371.         Decimal('100')</font>
<font color="black">5372.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('101.5'))</font>
<font color="black">5373.         Decimal('102')</font>
<font color="black">5374.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-101.5'))</font>
<font color="black">5375.         Decimal('-102')</font>
<font color="black">5376.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('10E+5'))</font>
<font color="black">5377.         Decimal('1.0E+6')</font>
<font color="black">5378.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('7.89E+77'))</font>
<font color="black">5379.         Decimal('7.89E+77')</font>
<font color="black">5380.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-Inf'))</font>
<font color="black">5381.         Decimal('-Infinity')</font>
<font color="black">5382.         &quot;&quot;&quot;</font>
<font color="red">5383.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5384.         return a.to_integral_exact(context=self)</font>
<font color="black">5385. </font>
<font color="green">5386.     def to_integral_value(self, a):</font>
<font color="black">5387.         &quot;&quot;&quot;Rounds to an integer.</font>
<font color="black">5388. </font>
<font color="black">5389.         When the operand has a negative exponent, the result is the same</font>
<font color="black">5390.         as using the quantize() operation using the given operand as the</font>
<font color="black">5391.         left-hand-operand, 1E+0 as the right-hand-operand, and the precision</font>
<font color="black">5392.         of the operand as the precision setting, except that no flags will</font>
<font color="black">5393.         be set.  The rounding mode is taken from the context.</font>
<font color="black">5394. </font>
<font color="black">5395.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('2.1'))</font>
<font color="black">5396.         Decimal('2')</font>
<font color="black">5397.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100'))</font>
<font color="black">5398.         Decimal('100')</font>
<font color="black">5399.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100.0'))</font>
<font color="black">5400.         Decimal('100')</font>
<font color="black">5401.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('101.5'))</font>
<font color="black">5402.         Decimal('102')</font>
<font color="black">5403.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-101.5'))</font>
<font color="black">5404.         Decimal('-102')</font>
<font color="black">5405.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('10E+5'))</font>
<font color="black">5406.         Decimal('1.0E+6')</font>
<font color="black">5407.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('7.89E+77'))</font>
<font color="black">5408.         Decimal('7.89E+77')</font>
<font color="black">5409.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-Inf'))</font>
<font color="black">5410.         Decimal('-Infinity')</font>
<font color="black">5411.         &quot;&quot;&quot;</font>
<font color="red">5412.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5413.         return a.to_integral_value(context=self)</font>
<font color="black">5414. </font>
<font color="black">5415.     # the method name changed, but we provide also the old one, for compatibility</font>
<font color="green">5416.     to_integral = to_integral_value</font>
<font color="black">5417. </font>
<font color="green">5418. class _WorkRep(object):</font>
<font color="green">5419.     __slots__ = ('sign','int','exp')</font>
<font color="black">5420.     # sign: 0 or 1</font>
<font color="black">5421.     # int:  int or long</font>
<font color="black">5422.     # exp:  None, int, or string</font>
<font color="black">5423. </font>
<font color="green">5424.     def __init__(self, value=None):</font>
<font color="red">5425.         if value is None:</font>
<font color="red">5426.             self.sign = None</font>
<font color="red">5427.             self.int = 0</font>
<font color="red">5428.             self.exp = None</font>
<font color="red">5429.         elif isinstance(value, Decimal):</font>
<font color="red">5430.             self.sign = value._sign</font>
<font color="red">5431.             self.int = int(value._int)</font>
<font color="red">5432.             self.exp = value._exp</font>
<font color="black">5433.         else:</font>
<font color="black">5434.             # assert isinstance(value, tuple)</font>
<font color="red">5435.             self.sign = value[0]</font>
<font color="red">5436.             self.int = value[1]</font>
<font color="red">5437.             self.exp = value[2]</font>
<font color="black">5438. </font>
<font color="green">5439.     def __repr__(self):</font>
<font color="red">5440.         return &quot;(%r, %r, %r)&quot; % (self.sign, self.int, self.exp)</font>
<font color="black">5441. </font>
<font color="green">5442.     __str__ = __repr__</font>
<font color="black">5443. </font>
<font color="black">5444. </font>
<font color="black">5445. </font>
<font color="green">5446. def _normalize(op1, op2, prec = 0):</font>
<font color="black">5447.     &quot;&quot;&quot;Normalizes op1, op2 to have the same exp and length of coefficient.</font>
<font color="black">5448. </font>
<font color="black">5449.     Done during addition.</font>
<font color="black">5450.     &quot;&quot;&quot;</font>
<font color="red">5451.     if op1.exp &lt; op2.exp:</font>
<font color="red">5452.         tmp = op2</font>
<font color="red">5453.         other = op1</font>
<font color="black">5454.     else:</font>
<font color="red">5455.         tmp = op1</font>
<font color="red">5456.         other = op2</font>
<font color="black">5457. </font>
<font color="black">5458.     # Let exp = min(tmp.exp - 1, tmp.adjusted() - precision - 1).</font>
<font color="black">5459.     # Then adding 10**exp to tmp has the same effect (after rounding)</font>
<font color="black">5460.     # as adding any positive quantity smaller than 10**exp; similarly</font>
<font color="black">5461.     # for subtraction.  So if other is smaller than 10**exp we replace</font>
<font color="black">5462.     # it with 10**exp.  This avoids tmp.exp - other.exp getting too large.</font>
<font color="red">5463.     tmp_len = len(str(tmp.int))</font>
<font color="red">5464.     other_len = len(str(other.int))</font>
<font color="red">5465.     exp = tmp.exp + min(-1, tmp_len - prec - 2)</font>
<font color="red">5466.     if other_len + other.exp - 1 &lt; exp:</font>
<font color="red">5467.         other.int = 1</font>
<font color="red">5468.         other.exp = exp</font>
<font color="black">5469. </font>
<font color="red">5470.     tmp.int *= 10 ** (tmp.exp - other.exp)</font>
<font color="red">5471.     tmp.exp = other.exp</font>
<font color="red">5472.     return op1, op2</font>
<font color="black">5473. </font>
<font color="black">5474. ##### Integer arithmetic functions used by ln, log10, exp and __pow__ #####</font>
<font color="black">5475. </font>
<font color="black">5476. # This function from Tim Peters was taken from here:</font>
<font color="black">5477. # http://mail.python.org/pipermail/python-list/1999-July/007758.html</font>
<font color="black">5478. # The correction being in the function definition is for speed, and</font>
<font color="black">5479. # the whole function is not resolved with math.log because of avoiding</font>
<font color="black">5480. # the use of floats.</font>
<font color="green">5481. def _nbits(n, correction = {</font>
<font color="green">5482.         '0': 4, '1': 3, '2': 2, '3': 2,</font>
<font color="green">5483.         '4': 1, '5': 1, '6': 1, '7': 1,</font>
<font color="green">5484.         '8': 0, '9': 0, 'a': 0, 'b': 0,</font>
<font color="green">5485.         'c': 0, 'd': 0, 'e': 0, 'f': 0}):</font>
<font color="black">5486.     &quot;&quot;&quot;Number of bits in binary representation of the positive integer n,</font>
<font color="black">5487.     or 0 if n == 0.</font>
<font color="black">5488.     &quot;&quot;&quot;</font>
<font color="red">5489.     if n &lt; 0:</font>
<font color="red">5490.         raise ValueError(&quot;The argument to _nbits should be nonnegative.&quot;)</font>
<font color="red">5491.     hex_n = &quot;%x&quot; % n</font>
<font color="red">5492.     return 4*len(hex_n) - correction[hex_n[0]]</font>
<font color="black">5493. </font>
<font color="green">5494. def _decimal_lshift_exact(n, e):</font>
<font color="black">5495.     &quot;&quot;&quot; Given integers n and e, return n * 10**e if it's an integer, else None.</font>
<font color="black">5496. </font>
<font color="black">5497.     The computation is designed to avoid computing large powers of 10</font>
<font color="black">5498.     unnecessarily.</font>
<font color="black">5499. </font>
<font color="black">5500.     &gt;&gt;&gt; _decimal_lshift_exact(3, 4)</font>
<font color="black">5501.     30000</font>
<font color="black">5502.     &gt;&gt;&gt; _decimal_lshift_exact(300, -999999999)  # returns None</font>
<font color="black">5503. </font>
<font color="black">5504.     &quot;&quot;&quot;</font>
<font color="red">5505.     if n == 0:</font>
<font color="red">5506.         return 0</font>
<font color="red">5507.     elif e &gt;= 0:</font>
<font color="red">5508.         return n * 10**e</font>
<font color="black">5509.     else:</font>
<font color="black">5510.         # val_n = largest power of 10 dividing n.</font>
<font color="red">5511.         str_n = str(abs(n))</font>
<font color="red">5512.         val_n = len(str_n) - len(str_n.rstrip('0'))</font>
<font color="red">5513.         return None if val_n &lt; -e else n // 10**-e</font>
<font color="black">5514. </font>
<font color="green">5515. def _sqrt_nearest(n, a):</font>
<font color="black">5516.     &quot;&quot;&quot;Closest integer to the square root of the positive integer n.  a is</font>
<font color="black">5517.     an initial approximation to the square root.  Any positive integer</font>
<font color="black">5518.     will do for a, but the closer a is to the square root of n the</font>
<font color="black">5519.     faster convergence will be.</font>
<font color="black">5520. </font>
<font color="black">5521.     &quot;&quot;&quot;</font>
<font color="red">5522.     if n &lt;= 0 or a &lt;= 0:</font>
<font color="red">5523.         raise ValueError(&quot;Both arguments to _sqrt_nearest should be positive.&quot;)</font>
<font color="black">5524. </font>
<font color="red">5525.     b=0</font>
<font color="red">5526.     while a != b:</font>
<font color="red">5527.         b, a = a, a--n//a&gt;&gt;1</font>
<font color="red">5528.     return a</font>
<font color="black">5529. </font>
<font color="green">5530. def _rshift_nearest(x, shift):</font>
<font color="black">5531.     &quot;&quot;&quot;Given an integer x and a nonnegative integer shift, return closest</font>
<font color="black">5532.     integer to x / 2**shift; use round-to-even in case of a tie.</font>
<font color="black">5533. </font>
<font color="black">5534.     &quot;&quot;&quot;</font>
<font color="red">5535.     b, q = 1L &lt;&lt; shift, x &gt;&gt; shift</font>
<font color="red">5536.     return q + (2*(x &amp; (b-1)) + (q&amp;1) &gt; b)</font>
<font color="black">5537. </font>
<font color="green">5538. def _div_nearest(a, b):</font>
<font color="black">5539.     &quot;&quot;&quot;Closest integer to a/b, a and b positive integers; rounds to even</font>
<font color="black">5540.     in the case of a tie.</font>
<font color="black">5541. </font>
<font color="black">5542.     &quot;&quot;&quot;</font>
<font color="red">5543.     q, r = divmod(a, b)</font>
<font color="red">5544.     return q + (2*r + (q&amp;1) &gt; b)</font>
<font color="black">5545. </font>
<font color="green">5546. def _ilog(x, M, L = 8):</font>
<font color="black">5547.     &quot;&quot;&quot;Integer approximation to M*log(x/M), with absolute error boundable</font>
<font color="black">5548.     in terms only of x/M.</font>
<font color="black">5549. </font>
<font color="black">5550.     Given positive integers x and M, return an integer approximation to</font>
<font color="black">5551.     M * log(x/M).  For L = 8 and 0.1 &lt;= x/M &lt;= 10 the difference</font>
<font color="black">5552.     between the approximation and the exact result is at most 22.  For</font>
<font color="black">5553.     L = 8 and 1.0 &lt;= x/M &lt;= 10.0 the difference is at most 15.  In</font>
<font color="black">5554.     both cases these are upper bounds on the error; it will usually be</font>
<font color="black">5555.     much smaller.&quot;&quot;&quot;</font>
<font color="black">5556. </font>
<font color="black">5557.     # The basic algorithm is the following: let log1p be the function</font>
<font color="black">5558.     # log1p(x) = log(1+x).  Then log(x/M) = log1p((x-M)/M).  We use</font>
<font color="black">5559.     # the reduction</font>
<font color="black">5560.     #</font>
<font color="black">5561.     #    log1p(y) = 2*log1p(y/(1+sqrt(1+y)))</font>
<font color="black">5562.     #</font>
<font color="black">5563.     # repeatedly until the argument to log1p is small (&lt; 2**-L in</font>
<font color="black">5564.     # absolute value).  For small y we can use the Taylor series</font>
<font color="black">5565.     # expansion</font>
<font color="black">5566.     #</font>
<font color="black">5567.     #    log1p(y) ~ y - y**2/2 + y**3/3 - ... - (-y)**T/T</font>
<font color="black">5568.     #</font>
<font color="black">5569.     # truncating at T such that y**T is small enough.  The whole</font>
<font color="black">5570.     # computation is carried out in a form of fixed-point arithmetic,</font>
<font color="black">5571.     # with a real number z being represented by an integer</font>
<font color="black">5572.     # approximation to z*M.  To avoid loss of precision, the y below</font>
<font color="black">5573.     # is actually an integer approximation to 2**R*y*M, where R is the</font>
<font color="black">5574.     # number of reductions performed so far.</font>
<font color="black">5575. </font>
<font color="red">5576.     y = x-M</font>
<font color="black">5577.     # argument reduction; R = number of reductions performed</font>
<font color="red">5578.     R = 0</font>
<font color="red">5579.     while (R &lt;= L and long(abs(y)) &lt;&lt; L-R &gt;= M or</font>
<font color="red">5580.            R &gt; L and abs(y) &gt;&gt; R-L &gt;= M):</font>
<font color="red">5581.         y = _div_nearest(long(M*y) &lt;&lt; 1,</font>
<font color="red">5582.                          M + _sqrt_nearest(M*(M+_rshift_nearest(y, R)), M))</font>
<font color="red">5583.         R += 1</font>
<font color="black">5584. </font>
<font color="black">5585.     # Taylor series with T terms</font>
<font color="red">5586.     T = -int(-10*len(str(M))//(3*L))</font>
<font color="red">5587.     yshift = _rshift_nearest(y, R)</font>
<font color="red">5588.     w = _div_nearest(M, T)</font>
<font color="red">5589.     for k in xrange(T-1, 0, -1):</font>
<font color="red">5590.         w = _div_nearest(M, k) - _div_nearest(yshift*w, M)</font>
<font color="black">5591. </font>
<font color="red">5592.     return _div_nearest(w*y, M)</font>
<font color="black">5593. </font>
<font color="green">5594. def _dlog10(c, e, p):</font>
<font color="black">5595.     &quot;&quot;&quot;Given integers c, e and p with c &gt; 0, p &gt;= 0, compute an integer</font>
<font color="black">5596.     approximation to 10**p * log10(c*10**e), with an absolute error of</font>
<font color="black">5597.     at most 1.  Assumes that c*10**e is not exactly 1.&quot;&quot;&quot;</font>
<font color="black">5598. </font>
<font color="black">5599.     # increase precision by 2; compensate for this by dividing</font>
<font color="black">5600.     # final result by 100</font>
<font color="red">5601.     p += 2</font>
<font color="black">5602. </font>
<font color="black">5603.     # write c*10**e as d*10**f with either:</font>
<font color="black">5604.     #   f &gt;= 0 and 1 &lt;= d &lt;= 10, or</font>
<font color="black">5605.     #   f &lt;= 0 and 0.1 &lt;= d &lt;= 1.</font>
<font color="black">5606.     # Thus for c*10**e close to 1, f = 0</font>
<font color="red">5607.     l = len(str(c))</font>
<font color="red">5608.     f = e+l - (e+l &gt;= 1)</font>
<font color="black">5609. </font>
<font color="red">5610.     if p &gt; 0:</font>
<font color="red">5611.         M = 10**p</font>
<font color="red">5612.         k = e+p-f</font>
<font color="red">5613.         if k &gt;= 0:</font>
<font color="red">5614.             c *= 10**k</font>
<font color="black">5615.         else:</font>
<font color="red">5616.             c = _div_nearest(c, 10**-k)</font>
<font color="black">5617. </font>
<font color="red">5618.         log_d = _ilog(c, M) # error &lt; 5 + 22 = 27</font>
<font color="red">5619.         log_10 = _log10_digits(p) # error &lt; 1</font>
<font color="red">5620.         log_d = _div_nearest(log_d*M, log_10)</font>
<font color="red">5621.         log_tenpower = f*M # exact</font>
<font color="black">5622.     else:</font>
<font color="red">5623.         log_d = 0  # error &lt; 2.31</font>
<font color="red">5624.         log_tenpower = _div_nearest(f, 10**-p) # error &lt; 0.5</font>
<font color="black">5625. </font>
<font color="red">5626.     return _div_nearest(log_tenpower+log_d, 100)</font>
<font color="black">5627. </font>
<font color="green">5628. def _dlog(c, e, p):</font>
<font color="black">5629.     &quot;&quot;&quot;Given integers c, e and p with c &gt; 0, compute an integer</font>
<font color="black">5630.     approximation to 10**p * log(c*10**e), with an absolute error of</font>
<font color="black">5631.     at most 1.  Assumes that c*10**e is not exactly 1.&quot;&quot;&quot;</font>
<font color="black">5632. </font>
<font color="black">5633.     # Increase precision by 2. The precision increase is compensated</font>
<font color="black">5634.     # for at the end with a division by 100.</font>
<font color="red">5635.     p += 2</font>
<font color="black">5636. </font>
<font color="black">5637.     # rewrite c*10**e as d*10**f with either f &gt;= 0 and 1 &lt;= d &lt;= 10,</font>
<font color="black">5638.     # or f &lt;= 0 and 0.1 &lt;= d &lt;= 1.  Then we can compute 10**p * log(c*10**e)</font>
<font color="black">5639.     # as 10**p * log(d) + 10**p*f * log(10).</font>
<font color="red">5640.     l = len(str(c))</font>
<font color="red">5641.     f = e+l - (e+l &gt;= 1)</font>
<font color="black">5642. </font>
<font color="black">5643.     # compute approximation to 10**p*log(d), with error &lt; 27</font>
<font color="red">5644.     if p &gt; 0:</font>
<font color="red">5645.         k = e+p-f</font>
<font color="red">5646.         if k &gt;= 0:</font>
<font color="red">5647.             c *= 10**k</font>
<font color="black">5648.         else:</font>
<font color="red">5649.             c = _div_nearest(c, 10**-k)  # error of &lt;= 0.5 in c</font>
<font color="black">5650. </font>
<font color="black">5651.         # _ilog magnifies existing error in c by a factor of at most 10</font>
<font color="red">5652.         log_d = _ilog(c, 10**p) # error &lt; 5 + 22 = 27</font>
<font color="black">5653.     else:</font>
<font color="black">5654.         # p &lt;= 0: just approximate the whole thing by 0; error &lt; 2.31</font>
<font color="red">5655.         log_d = 0</font>
<font color="black">5656. </font>
<font color="black">5657.     # compute approximation to f*10**p*log(10), with error &lt; 11.</font>
<font color="red">5658.     if f:</font>
<font color="red">5659.         extra = len(str(abs(f)))-1</font>
<font color="red">5660.         if p + extra &gt;= 0:</font>
<font color="black">5661.             # error in f * _log10_digits(p+extra) &lt; |f| * 1 = |f|</font>
<font color="black">5662.             # after division, error &lt; |f|/10**extra + 0.5 &lt; 10 + 0.5 &lt; 11</font>
<font color="red">5663.             f_log_ten = _div_nearest(f*_log10_digits(p+extra), 10**extra)</font>
<font color="black">5664.         else:</font>
<font color="red">5665.             f_log_ten = 0</font>
<font color="black">5666.     else:</font>
<font color="red">5667.         f_log_ten = 0</font>
<font color="black">5668. </font>
<font color="black">5669.     # error in sum &lt; 11+27 = 38; error after division &lt; 0.38 + 0.5 &lt; 1</font>
<font color="red">5670.     return _div_nearest(f_log_ten + log_d, 100)</font>
<font color="black">5671. </font>
<font color="green">5672. class _Log10Memoize(object):</font>
<font color="black">5673.     &quot;&quot;&quot;Class to compute, store, and allow retrieval of, digits of the</font>
<font color="black">5674.     constant log(10) = 2.302585....  This constant is needed by</font>
<font color="green">5675.     Decimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__.&quot;&quot;&quot;</font>
<font color="green">5676.     def __init__(self):</font>
<font color="green">5677.         self.digits = &quot;23025850929940456840179914546843642076011014886&quot;</font>
<font color="black">5678. </font>
<font color="green">5679.     def getdigits(self, p):</font>
<font color="black">5680.         &quot;&quot;&quot;Given an integer p &gt;= 0, return floor(10**p)*log(10).</font>
<font color="black">5681. </font>
<font color="black">5682.         For example, self.getdigits(3) returns 2302.</font>
<font color="black">5683.         &quot;&quot;&quot;</font>
<font color="black">5684.         # digits are stored as a string, for quick conversion to</font>
<font color="black">5685.         # integer in the case that we've already computed enough</font>
<font color="black">5686.         # digits; the stored digits should always be correct</font>
<font color="black">5687.         # (truncated, not rounded to nearest).</font>
<font color="red">5688.         if p &lt; 0:</font>
<font color="red">5689.             raise ValueError(&quot;p should be nonnegative&quot;)</font>
<font color="black">5690. </font>
<font color="red">5691.         if p &gt;= len(self.digits):</font>
<font color="black">5692.             # compute p+3, p+6, p+9, ... digits; continue until at</font>
<font color="black">5693.             # least one of the extra digits is nonzero</font>
<font color="red">5694.             extra = 3</font>
<font color="red">5695.             while True:</font>
<font color="black">5696.                 # compute p+extra digits, correct to within 1ulp</font>
<font color="red">5697.                 M = 10**(p+extra+2)</font>
<font color="red">5698.                 digits = str(_div_nearest(_ilog(10*M, M), 100))</font>
<font color="red">5699.                 if digits[-extra:] != '0'*extra:</font>
<font color="red">5700.                     break</font>
<font color="red">5701.                 extra += 3</font>
<font color="black">5702.             # keep all reliable digits so far; remove trailing zeros</font>
<font color="black">5703.             # and next nonzero digit</font>
<font color="red">5704.             self.digits = digits.rstrip('0')[:-1]</font>
<font color="red">5705.         return int(self.digits[:p+1])</font>
<font color="black">5706. </font>
<font color="green">5707. _log10_digits = _Log10Memoize().getdigits</font>
<font color="black">5708. </font>
<font color="green">5709. def _iexp(x, M, L=8):</font>
<font color="black">5710.     &quot;&quot;&quot;Given integers x and M, M &gt; 0, such that x/M is small in absolute</font>
<font color="black">5711.     value, compute an integer approximation to M*exp(x/M).  For 0 &lt;=</font>
<font color="black">5712.     x/M &lt;= 2.4, the absolute error in the result is bounded by 60 (and</font>
<font color="black">5713.     is usually much smaller).&quot;&quot;&quot;</font>
<font color="black">5714. </font>
<font color="black">5715.     # Algorithm: to compute exp(z) for a real number z, first divide z</font>
<font color="black">5716.     # by a suitable power R of 2 so that |z/2**R| &lt; 2**-L.  Then</font>
<font color="black">5717.     # compute expm1(z/2**R) = exp(z/2**R) - 1 using the usual Taylor</font>
<font color="black">5718.     # series</font>
<font color="black">5719.     #</font>
<font color="black">5720.     #     expm1(x) = x + x**2/2! + x**3/3! + ...</font>
<font color="black">5721.     #</font>
<font color="black">5722.     # Now use the identity</font>
<font color="black">5723.     #</font>
<font color="black">5724.     #     expm1(2x) = expm1(x)*(expm1(x)+2)</font>
<font color="black">5725.     #</font>
<font color="black">5726.     # R times to compute the sequence expm1(z/2**R),</font>
<font color="black">5727.     # expm1(z/2**(R-1)), ... , exp(z/2), exp(z).</font>
<font color="black">5728. </font>
<font color="black">5729.     # Find R such that x/2**R/M &lt;= 2**-L</font>
<font color="red">5730.     R = _nbits((long(x)&lt;&lt;L)//M)</font>
<font color="black">5731. </font>
<font color="black">5732.     # Taylor series.  (2**L)**T &gt; M</font>
<font color="red">5733.     T = -int(-10*len(str(M))//(3*L))</font>
<font color="red">5734.     y = _div_nearest(x, T)</font>
<font color="red">5735.     Mshift = long(M)&lt;&lt;R</font>
<font color="red">5736.     for i in xrange(T-1, 0, -1):</font>
<font color="red">5737.         y = _div_nearest(x*(Mshift + y), Mshift * i)</font>
<font color="black">5738. </font>
<font color="black">5739.     # Expansion</font>
<font color="red">5740.     for k in xrange(R-1, -1, -1):</font>
<font color="red">5741.         Mshift = long(M)&lt;&lt;(k+2)</font>
<font color="red">5742.         y = _div_nearest(y*(y+Mshift), Mshift)</font>
<font color="black">5743. </font>
<font color="red">5744.     return M+y</font>
<font color="black">5745. </font>
<font color="green">5746. def _dexp(c, e, p):</font>
<font color="black">5747.     &quot;&quot;&quot;Compute an approximation to exp(c*10**e), with p decimal places of</font>
<font color="black">5748.     precision.</font>
<font color="black">5749. </font>
<font color="black">5750.     Returns integers d, f such that:</font>
<font color="black">5751. </font>
<font color="black">5752.       10**(p-1) &lt;= d &lt;= 10**p, and</font>
<font color="black">5753.       (d-1)*10**f &lt; exp(c*10**e) &lt; (d+1)*10**f</font>
<font color="black">5754. </font>
<font color="black">5755.     In other words, d*10**f is an approximation to exp(c*10**e) with p</font>
<font color="black">5756.     digits of precision, and with an error in d of at most 1.  This is</font>
<font color="black">5757.     almost, but not quite, the same as the error being &lt; 1ulp: when d</font>
<font color="black">5758.     = 10**(p-1) the error could be up to 10 ulp.&quot;&quot;&quot;</font>
<font color="black">5759. </font>
<font color="black">5760.     # we'll call iexp with M = 10**(p+2), giving p+3 digits of precision</font>
<font color="red">5761.     p += 2</font>
<font color="black">5762. </font>
<font color="black">5763.     # compute log(10) with extra precision = adjusted exponent of c*10**e</font>
<font color="red">5764.     extra = max(0, e + len(str(c)) - 1)</font>
<font color="red">5765.     q = p + extra</font>
<font color="black">5766. </font>
<font color="black">5767.     # compute quotient c*10**e/(log(10)) = c*10**(e+q)/(log(10)*10**q),</font>
<font color="black">5768.     # rounding down</font>
<font color="red">5769.     shift = e+q</font>
<font color="red">5770.     if shift &gt;= 0:</font>
<font color="red">5771.         cshift = c*10**shift</font>
<font color="black">5772.     else:</font>
<font color="red">5773.         cshift = c//10**-shift</font>
<font color="red">5774.     quot, rem = divmod(cshift, _log10_digits(q))</font>
<font color="black">5775. </font>
<font color="black">5776.     # reduce remainder back to original precision</font>
<font color="red">5777.     rem = _div_nearest(rem, 10**extra)</font>
<font color="black">5778. </font>
<font color="black">5779.     # error in result of _iexp &lt; 120;  error after division &lt; 0.62</font>
<font color="red">5780.     return _div_nearest(_iexp(rem, 10**p), 1000), quot - p + 3</font>
<font color="black">5781. </font>
<font color="green">5782. def _dpower(xc, xe, yc, ye, p):</font>
<font color="black">5783.     &quot;&quot;&quot;Given integers xc, xe, yc and ye representing Decimals x = xc*10**xe and</font>
<font color="black">5784.     y = yc*10**ye, compute x**y.  Returns a pair of integers (c, e) such that:</font>
<font color="black">5785. </font>
<font color="black">5786.       10**(p-1) &lt;= c &lt;= 10**p, and</font>
<font color="black">5787.       (c-1)*10**e &lt; x**y &lt; (c+1)*10**e</font>
<font color="black">5788. </font>
<font color="black">5789.     in other words, c*10**e is an approximation to x**y with p digits</font>
<font color="black">5790.     of precision, and with an error in c of at most 1.  (This is</font>
<font color="black">5791.     almost, but not quite, the same as the error being &lt; 1ulp: when c</font>
<font color="black">5792.     == 10**(p-1) we can only guarantee error &lt; 10ulp.)</font>
<font color="black">5793. </font>
<font color="black">5794.     We assume that: x is positive and not equal to 1, and y is nonzero.</font>
<font color="black">5795.     &quot;&quot;&quot;</font>
<font color="black">5796. </font>
<font color="black">5797.     # Find b such that 10**(b-1) &lt;= |y| &lt;= 10**b</font>
<font color="red">5798.     b = len(str(abs(yc))) + ye</font>
<font color="black">5799. </font>
<font color="black">5800.     # log(x) = lxc*10**(-p-b-1), to p+b+1 places after the decimal point</font>
<font color="red">5801.     lxc = _dlog(xc, xe, p+b+1)</font>
<font color="black">5802. </font>
<font color="black">5803.     # compute product y*log(x) = yc*lxc*10**(-p-b-1+ye) = pc*10**(-p-1)</font>
<font color="red">5804.     shift = ye-b</font>
<font color="red">5805.     if shift &gt;= 0:</font>
<font color="red">5806.         pc = lxc*yc*10**shift</font>
<font color="black">5807.     else:</font>
<font color="red">5808.         pc = _div_nearest(lxc*yc, 10**-shift)</font>
<font color="black">5809. </font>
<font color="red">5810.     if pc == 0:</font>
<font color="black">5811.         # we prefer a result that isn't exactly 1; this makes it</font>
<font color="black">5812.         # easier to compute a correctly rounded result in __pow__</font>
<font color="red">5813.         if ((len(str(xc)) + xe &gt;= 1) == (yc &gt; 0)): # if x**y &gt; 1:</font>
<font color="red">5814.             coeff, exp = 10**(p-1)+1, 1-p</font>
<font color="black">5815.         else:</font>
<font color="red">5816.             coeff, exp = 10**p-1, -p</font>
<font color="black">5817.     else:</font>
<font color="red">5818.         coeff, exp = _dexp(pc, -(p+1), p+1)</font>
<font color="red">5819.         coeff = _div_nearest(coeff, 10)</font>
<font color="red">5820.         exp += 1</font>
<font color="black">5821. </font>
<font color="red">5822.     return coeff, exp</font>
<font color="black">5823. </font>
<font color="green">5824. def _log10_lb(c, correction = {</font>
<font color="green">5825.         '1': 100, '2': 70, '3': 53, '4': 40, '5': 31,</font>
<font color="green">5826.         '6': 23, '7': 16, '8': 10, '9': 5}):</font>
<font color="black">5827.     &quot;&quot;&quot;Compute a lower bound for 100*log10(c) for a positive integer c.&quot;&quot;&quot;</font>
<font color="red">5828.     if c &lt;= 0:</font>
<font color="red">5829.         raise ValueError(&quot;The argument to _log10_lb should be nonnegative.&quot;)</font>
<font color="red">5830.     str_c = str(c)</font>
<font color="red">5831.     return 100*len(str_c) - correction[str_c[0]]</font>
<font color="black">5832. </font>
<font color="black">5833. ##### Helper Functions ####################################################</font>
<font color="black">5834. </font>
<font color="green">5835. def _convert_other(other, raiseit=False, allow_float=False):</font>
<font color="black">5836.     &quot;&quot;&quot;Convert other to Decimal.</font>
<font color="black">5837. </font>
<font color="black">5838.     Verifies that it's ok to use in an implicit construction.</font>
<font color="black">5839.     If allow_float is true, allow conversion from float;  this</font>
<font color="black">5840.     is used in the comparison methods (__eq__ and friends).</font>
<font color="black">5841. </font>
<font color="black">5842.     &quot;&quot;&quot;</font>
<font color="red">5843.     if isinstance(other, Decimal):</font>
<font color="red">5844.         return other</font>
<font color="red">5845.     if isinstance(other, (int, long)):</font>
<font color="red">5846.         return Decimal(other)</font>
<font color="red">5847.     if allow_float and isinstance(other, float):</font>
<font color="red">5848.         return Decimal.from_float(other)</font>
<font color="black">5849. </font>
<font color="red">5850.     if raiseit:</font>
<font color="red">5851.         raise TypeError(&quot;Unable to convert %s to Decimal&quot; % other)</font>
<font color="red">5852.     return NotImplemented</font>
<font color="black">5853. </font>
<font color="black">5854. ##### Setup Specific Contexts ############################################</font>
<font color="black">5855. </font>
<font color="black">5856. # The default context prototype used by Context()</font>
<font color="black">5857. # Is mutable, so that new contexts can have different default values</font>
<font color="black">5858. </font>
<font color="green">5859. DefaultContext = Context(</font>
<font color="green">5860.         prec=28, rounding=ROUND_HALF_EVEN,</font>
<font color="green">5861.         traps=[DivisionByZero, Overflow, InvalidOperation],</font>
<font color="green">5862.         flags=[],</font>
<font color="green">5863.         Emax=999999999,</font>
<font color="green">5864.         Emin=-999999999,</font>
<font color="green">5865.         capitals=1</font>
<font color="black">5866. )</font>
<font color="black">5867. </font>
<font color="black">5868. # Pre-made alternate contexts offered by the specification</font>
<font color="black">5869. # Don't change these; the user should be able to select these</font>
<font color="black">5870. # contexts and be able to reproduce results from other implementations</font>
<font color="black">5871. # of the spec.</font>
<font color="black">5872. </font>
<font color="green">5873. BasicContext = Context(</font>
<font color="green">5874.         prec=9, rounding=ROUND_HALF_UP,</font>
<font color="green">5875.         traps=[DivisionByZero, Overflow, InvalidOperation, Clamped, Underflow],</font>
<font color="green">5876.         flags=[],</font>
<font color="black">5877. )</font>
<font color="black">5878. </font>
<font color="green">5879. ExtendedContext = Context(</font>
<font color="green">5880.         prec=9, rounding=ROUND_HALF_EVEN,</font>
<font color="green">5881.         traps=[],</font>
<font color="green">5882.         flags=[],</font>
<font color="black">5883. )</font>
<font color="black">5884. </font>
<font color="black">5885. </font>
<font color="black">5886. ##### crud for parsing strings #############################################</font>
<font color="black">5887. #</font>
<font color="black">5888. # Regular expression used for parsing numeric strings.  Additional</font>
<font color="black">5889. # comments:</font>
<font color="black">5890. #</font>
<font color="black">5891. # 1. Uncomment the two '\s*' lines to allow leading and/or trailing</font>
<font color="black">5892. # whitespace.  But note that the specification disallows whitespace in</font>
<font color="black">5893. # a numeric string.</font>
<font color="black">5894. #</font>
<font color="black">5895. # 2. For finite numbers (not infinities and NaNs) the body of the</font>
<font color="black">5896. # number between the optional sign and the optional exponent must have</font>
<font color="black">5897. # at least one decimal digit, possibly after the decimal point.  The</font>
<font color="black">5898. # lookahead expression '(?=\d|\.\d)' checks this.</font>
<font color="black">5899. </font>
<font color="green">5900. import re</font>
<font color="green">5901. _parser = re.compile(r&quot;&quot;&quot;        # A numeric string consists of:</font>
<font color="black">5902. #    \s*</font>
<font color="black">5903.     (?P&lt;sign&gt;[-+])?              # an optional sign, followed by either...</font>
<font color="black">5904.     (</font>
<font color="black">5905.         (?=\d|\.\d)              # ...a number (with at least one digit)</font>
<font color="black">5906.         (?P&lt;int&gt;\d*)             # having a (possibly empty) integer part</font>
<font color="black">5907.         (\.(?P&lt;frac&gt;\d*))?       # followed by an optional fractional part</font>
<font color="black">5908.         (E(?P&lt;exp&gt;[-+]?\d+))?    # followed by an optional exponent, or...</font>
<font color="black">5909.     |</font>
<font color="black">5910.         Inf(inity)?              # ...an infinity, or...</font>
<font color="black">5911.     |</font>
<font color="black">5912.         (?P&lt;signal&gt;s)?           # ...an (optionally signaling)</font>
<font color="black">5913.         NaN                      # NaN</font>
<font color="black">5914.         (?P&lt;diag&gt;\d*)            # with (possibly empty) diagnostic info.</font>
<font color="black">5915.     )</font>
<font color="black">5916. #    \s*</font>
<font color="black">5917.     \Z</font>
<font color="green">5918. &quot;&quot;&quot;, re.VERBOSE | re.IGNORECASE | re.UNICODE).match</font>
<font color="black">5919. </font>
<font color="green">5920. _all_zeros = re.compile('0*$').match</font>
<font color="green">5921. _exact_half = re.compile('50*$').match</font>
<font color="black">5922. </font>
<font color="black">5923. ##### PEP3101 support functions ##############################################</font>
<font color="black">5924. # The functions in this section have little to do with the Decimal</font>
<font color="black">5925. # class, and could potentially be reused or adapted for other pure</font>
<font color="black">5926. # Python numeric classes that want to implement __format__</font>
<font color="black">5927. #</font>
<font color="black">5928. # A format specifier for Decimal looks like:</font>
<font color="black">5929. #</font>
<font color="black">5930. #   [[fill]align][sign][0][minimumwidth][,][.precision][type]</font>
<font color="black">5931. </font>
<font color="green">5932. _parse_format_specifier_regex = re.compile(r&quot;&quot;&quot;\A</font>
<font color="black">5933. (?:</font>
<font color="black">5934.    (?P&lt;fill&gt;.)?</font>
<font color="black">5935.    (?P&lt;align&gt;[&lt;&gt;=^])</font>
<font color="black">5936. )?</font>
<font color="black">5937. (?P&lt;sign&gt;[-+ ])?</font>
<font color="black">5938. (?P&lt;zeropad&gt;0)?</font>
<font color="black">5939. (?P&lt;minimumwidth&gt;(?!0)\d+)?</font>
<font color="black">5940. (?P&lt;thousands_sep&gt;,)?</font>
<font color="black">5941. (?:\.(?P&lt;precision&gt;0|(?!0)\d+))?</font>
<font color="black">5942. (?P&lt;type&gt;[eEfFgGn%])?</font>
<font color="black">5943. \Z</font>
<font color="green">5944. &quot;&quot;&quot;, re.VERBOSE)</font>
<font color="black">5945. </font>
<font color="green">5946. del re</font>
<font color="black">5947. </font>
<font color="black">5948. # The locale module is only needed for the 'n' format specifier.  The</font>
<font color="black">5949. # rest of the PEP 3101 code functions quite happily without it, so we</font>
<font color="black">5950. # don't care too much if locale isn't present.</font>
<font color="green">5951. try:</font>
<font color="green">5952.     import locale as _locale</font>
<font color="red">5953. except ImportError:</font>
<font color="red">5954.     pass</font>
<font color="black">5955. </font>
<font color="green">5956. def _parse_format_specifier(format_spec, _localeconv=None):</font>
<font color="black">5957.     &quot;&quot;&quot;Parse and validate a format specifier.</font>
<font color="black">5958. </font>
<font color="black">5959.     Turns a standard numeric format specifier into a dict, with the</font>
<font color="black">5960.     following entries:</font>
<font color="black">5961. </font>
<font color="black">5962.       fill: fill character to pad field to minimum width</font>
<font color="black">5963.       align: alignment type, either '&lt;', '&gt;', '=' or '^'</font>
<font color="black">5964.       sign: either '+', '-' or ' '</font>
<font color="black">5965.       minimumwidth: nonnegative integer giving minimum width</font>
<font color="black">5966.       zeropad: boolean, indicating whether to pad with zeros</font>
<font color="black">5967.       thousands_sep: string to use as thousands separator, or ''</font>
<font color="black">5968.       grouping: grouping for thousands separators, in format</font>
<font color="black">5969.         used by localeconv</font>
<font color="black">5970.       decimal_point: string to use for decimal point</font>
<font color="black">5971.       precision: nonnegative integer giving precision, or None</font>
<font color="black">5972.       type: one of the characters 'eEfFgG%', or None</font>
<font color="black">5973.       unicode: boolean (always True for Python 3.x)</font>
<font color="black">5974. </font>
<font color="black">5975.     &quot;&quot;&quot;</font>
<font color="red">5976.     m = _parse_format_specifier_regex.match(format_spec)</font>
<font color="red">5977.     if m is None:</font>
<font color="red">5978.         raise ValueError(&quot;Invalid format specifier: &quot; + format_spec)</font>
<font color="black">5979. </font>
<font color="black">5980.     # get the dictionary</font>
<font color="red">5981.     format_dict = m.groupdict()</font>
<font color="black">5982. </font>
<font color="black">5983.     # zeropad; defaults for fill and alignment.  If zero padding</font>
<font color="black">5984.     # is requested, the fill and align fields should be absent.</font>
<font color="red">5985.     fill = format_dict['fill']</font>
<font color="red">5986.     align = format_dict['align']</font>
<font color="red">5987.     format_dict['zeropad'] = (format_dict['zeropad'] is not None)</font>
<font color="red">5988.     if format_dict['zeropad']:</font>
<font color="red">5989.         if fill is not None:</font>
<font color="red">5990.             raise ValueError(&quot;Fill character conflicts with '0'&quot;</font>
<font color="red">5991.                              &quot; in format specifier: &quot; + format_spec)</font>
<font color="red">5992.         if align is not None:</font>
<font color="red">5993.             raise ValueError(&quot;Alignment conflicts with '0' in &quot;</font>
<font color="red">5994.                              &quot;format specifier: &quot; + format_spec)</font>
<font color="red">5995.     format_dict['fill'] = fill or ' '</font>
<font color="black">5996.     # PEP 3101 originally specified that the default alignment should</font>
<font color="black">5997.     # be left;  it was later agreed that right-aligned makes more sense</font>
<font color="black">5998.     # for numeric types.  See http://bugs.python.org/issue6857.</font>
<font color="red">5999.     format_dict['align'] = align or '&gt;'</font>
<font color="black">6000. </font>
<font color="black">6001.     # default sign handling: '-' for negative, '' for positive</font>
<font color="red">6002.     if format_dict['sign'] is None:</font>
<font color="red">6003.         format_dict['sign'] = '-'</font>
<font color="black">6004. </font>
<font color="black">6005.     # minimumwidth defaults to 0; precision remains None if not given</font>
<font color="red">6006.     format_dict['minimumwidth'] = int(format_dict['minimumwidth'] or '0')</font>
<font color="red">6007.     if format_dict['precision'] is not None:</font>
<font color="red">6008.         format_dict['precision'] = int(format_dict['precision'])</font>
<font color="black">6009. </font>
<font color="black">6010.     # if format type is 'g' or 'G' then a precision of 0 makes little</font>
<font color="black">6011.     # sense; convert it to 1.  Same if format type is unspecified.</font>
<font color="red">6012.     if format_dict['precision'] == 0:</font>
<font color="red">6013.         if format_dict['type'] is None or format_dict['type'] in 'gG':</font>
<font color="red">6014.             format_dict['precision'] = 1</font>
<font color="black">6015. </font>
<font color="black">6016.     # determine thousands separator, grouping, and decimal separator, and</font>
<font color="black">6017.     # add appropriate entries to format_dict</font>
<font color="red">6018.     if format_dict['type'] == 'n':</font>
<font color="black">6019.         # apart from separators, 'n' behaves just like 'g'</font>
<font color="red">6020.         format_dict['type'] = 'g'</font>
<font color="red">6021.         if _localeconv is None:</font>
<font color="red">6022.             _localeconv = _locale.localeconv()</font>
<font color="red">6023.         if format_dict['thousands_sep'] is not None:</font>
<font color="red">6024.             raise ValueError(&quot;Explicit thousands separator conflicts with &quot;</font>
<font color="red">6025.                              &quot;'n' type in format specifier: &quot; + format_spec)</font>
<font color="red">6026.         format_dict['thousands_sep'] = _localeconv['thousands_sep']</font>
<font color="red">6027.         format_dict['grouping'] = _localeconv['grouping']</font>
<font color="red">6028.         format_dict['decimal_point'] = _localeconv['decimal_point']</font>
<font color="black">6029.     else:</font>
<font color="red">6030.         if format_dict['thousands_sep'] is None:</font>
<font color="red">6031.             format_dict['thousands_sep'] = ''</font>
<font color="red">6032.         format_dict['grouping'] = [3, 0]</font>
<font color="red">6033.         format_dict['decimal_point'] = '.'</font>
<font color="black">6034. </font>
<font color="black">6035.     # record whether return type should be str or unicode</font>
<font color="red">6036.     format_dict['unicode'] = isinstance(format_spec, unicode)</font>
<font color="black">6037. </font>
<font color="red">6038.     return format_dict</font>
<font color="black">6039. </font>
<font color="green">6040. def _format_align(sign, body, spec):</font>
<font color="black">6041.     &quot;&quot;&quot;Given an unpadded, non-aligned numeric string 'body' and sign</font>
<font color="black">6042.     string 'sign', add padding and alignment conforming to the given</font>
<font color="black">6043.     format specifier dictionary 'spec' (as produced by</font>
<font color="black">6044.     parse_format_specifier).</font>
<font color="black">6045. </font>
<font color="black">6046.     Also converts result to unicode if necessary.</font>
<font color="black">6047. </font>
<font color="black">6048.     &quot;&quot;&quot;</font>
<font color="black">6049.     # how much extra space do we have to play with?</font>
<font color="red">6050.     minimumwidth = spec['minimumwidth']</font>
<font color="red">6051.     fill = spec['fill']</font>
<font color="red">6052.     padding = fill*(minimumwidth - len(sign) - len(body))</font>
<font color="black">6053. </font>
<font color="red">6054.     align = spec['align']</font>
<font color="red">6055.     if align == '&lt;':</font>
<font color="red">6056.         result = sign + body + padding</font>
<font color="red">6057.     elif align == '&gt;':</font>
<font color="red">6058.         result = padding + sign + body</font>
<font color="red">6059.     elif align == '=':</font>
<font color="red">6060.         result = sign + padding + body</font>
<font color="red">6061.     elif align == '^':</font>
<font color="red">6062.         half = len(padding)//2</font>
<font color="red">6063.         result = padding[:half] + sign + body + padding[half:]</font>
<font color="black">6064.     else:</font>
<font color="red">6065.         raise ValueError('Unrecognised alignment field')</font>
<font color="black">6066. </font>
<font color="black">6067.     # make sure that result is unicode if necessary</font>
<font color="red">6068.     if spec['unicode']:</font>
<font color="red">6069.         result = unicode(result)</font>
<font color="black">6070. </font>
<font color="red">6071.     return result</font>
<font color="black">6072. </font>
<font color="green">6073. def _group_lengths(grouping):</font>
<font color="black">6074.     &quot;&quot;&quot;Convert a localeconv-style grouping into a (possibly infinite)</font>
<font color="black">6075.     iterable of integers representing group lengths.</font>
<font color="black">6076. </font>
<font color="black">6077.     &quot;&quot;&quot;</font>
<font color="black">6078.     # The result from localeconv()['grouping'], and the input to this</font>
<font color="black">6079.     # function, should be a list of integers in one of the</font>
<font color="black">6080.     # following three forms:</font>
<font color="black">6081.     #</font>
<font color="black">6082.     #   (1) an empty list, or</font>
<font color="black">6083.     #   (2) nonempty list of positive integers + [0]</font>
<font color="black">6084.     #   (3) list of positive integers + [locale.CHAR_MAX], or</font>
<font color="black">6085. </font>
<font color="red">6086.     from itertools import chain, repeat</font>
<font color="red">6087.     if not grouping:</font>
<font color="red">6088.         return []</font>
<font color="red">6089.     elif grouping[-1] == 0 and len(grouping) &gt;= 2:</font>
<font color="red">6090.         return chain(grouping[:-1], repeat(grouping[-2]))</font>
<font color="red">6091.     elif grouping[-1] == _locale.CHAR_MAX:</font>
<font color="red">6092.         return grouping[:-1]</font>
<font color="black">6093.     else:</font>
<font color="red">6094.         raise ValueError('unrecognised format for grouping')</font>
<font color="black">6095. </font>
<font color="green">6096. def _insert_thousands_sep(digits, spec, min_width=1):</font>
<font color="black">6097.     &quot;&quot;&quot;Insert thousands separators into a digit string.</font>
<font color="black">6098. </font>
<font color="black">6099.     spec is a dictionary whose keys should include 'thousands_sep' and</font>
<font color="black">6100.     'grouping'; typically it's the result of parsing the format</font>
<font color="black">6101.     specifier using _parse_format_specifier.</font>
<font color="black">6102. </font>
<font color="black">6103.     The min_width keyword argument gives the minimum length of the</font>
<font color="black">6104.     result, which will be padded on the left with zeros if necessary.</font>
<font color="black">6105. </font>
<font color="black">6106.     If necessary, the zero padding adds an extra '0' on the left to</font>
<font color="black">6107.     avoid a leading thousands separator.  For example, inserting</font>
<font color="black">6108.     commas every three digits in '123456', with min_width=8, gives</font>
<font color="black">6109.     '0,123,456', even though that has length 9.</font>
<font color="black">6110. </font>
<font color="black">6111.     &quot;&quot;&quot;</font>
<font color="black">6112. </font>
<font color="red">6113.     sep = spec['thousands_sep']</font>
<font color="red">6114.     grouping = spec['grouping']</font>
<font color="black">6115. </font>
<font color="red">6116.     groups = []</font>
<font color="red">6117.     for l in _group_lengths(grouping):</font>
<font color="red">6118.         if l &lt;= 0:</font>
<font color="red">6119.             raise ValueError(&quot;group length should be positive&quot;)</font>
<font color="black">6120.         # max(..., 1) forces at least 1 digit to the left of a separator</font>
<font color="red">6121.         l = min(max(len(digits), min_width, 1), l)</font>
<font color="red">6122.         groups.append('0'*(l - len(digits)) + digits[-l:])</font>
<font color="red">6123.         digits = digits[:-l]</font>
<font color="red">6124.         min_width -= l</font>
<font color="red">6125.         if not digits and min_width &lt;= 0:</font>
<font color="red">6126.             break</font>
<font color="red">6127.         min_width -= len(sep)</font>
<font color="black">6128.     else:</font>
<font color="red">6129.         l = max(len(digits), min_width, 1)</font>
<font color="red">6130.         groups.append('0'*(l - len(digits)) + digits[-l:])</font>
<font color="red">6131.     return sep.join(reversed(groups))</font>
<font color="black">6132. </font>
<font color="green">6133. def _format_sign(is_negative, spec):</font>
<font color="black">6134.     &quot;&quot;&quot;Determine sign character.&quot;&quot;&quot;</font>
<font color="black">6135. </font>
<font color="red">6136.     if is_negative:</font>
<font color="red">6137.         return '-'</font>
<font color="red">6138.     elif spec['sign'] in ' +':</font>
<font color="red">6139.         return spec['sign']</font>
<font color="black">6140.     else:</font>
<font color="red">6141.         return ''</font>
<font color="black">6142. </font>
<font color="green">6143. def _format_number(is_negative, intpart, fracpart, exp, spec):</font>
<font color="black">6144.     &quot;&quot;&quot;Format a number, given the following data:</font>
<font color="black">6145. </font>
<font color="black">6146.     is_negative: true if the number is negative, else false</font>
<font color="black">6147.     intpart: string of digits that must appear before the decimal point</font>
<font color="black">6148.     fracpart: string of digits that must come after the point</font>
<font color="black">6149.     exp: exponent, as an integer</font>
<font color="black">6150.     spec: dictionary resulting from parsing the format specifier</font>
<font color="black">6151. </font>
<font color="black">6152.     This function uses the information in spec to:</font>
<font color="black">6153.       insert separators (decimal separator and thousands separators)</font>
<font color="black">6154.       format the sign</font>
<font color="black">6155.       format the exponent</font>
<font color="black">6156.       add trailing '%' for the '%' type</font>
<font color="black">6157.       zero-pad if necessary</font>
<font color="black">6158.       fill and align if necessary</font>
<font color="black">6159.     &quot;&quot;&quot;</font>
<font color="black">6160. </font>
<font color="red">6161.     sign = _format_sign(is_negative, spec)</font>
<font color="black">6162. </font>
<font color="red">6163.     if fracpart:</font>
<font color="red">6164.         fracpart = spec['decimal_point'] + fracpart</font>
<font color="black">6165. </font>
<font color="red">6166.     if exp != 0 or spec['type'] in 'eE':</font>
<font color="red">6167.         echar = {'E': 'E', 'e': 'e', 'G': 'E', 'g': 'e'}[spec['type']]</font>
<font color="red">6168.         fracpart += &quot;{0}{1:+}&quot;.format(echar, exp)</font>
<font color="red">6169.     if spec['type'] == '%':</font>
<font color="red">6170.         fracpart += '%'</font>
<font color="black">6171. </font>
<font color="red">6172.     if spec['zeropad']:</font>
<font color="red">6173.         min_width = spec['minimumwidth'] - len(fracpart) - len(sign)</font>
<font color="black">6174.     else:</font>
<font color="red">6175.         min_width = 0</font>
<font color="red">6176.     intpart = _insert_thousands_sep(intpart, spec, min_width)</font>
<font color="black">6177. </font>
<font color="red">6178.     return _format_align(sign, intpart+fracpart, spec)</font>
<font color="black">6179. </font>
<font color="black">6180. </font>
<font color="black">6181. ##### Useful Constants (internal use only) ################################</font>
<font color="black">6182. </font>
<font color="black">6183. # Reusable defaults</font>
<font color="green">6184. _Infinity = Decimal('Inf')</font>
<font color="green">6185. _NegativeInfinity = Decimal('-Inf')</font>
<font color="green">6186. _NaN = Decimal('NaN')</font>
<font color="green">6187. _Zero = Decimal(0)</font>
<font color="green">6188. _One = Decimal(1)</font>
<font color="green">6189. _NegativeOne = Decimal(-1)</font>
<font color="black">6190. </font>
<font color="black">6191. # _SignedInfinity[sign] is infinity w/ that sign</font>
<font color="green">6192. _SignedInfinity = (_Infinity, _NegativeInfinity)</font>
<font color="black">6193. </font>
<font color="black">6194. </font>
<font color="black">6195. </font>
<font color="green">6196. if __name__ == '__main__':</font>
<font color="red">6197.     import doctest, sys</font>
<font color="red">6198.     doctest.testmod(sys.modules[__name__])</font>
</pre>

