source file: <b>/usr/lib/python2.7/inspect.py</b><br>


file stats: <b>607 lines, 166 executed: 27.3% covered</b>
<pre>
<font color="black">   1. # -*- coding: iso-8859-1 -*-</font>
<font color="black">   2. &quot;&quot;&quot;Get useful information from live Python objects.</font>
<font color="black">   3. </font>
<font color="black">   4. This module encapsulates the interface provided by the internal special</font>
<font color="black">   5. attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.</font>
<font color="black">   6. It also provides some help for examining source code and class layout.</font>
<font color="black">   7. </font>
<font color="black">   8. Here are some of the useful functions provided by this module:</font>
<font color="black">   9. </font>
<font color="black">  10.     ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),</font>
<font color="black">  11.         isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),</font>
<font color="black">  12.         isroutine() - check object types</font>
<font color="black">  13.     getmembers() - get members of an object that satisfy a given condition</font>
<font color="black">  14. </font>
<font color="black">  15.     getfile(), getsourcefile(), getsource() - find an object's source code</font>
<font color="black">  16.     getdoc(), getcomments() - get documentation on an object</font>
<font color="black">  17.     getmodule() - determine the module that an object came from</font>
<font color="black">  18.     getclasstree() - arrange classes so as to represent their hierarchy</font>
<font color="black">  19. </font>
<font color="black">  20.     getargspec(), getargvalues(), getcallargs() - get info about function arguments</font>
<font color="black">  21.     formatargspec(), formatargvalues() - format an argument spec</font>
<font color="black">  22.     getouterframes(), getinnerframes() - get info about frames</font>
<font color="black">  23.     currentframe() - get the current stack frame</font>
<font color="black">  24.     stack(), trace() - get info about frames on the stack or in a traceback</font>
<font color="green">  25. &quot;&quot;&quot;</font>
<font color="black">  26. </font>
<font color="black">  27. # This module is in the public domain.  No warranties.</font>
<font color="black">  28. </font>
<font color="green">  29. __author__ = 'Ka-Ping Yee &lt;ping@lfw.org&gt;'</font>
<font color="green">  30. __date__ = '1 Jan 2001'</font>
<font color="black">  31. </font>
<font color="green">  32. import sys</font>
<font color="green">  33. import os</font>
<font color="green">  34. import types</font>
<font color="green">  35. import string</font>
<font color="green">  36. import re</font>
<font color="green">  37. import dis</font>
<font color="green">  38. import imp</font>
<font color="green">  39. import tokenize</font>
<font color="green">  40. import linecache</font>
<font color="green">  41. from operator import attrgetter</font>
<font color="green">  42. from collections import namedtuple</font>
<font color="black">  43. </font>
<font color="black">  44. # These constants are from Include/code.h.</font>
<font color="green">  45. CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, CO_VARKEYWORDS = 0x1, 0x2, 0x4, 0x8</font>
<font color="green">  46. CO_NESTED, CO_GENERATOR, CO_NOFREE = 0x10, 0x20, 0x40</font>
<font color="black">  47. # See Include/object.h</font>
<font color="green">  48. TPFLAGS_IS_ABSTRACT = 1 &lt;&lt; 20</font>
<font color="black">  49. </font>
<font color="black">  50. # ----------------------------------------------------------- type-checking</font>
<font color="green">  51. def ismodule(object):</font>
<font color="black">  52.     &quot;&quot;&quot;Return true if the object is a module.</font>
<font color="black">  53. </font>
<font color="black">  54.     Module objects provide these attributes:</font>
<font color="black">  55.         __doc__         documentation string</font>
<font color="black">  56.         __file__        filename (missing for built-in modules)&quot;&quot;&quot;</font>
<font color="red">  57.     return isinstance(object, types.ModuleType)</font>
<font color="black">  58. </font>
<font color="green">  59. def isclass(object):</font>
<font color="black">  60.     &quot;&quot;&quot;Return true if the object is a class.</font>
<font color="black">  61. </font>
<font color="black">  62.     Class objects provide these attributes:</font>
<font color="black">  63.         __doc__         documentation string</font>
<font color="black">  64.         __module__      name of module in which this class was defined&quot;&quot;&quot;</font>
<font color="green">  65.     return isinstance(object, (type, types.ClassType))</font>
<font color="black">  66. </font>
<font color="green">  67. def ismethod(object):</font>
<font color="black">  68.     &quot;&quot;&quot;Return true if the object is an instance method.</font>
<font color="black">  69. </font>
<font color="black">  70.     Instance method objects provide these attributes:</font>
<font color="black">  71.         __doc__         documentation string</font>
<font color="black">  72.         __name__        name with which this method was defined</font>
<font color="black">  73.         im_class        class object in which this method belongs</font>
<font color="black">  74.         im_func         function object containing implementation of method</font>
<font color="black">  75.         im_self         instance to which this method is bound, or None&quot;&quot;&quot;</font>
<font color="green">  76.     return isinstance(object, types.MethodType)</font>
<font color="black">  77. </font>
<font color="green">  78. def ismethoddescriptor(object):</font>
<font color="black">  79.     &quot;&quot;&quot;Return true if the object is a method descriptor.</font>
<font color="black">  80. </font>
<font color="black">  81.     But not if ismethod() or isclass() or isfunction() are true.</font>
<font color="black">  82. </font>
<font color="black">  83.     This is new in Python 2.2, and, for example, is true of int.__add__.</font>
<font color="black">  84.     An object passing this test has a __get__ attribute but not a __set__</font>
<font color="black">  85.     attribute, but beyond that the set of attributes varies.  __name__ is</font>
<font color="black">  86.     usually sensible, and __doc__ often is.</font>
<font color="black">  87. </font>
<font color="black">  88.     Methods implemented via descriptors that also pass one of the other</font>
<font color="black">  89.     tests return false from the ismethoddescriptor() test, simply because</font>
<font color="black">  90.     the other tests promise more -- you can, e.g., count on having the</font>
<font color="black">  91.     im_func attribute (etc) when an object passes ismethod().&quot;&quot;&quot;</font>
<font color="red">  92.     return (hasattr(object, &quot;__get__&quot;)</font>
<font color="red">  93.             and not hasattr(object, &quot;__set__&quot;) # else it's a data descriptor</font>
<font color="red">  94.             and not ismethod(object)           # mutual exclusion</font>
<font color="red">  95.             and not isfunction(object)</font>
<font color="red">  96.             and not isclass(object))</font>
<font color="black">  97. </font>
<font color="green">  98. def isdatadescriptor(object):</font>
<font color="black">  99.     &quot;&quot;&quot;Return true if the object is a data descriptor.</font>
<font color="black"> 100. </font>
<font color="black"> 101.     Data descriptors have both a __get__ and a __set__ attribute.  Examples are</font>
<font color="black"> 102.     properties (defined in Python) and getsets and members (defined in C).</font>
<font color="black"> 103.     Typically, data descriptors will also have __name__ and __doc__ attributes</font>
<font color="black"> 104.     (properties, getsets, and members have both of these attributes), but this</font>
<font color="black"> 105.     is not guaranteed.&quot;&quot;&quot;</font>
<font color="red"> 106.     return (hasattr(object, &quot;__set__&quot;) and hasattr(object, &quot;__get__&quot;))</font>
<font color="black"> 107. </font>
<font color="green"> 108. if hasattr(types, 'MemberDescriptorType'):</font>
<font color="black"> 109.     # CPython and equivalent</font>
<font color="green"> 110.     def ismemberdescriptor(object):</font>
<font color="black"> 111.         &quot;&quot;&quot;Return true if the object is a member descriptor.</font>
<font color="black"> 112. </font>
<font color="black"> 113.         Member descriptors are specialized descriptors defined in extension</font>
<font color="black"> 114.         modules.&quot;&quot;&quot;</font>
<font color="red"> 115.         return isinstance(object, types.MemberDescriptorType)</font>
<font color="black"> 116. else:</font>
<font color="black"> 117.     # Other implementations</font>
<font color="red"> 118.     def ismemberdescriptor(object):</font>
<font color="black"> 119.         &quot;&quot;&quot;Return true if the object is a member descriptor.</font>
<font color="black"> 120. </font>
<font color="black"> 121.         Member descriptors are specialized descriptors defined in extension</font>
<font color="black"> 122.         modules.&quot;&quot;&quot;</font>
<font color="red"> 123.         return False</font>
<font color="black"> 124. </font>
<font color="green"> 125. if hasattr(types, 'GetSetDescriptorType'):</font>
<font color="black"> 126.     # CPython and equivalent</font>
<font color="green"> 127.     def isgetsetdescriptor(object):</font>
<font color="black"> 128.         &quot;&quot;&quot;Return true if the object is a getset descriptor.</font>
<font color="black"> 129. </font>
<font color="black"> 130.         getset descriptors are specialized descriptors defined in extension</font>
<font color="black"> 131.         modules.&quot;&quot;&quot;</font>
<font color="red"> 132.         return isinstance(object, types.GetSetDescriptorType)</font>
<font color="black"> 133. else:</font>
<font color="black"> 134.     # Other implementations</font>
<font color="red"> 135.     def isgetsetdescriptor(object):</font>
<font color="black"> 136.         &quot;&quot;&quot;Return true if the object is a getset descriptor.</font>
<font color="black"> 137. </font>
<font color="black"> 138.         getset descriptors are specialized descriptors defined in extension</font>
<font color="black"> 139.         modules.&quot;&quot;&quot;</font>
<font color="red"> 140.         return False</font>
<font color="black"> 141. </font>
<font color="green"> 142. def isfunction(object):</font>
<font color="black"> 143.     &quot;&quot;&quot;Return true if the object is a user-defined function.</font>
<font color="black"> 144. </font>
<font color="black"> 145.     Function objects provide these attributes:</font>
<font color="black"> 146.         __doc__         documentation string</font>
<font color="black"> 147.         __name__        name with which this function was defined</font>
<font color="black"> 148.         func_code       code object containing compiled function bytecode</font>
<font color="black"> 149.         func_defaults   tuple of any default values for arguments</font>
<font color="black"> 150.         func_doc        (same as __doc__)</font>
<font color="black"> 151.         func_globals    global namespace in which this function was defined</font>
<font color="black"> 152.         func_name       (same as __name__)&quot;&quot;&quot;</font>
<font color="green"> 153.     return isinstance(object, types.FunctionType)</font>
<font color="black"> 154. </font>
<font color="green"> 155. def isgeneratorfunction(object):</font>
<font color="black"> 156.     &quot;&quot;&quot;Return true if the object is a user-defined generator function.</font>
<font color="black"> 157. </font>
<font color="black"> 158.     Generator function objects provides same attributes as functions.</font>
<font color="black"> 159. </font>
<font color="black"> 160.     See help(isfunction) for attributes listing.&quot;&quot;&quot;</font>
<font color="red"> 161.     return bool((isfunction(object) or ismethod(object)) and</font>
<font color="red"> 162.                 object.func_code.co_flags &amp; CO_GENERATOR)</font>
<font color="black"> 163. </font>
<font color="green"> 164. def isgenerator(object):</font>
<font color="black"> 165.     &quot;&quot;&quot;Return true if the object is a generator.</font>
<font color="black"> 166. </font>
<font color="black"> 167.     Generator objects provide these attributes:</font>
<font color="black"> 168.         __iter__        defined to support iteration over container</font>
<font color="black"> 169.         close           raises a new GeneratorExit exception inside the</font>
<font color="black"> 170.                         generator to terminate the iteration</font>
<font color="black"> 171.         gi_code         code object</font>
<font color="black"> 172.         gi_frame        frame object or possibly None once the generator has</font>
<font color="black"> 173.                         been exhausted</font>
<font color="black"> 174.         gi_running      set to 1 when generator is executing, 0 otherwise</font>
<font color="black"> 175.         next            return the next item from the container</font>
<font color="black"> 176.         send            resumes the generator and &quot;sends&quot; a value that becomes</font>
<font color="black"> 177.                         the result of the current yield-expression</font>
<font color="black"> 178.         throw           used to raise an exception inside the generator&quot;&quot;&quot;</font>
<font color="red"> 179.     return isinstance(object, types.GeneratorType)</font>
<font color="black"> 180. </font>
<font color="green"> 181. def istraceback(object):</font>
<font color="black"> 182.     &quot;&quot;&quot;Return true if the object is a traceback.</font>
<font color="black"> 183. </font>
<font color="black"> 184.     Traceback objects provide these attributes:</font>
<font color="black"> 185.         tb_frame        frame object at this level</font>
<font color="black"> 186.         tb_lasti        index of last attempted instruction in bytecode</font>
<font color="black"> 187.         tb_lineno       current line number in Python source code</font>
<font color="black"> 188.         tb_next         next inner traceback object (called by this level)&quot;&quot;&quot;</font>
<font color="red"> 189.     return isinstance(object, types.TracebackType)</font>
<font color="black"> 190. </font>
<font color="green"> 191. def isframe(object):</font>
<font color="black"> 192.     &quot;&quot;&quot;Return true if the object is a frame object.</font>
<font color="black"> 193. </font>
<font color="black"> 194.     Frame objects provide these attributes:</font>
<font color="black"> 195.         f_back          next outer frame object (this frame's caller)</font>
<font color="black"> 196.         f_builtins      built-in namespace seen by this frame</font>
<font color="black"> 197.         f_code          code object being executed in this frame</font>
<font color="black"> 198.         f_exc_traceback traceback if raised in this frame, or None</font>
<font color="black"> 199.         f_exc_type      exception type if raised in this frame, or None</font>
<font color="black"> 200.         f_exc_value     exception value if raised in this frame, or None</font>
<font color="black"> 201.         f_globals       global namespace seen by this frame</font>
<font color="black"> 202.         f_lasti         index of last attempted instruction in bytecode</font>
<font color="black"> 203.         f_lineno        current line number in Python source code</font>
<font color="black"> 204.         f_locals        local namespace seen by this frame</font>
<font color="black"> 205.         f_restricted    0 or 1 if frame is in restricted execution mode</font>
<font color="black"> 206.         f_trace         tracing function for this frame, or None&quot;&quot;&quot;</font>
<font color="red"> 207.     return isinstance(object, types.FrameType)</font>
<font color="black"> 208. </font>
<font color="green"> 209. def iscode(object):</font>
<font color="black"> 210.     &quot;&quot;&quot;Return true if the object is a code object.</font>
<font color="black"> 211. </font>
<font color="black"> 212.     Code objects provide these attributes:</font>
<font color="black"> 213.         co_argcount     number of arguments (not including * or ** args)</font>
<font color="black"> 214.         co_code         string of raw compiled bytecode</font>
<font color="black"> 215.         co_consts       tuple of constants used in the bytecode</font>
<font color="black"> 216.         co_filename     name of file in which this code object was created</font>
<font color="black"> 217.         co_firstlineno  number of first line in Python source code</font>
<font color="black"> 218.         co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg</font>
<font color="black"> 219.         co_lnotab       encoded mapping of line numbers to bytecode indices</font>
<font color="black"> 220.         co_name         name with which this code object was defined</font>
<font color="black"> 221.         co_names        tuple of names of local variables</font>
<font color="black"> 222.         co_nlocals      number of local variables</font>
<font color="black"> 223.         co_stacksize    virtual machine stack space required</font>
<font color="black"> 224.         co_varnames     tuple of names of arguments and local variables&quot;&quot;&quot;</font>
<font color="green"> 225.     return isinstance(object, types.CodeType)</font>
<font color="black"> 226. </font>
<font color="green"> 227. def isbuiltin(object):</font>
<font color="black"> 228.     &quot;&quot;&quot;Return true if the object is a built-in function or method.</font>
<font color="black"> 229. </font>
<font color="black"> 230.     Built-in functions and methods provide these attributes:</font>
<font color="black"> 231.         __doc__         documentation string</font>
<font color="black"> 232.         __name__        original name of this function or method</font>
<font color="black"> 233.         __self__        instance to which a method is bound, or None&quot;&quot;&quot;</font>
<font color="red"> 234.     return isinstance(object, types.BuiltinFunctionType)</font>
<font color="black"> 235. </font>
<font color="green"> 236. def isroutine(object):</font>
<font color="black"> 237.     &quot;&quot;&quot;Return true if the object is any kind of function or method.&quot;&quot;&quot;</font>
<font color="red"> 238.     return (isbuiltin(object)</font>
<font color="red"> 239.             or isfunction(object)</font>
<font color="red"> 240.             or ismethod(object)</font>
<font color="red"> 241.             or ismethoddescriptor(object))</font>
<font color="black"> 242. </font>
<font color="green"> 243. def isabstract(object):</font>
<font color="black"> 244.     &quot;&quot;&quot;Return true if the object is an abstract base class (ABC).&quot;&quot;&quot;</font>
<font color="red"> 245.     return bool(isinstance(object, type) and object.__flags__ &amp; TPFLAGS_IS_ABSTRACT)</font>
<font color="black"> 246. </font>
<font color="green"> 247. def getmembers(object, predicate=None):</font>
<font color="black"> 248.     &quot;&quot;&quot;Return all members of an object as (name, value) pairs sorted by name.</font>
<font color="black"> 249.     Optionally, only return members that satisfy a given predicate.&quot;&quot;&quot;</font>
<font color="green"> 250.     results = []</font>
<font color="green"> 251.     for key in dir(object):</font>
<font color="green"> 252.         try:</font>
<font color="green"> 253.             value = getattr(object, key)</font>
<font color="red"> 254.         except AttributeError:</font>
<font color="red"> 255.             continue</font>
<font color="green"> 256.         if not predicate or predicate(value):</font>
<font color="green"> 257.             results.append((key, value))</font>
<font color="green"> 258.     results.sort()</font>
<font color="green"> 259.     return results</font>
<font color="black"> 260. </font>
<font color="green"> 261. Attribute = namedtuple('Attribute', 'name kind defining_class object')</font>
<font color="black"> 262. </font>
<font color="green"> 263. def classify_class_attrs(cls):</font>
<font color="black"> 264.     &quot;&quot;&quot;Return list of attribute-descriptor tuples.</font>
<font color="black"> 265. </font>
<font color="black"> 266.     For each name in dir(cls), the return list contains a 4-tuple</font>
<font color="black"> 267.     with these elements:</font>
<font color="black"> 268. </font>
<font color="black"> 269.         0. The name (a string).</font>
<font color="black"> 270. </font>
<font color="black"> 271.         1. The kind of attribute this is, one of these strings:</font>
<font color="black"> 272.                'class method'    created via classmethod()</font>
<font color="black"> 273.                'static method'   created via staticmethod()</font>
<font color="black"> 274.                'property'        created via property()</font>
<font color="black"> 275.                'method'          any other flavor of method</font>
<font color="black"> 276.                'data'            not a method</font>
<font color="black"> 277. </font>
<font color="black"> 278.         2. The class which defined this attribute (a class).</font>
<font color="black"> 279. </font>
<font color="black"> 280.         3. The object as obtained directly from the defining class's</font>
<font color="black"> 281.            __dict__, not via getattr.  This is especially important for</font>
<font color="black"> 282.            data attributes:  C.data is just a data object, but</font>
<font color="black"> 283.            C.__dict__['data'] may be a data descriptor with additional</font>
<font color="black"> 284.            info, like a __doc__ string.</font>
<font color="black"> 285.     &quot;&quot;&quot;</font>
<font color="black"> 286. </font>
<font color="red"> 287.     mro = getmro(cls)</font>
<font color="red"> 288.     names = dir(cls)</font>
<font color="red"> 289.     result = []</font>
<font color="red"> 290.     for name in names:</font>
<font color="black"> 291.         # Get the object associated with the name, and where it was defined.</font>
<font color="black"> 292.         # Getting an obj from the __dict__ sometimes reveals more than</font>
<font color="black"> 293.         # using getattr.  Static and class methods are dramatic examples.</font>
<font color="black"> 294.         # Furthermore, some objects may raise an Exception when fetched with</font>
<font color="black"> 295.         # getattr(). This is the case with some descriptors (bug #1785).</font>
<font color="black"> 296.         # Thus, we only use getattr() as a last resort.</font>
<font color="red"> 297.         homecls = None</font>
<font color="red"> 298.         for base in (cls,) + mro:</font>
<font color="red"> 299.             if name in base.__dict__:</font>
<font color="red"> 300.                 obj = base.__dict__[name]</font>
<font color="red"> 301.                 homecls = base</font>
<font color="red"> 302.                 break</font>
<font color="black"> 303.         else:</font>
<font color="red"> 304.             obj = getattr(cls, name)</font>
<font color="red"> 305.             homecls = getattr(obj, &quot;__objclass__&quot;, homecls)</font>
<font color="black"> 306. </font>
<font color="black"> 307.         # Classify the object.</font>
<font color="red"> 308.         if isinstance(obj, staticmethod):</font>
<font color="red"> 309.             kind = &quot;static method&quot;</font>
<font color="red"> 310.         elif isinstance(obj, classmethod):</font>
<font color="red"> 311.             kind = &quot;class method&quot;</font>
<font color="red"> 312.         elif isinstance(obj, property):</font>
<font color="red"> 313.             kind = &quot;property&quot;</font>
<font color="red"> 314.         elif ismethoddescriptor(obj):</font>
<font color="red"> 315.             kind = &quot;method&quot;</font>
<font color="red"> 316.         elif isdatadescriptor(obj):</font>
<font color="red"> 317.             kind = &quot;data&quot;</font>
<font color="black"> 318.         else:</font>
<font color="red"> 319.             obj_via_getattr = getattr(cls, name)</font>
<font color="red"> 320.             if (ismethod(obj_via_getattr) or</font>
<font color="red"> 321.                 ismethoddescriptor(obj_via_getattr)):</font>
<font color="red"> 322.                 kind = &quot;method&quot;</font>
<font color="black"> 323.             else:</font>
<font color="red"> 324.                 kind = &quot;data&quot;</font>
<font color="red"> 325.             obj = obj_via_getattr</font>
<font color="black"> 326. </font>
<font color="red"> 327.         result.append(Attribute(name, kind, homecls, obj))</font>
<font color="black"> 328. </font>
<font color="red"> 329.     return result</font>
<font color="black"> 330. </font>
<font color="black"> 331. # ----------------------------------------------------------- class helpers</font>
<font color="green"> 332. def _searchbases(cls, accum):</font>
<font color="black"> 333.     # Simulate the &quot;classic class&quot; search order.</font>
<font color="red"> 334.     if cls in accum:</font>
<font color="red"> 335.         return</font>
<font color="red"> 336.     accum.append(cls)</font>
<font color="red"> 337.     for base in cls.__bases__:</font>
<font color="red"> 338.         _searchbases(base, accum)</font>
<font color="black"> 339. </font>
<font color="green"> 340. def getmro(cls):</font>
<font color="black"> 341.     &quot;Return tuple of base classes (including cls) in method resolution order.&quot;</font>
<font color="green"> 342.     if hasattr(cls, &quot;__mro__&quot;):</font>
<font color="green"> 343.         return cls.__mro__</font>
<font color="black"> 344.     else:</font>
<font color="red"> 345.         result = []</font>
<font color="red"> 346.         _searchbases(cls, result)</font>
<font color="red"> 347.         return tuple(result)</font>
<font color="black"> 348. </font>
<font color="black"> 349. # -------------------------------------------------- source code extraction</font>
<font color="green"> 350. def indentsize(line):</font>
<font color="black"> 351.     &quot;&quot;&quot;Return the indent size, in spaces, at the start of a line of text.&quot;&quot;&quot;</font>
<font color="red"> 352.     expline = string.expandtabs(line)</font>
<font color="red"> 353.     return len(expline) - len(string.lstrip(expline))</font>
<font color="black"> 354. </font>
<font color="green"> 355. def getdoc(object):</font>
<font color="black"> 356.     &quot;&quot;&quot;Get the documentation string for an object.</font>
<font color="black"> 357. </font>
<font color="black"> 358.     All tabs are expanded to spaces.  To clean up docstrings that are</font>
<font color="black"> 359.     indented to line up with blocks of code, any whitespace than can be</font>
<font color="black"> 360.     uniformly removed from the second line onwards is removed.&quot;&quot;&quot;</font>
<font color="red"> 361.     try:</font>
<font color="red"> 362.         doc = object.__doc__</font>
<font color="red"> 363.     except AttributeError:</font>
<font color="red"> 364.         return None</font>
<font color="red"> 365.     if not isinstance(doc, types.StringTypes):</font>
<font color="red"> 366.         return None</font>
<font color="red"> 367.     return cleandoc(doc)</font>
<font color="black"> 368. </font>
<font color="green"> 369. def cleandoc(doc):</font>
<font color="black"> 370.     &quot;&quot;&quot;Clean up indentation from docstrings.</font>
<font color="black"> 371. </font>
<font color="black"> 372.     Any whitespace that can be uniformly removed from the second line</font>
<font color="black"> 373.     onwards is removed.&quot;&quot;&quot;</font>
<font color="red"> 374.     try:</font>
<font color="red"> 375.         lines = string.split(string.expandtabs(doc), '\n')</font>
<font color="red"> 376.     except UnicodeError:</font>
<font color="red"> 377.         return None</font>
<font color="black"> 378.     else:</font>
<font color="black"> 379.         # Find minimum indentation of any non-blank lines after first line.</font>
<font color="red"> 380.         margin = sys.maxint</font>
<font color="red"> 381.         for line in lines[1:]:</font>
<font color="red"> 382.             content = len(string.lstrip(line))</font>
<font color="red"> 383.             if content:</font>
<font color="red"> 384.                 indent = len(line) - content</font>
<font color="red"> 385.                 margin = min(margin, indent)</font>
<font color="black"> 386.         # Remove indentation.</font>
<font color="red"> 387.         if lines:</font>
<font color="red"> 388.             lines[0] = lines[0].lstrip()</font>
<font color="red"> 389.         if margin &lt; sys.maxint:</font>
<font color="red"> 390.             for i in range(1, len(lines)): lines[i] = lines[i][margin:]</font>
<font color="black"> 391.         # Remove any trailing or leading blank lines.</font>
<font color="red"> 392.         while lines and not lines[-1]:</font>
<font color="red"> 393.             lines.pop()</font>
<font color="red"> 394.         while lines and not lines[0]:</font>
<font color="red"> 395.             lines.pop(0)</font>
<font color="red"> 396.         return string.join(lines, '\n')</font>
<font color="black"> 397. </font>
<font color="green"> 398. def getfile(object):</font>
<font color="black"> 399.     &quot;&quot;&quot;Work out which source or compiled file an object was defined in.&quot;&quot;&quot;</font>
<font color="red"> 400.     if ismodule(object):</font>
<font color="red"> 401.         if hasattr(object, '__file__'):</font>
<font color="red"> 402.             return object.__file__</font>
<font color="red"> 403.         raise TypeError('{!r} is a built-in module'.format(object))</font>
<font color="red"> 404.     if isclass(object):</font>
<font color="red"> 405.         object = sys.modules.get(object.__module__)</font>
<font color="red"> 406.         if hasattr(object, '__file__'):</font>
<font color="red"> 407.             return object.__file__</font>
<font color="red"> 408.         raise TypeError('{!r} is a built-in class'.format(object))</font>
<font color="red"> 409.     if ismethod(object):</font>
<font color="red"> 410.         object = object.im_func</font>
<font color="red"> 411.     if isfunction(object):</font>
<font color="red"> 412.         object = object.func_code</font>
<font color="red"> 413.     if istraceback(object):</font>
<font color="red"> 414.         object = object.tb_frame</font>
<font color="red"> 415.     if isframe(object):</font>
<font color="red"> 416.         object = object.f_code</font>
<font color="red"> 417.     if iscode(object):</font>
<font color="red"> 418.         return object.co_filename</font>
<font color="red"> 419.     raise TypeError('{!r} is not a module, class, method, '</font>
<font color="red"> 420.                     'function, traceback, frame, or code object'.format(object))</font>
<font color="black"> 421. </font>
<font color="green"> 422. ModuleInfo = namedtuple('ModuleInfo', 'name suffix mode module_type')</font>
<font color="black"> 423. </font>
<font color="green"> 424. def getmoduleinfo(path):</font>
<font color="black"> 425.     &quot;&quot;&quot;Get the module name, suffix, mode, and module type for a given file.&quot;&quot;&quot;</font>
<font color="green"> 426.     filename = os.path.basename(path)</font>
<font color="green"> 427.     suffixes = map(lambda info:</font>
<font color="green"> 428.                    (-len(info[0]), info[0], info[1], info[2]),</font>
<font color="green"> 429.                     imp.get_suffixes())</font>
<font color="green"> 430.     suffixes.sort() # try longest suffixes first, in case they overlap</font>
<font color="green"> 431.     for neglen, suffix, mode, mtype in suffixes:</font>
<font color="green"> 432.         if filename[neglen:] == suffix:</font>
<font color="green"> 433.             return ModuleInfo(filename[:neglen], suffix, mode, mtype)</font>
<font color="black"> 434. </font>
<font color="green"> 435. def getmodulename(path):</font>
<font color="black"> 436.     &quot;&quot;&quot;Return the module name for a given file, or None.&quot;&quot;&quot;</font>
<font color="green"> 437.     info = getmoduleinfo(path)</font>
<font color="green"> 438.     if info: return info[0]</font>
<font color="black"> 439. </font>
<font color="green"> 440. def getsourcefile(object):</font>
<font color="black"> 441.     &quot;&quot;&quot;Return the filename that can be used to locate an object's source.</font>
<font color="black"> 442.     Return None if no way can be identified to get the source.</font>
<font color="black"> 443.     &quot;&quot;&quot;</font>
<font color="red"> 444.     filename = getfile(object)</font>
<font color="red"> 445.     if string.lower(filename[-4:]) in ('.pyc', '.pyo'):</font>
<font color="red"> 446.         filename = filename[:-4] + '.py'</font>
<font color="red"> 447.     for suffix, mode, kind in imp.get_suffixes():</font>
<font color="red"> 448.         if 'b' in mode and string.lower(filename[-len(suffix):]) == suffix:</font>
<font color="black"> 449.             # Looks like a binary file.  We want to only return a text file.</font>
<font color="red"> 450.             return None</font>
<font color="red"> 451.     if os.path.exists(filename):</font>
<font color="red"> 452.         return filename</font>
<font color="black"> 453.     # only return a non-existent filename if the module has a PEP 302 loader</font>
<font color="red"> 454.     if hasattr(getmodule(object, filename), '__loader__'):</font>
<font color="red"> 455.         return filename</font>
<font color="black"> 456.     # or it is in the linecache</font>
<font color="red"> 457.     if filename in linecache.cache:</font>
<font color="red"> 458.         return filename</font>
<font color="black"> 459. </font>
<font color="green"> 460. def getabsfile(object, _filename=None):</font>
<font color="black"> 461.     &quot;&quot;&quot;Return an absolute path to the source or compiled file for an object.</font>
<font color="black"> 462. </font>
<font color="black"> 463.     The idea is for each object to have a unique origin, so this routine</font>
<font color="black"> 464.     normalizes the result as much as possible.&quot;&quot;&quot;</font>
<font color="red"> 465.     if _filename is None:</font>
<font color="red"> 466.         _filename = getsourcefile(object) or getfile(object)</font>
<font color="red"> 467.     return os.path.normcase(os.path.abspath(_filename))</font>
<font color="black"> 468. </font>
<font color="green"> 469. modulesbyfile = {}</font>
<font color="green"> 470. _filesbymodname = {}</font>
<font color="black"> 471. </font>
<font color="green"> 472. def getmodule(object, _filename=None):</font>
<font color="black"> 473.     &quot;&quot;&quot;Return the module an object was defined in, or None if not found.&quot;&quot;&quot;</font>
<font color="red"> 474.     if ismodule(object):</font>
<font color="red"> 475.         return object</font>
<font color="red"> 476.     if hasattr(object, '__module__'):</font>
<font color="red"> 477.         return sys.modules.get(object.__module__)</font>
<font color="black"> 478.     # Try the filename to modulename cache</font>
<font color="red"> 479.     if _filename is not None and _filename in modulesbyfile:</font>
<font color="red"> 480.         return sys.modules.get(modulesbyfile[_filename])</font>
<font color="black"> 481.     # Try the cache again with the absolute file name</font>
<font color="red"> 482.     try:</font>
<font color="red"> 483.         file = getabsfile(object, _filename)</font>
<font color="red"> 484.     except TypeError:</font>
<font color="red"> 485.         return None</font>
<font color="red"> 486.     if file in modulesbyfile:</font>
<font color="red"> 487.         return sys.modules.get(modulesbyfile[file])</font>
<font color="black"> 488.     # Update the filename to module name cache and check yet again</font>
<font color="black"> 489.     # Copy sys.modules in order to cope with changes while iterating</font>
<font color="red"> 490.     for modname, module in sys.modules.items():</font>
<font color="red"> 491.         if ismodule(module) and hasattr(module, '__file__'):</font>
<font color="red"> 492.             f = module.__file__</font>
<font color="red"> 493.             if f == _filesbymodname.get(modname, None):</font>
<font color="black"> 494.                 # Have already mapped this module, so skip it</font>
<font color="red"> 495.                 continue</font>
<font color="red"> 496.             _filesbymodname[modname] = f</font>
<font color="red"> 497.             f = getabsfile(module)</font>
<font color="black"> 498.             # Always map to the name the module knows itself by</font>
<font color="black"> 499.             modulesbyfile[f] = modulesbyfile[</font>
<font color="red"> 500.                 os.path.realpath(f)] = module.__name__</font>
<font color="red"> 501.     if file in modulesbyfile:</font>
<font color="red"> 502.         return sys.modules.get(modulesbyfile[file])</font>
<font color="black"> 503.     # Check the main module</font>
<font color="red"> 504.     main = sys.modules['__main__']</font>
<font color="red"> 505.     if not hasattr(object, '__name__'):</font>
<font color="red"> 506.         return None</font>
<font color="red"> 507.     if hasattr(main, object.__name__):</font>
<font color="red"> 508.         mainobject = getattr(main, object.__name__)</font>
<font color="red"> 509.         if mainobject is object:</font>
<font color="red"> 510.             return main</font>
<font color="black"> 511.     # Check builtins</font>
<font color="red"> 512.     builtin = sys.modules['__builtin__']</font>
<font color="red"> 513.     if hasattr(builtin, object.__name__):</font>
<font color="red"> 514.         builtinobject = getattr(builtin, object.__name__)</font>
<font color="red"> 515.         if builtinobject is object:</font>
<font color="red"> 516.             return builtin</font>
<font color="black"> 517. </font>
<font color="green"> 518. def findsource(object):</font>
<font color="black"> 519.     &quot;&quot;&quot;Return the entire source file and starting line number for an object.</font>
<font color="black"> 520. </font>
<font color="black"> 521.     The argument may be a module, class, method, function, traceback, frame,</font>
<font color="black"> 522.     or code object.  The source code is returned as a list of all the lines</font>
<font color="black"> 523.     in the file and the line number indexes a line in that list.  An IOError</font>
<font color="black"> 524.     is raised if the source code cannot be retrieved.&quot;&quot;&quot;</font>
<font color="black"> 525. </font>
<font color="red"> 526.     file = getfile(object)</font>
<font color="red"> 527.     sourcefile = getsourcefile(object)</font>
<font color="red"> 528.     if not sourcefile and file[:1] + file[-1:] != '&lt;&gt;':</font>
<font color="red"> 529.         raise IOError('source code not available')</font>
<font color="red"> 530.     file = sourcefile if sourcefile else file</font>
<font color="black"> 531. </font>
<font color="red"> 532.     module = getmodule(object, file)</font>
<font color="red"> 533.     if module:</font>
<font color="red"> 534.         lines = linecache.getlines(file, module.__dict__)</font>
<font color="black"> 535.     else:</font>
<font color="red"> 536.         lines = linecache.getlines(file)</font>
<font color="red"> 537.     if not lines:</font>
<font color="red"> 538.         raise IOError('could not get source code')</font>
<font color="black"> 539. </font>
<font color="red"> 540.     if ismodule(object):</font>
<font color="red"> 541.         return lines, 0</font>
<font color="black"> 542. </font>
<font color="red"> 543.     if isclass(object):</font>
<font color="red"> 544.         name = object.__name__</font>
<font color="red"> 545.         pat = re.compile(r'^(\s*)class\s*' + name + r'\b')</font>
<font color="black"> 546.         # make some effort to find the best matching class definition:</font>
<font color="black"> 547.         # use the one with the least indentation, which is the one</font>
<font color="black"> 548.         # that's most probably not inside a function definition.</font>
<font color="red"> 549.         candidates = []</font>
<font color="red"> 550.         for i in range(len(lines)):</font>
<font color="red"> 551.             match = pat.match(lines[i])</font>
<font color="red"> 552.             if match:</font>
<font color="black"> 553.                 # if it's at toplevel, it's already the best one</font>
<font color="red"> 554.                 if lines[i][0] == 'c':</font>
<font color="red"> 555.                     return lines, i</font>
<font color="black"> 556.                 # else add whitespace to candidate list</font>
<font color="red"> 557.                 candidates.append((match.group(1), i))</font>
<font color="red"> 558.         if candidates:</font>
<font color="black"> 559.             # this will sort by whitespace, and by line number,</font>
<font color="black"> 560.             # less whitespace first</font>
<font color="red"> 561.             candidates.sort()</font>
<font color="red"> 562.             return lines, candidates[0][1]</font>
<font color="black"> 563.         else:</font>
<font color="red"> 564.             raise IOError('could not find class definition')</font>
<font color="black"> 565. </font>
<font color="red"> 566.     if ismethod(object):</font>
<font color="red"> 567.         object = object.im_func</font>
<font color="red"> 568.     if isfunction(object):</font>
<font color="red"> 569.         object = object.func_code</font>
<font color="red"> 570.     if istraceback(object):</font>
<font color="red"> 571.         object = object.tb_frame</font>
<font color="red"> 572.     if isframe(object):</font>
<font color="red"> 573.         object = object.f_code</font>
<font color="red"> 574.     if iscode(object):</font>
<font color="red"> 575.         if not hasattr(object, 'co_firstlineno'):</font>
<font color="red"> 576.             raise IOError('could not find function definition')</font>
<font color="red"> 577.         lnum = object.co_firstlineno - 1</font>
<font color="red"> 578.         pat = re.compile(r'^(\s*def\s)|(.*(?&lt;!\w)lambda(:|\s))|^(\s*@)')</font>
<font color="red"> 579.         while lnum &gt; 0:</font>
<font color="red"> 580.             if pat.match(lines[lnum]): break</font>
<font color="red"> 581.             lnum = lnum - 1</font>
<font color="red"> 582.         return lines, lnum</font>
<font color="red"> 583.     raise IOError('could not find code object')</font>
<font color="black"> 584. </font>
<font color="green"> 585. def getcomments(object):</font>
<font color="black"> 586.     &quot;&quot;&quot;Get lines of comments immediately preceding an object's source code.</font>
<font color="black"> 587. </font>
<font color="black"> 588.     Returns None when source can't be found.</font>
<font color="black"> 589.     &quot;&quot;&quot;</font>
<font color="red"> 590.     try:</font>
<font color="red"> 591.         lines, lnum = findsource(object)</font>
<font color="red"> 592.     except (IOError, TypeError):</font>
<font color="red"> 593.         return None</font>
<font color="black"> 594. </font>
<font color="red"> 595.     if ismodule(object):</font>
<font color="black"> 596.         # Look for a comment block at the top of the file.</font>
<font color="red"> 597.         start = 0</font>
<font color="red"> 598.         if lines and lines[0][:2] == '#!': start = 1</font>
<font color="red"> 599.         while start &lt; len(lines) and string.strip(lines[start]) in ('', '#'):</font>
<font color="red"> 600.             start = start + 1</font>
<font color="red"> 601.         if start &lt; len(lines) and lines[start][:1] == '#':</font>
<font color="red"> 602.             comments = []</font>
<font color="red"> 603.             end = start</font>
<font color="red"> 604.             while end &lt; len(lines) and lines[end][:1] == '#':</font>
<font color="red"> 605.                 comments.append(string.expandtabs(lines[end]))</font>
<font color="red"> 606.                 end = end + 1</font>
<font color="red"> 607.             return string.join(comments, '')</font>
<font color="black"> 608. </font>
<font color="black"> 609.     # Look for a preceding block of comments at the same indentation.</font>
<font color="red"> 610.     elif lnum &gt; 0:</font>
<font color="red"> 611.         indent = indentsize(lines[lnum])</font>
<font color="red"> 612.         end = lnum - 1</font>
<font color="red"> 613.         if end &gt;= 0 and string.lstrip(lines[end])[:1] == '#' and \</font>
<font color="red"> 614.             indentsize(lines[end]) == indent:</font>
<font color="red"> 615.             comments = [string.lstrip(string.expandtabs(lines[end]))]</font>
<font color="red"> 616.             if end &gt; 0:</font>
<font color="red"> 617.                 end = end - 1</font>
<font color="red"> 618.                 comment = string.lstrip(string.expandtabs(lines[end]))</font>
<font color="red"> 619.                 while comment[:1] == '#' and indentsize(lines[end]) == indent:</font>
<font color="red"> 620.                     comments[:0] = [comment]</font>
<font color="red"> 621.                     end = end - 1</font>
<font color="red"> 622.                     if end &lt; 0: break</font>
<font color="red"> 623.                     comment = string.lstrip(string.expandtabs(lines[end]))</font>
<font color="red"> 624.             while comments and string.strip(comments[0]) == '#':</font>
<font color="red"> 625.                 comments[:1] = []</font>
<font color="red"> 626.             while comments and string.strip(comments[-1]) == '#':</font>
<font color="red"> 627.                 comments[-1:] = []</font>
<font color="red"> 628.             return string.join(comments, '')</font>
<font color="black"> 629. </font>
<font color="green"> 630. class EndOfBlock(Exception): pass</font>
<font color="black"> 631. </font>
<font color="green"> 632. class BlockFinder:</font>
<font color="green"> 633.     &quot;&quot;&quot;Provide a tokeneater() method to detect the end of a code block.&quot;&quot;&quot;</font>
<font color="green"> 634.     def __init__(self):</font>
<font color="red"> 635.         self.indent = 0</font>
<font color="red"> 636.         self.islambda = False</font>
<font color="red"> 637.         self.started = False</font>
<font color="red"> 638.         self.passline = False</font>
<font color="red"> 639.         self.last = 1</font>
<font color="black"> 640. </font>
<font color="green"> 641.     def tokeneater(self, type, token, srow_scol, erow_ecol, line):</font>
<font color="red"> 642.         srow, scol = srow_scol</font>
<font color="red"> 643.         erow, ecol = erow_ecol</font>
<font color="red"> 644.         if not self.started:</font>
<font color="black"> 645.             # look for the first &quot;def&quot;, &quot;class&quot; or &quot;lambda&quot;</font>
<font color="red"> 646.             if token in (&quot;def&quot;, &quot;class&quot;, &quot;lambda&quot;):</font>
<font color="red"> 647.                 if token == &quot;lambda&quot;:</font>
<font color="red"> 648.                     self.islambda = True</font>
<font color="red"> 649.                 self.started = True</font>
<font color="red"> 650.             self.passline = True    # skip to the end of the line</font>
<font color="red"> 651.         elif type == tokenize.NEWLINE:</font>
<font color="red"> 652.             self.passline = False   # stop skipping when a NEWLINE is seen</font>
<font color="red"> 653.             self.last = srow</font>
<font color="red"> 654.             if self.islambda:       # lambdas always end at the first NEWLINE</font>
<font color="red"> 655.                 raise EndOfBlock</font>
<font color="red"> 656.         elif self.passline:</font>
<font color="red"> 657.             pass</font>
<font color="red"> 658.         elif type == tokenize.INDENT:</font>
<font color="red"> 659.             self.indent = self.indent + 1</font>
<font color="red"> 660.             self.passline = True</font>
<font color="red"> 661.         elif type == tokenize.DEDENT:</font>
<font color="red"> 662.             self.indent = self.indent - 1</font>
<font color="black"> 663.             # the end of matching indent/dedent pairs end a block</font>
<font color="black"> 664.             # (note that this only works for &quot;def&quot;/&quot;class&quot; blocks,</font>
<font color="black"> 665.             #  not e.g. for &quot;if: else:&quot; or &quot;try: finally:&quot; blocks)</font>
<font color="red"> 666.             if self.indent &lt;= 0:</font>
<font color="red"> 667.                 raise EndOfBlock</font>
<font color="red"> 668.         elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):</font>
<font color="black"> 669.             # any other token on the same indentation level end the previous</font>
<font color="black"> 670.             # block as well, except the pseudo-tokens COMMENT and NL.</font>
<font color="red"> 671.             raise EndOfBlock</font>
<font color="black"> 672. </font>
<font color="green"> 673. def getblock(lines):</font>
<font color="black"> 674.     &quot;&quot;&quot;Extract the block of code at the top of the given list of lines.&quot;&quot;&quot;</font>
<font color="red"> 675.     blockfinder = BlockFinder()</font>
<font color="red"> 676.     try:</font>
<font color="red"> 677.         tokenize.tokenize(iter(lines).next, blockfinder.tokeneater)</font>
<font color="red"> 678.     except (EndOfBlock, IndentationError):</font>
<font color="red"> 679.         pass</font>
<font color="red"> 680.     return lines[:blockfinder.last]</font>
<font color="black"> 681. </font>
<font color="green"> 682. def getsourcelines(object):</font>
<font color="black"> 683.     &quot;&quot;&quot;Return a list of source lines and starting line number for an object.</font>
<font color="black"> 684. </font>
<font color="black"> 685.     The argument may be a module, class, method, function, traceback, frame,</font>
<font color="black"> 686.     or code object.  The source code is returned as a list of the lines</font>
<font color="black"> 687.     corresponding to the object and the line number indicates where in the</font>
<font color="black"> 688.     original source file the first line of code was found.  An IOError is</font>
<font color="black"> 689.     raised if the source code cannot be retrieved.&quot;&quot;&quot;</font>
<font color="red"> 690.     lines, lnum = findsource(object)</font>
<font color="black"> 691. </font>
<font color="red"> 692.     if ismodule(object): return lines, 0</font>
<font color="red"> 693.     else: return getblock(lines[lnum:]), lnum + 1</font>
<font color="black"> 694. </font>
<font color="green"> 695. def getsource(object):</font>
<font color="black"> 696.     &quot;&quot;&quot;Return the text of the source code for an object.</font>
<font color="black"> 697. </font>
<font color="black"> 698.     The argument may be a module, class, method, function, traceback, frame,</font>
<font color="black"> 699.     or code object.  The source code is returned as a single string.  An</font>
<font color="black"> 700.     IOError is raised if the source code cannot be retrieved.&quot;&quot;&quot;</font>
<font color="red"> 701.     lines, lnum = getsourcelines(object)</font>
<font color="red"> 702.     return string.join(lines, '')</font>
<font color="black"> 703. </font>
<font color="black"> 704. # --------------------------------------------------- class tree extraction</font>
<font color="green"> 705. def walktree(classes, children, parent):</font>
<font color="black"> 706.     &quot;&quot;&quot;Recursive helper function for getclasstree().&quot;&quot;&quot;</font>
<font color="red"> 707.     results = []</font>
<font color="red"> 708.     classes.sort(key=attrgetter('__module__', '__name__'))</font>
<font color="red"> 709.     for c in classes:</font>
<font color="red"> 710.         results.append((c, c.__bases__))</font>
<font color="red"> 711.         if c in children:</font>
<font color="red"> 712.             results.append(walktree(children[c], children, c))</font>
<font color="red"> 713.     return results</font>
<font color="black"> 714. </font>
<font color="green"> 715. def getclasstree(classes, unique=0):</font>
<font color="black"> 716.     &quot;&quot;&quot;Arrange the given list of classes into a hierarchy of nested lists.</font>
<font color="black"> 717. </font>
<font color="black"> 718.     Where a nested list appears, it contains classes derived from the class</font>
<font color="black"> 719.     whose entry immediately precedes the list.  Each entry is a 2-tuple</font>
<font color="black"> 720.     containing a class and a tuple of its base classes.  If the 'unique'</font>
<font color="black"> 721.     argument is true, exactly one entry appears in the returned structure</font>
<font color="black"> 722.     for each class in the given list.  Otherwise, classes using multiple</font>
<font color="black"> 723.     inheritance and their descendants will appear multiple times.&quot;&quot;&quot;</font>
<font color="red"> 724.     children = {}</font>
<font color="red"> 725.     roots = []</font>
<font color="red"> 726.     for c in classes:</font>
<font color="red"> 727.         if c.__bases__:</font>
<font color="red"> 728.             for parent in c.__bases__:</font>
<font color="red"> 729.                 if not parent in children:</font>
<font color="red"> 730.                     children[parent] = []</font>
<font color="red"> 731.                 if c not in children[parent]:</font>
<font color="red"> 732.                     children[parent].append(c)</font>
<font color="red"> 733.                 if unique and parent in classes: break</font>
<font color="red"> 734.         elif c not in roots:</font>
<font color="red"> 735.             roots.append(c)</font>
<font color="red"> 736.     for parent in children:</font>
<font color="red"> 737.         if parent not in classes:</font>
<font color="red"> 738.             roots.append(parent)</font>
<font color="red"> 739.     return walktree(roots, children, None)</font>
<font color="black"> 740. </font>
<font color="black"> 741. # ------------------------------------------------ argument list extraction</font>
<font color="green"> 742. Arguments = namedtuple('Arguments', 'args varargs keywords')</font>
<font color="black"> 743. </font>
<font color="green"> 744. def getargs(co):</font>
<font color="black"> 745.     &quot;&quot;&quot;Get information about the arguments accepted by a code object.</font>
<font color="black"> 746. </font>
<font color="black"> 747.     Three things are returned: (args, varargs, varkw), where 'args' is</font>
<font color="black"> 748.     a list of argument names (possibly containing nested lists), and</font>
<font color="black"> 749.     'varargs' and 'varkw' are the names of the * and ** arguments or None.&quot;&quot;&quot;</font>
<font color="black"> 750. </font>
<font color="green"> 751.     if not iscode(co):</font>
<font color="red"> 752.         raise TypeError('{!r} is not a code object'.format(co))</font>
<font color="black"> 753. </font>
<font color="green"> 754.     nargs = co.co_argcount</font>
<font color="green"> 755.     names = co.co_varnames</font>
<font color="green"> 756.     args = list(names[:nargs])</font>
<font color="green"> 757.     step = 0</font>
<font color="black"> 758. </font>
<font color="black"> 759.     # The following acrobatics are for anonymous (tuple) arguments.</font>
<font color="green"> 760.     for i in range(nargs):</font>
<font color="green"> 761.         if args[i][:1] in ('', '.'):</font>
<font color="red"> 762.             stack, remain, count = [], [], []</font>
<font color="red"> 763.             while step &lt; len(co.co_code):</font>
<font color="red"> 764.                 op = ord(co.co_code[step])</font>
<font color="red"> 765.                 step = step + 1</font>
<font color="red"> 766.                 if op &gt;= dis.HAVE_ARGUMENT:</font>
<font color="red"> 767.                     opname = dis.opname[op]</font>
<font color="red"> 768.                     value = ord(co.co_code[step]) + ord(co.co_code[step+1])*256</font>
<font color="red"> 769.                     step = step + 2</font>
<font color="red"> 770.                     if opname in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):</font>
<font color="red"> 771.                         remain.append(value)</font>
<font color="red"> 772.                         count.append(value)</font>
<font color="red"> 773.                     elif opname == 'STORE_FAST':</font>
<font color="red"> 774.                         stack.append(names[value])</font>
<font color="black"> 775. </font>
<font color="black"> 776.                         # Special case for sublists of length 1: def foo((bar))</font>
<font color="black"> 777.                         # doesn't generate the UNPACK_TUPLE bytecode, so if</font>
<font color="black"> 778.                         # `remain` is empty here, we have such a sublist.</font>
<font color="red"> 779.                         if not remain:</font>
<font color="red"> 780.                             stack[0] = [stack[0]]</font>
<font color="red"> 781.                             break</font>
<font color="black"> 782.                         else:</font>
<font color="red"> 783.                             remain[-1] = remain[-1] - 1</font>
<font color="red"> 784.                             while remain[-1] == 0:</font>
<font color="red"> 785.                                 remain.pop()</font>
<font color="red"> 786.                                 size = count.pop()</font>
<font color="red"> 787.                                 stack[-size:] = [stack[-size:]]</font>
<font color="red"> 788.                                 if not remain: break</font>
<font color="red"> 789.                                 remain[-1] = remain[-1] - 1</font>
<font color="red"> 790.                             if not remain: break</font>
<font color="red"> 791.             args[i] = stack[0]</font>
<font color="black"> 792. </font>
<font color="green"> 793.     varargs = None</font>
<font color="green"> 794.     if co.co_flags &amp; CO_VARARGS:</font>
<font color="red"> 795.         varargs = co.co_varnames[nargs]</font>
<font color="red"> 796.         nargs = nargs + 1</font>
<font color="green"> 797.     varkw = None</font>
<font color="green"> 798.     if co.co_flags &amp; CO_VARKEYWORDS:</font>
<font color="green"> 799.         varkw = co.co_varnames[nargs]</font>
<font color="green"> 800.     return Arguments(args, varargs, varkw)</font>
<font color="black"> 801. </font>
<font color="green"> 802. ArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')</font>
<font color="black"> 803. </font>
<font color="green"> 804. def getargspec(func):</font>
<font color="black"> 805.     &quot;&quot;&quot;Get the names and default values of a function's arguments.</font>
<font color="black"> 806. </font>
<font color="black"> 807.     A tuple of four things is returned: (args, varargs, varkw, defaults).</font>
<font color="black"> 808.     'args' is a list of the argument names (it may contain nested lists).</font>
<font color="black"> 809.     'varargs' and 'varkw' are the names of the * and ** arguments or None.</font>
<font color="black"> 810.     'defaults' is an n-tuple of the default values of the last n arguments.</font>
<font color="black"> 811.     &quot;&quot;&quot;</font>
<font color="black"> 812. </font>
<font color="green"> 813.     if ismethod(func):</font>
<font color="green"> 814.         func = func.im_func</font>
<font color="green"> 815.     if not isfunction(func):</font>
<font color="red"> 816.         raise TypeError('{!r} is not a Python function'.format(func))</font>
<font color="green"> 817.     args, varargs, varkw = getargs(func.func_code)</font>
<font color="green"> 818.     return ArgSpec(args, varargs, varkw, func.func_defaults)</font>
<font color="black"> 819. </font>
<font color="green"> 820. ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')</font>
<font color="black"> 821. </font>
<font color="green"> 822. def getargvalues(frame):</font>
<font color="black"> 823.     &quot;&quot;&quot;Get information about arguments passed into a particular frame.</font>
<font color="black"> 824. </font>
<font color="black"> 825.     A tuple of four things is returned: (args, varargs, varkw, locals).</font>
<font color="black"> 826.     'args' is a list of the argument names (it may contain nested lists).</font>
<font color="black"> 827.     'varargs' and 'varkw' are the names of the * and ** arguments or None.</font>
<font color="black"> 828.     'locals' is the locals dictionary of the given frame.&quot;&quot;&quot;</font>
<font color="red"> 829.     args, varargs, varkw = getargs(frame.f_code)</font>
<font color="red"> 830.     return ArgInfo(args, varargs, varkw, frame.f_locals)</font>
<font color="black"> 831. </font>
<font color="green"> 832. def joinseq(seq):</font>
<font color="red"> 833.     if len(seq) == 1:</font>
<font color="red"> 834.         return '(' + seq[0] + ',)'</font>
<font color="black"> 835.     else:</font>
<font color="red"> 836.         return '(' + string.join(seq, ', ') + ')'</font>
<font color="black"> 837. </font>
<font color="green"> 838. def strseq(object, convert, join=joinseq):</font>
<font color="black"> 839.     &quot;&quot;&quot;Recursively walk a sequence, stringifying each element.&quot;&quot;&quot;</font>
<font color="red"> 840.     if type(object) in (list, tuple):</font>
<font color="red"> 841.         return join(map(lambda o, c=convert, j=join: strseq(o, c, j), object))</font>
<font color="black"> 842.     else:</font>
<font color="red"> 843.         return convert(object)</font>
<font color="black"> 844. </font>
<font color="green"> 845. def formatargspec(args, varargs=None, varkw=None, defaults=None,</font>
<font color="green"> 846.                   formatarg=str,</font>
<font color="green"> 847.                   formatvarargs=lambda name: '*' + name,</font>
<font color="green"> 848.                   formatvarkw=lambda name: '**' + name,</font>
<font color="green"> 849.                   formatvalue=lambda value: '=' + repr(value),</font>
<font color="green"> 850.                   join=joinseq):</font>
<font color="black"> 851.     &quot;&quot;&quot;Format an argument spec from the 4 values returned by getargspec.</font>
<font color="black"> 852. </font>
<font color="black"> 853.     The first four arguments are (args, varargs, varkw, defaults).  The</font>
<font color="black"> 854.     other four arguments are the corresponding optional formatting functions</font>
<font color="black"> 855.     that are called to turn names and values into strings.  The ninth</font>
<font color="black"> 856.     argument is an optional function to format the sequence of arguments.&quot;&quot;&quot;</font>
<font color="red"> 857.     specs = []</font>
<font color="red"> 858.     if defaults:</font>
<font color="red"> 859.         firstdefault = len(args) - len(defaults)</font>
<font color="red"> 860.     for i, arg in enumerate(args):</font>
<font color="red"> 861.         spec = strseq(arg, formatarg, join)</font>
<font color="red"> 862.         if defaults and i &gt;= firstdefault:</font>
<font color="red"> 863.             spec = spec + formatvalue(defaults[i - firstdefault])</font>
<font color="red"> 864.         specs.append(spec)</font>
<font color="red"> 865.     if varargs is not None:</font>
<font color="red"> 866.         specs.append(formatvarargs(varargs))</font>
<font color="red"> 867.     if varkw is not None:</font>
<font color="red"> 868.         specs.append(formatvarkw(varkw))</font>
<font color="red"> 869.     return '(' + string.join(specs, ', ') + ')'</font>
<font color="black"> 870. </font>
<font color="black"> 871. def formatargvalues(args, varargs, varkw, locals,</font>
<font color="green"> 872.                     formatarg=str,</font>
<font color="green"> 873.                     formatvarargs=lambda name: '*' + name,</font>
<font color="green"> 874.                     formatvarkw=lambda name: '**' + name,</font>
<font color="green"> 875.                     formatvalue=lambda value: '=' + repr(value),</font>
<font color="green"> 876.                     join=joinseq):</font>
<font color="black"> 877.     &quot;&quot;&quot;Format an argument spec from the 4 values returned by getargvalues.</font>
<font color="black"> 878. </font>
<font color="black"> 879.     The first four arguments are (args, varargs, varkw, locals).  The</font>
<font color="black"> 880.     next four arguments are the corresponding optional formatting functions</font>
<font color="black"> 881.     that are called to turn names and values into strings.  The ninth</font>
<font color="black"> 882.     argument is an optional function to format the sequence of arguments.&quot;&quot;&quot;</font>
<font color="red"> 883.     def convert(name, locals=locals,</font>
<font color="red"> 884.                 formatarg=formatarg, formatvalue=formatvalue):</font>
<font color="red"> 885.         return formatarg(name) + formatvalue(locals[name])</font>
<font color="red"> 886.     specs = []</font>
<font color="red"> 887.     for i in range(len(args)):</font>
<font color="red"> 888.         specs.append(strseq(args[i], convert, join))</font>
<font color="red"> 889.     if varargs:</font>
<font color="red"> 890.         specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))</font>
<font color="red"> 891.     if varkw:</font>
<font color="red"> 892.         specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))</font>
<font color="red"> 893.     return '(' + string.join(specs, ', ') + ')'</font>
<font color="black"> 894. </font>
<font color="green"> 895. def getcallargs(func, *positional, **named):</font>
<font color="black"> 896.     &quot;&quot;&quot;Get the mapping of arguments to values.</font>
<font color="black"> 897. </font>
<font color="black"> 898.     A dict is returned, with keys the function argument names (including the</font>
<font color="black"> 899.     names of the * and ** arguments, if any), and values the respective bound</font>
<font color="black"> 900.     values from 'positional' and 'named'.&quot;&quot;&quot;</font>
<font color="green"> 901.     args, varargs, varkw, defaults = getargspec(func)</font>
<font color="green"> 902.     f_name = func.__name__</font>
<font color="green"> 903.     arg2value = {}</font>
<font color="black"> 904. </font>
<font color="black"> 905.     # The following closures are basically because of tuple parameter unpacking.</font>
<font color="green"> 906.     assigned_tuple_params = []</font>
<font color="green"> 907.     def assign(arg, value):</font>
<font color="green"> 908.         if isinstance(arg, str):</font>
<font color="green"> 909.             arg2value[arg] = value</font>
<font color="black"> 910.         else:</font>
<font color="red"> 911.             assigned_tuple_params.append(arg)</font>
<font color="red"> 912.             value = iter(value)</font>
<font color="red"> 913.             for i, subarg in enumerate(arg):</font>
<font color="red"> 914.                 try:</font>
<font color="red"> 915.                     subvalue = next(value)</font>
<font color="red"> 916.                 except StopIteration:</font>
<font color="red"> 917.                     raise ValueError('need more than %d %s to unpack' %</font>
<font color="red"> 918.                                      (i, 'values' if i &gt; 1 else 'value'))</font>
<font color="red"> 919.                 assign(subarg,subvalue)</font>
<font color="red"> 920.             try:</font>
<font color="red"> 921.                 next(value)</font>
<font color="red"> 922.             except StopIteration:</font>
<font color="red"> 923.                 pass</font>
<font color="black"> 924.             else:</font>
<font color="red"> 925.                 raise ValueError('too many values to unpack')</font>
<font color="green"> 926.     def is_assigned(arg):</font>
<font color="green"> 927.         if isinstance(arg,str):</font>
<font color="green"> 928.             return arg in arg2value</font>
<font color="red"> 929.         return arg in assigned_tuple_params</font>
<font color="green"> 930.     if ismethod(func) and func.im_self is not None:</font>
<font color="black"> 931.         # implicit 'self' (or 'cls' for classmethods) argument</font>
<font color="red"> 932.         positional = (func.im_self,) + positional</font>
<font color="green"> 933.     num_pos = len(positional)</font>
<font color="green"> 934.     num_total = num_pos + len(named)</font>
<font color="green"> 935.     num_args = len(args)</font>
<font color="green"> 936.     num_defaults = len(defaults) if defaults else 0</font>
<font color="green"> 937.     for arg, value in zip(args, positional):</font>
<font color="green"> 938.         assign(arg, value)</font>
<font color="green"> 939.     if varargs:</font>
<font color="red"> 940.         if num_pos &gt; num_args:</font>
<font color="red"> 941.             assign(varargs, positional[-(num_pos-num_args):])</font>
<font color="black"> 942.         else:</font>
<font color="red"> 943.             assign(varargs, ())</font>
<font color="green"> 944.     elif 0 &lt; num_args &lt; num_pos:</font>
<font color="red"> 945.         raise TypeError('%s() takes %s %d %s (%d given)' % (</font>
<font color="red"> 946.             f_name, 'at most' if defaults else 'exactly', num_args,</font>
<font color="red"> 947.             'arguments' if num_args &gt; 1 else 'argument', num_total))</font>
<font color="green"> 948.     elif num_args == 0 and num_total:</font>
<font color="red"> 949.         if varkw:</font>
<font color="red"> 950.             if num_pos:</font>
<font color="black"> 951.                 # XXX: We should use num_pos, but Python also uses num_total:</font>
<font color="red"> 952.                 raise TypeError('%s() takes exactly 0 arguments '</font>
<font color="red"> 953.                                 '(%d given)' % (f_name, num_total))</font>
<font color="black"> 954.         else:</font>
<font color="red"> 955.             raise TypeError('%s() takes no arguments (%d given)' %</font>
<font color="red"> 956.                             (f_name, num_total))</font>
<font color="green"> 957.     for arg in args:</font>
<font color="green"> 958.         if isinstance(arg, str) and arg in named:</font>
<font color="red"> 959.             if is_assigned(arg):</font>
<font color="red"> 960.                 raise TypeError(&quot;%s() got multiple values for keyword &quot;</font>
<font color="red"> 961.                                 &quot;argument '%s'&quot; % (f_name, arg))</font>
<font color="black"> 962.             else:</font>
<font color="red"> 963.                 assign(arg, named.pop(arg))</font>
<font color="green"> 964.     if defaults:    # fill in any missing values with the defaults</font>
<font color="green"> 965.         for arg, value in zip(args[-num_defaults:], defaults):</font>
<font color="green"> 966.             if not is_assigned(arg):</font>
<font color="green"> 967.                 assign(arg, value)</font>
<font color="green"> 968.     if varkw:</font>
<font color="red"> 969.         assign(varkw, named)</font>
<font color="green"> 970.     elif named:</font>
<font color="red"> 971.         unexpected = next(iter(named))</font>
<font color="red"> 972.         if isinstance(unexpected, unicode):</font>
<font color="red"> 973.             unexpected = unexpected.encode(sys.getdefaultencoding(), 'replace')</font>
<font color="red"> 974.         raise TypeError(&quot;%s() got an unexpected keyword argument '%s'&quot; %</font>
<font color="red"> 975.                         (f_name, unexpected))</font>
<font color="green"> 976.     unassigned = num_args - len([arg for arg in args if is_assigned(arg)])</font>
<font color="green"> 977.     if unassigned:</font>
<font color="red"> 978.         num_required = num_args - num_defaults</font>
<font color="red"> 979.         raise TypeError('%s() takes %s %d %s (%d given)' % (</font>
<font color="red"> 980.             f_name, 'at least' if defaults else 'exactly', num_required,</font>
<font color="red"> 981.             'arguments' if num_required &gt; 1 else 'argument', num_total))</font>
<font color="green"> 982.     return arg2value</font>
<font color="black"> 983. </font>
<font color="black"> 984. # -------------------------------------------------- stack frame extraction</font>
<font color="black"> 985. </font>
<font color="green"> 986. Traceback = namedtuple('Traceback', 'filename lineno function code_context index')</font>
<font color="black"> 987. </font>
<font color="green"> 988. def getframeinfo(frame, context=1):</font>
<font color="black"> 989.     &quot;&quot;&quot;Get information about a frame or traceback object.</font>
<font color="black"> 990. </font>
<font color="black"> 991.     A tuple of five things is returned: the filename, the line number of</font>
<font color="black"> 992.     the current line, the function name, a list of lines of context from</font>
<font color="black"> 993.     the source code, and the index of the current line within that list.</font>
<font color="black"> 994.     The optional second argument specifies the number of lines of context</font>
<font color="black"> 995.     to return, which are centered around the current line.&quot;&quot;&quot;</font>
<font color="red"> 996.     if istraceback(frame):</font>
<font color="red"> 997.         lineno = frame.tb_lineno</font>
<font color="red"> 998.         frame = frame.tb_frame</font>
<font color="black"> 999.     else:</font>
<font color="red">1000.         lineno = frame.f_lineno</font>
<font color="red">1001.     if not isframe(frame):</font>
<font color="red">1002.         raise TypeError('{!r} is not a frame or traceback object'.format(frame))</font>
<font color="black">1003. </font>
<font color="red">1004.     filename = getsourcefile(frame) or getfile(frame)</font>
<font color="red">1005.     if context &gt; 0:</font>
<font color="red">1006.         start = lineno - 1 - context//2</font>
<font color="red">1007.         try:</font>
<font color="red">1008.             lines, lnum = findsource(frame)</font>
<font color="red">1009.         except IOError:</font>
<font color="red">1010.             lines = index = None</font>
<font color="black">1011.         else:</font>
<font color="red">1012.             start = max(start, 1)</font>
<font color="red">1013.             start = max(0, min(start, len(lines) - context))</font>
<font color="red">1014.             lines = lines[start:start+context]</font>
<font color="red">1015.             index = lineno - 1 - start</font>
<font color="black">1016.     else:</font>
<font color="red">1017.         lines = index = None</font>
<font color="black">1018. </font>
<font color="red">1019.     return Traceback(filename, lineno, frame.f_code.co_name, lines, index)</font>
<font color="black">1020. </font>
<font color="green">1021. def getlineno(frame):</font>
<font color="black">1022.     &quot;&quot;&quot;Get the line number from a frame object, allowing for optimization.&quot;&quot;&quot;</font>
<font color="black">1023.     # FrameType.f_lineno is now a descriptor that grovels co_lnotab</font>
<font color="red">1024.     return frame.f_lineno</font>
<font color="black">1025. </font>
<font color="green">1026. def getouterframes(frame, context=1):</font>
<font color="black">1027.     &quot;&quot;&quot;Get a list of records for a frame and all higher (calling) frames.</font>
<font color="black">1028. </font>
<font color="black">1029.     Each record contains a frame object, filename, line number, function</font>
<font color="black">1030.     name, a list of lines of context, and index within the context.&quot;&quot;&quot;</font>
<font color="red">1031.     framelist = []</font>
<font color="red">1032.     while frame:</font>
<font color="red">1033.         framelist.append((frame,) + getframeinfo(frame, context))</font>
<font color="red">1034.         frame = frame.f_back</font>
<font color="red">1035.     return framelist</font>
<font color="black">1036. </font>
<font color="green">1037. def getinnerframes(tb, context=1):</font>
<font color="black">1038.     &quot;&quot;&quot;Get a list of records for a traceback's frame and all lower frames.</font>
<font color="black">1039. </font>
<font color="black">1040.     Each record contains a frame object, filename, line number, function</font>
<font color="black">1041.     name, a list of lines of context, and index within the context.&quot;&quot;&quot;</font>
<font color="red">1042.     framelist = []</font>
<font color="red">1043.     while tb:</font>
<font color="red">1044.         framelist.append((tb.tb_frame,) + getframeinfo(tb, context))</font>
<font color="red">1045.         tb = tb.tb_next</font>
<font color="red">1046.     return framelist</font>
<font color="black">1047. </font>
<font color="green">1048. if hasattr(sys, '_getframe'):</font>
<font color="green">1049.     currentframe = sys._getframe</font>
<font color="black">1050. else:</font>
<font color="red">1051.     currentframe = lambda _=None: None</font>
<font color="black">1052. </font>
<font color="green">1053. def stack(context=1):</font>
<font color="black">1054.     &quot;&quot;&quot;Return a list of records for the stack above the caller's frame.&quot;&quot;&quot;</font>
<font color="red">1055.     return getouterframes(sys._getframe(1), context)</font>
<font color="black">1056. </font>
<font color="green">1057. def trace(context=1):</font>
<font color="black">1058.     &quot;&quot;&quot;Return a list of records for the stack below the current exception.&quot;&quot;&quot;</font>
<font color="red">1059.     return getinnerframes(sys.exc_info()[2], context)</font>
</pre>

