source file: <b>/usr/lib/python2.7/logging/__init__.py</b><br>


file stats: <b>729 lines, 325 executed: 44.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2001-2012 by Vinay Sajip. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Permission to use, copy, modify, and distribute this software and its</font>
<font color="black">   4. # documentation for any purpose and without fee is hereby granted,</font>
<font color="black">   5. # provided that the above copyright notice appear in all copies and that</font>
<font color="black">   6. # both that copyright notice and this permission notice appear in</font>
<font color="black">   7. # supporting documentation, and that the name of Vinay Sajip</font>
<font color="black">   8. # not be used in advertising or publicity pertaining to distribution</font>
<font color="black">   9. # of the software without specific, written prior permission.</font>
<font color="black">  10. # VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</font>
<font color="black">  11. # ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL</font>
<font color="black">  12. # VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</font>
<font color="black">  13. # ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER</font>
<font color="black">  14. # IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</font>
<font color="black">  15. # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</font>
<font color="black">  16. </font>
<font color="black">  17. &quot;&quot;&quot;</font>
<font color="black">  18. Logging package for Python. Based on PEP 282 and comments thereto in</font>
<font color="black">  19. comp.lang.python.</font>
<font color="black">  20. </font>
<font color="black">  21. Copyright (C) 2001-2012 Vinay Sajip. All Rights Reserved.</font>
<font color="black">  22. </font>
<font color="black">  23. To use, simply 'import logging' and log away!</font>
<font color="green">  24. &quot;&quot;&quot;</font>
<font color="black">  25. </font>
<font color="green">  26. import sys, os, time, cStringIO, traceback, warnings, weakref</font>
<font color="black">  27. </font>
<font color="green">  28. __all__ = ['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR',</font>
<font color="green">  29.            'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO',</font>
<font color="green">  30.            'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler',</font>
<font color="green">  31.            'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig',</font>
<font color="green">  32.            'captureWarnings', 'critical', 'debug', 'disable', 'error',</font>
<font color="green">  33.            'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass',</font>
<font color="green">  34.            'info', 'log', 'makeLogRecord', 'setLoggerClass', 'warn', 'warning']</font>
<font color="black">  35. </font>
<font color="green">  36. try:</font>
<font color="green">  37.     import codecs</font>
<font color="red">  38. except ImportError:</font>
<font color="red">  39.     codecs = None</font>
<font color="black">  40. </font>
<font color="green">  41. try:</font>
<font color="green">  42.     import thread</font>
<font color="green">  43.     import threading</font>
<font color="red">  44. except ImportError:</font>
<font color="red">  45.     thread = None</font>
<font color="black">  46. </font>
<font color="green">  47. __author__  = &quot;Vinay Sajip &lt;vinay_sajip@red-dove.com&gt;&quot;</font>
<font color="green">  48. __status__  = &quot;production&quot;</font>
<font color="green">  49. __version__ = &quot;0.5.1.2&quot;</font>
<font color="green">  50. __date__    = &quot;07 February 2010&quot;</font>
<font color="black">  51. </font>
<font color="black">  52. #---------------------------------------------------------------------------</font>
<font color="black">  53. #   Miscellaneous module data</font>
<font color="black">  54. #---------------------------------------------------------------------------</font>
<font color="green">  55. try:</font>
<font color="green">  56.     unicode</font>
<font color="green">  57.     _unicode = True</font>
<font color="red">  58. except NameError:</font>
<font color="red">  59.     _unicode = False</font>
<font color="black">  60. </font>
<font color="black">  61. #</font>
<font color="black">  62. # _srcfile is used when walking the stack to check when we've got the first</font>
<font color="black">  63. # caller stack frame.</font>
<font color="black">  64. #</font>
<font color="green">  65. if hasattr(sys, 'frozen'): #support for py2exe</font>
<font color="red">  66.     _srcfile = &quot;logging%s__init__%s&quot; % (os.sep, __file__[-4:])</font>
<font color="green">  67. elif __file__[-4:].lower() in ['.pyc', '.pyo']:</font>
<font color="green">  68.     _srcfile = __file__[:-4] + '.py'</font>
<font color="black">  69. else:</font>
<font color="red">  70.     _srcfile = __file__</font>
<font color="green">  71. _srcfile = os.path.normcase(_srcfile)</font>
<font color="black">  72. </font>
<font color="black">  73. # next bit filched from 1.5.2's inspect.py</font>
<font color="green">  74. def currentframe():</font>
<font color="black">  75.     &quot;&quot;&quot;Return the frame object for the caller's stack frame.&quot;&quot;&quot;</font>
<font color="red">  76.     try:</font>
<font color="red">  77.         raise Exception</font>
<font color="red">  78.     except:</font>
<font color="red">  79.         return sys.exc_info()[2].tb_frame.f_back</font>
<font color="black">  80. </font>
<font color="green">  81. if hasattr(sys, '_getframe'): currentframe = lambda: sys._getframe(3)</font>
<font color="black">  82. # done filching</font>
<font color="black">  83. </font>
<font color="black">  84. # _srcfile is only used in conjunction with sys._getframe().</font>
<font color="black">  85. # To provide compatibility with older versions of Python, set _srcfile</font>
<font color="black">  86. # to None if _getframe() is not available; this value will prevent</font>
<font color="black">  87. # findCaller() from being called.</font>
<font color="black">  88. #if not hasattr(sys, &quot;_getframe&quot;):</font>
<font color="black">  89. #    _srcfile = None</font>
<font color="black">  90. </font>
<font color="black">  91. #</font>
<font color="black">  92. #_startTime is used as the base when calculating the relative time of events</font>
<font color="black">  93. #</font>
<font color="green">  94. _startTime = time.time()</font>
<font color="black">  95. </font>
<font color="black">  96. #</font>
<font color="black">  97. #raiseExceptions is used to see if exceptions during handling should be</font>
<font color="black">  98. #propagated</font>
<font color="black">  99. #</font>
<font color="green"> 100. raiseExceptions = 1</font>
<font color="black"> 101. </font>
<font color="black"> 102. #</font>
<font color="black"> 103. # If you don't want threading information in the log, set this to zero</font>
<font color="black"> 104. #</font>
<font color="green"> 105. logThreads = 1</font>
<font color="black"> 106. </font>
<font color="black"> 107. #</font>
<font color="black"> 108. # If you don't want multiprocessing information in the log, set this to zero</font>
<font color="black"> 109. #</font>
<font color="green"> 110. logMultiprocessing = 1</font>
<font color="black"> 111. </font>
<font color="black"> 112. #</font>
<font color="black"> 113. # If you don't want process information in the log, set this to zero</font>
<font color="black"> 114. #</font>
<font color="green"> 115. logProcesses = 1</font>
<font color="black"> 116. </font>
<font color="black"> 117. #---------------------------------------------------------------------------</font>
<font color="black"> 118. #   Level related stuff</font>
<font color="black"> 119. #---------------------------------------------------------------------------</font>
<font color="black"> 120. #</font>
<font color="black"> 121. # Default levels and level names, these can be replaced with any positive set</font>
<font color="black"> 122. # of values having corresponding names. There is a pseudo-level, NOTSET, which</font>
<font color="black"> 123. # is only really there as a lower limit for user-defined levels. Handlers and</font>
<font color="black"> 124. # loggers are initialized with NOTSET so that they will log all messages, even</font>
<font color="black"> 125. # at user-defined levels.</font>
<font color="black"> 126. #</font>
<font color="black"> 127. </font>
<font color="green"> 128. CRITICAL = 50</font>
<font color="green"> 129. FATAL = CRITICAL</font>
<font color="green"> 130. ERROR = 40</font>
<font color="green"> 131. WARNING = 30</font>
<font color="green"> 132. WARN = WARNING</font>
<font color="green"> 133. INFO = 20</font>
<font color="green"> 134. DEBUG = 10</font>
<font color="green"> 135. NOTSET = 0</font>
<font color="black"> 136. </font>
<font color="green"> 137. _levelNames = {</font>
<font color="green"> 138.     CRITICAL : 'CRITICAL',</font>
<font color="green"> 139.     ERROR : 'ERROR',</font>
<font color="green"> 140.     WARNING : 'WARNING',</font>
<font color="green"> 141.     INFO : 'INFO',</font>
<font color="green"> 142.     DEBUG : 'DEBUG',</font>
<font color="green"> 143.     NOTSET : 'NOTSET',</font>
<font color="green"> 144.     'CRITICAL' : CRITICAL,</font>
<font color="green"> 145.     'ERROR' : ERROR,</font>
<font color="green"> 146.     'WARN' : WARNING,</font>
<font color="green"> 147.     'WARNING' : WARNING,</font>
<font color="green"> 148.     'INFO' : INFO,</font>
<font color="green"> 149.     'DEBUG' : DEBUG,</font>
<font color="green"> 150.     'NOTSET' : NOTSET,</font>
<font color="black"> 151. }</font>
<font color="black"> 152. </font>
<font color="green"> 153. def getLevelName(level):</font>
<font color="black"> 154.     &quot;&quot;&quot;</font>
<font color="black"> 155.     Return the textual representation of logging level 'level'.</font>
<font color="black"> 156. </font>
<font color="black"> 157.     If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,</font>
<font color="black"> 158.     INFO, DEBUG) then you get the corresponding string. If you have</font>
<font color="black"> 159.     associated levels with names using addLevelName then the name you have</font>
<font color="black"> 160.     associated with 'level' is returned.</font>
<font color="black"> 161. </font>
<font color="black"> 162.     If a numeric value corresponding to one of the defined levels is passed</font>
<font color="black"> 163.     in, the corresponding string representation is returned.</font>
<font color="black"> 164. </font>
<font color="black"> 165.     Otherwise, the string &quot;Level %s&quot; % level is returned.</font>
<font color="black"> 166.     &quot;&quot;&quot;</font>
<font color="red"> 167.     return _levelNames.get(level, (&quot;Level %s&quot; % level))</font>
<font color="black"> 168. </font>
<font color="green"> 169. def addLevelName(level, levelName):</font>
<font color="black"> 170.     &quot;&quot;&quot;</font>
<font color="black"> 171.     Associate 'levelName' with 'level'.</font>
<font color="black"> 172. </font>
<font color="black"> 173.     This is used when converting levels to text during message formatting.</font>
<font color="black"> 174.     &quot;&quot;&quot;</font>
<font color="red"> 175.     _acquireLock()</font>
<font color="red"> 176.     try:    #unlikely to cause an exception, but you never know...</font>
<font color="red"> 177.         _levelNames[level] = levelName</font>
<font color="red"> 178.         _levelNames[levelName] = level</font>
<font color="black"> 179.     finally:</font>
<font color="red"> 180.         _releaseLock()</font>
<font color="black"> 181. </font>
<font color="green"> 182. def _checkLevel(level):</font>
<font color="green"> 183.     if isinstance(level, (int, long)):</font>
<font color="green"> 184.         rv = level</font>
<font color="green"> 185.     elif str(level) == level:</font>
<font color="green"> 186.         if level not in _levelNames:</font>
<font color="red"> 187.             raise ValueError(&quot;Unknown level: %r&quot; % level)</font>
<font color="green"> 188.         rv = _levelNames[level]</font>
<font color="black"> 189.     else:</font>
<font color="red"> 190.         raise TypeError(&quot;Level not an integer or a valid string: %r&quot; % level)</font>
<font color="green"> 191.     return rv</font>
<font color="black"> 192. </font>
<font color="black"> 193. #---------------------------------------------------------------------------</font>
<font color="black"> 194. #   Thread-related stuff</font>
<font color="black"> 195. #---------------------------------------------------------------------------</font>
<font color="black"> 196. </font>
<font color="black"> 197. #</font>
<font color="black"> 198. #_lock is used to serialize access to shared data structures in this module.</font>
<font color="black"> 199. #This needs to be an RLock because fileConfig() creates and configures</font>
<font color="black"> 200. #Handlers, and so might arbitrary user threads. Since Handler code updates the</font>
<font color="black"> 201. #shared dictionary _handlers, it needs to acquire the lock. But if configuring,</font>
<font color="black"> 202. #the lock would already have been acquired - so we need an RLock.</font>
<font color="black"> 203. #The same argument applies to Loggers and Manager.loggerDict.</font>
<font color="black"> 204. #</font>
<font color="green"> 205. if thread:</font>
<font color="green"> 206.     _lock = threading.RLock()</font>
<font color="black"> 207. else:</font>
<font color="red"> 208.     _lock = None</font>
<font color="black"> 209. </font>
<font color="green"> 210. def _acquireLock():</font>
<font color="black"> 211.     &quot;&quot;&quot;</font>
<font color="black"> 212.     Acquire the module-level lock for serializing access to shared data.</font>
<font color="black"> 213. </font>
<font color="black"> 214.     This should be released with _releaseLock().</font>
<font color="black"> 215.     &quot;&quot;&quot;</font>
<font color="green"> 216.     if _lock:</font>
<font color="green"> 217.         _lock.acquire()</font>
<font color="black"> 218. </font>
<font color="green"> 219. def _releaseLock():</font>
<font color="black"> 220.     &quot;&quot;&quot;</font>
<font color="black"> 221.     Release the module-level lock acquired by calling _acquireLock().</font>
<font color="black"> 222.     &quot;&quot;&quot;</font>
<font color="green"> 223.     if _lock:</font>
<font color="green"> 224.         _lock.release()</font>
<font color="black"> 225. </font>
<font color="black"> 226. #---------------------------------------------------------------------------</font>
<font color="black"> 227. #   The logging record</font>
<font color="black"> 228. #---------------------------------------------------------------------------</font>
<font color="black"> 229. </font>
<font color="green"> 230. class LogRecord(object):</font>
<font color="black"> 231.     &quot;&quot;&quot;</font>
<font color="black"> 232.     A LogRecord instance represents an event being logged.</font>
<font color="black"> 233. </font>
<font color="black"> 234.     LogRecord instances are created every time something is logged. They</font>
<font color="black"> 235.     contain all the information pertinent to the event being logged. The</font>
<font color="black"> 236.     main information passed in is in msg and args, which are combined</font>
<font color="black"> 237.     using str(msg) % args to create the message field of the record. The</font>
<font color="black"> 238.     record also includes information such as when the record was created,</font>
<font color="black"> 239.     the source line where the logging call was made, and any exception</font>
<font color="black"> 240.     information to be logged.</font>
<font color="green"> 241.     &quot;&quot;&quot;</font>
<font color="black"> 242.     def __init__(self, name, level, pathname, lineno,</font>
<font color="green"> 243.                  msg, args, exc_info, func=None):</font>
<font color="black"> 244.         &quot;&quot;&quot;</font>
<font color="black"> 245.         Initialize a logging record with interesting information.</font>
<font color="black"> 246.         &quot;&quot;&quot;</font>
<font color="red"> 247.         ct = time.time()</font>
<font color="red"> 248.         self.name = name</font>
<font color="red"> 249.         self.msg = msg</font>
<font color="black"> 250.         #</font>
<font color="black"> 251.         # The following statement allows passing of a dictionary as a sole</font>
<font color="black"> 252.         # argument, so that you can do something like</font>
<font color="black"> 253.         #  logging.debug(&quot;a %(a)d b %(b)s&quot;, {'a':1, 'b':2})</font>
<font color="black"> 254.         # Suggested by Stefan Behnel.</font>
<font color="black"> 255.         # Note that without the test for args[0], we get a problem because</font>
<font color="black"> 256.         # during formatting, we test to see if the arg is present using</font>
<font color="black"> 257.         # 'if self.args:'. If the event being logged is e.g. 'Value is %d'</font>
<font color="black"> 258.         # and if the passed arg fails 'if self.args:' then no formatting</font>
<font color="black"> 259.         # is done. For example, logger.warn('Value is %d', 0) would log</font>
<font color="black"> 260.         # 'Value is %d' instead of 'Value is 0'.</font>
<font color="black"> 261.         # For the use case of passing a dictionary, this should not be a</font>
<font color="black"> 262.         # problem.</font>
<font color="red"> 263.         if args and len(args) == 1 and isinstance(args[0], dict) and args[0]:</font>
<font color="red"> 264.             args = args[0]</font>
<font color="red"> 265.         self.args = args</font>
<font color="red"> 266.         self.levelname = getLevelName(level)</font>
<font color="red"> 267.         self.levelno = level</font>
<font color="red"> 268.         self.pathname = pathname</font>
<font color="red"> 269.         try:</font>
<font color="red"> 270.             self.filename = os.path.basename(pathname)</font>
<font color="red"> 271.             self.module = os.path.splitext(self.filename)[0]</font>
<font color="red"> 272.         except (TypeError, ValueError, AttributeError):</font>
<font color="red"> 273.             self.filename = pathname</font>
<font color="red"> 274.             self.module = &quot;Unknown module&quot;</font>
<font color="red"> 275.         self.exc_info = exc_info</font>
<font color="red"> 276.         self.exc_text = None      # used to cache the traceback text</font>
<font color="red"> 277.         self.lineno = lineno</font>
<font color="red"> 278.         self.funcName = func</font>
<font color="red"> 279.         self.created = ct</font>
<font color="red"> 280.         self.msecs = (ct - long(ct)) * 1000</font>
<font color="red"> 281.         self.relativeCreated = (self.created - _startTime) * 1000</font>
<font color="red"> 282.         if logThreads and thread:</font>
<font color="red"> 283.             self.thread = thread.get_ident()</font>
<font color="red"> 284.             self.threadName = threading.current_thread().name</font>
<font color="black"> 285.         else:</font>
<font color="red"> 286.             self.thread = None</font>
<font color="red"> 287.             self.threadName = None</font>
<font color="red"> 288.         if not logMultiprocessing:</font>
<font color="red"> 289.             self.processName = None</font>
<font color="black"> 290.         else:</font>
<font color="red"> 291.             self.processName = 'MainProcess'</font>
<font color="red"> 292.             mp = sys.modules.get('multiprocessing')</font>
<font color="red"> 293.             if mp is not None:</font>
<font color="black"> 294.                 # Errors may occur if multiprocessing has not finished loading</font>
<font color="black"> 295.                 # yet - e.g. if a custom import hook causes third-party code</font>
<font color="black"> 296.                 # to run when multiprocessing calls import. See issue 8200</font>
<font color="black"> 297.                 # for an example</font>
<font color="red"> 298.                 try:</font>
<font color="red"> 299.                     self.processName = mp.current_process().name</font>
<font color="red"> 300.                 except StandardError:</font>
<font color="red"> 301.                     pass</font>
<font color="red"> 302.         if logProcesses and hasattr(os, 'getpid'):</font>
<font color="red"> 303.             self.process = os.getpid()</font>
<font color="black"> 304.         else:</font>
<font color="red"> 305.             self.process = None</font>
<font color="black"> 306. </font>
<font color="green"> 307.     def __str__(self):</font>
<font color="red"> 308.         return '&lt;LogRecord: %s, %s, %s, %s, &quot;%s&quot;&gt;'%(self.name, self.levelno,</font>
<font color="red"> 309.             self.pathname, self.lineno, self.msg)</font>
<font color="black"> 310. </font>
<font color="green"> 311.     def getMessage(self):</font>
<font color="black"> 312.         &quot;&quot;&quot;</font>
<font color="black"> 313.         Return the message for this LogRecord.</font>
<font color="black"> 314. </font>
<font color="black"> 315.         Return the message for this LogRecord after merging any user-supplied</font>
<font color="black"> 316.         arguments with the message.</font>
<font color="black"> 317.         &quot;&quot;&quot;</font>
<font color="red"> 318.         if not _unicode: #if no unicode support...</font>
<font color="red"> 319.             msg = str(self.msg)</font>
<font color="black"> 320.         else:</font>
<font color="red"> 321.             msg = self.msg</font>
<font color="red"> 322.             if not isinstance(msg, basestring):</font>
<font color="red"> 323.                 try:</font>
<font color="red"> 324.                     msg = str(self.msg)</font>
<font color="red"> 325.                 except UnicodeError:</font>
<font color="red"> 326.                     msg = self.msg      #Defer encoding till later</font>
<font color="red"> 327.         if self.args:</font>
<font color="red"> 328.             msg = msg % self.args</font>
<font color="red"> 329.         return msg</font>
<font color="black"> 330. </font>
<font color="green"> 331. def makeLogRecord(dict):</font>
<font color="black"> 332.     &quot;&quot;&quot;</font>
<font color="black"> 333.     Make a LogRecord whose attributes are defined by the specified dictionary,</font>
<font color="black"> 334.     This function is useful for converting a logging event received over</font>
<font color="black"> 335.     a socket connection (which is sent as a dictionary) into a LogRecord</font>
<font color="black"> 336.     instance.</font>
<font color="black"> 337.     &quot;&quot;&quot;</font>
<font color="red"> 338.     rv = LogRecord(None, None, &quot;&quot;, 0, &quot;&quot;, (), None, None)</font>
<font color="red"> 339.     rv.__dict__.update(dict)</font>
<font color="red"> 340.     return rv</font>
<font color="black"> 341. </font>
<font color="black"> 342. #---------------------------------------------------------------------------</font>
<font color="black"> 343. #   Formatter classes and functions</font>
<font color="black"> 344. #---------------------------------------------------------------------------</font>
<font color="black"> 345. </font>
<font color="green"> 346. class Formatter(object):</font>
<font color="black"> 347.     &quot;&quot;&quot;</font>
<font color="black"> 348.     Formatter instances are used to convert a LogRecord to text.</font>
<font color="black"> 349. </font>
<font color="black"> 350.     Formatters need to know how a LogRecord is constructed. They are</font>
<font color="black"> 351.     responsible for converting a LogRecord to (usually) a string which can</font>
<font color="black"> 352.     be interpreted by either a human or an external system. The base Formatter</font>
<font color="black"> 353.     allows a formatting string to be specified. If none is supplied, the</font>
<font color="black"> 354.     default value of &quot;%s(message)\\n&quot; is used.</font>
<font color="black"> 355. </font>
<font color="black"> 356.     The Formatter can be initialized with a format string which makes use of</font>
<font color="black"> 357.     knowledge of the LogRecord attributes - e.g. the default value mentioned</font>
<font color="black"> 358.     above makes use of the fact that the user's message and arguments are pre-</font>
<font color="black"> 359.     formatted into a LogRecord's message attribute. Currently, the useful</font>
<font color="black"> 360.     attributes in a LogRecord are described by:</font>
<font color="black"> 361. </font>
<font color="black"> 362.     %(name)s            Name of the logger (logging channel)</font>
<font color="black"> 363.     %(levelno)s         Numeric logging level for the message (DEBUG, INFO,</font>
<font color="black"> 364.                         WARNING, ERROR, CRITICAL)</font>
<font color="black"> 365.     %(levelname)s       Text logging level for the message (&quot;DEBUG&quot;, &quot;INFO&quot;,</font>
<font color="black"> 366.                         &quot;WARNING&quot;, &quot;ERROR&quot;, &quot;CRITICAL&quot;)</font>
<font color="black"> 367.     %(pathname)s        Full pathname of the source file where the logging</font>
<font color="black"> 368.                         call was issued (if available)</font>
<font color="black"> 369.     %(filename)s        Filename portion of pathname</font>
<font color="black"> 370.     %(module)s          Module (name portion of filename)</font>
<font color="black"> 371.     %(lineno)d          Source line number where the logging call was issued</font>
<font color="black"> 372.                         (if available)</font>
<font color="black"> 373.     %(funcName)s        Function name</font>
<font color="black"> 374.     %(created)f         Time when the LogRecord was created (time.time()</font>
<font color="black"> 375.                         return value)</font>
<font color="black"> 376.     %(asctime)s         Textual time when the LogRecord was created</font>
<font color="black"> 377.     %(msecs)d           Millisecond portion of the creation time</font>
<font color="black"> 378.     %(relativeCreated)d Time in milliseconds when the LogRecord was created,</font>
<font color="black"> 379.                         relative to the time the logging module was loaded</font>
<font color="black"> 380.                         (typically at application startup time)</font>
<font color="black"> 381.     %(thread)d          Thread ID (if available)</font>
<font color="black"> 382.     %(threadName)s      Thread name (if available)</font>
<font color="black"> 383.     %(process)d         Process ID (if available)</font>
<font color="black"> 384.     %(message)s         The result of record.getMessage(), computed just as</font>
<font color="black"> 385.                         the record is emitted</font>
<font color="green"> 386.     &quot;&quot;&quot;</font>
<font color="black"> 387. </font>
<font color="green"> 388.     converter = time.localtime</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def __init__(self, fmt=None, datefmt=None):</font>
<font color="black"> 391.         &quot;&quot;&quot;</font>
<font color="black"> 392.         Initialize the formatter with specified format strings.</font>
<font color="black"> 393. </font>
<font color="black"> 394.         Initialize the formatter either with the specified format string, or a</font>
<font color="black"> 395.         default as described above. Allow for specialized date formatting with</font>
<font color="black"> 396.         the optional datefmt argument (if omitted, you get the ISO8601 format).</font>
<font color="black"> 397.         &quot;&quot;&quot;</font>
<font color="green"> 398.         if fmt:</font>
<font color="red"> 399.             self._fmt = fmt</font>
<font color="black"> 400.         else:</font>
<font color="green"> 401.             self._fmt = &quot;%(message)s&quot;</font>
<font color="green"> 402.         self.datefmt = datefmt</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def formatTime(self, record, datefmt=None):</font>
<font color="black"> 405.         &quot;&quot;&quot;</font>
<font color="black"> 406.         Return the creation time of the specified LogRecord as formatted text.</font>
<font color="black"> 407. </font>
<font color="black"> 408.         This method should be called from format() by a formatter which</font>
<font color="black"> 409.         wants to make use of a formatted time. This method can be overridden</font>
<font color="black"> 410.         in formatters to provide for any specific requirement, but the</font>
<font color="black"> 411.         basic behaviour is as follows: if datefmt (a string) is specified,</font>
<font color="black"> 412.         it is used with time.strftime() to format the creation time of the</font>
<font color="black"> 413.         record. Otherwise, the ISO8601 format is used. The resulting</font>
<font color="black"> 414.         string is returned. This function uses a user-configurable function</font>
<font color="black"> 415.         to convert the creation time to a tuple. By default, time.localtime()</font>
<font color="black"> 416.         is used; to change this for a particular formatter instance, set the</font>
<font color="black"> 417.         'converter' attribute to a function with the same signature as</font>
<font color="black"> 418.         time.localtime() or time.gmtime(). To change it for all formatters,</font>
<font color="black"> 419.         for example if you want all logging times to be shown in GMT,</font>
<font color="black"> 420.         set the 'converter' attribute in the Formatter class.</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="red"> 422.         ct = self.converter(record.created)</font>
<font color="red"> 423.         if datefmt:</font>
<font color="red"> 424.             s = time.strftime(datefmt, ct)</font>
<font color="black"> 425.         else:</font>
<font color="red"> 426.             t = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, ct)</font>
<font color="red"> 427.             s = &quot;%s,%03d&quot; % (t, record.msecs)</font>
<font color="red"> 428.         return s</font>
<font color="black"> 429. </font>
<font color="green"> 430.     def formatException(self, ei):</font>
<font color="black"> 431.         &quot;&quot;&quot;</font>
<font color="black"> 432.         Format and return the specified exception information as a string.</font>
<font color="black"> 433. </font>
<font color="black"> 434.         This default implementation just uses</font>
<font color="black"> 435.         traceback.print_exception()</font>
<font color="black"> 436.         &quot;&quot;&quot;</font>
<font color="red"> 437.         sio = cStringIO.StringIO()</font>
<font color="red"> 438.         traceback.print_exception(ei[0], ei[1], ei[2], None, sio)</font>
<font color="red"> 439.         s = sio.getvalue()</font>
<font color="red"> 440.         sio.close()</font>
<font color="red"> 441.         if s[-1:] == &quot;\n&quot;:</font>
<font color="red"> 442.             s = s[:-1]</font>
<font color="red"> 443.         return s</font>
<font color="black"> 444. </font>
<font color="green"> 445.     def usesTime(self):</font>
<font color="black"> 446.         &quot;&quot;&quot;</font>
<font color="black"> 447.         Check if the format uses the creation time of the record.</font>
<font color="black"> 448.         &quot;&quot;&quot;</font>
<font color="red"> 449.         return self._fmt.find(&quot;%(asctime)&quot;) &gt;= 0</font>
<font color="black"> 450. </font>
<font color="green"> 451.     def format(self, record):</font>
<font color="black"> 452.         &quot;&quot;&quot;</font>
<font color="black"> 453.         Format the specified record as text.</font>
<font color="black"> 454. </font>
<font color="black"> 455.         The record's attribute dictionary is used as the operand to a</font>
<font color="black"> 456.         string formatting operation which yields the returned string.</font>
<font color="black"> 457.         Before formatting the dictionary, a couple of preparatory steps</font>
<font color="black"> 458.         are carried out. The message attribute of the record is computed</font>
<font color="black"> 459.         using LogRecord.getMessage(). If the formatting string uses the</font>
<font color="black"> 460.         time (as determined by a call to usesTime(), formatTime() is</font>
<font color="black"> 461.         called to format the event time. If there is exception information,</font>
<font color="black"> 462.         it is formatted using formatException() and appended to the message.</font>
<font color="black"> 463.         &quot;&quot;&quot;</font>
<font color="red"> 464.         record.message = record.getMessage()</font>
<font color="red"> 465.         if self.usesTime():</font>
<font color="red"> 466.             record.asctime = self.formatTime(record, self.datefmt)</font>
<font color="red"> 467.         s = self._fmt % record.__dict__</font>
<font color="red"> 468.         if record.exc_info:</font>
<font color="black"> 469.             # Cache the traceback text to avoid converting it multiple times</font>
<font color="black"> 470.             # (it's constant anyway)</font>
<font color="red"> 471.             if not record.exc_text:</font>
<font color="red"> 472.                 record.exc_text = self.formatException(record.exc_info)</font>
<font color="red"> 473.         if record.exc_text:</font>
<font color="red"> 474.             if s[-1:] != &quot;\n&quot;:</font>
<font color="red"> 475.                 s = s + &quot;\n&quot;</font>
<font color="red"> 476.             try:</font>
<font color="red"> 477.                 s = s + record.exc_text</font>
<font color="red"> 478.             except UnicodeError:</font>
<font color="black"> 479.                 # Sometimes filenames have non-ASCII chars, which can lead</font>
<font color="black"> 480.                 # to errors when s is Unicode and record.exc_text is str</font>
<font color="black"> 481.                 # See issue 8924.</font>
<font color="black"> 482.                 # We also use replace for when there are multiple</font>
<font color="black"> 483.                 # encodings, e.g. UTF-8 for the filesystem and latin-1</font>
<font color="black"> 484.                 # for a script. See issue 13232.</font>
<font color="red"> 485.                 s = s + record.exc_text.decode(sys.getfilesystemencoding(),</font>
<font color="red"> 486.                                                'replace')</font>
<font color="red"> 487.         return s</font>
<font color="black"> 488. </font>
<font color="black"> 489. #</font>
<font color="black"> 490. #   The default formatter to use when no other is specified</font>
<font color="black"> 491. #</font>
<font color="green"> 492. _defaultFormatter = Formatter()</font>
<font color="black"> 493. </font>
<font color="green"> 494. class BufferingFormatter(object):</font>
<font color="black"> 495.     &quot;&quot;&quot;</font>
<font color="black"> 496.     A formatter suitable for formatting a number of records.</font>
<font color="green"> 497.     &quot;&quot;&quot;</font>
<font color="green"> 498.     def __init__(self, linefmt=None):</font>
<font color="black"> 499.         &quot;&quot;&quot;</font>
<font color="black"> 500.         Optionally specify a formatter which will be used to format each</font>
<font color="black"> 501.         individual record.</font>
<font color="black"> 502.         &quot;&quot;&quot;</font>
<font color="red"> 503.         if linefmt:</font>
<font color="red"> 504.             self.linefmt = linefmt</font>
<font color="black"> 505.         else:</font>
<font color="red"> 506.             self.linefmt = _defaultFormatter</font>
<font color="black"> 507. </font>
<font color="green"> 508.     def formatHeader(self, records):</font>
<font color="black"> 509.         &quot;&quot;&quot;</font>
<font color="black"> 510.         Return the header string for the specified records.</font>
<font color="black"> 511.         &quot;&quot;&quot;</font>
<font color="red"> 512.         return &quot;&quot;</font>
<font color="black"> 513. </font>
<font color="green"> 514.     def formatFooter(self, records):</font>
<font color="black"> 515.         &quot;&quot;&quot;</font>
<font color="black"> 516.         Return the footer string for the specified records.</font>
<font color="black"> 517.         &quot;&quot;&quot;</font>
<font color="red"> 518.         return &quot;&quot;</font>
<font color="black"> 519. </font>
<font color="green"> 520.     def format(self, records):</font>
<font color="black"> 521.         &quot;&quot;&quot;</font>
<font color="black"> 522.         Format the specified records and return the result as a string.</font>
<font color="black"> 523.         &quot;&quot;&quot;</font>
<font color="red"> 524.         rv = &quot;&quot;</font>
<font color="red"> 525.         if len(records) &gt; 0:</font>
<font color="red"> 526.             rv = rv + self.formatHeader(records)</font>
<font color="red"> 527.             for record in records:</font>
<font color="red"> 528.                 rv = rv + self.linefmt.format(record)</font>
<font color="red"> 529.             rv = rv + self.formatFooter(records)</font>
<font color="red"> 530.         return rv</font>
<font color="black"> 531. </font>
<font color="black"> 532. #---------------------------------------------------------------------------</font>
<font color="black"> 533. #   Filter classes and functions</font>
<font color="black"> 534. #---------------------------------------------------------------------------</font>
<font color="black"> 535. </font>
<font color="green"> 536. class Filter(object):</font>
<font color="black"> 537.     &quot;&quot;&quot;</font>
<font color="black"> 538.     Filter instances are used to perform arbitrary filtering of LogRecords.</font>
<font color="black"> 539. </font>
<font color="black"> 540.     Loggers and Handlers can optionally use Filter instances to filter</font>
<font color="black"> 541.     records as desired. The base filter class only allows events which are</font>
<font color="black"> 542.     below a certain point in the logger hierarchy. For example, a filter</font>
<font color="black"> 543.     initialized with &quot;A.B&quot; will allow events logged by loggers &quot;A.B&quot;,</font>
<font color="black"> 544.     &quot;A.B.C&quot;, &quot;A.B.C.D&quot;, &quot;A.B.D&quot; etc. but not &quot;A.BB&quot;, &quot;B.A.B&quot; etc. If</font>
<font color="black"> 545.     initialized with the empty string, all events are passed.</font>
<font color="green"> 546.     &quot;&quot;&quot;</font>
<font color="green"> 547.     def __init__(self, name=''):</font>
<font color="black"> 548.         &quot;&quot;&quot;</font>
<font color="black"> 549.         Initialize a filter.</font>
<font color="black"> 550. </font>
<font color="black"> 551.         Initialize with the name of the logger which, together with its</font>
<font color="black"> 552.         children, will have its events allowed through the filter. If no</font>
<font color="black"> 553.         name is specified, allow every event.</font>
<font color="black"> 554.         &quot;&quot;&quot;</font>
<font color="green"> 555.         self.name = name</font>
<font color="green"> 556.         self.nlen = len(name)</font>
<font color="black"> 557. </font>
<font color="green"> 558.     def filter(self, record):</font>
<font color="black"> 559.         &quot;&quot;&quot;</font>
<font color="black"> 560.         Determine if the specified record is to be logged.</font>
<font color="black"> 561. </font>
<font color="black"> 562.         Is the specified record to be logged? Returns 0 for no, nonzero for</font>
<font color="black"> 563.         yes. If deemed appropriate, the record may be modified in-place.</font>
<font color="black"> 564.         &quot;&quot;&quot;</font>
<font color="red"> 565.         if self.nlen == 0:</font>
<font color="red"> 566.             return 1</font>
<font color="red"> 567.         elif self.name == record.name:</font>
<font color="red"> 568.             return 1</font>
<font color="red"> 569.         elif record.name.find(self.name, 0, self.nlen) != 0:</font>
<font color="red"> 570.             return 0</font>
<font color="red"> 571.         return (record.name[self.nlen] == &quot;.&quot;)</font>
<font color="black"> 572. </font>
<font color="green"> 573. class Filterer(object):</font>
<font color="black"> 574.     &quot;&quot;&quot;</font>
<font color="black"> 575.     A base class for loggers and handlers which allows them to share</font>
<font color="black"> 576.     common code.</font>
<font color="green"> 577.     &quot;&quot;&quot;</font>
<font color="green"> 578.     def __init__(self):</font>
<font color="black"> 579.         &quot;&quot;&quot;</font>
<font color="black"> 580.         Initialize the list of filters to be an empty list.</font>
<font color="black"> 581.         &quot;&quot;&quot;</font>
<font color="green"> 582.         self.filters = []</font>
<font color="black"> 583. </font>
<font color="green"> 584.     def addFilter(self, filter):</font>
<font color="black"> 585.         &quot;&quot;&quot;</font>
<font color="black"> 586.         Add the specified filter to this handler.</font>
<font color="black"> 587.         &quot;&quot;&quot;</font>
<font color="green"> 588.         if not (filter in self.filters):</font>
<font color="green"> 589.             self.filters.append(filter)</font>
<font color="black"> 590. </font>
<font color="green"> 591.     def removeFilter(self, filter):</font>
<font color="black"> 592.         &quot;&quot;&quot;</font>
<font color="black"> 593.         Remove the specified filter from this handler.</font>
<font color="black"> 594.         &quot;&quot;&quot;</font>
<font color="red"> 595.         if filter in self.filters:</font>
<font color="red"> 596.             self.filters.remove(filter)</font>
<font color="black"> 597. </font>
<font color="green"> 598.     def filter(self, record):</font>
<font color="black"> 599.         &quot;&quot;&quot;</font>
<font color="black"> 600.         Determine if a record is loggable by consulting all the filters.</font>
<font color="black"> 601. </font>
<font color="black"> 602.         The default is to allow the record to be logged; any filter can veto</font>
<font color="black"> 603.         this and the record is then dropped. Returns a zero value if a record</font>
<font color="black"> 604.         is to be dropped, else non-zero.</font>
<font color="black"> 605.         &quot;&quot;&quot;</font>
<font color="red"> 606.         rv = 1</font>
<font color="red"> 607.         for f in self.filters:</font>
<font color="red"> 608.             if not f.filter(record):</font>
<font color="red"> 609.                 rv = 0</font>
<font color="red"> 610.                 break</font>
<font color="red"> 611.         return rv</font>
<font color="black"> 612. </font>
<font color="black"> 613. #---------------------------------------------------------------------------</font>
<font color="black"> 614. #   Handler classes and functions</font>
<font color="black"> 615. #---------------------------------------------------------------------------</font>
<font color="black"> 616. </font>
<font color="green"> 617. _handlers = weakref.WeakValueDictionary()  #map of handler names to handlers</font>
<font color="green"> 618. _handlerList = [] # added to allow handlers to be removed in reverse of order initialized</font>
<font color="black"> 619. </font>
<font color="green"> 620. def _removeHandlerRef(wr):</font>
<font color="black"> 621.     &quot;&quot;&quot;</font>
<font color="black"> 622.     Remove a handler reference from the internal cleanup list.</font>
<font color="black"> 623.     &quot;&quot;&quot;</font>
<font color="black"> 624.     # This function can be called during module teardown, when globals are</font>
<font color="black"> 625.     # set to None. If _acquireLock is None, assume this is the case and do</font>
<font color="black"> 626.     # nothing.</font>
<font color="red"> 627.     if (_acquireLock is not None and _handlerList is not None and</font>
<font color="red"> 628.         _releaseLock is not None):</font>
<font color="red"> 629.         _acquireLock()</font>
<font color="red"> 630.         try:</font>
<font color="red"> 631.             if wr in _handlerList:</font>
<font color="red"> 632.                 _handlerList.remove(wr)</font>
<font color="black"> 633.         finally:</font>
<font color="red"> 634.             _releaseLock()</font>
<font color="black"> 635. </font>
<font color="green"> 636. def _addHandlerRef(handler):</font>
<font color="black"> 637.     &quot;&quot;&quot;</font>
<font color="black"> 638.     Add a handler to the internal cleanup list using a weak reference.</font>
<font color="black"> 639.     &quot;&quot;&quot;</font>
<font color="green"> 640.     _acquireLock()</font>
<font color="green"> 641.     try:</font>
<font color="green"> 642.         _handlerList.append(weakref.ref(handler, _removeHandlerRef))</font>
<font color="black"> 643.     finally:</font>
<font color="green"> 644.         _releaseLock()</font>
<font color="black"> 645. </font>
<font color="green"> 646. class Handler(Filterer):</font>
<font color="black"> 647.     &quot;&quot;&quot;</font>
<font color="black"> 648.     Handler instances dispatch logging events to specific destinations.</font>
<font color="black"> 649. </font>
<font color="black"> 650.     The base handler class. Acts as a placeholder which defines the Handler</font>
<font color="black"> 651.     interface. Handlers can optionally use Formatter instances to format</font>
<font color="black"> 652.     records as desired. By default, no formatter is specified; in this case,</font>
<font color="black"> 653.     the 'raw' message as determined by record.message is logged.</font>
<font color="green"> 654.     &quot;&quot;&quot;</font>
<font color="green"> 655.     def __init__(self, level=NOTSET):</font>
<font color="black"> 656.         &quot;&quot;&quot;</font>
<font color="black"> 657.         Initializes the instance - basically setting the formatter to None</font>
<font color="black"> 658.         and the filter list to empty.</font>
<font color="black"> 659.         &quot;&quot;&quot;</font>
<font color="green"> 660.         Filterer.__init__(self)</font>
<font color="green"> 661.         self._name = None</font>
<font color="green"> 662.         self.level = _checkLevel(level)</font>
<font color="green"> 663.         self.formatter = None</font>
<font color="black"> 664.         # Add the handler to the global _handlerList (for cleanup on shutdown)</font>
<font color="green"> 665.         _addHandlerRef(self)</font>
<font color="green"> 666.         self.createLock()</font>
<font color="black"> 667. </font>
<font color="green"> 668.     def get_name(self):</font>
<font color="red"> 669.         return self._name</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def set_name(self, name):</font>
<font color="green"> 672.         _acquireLock()</font>
<font color="green"> 673.         try:</font>
<font color="green"> 674.             if self._name in _handlers:</font>
<font color="red"> 675.                 del _handlers[self._name]</font>
<font color="green"> 676.             self._name = name</font>
<font color="green"> 677.             if name:</font>
<font color="green"> 678.                 _handlers[name] = self</font>
<font color="black"> 679.         finally:</font>
<font color="green"> 680.             _releaseLock()</font>
<font color="black"> 681. </font>
<font color="green"> 682.     name = property(get_name, set_name)</font>
<font color="black"> 683. </font>
<font color="green"> 684.     def createLock(self):</font>
<font color="black"> 685.         &quot;&quot;&quot;</font>
<font color="black"> 686.         Acquire a thread lock for serializing access to the underlying I/O.</font>
<font color="black"> 687.         &quot;&quot;&quot;</font>
<font color="green"> 688.         if thread:</font>
<font color="green"> 689.             self.lock = threading.RLock()</font>
<font color="black"> 690.         else:</font>
<font color="red"> 691.             self.lock = None</font>
<font color="black"> 692. </font>
<font color="green"> 693.     def acquire(self):</font>
<font color="black"> 694.         &quot;&quot;&quot;</font>
<font color="black"> 695.         Acquire the I/O thread lock.</font>
<font color="black"> 696.         &quot;&quot;&quot;</font>
<font color="red"> 697.         if self.lock:</font>
<font color="red"> 698.             self.lock.acquire()</font>
<font color="black"> 699. </font>
<font color="green"> 700.     def release(self):</font>
<font color="black"> 701.         &quot;&quot;&quot;</font>
<font color="black"> 702.         Release the I/O thread lock.</font>
<font color="black"> 703.         &quot;&quot;&quot;</font>
<font color="red"> 704.         if self.lock:</font>
<font color="red"> 705.             self.lock.release()</font>
<font color="black"> 706. </font>
<font color="green"> 707.     def setLevel(self, level):</font>
<font color="black"> 708.         &quot;&quot;&quot;</font>
<font color="black"> 709.         Set the logging level of this handler.</font>
<font color="black"> 710.         &quot;&quot;&quot;</font>
<font color="green"> 711.         self.level = _checkLevel(level)</font>
<font color="black"> 712. </font>
<font color="green"> 713.     def format(self, record):</font>
<font color="black"> 714.         &quot;&quot;&quot;</font>
<font color="black"> 715.         Format the specified record.</font>
<font color="black"> 716. </font>
<font color="black"> 717.         If a formatter is set, use it. Otherwise, use the default formatter</font>
<font color="black"> 718.         for the module.</font>
<font color="black"> 719.         &quot;&quot;&quot;</font>
<font color="red"> 720.         if self.formatter:</font>
<font color="red"> 721.             fmt = self.formatter</font>
<font color="black"> 722.         else:</font>
<font color="red"> 723.             fmt = _defaultFormatter</font>
<font color="red"> 724.         return fmt.format(record)</font>
<font color="black"> 725. </font>
<font color="green"> 726.     def emit(self, record):</font>
<font color="black"> 727.         &quot;&quot;&quot;</font>
<font color="black"> 728.         Do whatever it takes to actually log the specified logging record.</font>
<font color="black"> 729. </font>
<font color="black"> 730.         This version is intended to be implemented by subclasses and so</font>
<font color="black"> 731.         raises a NotImplementedError.</font>
<font color="black"> 732.         &quot;&quot;&quot;</font>
<font color="red"> 733.         raise NotImplementedError('emit must be implemented '</font>
<font color="black"> 734.                                   'by Handler subclasses')</font>
<font color="black"> 735. </font>
<font color="green"> 736.     def handle(self, record):</font>
<font color="black"> 737.         &quot;&quot;&quot;</font>
<font color="black"> 738.         Conditionally emit the specified logging record.</font>
<font color="black"> 739. </font>
<font color="black"> 740.         Emission depends on filters which may have been added to the handler.</font>
<font color="black"> 741.         Wrap the actual emission of the record with acquisition/release of</font>
<font color="black"> 742.         the I/O thread lock. Returns whether the filter passed the record for</font>
<font color="black"> 743.         emission.</font>
<font color="black"> 744.         &quot;&quot;&quot;</font>
<font color="red"> 745.         rv = self.filter(record)</font>
<font color="red"> 746.         if rv:</font>
<font color="red"> 747.             self.acquire()</font>
<font color="red"> 748.             try:</font>
<font color="red"> 749.                 self.emit(record)</font>
<font color="black"> 750.             finally:</font>
<font color="red"> 751.                 self.release()</font>
<font color="red"> 752.         return rv</font>
<font color="black"> 753. </font>
<font color="green"> 754.     def setFormatter(self, fmt):</font>
<font color="black"> 755.         &quot;&quot;&quot;</font>
<font color="black"> 756.         Set the formatter for this handler.</font>
<font color="black"> 757.         &quot;&quot;&quot;</font>
<font color="red"> 758.         self.formatter = fmt</font>
<font color="black"> 759. </font>
<font color="green"> 760.     def flush(self):</font>
<font color="black"> 761.         &quot;&quot;&quot;</font>
<font color="black"> 762.         Ensure all logging output has been flushed.</font>
<font color="black"> 763. </font>
<font color="black"> 764.         This version does nothing and is intended to be implemented by</font>
<font color="black"> 765.         subclasses.</font>
<font color="black"> 766.         &quot;&quot;&quot;</font>
<font color="red"> 767.         pass</font>
<font color="black"> 768. </font>
<font color="green"> 769.     def close(self):</font>
<font color="black"> 770.         &quot;&quot;&quot;</font>
<font color="black"> 771.         Tidy up any resources used by the handler.</font>
<font color="black"> 772. </font>
<font color="black"> 773.         This version removes the handler from an internal map of handlers,</font>
<font color="black"> 774.         _handlers, which is used for handler lookup by name. Subclasses</font>
<font color="black"> 775.         should ensure that this gets called from overridden close()</font>
<font color="black"> 776.         methods.</font>
<font color="black"> 777.         &quot;&quot;&quot;</font>
<font color="black"> 778.         #get the module data lock, as we're updating a shared structure.</font>
<font color="red"> 779.         _acquireLock()</font>
<font color="red"> 780.         try:    #unlikely to raise an exception, but you never know...</font>
<font color="red"> 781.             if self._name and self._name in _handlers:</font>
<font color="red"> 782.                 del _handlers[self._name]</font>
<font color="black"> 783.         finally:</font>
<font color="red"> 784.             _releaseLock()</font>
<font color="black"> 785. </font>
<font color="green"> 786.     def handleError(self, record):</font>
<font color="black"> 787.         &quot;&quot;&quot;</font>
<font color="black"> 788.         Handle errors which occur during an emit() call.</font>
<font color="black"> 789. </font>
<font color="black"> 790.         This method should be called from handlers when an exception is</font>
<font color="black"> 791.         encountered during an emit() call. If raiseExceptions is false,</font>
<font color="black"> 792.         exceptions get silently ignored. This is what is mostly wanted</font>
<font color="black"> 793.         for a logging system - most users will not care about errors in</font>
<font color="black"> 794.         the logging system, they are more interested in application errors.</font>
<font color="black"> 795.         You could, however, replace this with a custom handler if you wish.</font>
<font color="black"> 796.         The record which was being processed is passed in to this method.</font>
<font color="black"> 797.         &quot;&quot;&quot;</font>
<font color="red"> 798.         if raiseExceptions and sys.stderr:  # see issue 13807</font>
<font color="red"> 799.             ei = sys.exc_info()</font>
<font color="red"> 800.             try:</font>
<font color="red"> 801.                 traceback.print_exception(ei[0], ei[1], ei[2],</font>
<font color="red"> 802.                                           None, sys.stderr)</font>
<font color="red"> 803.                 sys.stderr.write('Logged from file %s, line %s\n' % (</font>
<font color="red"> 804.                                  record.filename, record.lineno))</font>
<font color="red"> 805.             except IOError:</font>
<font color="red"> 806.                 pass    # see issue 5971</font>
<font color="black"> 807.             finally:</font>
<font color="red"> 808.                 del ei</font>
<font color="black"> 809. </font>
<font color="green"> 810. class StreamHandler(Handler):</font>
<font color="black"> 811.     &quot;&quot;&quot;</font>
<font color="black"> 812.     A handler class which writes logging records, appropriately formatted,</font>
<font color="black"> 813.     to a stream. Note that this class does not close the stream, as</font>
<font color="black"> 814.     sys.stdout or sys.stderr may be used.</font>
<font color="green"> 815.     &quot;&quot;&quot;</font>
<font color="black"> 816. </font>
<font color="green"> 817.     def __init__(self, stream=None):</font>
<font color="black"> 818.         &quot;&quot;&quot;</font>
<font color="black"> 819.         Initialize the handler.</font>
<font color="black"> 820. </font>
<font color="black"> 821.         If stream is not specified, sys.stderr is used.</font>
<font color="black"> 822.         &quot;&quot;&quot;</font>
<font color="green"> 823.         Handler.__init__(self)</font>
<font color="green"> 824.         if stream is None:</font>
<font color="green"> 825.             stream = sys.stderr</font>
<font color="green"> 826.         self.stream = stream</font>
<font color="black"> 827. </font>
<font color="green"> 828.     def flush(self):</font>
<font color="black"> 829.         &quot;&quot;&quot;</font>
<font color="black"> 830.         Flushes the stream.</font>
<font color="black"> 831.         &quot;&quot;&quot;</font>
<font color="red"> 832.         self.acquire()</font>
<font color="red"> 833.         try:</font>
<font color="red"> 834.             if self.stream and hasattr(self.stream, &quot;flush&quot;):</font>
<font color="red"> 835.                 self.stream.flush()</font>
<font color="black"> 836.         finally:</font>
<font color="red"> 837.             self.release()</font>
<font color="black"> 838. </font>
<font color="green"> 839.     def emit(self, record):</font>
<font color="black"> 840.         &quot;&quot;&quot;</font>
<font color="black"> 841.         Emit a record.</font>
<font color="black"> 842. </font>
<font color="black"> 843.         If a formatter is specified, it is used to format the record.</font>
<font color="black"> 844.         The record is then written to the stream with a trailing newline.  If</font>
<font color="black"> 845.         exception information is present, it is formatted using</font>
<font color="black"> 846.         traceback.print_exception and appended to the stream.  If the stream</font>
<font color="black"> 847.         has an 'encoding' attribute, it is used to determine how to do the</font>
<font color="black"> 848.         output to the stream.</font>
<font color="black"> 849.         &quot;&quot;&quot;</font>
<font color="red"> 850.         try:</font>
<font color="red"> 851.             msg = self.format(record)</font>
<font color="red"> 852.             stream = self.stream</font>
<font color="red"> 853.             fs = &quot;%s\n&quot;</font>
<font color="red"> 854.             if not _unicode: #if no unicode support...</font>
<font color="red"> 855.                 stream.write(fs % msg)</font>
<font color="black"> 856.             else:</font>
<font color="red"> 857.                 try:</font>
<font color="red"> 858.                     if (isinstance(msg, unicode) and</font>
<font color="red"> 859.                         getattr(stream, 'encoding', None)):</font>
<font color="red"> 860.                         ufs = u'%s\n'</font>
<font color="red"> 861.                         try:</font>
<font color="red"> 862.                             stream.write(ufs % msg)</font>
<font color="red"> 863.                         except UnicodeEncodeError:</font>
<font color="black"> 864.                             #Printing to terminals sometimes fails. For example,</font>
<font color="black"> 865.                             #with an encoding of 'cp1251', the above write will</font>
<font color="black"> 866.                             #work if written to a stream opened or wrapped by</font>
<font color="black"> 867.                             #the codecs module, but fail when writing to a</font>
<font color="black"> 868.                             #terminal even when the codepage is set to cp1251.</font>
<font color="black"> 869.                             #An extra encoding step seems to be needed.</font>
<font color="red"> 870.                             stream.write((ufs % msg).encode(stream.encoding))</font>
<font color="black"> 871.                     else:</font>
<font color="red"> 872.                         stream.write(fs % msg)</font>
<font color="red"> 873.                 except UnicodeError:</font>
<font color="red"> 874.                     stream.write(fs % msg.encode(&quot;UTF-8&quot;))</font>
<font color="red"> 875.             self.flush()</font>
<font color="red"> 876.         except (KeyboardInterrupt, SystemExit):</font>
<font color="red"> 877.             raise</font>
<font color="red"> 878.         except:</font>
<font color="red"> 879.             self.handleError(record)</font>
<font color="black"> 880. </font>
<font color="green"> 881. class FileHandler(StreamHandler):</font>
<font color="black"> 882.     &quot;&quot;&quot;</font>
<font color="black"> 883.     A handler class which writes formatted logging records to disk files.</font>
<font color="green"> 884.     &quot;&quot;&quot;</font>
<font color="green"> 885.     def __init__(self, filename, mode='a', encoding=None, delay=0):</font>
<font color="black"> 886.         &quot;&quot;&quot;</font>
<font color="black"> 887.         Open the specified file and use it as the stream for logging.</font>
<font color="black"> 888.         &quot;&quot;&quot;</font>
<font color="black"> 889.         #keep the absolute path, otherwise derived classes which use this</font>
<font color="black"> 890.         #may come a cropper when the current directory changes</font>
<font color="red"> 891.         if codecs is None:</font>
<font color="red"> 892.             encoding = None</font>
<font color="red"> 893.         self.baseFilename = os.path.abspath(filename)</font>
<font color="red"> 894.         self.mode = mode</font>
<font color="red"> 895.         self.encoding = encoding</font>
<font color="red"> 896.         self.delay = delay</font>
<font color="red"> 897.         if delay:</font>
<font color="black"> 898.             #We don't open the stream, but we still need to call the</font>
<font color="black"> 899.             #Handler constructor to set level, formatter, lock etc.</font>
<font color="red"> 900.             Handler.__init__(self)</font>
<font color="red"> 901.             self.stream = None</font>
<font color="black"> 902.         else:</font>
<font color="red"> 903.             StreamHandler.__init__(self, self._open())</font>
<font color="black"> 904. </font>
<font color="green"> 905.     def close(self):</font>
<font color="black"> 906.         &quot;&quot;&quot;</font>
<font color="black"> 907.         Closes the stream.</font>
<font color="black"> 908.         &quot;&quot;&quot;</font>
<font color="red"> 909.         self.acquire()</font>
<font color="red"> 910.         try:</font>
<font color="red"> 911.             if self.stream:</font>
<font color="red"> 912.                 self.flush()</font>
<font color="red"> 913.                 if hasattr(self.stream, &quot;close&quot;):</font>
<font color="red"> 914.                     self.stream.close()</font>
<font color="red"> 915.                 self.stream = None</font>
<font color="black"> 916.             # Issue #19523: call unconditionally to</font>
<font color="black"> 917.             # prevent a handler leak when delay is set</font>
<font color="red"> 918.             StreamHandler.close(self)</font>
<font color="black"> 919.         finally:</font>
<font color="red"> 920.             self.release()</font>
<font color="black"> 921. </font>
<font color="green"> 922.     def _open(self):</font>
<font color="black"> 923.         &quot;&quot;&quot;</font>
<font color="black"> 924.         Open the current base file with the (original) mode and encoding.</font>
<font color="black"> 925.         Return the resulting stream.</font>
<font color="black"> 926.         &quot;&quot;&quot;</font>
<font color="red"> 927.         if self.encoding is None:</font>
<font color="red"> 928.             stream = open(self.baseFilename, self.mode)</font>
<font color="black"> 929.         else:</font>
<font color="red"> 930.             stream = codecs.open(self.baseFilename, self.mode, self.encoding)</font>
<font color="red"> 931.         return stream</font>
<font color="black"> 932. </font>
<font color="green"> 933.     def emit(self, record):</font>
<font color="black"> 934.         &quot;&quot;&quot;</font>
<font color="black"> 935.         Emit a record.</font>
<font color="black"> 936. </font>
<font color="black"> 937.         If the stream was not opened because 'delay' was specified in the</font>
<font color="black"> 938.         constructor, open it before calling the superclass's emit.</font>
<font color="black"> 939.         &quot;&quot;&quot;</font>
<font color="red"> 940.         if self.stream is None:</font>
<font color="red"> 941.             self.stream = self._open()</font>
<font color="red"> 942.         StreamHandler.emit(self, record)</font>
<font color="black"> 943. </font>
<font color="black"> 944. #---------------------------------------------------------------------------</font>
<font color="black"> 945. #   Manager classes and functions</font>
<font color="black"> 946. #---------------------------------------------------------------------------</font>
<font color="black"> 947. </font>
<font color="green"> 948. class PlaceHolder(object):</font>
<font color="black"> 949.     &quot;&quot;&quot;</font>
<font color="black"> 950.     PlaceHolder instances are used in the Manager logger hierarchy to take</font>
<font color="black"> 951.     the place of nodes for which no loggers have been defined. This class is</font>
<font color="black"> 952.     intended for internal use only and not as part of the public API.</font>
<font color="green"> 953.     &quot;&quot;&quot;</font>
<font color="green"> 954.     def __init__(self, alogger):</font>
<font color="black"> 955.         &quot;&quot;&quot;</font>
<font color="black"> 956.         Initialize with the specified logger being a child of this placeholder.</font>
<font color="black"> 957.         &quot;&quot;&quot;</font>
<font color="black"> 958.         #self.loggers = [alogger]</font>
<font color="green"> 959.         self.loggerMap = { alogger : None }</font>
<font color="black"> 960. </font>
<font color="green"> 961.     def append(self, alogger):</font>
<font color="black"> 962.         &quot;&quot;&quot;</font>
<font color="black"> 963.         Add the specified logger as a child of this placeholder.</font>
<font color="black"> 964.         &quot;&quot;&quot;</font>
<font color="black"> 965.         #if alogger not in self.loggers:</font>
<font color="green"> 966.         if alogger not in self.loggerMap:</font>
<font color="black"> 967.             #self.loggers.append(alogger)</font>
<font color="green"> 968.             self.loggerMap[alogger] = None</font>
<font color="black"> 969. </font>
<font color="black"> 970. #</font>
<font color="black"> 971. #   Determine which class to use when instantiating loggers.</font>
<font color="black"> 972. #</font>
<font color="green"> 973. _loggerClass = None</font>
<font color="black"> 974. </font>
<font color="green"> 975. def setLoggerClass(klass):</font>
<font color="black"> 976.     &quot;&quot;&quot;</font>
<font color="black"> 977.     Set the class to be used when instantiating a logger. The class should</font>
<font color="black"> 978.     define __init__() such that only a name argument is required, and the</font>
<font color="black"> 979.     __init__() should call Logger.__init__()</font>
<font color="black"> 980.     &quot;&quot;&quot;</font>
<font color="red"> 981.     if klass != Logger:</font>
<font color="red"> 982.         if not issubclass(klass, Logger):</font>
<font color="red"> 983.             raise TypeError(&quot;logger not derived from logging.Logger: &quot;</font>
<font color="red"> 984.                             + klass.__name__)</font>
<font color="black"> 985.     global _loggerClass</font>
<font color="red"> 986.     _loggerClass = klass</font>
<font color="black"> 987. </font>
<font color="green"> 988. def getLoggerClass():</font>
<font color="black"> 989.     &quot;&quot;&quot;</font>
<font color="black"> 990.     Return the class to be used when instantiating a logger.</font>
<font color="black"> 991.     &quot;&quot;&quot;</font>
<font color="black"> 992. </font>
<font color="red"> 993.     return _loggerClass</font>
<font color="black"> 994. </font>
<font color="green"> 995. class Manager(object):</font>
<font color="black"> 996.     &quot;&quot;&quot;</font>
<font color="black"> 997.     There is [under normal circumstances] just one Manager instance, which</font>
<font color="black"> 998.     holds the hierarchy of loggers.</font>
<font color="green"> 999.     &quot;&quot;&quot;</font>
<font color="green">1000.     def __init__(self, rootnode):</font>
<font color="black">1001.         &quot;&quot;&quot;</font>
<font color="black">1002.         Initialize the manager with the root node of the logger hierarchy.</font>
<font color="black">1003.         &quot;&quot;&quot;</font>
<font color="green">1004.         self.root = rootnode</font>
<font color="green">1005.         self.disable = 0</font>
<font color="green">1006.         self.emittedNoHandlerWarning = 0</font>
<font color="green">1007.         self.loggerDict = {}</font>
<font color="green">1008.         self.loggerClass = None</font>
<font color="black">1009. </font>
<font color="green">1010.     def getLogger(self, name):</font>
<font color="black">1011.         &quot;&quot;&quot;</font>
<font color="black">1012.         Get a logger with the specified name (channel name), creating it</font>
<font color="black">1013.         if it doesn't yet exist. This name is a dot-separated hierarchical</font>
<font color="black">1014.         name, such as &quot;a&quot;, &quot;a.b&quot;, &quot;a.b.c&quot; or similar.</font>
<font color="black">1015. </font>
<font color="black">1016.         If a PlaceHolder existed for the specified name [i.e. the logger</font>
<font color="black">1017.         didn't exist but a child of it did], replace it with the created</font>
<font color="black">1018.         logger and fix up the parent/child references which pointed to the</font>
<font color="black">1019.         placeholder to now point to the logger.</font>
<font color="black">1020.         &quot;&quot;&quot;</font>
<font color="green">1021.         rv = None</font>
<font color="green">1022.         if not isinstance(name, basestring):</font>
<font color="red">1023.             raise TypeError('A logger name must be string or Unicode')</font>
<font color="green">1024.         if isinstance(name, unicode):</font>
<font color="green">1025.             name = name.encode('utf-8')</font>
<font color="green">1026.         _acquireLock()</font>
<font color="green">1027.         try:</font>
<font color="green">1028.             if name in self.loggerDict:</font>
<font color="green">1029.                 rv = self.loggerDict[name]</font>
<font color="green">1030.                 if isinstance(rv, PlaceHolder):</font>
<font color="green">1031.                     ph = rv</font>
<font color="green">1032.                     rv = (self.loggerClass or _loggerClass)(name)</font>
<font color="green">1033.                     rv.manager = self</font>
<font color="green">1034.                     self.loggerDict[name] = rv</font>
<font color="green">1035.                     self._fixupChildren(ph, rv)</font>
<font color="green">1036.                     self._fixupParents(rv)</font>
<font color="black">1037.             else:</font>
<font color="green">1038.                 rv = (self.loggerClass or _loggerClass)(name)</font>
<font color="green">1039.                 rv.manager = self</font>
<font color="green">1040.                 self.loggerDict[name] = rv</font>
<font color="green">1041.                 self._fixupParents(rv)</font>
<font color="black">1042.         finally:</font>
<font color="green">1043.             _releaseLock()</font>
<font color="green">1044.         return rv</font>
<font color="black">1045. </font>
<font color="green">1046.     def setLoggerClass(self, klass):</font>
<font color="black">1047.         &quot;&quot;&quot;</font>
<font color="black">1048.         Set the class to be used when instantiating a logger with this Manager.</font>
<font color="black">1049.         &quot;&quot;&quot;</font>
<font color="red">1050.         if klass != Logger:</font>
<font color="red">1051.             if not issubclass(klass, Logger):</font>
<font color="red">1052.                 raise TypeError(&quot;logger not derived from logging.Logger: &quot;</font>
<font color="red">1053.                                 + klass.__name__)</font>
<font color="red">1054.         self.loggerClass = klass</font>
<font color="black">1055. </font>
<font color="green">1056.     def _fixupParents(self, alogger):</font>
<font color="black">1057.         &quot;&quot;&quot;</font>
<font color="black">1058.         Ensure that there are either loggers or placeholders all the way</font>
<font color="black">1059.         from the specified logger to the root of the logger hierarchy.</font>
<font color="black">1060.         &quot;&quot;&quot;</font>
<font color="green">1061.         name = alogger.name</font>
<font color="green">1062.         i = name.rfind(&quot;.&quot;)</font>
<font color="green">1063.         rv = None</font>
<font color="green">1064.         while (i &gt; 0) and not rv:</font>
<font color="green">1065.             substr = name[:i]</font>
<font color="green">1066.             if substr not in self.loggerDict:</font>
<font color="green">1067.                 self.loggerDict[substr] = PlaceHolder(alogger)</font>
<font color="black">1068.             else:</font>
<font color="green">1069.                 obj = self.loggerDict[substr]</font>
<font color="green">1070.                 if isinstance(obj, Logger):</font>
<font color="green">1071.                     rv = obj</font>
<font color="black">1072.                 else:</font>
<font color="green">1073.                     assert isinstance(obj, PlaceHolder)</font>
<font color="green">1074.                     obj.append(alogger)</font>
<font color="green">1075.             i = name.rfind(&quot;.&quot;, 0, i - 1)</font>
<font color="green">1076.         if not rv:</font>
<font color="green">1077.             rv = self.root</font>
<font color="green">1078.         alogger.parent = rv</font>
<font color="black">1079. </font>
<font color="green">1080.     def _fixupChildren(self, ph, alogger):</font>
<font color="black">1081.         &quot;&quot;&quot;</font>
<font color="black">1082.         Ensure that children of the placeholder ph are connected to the</font>
<font color="black">1083.         specified logger.</font>
<font color="black">1084.         &quot;&quot;&quot;</font>
<font color="green">1085.         name = alogger.name</font>
<font color="green">1086.         namelen = len(name)</font>
<font color="green">1087.         for c in ph.loggerMap.keys():</font>
<font color="black">1088.             #The if means ... if not c.parent.name.startswith(nm)</font>
<font color="green">1089.             if c.parent.name[:namelen] != name:</font>
<font color="green">1090.                 alogger.parent = c.parent</font>
<font color="green">1091.                 c.parent = alogger</font>
<font color="black">1092. </font>
<font color="black">1093. #---------------------------------------------------------------------------</font>
<font color="black">1094. #   Logger classes and functions</font>
<font color="black">1095. #---------------------------------------------------------------------------</font>
<font color="black">1096. </font>
<font color="green">1097. class Logger(Filterer):</font>
<font color="black">1098.     &quot;&quot;&quot;</font>
<font color="black">1099.     Instances of the Logger class represent a single logging channel. A</font>
<font color="black">1100.     &quot;logging channel&quot; indicates an area of an application. Exactly how an</font>
<font color="black">1101.     &quot;area&quot; is defined is up to the application developer. Since an</font>
<font color="black">1102.     application can have any number of areas, logging channels are identified</font>
<font color="black">1103.     by a unique string. Application areas can be nested (e.g. an area</font>
<font color="black">1104.     of &quot;input processing&quot; might include sub-areas &quot;read CSV files&quot;, &quot;read</font>
<font color="black">1105.     XLS files&quot; and &quot;read Gnumeric files&quot;). To cater for this natural nesting,</font>
<font color="black">1106.     channel names are organized into a namespace hierarchy where levels are</font>
<font color="black">1107.     separated by periods, much like the Java or Python package namespace. So</font>
<font color="black">1108.     in the instance given above, channel names might be &quot;input&quot; for the upper</font>
<font color="black">1109.     level, and &quot;input.csv&quot;, &quot;input.xls&quot; and &quot;input.gnu&quot; for the sub-levels.</font>
<font color="black">1110.     There is no arbitrary limit to the depth of nesting.</font>
<font color="green">1111.     &quot;&quot;&quot;</font>
<font color="green">1112.     def __init__(self, name, level=NOTSET):</font>
<font color="black">1113.         &quot;&quot;&quot;</font>
<font color="black">1114.         Initialize the logger with a name and an optional level.</font>
<font color="black">1115.         &quot;&quot;&quot;</font>
<font color="green">1116.         Filterer.__init__(self)</font>
<font color="green">1117.         self.name = name</font>
<font color="green">1118.         self.level = _checkLevel(level)</font>
<font color="green">1119.         self.parent = None</font>
<font color="green">1120.         self.propagate = 1</font>
<font color="green">1121.         self.handlers = []</font>
<font color="green">1122.         self.disabled = 0</font>
<font color="black">1123. </font>
<font color="green">1124.     def setLevel(self, level):</font>
<font color="black">1125.         &quot;&quot;&quot;</font>
<font color="black">1126.         Set the logging level of this logger.</font>
<font color="black">1127.         &quot;&quot;&quot;</font>
<font color="green">1128.         self.level = _checkLevel(level)</font>
<font color="black">1129. </font>
<font color="green">1130.     def debug(self, msg, *args, **kwargs):</font>
<font color="black">1131.         &quot;&quot;&quot;</font>
<font color="black">1132.         Log 'msg % args' with severity 'DEBUG'.</font>
<font color="black">1133. </font>
<font color="black">1134.         To pass exception information, use the keyword argument exc_info with</font>
<font color="black">1135.         a true value, e.g.</font>
<font color="black">1136. </font>
<font color="black">1137.         logger.debug(&quot;Houston, we have a %s&quot;, &quot;thorny problem&quot;, exc_info=1)</font>
<font color="black">1138.         &quot;&quot;&quot;</font>
<font color="green">1139.         if self.isEnabledFor(DEBUG):</font>
<font color="red">1140.             self._log(DEBUG, msg, args, **kwargs)</font>
<font color="black">1141. </font>
<font color="green">1142.     def info(self, msg, *args, **kwargs):</font>
<font color="black">1143.         &quot;&quot;&quot;</font>
<font color="black">1144.         Log 'msg % args' with severity 'INFO'.</font>
<font color="black">1145. </font>
<font color="black">1146.         To pass exception information, use the keyword argument exc_info with</font>
<font color="black">1147.         a true value, e.g.</font>
<font color="black">1148. </font>
<font color="black">1149.         logger.info(&quot;Houston, we have a %s&quot;, &quot;interesting problem&quot;, exc_info=1)</font>
<font color="black">1150.         &quot;&quot;&quot;</font>
<font color="red">1151.         if self.isEnabledFor(INFO):</font>
<font color="red">1152.             self._log(INFO, msg, args, **kwargs)</font>
<font color="black">1153. </font>
<font color="green">1154.     def warning(self, msg, *args, **kwargs):</font>
<font color="black">1155.         &quot;&quot;&quot;</font>
<font color="black">1156.         Log 'msg % args' with severity 'WARNING'.</font>
<font color="black">1157. </font>
<font color="black">1158.         To pass exception information, use the keyword argument exc_info with</font>
<font color="black">1159.         a true value, e.g.</font>
<font color="black">1160. </font>
<font color="black">1161.         logger.warning(&quot;Houston, we have a %s&quot;, &quot;bit of a problem&quot;, exc_info=1)</font>
<font color="black">1162.         &quot;&quot;&quot;</font>
<font color="red">1163.         if self.isEnabledFor(WARNING):</font>
<font color="red">1164.             self._log(WARNING, msg, args, **kwargs)</font>
<font color="black">1165. </font>
<font color="green">1166.     warn = warning</font>
<font color="black">1167. </font>
<font color="green">1168.     def error(self, msg, *args, **kwargs):</font>
<font color="black">1169.         &quot;&quot;&quot;</font>
<font color="black">1170.         Log 'msg % args' with severity 'ERROR'.</font>
<font color="black">1171. </font>
<font color="black">1172.         To pass exception information, use the keyword argument exc_info with</font>
<font color="black">1173.         a true value, e.g.</font>
<font color="black">1174. </font>
<font color="black">1175.         logger.error(&quot;Houston, we have a %s&quot;, &quot;major problem&quot;, exc_info=1)</font>
<font color="black">1176.         &quot;&quot;&quot;</font>
<font color="red">1177.         if self.isEnabledFor(ERROR):</font>
<font color="red">1178.             self._log(ERROR, msg, args, **kwargs)</font>
<font color="black">1179. </font>
<font color="green">1180.     def exception(self, msg, *args, **kwargs):</font>
<font color="black">1181.         &quot;&quot;&quot;</font>
<font color="black">1182.         Convenience method for logging an ERROR with exception information.</font>
<font color="black">1183.         &quot;&quot;&quot;</font>
<font color="red">1184.         kwargs['exc_info'] = 1</font>
<font color="red">1185.         self.error(msg, *args, **kwargs)</font>
<font color="black">1186. </font>
<font color="green">1187.     def critical(self, msg, *args, **kwargs):</font>
<font color="black">1188.         &quot;&quot;&quot;</font>
<font color="black">1189.         Log 'msg % args' with severity 'CRITICAL'.</font>
<font color="black">1190. </font>
<font color="black">1191.         To pass exception information, use the keyword argument exc_info with</font>
<font color="black">1192.         a true value, e.g.</font>
<font color="black">1193. </font>
<font color="black">1194.         logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)</font>
<font color="black">1195.         &quot;&quot;&quot;</font>
<font color="red">1196.         if self.isEnabledFor(CRITICAL):</font>
<font color="red">1197.             self._log(CRITICAL, msg, args, **kwargs)</font>
<font color="black">1198. </font>
<font color="green">1199.     fatal = critical</font>
<font color="black">1200. </font>
<font color="green">1201.     def log(self, level, msg, *args, **kwargs):</font>
<font color="black">1202.         &quot;&quot;&quot;</font>
<font color="black">1203.         Log 'msg % args' with the integer severity 'level'.</font>
<font color="black">1204. </font>
<font color="black">1205.         To pass exception information, use the keyword argument exc_info with</font>
<font color="black">1206.         a true value, e.g.</font>
<font color="black">1207. </font>
<font color="black">1208.         logger.log(level, &quot;We have a %s&quot;, &quot;mysterious problem&quot;, exc_info=1)</font>
<font color="black">1209.         &quot;&quot;&quot;</font>
<font color="red">1210.         if not isinstance(level, int):</font>
<font color="red">1211.             if raiseExceptions:</font>
<font color="red">1212.                 raise TypeError(&quot;level must be an integer&quot;)</font>
<font color="black">1213.             else:</font>
<font color="red">1214.                 return</font>
<font color="red">1215.         if self.isEnabledFor(level):</font>
<font color="red">1216.             self._log(level, msg, args, **kwargs)</font>
<font color="black">1217. </font>
<font color="green">1218.     def findCaller(self):</font>
<font color="black">1219.         &quot;&quot;&quot;</font>
<font color="black">1220.         Find the stack frame of the caller so that we can note the source</font>
<font color="black">1221.         file name, line number and function name.</font>
<font color="black">1222.         &quot;&quot;&quot;</font>
<font color="red">1223.         f = currentframe()</font>
<font color="black">1224.         #On some versions of IronPython, currentframe() returns None if</font>
<font color="black">1225.         #IronPython isn't run with -X:Frames.</font>
<font color="red">1226.         if f is not None:</font>
<font color="red">1227.             f = f.f_back</font>
<font color="red">1228.         rv = &quot;(unknown file)&quot;, 0, &quot;(unknown function)&quot;</font>
<font color="red">1229.         while hasattr(f, &quot;f_code&quot;):</font>
<font color="red">1230.             co = f.f_code</font>
<font color="red">1231.             filename = os.path.normcase(co.co_filename)</font>
<font color="red">1232.             if filename == _srcfile:</font>
<font color="red">1233.                 f = f.f_back</font>
<font color="red">1234.                 continue</font>
<font color="red">1235.             rv = (co.co_filename, f.f_lineno, co.co_name)</font>
<font color="red">1236.             break</font>
<font color="red">1237.         return rv</font>
<font color="black">1238. </font>
<font color="green">1239.     def makeRecord(self, name, level, fn, lno, msg, args, exc_info, func=None, extra=None):</font>
<font color="black">1240.         &quot;&quot;&quot;</font>
<font color="black">1241.         A factory method which can be overridden in subclasses to create</font>
<font color="black">1242.         specialized LogRecords.</font>
<font color="black">1243.         &quot;&quot;&quot;</font>
<font color="red">1244.         rv = LogRecord(name, level, fn, lno, msg, args, exc_info, func)</font>
<font color="red">1245.         if extra is not None:</font>
<font color="red">1246.             for key in extra:</font>
<font color="red">1247.                 if (key in [&quot;message&quot;, &quot;asctime&quot;]) or (key in rv.__dict__):</font>
<font color="red">1248.                     raise KeyError(&quot;Attempt to overwrite %r in LogRecord&quot; % key)</font>
<font color="red">1249.                 rv.__dict__[key] = extra[key]</font>
<font color="red">1250.         return rv</font>
<font color="black">1251. </font>
<font color="green">1252.     def _log(self, level, msg, args, exc_info=None, extra=None):</font>
<font color="black">1253.         &quot;&quot;&quot;</font>
<font color="black">1254.         Low-level logging routine which creates a LogRecord and then calls</font>
<font color="black">1255.         all the handlers of this logger to handle the record.</font>
<font color="black">1256.         &quot;&quot;&quot;</font>
<font color="red">1257.         if _srcfile:</font>
<font color="black">1258.             #IronPython doesn't track Python frames, so findCaller raises an</font>
<font color="black">1259.             #exception on some versions of IronPython. We trap it here so that</font>
<font color="black">1260.             #IronPython can use logging.</font>
<font color="red">1261.             try:</font>
<font color="red">1262.                 fn, lno, func = self.findCaller()</font>
<font color="red">1263.             except ValueError:</font>
<font color="red">1264.                 fn, lno, func = &quot;(unknown file)&quot;, 0, &quot;(unknown function)&quot;</font>
<font color="black">1265.         else:</font>
<font color="red">1266.             fn, lno, func = &quot;(unknown file)&quot;, 0, &quot;(unknown function)&quot;</font>
<font color="red">1267.         if exc_info:</font>
<font color="red">1268.             if not isinstance(exc_info, tuple):</font>
<font color="red">1269.                 exc_info = sys.exc_info()</font>
<font color="red">1270.         record = self.makeRecord(self.name, level, fn, lno, msg, args, exc_info, func, extra)</font>
<font color="red">1271.         self.handle(record)</font>
<font color="black">1272. </font>
<font color="green">1273.     def handle(self, record):</font>
<font color="black">1274.         &quot;&quot;&quot;</font>
<font color="black">1275.         Call the handlers for the specified record.</font>
<font color="black">1276. </font>
<font color="black">1277.         This method is used for unpickled records received from a socket, as</font>
<font color="black">1278.         well as those created locally. Logger-level filtering is applied.</font>
<font color="black">1279.         &quot;&quot;&quot;</font>
<font color="red">1280.         if (not self.disabled) and self.filter(record):</font>
<font color="red">1281.             self.callHandlers(record)</font>
<font color="black">1282. </font>
<font color="green">1283.     def addHandler(self, hdlr):</font>
<font color="black">1284.         &quot;&quot;&quot;</font>
<font color="black">1285.         Add the specified handler to this logger.</font>
<font color="black">1286.         &quot;&quot;&quot;</font>
<font color="green">1287.         _acquireLock()</font>
<font color="green">1288.         try:</font>
<font color="green">1289.             if not (hdlr in self.handlers):</font>
<font color="green">1290.                 self.handlers.append(hdlr)</font>
<font color="black">1291.         finally:</font>
<font color="green">1292.             _releaseLock()</font>
<font color="black">1293. </font>
<font color="green">1294.     def removeHandler(self, hdlr):</font>
<font color="black">1295.         &quot;&quot;&quot;</font>
<font color="black">1296.         Remove the specified handler from this logger.</font>
<font color="black">1297.         &quot;&quot;&quot;</font>
<font color="red">1298.         _acquireLock()</font>
<font color="red">1299.         try:</font>
<font color="red">1300.             if hdlr in self.handlers:</font>
<font color="red">1301.                 self.handlers.remove(hdlr)</font>
<font color="black">1302.         finally:</font>
<font color="red">1303.             _releaseLock()</font>
<font color="black">1304. </font>
<font color="green">1305.     def callHandlers(self, record):</font>
<font color="black">1306.         &quot;&quot;&quot;</font>
<font color="black">1307.         Pass a record to all relevant handlers.</font>
<font color="black">1308. </font>
<font color="black">1309.         Loop through all handlers for this logger and its parents in the</font>
<font color="black">1310.         logger hierarchy. If no handler was found, output a one-off error</font>
<font color="black">1311.         message to sys.stderr. Stop searching up the hierarchy whenever a</font>
<font color="black">1312.         logger with the &quot;propagate&quot; attribute set to zero is found - that</font>
<font color="black">1313.         will be the last logger whose handlers are called.</font>
<font color="black">1314.         &quot;&quot;&quot;</font>
<font color="red">1315.         c = self</font>
<font color="red">1316.         found = 0</font>
<font color="red">1317.         while c:</font>
<font color="red">1318.             for hdlr in c.handlers:</font>
<font color="red">1319.                 found = found + 1</font>
<font color="red">1320.                 if record.levelno &gt;= hdlr.level:</font>
<font color="red">1321.                     hdlr.handle(record)</font>
<font color="red">1322.             if not c.propagate:</font>
<font color="red">1323.                 c = None    #break out</font>
<font color="black">1324.             else:</font>
<font color="red">1325.                 c = c.parent</font>
<font color="red">1326.         if (found == 0) and raiseExceptions and not self.manager.emittedNoHandlerWarning:</font>
<font color="red">1327.             sys.stderr.write(&quot;No handlers could be found for logger&quot;</font>
<font color="red">1328.                              &quot; \&quot;%s\&quot;\n&quot; % self.name)</font>
<font color="red">1329.             self.manager.emittedNoHandlerWarning = 1</font>
<font color="black">1330. </font>
<font color="green">1331.     def getEffectiveLevel(self):</font>
<font color="black">1332.         &quot;&quot;&quot;</font>
<font color="black">1333.         Get the effective level for this logger.</font>
<font color="black">1334. </font>
<font color="black">1335.         Loop through this logger and its parents in the logger hierarchy,</font>
<font color="black">1336.         looking for a non-zero logging level. Return the first one found.</font>
<font color="black">1337.         &quot;&quot;&quot;</font>
<font color="green">1338.         logger = self</font>
<font color="green">1339.         while logger:</font>
<font color="green">1340.             if logger.level:</font>
<font color="green">1341.                 return logger.level</font>
<font color="green">1342.             logger = logger.parent</font>
<font color="red">1343.         return NOTSET</font>
<font color="black">1344. </font>
<font color="green">1345.     def isEnabledFor(self, level):</font>
<font color="black">1346.         &quot;&quot;&quot;</font>
<font color="black">1347.         Is this logger enabled for level 'level'?</font>
<font color="black">1348.         &quot;&quot;&quot;</font>
<font color="green">1349.         if self.manager.disable &gt;= level:</font>
<font color="red">1350.             return 0</font>
<font color="green">1351.         return level &gt;= self.getEffectiveLevel()</font>
<font color="black">1352. </font>
<font color="green">1353.     def getChild(self, suffix):</font>
<font color="black">1354.         &quot;&quot;&quot;</font>
<font color="black">1355.         Get a logger which is a descendant to this one.</font>
<font color="black">1356. </font>
<font color="black">1357.         This is a convenience method, such that</font>
<font color="black">1358. </font>
<font color="black">1359.         logging.getLogger('abc').getChild('def.ghi')</font>
<font color="black">1360. </font>
<font color="black">1361.         is the same as</font>
<font color="black">1362. </font>
<font color="black">1363.         logging.getLogger('abc.def.ghi')</font>
<font color="black">1364. </font>
<font color="black">1365.         It's useful, for example, when the parent logger is named using</font>
<font color="black">1366.         __name__ rather than a literal string.</font>
<font color="black">1367.         &quot;&quot;&quot;</font>
<font color="red">1368.         if self.root is not self:</font>
<font color="red">1369.             suffix = '.'.join((self.name, suffix))</font>
<font color="red">1370.         return self.manager.getLogger(suffix)</font>
<font color="black">1371. </font>
<font color="green">1372. class RootLogger(Logger):</font>
<font color="black">1373.     &quot;&quot;&quot;</font>
<font color="black">1374.     A root logger is not that different to any other logger, except that</font>
<font color="black">1375.     it must have a logging level and there is only one instance of it in</font>
<font color="black">1376.     the hierarchy.</font>
<font color="green">1377.     &quot;&quot;&quot;</font>
<font color="green">1378.     def __init__(self, level):</font>
<font color="black">1379.         &quot;&quot;&quot;</font>
<font color="black">1380.         Initialize the logger with the name &quot;root&quot;.</font>
<font color="black">1381.         &quot;&quot;&quot;</font>
<font color="green">1382.         Logger.__init__(self, &quot;root&quot;, level)</font>
<font color="black">1383. </font>
<font color="green">1384. _loggerClass = Logger</font>
<font color="black">1385. </font>
<font color="green">1386. class LoggerAdapter(object):</font>
<font color="black">1387.     &quot;&quot;&quot;</font>
<font color="black">1388.     An adapter for loggers which makes it easier to specify contextual</font>
<font color="black">1389.     information in logging output.</font>
<font color="green">1390.     &quot;&quot;&quot;</font>
<font color="black">1391. </font>
<font color="green">1392.     def __init__(self, logger, extra):</font>
<font color="black">1393.         &quot;&quot;&quot;</font>
<font color="black">1394.         Initialize the adapter with a logger and a dict-like object which</font>
<font color="black">1395.         provides contextual information. This constructor signature allows</font>
<font color="black">1396.         easy stacking of LoggerAdapters, if so desired.</font>
<font color="black">1397. </font>
<font color="black">1398.         You can effectively pass keyword arguments as shown in the</font>
<font color="black">1399.         following example:</font>
<font color="black">1400. </font>
<font color="black">1401.         adapter = LoggerAdapter(someLogger, dict(p1=v1, p2=&quot;v2&quot;))</font>
<font color="black">1402.         &quot;&quot;&quot;</font>
<font color="red">1403.         self.logger = logger</font>
<font color="red">1404.         self.extra = extra</font>
<font color="black">1405. </font>
<font color="green">1406.     def process(self, msg, kwargs):</font>
<font color="black">1407.         &quot;&quot;&quot;</font>
<font color="black">1408.         Process the logging message and keyword arguments passed in to</font>
<font color="black">1409.         a logging call to insert contextual information. You can either</font>
<font color="black">1410.         manipulate the message itself, the keyword args or both. Return</font>
<font color="black">1411.         the message and kwargs modified (or not) to suit your needs.</font>
<font color="black">1412. </font>
<font color="black">1413.         Normally, you'll only need to override this one method in a</font>
<font color="black">1414.         LoggerAdapter subclass for your specific needs.</font>
<font color="black">1415.         &quot;&quot;&quot;</font>
<font color="red">1416.         kwargs[&quot;extra&quot;] = self.extra</font>
<font color="red">1417.         return msg, kwargs</font>
<font color="black">1418. </font>
<font color="green">1419.     def debug(self, msg, *args, **kwargs):</font>
<font color="black">1420.         &quot;&quot;&quot;</font>
<font color="black">1421.         Delegate a debug call to the underlying logger, after adding</font>
<font color="black">1422.         contextual information from this adapter instance.</font>
<font color="black">1423.         &quot;&quot;&quot;</font>
<font color="red">1424.         msg, kwargs = self.process(msg, kwargs)</font>
<font color="red">1425.         self.logger.debug(msg, *args, **kwargs)</font>
<font color="black">1426. </font>
<font color="green">1427.     def info(self, msg, *args, **kwargs):</font>
<font color="black">1428.         &quot;&quot;&quot;</font>
<font color="black">1429.         Delegate an info call to the underlying logger, after adding</font>
<font color="black">1430.         contextual information from this adapter instance.</font>
<font color="black">1431.         &quot;&quot;&quot;</font>
<font color="red">1432.         msg, kwargs = self.process(msg, kwargs)</font>
<font color="red">1433.         self.logger.info(msg, *args, **kwargs)</font>
<font color="black">1434. </font>
<font color="green">1435.     def warning(self, msg, *args, **kwargs):</font>
<font color="black">1436.         &quot;&quot;&quot;</font>
<font color="black">1437.         Delegate a warning call to the underlying logger, after adding</font>
<font color="black">1438.         contextual information from this adapter instance.</font>
<font color="black">1439.         &quot;&quot;&quot;</font>
<font color="red">1440.         msg, kwargs = self.process(msg, kwargs)</font>
<font color="red">1441.         self.logger.warning(msg, *args, **kwargs)</font>
<font color="black">1442. </font>
<font color="green">1443.     def error(self, msg, *args, **kwargs):</font>
<font color="black">1444.         &quot;&quot;&quot;</font>
<font color="black">1445.         Delegate an error call to the underlying logger, after adding</font>
<font color="black">1446.         contextual information from this adapter instance.</font>
<font color="black">1447.         &quot;&quot;&quot;</font>
<font color="red">1448.         msg, kwargs = self.process(msg, kwargs)</font>
<font color="red">1449.         self.logger.error(msg, *args, **kwargs)</font>
<font color="black">1450. </font>
<font color="green">1451.     def exception(self, msg, *args, **kwargs):</font>
<font color="black">1452.         &quot;&quot;&quot;</font>
<font color="black">1453.         Delegate an exception call to the underlying logger, after adding</font>
<font color="black">1454.         contextual information from this adapter instance.</font>
<font color="black">1455.         &quot;&quot;&quot;</font>
<font color="red">1456.         msg, kwargs = self.process(msg, kwargs)</font>
<font color="red">1457.         kwargs[&quot;exc_info&quot;] = 1</font>
<font color="red">1458.         self.logger.error(msg, *args, **kwargs)</font>
<font color="black">1459. </font>
<font color="green">1460.     def critical(self, msg, *args, **kwargs):</font>
<font color="black">1461.         &quot;&quot;&quot;</font>
<font color="black">1462.         Delegate a critical call to the underlying logger, after adding</font>
<font color="black">1463.         contextual information from this adapter instance.</font>
<font color="black">1464.         &quot;&quot;&quot;</font>
<font color="red">1465.         msg, kwargs = self.process(msg, kwargs)</font>
<font color="red">1466.         self.logger.critical(msg, *args, **kwargs)</font>
<font color="black">1467. </font>
<font color="green">1468.     def log(self, level, msg, *args, **kwargs):</font>
<font color="black">1469.         &quot;&quot;&quot;</font>
<font color="black">1470.         Delegate a log call to the underlying logger, after adding</font>
<font color="black">1471.         contextual information from this adapter instance.</font>
<font color="black">1472.         &quot;&quot;&quot;</font>
<font color="red">1473.         msg, kwargs = self.process(msg, kwargs)</font>
<font color="red">1474.         self.logger.log(level, msg, *args, **kwargs)</font>
<font color="black">1475. </font>
<font color="green">1476.     def isEnabledFor(self, level):</font>
<font color="black">1477.         &quot;&quot;&quot;</font>
<font color="black">1478.         See if the underlying logger is enabled for the specified level.</font>
<font color="black">1479.         &quot;&quot;&quot;</font>
<font color="red">1480.         return self.logger.isEnabledFor(level)</font>
<font color="black">1481. </font>
<font color="green">1482. root = RootLogger(WARNING)</font>
<font color="green">1483. Logger.root = root</font>
<font color="green">1484. Logger.manager = Manager(Logger.root)</font>
<font color="black">1485. </font>
<font color="black">1486. #---------------------------------------------------------------------------</font>
<font color="black">1487. # Configuration classes and functions</font>
<font color="black">1488. #---------------------------------------------------------------------------</font>
<font color="black">1489. </font>
<font color="green">1490. BASIC_FORMAT = &quot;%(levelname)s:%(name)s:%(message)s&quot;</font>
<font color="black">1491. </font>
<font color="green">1492. def basicConfig(**kwargs):</font>
<font color="black">1493.     &quot;&quot;&quot;</font>
<font color="black">1494.     Do basic configuration for the logging system.</font>
<font color="black">1495. </font>
<font color="black">1496.     This function does nothing if the root logger already has handlers</font>
<font color="black">1497.     configured. It is a convenience method intended for use by simple scripts</font>
<font color="black">1498.     to do one-shot configuration of the logging package.</font>
<font color="black">1499. </font>
<font color="black">1500.     The default behaviour is to create a StreamHandler which writes to</font>
<font color="black">1501.     sys.stderr, set a formatter using the BASIC_FORMAT format string, and</font>
<font color="black">1502.     add the handler to the root logger.</font>
<font color="black">1503. </font>
<font color="black">1504.     A number of optional keyword arguments may be specified, which can alter</font>
<font color="black">1505.     the default behaviour.</font>
<font color="black">1506. </font>
<font color="black">1507.     filename  Specifies that a FileHandler be created, using the specified</font>
<font color="black">1508.               filename, rather than a StreamHandler.</font>
<font color="black">1509.     filemode  Specifies the mode to open the file, if filename is specified</font>
<font color="black">1510.               (if filemode is unspecified, it defaults to 'a').</font>
<font color="black">1511.     format    Use the specified format string for the handler.</font>
<font color="black">1512.     datefmt   Use the specified date/time format.</font>
<font color="black">1513.     level     Set the root logger level to the specified level.</font>
<font color="black">1514.     stream    Use the specified stream to initialize the StreamHandler. Note</font>
<font color="black">1515.               that this argument is incompatible with 'filename' - if both</font>
<font color="black">1516.               are present, 'stream' is ignored.</font>
<font color="black">1517. </font>
<font color="black">1518.     Note that you could specify a stream created using open(filename, mode)</font>
<font color="black">1519.     rather than passing the filename and mode in. However, it should be</font>
<font color="black">1520.     remembered that StreamHandler does not close its stream (since it may be</font>
<font color="black">1521.     using sys.stdout or sys.stderr), whereas FileHandler closes its stream</font>
<font color="black">1522.     when the handler is closed.</font>
<font color="black">1523.     &quot;&quot;&quot;</font>
<font color="black">1524.     # Add thread safety in case someone mistakenly calls</font>
<font color="black">1525.     # basicConfig() from multiple threads</font>
<font color="red">1526.     _acquireLock()</font>
<font color="red">1527.     try:</font>
<font color="red">1528.         if len(root.handlers) == 0:</font>
<font color="red">1529.             filename = kwargs.get(&quot;filename&quot;)</font>
<font color="red">1530.             if filename:</font>
<font color="red">1531.                 mode = kwargs.get(&quot;filemode&quot;, 'a')</font>
<font color="red">1532.                 hdlr = FileHandler(filename, mode)</font>
<font color="black">1533.             else:</font>
<font color="red">1534.                 stream = kwargs.get(&quot;stream&quot;)</font>
<font color="red">1535.                 hdlr = StreamHandler(stream)</font>
<font color="red">1536.             fs = kwargs.get(&quot;format&quot;, BASIC_FORMAT)</font>
<font color="red">1537.             dfs = kwargs.get(&quot;datefmt&quot;, None)</font>
<font color="red">1538.             fmt = Formatter(fs, dfs)</font>
<font color="red">1539.             hdlr.setFormatter(fmt)</font>
<font color="red">1540.             root.addHandler(hdlr)</font>
<font color="red">1541.             level = kwargs.get(&quot;level&quot;)</font>
<font color="red">1542.             if level is not None:</font>
<font color="red">1543.                 root.setLevel(level)</font>
<font color="black">1544.     finally:</font>
<font color="red">1545.         _releaseLock()</font>
<font color="black">1546. </font>
<font color="black">1547. #---------------------------------------------------------------------------</font>
<font color="black">1548. # Utility functions at module level.</font>
<font color="black">1549. # Basically delegate everything to the root logger.</font>
<font color="black">1550. #---------------------------------------------------------------------------</font>
<font color="black">1551. </font>
<font color="green">1552. def getLogger(name=None):</font>
<font color="black">1553.     &quot;&quot;&quot;</font>
<font color="black">1554.     Return a logger with the specified name, creating it if necessary.</font>
<font color="black">1555. </font>
<font color="black">1556.     If no name is specified, return the root logger.</font>
<font color="black">1557.     &quot;&quot;&quot;</font>
<font color="green">1558.     if name:</font>
<font color="green">1559.         return Logger.manager.getLogger(name)</font>
<font color="black">1560.     else:</font>
<font color="red">1561.         return root</font>
<font color="black">1562. </font>
<font color="black">1563. #def getRootLogger():</font>
<font color="black">1564. #    &quot;&quot;&quot;</font>
<font color="black">1565. #    Return the root logger.</font>
<font color="black">1566. #</font>
<font color="black">1567. #    Note that getLogger('') now does the same thing, so this function is</font>
<font color="black">1568. #    deprecated and may disappear in the future.</font>
<font color="black">1569. #    &quot;&quot;&quot;</font>
<font color="black">1570. #    return root</font>
<font color="black">1571. </font>
<font color="green">1572. def critical(msg, *args, **kwargs):</font>
<font color="black">1573.     &quot;&quot;&quot;</font>
<font color="black">1574.     Log a message with severity 'CRITICAL' on the root logger.</font>
<font color="black">1575.     &quot;&quot;&quot;</font>
<font color="red">1576.     if len(root.handlers) == 0:</font>
<font color="red">1577.         basicConfig()</font>
<font color="red">1578.     root.critical(msg, *args, **kwargs)</font>
<font color="black">1579. </font>
<font color="green">1580. fatal = critical</font>
<font color="black">1581. </font>
<font color="green">1582. def error(msg, *args, **kwargs):</font>
<font color="black">1583.     &quot;&quot;&quot;</font>
<font color="black">1584.     Log a message with severity 'ERROR' on the root logger.</font>
<font color="black">1585.     &quot;&quot;&quot;</font>
<font color="red">1586.     if len(root.handlers) == 0:</font>
<font color="red">1587.         basicConfig()</font>
<font color="red">1588.     root.error(msg, *args, **kwargs)</font>
<font color="black">1589. </font>
<font color="green">1590. def exception(msg, *args, **kwargs):</font>
<font color="black">1591.     &quot;&quot;&quot;</font>
<font color="black">1592.     Log a message with severity 'ERROR' on the root logger,</font>
<font color="black">1593.     with exception information.</font>
<font color="black">1594.     &quot;&quot;&quot;</font>
<font color="red">1595.     kwargs['exc_info'] = 1</font>
<font color="red">1596.     error(msg, *args, **kwargs)</font>
<font color="black">1597. </font>
<font color="green">1598. def warning(msg, *args, **kwargs):</font>
<font color="black">1599.     &quot;&quot;&quot;</font>
<font color="black">1600.     Log a message with severity 'WARNING' on the root logger.</font>
<font color="black">1601.     &quot;&quot;&quot;</font>
<font color="red">1602.     if len(root.handlers) == 0:</font>
<font color="red">1603.         basicConfig()</font>
<font color="red">1604.     root.warning(msg, *args, **kwargs)</font>
<font color="black">1605. </font>
<font color="green">1606. warn = warning</font>
<font color="black">1607. </font>
<font color="green">1608. def info(msg, *args, **kwargs):</font>
<font color="black">1609.     &quot;&quot;&quot;</font>
<font color="black">1610.     Log a message with severity 'INFO' on the root logger.</font>
<font color="black">1611.     &quot;&quot;&quot;</font>
<font color="red">1612.     if len(root.handlers) == 0:</font>
<font color="red">1613.         basicConfig()</font>
<font color="red">1614.     root.info(msg, *args, **kwargs)</font>
<font color="black">1615. </font>
<font color="green">1616. def debug(msg, *args, **kwargs):</font>
<font color="black">1617.     &quot;&quot;&quot;</font>
<font color="black">1618.     Log a message with severity 'DEBUG' on the root logger.</font>
<font color="black">1619.     &quot;&quot;&quot;</font>
<font color="red">1620.     if len(root.handlers) == 0:</font>
<font color="red">1621.         basicConfig()</font>
<font color="red">1622.     root.debug(msg, *args, **kwargs)</font>
<font color="black">1623. </font>
<font color="green">1624. def log(level, msg, *args, **kwargs):</font>
<font color="black">1625.     &quot;&quot;&quot;</font>
<font color="black">1626.     Log 'msg % args' with the integer severity 'level' on the root logger.</font>
<font color="black">1627.     &quot;&quot;&quot;</font>
<font color="red">1628.     if len(root.handlers) == 0:</font>
<font color="red">1629.         basicConfig()</font>
<font color="red">1630.     root.log(level, msg, *args, **kwargs)</font>
<font color="black">1631. </font>
<font color="green">1632. def disable(level):</font>
<font color="black">1633.     &quot;&quot;&quot;</font>
<font color="black">1634.     Disable all logging calls of severity 'level' and below.</font>
<font color="black">1635.     &quot;&quot;&quot;</font>
<font color="red">1636.     root.manager.disable = level</font>
<font color="black">1637. </font>
<font color="green">1638. def shutdown(handlerList=_handlerList):</font>
<font color="black">1639.     &quot;&quot;&quot;</font>
<font color="black">1640.     Perform any cleanup actions in the logging system (e.g. flushing</font>
<font color="black">1641.     buffers).</font>
<font color="black">1642. </font>
<font color="black">1643.     Should be called at application exit.</font>
<font color="black">1644.     &quot;&quot;&quot;</font>
<font color="red">1645.     for wr in reversed(handlerList[:]):</font>
<font color="black">1646.         #errors might occur, for example, if files are locked</font>
<font color="black">1647.         #we just ignore them if raiseExceptions is not set</font>
<font color="red">1648.         try:</font>
<font color="red">1649.             h = wr()</font>
<font color="red">1650.             if h:</font>
<font color="red">1651.                 try:</font>
<font color="red">1652.                     h.acquire()</font>
<font color="red">1653.                     h.flush()</font>
<font color="red">1654.                     h.close()</font>
<font color="red">1655.                 except (IOError, ValueError):</font>
<font color="black">1656.                     # Ignore errors which might be caused</font>
<font color="black">1657.                     # because handlers have been closed but</font>
<font color="black">1658.                     # references to them are still around at</font>
<font color="black">1659.                     # application exit.</font>
<font color="red">1660.                     pass</font>
<font color="black">1661.                 finally:</font>
<font color="red">1662.                     h.release()</font>
<font color="red">1663.         except:</font>
<font color="red">1664.             if raiseExceptions:</font>
<font color="red">1665.                 raise</font>
<font color="black">1666.             #else, swallow</font>
<font color="black">1667. </font>
<font color="black">1668. #Let's try and shutdown automatically on application exit...</font>
<font color="green">1669. import atexit</font>
<font color="green">1670. atexit.register(shutdown)</font>
<font color="black">1671. </font>
<font color="black">1672. # Null handler</font>
<font color="black">1673. </font>
<font color="green">1674. class NullHandler(Handler):</font>
<font color="black">1675.     &quot;&quot;&quot;</font>
<font color="black">1676.     This handler does nothing. It's intended to be used to avoid the</font>
<font color="black">1677.     &quot;No handlers could be found for logger XXX&quot; one-off warning. This is</font>
<font color="black">1678.     important for library code, which may contain code to log events. If a user</font>
<font color="black">1679.     of the library does not configure logging, the one-off warning might be</font>
<font color="black">1680.     produced; to avoid this, the library developer simply needs to instantiate</font>
<font color="black">1681.     a NullHandler and add it to the top-level logger of the library module or</font>
<font color="black">1682.     package.</font>
<font color="green">1683.     &quot;&quot;&quot;</font>
<font color="green">1684.     def handle(self, record):</font>
<font color="red">1685.         pass</font>
<font color="black">1686. </font>
<font color="green">1687.     def emit(self, record):</font>
<font color="red">1688.         pass</font>
<font color="black">1689. </font>
<font color="green">1690.     def createLock(self):</font>
<font color="red">1691.         self.lock = None</font>
<font color="black">1692. </font>
<font color="black">1693. # Warnings integration</font>
<font color="black">1694. </font>
<font color="green">1695. _warnings_showwarning = None</font>
<font color="black">1696. </font>
<font color="green">1697. def _showwarning(message, category, filename, lineno, file=None, line=None):</font>
<font color="black">1698.     &quot;&quot;&quot;</font>
<font color="black">1699.     Implementation of showwarnings which redirects to logging, which will first</font>
<font color="black">1700.     check to see if the file parameter is None. If a file is specified, it will</font>
<font color="black">1701.     delegate to the original warnings implementation of showwarning. Otherwise,</font>
<font color="black">1702.     it will call warnings.formatwarning and will log the resulting string to a</font>
<font color="black">1703.     warnings logger named &quot;py.warnings&quot; with level logging.WARNING.</font>
<font color="black">1704.     &quot;&quot;&quot;</font>
<font color="red">1705.     if file is not None:</font>
<font color="red">1706.         if _warnings_showwarning is not None:</font>
<font color="red">1707.             _warnings_showwarning(message, category, filename, lineno, file, line)</font>
<font color="black">1708.     else:</font>
<font color="red">1709.         s = warnings.formatwarning(message, category, filename, lineno, line)</font>
<font color="red">1710.         logger = getLogger(&quot;py.warnings&quot;)</font>
<font color="red">1711.         if not logger.handlers:</font>
<font color="red">1712.             logger.addHandler(NullHandler())</font>
<font color="red">1713.         logger.warning(&quot;%s&quot;, s)</font>
<font color="black">1714. </font>
<font color="green">1715. def captureWarnings(capture):</font>
<font color="black">1716.     &quot;&quot;&quot;</font>
<font color="black">1717.     If capture is true, redirect all warnings to the logging package.</font>
<font color="black">1718.     If capture is False, ensure that warnings are not redirected to logging</font>
<font color="black">1719.     but to their original destinations.</font>
<font color="black">1720.     &quot;&quot;&quot;</font>
<font color="black">1721.     global _warnings_showwarning</font>
<font color="green">1722.     if capture:</font>
<font color="green">1723.         if _warnings_showwarning is None:</font>
<font color="green">1724.             _warnings_showwarning = warnings.showwarning</font>
<font color="green">1725.             warnings.showwarning = _showwarning</font>
<font color="black">1726.     else:</font>
<font color="red">1727.         if _warnings_showwarning is not None:</font>
<font color="red">1728.             warnings.showwarning = _warnings_showwarning</font>
<font color="red">1729.             _warnings_showwarning = None</font>
</pre>

