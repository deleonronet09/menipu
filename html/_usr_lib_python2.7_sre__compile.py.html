source file: <b>/usr/lib/python2.7/sre_compile.py</b><br>


file stats: <b>393 lines, 264 executed: 67.2% covered</b>
<pre>
<font color="black">   1. #</font>
<font color="black">   2. # Secret Labs' Regular Expression Engine</font>
<font color="black">   3. #</font>
<font color="black">   4. # convert template to internal format</font>
<font color="black">   5. #</font>
<font color="black">   6. # Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.</font>
<font color="black">   7. #</font>
<font color="black">   8. # See the sre.py file for information on usage and redistribution.</font>
<font color="black">   9. #</font>
<font color="black">  10. </font>
<font color="red">  11. &quot;&quot;&quot;Internal support module for sre&quot;&quot;&quot;</font>
<font color="black">  12. </font>
<font color="red">  13. import _sre, sys</font>
<font color="red">  14. import sre_parse</font>
<font color="red">  15. from sre_constants import *</font>
<font color="black">  16. </font>
<font color="red">  17. assert _sre.MAGIC == MAGIC, &quot;SRE module mismatch&quot;</font>
<font color="black">  18. </font>
<font color="red">  19. if _sre.CODESIZE == 2:</font>
<font color="red">  20.     MAXCODE = 65535</font>
<font color="black">  21. else:</font>
<font color="red">  22.     MAXCODE = 0xFFFFFFFFL</font>
<font color="black">  23. </font>
<font color="red">  24. def _identityfunction(x):</font>
<font color="green">  25.     return x</font>
<font color="black">  26. </font>
<font color="red">  27. _LITERAL_CODES = set([LITERAL, NOT_LITERAL])</font>
<font color="red">  28. _REPEATING_CODES = set([REPEAT, MIN_REPEAT, MAX_REPEAT])</font>
<font color="red">  29. _SUCCESS_CODES = set([SUCCESS, FAILURE])</font>
<font color="red">  30. _ASSERT_CODES = set([ASSERT, ASSERT_NOT])</font>
<font color="black">  31. </font>
<font color="red">  32. def _compile(code, pattern, flags):</font>
<font color="black">  33.     # internal: compile a (sub)pattern</font>
<font color="green">  34.     emit = code.append</font>
<font color="green">  35.     _len = len</font>
<font color="green">  36.     LITERAL_CODES = _LITERAL_CODES</font>
<font color="green">  37.     REPEATING_CODES = _REPEATING_CODES</font>
<font color="green">  38.     SUCCESS_CODES = _SUCCESS_CODES</font>
<font color="green">  39.     ASSERT_CODES = _ASSERT_CODES</font>
<font color="green">  40.     for op, av in pattern:</font>
<font color="green">  41.         if op in LITERAL_CODES:</font>
<font color="green">  42.             if flags &amp; SRE_FLAG_IGNORECASE:</font>
<font color="green">  43.                 emit(OPCODES[OP_IGNORE[op]])</font>
<font color="green">  44.                 emit(_sre.getlower(av, flags))</font>
<font color="black">  45.             else:</font>
<font color="green">  46.                 emit(OPCODES[op])</font>
<font color="green">  47.                 emit(av)</font>
<font color="green">  48.         elif op is IN:</font>
<font color="green">  49.             if flags &amp; SRE_FLAG_IGNORECASE:</font>
<font color="green">  50.                 emit(OPCODES[OP_IGNORE[op]])</font>
<font color="green">  51.                 def fixup(literal, flags=flags):</font>
<font color="green">  52.                     return _sre.getlower(literal, flags)</font>
<font color="black">  53.             else:</font>
<font color="green">  54.                 emit(OPCODES[op])</font>
<font color="green">  55.                 fixup = _identityfunction</font>
<font color="green">  56.             skip = _len(code); emit(0)</font>
<font color="green">  57.             _compile_charset(av, flags, code, fixup)</font>
<font color="green">  58.             code[skip] = _len(code) - skip</font>
<font color="green">  59.         elif op is ANY:</font>
<font color="green">  60.             if flags &amp; SRE_FLAG_DOTALL:</font>
<font color="green">  61.                 emit(OPCODES[ANY_ALL])</font>
<font color="black">  62.             else:</font>
<font color="green">  63.                 emit(OPCODES[ANY])</font>
<font color="green">  64.         elif op in REPEATING_CODES:</font>
<font color="green">  65.             if flags &amp; SRE_FLAG_TEMPLATE:</font>
<font color="red">  66.                 raise error, &quot;internal: unsupported template operator&quot;</font>
<font color="red">  67.                 emit(OPCODES[REPEAT])</font>
<font color="red">  68.                 skip = _len(code); emit(0)</font>
<font color="red">  69.                 emit(av[0])</font>
<font color="red">  70.                 emit(av[1])</font>
<font color="red">  71.                 _compile(code, av[2], flags)</font>
<font color="red">  72.                 emit(OPCODES[SUCCESS])</font>
<font color="red">  73.                 code[skip] = _len(code) - skip</font>
<font color="green">  74.             elif _simple(av) and op is not REPEAT:</font>
<font color="green">  75.                 if op is MAX_REPEAT:</font>
<font color="green">  76.                     emit(OPCODES[REPEAT_ONE])</font>
<font color="black">  77.                 else:</font>
<font color="green">  78.                     emit(OPCODES[MIN_REPEAT_ONE])</font>
<font color="green">  79.                 skip = _len(code); emit(0)</font>
<font color="green">  80.                 emit(av[0])</font>
<font color="green">  81.                 emit(av[1])</font>
<font color="green">  82.                 _compile(code, av[2], flags)</font>
<font color="green">  83.                 emit(OPCODES[SUCCESS])</font>
<font color="green">  84.                 code[skip] = _len(code) - skip</font>
<font color="black">  85.             else:</font>
<font color="green">  86.                 emit(OPCODES[REPEAT])</font>
<font color="green">  87.                 skip = _len(code); emit(0)</font>
<font color="green">  88.                 emit(av[0])</font>
<font color="green">  89.                 emit(av[1])</font>
<font color="green">  90.                 _compile(code, av[2], flags)</font>
<font color="green">  91.                 code[skip] = _len(code) - skip</font>
<font color="green">  92.                 if op is MAX_REPEAT:</font>
<font color="green">  93.                     emit(OPCODES[MAX_UNTIL])</font>
<font color="black">  94.                 else:</font>
<font color="green">  95.                     emit(OPCODES[MIN_UNTIL])</font>
<font color="green">  96.         elif op is SUBPATTERN:</font>
<font color="green">  97.             if av[0]:</font>
<font color="green">  98.                 emit(OPCODES[MARK])</font>
<font color="green">  99.                 emit((av[0]-1)*2)</font>
<font color="black"> 100.             # _compile_info(code, av[1], flags)</font>
<font color="green"> 101.             _compile(code, av[1], flags)</font>
<font color="green"> 102.             if av[0]:</font>
<font color="green"> 103.                 emit(OPCODES[MARK])</font>
<font color="green"> 104.                 emit((av[0]-1)*2+1)</font>
<font color="green"> 105.         elif op in SUCCESS_CODES:</font>
<font color="red"> 106.             emit(OPCODES[op])</font>
<font color="green"> 107.         elif op in ASSERT_CODES:</font>
<font color="green"> 108.             emit(OPCODES[op])</font>
<font color="green"> 109.             skip = _len(code); emit(0)</font>
<font color="green"> 110.             if av[0] &gt;= 0:</font>
<font color="green"> 111.                 emit(0) # look ahead</font>
<font color="black"> 112.             else:</font>
<font color="green"> 113.                 lo, hi = av[1].getwidth()</font>
<font color="green"> 114.                 if lo != hi:</font>
<font color="red"> 115.                     raise error, &quot;look-behind requires fixed-width pattern&quot;</font>
<font color="green"> 116.                 emit(lo) # look behind</font>
<font color="green"> 117.             _compile(code, av[1], flags)</font>
<font color="green"> 118.             emit(OPCODES[SUCCESS])</font>
<font color="green"> 119.             code[skip] = _len(code) - skip</font>
<font color="green"> 120.         elif op is CALL:</font>
<font color="red"> 121.             emit(OPCODES[op])</font>
<font color="red"> 122.             skip = _len(code); emit(0)</font>
<font color="red"> 123.             _compile(code, av, flags)</font>
<font color="red"> 124.             emit(OPCODES[SUCCESS])</font>
<font color="red"> 125.             code[skip] = _len(code) - skip</font>
<font color="green"> 126.         elif op is AT:</font>
<font color="green"> 127.             emit(OPCODES[op])</font>
<font color="green"> 128.             if flags &amp; SRE_FLAG_MULTILINE:</font>
<font color="green"> 129.                 av = AT_MULTILINE.get(av, av)</font>
<font color="green"> 130.             if flags &amp; SRE_FLAG_LOCALE:</font>
<font color="red"> 131.                 av = AT_LOCALE.get(av, av)</font>
<font color="green"> 132.             elif flags &amp; SRE_FLAG_UNICODE:</font>
<font color="green"> 133.                 av = AT_UNICODE.get(av, av)</font>
<font color="green"> 134.             emit(ATCODES[av])</font>
<font color="green"> 135.         elif op is BRANCH:</font>
<font color="green"> 136.             emit(OPCODES[op])</font>
<font color="green"> 137.             tail = []</font>
<font color="green"> 138.             tailappend = tail.append</font>
<font color="green"> 139.             for av in av[1]:</font>
<font color="green"> 140.                 skip = _len(code); emit(0)</font>
<font color="black"> 141.                 # _compile_info(code, av, flags)</font>
<font color="green"> 142.                 _compile(code, av, flags)</font>
<font color="green"> 143.                 emit(OPCODES[JUMP])</font>
<font color="green"> 144.                 tailappend(_len(code)); emit(0)</font>
<font color="green"> 145.                 code[skip] = _len(code) - skip</font>
<font color="green"> 146.             emit(0) # end of branch</font>
<font color="green"> 147.             for tail in tail:</font>
<font color="green"> 148.                 code[tail] = _len(code) - tail</font>
<font color="red"> 149.         elif op is CATEGORY:</font>
<font color="red"> 150.             emit(OPCODES[op])</font>
<font color="red"> 151.             if flags &amp; SRE_FLAG_LOCALE:</font>
<font color="red"> 152.                 av = CH_LOCALE[av]</font>
<font color="red"> 153.             elif flags &amp; SRE_FLAG_UNICODE:</font>
<font color="red"> 154.                 av = CH_UNICODE[av]</font>
<font color="red"> 155.             emit(CHCODES[av])</font>
<font color="red"> 156.         elif op is GROUPREF:</font>
<font color="red"> 157.             if flags &amp; SRE_FLAG_IGNORECASE:</font>
<font color="red"> 158.                 emit(OPCODES[OP_IGNORE[op]])</font>
<font color="black"> 159.             else:</font>
<font color="red"> 160.                 emit(OPCODES[op])</font>
<font color="red"> 161.             emit(av-1)</font>
<font color="red"> 162.         elif op is GROUPREF_EXISTS:</font>
<font color="red"> 163.             emit(OPCODES[op])</font>
<font color="red"> 164.             emit(av[0]-1)</font>
<font color="red"> 165.             skipyes = _len(code); emit(0)</font>
<font color="red"> 166.             _compile(code, av[1], flags)</font>
<font color="red"> 167.             if av[2]:</font>
<font color="red"> 168.                 emit(OPCODES[JUMP])</font>
<font color="red"> 169.                 skipno = _len(code); emit(0)</font>
<font color="red"> 170.                 code[skipyes] = _len(code) - skipyes + 1</font>
<font color="red"> 171.                 _compile(code, av[2], flags)</font>
<font color="red"> 172.                 code[skipno] = _len(code) - skipno</font>
<font color="black"> 173.             else:</font>
<font color="red"> 174.                 code[skipyes] = _len(code) - skipyes + 1</font>
<font color="black"> 175.         else:</font>
<font color="red"> 176.             raise ValueError, (&quot;unsupported operand type&quot;, op)</font>
<font color="black"> 177. </font>
<font color="red"> 178. def _compile_charset(charset, flags, code, fixup=None):</font>
<font color="black"> 179.     # compile charset subprogram</font>
<font color="green"> 180.     emit = code.append</font>
<font color="green"> 181.     if fixup is None:</font>
<font color="green"> 182.         fixup = _identityfunction</font>
<font color="green"> 183.     for op, av in _optimize_charset(charset, fixup):</font>
<font color="green"> 184.         emit(OPCODES[op])</font>
<font color="green"> 185.         if op is NEGATE:</font>
<font color="green"> 186.             pass</font>
<font color="green"> 187.         elif op is LITERAL:</font>
<font color="green"> 188.             emit(fixup(av))</font>
<font color="green"> 189.         elif op is RANGE:</font>
<font color="green"> 190.             emit(fixup(av[0]))</font>
<font color="green"> 191.             emit(fixup(av[1]))</font>
<font color="green"> 192.         elif op is CHARSET:</font>
<font color="green"> 193.             code.extend(av)</font>
<font color="green"> 194.         elif op is BIGCHARSET:</font>
<font color="red"> 195.             code.extend(av)</font>
<font color="green"> 196.         elif op is CATEGORY:</font>
<font color="green"> 197.             if flags &amp; SRE_FLAG_LOCALE:</font>
<font color="red"> 198.                 emit(CHCODES[CH_LOCALE[av]])</font>
<font color="green"> 199.             elif flags &amp; SRE_FLAG_UNICODE:</font>
<font color="green"> 200.                 emit(CHCODES[CH_UNICODE[av]])</font>
<font color="black"> 201.             else:</font>
<font color="green"> 202.                 emit(CHCODES[av])</font>
<font color="black"> 203.         else:</font>
<font color="red"> 204.             raise error, &quot;internal: unsupported set operator&quot;</font>
<font color="green"> 205.     emit(OPCODES[FAILURE])</font>
<font color="black"> 206. </font>
<font color="red"> 207. def _optimize_charset(charset, fixup):</font>
<font color="black"> 208.     # internal: optimize character set</font>
<font color="green"> 209.     out = []</font>
<font color="green"> 210.     outappend = out.append</font>
<font color="green"> 211.     charmap = [0]*256</font>
<font color="green"> 212.     try:</font>
<font color="green"> 213.         for op, av in charset:</font>
<font color="green"> 214.             if op is NEGATE:</font>
<font color="green"> 215.                 outappend((op, av))</font>
<font color="green"> 216.             elif op is LITERAL:</font>
<font color="green"> 217.                 charmap[fixup(av)] = 1</font>
<font color="green"> 218.             elif op is RANGE:</font>
<font color="green"> 219.                 for i in range(fixup(av[0]), fixup(av[1])+1):</font>
<font color="green"> 220.                     charmap[i] = 1</font>
<font color="green"> 221.             elif op is CATEGORY:</font>
<font color="black"> 222.                 # XXX: could append to charmap tail</font>
<font color="green"> 223.                 return charset # cannot compress</font>
<font color="red"> 224.     except IndexError:</font>
<font color="black"> 225.         # character set contains unicode characters</font>
<font color="red"> 226.         return _optimize_unicode(charset, fixup)</font>
<font color="black"> 227.     # compress character map</font>
<font color="green"> 228.     i = p = n = 0</font>
<font color="green"> 229.     runs = []</font>
<font color="green"> 230.     runsappend = runs.append</font>
<font color="green"> 231.     for c in charmap:</font>
<font color="green"> 232.         if c:</font>
<font color="green"> 233.             if n == 0:</font>
<font color="green"> 234.                 p = i</font>
<font color="green"> 235.             n = n + 1</font>
<font color="green"> 236.         elif n:</font>
<font color="green"> 237.             runsappend((p, n))</font>
<font color="green"> 238.             n = 0</font>
<font color="green"> 239.         i = i + 1</font>
<font color="green"> 240.     if n:</font>
<font color="green"> 241.         runsappend((p, n))</font>
<font color="green"> 242.     if len(runs) &lt;= 2:</font>
<font color="black"> 243.         # use literal/range</font>
<font color="green"> 244.         for p, n in runs:</font>
<font color="green"> 245.             if n == 1:</font>
<font color="green"> 246.                 outappend((LITERAL, p))</font>
<font color="black"> 247.             else:</font>
<font color="green"> 248.                 outappend((RANGE, (p, p+n-1)))</font>
<font color="green"> 249.         if len(out) &lt; len(charset):</font>
<font color="green"> 250.             return out</font>
<font color="black"> 251.     else:</font>
<font color="black"> 252.         # use bitmap</font>
<font color="green"> 253.         data = _mk_bitmap(charmap)</font>
<font color="green"> 254.         outappend((CHARSET, data))</font>
<font color="green"> 255.         return out</font>
<font color="green"> 256.     return charset</font>
<font color="black"> 257. </font>
<font color="red"> 258. def _mk_bitmap(bits):</font>
<font color="green"> 259.     data = []</font>
<font color="green"> 260.     dataappend = data.append</font>
<font color="green"> 261.     if _sre.CODESIZE == 2:</font>
<font color="red"> 262.         start = (1, 0)</font>
<font color="black"> 263.     else:</font>
<font color="green"> 264.         start = (1L, 0L)</font>
<font color="green"> 265.     m, v = start</font>
<font color="green"> 266.     for c in bits:</font>
<font color="green"> 267.         if c:</font>
<font color="green"> 268.             v = v + m</font>
<font color="green"> 269.         m = m + m</font>
<font color="green"> 270.         if m &gt; MAXCODE:</font>
<font color="green"> 271.             dataappend(v)</font>
<font color="green"> 272.             m, v = start</font>
<font color="green"> 273.     return data</font>
<font color="black"> 274. </font>
<font color="black"> 275. # To represent a big charset, first a bitmap of all characters in the</font>
<font color="black"> 276. # set is constructed. Then, this bitmap is sliced into chunks of 256</font>
<font color="black"> 277. # characters, duplicate chunks are eliminated, and each chunk is</font>
<font color="black"> 278. # given a number. In the compiled expression, the charset is</font>
<font color="black"> 279. # represented by a 32-bit word sequence, consisting of one word for</font>
<font color="black"> 280. # the number of different chunks, a sequence of 256 bytes (64 words)</font>
<font color="black"> 281. # of chunk numbers indexed by their original chunk position, and a</font>
<font color="black"> 282. # sequence of 256-bit chunks (8 words each).</font>
<font color="black"> 283. </font>
<font color="black"> 284. # Compression is normally good: in a typical charset, large ranges of</font>
<font color="black"> 285. # Unicode will be either completely excluded (e.g. if only cyrillic</font>
<font color="black"> 286. # letters are to be matched), or completely included (e.g. if large</font>
<font color="black"> 287. # subranges of Kanji match). These ranges will be represented by</font>
<font color="black"> 288. # chunks of all one-bits or all zero-bits.</font>
<font color="black"> 289. </font>
<font color="black"> 290. # Matching can be also done efficiently: the more significant byte of</font>
<font color="black"> 291. # the Unicode character is an index into the chunk number, and the</font>
<font color="black"> 292. # less significant byte is a bit index in the chunk (just like the</font>
<font color="black"> 293. # CHARSET matching).</font>
<font color="black"> 294. </font>
<font color="black"> 295. # In UCS-4 mode, the BIGCHARSET opcode still supports only subsets</font>
<font color="black"> 296. # of the basic multilingual plane; an efficient representation</font>
<font color="black"> 297. # for all of Unicode has not yet been developed. This means,</font>
<font color="black"> 298. # in particular, that negated charsets cannot be represented as</font>
<font color="black"> 299. # bigcharsets.</font>
<font color="black"> 300. </font>
<font color="red"> 301. def _optimize_unicode(charset, fixup):</font>
<font color="red"> 302.     try:</font>
<font color="red"> 303.         import array</font>
<font color="red"> 304.     except ImportError:</font>
<font color="red"> 305.         return charset</font>
<font color="red"> 306.     charmap = [0]*65536</font>
<font color="red"> 307.     negate = 0</font>
<font color="red"> 308.     try:</font>
<font color="red"> 309.         for op, av in charset:</font>
<font color="red"> 310.             if op is NEGATE:</font>
<font color="red"> 311.                 negate = 1</font>
<font color="red"> 312.             elif op is LITERAL:</font>
<font color="red"> 313.                 charmap[fixup(av)] = 1</font>
<font color="red"> 314.             elif op is RANGE:</font>
<font color="red"> 315.                 for i in xrange(fixup(av[0]), fixup(av[1])+1):</font>
<font color="red"> 316.                     charmap[i] = 1</font>
<font color="red"> 317.             elif op is CATEGORY:</font>
<font color="black"> 318.                 # XXX: could expand category</font>
<font color="red"> 319.                 return charset # cannot compress</font>
<font color="red"> 320.     except IndexError:</font>
<font color="black"> 321.         # non-BMP characters</font>
<font color="red"> 322.         return charset</font>
<font color="red"> 323.     if negate:</font>
<font color="red"> 324.         if sys.maxunicode != 65535:</font>
<font color="black"> 325.             # XXX: negation does not work with big charsets</font>
<font color="red"> 326.             return charset</font>
<font color="red"> 327.         for i in xrange(65536):</font>
<font color="red"> 328.             charmap[i] = not charmap[i]</font>
<font color="red"> 329.     comps = {}</font>
<font color="red"> 330.     mapping = [0]*256</font>
<font color="red"> 331.     block = 0</font>
<font color="red"> 332.     data = []</font>
<font color="red"> 333.     for i in xrange(256):</font>
<font color="red"> 334.         chunk = tuple(charmap[i*256:(i+1)*256])</font>
<font color="red"> 335.         new = comps.setdefault(chunk, block)</font>
<font color="red"> 336.         mapping[i] = new</font>
<font color="red"> 337.         if new == block:</font>
<font color="red"> 338.             block = block + 1</font>
<font color="red"> 339.             data = data + _mk_bitmap(chunk)</font>
<font color="red"> 340.     header = [block]</font>
<font color="red"> 341.     if _sre.CODESIZE == 2:</font>
<font color="red"> 342.         code = 'H'</font>
<font color="black"> 343.     else:</font>
<font color="red"> 344.         code = 'I'</font>
<font color="black"> 345.     # Convert block indices to byte array of 256 bytes</font>
<font color="red"> 346.     mapping = array.array('B', mapping).tostring()</font>
<font color="black"> 347.     # Convert byte array to word array</font>
<font color="red"> 348.     mapping = array.array(code, mapping)</font>
<font color="red"> 349.     assert mapping.itemsize == _sre.CODESIZE</font>
<font color="red"> 350.     header = header + mapping.tolist()</font>
<font color="red"> 351.     data[0:0] = header</font>
<font color="red"> 352.     return [(BIGCHARSET, data)]</font>
<font color="black"> 353. </font>
<font color="red"> 354. def _simple(av):</font>
<font color="black"> 355.     # check if av is a &quot;simple&quot; operator</font>
<font color="green"> 356.     lo, hi = av[2].getwidth()</font>
<font color="green"> 357.     return lo == hi == 1 and av[2][0][0] != SUBPATTERN</font>
<font color="black"> 358. </font>
<font color="red"> 359. def _compile_info(code, pattern, flags):</font>
<font color="black"> 360.     # internal: compile an info block.  in the current version,</font>
<font color="black"> 361.     # this contains min/max pattern width, and an optional literal</font>
<font color="black"> 362.     # prefix or a character map</font>
<font color="green"> 363.     lo, hi = pattern.getwidth()</font>
<font color="green"> 364.     if lo == 0:</font>
<font color="green"> 365.         return # not worth it</font>
<font color="black"> 366.     # look for a literal prefix</font>
<font color="green"> 367.     prefix = []</font>
<font color="green"> 368.     prefixappend = prefix.append</font>
<font color="green"> 369.     prefix_skip = 0</font>
<font color="green"> 370.     charset = [] # not used</font>
<font color="green"> 371.     charsetappend = charset.append</font>
<font color="green"> 372.     if not (flags &amp; SRE_FLAG_IGNORECASE):</font>
<font color="black"> 373.         # look for literal prefix</font>
<font color="green"> 374.         for op, av in pattern.data:</font>
<font color="green"> 375.             if op is LITERAL:</font>
<font color="green"> 376.                 if len(prefix) == prefix_skip:</font>
<font color="green"> 377.                     prefix_skip = prefix_skip + 1</font>
<font color="green"> 378.                 prefixappend(av)</font>
<font color="green"> 379.             elif op is SUBPATTERN and len(av[1]) == 1:</font>
<font color="green"> 380.                 op, av = av[1][0]</font>
<font color="green"> 381.                 if op is LITERAL:</font>
<font color="red"> 382.                     prefixappend(av)</font>
<font color="black"> 383.                 else:</font>
<font color="green"> 384.                     break</font>
<font color="black"> 385.             else:</font>
<font color="green"> 386.                 break</font>
<font color="black"> 387.         # if no prefix, look for charset prefix</font>
<font color="green"> 388.         if not prefix and pattern.data:</font>
<font color="green"> 389.             op, av = pattern.data[0]</font>
<font color="green"> 390.             if op is SUBPATTERN and av[1]:</font>
<font color="green"> 391.                 op, av = av[1][0]</font>
<font color="green"> 392.                 if op is LITERAL:</font>
<font color="green"> 393.                     charsetappend((op, av))</font>
<font color="green"> 394.                 elif op is BRANCH:</font>
<font color="green"> 395.                     c = []</font>
<font color="green"> 396.                     cappend = c.append</font>
<font color="green"> 397.                     for p in av[1]:</font>
<font color="green"> 398.                         if not p:</font>
<font color="red"> 399.                             break</font>
<font color="green"> 400.                         op, av = p[0]</font>
<font color="green"> 401.                         if op is LITERAL:</font>
<font color="green"> 402.                             cappend((op, av))</font>
<font color="black"> 403.                         else:</font>
<font color="green"> 404.                             break</font>
<font color="black"> 405.                     else:</font>
<font color="green"> 406.                         charset = c</font>
<font color="green"> 407.             elif op is BRANCH:</font>
<font color="green"> 408.                 c = []</font>
<font color="green"> 409.                 cappend = c.append</font>
<font color="green"> 410.                 for p in av[1]:</font>
<font color="green"> 411.                     if not p:</font>
<font color="red"> 412.                         break</font>
<font color="green"> 413.                     op, av = p[0]</font>
<font color="green"> 414.                     if op is LITERAL:</font>
<font color="green"> 415.                         cappend((op, av))</font>
<font color="black"> 416.                     else:</font>
<font color="green"> 417.                         break</font>
<font color="black"> 418.                 else:</font>
<font color="green"> 419.                     charset = c</font>
<font color="green"> 420.             elif op is IN:</font>
<font color="green"> 421.                 charset = av</font>
<font color="black"> 422. ##     if prefix:</font>
<font color="black"> 423. ##         print &quot;*** PREFIX&quot;, prefix, prefix_skip</font>
<font color="black"> 424. ##     if charset:</font>
<font color="black"> 425. ##         print &quot;*** CHARSET&quot;, charset</font>
<font color="black"> 426.     # add an info block</font>
<font color="green"> 427.     emit = code.append</font>
<font color="green"> 428.     emit(OPCODES[INFO])</font>
<font color="green"> 429.     skip = len(code); emit(0)</font>
<font color="black"> 430.     # literal flag</font>
<font color="green"> 431.     mask = 0</font>
<font color="green"> 432.     if prefix:</font>
<font color="green"> 433.         mask = SRE_INFO_PREFIX</font>
<font color="green"> 434.         if len(prefix) == prefix_skip == len(pattern.data):</font>
<font color="green"> 435.             mask = mask + SRE_INFO_LITERAL</font>
<font color="green"> 436.     elif charset:</font>
<font color="green"> 437.         mask = mask + SRE_INFO_CHARSET</font>
<font color="green"> 438.     emit(mask)</font>
<font color="black"> 439.     # pattern length</font>
<font color="green"> 440.     if lo &lt; MAXCODE:</font>
<font color="green"> 441.         emit(lo)</font>
<font color="black"> 442.     else:</font>
<font color="red"> 443.         emit(MAXCODE)</font>
<font color="red"> 444.         prefix = prefix[:MAXCODE]</font>
<font color="green"> 445.     if hi &lt; MAXCODE:</font>
<font color="green"> 446.         emit(hi)</font>
<font color="black"> 447.     else:</font>
<font color="green"> 448.         emit(0)</font>
<font color="black"> 449.     # add literal prefix</font>
<font color="green"> 450.     if prefix:</font>
<font color="green"> 451.         emit(len(prefix)) # length</font>
<font color="green"> 452.         emit(prefix_skip) # skip</font>
<font color="green"> 453.         code.extend(prefix)</font>
<font color="black"> 454.         # generate overlap table</font>
<font color="green"> 455.         table = [-1] + ([0]*len(prefix))</font>
<font color="green"> 456.         for i in xrange(len(prefix)):</font>
<font color="green"> 457.             table[i+1] = table[i]+1</font>
<font color="green"> 458.             while table[i+1] &gt; 0 and prefix[i] != prefix[table[i+1]-1]:</font>
<font color="green"> 459.                 table[i+1] = table[table[i+1]-1]+1</font>
<font color="green"> 460.         code.extend(table[1:]) # don't store first entry</font>
<font color="green"> 461.     elif charset:</font>
<font color="green"> 462.         _compile_charset(charset, flags, code)</font>
<font color="green"> 463.     code[skip] = len(code) - skip</font>
<font color="black"> 464. </font>
<font color="red"> 465. try:</font>
<font color="red"> 466.     unicode</font>
<font color="red"> 467. except NameError:</font>
<font color="red"> 468.     STRING_TYPES = (type(&quot;&quot;),)</font>
<font color="black"> 469. else:</font>
<font color="red"> 470.     STRING_TYPES = (type(&quot;&quot;), type(unicode(&quot;&quot;)))</font>
<font color="black"> 471. </font>
<font color="red"> 472. def isstring(obj):</font>
<font color="green"> 473.     for tp in STRING_TYPES:</font>
<font color="green"> 474.         if isinstance(obj, tp):</font>
<font color="green"> 475.             return 1</font>
<font color="red"> 476.     return 0</font>
<font color="black"> 477. </font>
<font color="red"> 478. def _code(p, flags):</font>
<font color="black"> 479. </font>
<font color="green"> 480.     flags = p.pattern.flags | flags</font>
<font color="green"> 481.     code = []</font>
<font color="black"> 482. </font>
<font color="black"> 483.     # compile info block</font>
<font color="green"> 484.     _compile_info(code, p, flags)</font>
<font color="black"> 485. </font>
<font color="black"> 486.     # compile the pattern</font>
<font color="green"> 487.     _compile(code, p.data, flags)</font>
<font color="black"> 488. </font>
<font color="green"> 489.     code.append(OPCODES[SUCCESS])</font>
<font color="black"> 490. </font>
<font color="green"> 491.     return code</font>
<font color="black"> 492. </font>
<font color="red"> 493. def compile(p, flags=0):</font>
<font color="black"> 494.     # internal: convert pattern list to internal format</font>
<font color="black"> 495. </font>
<font color="green"> 496.     if isstring(p):</font>
<font color="green"> 497.         pattern = p</font>
<font color="green"> 498.         p = sre_parse.parse(p, flags)</font>
<font color="black"> 499.     else:</font>
<font color="red"> 500.         pattern = None</font>
<font color="black"> 501. </font>
<font color="green"> 502.     code = _code(p, flags)</font>
<font color="black"> 503. </font>
<font color="black"> 504.     # print code</font>
<font color="black"> 505. </font>
<font color="black"> 506.     # XXX: &lt;fl&gt; get rid of this limitation!</font>
<font color="green"> 507.     if p.pattern.groups &gt; 100:</font>
<font color="red"> 508.         raise AssertionError(</font>
<font color="red"> 509.             &quot;sorry, but this version only supports 100 named groups&quot;</font>
<font color="black"> 510.             )</font>
<font color="black"> 511. </font>
<font color="black"> 512.     # map in either direction</font>
<font color="green"> 513.     groupindex = p.pattern.groupdict</font>
<font color="green"> 514.     indexgroup = [None] * p.pattern.groups</font>
<font color="green"> 515.     for k, i in groupindex.items():</font>
<font color="green"> 516.         indexgroup[i] = k</font>
<font color="black"> 517. </font>
<font color="green"> 518.     return _sre.compile(</font>
<font color="green"> 519.         pattern, flags | p.pattern.flags, code,</font>
<font color="green"> 520.         p.pattern.groups-1,</font>
<font color="green"> 521.         groupindex, indexgroup</font>
<font color="black"> 522.         )</font>
</pre>

