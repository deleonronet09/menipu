source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/test/testcases.py</b><br>


file stats: <b>841 lines, 236 executed: 28.1% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import difflib</font>
<font color="green">   4. import errno</font>
<font color="green">   5. import json</font>
<font color="green">   6. import os</font>
<font color="green">   7. import posixpath</font>
<font color="green">   8. import socket</font>
<font color="green">   9. import sys</font>
<font color="green">  10. import threading</font>
<font color="green">  11. import unittest</font>
<font color="green">  12. import warnings</font>
<font color="green">  13. from collections import Counter</font>
<font color="green">  14. from contextlib import contextmanager</font>
<font color="green">  15. from copy import copy</font>
<font color="green">  16. from functools import wraps</font>
<font color="green">  17. from unittest.util import safe_repr</font>
<font color="black">  18. </font>
<font color="green">  19. from django.apps import apps</font>
<font color="green">  20. from django.conf import settings</font>
<font color="green">  21. from django.core import mail</font>
<font color="green">  22. from django.core.exceptions import ImproperlyConfigured, ValidationError</font>
<font color="green">  23. from django.core.files import locks</font>
<font color="green">  24. from django.core.handlers.wsgi import WSGIHandler, get_path_info</font>
<font color="green">  25. from django.core.management import call_command</font>
<font color="green">  26. from django.core.management.color import no_style</font>
<font color="green">  27. from django.core.management.sql import emit_post_migrate_signal</font>
<font color="green">  28. from django.core.servers.basehttp import WSGIRequestHandler, WSGIServer</font>
<font color="green">  29. from django.core.urlresolvers import clear_url_caches, set_urlconf</font>
<font color="green">  30. from django.db import DEFAULT_DB_ALIAS, connection, connections, transaction</font>
<font color="green">  31. from django.forms.fields import CharField</font>
<font color="green">  32. from django.http import QueryDict</font>
<font color="green">  33. from django.test.client import Client</font>
<font color="green">  34. from django.test.html import HTMLParseError, parse_html</font>
<font color="green">  35. from django.test.signals import setting_changed, template_rendered</font>
<font color="green">  36. from django.test.utils import (</font>
<font color="black">  37.     CaptureQueriesContext, ContextList, compare_xml, modify_settings,</font>
<font color="black">  38.     override_settings,</font>
<font color="black">  39. )</font>
<font color="green">  40. from django.utils import six</font>
<font color="green">  41. from django.utils.decorators import classproperty</font>
<font color="green">  42. from django.utils.deprecation import (</font>
<font color="black">  43.     RemovedInDjango20Warning, RemovedInDjango110Warning,</font>
<font color="black">  44. )</font>
<font color="green">  45. from django.utils.encoding import force_text</font>
<font color="green">  46. from django.utils.six.moves.urllib.parse import (</font>
<font color="black">  47.     unquote, urlparse, urlsplit, urlunsplit,</font>
<font color="black">  48. )</font>
<font color="green">  49. from django.utils.six.moves.urllib.request import url2pathname</font>
<font color="green">  50. from django.views.static import serve</font>
<font color="black">  51. </font>
<font color="green">  52. __all__ = ('TestCase', 'TransactionTestCase',</font>
<font color="green">  53.            'SimpleTestCase', 'skipIfDBFeature', 'skipUnlessDBFeature')</font>
<font color="black">  54. </font>
<font color="black">  55. </font>
<font color="green">  56. def to_list(value):</font>
<font color="black">  57.     &quot;&quot;&quot;</font>
<font color="black">  58.     Puts value into a list if it's not already one.</font>
<font color="black">  59.     Returns an empty list if value is None.</font>
<font color="black">  60.     &quot;&quot;&quot;</font>
<font color="red">  61.     if value is None:</font>
<font color="red">  62.         value = []</font>
<font color="red">  63.     elif not isinstance(value, list):</font>
<font color="red">  64.         value = [value]</font>
<font color="red">  65.     return value</font>
<font color="black">  66. </font>
<font color="black">  67. </font>
<font color="green">  68. def assert_and_parse_html(self, html, user_msg, msg):</font>
<font color="red">  69.     try:</font>
<font color="red">  70.         dom = parse_html(html)</font>
<font color="red">  71.     except HTMLParseError as e:</font>
<font color="red">  72.         standardMsg = '%s\n%s' % (msg, e.msg)</font>
<font color="red">  73.         self.fail(self._formatMessage(user_msg, standardMsg))</font>
<font color="red">  74.     return dom</font>
<font color="black">  75. </font>
<font color="black">  76. </font>
<font color="green">  77. class _AssertNumQueriesContext(CaptureQueriesContext):</font>
<font color="green">  78.     def __init__(self, test_case, num, connection):</font>
<font color="red">  79.         self.test_case = test_case</font>
<font color="red">  80.         self.num = num</font>
<font color="red">  81.         super(_AssertNumQueriesContext, self).__init__(connection)</font>
<font color="black">  82. </font>
<font color="green">  83.     def __exit__(self, exc_type, exc_value, traceback):</font>
<font color="red">  84.         super(_AssertNumQueriesContext, self).__exit__(exc_type, exc_value, traceback)</font>
<font color="red">  85.         if exc_type is not None:</font>
<font color="red">  86.             return</font>
<font color="red">  87.         executed = len(self)</font>
<font color="red">  88.         self.test_case.assertEqual(</font>
<font color="red">  89.             executed, self.num,</font>
<font color="red">  90.             &quot;%d queries executed, %d expected\nCaptured queries were:\n%s&quot; % (</font>
<font color="red">  91.                 executed, self.num,</font>
<font color="red">  92.                 '\n'.join(</font>
<font color="red">  93.                     query['sql'] for query in self.captured_queries</font>
<font color="black">  94.                 )</font>
<font color="black">  95.             )</font>
<font color="black">  96.         )</font>
<font color="black">  97. </font>
<font color="black">  98. </font>
<font color="green">  99. class _AssertTemplateUsedContext(object):</font>
<font color="green"> 100.     def __init__(self, test_case, template_name):</font>
<font color="red"> 101.         self.test_case = test_case</font>
<font color="red"> 102.         self.template_name = template_name</font>
<font color="red"> 103.         self.rendered_templates = []</font>
<font color="red"> 104.         self.rendered_template_names = []</font>
<font color="red"> 105.         self.context = ContextList()</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def on_template_render(self, sender, signal, template, context, **kwargs):</font>
<font color="red"> 108.         self.rendered_templates.append(template)</font>
<font color="red"> 109.         self.rendered_template_names.append(template.name)</font>
<font color="red"> 110.         self.context.append(copy(context))</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def test(self):</font>
<font color="red"> 113.         return self.template_name in self.rendered_template_names</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def message(self):</font>
<font color="red"> 116.         return '%s was not rendered.' % self.template_name</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def __enter__(self):</font>
<font color="red"> 119.         template_rendered.connect(self.on_template_render)</font>
<font color="red"> 120.         return self</font>
<font color="black"> 121. </font>
<font color="green"> 122.     def __exit__(self, exc_type, exc_value, traceback):</font>
<font color="red"> 123.         template_rendered.disconnect(self.on_template_render)</font>
<font color="red"> 124.         if exc_type is not None:</font>
<font color="red"> 125.             return</font>
<font color="black"> 126. </font>
<font color="red"> 127.         if not self.test():</font>
<font color="red"> 128.             message = self.message()</font>
<font color="red"> 129.             if len(self.rendered_templates) == 0:</font>
<font color="red"> 130.                 message += ' No template was rendered.'</font>
<font color="black"> 131.             else:</font>
<font color="red"> 132.                 message += ' Following templates were rendered: %s' % (</font>
<font color="red"> 133.                     ', '.join(self.rendered_template_names))</font>
<font color="red"> 134.             self.test_case.fail(message)</font>
<font color="black"> 135. </font>
<font color="black"> 136. </font>
<font color="green"> 137. class _AssertTemplateNotUsedContext(_AssertTemplateUsedContext):</font>
<font color="green"> 138.     def test(self):</font>
<font color="red"> 139.         return self.template_name not in self.rendered_template_names</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def message(self):</font>
<font color="red"> 142.         return '%s was rendered.' % self.template_name</font>
<font color="black"> 143. </font>
<font color="black"> 144. </font>
<font color="green"> 145. class _CursorFailure(object):</font>
<font color="green"> 146.     def __init__(self, cls_name, wrapped):</font>
<font color="red"> 147.         self.cls_name = cls_name</font>
<font color="red"> 148.         self.wrapped = wrapped</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def __call__(self):</font>
<font color="red"> 151.         raise AssertionError(</font>
<font color="red"> 152.             &quot;Database queries aren't allowed in SimpleTestCase. &quot;</font>
<font color="black"> 153.             &quot;Either use TestCase or TransactionTestCase to ensure proper test isolation or &quot;</font>
<font color="red"> 154.             &quot;set %s.allow_database_queries to True to silence this failure.&quot; % self.cls_name</font>
<font color="black"> 155.         )</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="green"> 158. class SimpleTestCase(unittest.TestCase):</font>
<font color="black"> 159. </font>
<font color="black"> 160.     # The class we'll use for the test client self.client.</font>
<font color="black"> 161.     # Can be overridden in derived classes.</font>
<font color="green"> 162.     client_class = Client</font>
<font color="green"> 163.     _overridden_settings = None</font>
<font color="green"> 164.     _modified_settings = None</font>
<font color="black"> 165. </font>
<font color="black"> 166.     # Tests shouldn't be allowed to query the database since</font>
<font color="black"> 167.     # this base class doesn't enforce any isolation.</font>
<font color="green"> 168.     allow_database_queries = False</font>
<font color="black"> 169. </font>
<font color="green"> 170.     @classmethod</font>
<font color="black"> 171.     def setUpClass(cls):</font>
<font color="green"> 172.         super(SimpleTestCase, cls).setUpClass()</font>
<font color="green"> 173.         if cls._overridden_settings:</font>
<font color="red"> 174.             cls._cls_overridden_context = override_settings(**cls._overridden_settings)</font>
<font color="red"> 175.             cls._cls_overridden_context.enable()</font>
<font color="green"> 176.         if cls._modified_settings:</font>
<font color="red"> 177.             cls._cls_modified_context = modify_settings(cls._modified_settings)</font>
<font color="red"> 178.             cls._cls_modified_context.enable()</font>
<font color="green"> 179.         if not cls.allow_database_queries:</font>
<font color="red"> 180.             for alias in connections:</font>
<font color="red"> 181.                 connection = connections[alias]</font>
<font color="red"> 182.                 connection.cursor = _CursorFailure(cls.__name__, connection.cursor)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     @classmethod</font>
<font color="black"> 185.     def tearDownClass(cls):</font>
<font color="green"> 186.         if not cls.allow_database_queries:</font>
<font color="red"> 187.             for alias in connections:</font>
<font color="red"> 188.                 connection = connections[alias]</font>
<font color="red"> 189.                 connection.cursor = connection.cursor.wrapped</font>
<font color="green"> 190.         if hasattr(cls, '_cls_modified_context'):</font>
<font color="red"> 191.             cls._cls_modified_context.disable()</font>
<font color="red"> 192.             delattr(cls, '_cls_modified_context')</font>
<font color="green"> 193.         if hasattr(cls, '_cls_overridden_context'):</font>
<font color="red"> 194.             cls._cls_overridden_context.disable()</font>
<font color="red"> 195.             delattr(cls, '_cls_overridden_context')</font>
<font color="green"> 196.         super(SimpleTestCase, cls).tearDownClass()</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def __call__(self, result=None):</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="black"> 200.         Wrapper around default __call__ method to perform common Django test</font>
<font color="black"> 201.         set up. This means that user-defined Test Cases aren't required to</font>
<font color="black"> 202.         include a call to super().setUp().</font>
<font color="black"> 203.         &quot;&quot;&quot;</font>
<font color="green"> 204.         testMethod = getattr(self, self._testMethodName)</font>
<font color="green"> 205.         skipped = (getattr(self.__class__, &quot;__unittest_skip__&quot;, False) or</font>
<font color="green"> 206.             getattr(testMethod, &quot;__unittest_skip__&quot;, False))</font>
<font color="black"> 207. </font>
<font color="green"> 208.         if not skipped:</font>
<font color="green"> 209.             try:</font>
<font color="green"> 210.                 self._pre_setup()</font>
<font color="red"> 211.             except Exception:</font>
<font color="red"> 212.                 result.addError(self, sys.exc_info())</font>
<font color="red"> 213.                 return</font>
<font color="green"> 214.         super(SimpleTestCase, self).__call__(result)</font>
<font color="green"> 215.         if not skipped:</font>
<font color="green"> 216.             try:</font>
<font color="green"> 217.                 self._post_teardown()</font>
<font color="red"> 218.             except Exception:</font>
<font color="red"> 219.                 result.addError(self, sys.exc_info())</font>
<font color="red"> 220.                 return</font>
<font color="black"> 221. </font>
<font color="green"> 222.     def _pre_setup(self):</font>
<font color="black"> 223.         &quot;&quot;&quot;Performs any pre-test setup. This includes:</font>
<font color="black"> 224. </font>
<font color="black"> 225.         * Creating a test client.</font>
<font color="black"> 226.         * If the class has a 'urls' attribute, replace ROOT_URLCONF with it.</font>
<font color="black"> 227.         * Clearing the mail test outbox.</font>
<font color="black"> 228.         &quot;&quot;&quot;</font>
<font color="green"> 229.         self.client = self.client_class()</font>
<font color="green"> 230.         self._urlconf_setup()</font>
<font color="green"> 231.         mail.outbox = []</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def _urlconf_setup(self):</font>
<font color="green"> 234.         if hasattr(self, 'urls'):</font>
<font color="red"> 235.             warnings.warn(</font>
<font color="red"> 236.                 &quot;SimpleTestCase.urls is deprecated and will be removed in &quot;</font>
<font color="black"> 237.                 &quot;Django 1.10. Use @override_settings(ROOT_URLCONF=...) &quot;</font>
<font color="red"> 238.                 &quot;in %s instead.&quot; % self.__class__.__name__,</font>
<font color="red"> 239.                 RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 240.             set_urlconf(None)</font>
<font color="red"> 241.             self._old_root_urlconf = settings.ROOT_URLCONF</font>
<font color="red"> 242.             settings.ROOT_URLCONF = self.urls</font>
<font color="red"> 243.             clear_url_caches()</font>
<font color="black"> 244. </font>
<font color="green"> 245.     def _post_teardown(self):</font>
<font color="black"> 246.         &quot;&quot;&quot;Performs any post-test things. This includes:</font>
<font color="black"> 247. </font>
<font color="black"> 248.         * Putting back the original ROOT_URLCONF if it was changed.</font>
<font color="black"> 249.         &quot;&quot;&quot;</font>
<font color="green"> 250.         self._urlconf_teardown()</font>
<font color="black"> 251. </font>
<font color="green"> 252.     def _urlconf_teardown(self):</font>
<font color="green"> 253.         if hasattr(self, '_old_root_urlconf'):</font>
<font color="red"> 254.             set_urlconf(None)</font>
<font color="red"> 255.             settings.ROOT_URLCONF = self._old_root_urlconf</font>
<font color="red"> 256.             clear_url_caches()</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def settings(self, **kwargs):</font>
<font color="black"> 259.         &quot;&quot;&quot;</font>
<font color="black"> 260.         A context manager that temporarily sets a setting and reverts to the original value when exiting the context.</font>
<font color="black"> 261.         &quot;&quot;&quot;</font>
<font color="red"> 262.         return override_settings(**kwargs)</font>
<font color="black"> 263. </font>
<font color="green"> 264.     def modify_settings(self, **kwargs):</font>
<font color="black"> 265.         &quot;&quot;&quot;</font>
<font color="black"> 266.         A context manager that temporarily applies changes a list setting and</font>
<font color="black"> 267.         reverts back to the original value when exiting the context.</font>
<font color="black"> 268.         &quot;&quot;&quot;</font>
<font color="red"> 269.         return modify_settings(**kwargs)</font>
<font color="black"> 270. </font>
<font color="green"> 271.     def assertRedirects(self, response, expected_url, status_code=302,</font>
<font color="green"> 272.                         target_status_code=200, host=None, msg_prefix='',</font>
<font color="green"> 273.                         fetch_redirect_response=True):</font>
<font color="black"> 274.         &quot;&quot;&quot;Asserts that a response redirected to a specific URL, and that the</font>
<font color="black"> 275.         redirect URL can be loaded.</font>
<font color="black"> 276. </font>
<font color="black"> 277.         Note that assertRedirects won't work for external links since it uses</font>
<font color="black"> 278.         TestClient to do a request (use fetch_redirect_response=False to check</font>
<font color="black"> 279.         such links without fetching them).</font>
<font color="black"> 280.         &quot;&quot;&quot;</font>
<font color="red"> 281.         if host is not None:</font>
<font color="red"> 282.             warnings.warn(</font>
<font color="red"> 283.                 &quot;The host argument is deprecated and no longer used by assertRedirects&quot;,</font>
<font color="red"> 284.                 RemovedInDjango20Warning, stacklevel=2</font>
<font color="black"> 285.             )</font>
<font color="black"> 286. </font>
<font color="red"> 287.         if msg_prefix:</font>
<font color="red"> 288.             msg_prefix += &quot;: &quot;</font>
<font color="black"> 289. </font>
<font color="red"> 290.         if hasattr(response, 'redirect_chain'):</font>
<font color="black"> 291.             # The request was a followed redirect</font>
<font color="red"> 292.             self.assertTrue(len(response.redirect_chain) &gt; 0,</font>
<font color="red"> 293.                 msg_prefix + &quot;Response didn't redirect as expected: Response&quot;</font>
<font color="black"> 294.                 &quot; code was %d (expected %d)&quot; %</font>
<font color="red"> 295.                     (response.status_code, status_code))</font>
<font color="black"> 296. </font>
<font color="red"> 297.             self.assertEqual(response.redirect_chain[0][1], status_code,</font>
<font color="red"> 298.                 msg_prefix + &quot;Initial response didn't redirect as expected:&quot;</font>
<font color="black"> 299.                 &quot; Response code was %d (expected %d)&quot; %</font>
<font color="red"> 300.                     (response.redirect_chain[0][1], status_code))</font>
<font color="black"> 301. </font>
<font color="red"> 302.             url, status_code = response.redirect_chain[-1]</font>
<font color="red"> 303.             scheme, netloc, path, query, fragment = urlsplit(url)</font>
<font color="black"> 304. </font>
<font color="red"> 305.             self.assertEqual(response.status_code, target_status_code,</font>
<font color="red"> 306.                 msg_prefix + &quot;Response didn't redirect as expected: Final&quot;</font>
<font color="black"> 307.                 &quot; Response code was %d (expected %d)&quot; %</font>
<font color="red"> 308.                     (response.status_code, target_status_code))</font>
<font color="black"> 309. </font>
<font color="black"> 310.         else:</font>
<font color="black"> 311.             # Not a followed redirect</font>
<font color="red"> 312.             self.assertEqual(response.status_code, status_code,</font>
<font color="red"> 313.                 msg_prefix + &quot;Response didn't redirect as expected: Response&quot;</font>
<font color="black"> 314.                 &quot; code was %d (expected %d)&quot; %</font>
<font color="red"> 315.                     (response.status_code, status_code))</font>
<font color="black"> 316. </font>
<font color="red"> 317.             url = response.url</font>
<font color="red"> 318.             scheme, netloc, path, query, fragment = urlsplit(url)</font>
<font color="black"> 319. </font>
<font color="red"> 320.             if fetch_redirect_response:</font>
<font color="red"> 321.                 redirect_response = response.client.get(path, QueryDict(query),</font>
<font color="red"> 322.                                                         secure=(scheme == 'https'))</font>
<font color="black"> 323. </font>
<font color="black"> 324.                 # Get the redirection page, using the same client that was used</font>
<font color="black"> 325.                 # to obtain the original response.</font>
<font color="red"> 326.                 self.assertEqual(redirect_response.status_code, target_status_code,</font>
<font color="red"> 327.                     msg_prefix + &quot;Couldn't retrieve redirection page '%s':&quot;</font>
<font color="black"> 328.                     &quot; response code was %d (expected %d)&quot; %</font>
<font color="red"> 329.                         (path, redirect_response.status_code, target_status_code))</font>
<font color="black"> 330. </font>
<font color="red"> 331.         if url != expected_url:</font>
<font color="black"> 332.             # For temporary backwards compatibility, try to compare with a relative url</font>
<font color="red"> 333.             e_scheme, e_netloc, e_path, e_query, e_fragment = urlsplit(expected_url)</font>
<font color="red"> 334.             relative_url = urlunsplit(('', '', e_path, e_query, e_fragment))</font>
<font color="red"> 335.             if url == relative_url:</font>
<font color="red"> 336.                 warnings.warn(</font>
<font color="red"> 337.                     &quot;assertRedirects had to strip the scheme and domain from the &quot;</font>
<font color="black"> 338.                     &quot;expected URL, as it was always added automatically to URLs &quot;</font>
<font color="black"> 339.                     &quot;before Django 1.9. Please update your expected URLs by &quot;</font>
<font color="black"> 340.                     &quot;removing the scheme and domain.&quot;,</font>
<font color="red"> 341.                     RemovedInDjango20Warning, stacklevel=2)</font>
<font color="red"> 342.                 expected_url = relative_url</font>
<font color="black"> 343. </font>
<font color="red"> 344.         self.assertEqual(url, expected_url,</font>
<font color="red"> 345.             msg_prefix + &quot;Response redirected to '%s', expected '%s'&quot; %</font>
<font color="red"> 346.                 (url, expected_url))</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def _assert_contains(self, response, text, status_code, msg_prefix, html):</font>
<font color="black"> 349.         # If the response supports deferred rendering and hasn't been rendered</font>
<font color="black"> 350.         # yet, then ensure that it does get rendered before proceeding further.</font>
<font color="red"> 351.         if (hasattr(response, 'render') and callable(response.render)</font>
<font color="red"> 352.                 and not response.is_rendered):</font>
<font color="red"> 353.             response.render()</font>
<font color="black"> 354. </font>
<font color="red"> 355.         if msg_prefix:</font>
<font color="red"> 356.             msg_prefix += &quot;: &quot;</font>
<font color="black"> 357. </font>
<font color="red"> 358.         self.assertEqual(response.status_code, status_code,</font>
<font color="red"> 359.             msg_prefix + &quot;Couldn't retrieve content: Response code was %d&quot;</font>
<font color="red"> 360.             &quot; (expected %d)&quot; % (response.status_code, status_code))</font>
<font color="black"> 361. </font>
<font color="red"> 362.         if response.streaming:</font>
<font color="red"> 363.             content = b''.join(response.streaming_content)</font>
<font color="black"> 364.         else:</font>
<font color="red"> 365.             content = response.content</font>
<font color="red"> 366.         if not isinstance(text, bytes) or html:</font>
<font color="red"> 367.             text = force_text(text, encoding=response.charset)</font>
<font color="red"> 368.             content = content.decode(response.charset)</font>
<font color="red"> 369.             text_repr = &quot;'%s'&quot; % text</font>
<font color="black"> 370.         else:</font>
<font color="red"> 371.             text_repr = repr(text)</font>
<font color="red"> 372.         if html:</font>
<font color="red"> 373.             content = assert_and_parse_html(self, content, None,</font>
<font color="red"> 374.                 &quot;Response's content is not valid HTML:&quot;)</font>
<font color="red"> 375.             text = assert_and_parse_html(self, text, None,</font>
<font color="red"> 376.                 &quot;Second argument is not valid HTML:&quot;)</font>
<font color="red"> 377.         real_count = content.count(text)</font>
<font color="red"> 378.         return (text_repr, real_count, msg_prefix)</font>
<font color="black"> 379. </font>
<font color="green"> 380.     def assertContains(self, response, text, count=None, status_code=200,</font>
<font color="green"> 381.                        msg_prefix='', html=False):</font>
<font color="black"> 382.         &quot;&quot;&quot;</font>
<font color="black"> 383.         Asserts that a response indicates that some content was retrieved</font>
<font color="black"> 384.         successfully, (i.e., the HTTP status code was as expected), and that</font>
<font color="black"> 385.         ``text`` occurs ``count`` times in the content of the response.</font>
<font color="black"> 386.         If ``count`` is None, the count doesn't matter - the assertion is true</font>
<font color="black"> 387.         if the text occurs at least once in the response.</font>
<font color="black"> 388.         &quot;&quot;&quot;</font>
<font color="red"> 389.         text_repr, real_count, msg_prefix = self._assert_contains(</font>
<font color="red"> 390.             response, text, status_code, msg_prefix, html)</font>
<font color="black"> 391. </font>
<font color="red"> 392.         if count is not None:</font>
<font color="red"> 393.             self.assertEqual(real_count, count,</font>
<font color="red"> 394.                 msg_prefix + &quot;Found %d instances of %s in response&quot;</font>
<font color="red"> 395.                 &quot; (expected %d)&quot; % (real_count, text_repr, count))</font>
<font color="black"> 396.         else:</font>
<font color="red"> 397.             self.assertTrue(real_count != 0,</font>
<font color="red"> 398.                 msg_prefix + &quot;Couldn't find %s in response&quot; % text_repr)</font>
<font color="black"> 399. </font>
<font color="green"> 400.     def assertNotContains(self, response, text, status_code=200,</font>
<font color="green"> 401.                           msg_prefix='', html=False):</font>
<font color="black"> 402.         &quot;&quot;&quot;</font>
<font color="black"> 403.         Asserts that a response indicates that some content was retrieved</font>
<font color="black"> 404.         successfully, (i.e., the HTTP status code was as expected), and that</font>
<font color="black"> 405.         ``text`` doesn't occurs in the content of the response.</font>
<font color="black"> 406.         &quot;&quot;&quot;</font>
<font color="red"> 407.         text_repr, real_count, msg_prefix = self._assert_contains(</font>
<font color="red"> 408.             response, text, status_code, msg_prefix, html)</font>
<font color="black"> 409. </font>
<font color="red"> 410.         self.assertEqual(real_count, 0,</font>
<font color="red"> 411.                 msg_prefix + &quot;Response should not contain %s&quot; % text_repr)</font>
<font color="black"> 412. </font>
<font color="green"> 413.     def assertFormError(self, response, form, field, errors, msg_prefix=''):</font>
<font color="black"> 414.         &quot;&quot;&quot;</font>
<font color="black"> 415.         Asserts that a form used to render the response has a specific field</font>
<font color="black"> 416.         error.</font>
<font color="black"> 417.         &quot;&quot;&quot;</font>
<font color="red"> 418.         if msg_prefix:</font>
<font color="red"> 419.             msg_prefix += &quot;: &quot;</font>
<font color="black"> 420. </font>
<font color="black"> 421.         # Put context(s) into a list to simplify processing.</font>
<font color="red"> 422.         contexts = to_list(response.context)</font>
<font color="red"> 423.         if not contexts:</font>
<font color="red"> 424.             self.fail(msg_prefix + &quot;Response did not use any contexts to &quot;</font>
<font color="black"> 425.                       &quot;render the response&quot;)</font>
<font color="black"> 426. </font>
<font color="black"> 427.         # Put error(s) into a list to simplify processing.</font>
<font color="red"> 428.         errors = to_list(errors)</font>
<font color="black"> 429. </font>
<font color="black"> 430.         # Search all contexts for the error.</font>
<font color="red"> 431.         found_form = False</font>
<font color="red"> 432.         for i, context in enumerate(contexts):</font>
<font color="red"> 433.             if form not in context:</font>
<font color="red"> 434.                 continue</font>
<font color="red"> 435.             found_form = True</font>
<font color="red"> 436.             for err in errors:</font>
<font color="red"> 437.                 if field:</font>
<font color="red"> 438.                     if field in context[form].errors:</font>
<font color="red"> 439.                         field_errors = context[form].errors[field]</font>
<font color="red"> 440.                         self.assertTrue(err in field_errors,</font>
<font color="red"> 441.                             msg_prefix + &quot;The field '%s' on form '%s' in&quot;</font>
<font color="black"> 442.                             &quot; context %d does not contain the error '%s'&quot;</font>
<font color="black"> 443.                             &quot; (actual errors: %s)&quot; %</font>
<font color="red"> 444.                             (field, form, i, err, repr(field_errors)))</font>
<font color="red"> 445.                     elif field in context[form].fields:</font>
<font color="red"> 446.                         self.fail(msg_prefix + &quot;The field '%s' on form '%s'&quot;</font>
<font color="black"> 447.                                   &quot; in context %d contains no errors&quot; %</font>
<font color="red"> 448.                                   (field, form, i))</font>
<font color="black"> 449.                     else:</font>
<font color="red"> 450.                         self.fail(msg_prefix + &quot;The form '%s' in context %d&quot;</font>
<font color="black"> 451.                                   &quot; does not contain the field '%s'&quot; %</font>
<font color="red"> 452.                                   (form, i, field))</font>
<font color="black"> 453.                 else:</font>
<font color="red"> 454.                     non_field_errors = context[form].non_field_errors()</font>
<font color="red"> 455.                     self.assertTrue(err in non_field_errors,</font>
<font color="red"> 456.                         msg_prefix + &quot;The form '%s' in context %d does not&quot;</font>
<font color="black"> 457.                         &quot; contain the non-field error '%s'&quot;</font>
<font color="black"> 458.                         &quot; (actual errors: %s)&quot; %</font>
<font color="red"> 459.                             (form, i, err, non_field_errors))</font>
<font color="red"> 460.         if not found_form:</font>
<font color="red"> 461.             self.fail(msg_prefix + &quot;The form '%s' was not used to render the&quot;</font>
<font color="red"> 462.                       &quot; response&quot; % form)</font>
<font color="black"> 463. </font>
<font color="black"> 464.     def assertFormsetError(self, response, formset, form_index, field, errors,</font>
<font color="green"> 465.                            msg_prefix=''):</font>
<font color="black"> 466.         &quot;&quot;&quot;</font>
<font color="black"> 467.         Asserts that a formset used to render the response has a specific error.</font>
<font color="black"> 468. </font>
<font color="black"> 469.         For field errors, specify the ``form_index`` and the ``field``.</font>
<font color="black"> 470.         For non-field errors, specify the ``form_index`` and the ``field`` as</font>
<font color="black"> 471.         None.</font>
<font color="black"> 472.         For non-form errors, specify ``form_index`` as None and the ``field``</font>
<font color="black"> 473.         as None.</font>
<font color="black"> 474.         &quot;&quot;&quot;</font>
<font color="black"> 475.         # Add punctuation to msg_prefix</font>
<font color="red"> 476.         if msg_prefix:</font>
<font color="red"> 477.             msg_prefix += &quot;: &quot;</font>
<font color="black"> 478. </font>
<font color="black"> 479.         # Put context(s) into a list to simplify processing.</font>
<font color="red"> 480.         contexts = to_list(response.context)</font>
<font color="red"> 481.         if not contexts:</font>
<font color="red"> 482.             self.fail(msg_prefix + 'Response did not use any contexts to '</font>
<font color="black"> 483.                       'render the response')</font>
<font color="black"> 484. </font>
<font color="black"> 485.         # Put error(s) into a list to simplify processing.</font>
<font color="red"> 486.         errors = to_list(errors)</font>
<font color="black"> 487. </font>
<font color="black"> 488.         # Search all contexts for the error.</font>
<font color="red"> 489.         found_formset = False</font>
<font color="red"> 490.         for i, context in enumerate(contexts):</font>
<font color="red"> 491.             if formset not in context:</font>
<font color="red"> 492.                 continue</font>
<font color="red"> 493.             found_formset = True</font>
<font color="red"> 494.             for err in errors:</font>
<font color="red"> 495.                 if field is not None:</font>
<font color="red"> 496.                     if field in context[formset].forms[form_index].errors:</font>
<font color="red"> 497.                         field_errors = context[formset].forms[form_index].errors[field]</font>
<font color="red"> 498.                         self.assertTrue(err in field_errors,</font>
<font color="red"> 499.                                 msg_prefix + &quot;The field '%s' on formset '%s', &quot;</font>
<font color="black"> 500.                                 &quot;form %d in context %d does not contain the &quot;</font>
<font color="black"> 501.                                 &quot;error '%s' (actual errors: %s)&quot; %</font>
<font color="red"> 502.                                 (field, formset, form_index, i, err,</font>
<font color="red"> 503.                                  repr(field_errors)))</font>
<font color="red"> 504.                     elif field in context[formset].forms[form_index].fields:</font>
<font color="red"> 505.                         self.fail(msg_prefix + &quot;The field '%s' &quot;</font>
<font color="black"> 506.                                   &quot;on formset '%s', form %d in &quot;</font>
<font color="black"> 507.                                   &quot;context %d contains no errors&quot; %</font>
<font color="red"> 508.                                   (field, formset, form_index, i))</font>
<font color="black"> 509.                     else:</font>
<font color="red"> 510.                         self.fail(msg_prefix + &quot;The formset '%s', form %d in &quot;</font>
<font color="black"> 511.                                   &quot;context %d does not contain the field '%s'&quot; %</font>
<font color="red"> 512.                                   (formset, form_index, i, field))</font>
<font color="red"> 513.                 elif form_index is not None:</font>
<font color="red"> 514.                     non_field_errors = context[formset].forms[form_index].non_field_errors()</font>
<font color="red"> 515.                     self.assertFalse(len(non_field_errors) == 0,</font>
<font color="red"> 516.                                      msg_prefix + &quot;The formset '%s', form %d in &quot;</font>
<font color="black"> 517.                                      &quot;context %d does not contain any non-field &quot;</font>
<font color="red"> 518.                                      &quot;errors.&quot; % (formset, form_index, i))</font>
<font color="red"> 519.                     self.assertTrue(err in non_field_errors,</font>
<font color="red"> 520.                                     msg_prefix + &quot;The formset '%s', form %d &quot;</font>
<font color="black"> 521.                                     &quot;in context %d does not contain the &quot;</font>
<font color="black"> 522.                                     &quot;non-field error '%s' &quot;</font>
<font color="black"> 523.                                     &quot;(actual errors: %s)&quot; %</font>
<font color="red"> 524.                                     (formset, form_index, i, err,</font>
<font color="red"> 525.                                      repr(non_field_errors)))</font>
<font color="black"> 526.                 else:</font>
<font color="red"> 527.                     non_form_errors = context[formset].non_form_errors()</font>
<font color="red"> 528.                     self.assertFalse(len(non_form_errors) == 0,</font>
<font color="red"> 529.                                      msg_prefix + &quot;The formset '%s' in &quot;</font>
<font color="black"> 530.                                      &quot;context %d does not contain any &quot;</font>
<font color="red"> 531.                                      &quot;non-form errors.&quot; % (formset, i))</font>
<font color="red"> 532.                     self.assertTrue(err in non_form_errors,</font>
<font color="red"> 533.                                     msg_prefix + &quot;The formset '%s' in context &quot;</font>
<font color="black"> 534.                                     &quot;%d does not contain the &quot;</font>
<font color="black"> 535.                                     &quot;non-form error '%s' (actual errors: %s)&quot; %</font>
<font color="red"> 536.                                     (formset, i, err, repr(non_form_errors)))</font>
<font color="red"> 537.         if not found_formset:</font>
<font color="red"> 538.             self.fail(msg_prefix + &quot;The formset '%s' was not used to render &quot;</font>
<font color="red"> 539.                       &quot;the response&quot; % formset)</font>
<font color="black"> 540. </font>
<font color="green"> 541.     def _assert_template_used(self, response, template_name, msg_prefix):</font>
<font color="black"> 542. </font>
<font color="red"> 543.         if response is None and template_name is None:</font>
<font color="red"> 544.             raise TypeError('response and/or template_name argument must be provided')</font>
<font color="black"> 545. </font>
<font color="red"> 546.         if msg_prefix:</font>
<font color="red"> 547.             msg_prefix += &quot;: &quot;</font>
<font color="black"> 548. </font>
<font color="red"> 549.         if template_name is not None and response is not None and not hasattr(response, 'templates'):</font>
<font color="red"> 550.             raise ValueError(</font>
<font color="red"> 551.                 &quot;assertTemplateUsed() and assertTemplateNotUsed() are only &quot;</font>
<font color="black"> 552.                 &quot;usable on responses fetched using the Django test Client.&quot;</font>
<font color="black"> 553.             )</font>
<font color="black"> 554. </font>
<font color="red"> 555.         if not hasattr(response, 'templates') or (response is None and template_name):</font>
<font color="red"> 556.             if response:</font>
<font color="red"> 557.                 template_name = response</font>
<font color="red"> 558.                 response = None</font>
<font color="black"> 559.             # use this template with context manager</font>
<font color="red"> 560.             return template_name, None, msg_prefix</font>
<font color="black"> 561. </font>
<font color="red"> 562.         template_names = [t.name for t in response.templates if t.name is not</font>
<font color="red"> 563.                           None]</font>
<font color="red"> 564.         return None, template_names, msg_prefix</font>
<font color="black"> 565. </font>
<font color="green"> 566.     def assertTemplateUsed(self, response=None, template_name=None, msg_prefix='', count=None):</font>
<font color="black"> 567.         &quot;&quot;&quot;</font>
<font color="black"> 568.         Asserts that the template with the provided name was used in rendering</font>
<font color="black"> 569.         the response. Also usable as context manager.</font>
<font color="black"> 570.         &quot;&quot;&quot;</font>
<font color="red"> 571.         context_mgr_template, template_names, msg_prefix = self._assert_template_used(</font>
<font color="red"> 572.             response, template_name, msg_prefix)</font>
<font color="black"> 573. </font>
<font color="red"> 574.         if context_mgr_template:</font>
<font color="black"> 575.             # Use assertTemplateUsed as context manager.</font>
<font color="red"> 576.             return _AssertTemplateUsedContext(self, context_mgr_template)</font>
<font color="black"> 577. </font>
<font color="red"> 578.         if not template_names:</font>
<font color="red"> 579.             self.fail(msg_prefix + &quot;No templates used to render the response&quot;)</font>
<font color="red"> 580.         self.assertTrue(template_name in template_names,</font>
<font color="red"> 581.             msg_prefix + &quot;Template '%s' was not a template used to render&quot;</font>
<font color="black"> 582.             &quot; the response. Actual template(s) used: %s&quot; %</font>
<font color="red"> 583.                 (template_name, ', '.join(template_names)))</font>
<font color="black"> 584. </font>
<font color="red"> 585.         if count is not None:</font>
<font color="red"> 586.             self.assertEqual(template_names.count(template_name), count,</font>
<font color="red"> 587.                 msg_prefix + &quot;Template '%s' was expected to be rendered %d &quot;</font>
<font color="black"> 588.                 &quot;time(s) but was actually rendered %d time(s).&quot; %</font>
<font color="red"> 589.                     (template_name, count, template_names.count(template_name)))</font>
<font color="black"> 590. </font>
<font color="green"> 591.     def assertTemplateNotUsed(self, response=None, template_name=None, msg_prefix=''):</font>
<font color="black"> 592.         &quot;&quot;&quot;</font>
<font color="black"> 593.         Asserts that the template with the provided name was NOT used in</font>
<font color="black"> 594.         rendering the response. Also usable as context manager.</font>
<font color="black"> 595.         &quot;&quot;&quot;</font>
<font color="black"> 596. </font>
<font color="red"> 597.         context_mgr_template, template_names, msg_prefix = self._assert_template_used(</font>
<font color="red"> 598.             response, template_name, msg_prefix)</font>
<font color="black"> 599. </font>
<font color="red"> 600.         if context_mgr_template:</font>
<font color="black"> 601.             # Use assertTemplateNotUsed as context manager.</font>
<font color="red"> 602.             return _AssertTemplateNotUsedContext(self, context_mgr_template)</font>
<font color="black"> 603. </font>
<font color="red"> 604.         self.assertFalse(template_name in template_names,</font>
<font color="red"> 605.             msg_prefix + &quot;Template '%s' was used unexpectedly in rendering&quot;</font>
<font color="red"> 606.             &quot; the response&quot; % template_name)</font>
<font color="black"> 607. </font>
<font color="green"> 608.     @contextmanager</font>
<font color="black"> 609.     def _assert_raises_message_cm(self, expected_exception, expected_message):</font>
<font color="red"> 610.         with self.assertRaises(expected_exception) as cm:</font>
<font color="red"> 611.             yield cm</font>
<font color="red"> 612.         self.assertIn(expected_message, str(cm.exception))</font>
<font color="black"> 613. </font>
<font color="green"> 614.     def assertRaisesMessage(self, expected_exception, expected_message, *args, **kwargs):</font>
<font color="black"> 615.         &quot;&quot;&quot;</font>
<font color="black"> 616.         Asserts that expected_message is found in the the message of a raised</font>
<font color="black"> 617.         exception.</font>
<font color="black"> 618. </font>
<font color="black"> 619.         Args:</font>
<font color="black"> 620.             expected_exception: Exception class expected to be raised.</font>
<font color="black"> 621.             expected_message: expected error message string value.</font>
<font color="black"> 622.             args: Function to be called and extra positional args.</font>
<font color="black"> 623.             kwargs: Extra kwargs.</font>
<font color="black"> 624.         &quot;&quot;&quot;</font>
<font color="black"> 625.         # callable_obj was a documented kwarg in Django 1.8 and older.</font>
<font color="red"> 626.         callable_obj = kwargs.pop('callable_obj', None)</font>
<font color="red"> 627.         if callable_obj:</font>
<font color="red"> 628.             warnings.warn(</font>
<font color="red"> 629.                 'The callable_obj kwarg is deprecated. Pass the callable '</font>
<font color="red"> 630.                 'as a positional argument instead.', RemovedInDjango20Warning</font>
<font color="black"> 631.             )</font>
<font color="red"> 632.         elif len(args):</font>
<font color="red"> 633.             callable_obj = args[0]</font>
<font color="red"> 634.             args = args[1:]</font>
<font color="black"> 635. </font>
<font color="red"> 636.         cm = self._assert_raises_message_cm(expected_exception, expected_message)</font>
<font color="black"> 637.         # Assertion used in context manager fashion.</font>
<font color="red"> 638.         if callable_obj is None:</font>
<font color="red"> 639.             return cm</font>
<font color="black"> 640.         # Assertion was passed a callable.</font>
<font color="red"> 641.         with cm:</font>
<font color="red"> 642.             callable_obj(*args, **kwargs)</font>
<font color="black"> 643. </font>
<font color="green"> 644.     def assertFieldOutput(self, fieldclass, valid, invalid, field_args=None,</font>
<font color="green"> 645.             field_kwargs=None, empty_value=''):</font>
<font color="black"> 646.         &quot;&quot;&quot;</font>
<font color="black"> 647.         Asserts that a form field behaves correctly with various inputs.</font>
<font color="black"> 648. </font>
<font color="black"> 649.         Args:</font>
<font color="black"> 650.             fieldclass: the class of the field to be tested.</font>
<font color="black"> 651.             valid: a dictionary mapping valid inputs to their expected</font>
<font color="black"> 652.                     cleaned values.</font>
<font color="black"> 653.             invalid: a dictionary mapping invalid inputs to one or more</font>
<font color="black"> 654.                     raised error messages.</font>
<font color="black"> 655.             field_args: the args passed to instantiate the field</font>
<font color="black"> 656.             field_kwargs: the kwargs passed to instantiate the field</font>
<font color="black"> 657.             empty_value: the expected clean output for inputs in empty_values</font>
<font color="black"> 658.         &quot;&quot;&quot;</font>
<font color="red"> 659.         if field_args is None:</font>
<font color="red"> 660.             field_args = []</font>
<font color="red"> 661.         if field_kwargs is None:</font>
<font color="red"> 662.             field_kwargs = {}</font>
<font color="red"> 663.         required = fieldclass(*field_args, **field_kwargs)</font>
<font color="red"> 664.         optional = fieldclass(*field_args,</font>
<font color="red"> 665.                               **dict(field_kwargs, required=False))</font>
<font color="black"> 666.         # test valid inputs</font>
<font color="red"> 667.         for input, output in valid.items():</font>
<font color="red"> 668.             self.assertEqual(required.clean(input), output)</font>
<font color="red"> 669.             self.assertEqual(optional.clean(input), output)</font>
<font color="black"> 670.         # test invalid inputs</font>
<font color="red"> 671.         for input, errors in invalid.items():</font>
<font color="red"> 672.             with self.assertRaises(ValidationError) as context_manager:</font>
<font color="red"> 673.                 required.clean(input)</font>
<font color="red"> 674.             self.assertEqual(context_manager.exception.messages, errors)</font>
<font color="black"> 675. </font>
<font color="red"> 676.             with self.assertRaises(ValidationError) as context_manager:</font>
<font color="red"> 677.                 optional.clean(input)</font>
<font color="red"> 678.             self.assertEqual(context_manager.exception.messages, errors)</font>
<font color="black"> 679.         # test required inputs</font>
<font color="red"> 680.         error_required = [force_text(required.error_messages['required'])]</font>
<font color="red"> 681.         for e in required.empty_values:</font>
<font color="red"> 682.             with self.assertRaises(ValidationError) as context_manager:</font>
<font color="red"> 683.                 required.clean(e)</font>
<font color="red"> 684.             self.assertEqual(context_manager.exception.messages,</font>
<font color="red"> 685.                              error_required)</font>
<font color="red"> 686.             self.assertEqual(optional.clean(e), empty_value)</font>
<font color="black"> 687.         # test that max_length and min_length are always accepted</font>
<font color="red"> 688.         if issubclass(fieldclass, CharField):</font>
<font color="red"> 689.             field_kwargs.update({'min_length': 2, 'max_length': 20})</font>
<font color="red"> 690.             self.assertIsInstance(fieldclass(*field_args, **field_kwargs),</font>
<font color="red"> 691.                                   fieldclass)</font>
<font color="black"> 692. </font>
<font color="green"> 693.     def assertHTMLEqual(self, html1, html2, msg=None):</font>
<font color="black"> 694.         &quot;&quot;&quot;</font>
<font color="black"> 695.         Asserts that two HTML snippets are semantically the same.</font>
<font color="black"> 696.         Whitespace in most cases is ignored, and attribute ordering is not</font>
<font color="black"> 697.         significant. The passed-in arguments must be valid HTML.</font>
<font color="black"> 698.         &quot;&quot;&quot;</font>
<font color="red"> 699.         dom1 = assert_and_parse_html(self, html1, msg,</font>
<font color="red"> 700.             'First argument is not valid HTML:')</font>
<font color="red"> 701.         dom2 = assert_and_parse_html(self, html2, msg,</font>
<font color="red"> 702.             'Second argument is not valid HTML:')</font>
<font color="black"> 703. </font>
<font color="red"> 704.         if dom1 != dom2:</font>
<font color="red"> 705.             standardMsg = '%s != %s' % (</font>
<font color="red"> 706.                 safe_repr(dom1, True), safe_repr(dom2, True))</font>
<font color="red"> 707.             diff = ('\n' + '\n'.join(difflib.ndiff(</font>
<font color="red"> 708.                            six.text_type(dom1).splitlines(),</font>
<font color="red"> 709.                            six.text_type(dom2).splitlines())))</font>
<font color="red"> 710.             standardMsg = self._truncateMessage(standardMsg, diff)</font>
<font color="red"> 711.             self.fail(self._formatMessage(msg, standardMsg))</font>
<font color="black"> 712. </font>
<font color="green"> 713.     def assertHTMLNotEqual(self, html1, html2, msg=None):</font>
<font color="black"> 714.         &quot;&quot;&quot;Asserts that two HTML snippets are not semantically equivalent.&quot;&quot;&quot;</font>
<font color="red"> 715.         dom1 = assert_and_parse_html(self, html1, msg,</font>
<font color="red"> 716.             'First argument is not valid HTML:')</font>
<font color="red"> 717.         dom2 = assert_and_parse_html(self, html2, msg,</font>
<font color="red"> 718.             'Second argument is not valid HTML:')</font>
<font color="black"> 719. </font>
<font color="red"> 720.         if dom1 == dom2:</font>
<font color="red"> 721.             standardMsg = '%s == %s' % (</font>
<font color="red"> 722.                 safe_repr(dom1, True), safe_repr(dom2, True))</font>
<font color="red"> 723.             self.fail(self._formatMessage(msg, standardMsg))</font>
<font color="black"> 724. </font>
<font color="green"> 725.     def assertInHTML(self, needle, haystack, count=None, msg_prefix=''):</font>
<font color="red"> 726.         needle = assert_and_parse_html(self, needle, None,</font>
<font color="red"> 727.             'First argument is not valid HTML:')</font>
<font color="red"> 728.         haystack = assert_and_parse_html(self, haystack, None,</font>
<font color="red"> 729.             'Second argument is not valid HTML:')</font>
<font color="red"> 730.         real_count = haystack.count(needle)</font>
<font color="red"> 731.         if count is not None:</font>
<font color="red"> 732.             self.assertEqual(real_count, count,</font>
<font color="red"> 733.                 msg_prefix + &quot;Found %d instances of '%s' in response&quot;</font>
<font color="red"> 734.                 &quot; (expected %d)&quot; % (real_count, needle, count))</font>
<font color="black"> 735.         else:</font>
<font color="red"> 736.             self.assertTrue(real_count != 0,</font>
<font color="red"> 737.                 msg_prefix + &quot;Couldn't find '%s' in response&quot; % needle)</font>
<font color="black"> 738. </font>
<font color="green"> 739.     def assertJSONEqual(self, raw, expected_data, msg=None):</font>
<font color="black"> 740.         &quot;&quot;&quot;</font>
<font color="black"> 741.         Asserts that the JSON fragments raw and expected_data are equal.</font>
<font color="black"> 742.         Usual JSON non-significant whitespace rules apply as the heavyweight</font>
<font color="black"> 743.         is delegated to the json library.</font>
<font color="black"> 744.         &quot;&quot;&quot;</font>
<font color="red"> 745.         try:</font>
<font color="red"> 746.             data = json.loads(raw)</font>
<font color="red"> 747.         except ValueError:</font>
<font color="red"> 748.             self.fail(&quot;First argument is not valid JSON: %r&quot; % raw)</font>
<font color="red"> 749.         if isinstance(expected_data, six.string_types):</font>
<font color="red"> 750.             try:</font>
<font color="red"> 751.                 expected_data = json.loads(expected_data)</font>
<font color="red"> 752.             except ValueError:</font>
<font color="red"> 753.                 self.fail(&quot;Second argument is not valid JSON: %r&quot; % expected_data)</font>
<font color="red"> 754.         self.assertEqual(data, expected_data, msg=msg)</font>
<font color="black"> 755. </font>
<font color="green"> 756.     def assertJSONNotEqual(self, raw, expected_data, msg=None):</font>
<font color="black"> 757.         &quot;&quot;&quot;</font>
<font color="black"> 758.         Asserts that the JSON fragments raw and expected_data are not equal.</font>
<font color="black"> 759.         Usual JSON non-significant whitespace rules apply as the heavyweight</font>
<font color="black"> 760.         is delegated to the json library.</font>
<font color="black"> 761.         &quot;&quot;&quot;</font>
<font color="red"> 762.         try:</font>
<font color="red"> 763.             data = json.loads(raw)</font>
<font color="red"> 764.         except ValueError:</font>
<font color="red"> 765.             self.fail(&quot;First argument is not valid JSON: %r&quot; % raw)</font>
<font color="red"> 766.         if isinstance(expected_data, six.string_types):</font>
<font color="red"> 767.             try:</font>
<font color="red"> 768.                 expected_data = json.loads(expected_data)</font>
<font color="red"> 769.             except ValueError:</font>
<font color="red"> 770.                 self.fail(&quot;Second argument is not valid JSON: %r&quot; % expected_data)</font>
<font color="red"> 771.         self.assertNotEqual(data, expected_data, msg=msg)</font>
<font color="black"> 772. </font>
<font color="green"> 773.     def assertXMLEqual(self, xml1, xml2, msg=None):</font>
<font color="black"> 774.         &quot;&quot;&quot;</font>
<font color="black"> 775.         Asserts that two XML snippets are semantically the same.</font>
<font color="black"> 776.         Whitespace in most cases is ignored, and attribute ordering is not</font>
<font color="black"> 777.         significant. The passed-in arguments must be valid XML.</font>
<font color="black"> 778.         &quot;&quot;&quot;</font>
<font color="red"> 779.         try:</font>
<font color="red"> 780.             result = compare_xml(xml1, xml2)</font>
<font color="red"> 781.         except Exception as e:</font>
<font color="red"> 782.             standardMsg = 'First or second argument is not valid XML\n%s' % e</font>
<font color="red"> 783.             self.fail(self._formatMessage(msg, standardMsg))</font>
<font color="black"> 784.         else:</font>
<font color="red"> 785.             if not result:</font>
<font color="red"> 786.                 standardMsg = '%s != %s' % (safe_repr(xml1, True), safe_repr(xml2, True))</font>
<font color="red"> 787.                 diff = ('\n' + '\n'.join(</font>
<font color="red"> 788.                     difflib.ndiff(</font>
<font color="red"> 789.                         six.text_type(xml1).splitlines(),</font>
<font color="red"> 790.                         six.text_type(xml2).splitlines(),</font>
<font color="black"> 791.                     )</font>
<font color="black"> 792.                 ))</font>
<font color="red"> 793.                 standardMsg = self._truncateMessage(standardMsg, diff)</font>
<font color="red"> 794.                 self.fail(self._formatMessage(msg, standardMsg))</font>
<font color="black"> 795. </font>
<font color="green"> 796.     def assertXMLNotEqual(self, xml1, xml2, msg=None):</font>
<font color="black"> 797.         &quot;&quot;&quot;</font>
<font color="black"> 798.         Asserts that two XML snippets are not semantically equivalent.</font>
<font color="black"> 799.         Whitespace in most cases is ignored, and attribute ordering is not</font>
<font color="black"> 800.         significant. The passed-in arguments must be valid XML.</font>
<font color="black"> 801.         &quot;&quot;&quot;</font>
<font color="red"> 802.         try:</font>
<font color="red"> 803.             result = compare_xml(xml1, xml2)</font>
<font color="red"> 804.         except Exception as e:</font>
<font color="red"> 805.             standardMsg = 'First or second argument is not valid XML\n%s' % e</font>
<font color="red"> 806.             self.fail(self._formatMessage(msg, standardMsg))</font>
<font color="black"> 807.         else:</font>
<font color="red"> 808.             if result:</font>
<font color="red"> 809.                 standardMsg = '%s == %s' % (safe_repr(xml1, True), safe_repr(xml2, True))</font>
<font color="red"> 810.                 self.fail(self._formatMessage(msg, standardMsg))</font>
<font color="black"> 811. </font>
<font color="black"> 812. </font>
<font color="green"> 813. class TransactionTestCase(SimpleTestCase):</font>
<font color="black"> 814. </font>
<font color="black"> 815.     # Subclasses can ask for resetting of auto increment sequence before each</font>
<font color="black"> 816.     # test case</font>
<font color="green"> 817.     reset_sequences = False</font>
<font color="black"> 818. </font>
<font color="black"> 819.     # Subclasses can enable only a subset of apps for faster tests</font>
<font color="green"> 820.     available_apps = None</font>
<font color="black"> 821. </font>
<font color="black"> 822.     # Subclasses can define fixtures which will be automatically installed.</font>
<font color="green"> 823.     fixtures = None</font>
<font color="black"> 824. </font>
<font color="black"> 825.     # If transactions aren't available, Django will serialize the database</font>
<font color="black"> 826.     # contents into a fixture during setup and flush and reload them</font>
<font color="black"> 827.     # during teardown (as flush does not restore data from migrations).</font>
<font color="black"> 828.     # This can be slow; this flag allows enabling on a per-case basis.</font>
<font color="green"> 829.     serialized_rollback = False</font>
<font color="black"> 830. </font>
<font color="black"> 831.     # Since tests will be wrapped in a transaction, or serialized if they</font>
<font color="black"> 832.     # are not available, we allow queries to be run.</font>
<font color="green"> 833.     allow_database_queries = True</font>
<font color="black"> 834. </font>
<font color="green"> 835.     def _pre_setup(self):</font>
<font color="black"> 836.         &quot;&quot;&quot;Performs any pre-test setup. This includes:</font>
<font color="black"> 837. </font>
<font color="black"> 838.         * If the class has an 'available_apps' attribute, restricting the app</font>
<font color="black"> 839.           registry to these applications, then firing post_migrate -- it must</font>
<font color="black"> 840.           run with the correct set of applications for the test case.</font>
<font color="black"> 841.         * If the class has a 'fixtures' attribute, installing these fixtures.</font>
<font color="black"> 842.         &quot;&quot;&quot;</font>
<font color="green"> 843.         super(TransactionTestCase, self)._pre_setup()</font>
<font color="green"> 844.         if self.available_apps is not None:</font>
<font color="red"> 845.             apps.set_available_apps(self.available_apps)</font>
<font color="red"> 846.             setting_changed.send(sender=settings._wrapped.__class__,</font>
<font color="red"> 847.                                  setting='INSTALLED_APPS',</font>
<font color="red"> 848.                                  value=self.available_apps,</font>
<font color="red"> 849.                                  enter=True)</font>
<font color="red"> 850.             for db_name in self._databases_names(include_mirrors=False):</font>
<font color="red"> 851.                 emit_post_migrate_signal(verbosity=0, interactive=False, db=db_name)</font>
<font color="green"> 852.         try:</font>
<font color="green"> 853.             self._fixture_setup()</font>
<font color="red"> 854.         except Exception:</font>
<font color="red"> 855.             if self.available_apps is not None:</font>
<font color="red"> 856.                 apps.unset_available_apps()</font>
<font color="red"> 857.                 setting_changed.send(sender=settings._wrapped.__class__,</font>
<font color="red"> 858.                                      setting='INSTALLED_APPS',</font>
<font color="red"> 859.                                      value=settings.INSTALLED_APPS,</font>
<font color="red"> 860.                                      enter=False)</font>
<font color="black"> 861. </font>
<font color="red"> 862.             raise</font>
<font color="black"> 863. </font>
<font color="green"> 864.     @classmethod</font>
<font color="green"> 865.     def _databases_names(cls, include_mirrors=True):</font>
<font color="black"> 866.         # If the test case has a multi_db=True flag, act on all databases,</font>
<font color="black"> 867.         # including mirrors or not. Otherwise, just on the default DB.</font>
<font color="green"> 868.         if getattr(cls, 'multi_db', False):</font>
<font color="red"> 869.             return [alias for alias in connections</font>
<font color="red"> 870.                     if include_mirrors or not connections[alias].settings_dict['TEST']['MIRROR']]</font>
<font color="black"> 871.         else:</font>
<font color="green"> 872.             return [DEFAULT_DB_ALIAS]</font>
<font color="black"> 873. </font>
<font color="green"> 874.     def _reset_sequences(self, db_name):</font>
<font color="red"> 875.         conn = connections[db_name]</font>
<font color="red"> 876.         if conn.features.supports_sequence_reset:</font>
<font color="red"> 877.             sql_list = conn.ops.sequence_reset_by_name_sql(</font>
<font color="red"> 878.                 no_style(), conn.introspection.sequence_list())</font>
<font color="red"> 879.             if sql_list:</font>
<font color="red"> 880.                 with transaction.atomic(using=db_name):</font>
<font color="red"> 881.                     cursor = conn.cursor()</font>
<font color="red"> 882.                     for sql in sql_list:</font>
<font color="red"> 883.                         cursor.execute(sql)</font>
<font color="black"> 884. </font>
<font color="green"> 885.     def _fixture_setup(self):</font>
<font color="red"> 886.         for db_name in self._databases_names(include_mirrors=False):</font>
<font color="black"> 887.             # Reset sequences</font>
<font color="red"> 888.             if self.reset_sequences:</font>
<font color="red"> 889.                 self._reset_sequences(db_name)</font>
<font color="black"> 890. </font>
<font color="black"> 891.             # If we need to provide replica initial data from migrated apps,</font>
<font color="black"> 892.             # then do so.</font>
<font color="red"> 893.             if self.serialized_rollback and hasattr(connections[db_name], &quot;_test_serialized_contents&quot;):</font>
<font color="red"> 894.                 if self.available_apps is not None:</font>
<font color="red"> 895.                     apps.unset_available_apps()</font>
<font color="red"> 896.                 connections[db_name].creation.deserialize_db_from_string(</font>
<font color="red"> 897.                     connections[db_name]._test_serialized_contents</font>
<font color="black"> 898.                 )</font>
<font color="red"> 899.                 if self.available_apps is not None:</font>
<font color="red"> 900.                     apps.set_available_apps(self.available_apps)</font>
<font color="black"> 901. </font>
<font color="red"> 902.             if self.fixtures:</font>
<font color="black"> 903.                 # We have to use this slightly awkward syntax due to the fact</font>
<font color="black"> 904.                 # that we're using *args and **kwargs together.</font>
<font color="red"> 905.                 call_command('loaddata', *self.fixtures,</font>
<font color="red"> 906.                              **{'verbosity': 0, 'database': db_name})</font>
<font color="black"> 907. </font>
<font color="green"> 908.     def _should_reload_connections(self):</font>
<font color="red"> 909.         return True</font>
<font color="black"> 910. </font>
<font color="green"> 911.     def _post_teardown(self):</font>
<font color="black"> 912.         &quot;&quot;&quot;Performs any post-test things. This includes:</font>
<font color="black"> 913. </font>
<font color="black"> 914.         * Flushing the contents of the database, to leave a clean slate. If</font>
<font color="black"> 915.           the class has an 'available_apps' attribute, post_migrate isn't fired.</font>
<font color="black"> 916.         * Force-closing the connection, so the next test gets a clean cursor.</font>
<font color="black"> 917.         &quot;&quot;&quot;</font>
<font color="green"> 918.         try:</font>
<font color="green"> 919.             self._fixture_teardown()</font>
<font color="green"> 920.             super(TransactionTestCase, self)._post_teardown()</font>
<font color="green"> 921.             if self._should_reload_connections():</font>
<font color="black"> 922.                 # Some DB cursors include SQL statements as part of cursor</font>
<font color="black"> 923.                 # creation. If you have a test that does a rollback, the effect</font>
<font color="black"> 924.                 # of these statements is lost, which can affect the operation of</font>
<font color="black"> 925.                 # tests (e.g., losing a timezone setting causing objects to be</font>
<font color="black"> 926.                 # created with the wrong time). To make sure this doesn't</font>
<font color="black"> 927.                 # happen, get a clean connection at the start of every test.</font>
<font color="red"> 928.                 for conn in connections.all():</font>
<font color="red"> 929.                     conn.close()</font>
<font color="black"> 930.         finally:</font>
<font color="green"> 931.             if self.available_apps is not None:</font>
<font color="red"> 932.                 apps.unset_available_apps()</font>
<font color="red"> 933.                 setting_changed.send(sender=settings._wrapped.__class__,</font>
<font color="red"> 934.                                      setting='INSTALLED_APPS',</font>
<font color="red"> 935.                                      value=settings.INSTALLED_APPS,</font>
<font color="red"> 936.                                      enter=False)</font>
<font color="black"> 937. </font>
<font color="green"> 938.     def _fixture_teardown(self):</font>
<font color="black"> 939.         # Allow TRUNCATE ... CASCADE and don't emit the post_migrate signal</font>
<font color="black"> 940.         # when flushing only a subset of the apps</font>
<font color="red"> 941.         for db_name in self._databases_names(include_mirrors=False):</font>
<font color="black"> 942.             # Flush the database</font>
<font color="black"> 943.             inhibit_post_migrate = (</font>
<font color="red"> 944.                 self.available_apps is not None</font>
<font color="black"> 945.                 or (</font>
<font color="black"> 946.                     # Inhibit the post_migrate signal when using serialized</font>
<font color="black"> 947.                     # rollback to avoid trying to recreate the serialized data.</font>
<font color="red"> 948.                     self.serialized_rollback and</font>
<font color="red"> 949.                     hasattr(connections[db_name], '_test_serialized_contents')</font>
<font color="black"> 950.                 )</font>
<font color="black"> 951.             )</font>
<font color="red"> 952.             call_command('flush', verbosity=0, interactive=False,</font>
<font color="red"> 953.                          database=db_name, reset_sequences=False,</font>
<font color="red"> 954.                          allow_cascade=self.available_apps is not None,</font>
<font color="red"> 955.                          inhibit_post_migrate=inhibit_post_migrate)</font>
<font color="black"> 956. </font>
<font color="green"> 957.     def assertQuerysetEqual(self, qs, values, transform=repr, ordered=True, msg=None):</font>
<font color="red"> 958.         items = six.moves.map(transform, qs)</font>
<font color="red"> 959.         if not ordered:</font>
<font color="red"> 960.             return self.assertEqual(Counter(items), Counter(values), msg=msg)</font>
<font color="red"> 961.         values = list(values)</font>
<font color="black"> 962.         # For example qs.iterator() could be passed as qs, but it does not</font>
<font color="black"> 963.         # have 'ordered' attribute.</font>
<font color="red"> 964.         if len(values) &gt; 1 and hasattr(qs, 'ordered') and not qs.ordered:</font>
<font color="red"> 965.             raise ValueError(&quot;Trying to compare non-ordered queryset &quot;</font>
<font color="black"> 966.                              &quot;against more than one ordered values&quot;)</font>
<font color="red"> 967.         return self.assertEqual(list(items), values, msg=msg)</font>
<font color="black"> 968. </font>
<font color="green"> 969.     def assertNumQueries(self, num, func=None, *args, **kwargs):</font>
<font color="red"> 970.         using = kwargs.pop(&quot;using&quot;, DEFAULT_DB_ALIAS)</font>
<font color="red"> 971.         conn = connections[using]</font>
<font color="black"> 972. </font>
<font color="red"> 973.         context = _AssertNumQueriesContext(self, num, conn)</font>
<font color="red"> 974.         if func is None:</font>
<font color="red"> 975.             return context</font>
<font color="black"> 976. </font>
<font color="red"> 977.         with context:</font>
<font color="red"> 978.             func(*args, **kwargs)</font>
<font color="black"> 979. </font>
<font color="black"> 980. </font>
<font color="green"> 981. def connections_support_transactions():</font>
<font color="black"> 982.     &quot;&quot;&quot;</font>
<font color="black"> 983.     Returns True if all connections support transactions.</font>
<font color="black"> 984.     &quot;&quot;&quot;</font>
<font color="green"> 985.     return all(conn.features.supports_transactions</font>
<font color="green"> 986.                for conn in connections.all())</font>
<font color="black"> 987. </font>
<font color="black"> 988. </font>
<font color="green"> 989. class TestCase(TransactionTestCase):</font>
<font color="black"> 990.     &quot;&quot;&quot;</font>
<font color="black"> 991.     Similar to TransactionTestCase, but uses `transaction.atomic()` to achieve</font>
<font color="black"> 992.     test isolation.</font>
<font color="black"> 993. </font>
<font color="black"> 994.     In most situations, TestCase should be preferred to TransactionTestCase as</font>
<font color="black"> 995.     it allows faster execution. However, there are some situations where using</font>
<font color="black"> 996.     TransactionTestCase might be necessary (e.g. testing some transactional</font>
<font color="black"> 997.     behavior).</font>
<font color="black"> 998. </font>
<font color="black"> 999.     On database backends with no transaction support, TestCase behaves as</font>
<font color="black">1000.     TransactionTestCase.</font>
<font color="green">1001.     &quot;&quot;&quot;</font>
<font color="green">1002.     @classmethod</font>
<font color="black">1003.     def _enter_atomics(cls):</font>
<font color="black">1004.         &quot;&quot;&quot;Helper method to open atomic blocks for multiple databases&quot;&quot;&quot;</font>
<font color="green">1005.         atomics = {}</font>
<font color="green">1006.         for db_name in cls._databases_names():</font>
<font color="green">1007.             atomics[db_name] = transaction.atomic(using=db_name)</font>
<font color="green">1008.             atomics[db_name].__enter__()</font>
<font color="green">1009.         return atomics</font>
<font color="black">1010. </font>
<font color="green">1011.     @classmethod</font>
<font color="black">1012.     def _rollback_atomics(cls, atomics):</font>
<font color="black">1013.         &quot;&quot;&quot;Rollback atomic blocks opened through the previous method&quot;&quot;&quot;</font>
<font color="green">1014.         for db_name in reversed(cls._databases_names()):</font>
<font color="green">1015.             transaction.set_rollback(True, using=db_name)</font>
<font color="green">1016.             atomics[db_name].__exit__(None, None, None)</font>
<font color="black">1017. </font>
<font color="green">1018.     @classmethod</font>
<font color="black">1019.     def setUpClass(cls):</font>
<font color="green">1020.         super(TestCase, cls).setUpClass()</font>
<font color="green">1021.         if not connections_support_transactions():</font>
<font color="red">1022.             return</font>
<font color="green">1023.         cls.cls_atomics = cls._enter_atomics()</font>
<font color="black">1024. </font>
<font color="green">1025.         if cls.fixtures:</font>
<font color="red">1026.             for db_name in cls._databases_names(include_mirrors=False):</font>
<font color="red">1027.                     try:</font>
<font color="red">1028.                         call_command('loaddata', *cls.fixtures, **{</font>
<font color="red">1029.                             'verbosity': 0,</font>
<font color="red">1030.                             'commit': False,</font>
<font color="red">1031.                             'database': db_name,</font>
<font color="black">1032.                         })</font>
<font color="red">1033.                     except Exception:</font>
<font color="red">1034.                         cls._rollback_atomics(cls.cls_atomics)</font>
<font color="red">1035.                         raise</font>
<font color="green">1036.         try:</font>
<font color="green">1037.             cls.setUpTestData()</font>
<font color="red">1038.         except Exception:</font>
<font color="red">1039.             cls._rollback_atomics(cls.cls_atomics)</font>
<font color="red">1040.             raise</font>
<font color="black">1041. </font>
<font color="green">1042.     @classmethod</font>
<font color="black">1043.     def tearDownClass(cls):</font>
<font color="green">1044.         if connections_support_transactions():</font>
<font color="green">1045.             cls._rollback_atomics(cls.cls_atomics)</font>
<font color="green">1046.             for conn in connections.all():</font>
<font color="green">1047.                 conn.close()</font>
<font color="green">1048.         super(TestCase, cls).tearDownClass()</font>
<font color="black">1049. </font>
<font color="green">1050.     @classmethod</font>
<font color="black">1051.     def setUpTestData(cls):</font>
<font color="black">1052.         &quot;&quot;&quot;Load initial data for the TestCase&quot;&quot;&quot;</font>
<font color="green">1053.         pass</font>
<font color="black">1054. </font>
<font color="green">1055.     def _should_reload_connections(self):</font>
<font color="green">1056.         if connections_support_transactions():</font>
<font color="green">1057.             return False</font>
<font color="red">1058.         return super(TestCase, self)._should_reload_connections()</font>
<font color="black">1059. </font>
<font color="green">1060.     def _fixture_setup(self):</font>
<font color="green">1061.         if not connections_support_transactions():</font>
<font color="black">1062.             # If the backend does not support transactions, we should reload</font>
<font color="black">1063.             # class data before each test</font>
<font color="red">1064.             self.setUpTestData()</font>
<font color="red">1065.             return super(TestCase, self)._fixture_setup()</font>
<font color="black">1066. </font>
<font color="green">1067.         assert not self.reset_sequences, 'reset_sequences cannot be used on TestCase instances'</font>
<font color="green">1068.         self.atomics = self._enter_atomics()</font>
<font color="black">1069. </font>
<font color="green">1070.     def _fixture_teardown(self):</font>
<font color="green">1071.         if not connections_support_transactions():</font>
<font color="red">1072.             return super(TestCase, self)._fixture_teardown()</font>
<font color="green">1073.         self._rollback_atomics(self.atomics)</font>
<font color="black">1074. </font>
<font color="black">1075. </font>
<font color="green">1076. class CheckCondition(object):</font>
<font color="green">1077.     &quot;&quot;&quot;Descriptor class for deferred condition checking&quot;&quot;&quot;</font>
<font color="green">1078.     def __init__(self, cond_func):</font>
<font color="red">1079.         self.cond_func = cond_func</font>
<font color="black">1080. </font>
<font color="green">1081.     def __get__(self, obj, objtype):</font>
<font color="red">1082.         return self.cond_func()</font>
<font color="black">1083. </font>
<font color="black">1084. </font>
<font color="green">1085. def _deferredSkip(condition, reason):</font>
<font color="red">1086.     def decorator(test_func):</font>
<font color="red">1087.         if not (isinstance(test_func, type) and</font>
<font color="red">1088.                 issubclass(test_func, unittest.TestCase)):</font>
<font color="red">1089.             @wraps(test_func)</font>
<font color="black">1090.             def skip_wrapper(*args, **kwargs):</font>
<font color="red">1091.                 if condition():</font>
<font color="red">1092.                     raise unittest.SkipTest(reason)</font>
<font color="red">1093.                 return test_func(*args, **kwargs)</font>
<font color="red">1094.             test_item = skip_wrapper</font>
<font color="black">1095.         else:</font>
<font color="black">1096.             # Assume a class is decorated</font>
<font color="red">1097.             test_item = test_func</font>
<font color="red">1098.             test_item.__unittest_skip__ = CheckCondition(condition)</font>
<font color="red">1099.         test_item.__unittest_skip_why__ = reason</font>
<font color="red">1100.         return test_item</font>
<font color="red">1101.     return decorator</font>
<font color="black">1102. </font>
<font color="black">1103. </font>
<font color="green">1104. def skipIfDBFeature(*features):</font>
<font color="black">1105.     &quot;&quot;&quot;</font>
<font color="black">1106.     Skip a test if a database has at least one of the named features.</font>
<font color="black">1107.     &quot;&quot;&quot;</font>
<font color="red">1108.     return _deferredSkip(</font>
<font color="red">1109.         lambda: any(getattr(connection.features, feature, False) for feature in features),</font>
<font color="red">1110.         &quot;Database has feature(s) %s&quot; % &quot;, &quot;.join(features)</font>
<font color="black">1111.     )</font>
<font color="black">1112. </font>
<font color="black">1113. </font>
<font color="green">1114. def skipUnlessDBFeature(*features):</font>
<font color="black">1115.     &quot;&quot;&quot;</font>
<font color="black">1116.     Skip a test unless a database has all the named features.</font>
<font color="black">1117.     &quot;&quot;&quot;</font>
<font color="red">1118.     return _deferredSkip(</font>
<font color="red">1119.         lambda: not all(getattr(connection.features, feature, False) for feature in features),</font>
<font color="red">1120.         &quot;Database doesn't support feature(s): %s&quot; % &quot;, &quot;.join(features)</font>
<font color="black">1121.     )</font>
<font color="black">1122. </font>
<font color="black">1123. </font>
<font color="green">1124. def skipUnlessAnyDBFeature(*features):</font>
<font color="black">1125.     &quot;&quot;&quot;</font>
<font color="black">1126.     Skip a test unless a database has any of the named features.</font>
<font color="black">1127.     &quot;&quot;&quot;</font>
<font color="red">1128.     return _deferredSkip(</font>
<font color="red">1129.         lambda: not any(getattr(connection.features, feature, False) for feature in features),</font>
<font color="red">1130.         &quot;Database doesn't support any of the feature(s): %s&quot; % &quot;, &quot;.join(features)</font>
<font color="black">1131.     )</font>
<font color="black">1132. </font>
<font color="black">1133. </font>
<font color="green">1134. class QuietWSGIRequestHandler(WSGIRequestHandler):</font>
<font color="black">1135.     &quot;&quot;&quot;</font>
<font color="black">1136.     Just a regular WSGIRequestHandler except it doesn't log to the standard</font>
<font color="black">1137.     output any of the requests received, so as to not clutter the output for</font>
<font color="black">1138.     the tests' results.</font>
<font color="green">1139.     &quot;&quot;&quot;</font>
<font color="black">1140. </font>
<font color="green">1141.     def log_message(*args):</font>
<font color="red">1142.         pass</font>
<font color="black">1143. </font>
<font color="black">1144. </font>
<font color="green">1145. class FSFilesHandler(WSGIHandler):</font>
<font color="black">1146.     &quot;&quot;&quot;</font>
<font color="black">1147.     WSGI middleware that intercepts calls to a directory, as defined by one of</font>
<font color="black">1148.     the *_ROOT settings, and serves those files, publishing them under *_URL.</font>
<font color="green">1149.     &quot;&quot;&quot;</font>
<font color="green">1150.     def __init__(self, application):</font>
<font color="red">1151.         self.application = application</font>
<font color="red">1152.         self.base_url = urlparse(self.get_base_url())</font>
<font color="red">1153.         super(FSFilesHandler, self).__init__()</font>
<font color="black">1154. </font>
<font color="green">1155.     def _should_handle(self, path):</font>
<font color="black">1156.         &quot;&quot;&quot;</font>
<font color="black">1157.         Checks if the path should be handled. Ignores the path if:</font>
<font color="black">1158. </font>
<font color="black">1159.         * the host is provided as part of the base_url</font>
<font color="black">1160.         * the request's path isn't under the media path (or equal)</font>
<font color="black">1161.         &quot;&quot;&quot;</font>
<font color="red">1162.         return path.startswith(self.base_url[2]) and not self.base_url[1]</font>
<font color="black">1163. </font>
<font color="green">1164.     def file_path(self, url):</font>
<font color="black">1165.         &quot;&quot;&quot;</font>
<font color="black">1166.         Returns the relative path to the file on disk for the given URL.</font>
<font color="black">1167.         &quot;&quot;&quot;</font>
<font color="red">1168.         relative_url = url[len(self.base_url[2]):]</font>
<font color="red">1169.         return url2pathname(relative_url)</font>
<font color="black">1170. </font>
<font color="green">1171.     def get_response(self, request):</font>
<font color="red">1172.         from django.http import Http404</font>
<font color="black">1173. </font>
<font color="red">1174.         if self._should_handle(request.path):</font>
<font color="red">1175.             try:</font>
<font color="red">1176.                 return self.serve(request)</font>
<font color="red">1177.             except Http404:</font>
<font color="red">1178.                 pass</font>
<font color="red">1179.         return super(FSFilesHandler, self).get_response(request)</font>
<font color="black">1180. </font>
<font color="green">1181.     def serve(self, request):</font>
<font color="red">1182.         os_rel_path = self.file_path(request.path)</font>
<font color="red">1183.         os_rel_path = posixpath.normpath(unquote(os_rel_path))</font>
<font color="black">1184.         # Emulate behavior of django.contrib.staticfiles.views.serve() when it</font>
<font color="black">1185.         # invokes staticfiles' finders functionality.</font>
<font color="black">1186.         # TODO: Modify if/when that internal API is refactored</font>
<font color="red">1187.         final_rel_path = os_rel_path.replace('\\', '/').lstrip('/')</font>
<font color="red">1188.         return serve(request, final_rel_path, document_root=self.get_base_dir())</font>
<font color="black">1189. </font>
<font color="green">1190.     def __call__(self, environ, start_response):</font>
<font color="red">1191.         if not self._should_handle(get_path_info(environ)):</font>
<font color="red">1192.             return self.application(environ, start_response)</font>
<font color="red">1193.         return super(FSFilesHandler, self).__call__(environ, start_response)</font>
<font color="black">1194. </font>
<font color="black">1195. </font>
<font color="green">1196. class _StaticFilesHandler(FSFilesHandler):</font>
<font color="black">1197.     &quot;&quot;&quot;</font>
<font color="black">1198.     Handler for serving static files. A private class that is meant to be used</font>
<font color="black">1199.     solely as a convenience by LiveServerThread.</font>
<font color="green">1200.     &quot;&quot;&quot;</font>
<font color="black">1201. </font>
<font color="green">1202.     def get_base_dir(self):</font>
<font color="red">1203.         return settings.STATIC_ROOT</font>
<font color="black">1204. </font>
<font color="green">1205.     def get_base_url(self):</font>
<font color="red">1206.         return settings.STATIC_URL</font>
<font color="black">1207. </font>
<font color="black">1208. </font>
<font color="green">1209. class _MediaFilesHandler(FSFilesHandler):</font>
<font color="black">1210.     &quot;&quot;&quot;</font>
<font color="black">1211.     Handler for serving the media files. A private class that is meant to be</font>
<font color="black">1212.     used solely as a convenience by LiveServerThread.</font>
<font color="green">1213.     &quot;&quot;&quot;</font>
<font color="black">1214. </font>
<font color="green">1215.     def get_base_dir(self):</font>
<font color="red">1216.         return settings.MEDIA_ROOT</font>
<font color="black">1217. </font>
<font color="green">1218.     def get_base_url(self):</font>
<font color="red">1219.         return settings.MEDIA_URL</font>
<font color="black">1220. </font>
<font color="black">1221. </font>
<font color="green">1222. class LiveServerThread(threading.Thread):</font>
<font color="black">1223.     &quot;&quot;&quot;</font>
<font color="black">1224.     Thread for running a live http server while the tests are running.</font>
<font color="green">1225.     &quot;&quot;&quot;</font>
<font color="black">1226. </font>
<font color="green">1227.     def __init__(self, host, possible_ports, static_handler, connections_override=None):</font>
<font color="red">1228.         self.host = host</font>
<font color="red">1229.         self.port = None</font>
<font color="red">1230.         self.possible_ports = possible_ports</font>
<font color="red">1231.         self.is_ready = threading.Event()</font>
<font color="red">1232.         self.error = None</font>
<font color="red">1233.         self.static_handler = static_handler</font>
<font color="red">1234.         self.connections_override = connections_override</font>
<font color="red">1235.         super(LiveServerThread, self).__init__()</font>
<font color="black">1236. </font>
<font color="green">1237.     def run(self):</font>
<font color="black">1238.         &quot;&quot;&quot;</font>
<font color="black">1239.         Sets up the live server and databases, and then loops over handling</font>
<font color="black">1240.         http requests.</font>
<font color="black">1241.         &quot;&quot;&quot;</font>
<font color="red">1242.         if self.connections_override:</font>
<font color="black">1243.             # Override this thread's database connections with the ones</font>
<font color="black">1244.             # provided by the main thread.</font>
<font color="red">1245.             for alias, conn in self.connections_override.items():</font>
<font color="red">1246.                 connections[alias] = conn</font>
<font color="red">1247.         try:</font>
<font color="black">1248.             # Create the handler for serving static and media files</font>
<font color="red">1249.             handler = self.static_handler(_MediaFilesHandler(WSGIHandler()))</font>
<font color="black">1250. </font>
<font color="black">1251.             # Go through the list of possible ports, hoping that we can find</font>
<font color="black">1252.             # one that is free to use for the WSGI server.</font>
<font color="red">1253.             for index, port in enumerate(self.possible_ports):</font>
<font color="red">1254.                 try:</font>
<font color="red">1255.                     self.httpd = self._create_server(port)</font>
<font color="red">1256.                 except socket.error as e:</font>
<font color="red">1257.                     if (index + 1 &lt; len(self.possible_ports) and</font>
<font color="red">1258.                             e.errno == errno.EADDRINUSE):</font>
<font color="black">1259.                         # This port is already in use, so we go on and try with</font>
<font color="black">1260.                         # the next one in the list.</font>
<font color="red">1261.                         continue</font>
<font color="black">1262.                     else:</font>
<font color="black">1263.                         # Either none of the given ports are free or the error</font>
<font color="black">1264.                         # is something else than &quot;Address already in use&quot;. So</font>
<font color="black">1265.                         # we let that error bubble up to the main thread.</font>
<font color="red">1266.                         raise</font>
<font color="black">1267.                 else:</font>
<font color="black">1268.                     # A free port was found.</font>
<font color="red">1269.                     self.port = port</font>
<font color="red">1270.                     break</font>
<font color="black">1271. </font>
<font color="red">1272.             self.httpd.set_app(handler)</font>
<font color="red">1273.             self.is_ready.set()</font>
<font color="red">1274.             self.httpd.serve_forever()</font>
<font color="red">1275.         except Exception as e:</font>
<font color="red">1276.             self.error = e</font>
<font color="red">1277.             self.is_ready.set()</font>
<font color="black">1278. </font>
<font color="green">1279.     def _create_server(self, port):</font>
<font color="red">1280.         return WSGIServer((self.host, port), QuietWSGIRequestHandler)</font>
<font color="black">1281. </font>
<font color="green">1282.     def terminate(self):</font>
<font color="red">1283.         if hasattr(self, 'httpd'):</font>
<font color="black">1284.             # Stop the WSGI server</font>
<font color="red">1285.             self.httpd.shutdown()</font>
<font color="red">1286.             self.httpd.server_close()</font>
<font color="black">1287. </font>
<font color="black">1288. </font>
<font color="green">1289. class LiveServerTestCase(TransactionTestCase):</font>
<font color="black">1290.     &quot;&quot;&quot;</font>
<font color="black">1291.     Does basically the same as TransactionTestCase but also launches a live</font>
<font color="black">1292.     http server in a separate thread so that the tests may use another testing</font>
<font color="black">1293.     framework, such as Selenium for example, instead of the built-in dummy</font>
<font color="black">1294.     client.</font>
<font color="black">1295.     Note that it inherits from TransactionTestCase instead of TestCase because</font>
<font color="black">1296.     the threads do not share the same transactions (unless if using in-memory</font>
<font color="black">1297.     sqlite) and each thread needs to commit all their transactions so that the</font>
<font color="black">1298.     other thread can see the changes.</font>
<font color="green">1299.     &quot;&quot;&quot;</font>
<font color="black">1300. </font>
<font color="green">1301.     static_handler = _StaticFilesHandler</font>
<font color="black">1302. </font>
<font color="green">1303.     @classproperty</font>
<font color="black">1304.     def live_server_url(cls):</font>
<font color="red">1305.         return 'http://%s:%s' % (</font>
<font color="red">1306.             cls.server_thread.host, cls.server_thread.port)</font>
<font color="black">1307. </font>
<font color="green">1308.     @classmethod</font>
<font color="black">1309.     def setUpClass(cls):</font>
<font color="red">1310.         super(LiveServerTestCase, cls).setUpClass()</font>
<font color="red">1311.         connections_override = {}</font>
<font color="red">1312.         for conn in connections.all():</font>
<font color="black">1313.             # If using in-memory sqlite databases, pass the connections to</font>
<font color="black">1314.             # the server thread.</font>
<font color="red">1315.             if conn.vendor == 'sqlite' and conn.is_in_memory_db(conn.settings_dict['NAME']):</font>
<font color="black">1316.                 # Explicitly enable thread-shareability for this connection</font>
<font color="red">1317.                 conn.allow_thread_sharing = True</font>
<font color="red">1318.                 connections_override[conn.alias] = conn</font>
<font color="black">1319. </font>
<font color="black">1320.         # Launch the live server's thread</font>
<font color="red">1321.         specified_address = os.environ.get(</font>
<font color="red">1322.             'DJANGO_LIVE_TEST_SERVER_ADDRESS', 'localhost:8081-8179')</font>
<font color="black">1323. </font>
<font color="black">1324.         # The specified ports may be of the form '8000-8010,8080,9200-9300'</font>
<font color="black">1325.         # i.e. a comma-separated list of ports or ranges of ports, so we break</font>
<font color="black">1326.         # it down into a detailed list of all possible ports.</font>
<font color="red">1327.         possible_ports = []</font>
<font color="red">1328.         try:</font>
<font color="red">1329.             host, port_ranges = specified_address.split(':')</font>
<font color="red">1330.             for port_range in port_ranges.split(','):</font>
<font color="black">1331.                 # A port range can be of either form: '8000' or '8000-8010'.</font>
<font color="red">1332.                 extremes = list(map(int, port_range.split('-')))</font>
<font color="red">1333.                 assert len(extremes) in [1, 2]</font>
<font color="red">1334.                 if len(extremes) == 1:</font>
<font color="black">1335.                     # Port range of the form '8000'</font>
<font color="red">1336.                     possible_ports.append(extremes[0])</font>
<font color="black">1337.                 else:</font>
<font color="black">1338.                     # Port range of the form '8000-8010'</font>
<font color="red">1339.                     for port in range(extremes[0], extremes[1] + 1):</font>
<font color="red">1340.                         possible_ports.append(port)</font>
<font color="red">1341.         except Exception:</font>
<font color="red">1342.             msg = 'Invalid address (&quot;%s&quot;) for live server.' % specified_address</font>
<font color="red">1343.             six.reraise(ImproperlyConfigured, ImproperlyConfigured(msg), sys.exc_info()[2])</font>
<font color="red">1344.         cls.server_thread = cls._create_server_thread(host, possible_ports, connections_override)</font>
<font color="red">1345.         cls.server_thread.daemon = True</font>
<font color="red">1346.         cls.server_thread.start()</font>
<font color="black">1347. </font>
<font color="black">1348.         # Wait for the live server to be ready</font>
<font color="red">1349.         cls.server_thread.is_ready.wait()</font>
<font color="red">1350.         if cls.server_thread.error:</font>
<font color="black">1351.             # Clean up behind ourselves, since tearDownClass won't get called in</font>
<font color="black">1352.             # case of errors.</font>
<font color="red">1353.             cls._tearDownClassInternal()</font>
<font color="red">1354.             raise cls.server_thread.error</font>
<font color="black">1355. </font>
<font color="green">1356.     @classmethod</font>
<font color="black">1357.     def _create_server_thread(cls, host, possible_ports, connections_override):</font>
<font color="red">1358.         return LiveServerThread(</font>
<font color="red">1359.             host,</font>
<font color="red">1360.             possible_ports,</font>
<font color="red">1361.             cls.static_handler,</font>
<font color="red">1362.             connections_override=connections_override,</font>
<font color="black">1363.         )</font>
<font color="black">1364. </font>
<font color="green">1365.     @classmethod</font>
<font color="black">1366.     def _tearDownClassInternal(cls):</font>
<font color="black">1367.         # There may not be a 'server_thread' attribute if setUpClass() for some</font>
<font color="black">1368.         # reasons has raised an exception.</font>
<font color="red">1369.         if hasattr(cls, 'server_thread'):</font>
<font color="black">1370.             # Terminate the live server's thread</font>
<font color="red">1371.             cls.server_thread.terminate()</font>
<font color="red">1372.             cls.server_thread.join()</font>
<font color="black">1373. </font>
<font color="black">1374.         # Restore sqlite in-memory database connections' non-shareability</font>
<font color="red">1375.         for conn in connections.all():</font>
<font color="red">1376.             if conn.vendor == 'sqlite' and conn.is_in_memory_db(conn.settings_dict['NAME']):</font>
<font color="red">1377.                 conn.allow_thread_sharing = False</font>
<font color="black">1378. </font>
<font color="green">1379.     @classmethod</font>
<font color="black">1380.     def tearDownClass(cls):</font>
<font color="red">1381.         cls._tearDownClassInternal()</font>
<font color="red">1382.         super(LiveServerTestCase, cls).tearDownClass()</font>
<font color="black">1383. </font>
<font color="black">1384. </font>
<font color="green">1385. class SerializeMixin(object):</font>
<font color="black">1386.     &quot;&quot;&quot;</font>
<font color="black">1387.     Mixin to enforce serialization of TestCases that share a common resource.</font>
<font color="black">1388. </font>
<font color="black">1389.     Define a common 'lockfile' for each set of TestCases to serialize. This</font>
<font color="black">1390.     file must exist on the filesystem.</font>
<font color="black">1391. </font>
<font color="black">1392.     Place it early in the MRO in order to isolate setUpClass / tearDownClass.</font>
<font color="green">1393.     &quot;&quot;&quot;</font>
<font color="black">1394. </font>
<font color="green">1395.     lockfile = None</font>
<font color="black">1396. </font>
<font color="green">1397.     @classmethod</font>
<font color="black">1398.     def setUpClass(cls):</font>
<font color="red">1399.         if cls.lockfile is None:</font>
<font color="red">1400.             raise ValueError(</font>
<font color="red">1401.                 &quot;{}.lockfile isn't set. Set it to a unique value &quot;</font>
<font color="red">1402.                 &quot;in the base class.&quot;.format(cls.__name__))</font>
<font color="red">1403.         cls._lockfile = open(cls.lockfile)</font>
<font color="red">1404.         locks.lock(cls._lockfile, locks.LOCK_EX)</font>
<font color="red">1405.         super(SerializeMixin, cls).setUpClass()</font>
<font color="black">1406. </font>
<font color="green">1407.     @classmethod</font>
<font color="black">1408.     def tearDownClass(cls):</font>
<font color="red">1409.         super(SerializeMixin, cls).tearDownClass()</font>
<font color="red">1410.         cls._lockfile.close()</font>
</pre>

