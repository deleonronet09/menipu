source file: <b>/usr/lib/python2.7/posixpath.py</b><br>


file stats: <b>246 lines, 68 executed: 27.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Common operations on Posix pathnames.</font>
<font color="black">   2. </font>
<font color="black">   3. Instead of importing this module directly, import os and refer to</font>
<font color="black">   4. this module as os.path.  The &quot;os.path&quot; name is an alias for this</font>
<font color="black">   5. module on Posix systems; on other systems (e.g. Mac, Windows),</font>
<font color="black">   6. os.path provides the same operations in a manner specific to that</font>
<font color="black">   7. platform, and is an alias to another module (e.g. macpath, ntpath).</font>
<font color="black">   8. </font>
<font color="black">   9. Some of this can actually be useful on non-Posix systems too, e.g.</font>
<font color="black">  10. for manipulation of the pathname component of URLs.</font>
<font color="red">  11. &quot;&quot;&quot;</font>
<font color="black">  12. </font>
<font color="red">  13. import os</font>
<font color="red">  14. import sys</font>
<font color="red">  15. import stat</font>
<font color="red">  16. import genericpath</font>
<font color="red">  17. import warnings</font>
<font color="red">  18. from genericpath import *</font>
<font color="black">  19. </font>
<font color="red">  20. try:</font>
<font color="red">  21.     _unicode = unicode</font>
<font color="red">  22. except NameError:</font>
<font color="black">  23.     # If Python is built without Unicode support, the unicode type</font>
<font color="black">  24.     # will not exist. Fake one.</font>
<font color="red">  25.     class _unicode(object):</font>
<font color="red">  26.         pass</font>
<font color="black">  27. </font>
<font color="red">  28. __all__ = [&quot;normcase&quot;,&quot;isabs&quot;,&quot;join&quot;,&quot;splitdrive&quot;,&quot;split&quot;,&quot;splitext&quot;,</font>
<font color="red">  29.            &quot;basename&quot;,&quot;dirname&quot;,&quot;commonprefix&quot;,&quot;getsize&quot;,&quot;getmtime&quot;,</font>
<font color="red">  30.            &quot;getatime&quot;,&quot;getctime&quot;,&quot;islink&quot;,&quot;exists&quot;,&quot;lexists&quot;,&quot;isdir&quot;,&quot;isfile&quot;,</font>
<font color="red">  31.            &quot;ismount&quot;,&quot;walk&quot;,&quot;expanduser&quot;,&quot;expandvars&quot;,&quot;normpath&quot;,&quot;abspath&quot;,</font>
<font color="red">  32.            &quot;samefile&quot;,&quot;sameopenfile&quot;,&quot;samestat&quot;,</font>
<font color="red">  33.            &quot;curdir&quot;,&quot;pardir&quot;,&quot;sep&quot;,&quot;pathsep&quot;,&quot;defpath&quot;,&quot;altsep&quot;,&quot;extsep&quot;,</font>
<font color="red">  34.            &quot;devnull&quot;,&quot;realpath&quot;,&quot;supports_unicode_filenames&quot;,&quot;relpath&quot;]</font>
<font color="black">  35. </font>
<font color="black">  36. # strings representing various path-related bits and pieces</font>
<font color="red">  37. curdir = '.'</font>
<font color="red">  38. pardir = '..'</font>
<font color="red">  39. extsep = '.'</font>
<font color="red">  40. sep = '/'</font>
<font color="red">  41. pathsep = ':'</font>
<font color="red">  42. defpath = ':/bin:/usr/bin'</font>
<font color="red">  43. altsep = None</font>
<font color="red">  44. devnull = '/dev/null'</font>
<font color="black">  45. </font>
<font color="black">  46. # Normalize the case of a pathname.  Trivial in Posix, string.lower on Mac.</font>
<font color="black">  47. # On MS-DOS this may also turn slashes into backslashes; however, other</font>
<font color="black">  48. # normalizations (such as optimizing '../' away) are not allowed</font>
<font color="black">  49. # (another function should be defined to do that).</font>
<font color="black">  50. </font>
<font color="red">  51. def normcase(s):</font>
<font color="black">  52.     &quot;&quot;&quot;Normalize case of pathname.  Has no effect under Posix&quot;&quot;&quot;</font>
<font color="green">  53.     return s</font>
<font color="black">  54. </font>
<font color="black">  55. </font>
<font color="black">  56. # Return whether a path is absolute.</font>
<font color="black">  57. # Trivial in Posix, harder on the Mac or MS-DOS.</font>
<font color="black">  58. </font>
<font color="red">  59. def isabs(s):</font>
<font color="black">  60.     &quot;&quot;&quot;Test whether a path is absolute&quot;&quot;&quot;</font>
<font color="green">  61.     return s.startswith('/')</font>
<font color="black">  62. </font>
<font color="black">  63. </font>
<font color="black">  64. # Join pathnames.</font>
<font color="black">  65. # Ignore the previous parts if a part is absolute.</font>
<font color="black">  66. # Insert a '/' unless the first part is empty or already ends in '/'.</font>
<font color="black">  67. </font>
<font color="red">  68. def join(a, *p):</font>
<font color="black">  69.     &quot;&quot;&quot;Join two or more pathname components, inserting '/' as needed.</font>
<font color="black">  70.     If any component is an absolute path, all previous path components</font>
<font color="black">  71.     will be discarded.  An empty last part will result in a path that</font>
<font color="black">  72.     ends with a separator.&quot;&quot;&quot;</font>
<font color="green">  73.     path = a</font>
<font color="green">  74.     for b in p:</font>
<font color="green">  75.         if b.startswith('/'):</font>
<font color="red">  76.             path = b</font>
<font color="green">  77.         elif path == '' or path.endswith('/'):</font>
<font color="green">  78.             path +=  b</font>
<font color="black">  79.         else:</font>
<font color="green">  80.             path += '/' + b</font>
<font color="green">  81.     return path</font>
<font color="black">  82. </font>
<font color="black">  83. </font>
<font color="black">  84. # Split a path in head (everything up to the last '/') and tail (the</font>
<font color="black">  85. # rest).  If the path ends in '/', tail will be empty.  If there is no</font>
<font color="black">  86. # '/' in the path, head  will be empty.</font>
<font color="black">  87. # Trailing '/'es are stripped from head unless it is the root.</font>
<font color="black">  88. </font>
<font color="red">  89. def split(p):</font>
<font color="black">  90.     &quot;&quot;&quot;Split a pathname.  Returns tuple &quot;(head, tail)&quot; where &quot;tail&quot; is</font>
<font color="black">  91.     everything after the final slash.  Either part may be empty.&quot;&quot;&quot;</font>
<font color="red">  92.     i = p.rfind('/') + 1</font>
<font color="red">  93.     head, tail = p[:i], p[i:]</font>
<font color="red">  94.     if head and head != '/'*len(head):</font>
<font color="red">  95.         head = head.rstrip('/')</font>
<font color="red">  96.     return head, tail</font>
<font color="black">  97. </font>
<font color="black">  98. </font>
<font color="black">  99. # Split a path in root and extension.</font>
<font color="black"> 100. # The extension is everything starting at the last dot in the last</font>
<font color="black"> 101. # pathname component; the root is everything before that.</font>
<font color="black"> 102. # It is always true that root + ext == p.</font>
<font color="black"> 103. </font>
<font color="red"> 104. def splitext(p):</font>
<font color="green"> 105.     return genericpath._splitext(p, sep, altsep, extsep)</font>
<font color="red"> 106. splitext.__doc__ = genericpath._splitext.__doc__</font>
<font color="black"> 107. </font>
<font color="black"> 108. # Split a pathname into a drive specification and the rest of the</font>
<font color="black"> 109. # path.  Useful on DOS/Windows/NT; on Unix, the drive is always empty.</font>
<font color="black"> 110. </font>
<font color="red"> 111. def splitdrive(p):</font>
<font color="black"> 112.     &quot;&quot;&quot;Split a pathname into drive and path. On Posix, drive is always</font>
<font color="black"> 113.     empty.&quot;&quot;&quot;</font>
<font color="red"> 114.     return '', p</font>
<font color="black"> 115. </font>
<font color="black"> 116. </font>
<font color="black"> 117. # Return the tail (basename) part of a path, same as split(path)[1].</font>
<font color="black"> 118. </font>
<font color="red"> 119. def basename(p):</font>
<font color="black"> 120.     &quot;&quot;&quot;Returns the final component of a pathname&quot;&quot;&quot;</font>
<font color="green"> 121.     i = p.rfind('/') + 1</font>
<font color="green"> 122.     return p[i:]</font>
<font color="black"> 123. </font>
<font color="black"> 124. </font>
<font color="black"> 125. # Return the head (dirname) part of a path, same as split(path)[0].</font>
<font color="black"> 126. </font>
<font color="red"> 127. def dirname(p):</font>
<font color="black"> 128.     &quot;&quot;&quot;Returns the directory component of a pathname&quot;&quot;&quot;</font>
<font color="green"> 129.     i = p.rfind('/') + 1</font>
<font color="green"> 130.     head = p[:i]</font>
<font color="green"> 131.     if head and head != '/'*len(head):</font>
<font color="green"> 132.         head = head.rstrip('/')</font>
<font color="green"> 133.     return head</font>
<font color="black"> 134. </font>
<font color="black"> 135. </font>
<font color="black"> 136. # Is a path a symbolic link?</font>
<font color="black"> 137. # This will always return false on systems where os.lstat doesn't exist.</font>
<font color="black"> 138. </font>
<font color="red"> 139. def islink(path):</font>
<font color="black"> 140.     &quot;&quot;&quot;Test whether a path is a symbolic link&quot;&quot;&quot;</font>
<font color="green"> 141.     try:</font>
<font color="green"> 142.         st = os.lstat(path)</font>
<font color="red"> 143.     except (os.error, AttributeError):</font>
<font color="red"> 144.         return False</font>
<font color="green"> 145.     return stat.S_ISLNK(st.st_mode)</font>
<font color="black"> 146. </font>
<font color="black"> 147. # Being true for dangling symbolic links is also useful.</font>
<font color="black"> 148. </font>
<font color="red"> 149. def lexists(path):</font>
<font color="black"> 150.     &quot;&quot;&quot;Test whether a path exists.  Returns True for broken symbolic links&quot;&quot;&quot;</font>
<font color="red"> 151.     try:</font>
<font color="red"> 152.         os.lstat(path)</font>
<font color="red"> 153.     except os.error:</font>
<font color="red"> 154.         return False</font>
<font color="red"> 155.     return True</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="black"> 158. # Are two filenames really pointing to the same file?</font>
<font color="black"> 159. </font>
<font color="red"> 160. def samefile(f1, f2):</font>
<font color="black"> 161.     &quot;&quot;&quot;Test whether two pathnames reference the same actual file&quot;&quot;&quot;</font>
<font color="red"> 162.     s1 = os.stat(f1)</font>
<font color="red"> 163.     s2 = os.stat(f2)</font>
<font color="red"> 164.     return samestat(s1, s2)</font>
<font color="black"> 165. </font>
<font color="black"> 166. </font>
<font color="black"> 167. # Are two open files really referencing the same file?</font>
<font color="black"> 168. # (Not necessarily the same file descriptor!)</font>
<font color="black"> 169. </font>
<font color="red"> 170. def sameopenfile(fp1, fp2):</font>
<font color="black"> 171.     &quot;&quot;&quot;Test whether two open file objects reference the same file&quot;&quot;&quot;</font>
<font color="red"> 172.     s1 = os.fstat(fp1)</font>
<font color="red"> 173.     s2 = os.fstat(fp2)</font>
<font color="red"> 174.     return samestat(s1, s2)</font>
<font color="black"> 175. </font>
<font color="black"> 176. </font>
<font color="black"> 177. # Are two stat buffers (obtained from stat, fstat or lstat)</font>
<font color="black"> 178. # describing the same file?</font>
<font color="black"> 179. </font>
<font color="red"> 180. def samestat(s1, s2):</font>
<font color="black"> 181.     &quot;&quot;&quot;Test whether two stat buffers reference the same file&quot;&quot;&quot;</font>
<font color="red"> 182.     return s1.st_ino == s2.st_ino and \</font>
<font color="red"> 183.            s1.st_dev == s2.st_dev</font>
<font color="black"> 184. </font>
<font color="black"> 185. </font>
<font color="black"> 186. # Is a path a mount point?</font>
<font color="black"> 187. # (Does this work for all UNIXes?  Is it even guaranteed to work by Posix?)</font>
<font color="black"> 188. </font>
<font color="red"> 189. def ismount(path):</font>
<font color="black"> 190.     &quot;&quot;&quot;Test whether a path is a mount point&quot;&quot;&quot;</font>
<font color="red"> 191.     if islink(path):</font>
<font color="black"> 192.         # A symlink can never be a mount point</font>
<font color="red"> 193.         return False</font>
<font color="red"> 194.     try:</font>
<font color="red"> 195.         s1 = os.lstat(path)</font>
<font color="red"> 196.         s2 = os.lstat(join(path, '..'))</font>
<font color="red"> 197.     except os.error:</font>
<font color="red"> 198.         return False # It doesn't exist -- so not a mount point :-)</font>
<font color="red"> 199.     dev1 = s1.st_dev</font>
<font color="red"> 200.     dev2 = s2.st_dev</font>
<font color="red"> 201.     if dev1 != dev2:</font>
<font color="red"> 202.         return True     # path/.. on a different device as path</font>
<font color="red"> 203.     ino1 = s1.st_ino</font>
<font color="red"> 204.     ino2 = s2.st_ino</font>
<font color="red"> 205.     if ino1 == ino2:</font>
<font color="red"> 206.         return True     # path/.. is the same i-node as path</font>
<font color="red"> 207.     return False</font>
<font color="black"> 208. </font>
<font color="black"> 209. </font>
<font color="black"> 210. # Directory tree walk.</font>
<font color="black"> 211. # For each directory under top (including top itself, but excluding</font>
<font color="black"> 212. # '.' and '..'), func(arg, dirname, filenames) is called, where</font>
<font color="black"> 213. # dirname is the name of the directory and filenames is the list</font>
<font color="black"> 214. # of files (and subdirectories etc.) in the directory.</font>
<font color="black"> 215. # The func may modify the filenames list, to implement a filter,</font>
<font color="black"> 216. # or to impose a different order of visiting.</font>
<font color="black"> 217. </font>
<font color="red"> 218. def walk(top, func, arg):</font>
<font color="black"> 219.     &quot;&quot;&quot;Directory tree walk with callback function.</font>
<font color="black"> 220. </font>
<font color="black"> 221.     For each directory in the directory tree rooted at top (including top</font>
<font color="black"> 222.     itself, but excluding '.' and '..'), call func(arg, dirname, fnames).</font>
<font color="black"> 223.     dirname is the name of the directory, and fnames a list of the names of</font>
<font color="black"> 224.     the files and subdirectories in dirname (excluding '.' and '..').  func</font>
<font color="black"> 225.     may modify the fnames list in-place (e.g. via del or slice assignment),</font>
<font color="black"> 226.     and walk will only recurse into the subdirectories whose names remain in</font>
<font color="black"> 227.     fnames; this can be used to implement a filter, or to impose a specific</font>
<font color="black"> 228.     order of visiting.  No semantics are defined for, or required of, arg,</font>
<font color="black"> 229.     beyond that arg is always passed to func.  It can be used, e.g., to pass</font>
<font color="black"> 230.     a filename pattern, or a mutable object designed to accumulate</font>
<font color="black"> 231.     statistics.  Passing None for arg is common.&quot;&quot;&quot;</font>
<font color="red"> 232.     warnings.warnpy3k(&quot;In 3.x, os.path.walk is removed in favor of os.walk.&quot;,</font>
<font color="red"> 233.                       stacklevel=2)</font>
<font color="red"> 234.     try:</font>
<font color="red"> 235.         names = os.listdir(top)</font>
<font color="red"> 236.     except os.error:</font>
<font color="red"> 237.         return</font>
<font color="red"> 238.     func(arg, top, names)</font>
<font color="red"> 239.     for name in names:</font>
<font color="red"> 240.         name = join(top, name)</font>
<font color="red"> 241.         try:</font>
<font color="red"> 242.             st = os.lstat(name)</font>
<font color="red"> 243.         except os.error:</font>
<font color="red"> 244.             continue</font>
<font color="red"> 245.         if stat.S_ISDIR(st.st_mode):</font>
<font color="red"> 246.             walk(name, func, arg)</font>
<font color="black"> 247. </font>
<font color="black"> 248. </font>
<font color="black"> 249. # Expand paths beginning with '~' or '~user'.</font>
<font color="black"> 250. # '~' means $HOME; '~user' means that user's home directory.</font>
<font color="black"> 251. # If the path doesn't begin with '~', or if the user or $HOME is unknown,</font>
<font color="black"> 252. # the path is returned unchanged (leaving error reporting to whatever</font>
<font color="black"> 253. # function is called with the expanded path as argument).</font>
<font color="black"> 254. # See also module 'glob' for expansion of *, ? and [...] in pathnames.</font>
<font color="black"> 255. # (A function should also be defined to do full *sh-style environment</font>
<font color="black"> 256. # variable expansion.)</font>
<font color="black"> 257. </font>
<font color="red"> 258. def expanduser(path):</font>
<font color="black"> 259.     &quot;&quot;&quot;Expand ~ and ~user constructions.  If user or $HOME is unknown,</font>
<font color="black"> 260.     do nothing.&quot;&quot;&quot;</font>
<font color="red"> 261.     if not path.startswith('~'):</font>
<font color="red"> 262.         return path</font>
<font color="red"> 263.     i = path.find('/', 1)</font>
<font color="red"> 264.     if i &lt; 0:</font>
<font color="red"> 265.         i = len(path)</font>
<font color="red"> 266.     if i == 1:</font>
<font color="red"> 267.         if 'HOME' not in os.environ:</font>
<font color="red"> 268.             import pwd</font>
<font color="red"> 269.             userhome = pwd.getpwuid(os.getuid()).pw_dir</font>
<font color="black"> 270.         else:</font>
<font color="red"> 271.             userhome = os.environ['HOME']</font>
<font color="black"> 272.     else:</font>
<font color="red"> 273.         import pwd</font>
<font color="red"> 274.         try:</font>
<font color="red"> 275.             pwent = pwd.getpwnam(path[1:i])</font>
<font color="red"> 276.         except KeyError:</font>
<font color="red"> 277.             return path</font>
<font color="red"> 278.         userhome = pwent.pw_dir</font>
<font color="red"> 279.     userhome = userhome.rstrip('/')</font>
<font color="red"> 280.     return (userhome + path[i:]) or '/'</font>
<font color="black"> 281. </font>
<font color="black"> 282. </font>
<font color="black"> 283. # Expand paths containing shell variable substitutions.</font>
<font color="black"> 284. # This expands the forms $variable and ${variable} only.</font>
<font color="black"> 285. # Non-existent variables are left unchanged.</font>
<font color="black"> 286. </font>
<font color="red"> 287. _varprog = None</font>
<font color="red"> 288. _uvarprog = None</font>
<font color="black"> 289. </font>
<font color="red"> 290. def expandvars(path):</font>
<font color="black"> 291.     &quot;&quot;&quot;Expand shell variables of form $var and ${var}.  Unknown variables</font>
<font color="black"> 292.     are left unchanged.&quot;&quot;&quot;</font>
<font color="black"> 293.     global _varprog, _uvarprog</font>
<font color="red"> 294.     if '$' not in path:</font>
<font color="red"> 295.         return path</font>
<font color="red"> 296.     if isinstance(path, _unicode):</font>
<font color="red"> 297.         if not _varprog:</font>
<font color="red"> 298.             import re</font>
<font color="red"> 299.             _varprog = re.compile(r'\$(\w+|\{[^}]*\})')</font>
<font color="red"> 300.         varprog = _varprog</font>
<font color="red"> 301.         encoding = sys.getfilesystemencoding()</font>
<font color="black"> 302.     else:</font>
<font color="red"> 303.         if not _uvarprog:</font>
<font color="red"> 304.             import re</font>
<font color="red"> 305.             _uvarprog = re.compile(_unicode(r'\$(\w+|\{[^}]*\})'), re.UNICODE)</font>
<font color="red"> 306.         varprog = _uvarprog</font>
<font color="red"> 307.         encoding = None</font>
<font color="red"> 308.     i = 0</font>
<font color="red"> 309.     while True:</font>
<font color="red"> 310.         m = varprog.search(path, i)</font>
<font color="red"> 311.         if not m:</font>
<font color="red"> 312.             break</font>
<font color="red"> 313.         i, j = m.span(0)</font>
<font color="red"> 314.         name = m.group(1)</font>
<font color="red"> 315.         if name.startswith('{') and name.endswith('}'):</font>
<font color="red"> 316.             name = name[1:-1]</font>
<font color="red"> 317.         if encoding:</font>
<font color="red"> 318.             name = name.encode(encoding)</font>
<font color="red"> 319.         if name in os.environ:</font>
<font color="red"> 320.             tail = path[j:]</font>
<font color="red"> 321.             value = os.environ[name]</font>
<font color="red"> 322.             if encoding:</font>
<font color="red"> 323.                 value = value.decode(encoding)</font>
<font color="red"> 324.             path = path[:i] + value</font>
<font color="red"> 325.             i = len(path)</font>
<font color="red"> 326.             path += tail</font>
<font color="black"> 327.         else:</font>
<font color="red"> 328.             i = j</font>
<font color="red"> 329.     return path</font>
<font color="black"> 330. </font>
<font color="black"> 331. </font>
<font color="black"> 332. # Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.</font>
<font color="black"> 333. # It should be understood that this may change the meaning of the path</font>
<font color="black"> 334. # if it contains symbolic links!</font>
<font color="black"> 335. </font>
<font color="red"> 336. def normpath(path):</font>
<font color="black"> 337.     &quot;&quot;&quot;Normalize path, eliminating double slashes, etc.&quot;&quot;&quot;</font>
<font color="black"> 338.     # Preserve unicode (if path is unicode)</font>
<font color="green"> 339.     slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')</font>
<font color="green"> 340.     if path == '':</font>
<font color="red"> 341.         return dot</font>
<font color="green"> 342.     initial_slashes = path.startswith('/')</font>
<font color="black"> 343.     # POSIX allows one or two initial slashes, but treats three or more</font>
<font color="black"> 344.     # as single slash.</font>
<font color="green"> 345.     if (initial_slashes and</font>
<font color="green"> 346.         path.startswith('//') and not path.startswith('///')):</font>
<font color="red"> 347.         initial_slashes = 2</font>
<font color="green"> 348.     comps = path.split('/')</font>
<font color="green"> 349.     new_comps = []</font>
<font color="green"> 350.     for comp in comps:</font>
<font color="green"> 351.         if comp in ('', '.'):</font>
<font color="green"> 352.             continue</font>
<font color="green"> 353.         if (comp != '..' or (not initial_slashes and not new_comps) or</font>
<font color="red"> 354.              (new_comps and new_comps[-1] == '..')):</font>
<font color="green"> 355.             new_comps.append(comp)</font>
<font color="red"> 356.         elif new_comps:</font>
<font color="red"> 357.             new_comps.pop()</font>
<font color="green"> 358.     comps = new_comps</font>
<font color="green"> 359.     path = slash.join(comps)</font>
<font color="green"> 360.     if initial_slashes:</font>
<font color="green"> 361.         path = slash*initial_slashes + path</font>
<font color="green"> 362.     return path or dot</font>
<font color="black"> 363. </font>
<font color="black"> 364. </font>
<font color="red"> 365. def abspath(path):</font>
<font color="black"> 366.     &quot;&quot;&quot;Return an absolute path.&quot;&quot;&quot;</font>
<font color="green"> 367.     if not isabs(path):</font>
<font color="green"> 368.         if isinstance(path, _unicode):</font>
<font color="red"> 369.             cwd = os.getcwdu()</font>
<font color="black"> 370.         else:</font>
<font color="green"> 371.             cwd = os.getcwd()</font>
<font color="green"> 372.         path = join(cwd, path)</font>
<font color="green"> 373.     return normpath(path)</font>
<font color="black"> 374. </font>
<font color="black"> 375. </font>
<font color="black"> 376. # Return a canonical path (i.e. the absolute location of a file on the</font>
<font color="black"> 377. # filesystem).</font>
<font color="black"> 378. </font>
<font color="red"> 379. def realpath(filename):</font>
<font color="black"> 380.     &quot;&quot;&quot;Return the canonical path of the specified filename, eliminating any</font>
<font color="black"> 381. symbolic links encountered in the path.&quot;&quot;&quot;</font>
<font color="green"> 382.     path, ok = _joinrealpath('', filename, {})</font>
<font color="green"> 383.     return abspath(path)</font>
<font color="black"> 384. </font>
<font color="black"> 385. # Join two paths, normalizing ang eliminating any symbolic links</font>
<font color="black"> 386. # encountered in the second path.</font>
<font color="red"> 387. def _joinrealpath(path, rest, seen):</font>
<font color="green"> 388.     if isabs(rest):</font>
<font color="green"> 389.         rest = rest[1:]</font>
<font color="green"> 390.         path = sep</font>
<font color="black"> 391. </font>
<font color="green"> 392.     while rest:</font>
<font color="green"> 393.         name, _, rest = rest.partition(sep)</font>
<font color="green"> 394.         if not name or name == curdir:</font>
<font color="black"> 395.             # current dir</font>
<font color="red"> 396.             continue</font>
<font color="green"> 397.         if name == pardir:</font>
<font color="black"> 398.             # parent dir</font>
<font color="red"> 399.             if path:</font>
<font color="red"> 400.                 path, name = split(path)</font>
<font color="red"> 401.                 if name == pardir:</font>
<font color="red"> 402.                     path = join(path, pardir, pardir)</font>
<font color="black"> 403.             else:</font>
<font color="red"> 404.                 path = pardir</font>
<font color="red"> 405.             continue</font>
<font color="green"> 406.         newpath = join(path, name)</font>
<font color="green"> 407.         if not islink(newpath):</font>
<font color="green"> 408.             path = newpath</font>
<font color="green"> 409.             continue</font>
<font color="black"> 410.         # Resolve the symbolic link</font>
<font color="green"> 411.         if newpath in seen:</font>
<font color="black"> 412.             # Already seen this path</font>
<font color="red"> 413.             path = seen[newpath]</font>
<font color="red"> 414.             if path is not None:</font>
<font color="black"> 415.                 # use cached value</font>
<font color="red"> 416.                 continue</font>
<font color="black"> 417.             # The symlink is not resolved, so we must have a symlink loop.</font>
<font color="black"> 418.             # Return already resolved part + rest of the path unchanged.</font>
<font color="red"> 419.             return join(newpath, rest), False</font>
<font color="green"> 420.         seen[newpath] = None # not resolved symlink</font>
<font color="green"> 421.         path, ok = _joinrealpath(path, os.readlink(newpath), seen)</font>
<font color="green"> 422.         if not ok:</font>
<font color="red"> 423.             return join(path, rest), False</font>
<font color="green"> 424.         seen[newpath] = path # resolved symlink</font>
<font color="black"> 425. </font>
<font color="green"> 426.     return path, True</font>
<font color="black"> 427. </font>
<font color="black"> 428. </font>
<font color="red"> 429. supports_unicode_filenames = (sys.platform == 'darwin')</font>
<font color="black"> 430. </font>
<font color="red"> 431. def relpath(path, start=curdir):</font>
<font color="black"> 432.     &quot;&quot;&quot;Return a relative version of a path&quot;&quot;&quot;</font>
<font color="black"> 433. </font>
<font color="green"> 434.     if not path:</font>
<font color="red"> 435.         raise ValueError(&quot;no path specified&quot;)</font>
<font color="black"> 436. </font>
<font color="green"> 437.     start_list = [x for x in abspath(start).split(sep) if x]</font>
<font color="green"> 438.     path_list = [x for x in abspath(path).split(sep) if x]</font>
<font color="black"> 439. </font>
<font color="black"> 440.     # Work out how much of the filepath is shared by start and path.</font>
<font color="green"> 441.     i = len(commonprefix([start_list, path_list]))</font>
<font color="black"> 442. </font>
<font color="green"> 443.     rel_list = [pardir] * (len(start_list)-i) + path_list[i:]</font>
<font color="green"> 444.     if not rel_list:</font>
<font color="red"> 445.         return curdir</font>
<font color="green"> 446.     return join(*rel_list)</font>
</pre>

