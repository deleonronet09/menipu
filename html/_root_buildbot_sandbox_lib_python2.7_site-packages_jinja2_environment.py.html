source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/environment.py</b><br>


file stats: <b>576 lines, 152 executed: 26.4% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.environment</font>
<font color="black">   4.     ~~~~~~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Provides a class that holds runtime and parsing time options.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">   9.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. import os</font>
<font color="green">  12. import sys</font>
<font color="green">  13. from jinja2 import nodes</font>
<font color="green">  14. from jinja2.defaults import BLOCK_START_STRING, \</font>
<font color="black">  15.      BLOCK_END_STRING, VARIABLE_START_STRING, VARIABLE_END_STRING, \</font>
<font color="black">  16.      COMMENT_START_STRING, COMMENT_END_STRING, LINE_STATEMENT_PREFIX, \</font>
<font color="black">  17.      LINE_COMMENT_PREFIX, TRIM_BLOCKS, NEWLINE_SEQUENCE, \</font>
<font color="black">  18.      DEFAULT_FILTERS, DEFAULT_TESTS, DEFAULT_NAMESPACE, \</font>
<font color="black">  19.      KEEP_TRAILING_NEWLINE, LSTRIP_BLOCKS</font>
<font color="green">  20. from jinja2.lexer import get_lexer, TokenStream</font>
<font color="green">  21. from jinja2.parser import Parser</font>
<font color="green">  22. from jinja2.nodes import EvalContext</font>
<font color="green">  23. from jinja2.optimizer import optimize</font>
<font color="green">  24. from jinja2.compiler import generate, CodeGenerator</font>
<font color="green">  25. from jinja2.runtime import Undefined, new_context, Context</font>
<font color="green">  26. from jinja2.exceptions import TemplateSyntaxError, TemplateNotFound, \</font>
<font color="black">  27.      TemplatesNotFound, TemplateRuntimeError</font>
<font color="green">  28. from jinja2.utils import import_string, LRUCache, Markup, missing, \</font>
<font color="black">  29.      concat, consume, internalcode</font>
<font color="green">  30. from jinja2._compat import imap, ifilter, string_types, iteritems, \</font>
<font color="black">  31.      text_type, reraise, implements_iterator, implements_to_string, \</font>
<font color="black">  32.      get_next, encode_filename, PY2, PYPY</font>
<font color="green">  33. from functools import reduce</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="black">  36. # for direct template usage we have up to ten living environments</font>
<font color="green">  37. _spontaneous_environments = LRUCache(10)</font>
<font color="black">  38. </font>
<font color="black">  39. # the function to create jinja traceback objects.  This is dynamically</font>
<font color="black">  40. # imported on the first exception in the exception handler.</font>
<font color="green">  41. _make_traceback = None</font>
<font color="black">  42. </font>
<font color="black">  43. </font>
<font color="green">  44. def get_spontaneous_environment(*args):</font>
<font color="black">  45.     &quot;&quot;&quot;Return a new spontaneous environment.  A spontaneous environment is an</font>
<font color="black">  46.     unnamed and unaccessible (in theory) environment that is used for</font>
<font color="black">  47.     templates generated from a string and not from the file system.</font>
<font color="black">  48.     &quot;&quot;&quot;</font>
<font color="red">  49.     try:</font>
<font color="red">  50.         env = _spontaneous_environments.get(args)</font>
<font color="red">  51.     except TypeError:</font>
<font color="red">  52.         return Environment(*args)</font>
<font color="red">  53.     if env is not None:</font>
<font color="red">  54.         return env</font>
<font color="red">  55.     _spontaneous_environments[args] = env = Environment(*args)</font>
<font color="red">  56.     env.shared = True</font>
<font color="red">  57.     return env</font>
<font color="black">  58. </font>
<font color="black">  59. </font>
<font color="green">  60. def create_cache(size):</font>
<font color="black">  61.     &quot;&quot;&quot;Return the cache class for the given size.&quot;&quot;&quot;</font>
<font color="red">  62.     if size == 0:</font>
<font color="red">  63.         return None</font>
<font color="red">  64.     if size &lt; 0:</font>
<font color="red">  65.         return {}</font>
<font color="red">  66.     return LRUCache(size)</font>
<font color="black">  67. </font>
<font color="black">  68. </font>
<font color="green">  69. def copy_cache(cache):</font>
<font color="black">  70.     &quot;&quot;&quot;Create an empty copy of the given cache.&quot;&quot;&quot;</font>
<font color="red">  71.     if cache is None:</font>
<font color="red">  72.         return None</font>
<font color="red">  73.     elif type(cache) is dict:</font>
<font color="red">  74.         return {}</font>
<font color="red">  75.     return LRUCache(cache.capacity)</font>
<font color="black">  76. </font>
<font color="black">  77. </font>
<font color="green">  78. def load_extensions(environment, extensions):</font>
<font color="black">  79.     &quot;&quot;&quot;Load the extensions from the list and bind it to the environment.</font>
<font color="black">  80.     Returns a dict of instantiated environments.</font>
<font color="black">  81.     &quot;&quot;&quot;</font>
<font color="red">  82.     result = {}</font>
<font color="red">  83.     for extension in extensions:</font>
<font color="red">  84.         if isinstance(extension, string_types):</font>
<font color="red">  85.             extension = import_string(extension)</font>
<font color="red">  86.         result[extension.identifier] = extension(environment)</font>
<font color="red">  87.     return result</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="green">  90. def _environment_sanity_check(environment):</font>
<font color="black">  91.     &quot;&quot;&quot;Perform a sanity check on the environment.&quot;&quot;&quot;</font>
<font color="red">  92.     assert issubclass(environment.undefined, Undefined), 'undefined must ' \</font>
<font color="black">  93.         'be a subclass of undefined because filters depend on it.'</font>
<font color="red">  94.     assert environment.block_start_string != \</font>
<font color="red">  95.         environment.variable_start_string != \</font>
<font color="red">  96.         environment.comment_start_string, 'block, variable and comment ' \</font>
<font color="black">  97.         'start strings must be different'</font>
<font color="red">  98.     assert environment.newline_sequence in ('\r', '\r\n', '\n'), \</font>
<font color="red">  99.         'newline_sequence set to unknown line ending string.'</font>
<font color="red"> 100.     return environment</font>
<font color="black"> 101. </font>
<font color="black"> 102. </font>
<font color="green"> 103. class Environment(object):</font>
<font color="black"> 104.     r&quot;&quot;&quot;The core component of Jinja is the `Environment`.  It contains</font>
<font color="black"> 105.     important shared variables like configuration, filters, tests,</font>
<font color="black"> 106.     globals and others.  Instances of this class may be modified if</font>
<font color="black"> 107.     they are not shared and if no template was loaded so far.</font>
<font color="black"> 108.     Modifications on environments after the first template was loaded</font>
<font color="black"> 109.     will lead to surprising effects and undefined behavior.</font>
<font color="black"> 110. </font>
<font color="black"> 111.     Here are the possible initialization parameters:</font>
<font color="black"> 112. </font>
<font color="black"> 113.         `block_start_string`</font>
<font color="black"> 114.             The string marking the beginning of a block.  Defaults to ``'{%'``.</font>
<font color="black"> 115. </font>
<font color="black"> 116.         `block_end_string`</font>
<font color="black"> 117.             The string marking the end of a block.  Defaults to ``'%}'``.</font>
<font color="black"> 118. </font>
<font color="black"> 119.         `variable_start_string`</font>
<font color="black"> 120.             The string marking the beginning of a print statement.</font>
<font color="black"> 121.             Defaults to ``'{{'``.</font>
<font color="black"> 122. </font>
<font color="black"> 123.         `variable_end_string`</font>
<font color="black"> 124.             The string marking the end of a print statement.  Defaults to</font>
<font color="black"> 125.             ``'}}'``.</font>
<font color="black"> 126. </font>
<font color="black"> 127.         `comment_start_string`</font>
<font color="black"> 128.             The string marking the beginning of a comment.  Defaults to ``'{#'``.</font>
<font color="black"> 129. </font>
<font color="black"> 130.         `comment_end_string`</font>
<font color="black"> 131.             The string marking the end of a comment.  Defaults to ``'#}'``.</font>
<font color="black"> 132. </font>
<font color="black"> 133.         `line_statement_prefix`</font>
<font color="black"> 134.             If given and a string, this will be used as prefix for line based</font>
<font color="black"> 135.             statements.  See also :ref:`line-statements`.</font>
<font color="black"> 136. </font>
<font color="black"> 137.         `line_comment_prefix`</font>
<font color="black"> 138.             If given and a string, this will be used as prefix for line based</font>
<font color="black"> 139.             comments.  See also :ref:`line-statements`.</font>
<font color="black"> 140. </font>
<font color="black"> 141.             .. versionadded:: 2.2</font>
<font color="black"> 142. </font>
<font color="black"> 143.         `trim_blocks`</font>
<font color="black"> 144.             If this is set to ``True`` the first newline after a block is</font>
<font color="black"> 145.             removed (block, not variable tag!).  Defaults to `False`.</font>
<font color="black"> 146. </font>
<font color="black"> 147.         `lstrip_blocks`</font>
<font color="black"> 148.             If this is set to ``True`` leading spaces and tabs are stripped</font>
<font color="black"> 149.             from the start of a line to a block.  Defaults to `False`.</font>
<font color="black"> 150. </font>
<font color="black"> 151.         `newline_sequence`</font>
<font color="black"> 152.             The sequence that starts a newline.  Must be one of ``'\r'``,</font>
<font color="black"> 153.             ``'\n'`` or ``'\r\n'``.  The default is ``'\n'`` which is a</font>
<font color="black"> 154.             useful default for Linux and OS X systems as well as web</font>
<font color="black"> 155.             applications.</font>
<font color="black"> 156. </font>
<font color="black"> 157.         `keep_trailing_newline`</font>
<font color="black"> 158.             Preserve the trailing newline when rendering templates.</font>
<font color="black"> 159.             The default is ``False``, which causes a single newline,</font>
<font color="black"> 160.             if present, to be stripped from the end of the template.</font>
<font color="black"> 161. </font>
<font color="black"> 162.             .. versionadded:: 2.7</font>
<font color="black"> 163. </font>
<font color="black"> 164.         `extensions`</font>
<font color="black"> 165.             List of Jinja extensions to use.  This can either be import paths</font>
<font color="black"> 166.             as strings or extension classes.  For more information have a</font>
<font color="black"> 167.             look at :ref:`the extensions documentation &lt;jinja-extensions&gt;`.</font>
<font color="black"> 168. </font>
<font color="black"> 169.         `optimized`</font>
<font color="black"> 170.             should the optimizer be enabled?  Default is `True`.</font>
<font color="black"> 171. </font>
<font color="black"> 172.         `undefined`</font>
<font color="black"> 173.             :class:`Undefined` or a subclass of it that is used to represent</font>
<font color="black"> 174.             undefined values in the template.</font>
<font color="black"> 175. </font>
<font color="black"> 176.         `finalize`</font>
<font color="black"> 177.             A callable that can be used to process the result of a variable</font>
<font color="black"> 178.             expression before it is output.  For example one can convert</font>
<font color="black"> 179.             `None` implicitly into an empty string here.</font>
<font color="black"> 180. </font>
<font color="black"> 181.         `autoescape`</font>
<font color="black"> 182.             If set to true the XML/HTML autoescaping feature is enabled by</font>
<font color="black"> 183.             default.  For more details about autoescaping see</font>
<font color="black"> 184.             :class:`~jinja2.utils.Markup`.  As of Jinja 2.4 this can also</font>
<font color="black"> 185.             be a callable that is passed the template name and has to</font>
<font color="black"> 186.             return `True` or `False` depending on autoescape should be</font>
<font color="black"> 187.             enabled by default.</font>
<font color="black"> 188. </font>
<font color="black"> 189.             .. versionchanged:: 2.4</font>
<font color="black"> 190.                `autoescape` can now be a function</font>
<font color="black"> 191. </font>
<font color="black"> 192.         `loader`</font>
<font color="black"> 193.             The template loader for this environment.</font>
<font color="black"> 194. </font>
<font color="black"> 195.         `cache_size`</font>
<font color="black"> 196.             The size of the cache.  Per default this is ``400`` which means</font>
<font color="black"> 197.             that if more than 400 templates are loaded the loader will clean</font>
<font color="black"> 198.             out the least recently used template.  If the cache size is set to</font>
<font color="black"> 199.             ``0`` templates are recompiled all the time, if the cache size is</font>
<font color="black"> 200.             ``-1`` the cache will not be cleaned.</font>
<font color="black"> 201. </font>
<font color="black"> 202.             .. versionchanged:: 2.8</font>
<font color="black"> 203.                The cache size was increased to 400 from a low 50.</font>
<font color="black"> 204. </font>
<font color="black"> 205.         `auto_reload`</font>
<font color="black"> 206.             Some loaders load templates from locations where the template</font>
<font color="black"> 207.             sources may change (ie: file system or database).  If</font>
<font color="black"> 208.             `auto_reload` is set to `True` (default) every time a template is</font>
<font color="black"> 209.             requested the loader checks if the source changed and if yes, it</font>
<font color="black"> 210.             will reload the template.  For higher performance it's possible to</font>
<font color="black"> 211.             disable that.</font>
<font color="black"> 212. </font>
<font color="black"> 213.         `bytecode_cache`</font>
<font color="black"> 214.             If set to a bytecode cache object, this object will provide a</font>
<font color="black"> 215.             cache for the internal Jinja bytecode so that templates don't</font>
<font color="black"> 216.             have to be parsed if they were not changed.</font>
<font color="black"> 217. </font>
<font color="black"> 218.             See :ref:`bytecode-cache` for more information.</font>
<font color="green"> 219.     &quot;&quot;&quot;</font>
<font color="black"> 220. </font>
<font color="black"> 221.     #: if this environment is sandboxed.  Modifying this variable won't make</font>
<font color="black"> 222.     #: the environment sandboxed though.  For a real sandboxed environment</font>
<font color="black"> 223.     #: have a look at jinja2.sandbox.  This flag alone controls the code</font>
<font color="black"> 224.     #: generation by the compiler.</font>
<font color="green"> 225.     sandboxed = False</font>
<font color="black"> 226. </font>
<font color="black"> 227.     #: True if the environment is just an overlay</font>
<font color="green"> 228.     overlayed = False</font>
<font color="black"> 229. </font>
<font color="black"> 230.     #: the environment this environment is linked to if it is an overlay</font>
<font color="green"> 231.     linked_to = None</font>
<font color="black"> 232. </font>
<font color="black"> 233.     #: shared environments have this set to `True`.  A shared environment</font>
<font color="black"> 234.     #: must not be modified</font>
<font color="green"> 235.     shared = False</font>
<font color="black"> 236. </font>
<font color="black"> 237.     #: these are currently EXPERIMENTAL undocumented features.</font>
<font color="green"> 238.     exception_handler = None</font>
<font color="green"> 239.     exception_formatter = None</font>
<font color="black"> 240. </font>
<font color="black"> 241.     #: the class that is used for code generation.  See</font>
<font color="black"> 242.     #: :class:`~jinja2.compiler.CodeGenerator` for more information.</font>
<font color="green"> 243.     code_generator_class = CodeGenerator</font>
<font color="black"> 244. </font>
<font color="black"> 245.     #: the context class thatis used for templates.  See</font>
<font color="black"> 246.     #: :class:`~jinja2.runtime.Context` for more information.</font>
<font color="green"> 247.     context_class = Context</font>
<font color="black"> 248. </font>
<font color="black"> 249.     def __init__(self,</font>
<font color="green"> 250.                  block_start_string=BLOCK_START_STRING,</font>
<font color="green"> 251.                  block_end_string=BLOCK_END_STRING,</font>
<font color="green"> 252.                  variable_start_string=VARIABLE_START_STRING,</font>
<font color="green"> 253.                  variable_end_string=VARIABLE_END_STRING,</font>
<font color="green"> 254.                  comment_start_string=COMMENT_START_STRING,</font>
<font color="green"> 255.                  comment_end_string=COMMENT_END_STRING,</font>
<font color="green"> 256.                  line_statement_prefix=LINE_STATEMENT_PREFIX,</font>
<font color="green"> 257.                  line_comment_prefix=LINE_COMMENT_PREFIX,</font>
<font color="green"> 258.                  trim_blocks=TRIM_BLOCKS,</font>
<font color="green"> 259.                  lstrip_blocks=LSTRIP_BLOCKS,</font>
<font color="green"> 260.                  newline_sequence=NEWLINE_SEQUENCE,</font>
<font color="green"> 261.                  keep_trailing_newline=KEEP_TRAILING_NEWLINE,</font>
<font color="green"> 262.                  extensions=(),</font>
<font color="green"> 263.                  optimized=True,</font>
<font color="green"> 264.                  undefined=Undefined,</font>
<font color="green"> 265.                  finalize=None,</font>
<font color="green"> 266.                  autoescape=False,</font>
<font color="green"> 267.                  loader=None,</font>
<font color="green"> 268.                  cache_size=400,</font>
<font color="green"> 269.                  auto_reload=True,</font>
<font color="green"> 270.                  bytecode_cache=None):</font>
<font color="black"> 271.         # !!Important notice!!</font>
<font color="black"> 272.         #   The constructor accepts quite a few arguments that should be</font>
<font color="black"> 273.         #   passed by keyword rather than position.  However it's important to</font>
<font color="black"> 274.         #   not change the order of arguments because it's used at least</font>
<font color="black"> 275.         #   internally in those cases:</font>
<font color="black"> 276.         #       -   spontaneous environments (i18n extension and Template)</font>
<font color="black"> 277.         #       -   unittests</font>
<font color="black"> 278.         #   If parameter changes are required only add parameters at the end</font>
<font color="black"> 279.         #   and don't change the arguments (or the defaults!) of the arguments</font>
<font color="black"> 280.         #   existing already.</font>
<font color="black"> 281. </font>
<font color="black"> 282.         # lexer / parser information</font>
<font color="red"> 283.         self.block_start_string = block_start_string</font>
<font color="red"> 284.         self.block_end_string = block_end_string</font>
<font color="red"> 285.         self.variable_start_string = variable_start_string</font>
<font color="red"> 286.         self.variable_end_string = variable_end_string</font>
<font color="red"> 287.         self.comment_start_string = comment_start_string</font>
<font color="red"> 288.         self.comment_end_string = comment_end_string</font>
<font color="red"> 289.         self.line_statement_prefix = line_statement_prefix</font>
<font color="red"> 290.         self.line_comment_prefix = line_comment_prefix</font>
<font color="red"> 291.         self.trim_blocks = trim_blocks</font>
<font color="red"> 292.         self.lstrip_blocks = lstrip_blocks</font>
<font color="red"> 293.         self.newline_sequence = newline_sequence</font>
<font color="red"> 294.         self.keep_trailing_newline = keep_trailing_newline</font>
<font color="black"> 295. </font>
<font color="black"> 296.         # runtime information</font>
<font color="red"> 297.         self.undefined = undefined</font>
<font color="red"> 298.         self.optimized = optimized</font>
<font color="red"> 299.         self.finalize = finalize</font>
<font color="red"> 300.         self.autoescape = autoescape</font>
<font color="black"> 301. </font>
<font color="black"> 302.         # defaults</font>
<font color="red"> 303.         self.filters = DEFAULT_FILTERS.copy()</font>
<font color="red"> 304.         self.tests = DEFAULT_TESTS.copy()</font>
<font color="red"> 305.         self.globals = DEFAULT_NAMESPACE.copy()</font>
<font color="black"> 306. </font>
<font color="black"> 307.         # set the loader provided</font>
<font color="red"> 308.         self.loader = loader</font>
<font color="red"> 309.         self.cache = create_cache(cache_size)</font>
<font color="red"> 310.         self.bytecode_cache = bytecode_cache</font>
<font color="red"> 311.         self.auto_reload = auto_reload</font>
<font color="black"> 312. </font>
<font color="black"> 313.         # load extensions</font>
<font color="red"> 314.         self.extensions = load_extensions(self, extensions)</font>
<font color="black"> 315. </font>
<font color="red"> 316.         _environment_sanity_check(self)</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def add_extension(self, extension):</font>
<font color="black"> 319.         &quot;&quot;&quot;Adds an extension after the environment was created.</font>
<font color="black"> 320. </font>
<font color="black"> 321.         .. versionadded:: 2.5</font>
<font color="black"> 322.         &quot;&quot;&quot;</font>
<font color="red"> 323.         self.extensions.update(load_extensions(self, [extension]))</font>
<font color="black"> 324. </font>
<font color="green"> 325.     def extend(self, **attributes):</font>
<font color="black"> 326.         &quot;&quot;&quot;Add the items to the instance of the environment if they do not exist</font>
<font color="black"> 327.         yet.  This is used by :ref:`extensions &lt;writing-extensions&gt;` to register</font>
<font color="black"> 328.         callbacks and configuration values without breaking inheritance.</font>
<font color="black"> 329.         &quot;&quot;&quot;</font>
<font color="red"> 330.         for key, value in iteritems(attributes):</font>
<font color="red"> 331.             if not hasattr(self, key):</font>
<font color="red"> 332.                 setattr(self, key, value)</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def overlay(self, block_start_string=missing, block_end_string=missing,</font>
<font color="green"> 335.                 variable_start_string=missing, variable_end_string=missing,</font>
<font color="green"> 336.                 comment_start_string=missing, comment_end_string=missing,</font>
<font color="green"> 337.                 line_statement_prefix=missing, line_comment_prefix=missing,</font>
<font color="green"> 338.                 trim_blocks=missing, lstrip_blocks=missing,</font>
<font color="green"> 339.                 extensions=missing, optimized=missing,</font>
<font color="green"> 340.                 undefined=missing, finalize=missing, autoescape=missing,</font>
<font color="green"> 341.                 loader=missing, cache_size=missing, auto_reload=missing,</font>
<font color="green"> 342.                 bytecode_cache=missing):</font>
<font color="black"> 343.         &quot;&quot;&quot;Create a new overlay environment that shares all the data with the</font>
<font color="black"> 344.         current environment except for cache and the overridden attributes.</font>
<font color="black"> 345.         Extensions cannot be removed for an overlayed environment.  An overlayed</font>
<font color="black"> 346.         environment automatically gets all the extensions of the environment it</font>
<font color="black"> 347.         is linked to plus optional extra extensions.</font>
<font color="black"> 348. </font>
<font color="black"> 349.         Creating overlays should happen after the initial environment was set</font>
<font color="black"> 350.         up completely.  Not all attributes are truly linked, some are just</font>
<font color="black"> 351.         copied over so modifications on the original environment may not shine</font>
<font color="black"> 352.         through.</font>
<font color="black"> 353.         &quot;&quot;&quot;</font>
<font color="red"> 354.         args = dict(locals())</font>
<font color="red"> 355.         del args['self'], args['cache_size'], args['extensions']</font>
<font color="black"> 356. </font>
<font color="red"> 357.         rv = object.__new__(self.__class__)</font>
<font color="red"> 358.         rv.__dict__.update(self.__dict__)</font>
<font color="red"> 359.         rv.overlayed = True</font>
<font color="red"> 360.         rv.linked_to = self</font>
<font color="black"> 361. </font>
<font color="red"> 362.         for key, value in iteritems(args):</font>
<font color="red"> 363.             if value is not missing:</font>
<font color="red"> 364.                 setattr(rv, key, value)</font>
<font color="black"> 365. </font>
<font color="red"> 366.         if cache_size is not missing:</font>
<font color="red"> 367.             rv.cache = create_cache(cache_size)</font>
<font color="black"> 368.         else:</font>
<font color="red"> 369.             rv.cache = copy_cache(self.cache)</font>
<font color="black"> 370. </font>
<font color="red"> 371.         rv.extensions = {}</font>
<font color="red"> 372.         for key, value in iteritems(self.extensions):</font>
<font color="red"> 373.             rv.extensions[key] = value.bind(rv)</font>
<font color="red"> 374.         if extensions is not missing:</font>
<font color="red"> 375.             rv.extensions.update(load_extensions(rv, extensions))</font>
<font color="black"> 376. </font>
<font color="red"> 377.         return _environment_sanity_check(rv)</font>
<font color="black"> 378. </font>
<font color="green"> 379.     lexer = property(get_lexer, doc=&quot;The lexer for this environment.&quot;)</font>
<font color="black"> 380. </font>
<font color="green"> 381.     def iter_extensions(self):</font>
<font color="black"> 382.         &quot;&quot;&quot;Iterates over the extensions by priority.&quot;&quot;&quot;</font>
<font color="red"> 383.         return iter(sorted(self.extensions.values(),</font>
<font color="red"> 384.                            key=lambda x: x.priority))</font>
<font color="black"> 385. </font>
<font color="green"> 386.     def getitem(self, obj, argument):</font>
<font color="black"> 387.         &quot;&quot;&quot;Get an item or attribute of an object but prefer the item.&quot;&quot;&quot;</font>
<font color="red"> 388.         try:</font>
<font color="red"> 389.             return obj[argument]</font>
<font color="red"> 390.         except (TypeError, LookupError):</font>
<font color="red"> 391.             if isinstance(argument, string_types):</font>
<font color="red"> 392.                 try:</font>
<font color="red"> 393.                     attr = str(argument)</font>
<font color="red"> 394.                 except Exception:</font>
<font color="red"> 395.                     pass</font>
<font color="black"> 396.                 else:</font>
<font color="red"> 397.                     try:</font>
<font color="red"> 398.                         return getattr(obj, attr)</font>
<font color="red"> 399.                     except AttributeError:</font>
<font color="red"> 400.                         pass</font>
<font color="red"> 401.             return self.undefined(obj=obj, name=argument)</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def getattr(self, obj, attribute):</font>
<font color="black"> 404.         &quot;&quot;&quot;Get an item or attribute of an object but prefer the attribute.</font>
<font color="black"> 405.         Unlike :meth:`getitem` the attribute *must* be a bytestring.</font>
<font color="black"> 406.         &quot;&quot;&quot;</font>
<font color="red"> 407.         try:</font>
<font color="red"> 408.             return getattr(obj, attribute)</font>
<font color="red"> 409.         except AttributeError:</font>
<font color="red"> 410.             pass</font>
<font color="red"> 411.         try:</font>
<font color="red"> 412.             return obj[attribute]</font>
<font color="red"> 413.         except (TypeError, LookupError, AttributeError):</font>
<font color="red"> 414.             return self.undefined(obj=obj, name=attribute)</font>
<font color="black"> 415. </font>
<font color="green"> 416.     def call_filter(self, name, value, args=None, kwargs=None,</font>
<font color="green"> 417.                     context=None, eval_ctx=None):</font>
<font color="black"> 418.         &quot;&quot;&quot;Invokes a filter on a value the same way the compiler does it.</font>
<font color="black"> 419. </font>
<font color="black"> 420.         .. versionadded:: 2.7</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="red"> 422.         func = self.filters.get(name)</font>
<font color="red"> 423.         if func is None:</font>
<font color="red"> 424.             raise TemplateRuntimeError('no filter named %r' % name)</font>
<font color="red"> 425.         args = [value] + list(args or ())</font>
<font color="red"> 426.         if getattr(func, 'contextfilter', False):</font>
<font color="red"> 427.             if context is None:</font>
<font color="red"> 428.                 raise TemplateRuntimeError('Attempted to invoke context '</font>
<font color="black"> 429.                                            'filter without context')</font>
<font color="red"> 430.             args.insert(0, context)</font>
<font color="red"> 431.         elif getattr(func, 'evalcontextfilter', False):</font>
<font color="red"> 432.             if eval_ctx is None:</font>
<font color="red"> 433.                 if context is not None:</font>
<font color="red"> 434.                     eval_ctx = context.eval_ctx</font>
<font color="black"> 435.                 else:</font>
<font color="red"> 436.                     eval_ctx = EvalContext(self)</font>
<font color="red"> 437.             args.insert(0, eval_ctx)</font>
<font color="red"> 438.         elif getattr(func, 'environmentfilter', False):</font>
<font color="red"> 439.             args.insert(0, self)</font>
<font color="red"> 440.         return func(*args, **(kwargs or {}))</font>
<font color="black"> 441. </font>
<font color="green"> 442.     def call_test(self, name, value, args=None, kwargs=None):</font>
<font color="black"> 443.         &quot;&quot;&quot;Invokes a test on a value the same way the compiler does it.</font>
<font color="black"> 444. </font>
<font color="black"> 445.         .. versionadded:: 2.7</font>
<font color="black"> 446.         &quot;&quot;&quot;</font>
<font color="red"> 447.         func = self.tests.get(name)</font>
<font color="red"> 448.         if func is None:</font>
<font color="red"> 449.             raise TemplateRuntimeError('no test named %r' % name)</font>
<font color="red"> 450.         return func(value, *(args or ()), **(kwargs or {}))</font>
<font color="black"> 451. </font>
<font color="green"> 452.     @internalcode</font>
<font color="green"> 453.     def parse(self, source, name=None, filename=None):</font>
<font color="black"> 454.         &quot;&quot;&quot;Parse the sourcecode and return the abstract syntax tree.  This</font>
<font color="black"> 455.         tree of nodes is used by the compiler to convert the template into</font>
<font color="black"> 456.         executable source- or bytecode.  This is useful for debugging or to</font>
<font color="black"> 457.         extract information from templates.</font>
<font color="black"> 458. </font>
<font color="black"> 459.         If you are :ref:`developing Jinja2 extensions &lt;writing-extensions&gt;`</font>
<font color="black"> 460.         this gives you a good overview of the node tree generated.</font>
<font color="black"> 461.         &quot;&quot;&quot;</font>
<font color="red"> 462.         try:</font>
<font color="red"> 463.             return self._parse(source, name, filename)</font>
<font color="red"> 464.         except TemplateSyntaxError:</font>
<font color="red"> 465.             exc_info = sys.exc_info()</font>
<font color="red"> 466.         self.handle_exception(exc_info, source_hint=source)</font>
<font color="black"> 467. </font>
<font color="green"> 468.     def _parse(self, source, name, filename):</font>
<font color="black"> 469.         &quot;&quot;&quot;Internal parsing function used by `parse` and `compile`.&quot;&quot;&quot;</font>
<font color="red"> 470.         return Parser(self, source, name, encode_filename(filename)).parse()</font>
<font color="black"> 471. </font>
<font color="green"> 472.     def lex(self, source, name=None, filename=None):</font>
<font color="black"> 473.         &quot;&quot;&quot;Lex the given sourcecode and return a generator that yields</font>
<font color="black"> 474.         tokens as tuples in the form ``(lineno, token_type, value)``.</font>
<font color="black"> 475.         This can be useful for :ref:`extension development &lt;writing-extensions&gt;`</font>
<font color="black"> 476.         and debugging templates.</font>
<font color="black"> 477. </font>
<font color="black"> 478.         This does not perform preprocessing.  If you want the preprocessing</font>
<font color="black"> 479.         of the extensions to be applied you have to filter source through</font>
<font color="black"> 480.         the :meth:`preprocess` method.</font>
<font color="black"> 481.         &quot;&quot;&quot;</font>
<font color="red"> 482.         source = text_type(source)</font>
<font color="red"> 483.         try:</font>
<font color="red"> 484.             return self.lexer.tokeniter(source, name, filename)</font>
<font color="red"> 485.         except TemplateSyntaxError:</font>
<font color="red"> 486.             exc_info = sys.exc_info()</font>
<font color="red"> 487.         self.handle_exception(exc_info, source_hint=source)</font>
<font color="black"> 488. </font>
<font color="green"> 489.     def preprocess(self, source, name=None, filename=None):</font>
<font color="black"> 490.         &quot;&quot;&quot;Preprocesses the source with all extensions.  This is automatically</font>
<font color="black"> 491.         called for all parsing and compiling methods but *not* for :meth:`lex`</font>
<font color="black"> 492.         because there you usually only want the actual source tokenized.</font>
<font color="black"> 493.         &quot;&quot;&quot;</font>
<font color="red"> 494.         return reduce(lambda s, e: e.preprocess(s, name, filename),</font>
<font color="red"> 495.                       self.iter_extensions(), text_type(source))</font>
<font color="black"> 496. </font>
<font color="green"> 497.     def _tokenize(self, source, name, filename=None, state=None):</font>
<font color="black"> 498.         &quot;&quot;&quot;Called by the parser to do the preprocessing and filtering</font>
<font color="black"> 499.         for all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`.</font>
<font color="black"> 500.         &quot;&quot;&quot;</font>
<font color="red"> 501.         source = self.preprocess(source, name, filename)</font>
<font color="red"> 502.         stream = self.lexer.tokenize(source, name, filename, state)</font>
<font color="red"> 503.         for ext in self.iter_extensions():</font>
<font color="red"> 504.             stream = ext.filter_stream(stream)</font>
<font color="red"> 505.             if not isinstance(stream, TokenStream):</font>
<font color="red"> 506.                 stream = TokenStream(stream, name, filename)</font>
<font color="red"> 507.         return stream</font>
<font color="black"> 508. </font>
<font color="green"> 509.     def _generate(self, source, name, filename, defer_init=False):</font>
<font color="black"> 510.         &quot;&quot;&quot;Internal hook that can be overridden to hook a different generate</font>
<font color="black"> 511.         method in.</font>
<font color="black"> 512. </font>
<font color="black"> 513.         .. versionadded:: 2.5</font>
<font color="black"> 514.         &quot;&quot;&quot;</font>
<font color="red"> 515.         return generate(source, self, name, filename, defer_init=defer_init)</font>
<font color="black"> 516. </font>
<font color="green"> 517.     def _compile(self, source, filename):</font>
<font color="black"> 518.         &quot;&quot;&quot;Internal hook that can be overridden to hook a different compile</font>
<font color="black"> 519.         method in.</font>
<font color="black"> 520. </font>
<font color="black"> 521.         .. versionadded:: 2.5</font>
<font color="black"> 522.         &quot;&quot;&quot;</font>
<font color="red"> 523.         return compile(source, filename, 'exec')</font>
<font color="black"> 524. </font>
<font color="green"> 525.     @internalcode</font>
<font color="green"> 526.     def compile(self, source, name=None, filename=None, raw=False,</font>
<font color="green"> 527.                 defer_init=False):</font>
<font color="black"> 528.         &quot;&quot;&quot;Compile a node or template source code.  The `name` parameter is</font>
<font color="black"> 529.         the load name of the template after it was joined using</font>
<font color="black"> 530.         :meth:`join_path` if necessary, not the filename on the file system.</font>
<font color="black"> 531.         the `filename` parameter is the estimated filename of the template on</font>
<font color="black"> 532.         the file system.  If the template came from a database or memory this</font>
<font color="black"> 533.         can be omitted.</font>
<font color="black"> 534. </font>
<font color="black"> 535.         The return value of this method is a python code object.  If the `raw`</font>
<font color="black"> 536.         parameter is `True` the return value will be a string with python</font>
<font color="black"> 537.         code equivalent to the bytecode returned otherwise.  This method is</font>
<font color="black"> 538.         mainly used internally.</font>
<font color="black"> 539. </font>
<font color="black"> 540.         `defer_init` is use internally to aid the module code generator.  This</font>
<font color="black"> 541.         causes the generated code to be able to import without the global</font>
<font color="black"> 542.         environment variable to be set.</font>
<font color="black"> 543. </font>
<font color="black"> 544.         .. versionadded:: 2.4</font>
<font color="black"> 545.            `defer_init` parameter added.</font>
<font color="black"> 546.         &quot;&quot;&quot;</font>
<font color="red"> 547.         source_hint = None</font>
<font color="red"> 548.         try:</font>
<font color="red"> 549.             if isinstance(source, string_types):</font>
<font color="red"> 550.                 source_hint = source</font>
<font color="red"> 551.                 source = self._parse(source, name, filename)</font>
<font color="red"> 552.             if self.optimized:</font>
<font color="red"> 553.                 source = optimize(source, self)</font>
<font color="red"> 554.             source = self._generate(source, name, filename,</font>
<font color="red"> 555.                                     defer_init=defer_init)</font>
<font color="red"> 556.             if raw:</font>
<font color="red"> 557.                 return source</font>
<font color="red"> 558.             if filename is None:</font>
<font color="red"> 559.                 filename = '&lt;template&gt;'</font>
<font color="black"> 560.             else:</font>
<font color="red"> 561.                 filename = encode_filename(filename)</font>
<font color="red"> 562.             return self._compile(source, filename)</font>
<font color="red"> 563.         except TemplateSyntaxError:</font>
<font color="red"> 564.             exc_info = sys.exc_info()</font>
<font color="red"> 565.         self.handle_exception(exc_info, source_hint=source_hint)</font>
<font color="black"> 566. </font>
<font color="green"> 567.     def compile_expression(self, source, undefined_to_none=True):</font>
<font color="black"> 568.         &quot;&quot;&quot;A handy helper method that returns a callable that accepts keyword</font>
<font color="black"> 569.         arguments that appear as variables in the expression.  If called it</font>
<font color="black"> 570.         returns the result of the expression.</font>
<font color="black"> 571. </font>
<font color="black"> 572.         This is useful if applications want to use the same rules as Jinja</font>
<font color="black"> 573.         in template &quot;configuration files&quot; or similar situations.</font>
<font color="black"> 574. </font>
<font color="black"> 575.         Example usage:</font>
<font color="black"> 576. </font>
<font color="black"> 577.         &gt;&gt;&gt; env = Environment()</font>
<font color="black"> 578.         &gt;&gt;&gt; expr = env.compile_expression('foo == 42')</font>
<font color="black"> 579.         &gt;&gt;&gt; expr(foo=23)</font>
<font color="black"> 580.         False</font>
<font color="black"> 581.         &gt;&gt;&gt; expr(foo=42)</font>
<font color="black"> 582.         True</font>
<font color="black"> 583. </font>
<font color="black"> 584.         Per default the return value is converted to `None` if the</font>
<font color="black"> 585.         expression returns an undefined value.  This can be changed</font>
<font color="black"> 586.         by setting `undefined_to_none` to `False`.</font>
<font color="black"> 587. </font>
<font color="black"> 588.         &gt;&gt;&gt; env.compile_expression('var')() is None</font>
<font color="black"> 589.         True</font>
<font color="black"> 590.         &gt;&gt;&gt; env.compile_expression('var', undefined_to_none=False)()</font>
<font color="black"> 591.         Undefined</font>
<font color="black"> 592. </font>
<font color="black"> 593.         .. versionadded:: 2.1</font>
<font color="black"> 594.         &quot;&quot;&quot;</font>
<font color="red"> 595.         parser = Parser(self, source, state='variable')</font>
<font color="red"> 596.         exc_info = None</font>
<font color="red"> 597.         try:</font>
<font color="red"> 598.             expr = parser.parse_expression()</font>
<font color="red"> 599.             if not parser.stream.eos:</font>
<font color="red"> 600.                 raise TemplateSyntaxError('chunk after expression',</font>
<font color="red"> 601.                                           parser.stream.current.lineno,</font>
<font color="red"> 602.                                           None, None)</font>
<font color="red"> 603.             expr.set_environment(self)</font>
<font color="red"> 604.         except TemplateSyntaxError:</font>
<font color="red"> 605.             exc_info = sys.exc_info()</font>
<font color="red"> 606.         if exc_info is not None:</font>
<font color="red"> 607.             self.handle_exception(exc_info, source_hint=source)</font>
<font color="red"> 608.         body = [nodes.Assign(nodes.Name('result', 'store'), expr, lineno=1)]</font>
<font color="red"> 609.         template = self.from_string(nodes.Template(body, lineno=1))</font>
<font color="red"> 610.         return TemplateExpression(template, undefined_to_none)</font>
<font color="black"> 611. </font>
<font color="green"> 612.     def compile_templates(self, target, extensions=None, filter_func=None,</font>
<font color="green"> 613.                           zip='deflated', log_function=None,</font>
<font color="green"> 614.                           ignore_errors=True, py_compile=False):</font>
<font color="black"> 615.         &quot;&quot;&quot;Finds all the templates the loader can find, compiles them</font>
<font color="black"> 616.         and stores them in `target`.  If `zip` is `None`, instead of in a</font>
<font color="black"> 617.         zipfile, the templates will be stored in a directory.</font>
<font color="black"> 618.         By default a deflate zip algorithm is used. To switch to</font>
<font color="black"> 619.         the stored algorithm, `zip` can be set to ``'stored'``.</font>
<font color="black"> 620. </font>
<font color="black"> 621.         `extensions` and `filter_func` are passed to :meth:`list_templates`.</font>
<font color="black"> 622.         Each template returned will be compiled to the target folder or</font>
<font color="black"> 623.         zipfile.</font>
<font color="black"> 624. </font>
<font color="black"> 625.         By default template compilation errors are ignored.  In case a</font>
<font color="black"> 626.         log function is provided, errors are logged.  If you want template</font>
<font color="black"> 627.         syntax errors to abort the compilation you can set `ignore_errors`</font>
<font color="black"> 628.         to `False` and you will get an exception on syntax errors.</font>
<font color="black"> 629. </font>
<font color="black"> 630.         If `py_compile` is set to `True` .pyc files will be written to the</font>
<font color="black"> 631.         target instead of standard .py files.  This flag does not do anything</font>
<font color="black"> 632.         on pypy and Python 3 where pyc files are not picked up by itself and</font>
<font color="black"> 633.         don't give much benefit.</font>
<font color="black"> 634. </font>
<font color="black"> 635.         .. versionadded:: 2.4</font>
<font color="black"> 636.         &quot;&quot;&quot;</font>
<font color="red"> 637.         from jinja2.loaders import ModuleLoader</font>
<font color="black"> 638. </font>
<font color="red"> 639.         if log_function is None:</font>
<font color="red"> 640.             log_function = lambda x: None</font>
<font color="black"> 641. </font>
<font color="red"> 642.         if py_compile:</font>
<font color="red"> 643.             if not PY2 or PYPY:</font>
<font color="red"> 644.                 from warnings import warn</font>
<font color="red"> 645.                 warn(Warning('py_compile has no effect on pypy or Python 3'))</font>
<font color="red"> 646.                 py_compile = False</font>
<font color="black"> 647.             else:</font>
<font color="red"> 648.                 import imp</font>
<font color="red"> 649.                 import marshal</font>
<font color="red"> 650.                 py_header = imp.get_magic() + \</font>
<font color="red"> 651.                     u'\xff\xff\xff\xff'.encode('iso-8859-15')</font>
<font color="black"> 652. </font>
<font color="black"> 653.                 # Python 3.3 added a source filesize to the header</font>
<font color="red"> 654.                 if sys.version_info &gt;= (3, 3):</font>
<font color="red"> 655.                     py_header += u'\x00\x00\x00\x00'.encode('iso-8859-15')</font>
<font color="black"> 656. </font>
<font color="red"> 657.         def write_file(filename, data, mode):</font>
<font color="red"> 658.             if zip:</font>
<font color="red"> 659.                 info = ZipInfo(filename)</font>
<font color="red"> 660.                 info.external_attr = 0o755 &lt;&lt; 16</font>
<font color="red"> 661.                 zip_file.writestr(info, data)</font>
<font color="black"> 662.             else:</font>
<font color="red"> 663.                 f = open(os.path.join(target, filename), mode)</font>
<font color="red"> 664.                 try:</font>
<font color="red"> 665.                     f.write(data)</font>
<font color="black"> 666.                 finally:</font>
<font color="red"> 667.                     f.close()</font>
<font color="black"> 668. </font>
<font color="red"> 669.         if zip is not None:</font>
<font color="red"> 670.             from zipfile import ZipFile, ZipInfo, ZIP_DEFLATED, ZIP_STORED</font>
<font color="red"> 671.             zip_file = ZipFile(target, 'w', dict(deflated=ZIP_DEFLATED,</font>
<font color="red"> 672.                                                  stored=ZIP_STORED)[zip])</font>
<font color="red"> 673.             log_function('Compiling into Zip archive &quot;%s&quot;' % target)</font>
<font color="black"> 674.         else:</font>
<font color="red"> 675.             if not os.path.isdir(target):</font>
<font color="red"> 676.                 os.makedirs(target)</font>
<font color="red"> 677.             log_function('Compiling into folder &quot;%s&quot;' % target)</font>
<font color="black"> 678. </font>
<font color="red"> 679.         try:</font>
<font color="red"> 680.             for name in self.list_templates(extensions, filter_func):</font>
<font color="red"> 681.                 source, filename, _ = self.loader.get_source(self, name)</font>
<font color="red"> 682.                 try:</font>
<font color="red"> 683.                     code = self.compile(source, name, filename, True, True)</font>
<font color="red"> 684.                 except TemplateSyntaxError as e:</font>
<font color="red"> 685.                     if not ignore_errors:</font>
<font color="red"> 686.                         raise</font>
<font color="red"> 687.                     log_function('Could not compile &quot;%s&quot;: %s' % (name, e))</font>
<font color="red"> 688.                     continue</font>
<font color="black"> 689. </font>
<font color="red"> 690.                 filename = ModuleLoader.get_module_filename(name)</font>
<font color="black"> 691. </font>
<font color="red"> 692.                 if py_compile:</font>
<font color="red"> 693.                     c = self._compile(code, encode_filename(filename))</font>
<font color="red"> 694.                     write_file(filename + 'c', py_header +</font>
<font color="red"> 695.                                marshal.dumps(c), 'wb')</font>
<font color="red"> 696.                     log_function('Byte-compiled &quot;%s&quot; as %s' %</font>
<font color="red"> 697.                                  (name, filename + 'c'))</font>
<font color="black"> 698.                 else:</font>
<font color="red"> 699.                     write_file(filename, code, 'w')</font>
<font color="red"> 700.                     log_function('Compiled &quot;%s&quot; as %s' % (name, filename))</font>
<font color="black"> 701.         finally:</font>
<font color="red"> 702.             if zip:</font>
<font color="red"> 703.                 zip_file.close()</font>
<font color="black"> 704. </font>
<font color="red"> 705.         log_function('Finished compiling templates')</font>
<font color="black"> 706. </font>
<font color="green"> 707.     def list_templates(self, extensions=None, filter_func=None):</font>
<font color="black"> 708.         &quot;&quot;&quot;Returns a list of templates for this environment.  This requires</font>
<font color="black"> 709.         that the loader supports the loader's</font>
<font color="black"> 710.         :meth:`~BaseLoader.list_templates` method.</font>
<font color="black"> 711. </font>
<font color="black"> 712.         If there are other files in the template folder besides the</font>
<font color="black"> 713.         actual templates, the returned list can be filtered.  There are two</font>
<font color="black"> 714.         ways: either `extensions` is set to a list of file extensions for</font>
<font color="black"> 715.         templates, or a `filter_func` can be provided which is a callable that</font>
<font color="black"> 716.         is passed a template name and should return `True` if it should end up</font>
<font color="black"> 717.         in the result list.</font>
<font color="black"> 718. </font>
<font color="black"> 719.         If the loader does not support that, a :exc:`TypeError` is raised.</font>
<font color="black"> 720. </font>
<font color="black"> 721.         .. versionadded:: 2.4</font>
<font color="black"> 722.         &quot;&quot;&quot;</font>
<font color="red"> 723.         x = self.loader.list_templates()</font>
<font color="red"> 724.         if extensions is not None:</font>
<font color="red"> 725.             if filter_func is not None:</font>
<font color="red"> 726.                 raise TypeError('either extensions or filter_func '</font>
<font color="black"> 727.                                 'can be passed, but not both')</font>
<font color="red"> 728.             filter_func = lambda x: '.' in x and \</font>
<font color="red"> 729.                                     x.rsplit('.', 1)[1] in extensions</font>
<font color="red"> 730.         if filter_func is not None:</font>
<font color="red"> 731.             x = list(ifilter(filter_func, x))</font>
<font color="red"> 732.         return x</font>
<font color="black"> 733. </font>
<font color="green"> 734.     def handle_exception(self, exc_info=None, rendered=False, source_hint=None):</font>
<font color="black"> 735.         &quot;&quot;&quot;Exception handling helper.  This is used internally to either raise</font>
<font color="black"> 736.         rewritten exceptions or return a rendered traceback for the template.</font>
<font color="black"> 737.         &quot;&quot;&quot;</font>
<font color="black"> 738.         global _make_traceback</font>
<font color="red"> 739.         if exc_info is None:</font>
<font color="red"> 740.             exc_info = sys.exc_info()</font>
<font color="black"> 741. </font>
<font color="black"> 742.         # the debugging module is imported when it's used for the first time.</font>
<font color="black"> 743.         # we're doing a lot of stuff there and for applications that do not</font>
<font color="black"> 744.         # get any exceptions in template rendering there is no need to load</font>
<font color="black"> 745.         # all of that.</font>
<font color="red"> 746.         if _make_traceback is None:</font>
<font color="red"> 747.             from jinja2.debug import make_traceback as _make_traceback</font>
<font color="red"> 748.         traceback = _make_traceback(exc_info, source_hint)</font>
<font color="red"> 749.         if rendered and self.exception_formatter is not None:</font>
<font color="red"> 750.             return self.exception_formatter(traceback)</font>
<font color="red"> 751.         if self.exception_handler is not None:</font>
<font color="red"> 752.             self.exception_handler(traceback)</font>
<font color="red"> 753.         exc_type, exc_value, tb = traceback.standard_exc_info</font>
<font color="red"> 754.         reraise(exc_type, exc_value, tb)</font>
<font color="black"> 755. </font>
<font color="green"> 756.     def join_path(self, template, parent):</font>
<font color="black"> 757.         &quot;&quot;&quot;Join a template with the parent.  By default all the lookups are</font>
<font color="black"> 758.         relative to the loader root so this method returns the `template`</font>
<font color="black"> 759.         parameter unchanged, but if the paths should be relative to the</font>
<font color="black"> 760.         parent template, this function can be used to calculate the real</font>
<font color="black"> 761.         template name.</font>
<font color="black"> 762. </font>
<font color="black"> 763.         Subclasses may override this method and implement template path</font>
<font color="black"> 764.         joining here.</font>
<font color="black"> 765.         &quot;&quot;&quot;</font>
<font color="red"> 766.         return template</font>
<font color="black"> 767. </font>
<font color="green"> 768.     @internalcode</font>
<font color="black"> 769.     def _load_template(self, name, globals):</font>
<font color="red"> 770.         if self.loader is None:</font>
<font color="red"> 771.             raise TypeError('no loader for this environment specified')</font>
<font color="red"> 772.         try:</font>
<font color="black"> 773.             # use abs path for cache key</font>
<font color="red"> 774.             cache_key = self.loader.get_source(self, name)[1]</font>
<font color="red"> 775.         except RuntimeError:</font>
<font color="black"> 776.             # if loader does not implement get_source()</font>
<font color="red"> 777.             cache_key = None</font>
<font color="black"> 778.         # if template is not file, use name for cache key</font>
<font color="red"> 779.         if cache_key is None:</font>
<font color="red"> 780.             cache_key = name</font>
<font color="red"> 781.         if self.cache is not None:</font>
<font color="red"> 782.             template = self.cache.get(cache_key)</font>
<font color="red"> 783.             if template is not None and (not self.auto_reload or</font>
<font color="red"> 784.                                          template.is_up_to_date):</font>
<font color="red"> 785.                 return template</font>
<font color="red"> 786.         template = self.loader.load(self, name, globals)</font>
<font color="red"> 787.         if self.cache is not None:</font>
<font color="red"> 788.             self.cache[cache_key] = template</font>
<font color="red"> 789.         return template</font>
<font color="black"> 790. </font>
<font color="green"> 791.     @internalcode</font>
<font color="green"> 792.     def get_template(self, name, parent=None, globals=None):</font>
<font color="black"> 793.         &quot;&quot;&quot;Load a template from the loader.  If a loader is configured this</font>
<font color="black"> 794.         method ask the loader for the template and returns a :class:`Template`.</font>
<font color="black"> 795.         If the `parent` parameter is not `None`, :meth:`join_path` is called</font>
<font color="black"> 796.         to get the real template name before loading.</font>
<font color="black"> 797. </font>
<font color="black"> 798.         The `globals` parameter can be used to provide template wide globals.</font>
<font color="black"> 799.         These variables are available in the context at render time.</font>
<font color="black"> 800. </font>
<font color="black"> 801.         If the template does not exist a :exc:`TemplateNotFound` exception is</font>
<font color="black"> 802.         raised.</font>
<font color="black"> 803. </font>
<font color="black"> 804.         .. versionchanged:: 2.4</font>
<font color="black"> 805.            If `name` is a :class:`Template` object it is returned from the</font>
<font color="black"> 806.            function unchanged.</font>
<font color="black"> 807.         &quot;&quot;&quot;</font>
<font color="red"> 808.         if isinstance(name, Template):</font>
<font color="red"> 809.             return name</font>
<font color="red"> 810.         if parent is not None:</font>
<font color="red"> 811.             name = self.join_path(name, parent)</font>
<font color="red"> 812.         return self._load_template(name, self.make_globals(globals))</font>
<font color="black"> 813. </font>
<font color="green"> 814.     @internalcode</font>
<font color="green"> 815.     def select_template(self, names, parent=None, globals=None):</font>
<font color="black"> 816.         &quot;&quot;&quot;Works like :meth:`get_template` but tries a number of templates</font>
<font color="black"> 817.         before it fails.  If it cannot find any of the templates, it will</font>
<font color="black"> 818.         raise a :exc:`TemplatesNotFound` exception.</font>
<font color="black"> 819. </font>
<font color="black"> 820.         .. versionadded:: 2.3</font>
<font color="black"> 821. </font>
<font color="black"> 822.         .. versionchanged:: 2.4</font>
<font color="black"> 823.            If `names` contains a :class:`Template` object it is returned</font>
<font color="black"> 824.            from the function unchanged.</font>
<font color="black"> 825.         &quot;&quot;&quot;</font>
<font color="red"> 826.         if not names:</font>
<font color="red"> 827.             raise TemplatesNotFound(message=u'Tried to select from an empty list '</font>
<font color="black"> 828.                                             u'of templates.')</font>
<font color="red"> 829.         globals = self.make_globals(globals)</font>
<font color="red"> 830.         for name in names:</font>
<font color="red"> 831.             if isinstance(name, Template):</font>
<font color="red"> 832.                 return name</font>
<font color="red"> 833.             if parent is not None:</font>
<font color="red"> 834.                 name = self.join_path(name, parent)</font>
<font color="red"> 835.             try:</font>
<font color="red"> 836.                 return self._load_template(name, globals)</font>
<font color="red"> 837.             except TemplateNotFound:</font>
<font color="red"> 838.                 pass</font>
<font color="red"> 839.         raise TemplatesNotFound(names)</font>
<font color="black"> 840. </font>
<font color="green"> 841.     @internalcode</font>
<font color="black"> 842.     def get_or_select_template(self, template_name_or_list,</font>
<font color="green"> 843.                                parent=None, globals=None):</font>
<font color="black"> 844.         &quot;&quot;&quot;Does a typecheck and dispatches to :meth:`select_template`</font>
<font color="black"> 845.         if an iterable of template names is given, otherwise to</font>
<font color="black"> 846.         :meth:`get_template`.</font>
<font color="black"> 847. </font>
<font color="black"> 848.         .. versionadded:: 2.3</font>
<font color="black"> 849.         &quot;&quot;&quot;</font>
<font color="red"> 850.         if isinstance(template_name_or_list, string_types):</font>
<font color="red"> 851.             return self.get_template(template_name_or_list, parent, globals)</font>
<font color="red"> 852.         elif isinstance(template_name_or_list, Template):</font>
<font color="red"> 853.             return template_name_or_list</font>
<font color="red"> 854.         return self.select_template(template_name_or_list, parent, globals)</font>
<font color="black"> 855. </font>
<font color="green"> 856.     def from_string(self, source, globals=None, template_class=None):</font>
<font color="black"> 857.         &quot;&quot;&quot;Load a template from a string.  This parses the source given and</font>
<font color="black"> 858.         returns a :class:`Template` object.</font>
<font color="black"> 859.         &quot;&quot;&quot;</font>
<font color="red"> 860.         globals = self.make_globals(globals)</font>
<font color="red"> 861.         cls = template_class or self.template_class</font>
<font color="red"> 862.         return cls.from_code(self, self.compile(source), globals, None)</font>
<font color="black"> 863. </font>
<font color="green"> 864.     def make_globals(self, d):</font>
<font color="black"> 865.         &quot;&quot;&quot;Return a dict for the globals.&quot;&quot;&quot;</font>
<font color="red"> 866.         if not d:</font>
<font color="red"> 867.             return self.globals</font>
<font color="red"> 868.         return dict(self.globals, **d)</font>
<font color="black"> 869. </font>
<font color="black"> 870. </font>
<font color="green"> 871. class Template(object):</font>
<font color="black"> 872.     &quot;&quot;&quot;The central template object.  This class represents a compiled template</font>
<font color="black"> 873.     and is used to evaluate it.</font>
<font color="black"> 874. </font>
<font color="black"> 875.     Normally the template object is generated from an :class:`Environment` but</font>
<font color="black"> 876.     it also has a constructor that makes it possible to create a template</font>
<font color="black"> 877.     instance directly using the constructor.  It takes the same arguments as</font>
<font color="black"> 878.     the environment constructor but it's not possible to specify a loader.</font>
<font color="black"> 879. </font>
<font color="black"> 880.     Every template object has a few methods and members that are guaranteed</font>
<font color="black"> 881.     to exist.  However it's important that a template object should be</font>
<font color="black"> 882.     considered immutable.  Modifications on the object are not supported.</font>
<font color="black"> 883. </font>
<font color="black"> 884.     Template objects created from the constructor rather than an environment</font>
<font color="black"> 885.     do have an `environment` attribute that points to a temporary environment</font>
<font color="black"> 886.     that is probably shared with other templates created with the constructor</font>
<font color="black"> 887.     and compatible settings.</font>
<font color="black"> 888. </font>
<font color="black"> 889.     &gt;&gt;&gt; template = Template('Hello {{ name }}!')</font>
<font color="black"> 890.     &gt;&gt;&gt; template.render(name='John Doe') == u'Hello John Doe!'</font>
<font color="black"> 891.     True</font>
<font color="black"> 892.     &gt;&gt;&gt; stream = template.stream(name='John Doe')</font>
<font color="black"> 893.     &gt;&gt;&gt; next(stream) == u'Hello John Doe!'</font>
<font color="black"> 894.     True</font>
<font color="black"> 895.     &gt;&gt;&gt; next(stream)</font>
<font color="black"> 896.     Traceback (most recent call last):</font>
<font color="black"> 897.         ...</font>
<font color="black"> 898.     StopIteration</font>
<font color="green"> 899.     &quot;&quot;&quot;</font>
<font color="black"> 900. </font>
<font color="black"> 901.     def __new__(cls, source,</font>
<font color="green"> 902.                 block_start_string=BLOCK_START_STRING,</font>
<font color="green"> 903.                 block_end_string=BLOCK_END_STRING,</font>
<font color="green"> 904.                 variable_start_string=VARIABLE_START_STRING,</font>
<font color="green"> 905.                 variable_end_string=VARIABLE_END_STRING,</font>
<font color="green"> 906.                 comment_start_string=COMMENT_START_STRING,</font>
<font color="green"> 907.                 comment_end_string=COMMENT_END_STRING,</font>
<font color="green"> 908.                 line_statement_prefix=LINE_STATEMENT_PREFIX,</font>
<font color="green"> 909.                 line_comment_prefix=LINE_COMMENT_PREFIX,</font>
<font color="green"> 910.                 trim_blocks=TRIM_BLOCKS,</font>
<font color="green"> 911.                 lstrip_blocks=LSTRIP_BLOCKS,</font>
<font color="green"> 912.                 newline_sequence=NEWLINE_SEQUENCE,</font>
<font color="green"> 913.                 keep_trailing_newline=KEEP_TRAILING_NEWLINE,</font>
<font color="green"> 914.                 extensions=(),</font>
<font color="green"> 915.                 optimized=True,</font>
<font color="green"> 916.                 undefined=Undefined,</font>
<font color="green"> 917.                 finalize=None,</font>
<font color="green"> 918.                 autoescape=False):</font>
<font color="red"> 919.         env = get_spontaneous_environment(</font>
<font color="red"> 920.             block_start_string, block_end_string, variable_start_string,</font>
<font color="red"> 921.             variable_end_string, comment_start_string, comment_end_string,</font>
<font color="red"> 922.             line_statement_prefix, line_comment_prefix, trim_blocks,</font>
<font color="red"> 923.             lstrip_blocks, newline_sequence, keep_trailing_newline,</font>
<font color="red"> 924.             frozenset(extensions), optimized, undefined, finalize, autoescape,</font>
<font color="red"> 925.             None, 0, False, None)</font>
<font color="red"> 926.         return env.from_string(source, template_class=cls)</font>
<font color="black"> 927. </font>
<font color="green"> 928.     @classmethod</font>
<font color="green"> 929.     def from_code(cls, environment, code, globals, uptodate=None):</font>
<font color="black"> 930.         &quot;&quot;&quot;Creates a template object from compiled code and the globals.  This</font>
<font color="black"> 931.         is used by the loaders and environment to create a template object.</font>
<font color="black"> 932.         &quot;&quot;&quot;</font>
<font color="red"> 933.         namespace = {</font>
<font color="red"> 934.             'environment':  environment,</font>
<font color="red"> 935.             '__file__':     code.co_filename</font>
<font color="black"> 936.         }</font>
<font color="red"> 937.         exec(code, namespace)</font>
<font color="red"> 938.         rv = cls._from_namespace(environment, namespace, globals)</font>
<font color="red"> 939.         rv._uptodate = uptodate</font>
<font color="red"> 940.         return rv</font>
<font color="black"> 941. </font>
<font color="green"> 942.     @classmethod</font>
<font color="black"> 943.     def from_module_dict(cls, environment, module_dict, globals):</font>
<font color="black"> 944.         &quot;&quot;&quot;Creates a template object from a module.  This is used by the</font>
<font color="black"> 945.         module loader to create a template object.</font>
<font color="black"> 946. </font>
<font color="black"> 947.         .. versionadded:: 2.4</font>
<font color="black"> 948.         &quot;&quot;&quot;</font>
<font color="red"> 949.         return cls._from_namespace(environment, module_dict, globals)</font>
<font color="black"> 950. </font>
<font color="green"> 951.     @classmethod</font>
<font color="black"> 952.     def _from_namespace(cls, environment, namespace, globals):</font>
<font color="red"> 953.         t = object.__new__(cls)</font>
<font color="red"> 954.         t.environment = environment</font>
<font color="red"> 955.         t.globals = globals</font>
<font color="red"> 956.         t.name = namespace['name']</font>
<font color="red"> 957.         t.filename = namespace['__file__']</font>
<font color="red"> 958.         t.blocks = namespace['blocks']</font>
<font color="black"> 959. </font>
<font color="black"> 960.         # render function and module</font>
<font color="red"> 961.         t.root_render_func = namespace['root']</font>
<font color="red"> 962.         t._module = None</font>
<font color="black"> 963. </font>
<font color="black"> 964.         # debug and loader helpers</font>
<font color="red"> 965.         t._debug_info = namespace['debug_info']</font>
<font color="red"> 966.         t._uptodate = None</font>
<font color="black"> 967. </font>
<font color="black"> 968.         # store the reference</font>
<font color="red"> 969.         namespace['environment'] = environment</font>
<font color="red"> 970.         namespace['__jinja_template__'] = t</font>
<font color="black"> 971. </font>
<font color="red"> 972.         return t</font>
<font color="black"> 973. </font>
<font color="green"> 974.     def render(self, *args, **kwargs):</font>
<font color="black"> 975.         &quot;&quot;&quot;This method accepts the same arguments as the `dict` constructor:</font>
<font color="black"> 976.         A dict, a dict subclass or some keyword arguments.  If no arguments</font>
<font color="black"> 977.         are given the context will be empty.  These two calls do the same::</font>
<font color="black"> 978. </font>
<font color="black"> 979.             template.render(knights='that say nih')</font>
<font color="black"> 980.             template.render({'knights': 'that say nih'})</font>
<font color="black"> 981. </font>
<font color="black"> 982.         This will return the rendered template as unicode string.</font>
<font color="black"> 983.         &quot;&quot;&quot;</font>
<font color="red"> 984.         vars = dict(*args, **kwargs)</font>
<font color="red"> 985.         try:</font>
<font color="red"> 986.             return concat(self.root_render_func(self.new_context(vars)))</font>
<font color="red"> 987.         except Exception:</font>
<font color="red"> 988.             exc_info = sys.exc_info()</font>
<font color="red"> 989.         return self.environment.handle_exception(exc_info, True)</font>
<font color="black"> 990. </font>
<font color="green"> 991.     def stream(self, *args, **kwargs):</font>
<font color="black"> 992.         &quot;&quot;&quot;Works exactly like :meth:`generate` but returns a</font>
<font color="black"> 993.         :class:`TemplateStream`.</font>
<font color="black"> 994.         &quot;&quot;&quot;</font>
<font color="red"> 995.         return TemplateStream(self.generate(*args, **kwargs))</font>
<font color="black"> 996. </font>
<font color="green"> 997.     def generate(self, *args, **kwargs):</font>
<font color="black"> 998.         &quot;&quot;&quot;For very large templates it can be useful to not render the whole</font>
<font color="black"> 999.         template at once but evaluate each statement after another and yield</font>
<font color="black">1000.         piece for piece.  This method basically does exactly that and returns</font>
<font color="black">1001.         a generator that yields one item after another as unicode strings.</font>
<font color="black">1002. </font>
<font color="black">1003.         It accepts the same arguments as :meth:`render`.</font>
<font color="black">1004.         &quot;&quot;&quot;</font>
<font color="red">1005.         vars = dict(*args, **kwargs)</font>
<font color="red">1006.         try:</font>
<font color="red">1007.             for event in self.root_render_func(self.new_context(vars)):</font>
<font color="red">1008.                 yield event</font>
<font color="red">1009.         except Exception:</font>
<font color="red">1010.             exc_info = sys.exc_info()</font>
<font color="black">1011.         else:</font>
<font color="red">1012.             return</font>
<font color="red">1013.         yield self.environment.handle_exception(exc_info, True)</font>
<font color="black">1014. </font>
<font color="green">1015.     def new_context(self, vars=None, shared=False, locals=None):</font>
<font color="black">1016.         &quot;&quot;&quot;Create a new :class:`Context` for this template.  The vars</font>
<font color="black">1017.         provided will be passed to the template.  Per default the globals</font>
<font color="black">1018.         are added to the context.  If shared is set to `True` the data</font>
<font color="black">1019.         is passed as it to the context without adding the globals.</font>
<font color="black">1020. </font>
<font color="black">1021.         `locals` can be a dict of local variables for internal usage.</font>
<font color="black">1022.         &quot;&quot;&quot;</font>
<font color="red">1023.         return new_context(self.environment, self.name, self.blocks,</font>
<font color="red">1024.                            vars, shared, self.globals, locals)</font>
<font color="black">1025. </font>
<font color="green">1026.     def make_module(self, vars=None, shared=False, locals=None):</font>
<font color="black">1027.         &quot;&quot;&quot;This method works like the :attr:`module` attribute when called</font>
<font color="black">1028.         without arguments but it will evaluate the template on every call</font>
<font color="black">1029.         rather than caching it.  It's also possible to provide</font>
<font color="black">1030.         a dict which is then used as context.  The arguments are the same</font>
<font color="black">1031.         as for the :meth:`new_context` method.</font>
<font color="black">1032.         &quot;&quot;&quot;</font>
<font color="red">1033.         return TemplateModule(self, self.new_context(vars, shared, locals))</font>
<font color="black">1034. </font>
<font color="green">1035.     @property</font>
<font color="black">1036.     def module(self):</font>
<font color="black">1037.         &quot;&quot;&quot;The template as module.  This is used for imports in the</font>
<font color="black">1038.         template runtime but is also useful if one wants to access</font>
<font color="black">1039.         exported template variables from the Python layer:</font>
<font color="black">1040. </font>
<font color="black">1041.         &gt;&gt;&gt; t = Template('{% macro foo() %}42{% endmacro %}23')</font>
<font color="black">1042.         &gt;&gt;&gt; str(t.module)</font>
<font color="black">1043.         '23'</font>
<font color="black">1044.         &gt;&gt;&gt; t.module.foo() == u'42'</font>
<font color="black">1045.         True</font>
<font color="black">1046.         &quot;&quot;&quot;</font>
<font color="red">1047.         if self._module is not None:</font>
<font color="red">1048.             return self._module</font>
<font color="red">1049.         self._module = rv = self.make_module()</font>
<font color="red">1050.         return rv</font>
<font color="black">1051. </font>
<font color="green">1052.     def get_corresponding_lineno(self, lineno):</font>
<font color="black">1053.         &quot;&quot;&quot;Return the source line number of a line number in the</font>
<font color="black">1054.         generated bytecode as they are not in sync.</font>
<font color="black">1055.         &quot;&quot;&quot;</font>
<font color="red">1056.         for template_line, code_line in reversed(self.debug_info):</font>
<font color="red">1057.             if code_line &lt;= lineno:</font>
<font color="red">1058.                 return template_line</font>
<font color="red">1059.         return 1</font>
<font color="black">1060. </font>
<font color="green">1061.     @property</font>
<font color="black">1062.     def is_up_to_date(self):</font>
<font color="black">1063.         &quot;&quot;&quot;If this variable is `False` there is a newer version available.&quot;&quot;&quot;</font>
<font color="red">1064.         if self._uptodate is None:</font>
<font color="red">1065.             return True</font>
<font color="red">1066.         return self._uptodate()</font>
<font color="black">1067. </font>
<font color="green">1068.     @property</font>
<font color="black">1069.     def debug_info(self):</font>
<font color="black">1070.         &quot;&quot;&quot;The debug info mapping.&quot;&quot;&quot;</font>
<font color="red">1071.         return [tuple(imap(int, x.split('='))) for x in</font>
<font color="red">1072.                 self._debug_info.split('&amp;')]</font>
<font color="black">1073. </font>
<font color="green">1074.     def __repr__(self):</font>
<font color="red">1075.         if self.name is None:</font>
<font color="red">1076.             name = 'memory:%x' % id(self)</font>
<font color="black">1077.         else:</font>
<font color="red">1078.             name = repr(self.name)</font>
<font color="red">1079.         return '&lt;%s %s&gt;' % (self.__class__.__name__, name)</font>
<font color="black">1080. </font>
<font color="black">1081. </font>
<font color="green">1082. @implements_to_string</font>
<font color="green">1083. class TemplateModule(object):</font>
<font color="black">1084.     &quot;&quot;&quot;Represents an imported template.  All the exported names of the</font>
<font color="black">1085.     template are available as attributes on this object.  Additionally</font>
<font color="black">1086.     converting it into an unicode- or bytestrings renders the contents.</font>
<font color="green">1087.     &quot;&quot;&quot;</font>
<font color="black">1088. </font>
<font color="green">1089.     def __init__(self, template, context):</font>
<font color="red">1090.         self._body_stream = list(template.root_render_func(context))</font>
<font color="red">1091.         self.__dict__.update(context.get_exported())</font>
<font color="red">1092.         self.__name__ = template.name</font>
<font color="black">1093. </font>
<font color="green">1094.     def __html__(self):</font>
<font color="red">1095.         return Markup(concat(self._body_stream))</font>
<font color="black">1096. </font>
<font color="green">1097.     def __str__(self):</font>
<font color="red">1098.         return concat(self._body_stream)</font>
<font color="black">1099. </font>
<font color="green">1100.     def __repr__(self):</font>
<font color="red">1101.         if self.__name__ is None:</font>
<font color="red">1102.             name = 'memory:%x' % id(self)</font>
<font color="black">1103.         else:</font>
<font color="red">1104.             name = repr(self.__name__)</font>
<font color="red">1105.         return '&lt;%s %s&gt;' % (self.__class__.__name__, name)</font>
<font color="black">1106. </font>
<font color="black">1107. </font>
<font color="green">1108. class TemplateExpression(object):</font>
<font color="black">1109.     &quot;&quot;&quot;The :meth:`jinja2.Environment.compile_expression` method returns an</font>
<font color="black">1110.     instance of this object.  It encapsulates the expression-like access</font>
<font color="black">1111.     to the template with an expression it wraps.</font>
<font color="green">1112.     &quot;&quot;&quot;</font>
<font color="black">1113. </font>
<font color="green">1114.     def __init__(self, template, undefined_to_none):</font>
<font color="red">1115.         self._template = template</font>
<font color="red">1116.         self._undefined_to_none = undefined_to_none</font>
<font color="black">1117. </font>
<font color="green">1118.     def __call__(self, *args, **kwargs):</font>
<font color="red">1119.         context = self._template.new_context(dict(*args, **kwargs))</font>
<font color="red">1120.         consume(self._template.root_render_func(context))</font>
<font color="red">1121.         rv = context.vars['result']</font>
<font color="red">1122.         if self._undefined_to_none and isinstance(rv, Undefined):</font>
<font color="red">1123.             rv = None</font>
<font color="red">1124.         return rv</font>
<font color="black">1125. </font>
<font color="black">1126. </font>
<font color="green">1127. @implements_iterator</font>
<font color="green">1128. class TemplateStream(object):</font>
<font color="black">1129.     &quot;&quot;&quot;A template stream works pretty much like an ordinary python generator</font>
<font color="black">1130.     but it can buffer multiple items to reduce the number of total iterations.</font>
<font color="black">1131.     Per default the output is unbuffered which means that for every unbuffered</font>
<font color="black">1132.     instruction in the template one unicode string is yielded.</font>
<font color="black">1133. </font>
<font color="black">1134.     If buffering is enabled with a buffer size of 5, five items are combined</font>
<font color="black">1135.     into a new unicode string.  This is mainly useful if you are streaming</font>
<font color="black">1136.     big templates to a client via WSGI which flushes after each iteration.</font>
<font color="green">1137.     &quot;&quot;&quot;</font>
<font color="black">1138. </font>
<font color="green">1139.     def __init__(self, gen):</font>
<font color="red">1140.         self._gen = gen</font>
<font color="red">1141.         self.disable_buffering()</font>
<font color="black">1142. </font>
<font color="green">1143.     def dump(self, fp, encoding=None, errors='strict'):</font>
<font color="black">1144.         &quot;&quot;&quot;Dump the complete stream into a file or file-like object.</font>
<font color="black">1145.         Per default unicode strings are written, if you want to encode</font>
<font color="black">1146.         before writing specify an `encoding`.</font>
<font color="black">1147. </font>
<font color="black">1148.         Example usage::</font>
<font color="black">1149. </font>
<font color="black">1150.             Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')</font>
<font color="black">1151.         &quot;&quot;&quot;</font>
<font color="red">1152.         close = False</font>
<font color="red">1153.         if isinstance(fp, string_types):</font>
<font color="red">1154.             if encoding is None:</font>
<font color="red">1155.                 encoding = 'utf-8'</font>
<font color="red">1156.             fp = open(fp, 'wb')</font>
<font color="red">1157.             close = True</font>
<font color="red">1158.         try:</font>
<font color="red">1159.             if encoding is not None:</font>
<font color="red">1160.                 iterable = (x.encode(encoding, errors) for x in self)</font>
<font color="black">1161.             else:</font>
<font color="red">1162.                 iterable = self</font>
<font color="red">1163.             if hasattr(fp, 'writelines'):</font>
<font color="red">1164.                 fp.writelines(iterable)</font>
<font color="black">1165.             else:</font>
<font color="red">1166.                 for item in iterable:</font>
<font color="red">1167.                     fp.write(item)</font>
<font color="black">1168.         finally:</font>
<font color="red">1169.             if close:</font>
<font color="red">1170.                 fp.close()</font>
<font color="black">1171. </font>
<font color="green">1172.     def disable_buffering(self):</font>
<font color="black">1173.         &quot;&quot;&quot;Disable the output buffering.&quot;&quot;&quot;</font>
<font color="red">1174.         self._next = get_next(self._gen)</font>
<font color="red">1175.         self.buffered = False</font>
<font color="black">1176. </font>
<font color="green">1177.     def enable_buffering(self, size=5):</font>
<font color="black">1178.         &quot;&quot;&quot;Enable buffering.  Buffer `size` items before yielding them.&quot;&quot;&quot;</font>
<font color="red">1179.         if size &lt;= 1:</font>
<font color="red">1180.             raise ValueError('buffer size too small')</font>
<font color="black">1181. </font>
<font color="red">1182.         def generator(next):</font>
<font color="red">1183.             buf = []</font>
<font color="red">1184.             c_size = 0</font>
<font color="red">1185.             push = buf.append</font>
<font color="black">1186. </font>
<font color="red">1187.             while 1:</font>
<font color="red">1188.                 try:</font>
<font color="red">1189.                     while c_size &lt; size:</font>
<font color="red">1190.                         c = next()</font>
<font color="red">1191.                         push(c)</font>
<font color="red">1192.                         if c:</font>
<font color="red">1193.                             c_size += 1</font>
<font color="red">1194.                 except StopIteration:</font>
<font color="red">1195.                     if not c_size:</font>
<font color="red">1196.                         return</font>
<font color="red">1197.                 yield concat(buf)</font>
<font color="red">1198.                 del buf[:]</font>
<font color="red">1199.                 c_size = 0</font>
<font color="black">1200. </font>
<font color="red">1201.         self.buffered = True</font>
<font color="red">1202.         self._next = get_next(generator(get_next(self._gen)))</font>
<font color="black">1203. </font>
<font color="green">1204.     def __iter__(self):</font>
<font color="red">1205.         return self</font>
<font color="black">1206. </font>
<font color="green">1207.     def __next__(self):</font>
<font color="red">1208.         return self._next()</font>
<font color="black">1209. </font>
<font color="black">1210. </font>
<font color="black">1211. # hook in default template class.  if anyone reads this comment: ignore that</font>
<font color="black">1212. # it's possible to use custom templates ;-)</font>
<font color="green">1213. Environment.template_class = Template</font>
</pre>

