source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/http/response.py</b><br>


file stats: <b>293 lines, 115 executed: 39.2% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import datetime</font>
<font color="green">   4. import json</font>
<font color="green">   5. import re</font>
<font color="green">   6. import sys</font>
<font color="green">   7. import time</font>
<font color="green">   8. from email.header import Header</font>
<font color="black">   9. </font>
<font color="green">  10. from django.conf import settings</font>
<font color="green">  11. from django.core import signals, signing</font>
<font color="green">  12. from django.core.exceptions import DisallowedRedirect</font>
<font color="green">  13. from django.core.serializers.json import DjangoJSONEncoder</font>
<font color="green">  14. from django.http.cookie import SimpleCookie</font>
<font color="green">  15. from django.utils import six, timezone</font>
<font color="green">  16. from django.utils.encoding import (</font>
<font color="black">  17.     force_bytes, force_str, force_text, iri_to_uri,</font>
<font color="black">  18. )</font>
<font color="green">  19. from django.utils.http import cookie_date</font>
<font color="green">  20. from django.utils.six.moves import map</font>
<font color="green">  21. from django.utils.six.moves.http_client import responses</font>
<font color="green">  22. from django.utils.six.moves.urllib.parse import urlparse</font>
<font color="black">  23. </font>
<font color="green">  24. _charset_from_content_type_re = re.compile(r';\s*charset=(?P&lt;charset&gt;[^\s;]+)', re.I)</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. class BadHeaderError(ValueError):</font>
<font color="green">  28.     pass</font>
<font color="black">  29. </font>
<font color="black">  30. </font>
<font color="green">  31. class HttpResponseBase(six.Iterator):</font>
<font color="black">  32.     &quot;&quot;&quot;</font>
<font color="black">  33.     An HTTP response base class with dictionary-accessed headers.</font>
<font color="black">  34. </font>
<font color="black">  35.     This class doesn't handle content. It should not be used directly.</font>
<font color="black">  36.     Use the HttpResponse and StreamingHttpResponse subclasses instead.</font>
<font color="green">  37.     &quot;&quot;&quot;</font>
<font color="black">  38. </font>
<font color="green">  39.     status_code = 200</font>
<font color="black">  40. </font>
<font color="green">  41.     def __init__(self, content_type=None, status=None, reason=None, charset=None):</font>
<font color="black">  42.         # _headers is a mapping of the lower-case name to the original case of</font>
<font color="black">  43.         # the header (required for working with legacy systems) and the header</font>
<font color="black">  44.         # value. Both the name of the header and its value are ASCII strings.</font>
<font color="red">  45.         self._headers = {}</font>
<font color="red">  46.         self._closable_objects = []</font>
<font color="black">  47.         # This parameter is set by the handler. It's necessary to preserve the</font>
<font color="black">  48.         # historical behavior of request_finished.</font>
<font color="red">  49.         self._handler_class = None</font>
<font color="red">  50.         self.cookies = SimpleCookie()</font>
<font color="red">  51.         self.closed = False</font>
<font color="red">  52.         if status is not None:</font>
<font color="red">  53.             self.status_code = status</font>
<font color="red">  54.         self._reason_phrase = reason</font>
<font color="red">  55.         self._charset = charset</font>
<font color="red">  56.         if content_type is None:</font>
<font color="red">  57.             content_type = '%s; charset=%s' % (settings.DEFAULT_CONTENT_TYPE,</font>
<font color="red">  58.                                                self.charset)</font>
<font color="red">  59.         self['Content-Type'] = content_type</font>
<font color="black">  60. </font>
<font color="green">  61.     @property</font>
<font color="black">  62.     def reason_phrase(self):</font>
<font color="red">  63.         if self._reason_phrase is not None:</font>
<font color="red">  64.             return self._reason_phrase</font>
<font color="black">  65.         # Leave self._reason_phrase unset in order to use the default</font>
<font color="black">  66.         # reason phrase for status code.</font>
<font color="red">  67.         return responses.get(self.status_code, 'Unknown Status Code')</font>
<font color="black">  68. </font>
<font color="green">  69.     @reason_phrase.setter</font>
<font color="black">  70.     def reason_phrase(self, value):</font>
<font color="red">  71.         self._reason_phrase = value</font>
<font color="black">  72. </font>
<font color="green">  73.     @property</font>
<font color="black">  74.     def charset(self):</font>
<font color="red">  75.         if self._charset is not None:</font>
<font color="red">  76.             return self._charset</font>
<font color="red">  77.         content_type = self.get('Content-Type', '')</font>
<font color="red">  78.         matched = _charset_from_content_type_re.search(content_type)</font>
<font color="red">  79.         if matched:</font>
<font color="black">  80.             # Extract the charset and strip its double quotes</font>
<font color="red">  81.             return matched.group('charset').replace('&quot;', '')</font>
<font color="red">  82.         return settings.DEFAULT_CHARSET</font>
<font color="black">  83. </font>
<font color="green">  84.     @charset.setter</font>
<font color="black">  85.     def charset(self, value):</font>
<font color="red">  86.         self._charset = value</font>
<font color="black">  87. </font>
<font color="green">  88.     def serialize_headers(self):</font>
<font color="black">  89.         &quot;&quot;&quot;HTTP headers as a bytestring.&quot;&quot;&quot;</font>
<font color="red">  90.         def to_bytes(val, encoding):</font>
<font color="red">  91.             return val if isinstance(val, bytes) else val.encode(encoding)</font>
<font color="black">  92. </font>
<font color="black">  93.         headers = [</font>
<font color="red">  94.             (b': '.join([to_bytes(key, 'ascii'), to_bytes(value, 'latin-1')]))</font>
<font color="red">  95.             for key, value in self._headers.values()</font>
<font color="black">  96.         ]</font>
<font color="red">  97.         return b'\r\n'.join(headers)</font>
<font color="black">  98. </font>
<font color="green">  99.     if six.PY3:</font>
<font color="red"> 100.         __bytes__ = serialize_headers</font>
<font color="black"> 101.     else:</font>
<font color="green"> 102.         __str__ = serialize_headers</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def _convert_to_charset(self, value, charset, mime_encode=False):</font>
<font color="black"> 105.         &quot;&quot;&quot;Converts headers key/value to ascii/latin-1 native strings.</font>
<font color="black"> 106. </font>
<font color="black"> 107.         `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and</font>
<font color="black"> 108.         `value` can't be represented in the given charset, MIME-encoding</font>
<font color="black"> 109.         is applied.</font>
<font color="black"> 110.         &quot;&quot;&quot;</font>
<font color="red"> 111.         if not isinstance(value, (bytes, six.text_type)):</font>
<font color="red"> 112.             value = str(value)</font>
<font color="red"> 113.         if ((isinstance(value, bytes) and (b'\n' in value or b'\r' in value)) or</font>
<font color="red"> 114.                 isinstance(value, six.text_type) and ('\n' in value or '\r' in value)):</font>
<font color="red"> 115.             raise BadHeaderError(&quot;Header values can't contain newlines (got %r)&quot; % value)</font>
<font color="red"> 116.         try:</font>
<font color="red"> 117.             if six.PY3:</font>
<font color="red"> 118.                 if isinstance(value, str):</font>
<font color="black"> 119.                     # Ensure string is valid in given charset</font>
<font color="red"> 120.                     value.encode(charset)</font>
<font color="black"> 121.                 else:</font>
<font color="black"> 122.                     # Convert bytestring using given charset</font>
<font color="red"> 123.                     value = value.decode(charset)</font>
<font color="black"> 124.             else:</font>
<font color="red"> 125.                 if isinstance(value, str):</font>
<font color="black"> 126.                     # Ensure string is valid in given charset</font>
<font color="red"> 127.                     value.decode(charset)</font>
<font color="black"> 128.                 else:</font>
<font color="black"> 129.                     # Convert unicode string to given charset</font>
<font color="red"> 130.                     value = value.encode(charset)</font>
<font color="red"> 131.         except UnicodeError as e:</font>
<font color="red"> 132.             if mime_encode:</font>
<font color="black"> 133.                 # Wrapping in str() is a workaround for #12422 under Python 2.</font>
<font color="red"> 134.                 value = str(Header(value, 'utf-8', maxlinelen=sys.maxsize).encode())</font>
<font color="black"> 135.             else:</font>
<font color="red"> 136.                 e.reason += ', HTTP response headers must be in %s format' % charset</font>
<font color="red"> 137.                 raise</font>
<font color="red"> 138.         return value</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def __setitem__(self, header, value):</font>
<font color="red"> 141.         header = self._convert_to_charset(header, 'ascii')</font>
<font color="red"> 142.         value = self._convert_to_charset(value, 'latin-1', mime_encode=True)</font>
<font color="red"> 143.         self._headers[header.lower()] = (header, value)</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def __delitem__(self, header):</font>
<font color="red"> 146.         try:</font>
<font color="red"> 147.             del self._headers[header.lower()]</font>
<font color="red"> 148.         except KeyError:</font>
<font color="red"> 149.             pass</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def __getitem__(self, header):</font>
<font color="red"> 152.         return self._headers[header.lower()][1]</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def has_header(self, header):</font>
<font color="black"> 155.         &quot;&quot;&quot;Case-insensitive check for a header.&quot;&quot;&quot;</font>
<font color="red"> 156.         return header.lower() in self._headers</font>
<font color="black"> 157. </font>
<font color="green"> 158.     __contains__ = has_header</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def items(self):</font>
<font color="red"> 161.         return self._headers.values()</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def get(self, header, alternate=None):</font>
<font color="red"> 164.         return self._headers.get(header.lower(), (None, alternate))[1]</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def set_cookie(self, key, value='', max_age=None, expires=None, path='/',</font>
<font color="green"> 167.                    domain=None, secure=False, httponly=False):</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="black"> 169.         Sets a cookie.</font>
<font color="black"> 170. </font>
<font color="black"> 171.         ``expires`` can be:</font>
<font color="black"> 172.         - a string in the correct format,</font>
<font color="black"> 173.         - a naive ``datetime.datetime`` object in UTC,</font>
<font color="black"> 174.         - an aware ``datetime.datetime`` object in any time zone.</font>
<font color="black"> 175.         If it is a ``datetime.datetime`` object then ``max_age`` will be calculated.</font>
<font color="black"> 176.         &quot;&quot;&quot;</font>
<font color="red"> 177.         value = force_str(value)</font>
<font color="red"> 178.         self.cookies[key] = value</font>
<font color="red"> 179.         if expires is not None:</font>
<font color="red"> 180.             if isinstance(expires, datetime.datetime):</font>
<font color="red"> 181.                 if timezone.is_aware(expires):</font>
<font color="red"> 182.                     expires = timezone.make_naive(expires, timezone.utc)</font>
<font color="red"> 183.                 delta = expires - expires.utcnow()</font>
<font color="black"> 184.                 # Add one second so the date matches exactly (a fraction of</font>
<font color="black"> 185.                 # time gets lost between converting to a timedelta and</font>
<font color="black"> 186.                 # then the date string).</font>
<font color="red"> 187.                 delta = delta + datetime.timedelta(seconds=1)</font>
<font color="black"> 188.                 # Just set max_age - the max_age logic will set expires.</font>
<font color="red"> 189.                 expires = None</font>
<font color="red"> 190.                 max_age = max(0, delta.days * 86400 + delta.seconds)</font>
<font color="black"> 191.             else:</font>
<font color="red"> 192.                 self.cookies[key]['expires'] = expires</font>
<font color="red"> 193.         if max_age is not None:</font>
<font color="red"> 194.             self.cookies[key]['max-age'] = max_age</font>
<font color="black"> 195.             # IE requires expires, so set it if hasn't been already.</font>
<font color="red"> 196.             if not expires:</font>
<font color="red"> 197.                 self.cookies[key]['expires'] = cookie_date(time.time() +</font>
<font color="red"> 198.                                                            max_age)</font>
<font color="red"> 199.         if path is not None:</font>
<font color="red"> 200.             self.cookies[key]['path'] = path</font>
<font color="red"> 201.         if domain is not None:</font>
<font color="red"> 202.             self.cookies[key]['domain'] = domain</font>
<font color="red"> 203.         if secure:</font>
<font color="red"> 204.             self.cookies[key]['secure'] = True</font>
<font color="red"> 205.         if httponly:</font>
<font color="red"> 206.             self.cookies[key]['httponly'] = True</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def setdefault(self, key, value):</font>
<font color="black"> 209.         &quot;&quot;&quot;Sets a header unless it has already been set.&quot;&quot;&quot;</font>
<font color="red"> 210.         if key not in self:</font>
<font color="red"> 211.             self[key] = value</font>
<font color="black"> 212. </font>
<font color="green"> 213.     def set_signed_cookie(self, key, value, salt='', **kwargs):</font>
<font color="red"> 214.         value = signing.get_cookie_signer(salt=key + salt).sign(value)</font>
<font color="red"> 215.         return self.set_cookie(key, value, **kwargs)</font>
<font color="black"> 216. </font>
<font color="green"> 217.     def delete_cookie(self, key, path='/', domain=None):</font>
<font color="red"> 218.         self.set_cookie(key, max_age=0, path=path, domain=domain,</font>
<font color="red"> 219.                         expires='Thu, 01-Jan-1970 00:00:00 GMT')</font>
<font color="black"> 220. </font>
<font color="black"> 221.     # Common methods used by subclasses</font>
<font color="black"> 222. </font>
<font color="green"> 223.     def make_bytes(self, value):</font>
<font color="black"> 224.         &quot;&quot;&quot;Turn a value into a bytestring encoded in the output charset.&quot;&quot;&quot;</font>
<font color="black"> 225.         # Per PEP 3333, this response body must be bytes. To avoid returning</font>
<font color="black"> 226.         # an instance of a subclass, this function returns `bytes(value)`.</font>
<font color="black"> 227.         # This doesn't make a copy when `value` already contains bytes.</font>
<font color="black"> 228. </font>
<font color="black"> 229.         # Handle string types -- we can't rely on force_bytes here because:</font>
<font color="black"> 230.         # - under Python 3 it attempts str conversion first</font>
<font color="black"> 231.         # - when self._charset != 'utf-8' it re-encodes the content</font>
<font color="red"> 232.         if isinstance(value, bytes):</font>
<font color="red"> 233.             return bytes(value)</font>
<font color="red"> 234.         if isinstance(value, six.text_type):</font>
<font color="red"> 235.             return bytes(value.encode(self.charset))</font>
<font color="black"> 236. </font>
<font color="black"> 237.         # Handle non-string types (#16494)</font>
<font color="red"> 238.         return force_bytes(value, self.charset)</font>
<font color="black"> 239. </font>
<font color="black"> 240.     # These methods partially implement the file-like object interface.</font>
<font color="black"> 241.     # See http://docs.python.org/lib/bltin-file-objects.html</font>
<font color="black"> 242. </font>
<font color="black"> 243.     # The WSGI server must call this method upon completion of the request.</font>
<font color="black"> 244.     # See http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html</font>
<font color="green"> 245.     def close(self):</font>
<font color="red"> 246.         for closable in self._closable_objects:</font>
<font color="red"> 247.             try:</font>
<font color="red"> 248.                 closable.close()</font>
<font color="red"> 249.             except Exception:</font>
<font color="red"> 250.                 pass</font>
<font color="red"> 251.         self.closed = True</font>
<font color="red"> 252.         signals.request_finished.send(sender=self._handler_class)</font>
<font color="black"> 253. </font>
<font color="green"> 254.     def write(self, content):</font>
<font color="red"> 255.         raise IOError(&quot;This %s instance is not writable&quot; % self.__class__.__name__)</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def flush(self):</font>
<font color="red"> 258.         pass</font>
<font color="black"> 259. </font>
<font color="green"> 260.     def tell(self):</font>
<font color="red"> 261.         raise IOError(&quot;This %s instance cannot tell its position&quot; % self.__class__.__name__)</font>
<font color="black"> 262. </font>
<font color="black"> 263.     # These methods partially implement a stream-like object interface.</font>
<font color="black"> 264.     # See https://docs.python.org/library/io.html#io.IOBase</font>
<font color="black"> 265. </font>
<font color="green"> 266.     def writable(self):</font>
<font color="red"> 267.         return False</font>
<font color="black"> 268. </font>
<font color="green"> 269.     def writelines(self, lines):</font>
<font color="red"> 270.         raise IOError(&quot;This %s instance is not writable&quot; % self.__class__.__name__)</font>
<font color="black"> 271. </font>
<font color="black"> 272. </font>
<font color="green"> 273. class HttpResponse(HttpResponseBase):</font>
<font color="black"> 274.     &quot;&quot;&quot;</font>
<font color="black"> 275.     An HTTP response class with a string as content.</font>
<font color="black"> 276. </font>
<font color="black"> 277.     This content that can be read, appended to or replaced.</font>
<font color="green"> 278.     &quot;&quot;&quot;</font>
<font color="black"> 279. </font>
<font color="green"> 280.     streaming = False</font>
<font color="black"> 281. </font>
<font color="green"> 282.     def __init__(self, content=b'', *args, **kwargs):</font>
<font color="red"> 283.         super(HttpResponse, self).__init__(*args, **kwargs)</font>
<font color="black"> 284.         # Content is a bytestring. See the `content` property methods.</font>
<font color="red"> 285.         self.content = content</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def __repr__(self):</font>
<font color="red"> 288.         return '&lt;%(cls)s status_code=%(status_code)d, &quot;%(content_type)s&quot;&gt;' % {</font>
<font color="red"> 289.             'cls': self.__class__.__name__,</font>
<font color="red"> 290.             'status_code': self.status_code,</font>
<font color="red"> 291.             'content_type': self['Content-Type'],</font>
<font color="black"> 292.         }</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def serialize(self):</font>
<font color="black"> 295.         &quot;&quot;&quot;Full HTTP message, including headers, as a bytestring.&quot;&quot;&quot;</font>
<font color="red"> 296.         return self.serialize_headers() + b'\r\n\r\n' + self.content</font>
<font color="black"> 297. </font>
<font color="green"> 298.     if six.PY3:</font>
<font color="red"> 299.         __bytes__ = serialize</font>
<font color="black"> 300.     else:</font>
<font color="green"> 301.         __str__ = serialize</font>
<font color="black"> 302. </font>
<font color="green"> 303.     @property</font>
<font color="black"> 304.     def content(self):</font>
<font color="red"> 305.         return b''.join(self._container)</font>
<font color="black"> 306. </font>
<font color="green"> 307.     @content.setter</font>
<font color="black"> 308.     def content(self, value):</font>
<font color="black"> 309.         # Consume iterators upon assignment to allow repeated iteration.</font>
<font color="red"> 310.         if hasattr(value, '__iter__') and not isinstance(value, (bytes, six.string_types)):</font>
<font color="red"> 311.             if hasattr(value, 'close'):</font>
<font color="red"> 312.                 self._closable_objects.append(value)</font>
<font color="red"> 313.             value = b''.join(self.make_bytes(chunk) for chunk in value)</font>
<font color="black"> 314.         else:</font>
<font color="red"> 315.             value = self.make_bytes(value)</font>
<font color="black"> 316.         # Create a list of properly encoded bytestrings to support write().</font>
<font color="red"> 317.         self._container = [value]</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def __iter__(self):</font>
<font color="red"> 320.         return iter(self._container)</font>
<font color="black"> 321. </font>
<font color="green"> 322.     def write(self, content):</font>
<font color="red"> 323.         self._container.append(self.make_bytes(content))</font>
<font color="black"> 324. </font>
<font color="green"> 325.     def tell(self):</font>
<font color="red"> 326.         return len(self.content)</font>
<font color="black"> 327. </font>
<font color="green"> 328.     def getvalue(self):</font>
<font color="red"> 329.         return self.content</font>
<font color="black"> 330. </font>
<font color="green"> 331.     def writable(self):</font>
<font color="red"> 332.         return True</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def writelines(self, lines):</font>
<font color="red"> 335.         for line in lines:</font>
<font color="red"> 336.             self.write(line)</font>
<font color="black"> 337. </font>
<font color="black"> 338. </font>
<font color="green"> 339. class StreamingHttpResponse(HttpResponseBase):</font>
<font color="black"> 340.     &quot;&quot;&quot;</font>
<font color="black"> 341.     A streaming HTTP response class with an iterator as content.</font>
<font color="black"> 342. </font>
<font color="black"> 343.     This should only be iterated once, when the response is streamed to the</font>
<font color="black"> 344.     client. However, it can be appended to or replaced with a new iterator</font>
<font color="black"> 345.     that wraps the original content (or yields entirely new content).</font>
<font color="green"> 346.     &quot;&quot;&quot;</font>
<font color="black"> 347. </font>
<font color="green"> 348.     streaming = True</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def __init__(self, streaming_content=(), *args, **kwargs):</font>
<font color="red"> 351.         super(StreamingHttpResponse, self).__init__(*args, **kwargs)</font>
<font color="black"> 352.         # `streaming_content` should be an iterable of bytestrings.</font>
<font color="black"> 353.         # See the `streaming_content` property methods.</font>
<font color="red"> 354.         self.streaming_content = streaming_content</font>
<font color="black"> 355. </font>
<font color="green"> 356.     @property</font>
<font color="black"> 357.     def content(self):</font>
<font color="red"> 358.         raise AttributeError(&quot;This %s instance has no `content` attribute. &quot;</font>
<font color="red"> 359.             &quot;Use `streaming_content` instead.&quot; % self.__class__.__name__)</font>
<font color="black"> 360. </font>
<font color="green"> 361.     @property</font>
<font color="black"> 362.     def streaming_content(self):</font>
<font color="red"> 363.         return map(self.make_bytes, self._iterator)</font>
<font color="black"> 364. </font>
<font color="green"> 365.     @streaming_content.setter</font>
<font color="black"> 366.     def streaming_content(self, value):</font>
<font color="red"> 367.         self._set_streaming_content(value)</font>
<font color="black"> 368. </font>
<font color="green"> 369.     def _set_streaming_content(self, value):</font>
<font color="black"> 370.         # Ensure we can never iterate on &quot;value&quot; more than once.</font>
<font color="red"> 371.         self._iterator = iter(value)</font>
<font color="red"> 372.         if hasattr(value, 'close'):</font>
<font color="red"> 373.             self._closable_objects.append(value)</font>
<font color="black"> 374. </font>
<font color="green"> 375.     def __iter__(self):</font>
<font color="red"> 376.         return self.streaming_content</font>
<font color="black"> 377. </font>
<font color="green"> 378.     def getvalue(self):</font>
<font color="red"> 379.         return b''.join(self.streaming_content)</font>
<font color="black"> 380. </font>
<font color="black"> 381. </font>
<font color="green"> 382. class FileResponse(StreamingHttpResponse):</font>
<font color="black"> 383.     &quot;&quot;&quot;</font>
<font color="black"> 384.     A streaming HTTP response class optimized for files.</font>
<font color="green"> 385.     &quot;&quot;&quot;</font>
<font color="green"> 386.     block_size = 4096</font>
<font color="black"> 387. </font>
<font color="green"> 388.     def _set_streaming_content(self, value):</font>
<font color="red"> 389.         if hasattr(value, 'read'):</font>
<font color="red"> 390.             self.file_to_stream = value</font>
<font color="red"> 391.             filelike = value</font>
<font color="red"> 392.             if hasattr(filelike, 'close'):</font>
<font color="red"> 393.                 self._closable_objects.append(filelike)</font>
<font color="red"> 394.             value = iter(lambda: filelike.read(self.block_size), b'')</font>
<font color="black"> 395.         else:</font>
<font color="red"> 396.             self.file_to_stream = None</font>
<font color="red"> 397.         super(FileResponse, self)._set_streaming_content(value)</font>
<font color="black"> 398. </font>
<font color="black"> 399. </font>
<font color="green"> 400. class HttpResponseRedirectBase(HttpResponse):</font>
<font color="green"> 401.     allowed_schemes = ['http', 'https', 'ftp']</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def __init__(self, redirect_to, *args, **kwargs):</font>
<font color="red"> 404.         parsed = urlparse(force_text(redirect_to))</font>
<font color="red"> 405.         if parsed.scheme and parsed.scheme not in self.allowed_schemes:</font>
<font color="red"> 406.             raise DisallowedRedirect(&quot;Unsafe redirect to URL with protocol '%s'&quot; % parsed.scheme)</font>
<font color="red"> 407.         super(HttpResponseRedirectBase, self).__init__(*args, **kwargs)</font>
<font color="red"> 408.         self['Location'] = iri_to_uri(redirect_to)</font>
<font color="black"> 409. </font>
<font color="green"> 410.     url = property(lambda self: self['Location'])</font>
<font color="black"> 411. </font>
<font color="green"> 412.     def __repr__(self):</font>
<font color="red"> 413.         return '&lt;%(cls)s status_code=%(status_code)d, &quot;%(content_type)s&quot;, url=&quot;%(url)s&quot;&gt;' % {</font>
<font color="red"> 414.             'cls': self.__class__.__name__,</font>
<font color="red"> 415.             'status_code': self.status_code,</font>
<font color="red"> 416.             'content_type': self['Content-Type'],</font>
<font color="red"> 417.             'url': self.url,</font>
<font color="black"> 418.         }</font>
<font color="black"> 419. </font>
<font color="black"> 420. </font>
<font color="green"> 421. class HttpResponseRedirect(HttpResponseRedirectBase):</font>
<font color="green"> 422.     status_code = 302</font>
<font color="black"> 423. </font>
<font color="black"> 424. </font>
<font color="green"> 425. class HttpResponsePermanentRedirect(HttpResponseRedirectBase):</font>
<font color="green"> 426.     status_code = 301</font>
<font color="black"> 427. </font>
<font color="black"> 428. </font>
<font color="green"> 429. class HttpResponseNotModified(HttpResponse):</font>
<font color="green"> 430.     status_code = 304</font>
<font color="black"> 431. </font>
<font color="green"> 432.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 433.         super(HttpResponseNotModified, self).__init__(*args, **kwargs)</font>
<font color="red"> 434.         del self['content-type']</font>
<font color="black"> 435. </font>
<font color="green"> 436.     @HttpResponse.content.setter</font>
<font color="black"> 437.     def content(self, value):</font>
<font color="red"> 438.         if value:</font>
<font color="red"> 439.             raise AttributeError(&quot;You cannot set content to a 304 (Not Modified) response&quot;)</font>
<font color="red"> 440.         self._container = []</font>
<font color="black"> 441. </font>
<font color="black"> 442. </font>
<font color="green"> 443. class HttpResponseBadRequest(HttpResponse):</font>
<font color="green"> 444.     status_code = 400</font>
<font color="black"> 445. </font>
<font color="black"> 446. </font>
<font color="green"> 447. class HttpResponseNotFound(HttpResponse):</font>
<font color="green"> 448.     status_code = 404</font>
<font color="black"> 449. </font>
<font color="black"> 450. </font>
<font color="green"> 451. class HttpResponseForbidden(HttpResponse):</font>
<font color="green"> 452.     status_code = 403</font>
<font color="black"> 453. </font>
<font color="black"> 454. </font>
<font color="green"> 455. class HttpResponseNotAllowed(HttpResponse):</font>
<font color="green"> 456.     status_code = 405</font>
<font color="black"> 457. </font>
<font color="green"> 458.     def __init__(self, permitted_methods, *args, **kwargs):</font>
<font color="red"> 459.         super(HttpResponseNotAllowed, self).__init__(*args, **kwargs)</font>
<font color="red"> 460.         self['Allow'] = ', '.join(permitted_methods)</font>
<font color="black"> 461. </font>
<font color="green"> 462.     def __repr__(self):</font>
<font color="red"> 463.         return '&lt;%(cls)s [%(methods)s] status_code=%(status_code)d, &quot;%(content_type)s&quot;&gt;' % {</font>
<font color="red"> 464.             'cls': self.__class__.__name__,</font>
<font color="red"> 465.             'status_code': self.status_code,</font>
<font color="red"> 466.             'content_type': self['Content-Type'],</font>
<font color="red"> 467.             'methods': self['Allow'],</font>
<font color="black"> 468.         }</font>
<font color="black"> 469. </font>
<font color="black"> 470. </font>
<font color="green"> 471. class HttpResponseGone(HttpResponse):</font>
<font color="green"> 472.     status_code = 410</font>
<font color="black"> 473. </font>
<font color="black"> 474. </font>
<font color="green"> 475. class HttpResponseServerError(HttpResponse):</font>
<font color="green"> 476.     status_code = 500</font>
<font color="black"> 477. </font>
<font color="black"> 478. </font>
<font color="green"> 479. class Http404(Exception):</font>
<font color="green"> 480.     pass</font>
<font color="black"> 481. </font>
<font color="black"> 482. </font>
<font color="green"> 483. class JsonResponse(HttpResponse):</font>
<font color="black"> 484.     &quot;&quot;&quot;</font>
<font color="black"> 485.     An HTTP response class that consumes data to be serialized to JSON.</font>
<font color="black"> 486. </font>
<font color="black"> 487.     :param data: Data to be dumped into json. By default only ``dict`` objects</font>
<font color="black"> 488.       are allowed to be passed due to a security flaw before EcmaScript 5. See</font>
<font color="black"> 489.       the ``safe`` parameter for more information.</font>
<font color="black"> 490.     :param encoder: Should be an json encoder class. Defaults to</font>
<font color="black"> 491.       ``django.core.serializers.json.DjangoJSONEncoder``.</font>
<font color="black"> 492.     :param safe: Controls if only ``dict`` objects may be serialized. Defaults</font>
<font color="black"> 493.       to ``True``.</font>
<font color="black"> 494.     :param json_dumps_params: A dictionary of kwargs passed to json.dumps().</font>
<font color="green"> 495.     &quot;&quot;&quot;</font>
<font color="black"> 496. </font>
<font color="green"> 497.     def __init__(self, data, encoder=DjangoJSONEncoder, safe=True,</font>
<font color="green"> 498.                  json_dumps_params=None, **kwargs):</font>
<font color="red"> 499.         if safe and not isinstance(data, dict):</font>
<font color="red"> 500.             raise TypeError('In order to allow non-dict objects to be '</font>
<font color="black"> 501.                 'serialized set the safe parameter to False')</font>
<font color="red"> 502.         if json_dumps_params is None:</font>
<font color="red"> 503.             json_dumps_params = {}</font>
<font color="red"> 504.         kwargs.setdefault('content_type', 'application/json')</font>
<font color="red"> 505.         data = json.dumps(data, cls=encoder, **json_dumps_params)</font>
<font color="red"> 506.         super(JsonResponse, self).__init__(content=data, **kwargs)</font>
</pre>

