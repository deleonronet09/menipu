source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/template/defaulttags.py</b><br>


file stats: <b>714 lines, 138 executed: 19.3% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Default tags used by the template system, available to all templates.&quot;&quot;&quot;</font>
<font color="green">   2. from __future__ import unicode_literals</font>
<font color="black">   3. </font>
<font color="green">   4. import os</font>
<font color="green">   5. import re</font>
<font color="green">   6. import sys</font>
<font color="green">   7. import warnings</font>
<font color="green">   8. from datetime import datetime</font>
<font color="green">   9. from itertools import cycle as itertools_cycle, groupby</font>
<font color="black">  10. </font>
<font color="green">  11. from django.conf import settings</font>
<font color="green">  12. from django.utils import six, timezone</font>
<font color="green">  13. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  14. from django.utils.encoding import force_text, smart_text</font>
<font color="green">  15. from django.utils.html import conditional_escape, format_html</font>
<font color="green">  16. from django.utils.lorem_ipsum import paragraphs, words</font>
<font color="green">  17. from django.utils.safestring import mark_safe</font>
<font color="black">  18. </font>
<font color="green">  19. from .base import (</font>
<font color="black">  20.     BLOCK_TAG_END, BLOCK_TAG_START, COMMENT_TAG_END, COMMENT_TAG_START,</font>
<font color="black">  21.     SINGLE_BRACE_END, SINGLE_BRACE_START, VARIABLE_ATTRIBUTE_SEPARATOR,</font>
<font color="black">  22.     VARIABLE_TAG_END, VARIABLE_TAG_START, Context, Node, NodeList, Template,</font>
<font color="black">  23.     TemplateSyntaxError, VariableDoesNotExist, kwarg_re,</font>
<font color="black">  24.     render_value_in_context, token_kwargs,</font>
<font color="black">  25. )</font>
<font color="green">  26. from .defaultfilters import date</font>
<font color="green">  27. from .library import Library</font>
<font color="green">  28. from .smartif import IfParser, Literal</font>
<font color="black">  29. </font>
<font color="green">  30. register = Library()</font>
<font color="black">  31. </font>
<font color="black">  32. </font>
<font color="green">  33. class AutoEscapeControlNode(Node):</font>
<font color="green">  34.     &quot;&quot;&quot;Implements the actions of the autoescape tag.&quot;&quot;&quot;</font>
<font color="green">  35.     def __init__(self, setting, nodelist):</font>
<font color="red">  36.         self.setting, self.nodelist = setting, nodelist</font>
<font color="black">  37. </font>
<font color="green">  38.     def render(self, context):</font>
<font color="red">  39.         old_setting = context.autoescape</font>
<font color="red">  40.         context.autoescape = self.setting</font>
<font color="red">  41.         output = self.nodelist.render(context)</font>
<font color="red">  42.         context.autoescape = old_setting</font>
<font color="red">  43.         if self.setting:</font>
<font color="red">  44.             return mark_safe(output)</font>
<font color="black">  45.         else:</font>
<font color="red">  46.             return output</font>
<font color="black">  47. </font>
<font color="black">  48. </font>
<font color="green">  49. class CommentNode(Node):</font>
<font color="green">  50.     def render(self, context):</font>
<font color="red">  51.         return ''</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. class CsrfTokenNode(Node):</font>
<font color="green">  55.     def render(self, context):</font>
<font color="red">  56.         csrf_token = context.get('csrf_token')</font>
<font color="red">  57.         if csrf_token:</font>
<font color="red">  58.             if csrf_token == 'NOTPROVIDED':</font>
<font color="red">  59.                 return format_html(&quot;&quot;)</font>
<font color="black">  60.             else:</font>
<font color="red">  61.                 return format_html(&quot;&lt;input type='hidden' name='csrfmiddlewaretoken' value='{}' /&gt;&quot;, csrf_token)</font>
<font color="black">  62.         else:</font>
<font color="black">  63.             # It's very probable that the token is missing because of</font>
<font color="black">  64.             # misconfiguration, so we raise a warning</font>
<font color="red">  65.             if settings.DEBUG:</font>
<font color="red">  66.                 warnings.warn(</font>
<font color="red">  67.                     &quot;A {% csrf_token %} was used in a template, but the context &quot;</font>
<font color="black">  68.                     &quot;did not provide the value.  This is usually caused by not &quot;</font>
<font color="black">  69.                     &quot;using RequestContext.&quot;</font>
<font color="black">  70.                 )</font>
<font color="red">  71.             return ''</font>
<font color="black">  72. </font>
<font color="black">  73. </font>
<font color="green">  74. class CycleNode(Node):</font>
<font color="green">  75.     def __init__(self, cyclevars, variable_name=None, silent=False):</font>
<font color="red">  76.         self.cyclevars = cyclevars</font>
<font color="red">  77.         self.variable_name = variable_name</font>
<font color="red">  78.         self.silent = silent</font>
<font color="black">  79. </font>
<font color="green">  80.     def render(self, context):</font>
<font color="red">  81.         if self not in context.render_context:</font>
<font color="black">  82.             # First time the node is rendered in template</font>
<font color="red">  83.             context.render_context[self] = itertools_cycle(self.cyclevars)</font>
<font color="red">  84.         cycle_iter = context.render_context[self]</font>
<font color="red">  85.         value = next(cycle_iter).resolve(context)</font>
<font color="red">  86.         if self.variable_name:</font>
<font color="red">  87.             context[self.variable_name] = value</font>
<font color="red">  88.         if self.silent:</font>
<font color="red">  89.             return ''</font>
<font color="red">  90.         return render_value_in_context(value, context)</font>
<font color="black">  91. </font>
<font color="black">  92. </font>
<font color="green">  93. class DebugNode(Node):</font>
<font color="green">  94.     def render(self, context):</font>
<font color="red">  95.         from pprint import pformat</font>
<font color="red">  96.         output = [force_text(pformat(val)) for val in context]</font>
<font color="red">  97.         output.append('\n\n')</font>
<font color="red">  98.         output.append(force_text(pformat(sys.modules)))</font>
<font color="red">  99.         return ''.join(output)</font>
<font color="black"> 100. </font>
<font color="black"> 101. </font>
<font color="green"> 102. class FilterNode(Node):</font>
<font color="green"> 103.     def __init__(self, filter_expr, nodelist):</font>
<font color="red"> 104.         self.filter_expr, self.nodelist = filter_expr, nodelist</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def render(self, context):</font>
<font color="red"> 107.         output = self.nodelist.render(context)</font>
<font color="black"> 108.         # Apply filters.</font>
<font color="red"> 109.         with context.push(var=output):</font>
<font color="red"> 110.             return self.filter_expr.resolve(context)</font>
<font color="black"> 111. </font>
<font color="black"> 112. </font>
<font color="green"> 113. class FirstOfNode(Node):</font>
<font color="green"> 114.     def __init__(self, variables, asvar=None):</font>
<font color="red"> 115.         self.vars = variables</font>
<font color="red"> 116.         self.asvar = asvar</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def render(self, context):</font>
<font color="red"> 119.         for var in self.vars:</font>
<font color="red"> 120.             value = var.resolve(context, True)</font>
<font color="red"> 121.             if value:</font>
<font color="red"> 122.                 first = render_value_in_context(value, context)</font>
<font color="red"> 123.                 if self.asvar:</font>
<font color="red"> 124.                     context[self.asvar] = first</font>
<font color="red"> 125.                     return ''</font>
<font color="red"> 126.                 return first</font>
<font color="red"> 127.         return ''</font>
<font color="black"> 128. </font>
<font color="black"> 129. </font>
<font color="green"> 130. class ForNode(Node):</font>
<font color="green"> 131.     child_nodelists = ('nodelist_loop', 'nodelist_empty')</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def __init__(self, loopvars, sequence, is_reversed, nodelist_loop, nodelist_empty=None):</font>
<font color="red"> 134.         self.loopvars, self.sequence = loopvars, sequence</font>
<font color="red"> 135.         self.is_reversed = is_reversed</font>
<font color="red"> 136.         self.nodelist_loop = nodelist_loop</font>
<font color="red"> 137.         if nodelist_empty is None:</font>
<font color="red"> 138.             self.nodelist_empty = NodeList()</font>
<font color="black"> 139.         else:</font>
<font color="red"> 140.             self.nodelist_empty = nodelist_empty</font>
<font color="black"> 141. </font>
<font color="green"> 142.     def __repr__(self):</font>
<font color="red"> 143.         reversed_text = ' reversed' if self.is_reversed else ''</font>
<font color="red"> 144.         return &quot;&lt;For Node: for %s in %s, tail_len: %d%s&gt;&quot; % \</font>
<font color="red"> 145.             (', '.join(self.loopvars), self.sequence, len(self.nodelist_loop),</font>
<font color="red"> 146.              reversed_text)</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def __iter__(self):</font>
<font color="red"> 149.         for node in self.nodelist_loop:</font>
<font color="red"> 150.             yield node</font>
<font color="red"> 151.         for node in self.nodelist_empty:</font>
<font color="red"> 152.             yield node</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def render(self, context):</font>
<font color="red"> 155.         if 'forloop' in context:</font>
<font color="red"> 156.             parentloop = context['forloop']</font>
<font color="black"> 157.         else:</font>
<font color="red"> 158.             parentloop = {}</font>
<font color="red"> 159.         with context.push():</font>
<font color="red"> 160.             try:</font>
<font color="red"> 161.                 values = self.sequence.resolve(context, True)</font>
<font color="red"> 162.             except VariableDoesNotExist:</font>
<font color="red"> 163.                 values = []</font>
<font color="red"> 164.             if values is None:</font>
<font color="red"> 165.                 values = []</font>
<font color="red"> 166.             if not hasattr(values, '__len__'):</font>
<font color="red"> 167.                 values = list(values)</font>
<font color="red"> 168.             len_values = len(values)</font>
<font color="red"> 169.             if len_values &lt; 1:</font>
<font color="red"> 170.                 return self.nodelist_empty.render(context)</font>
<font color="red"> 171.             nodelist = []</font>
<font color="red"> 172.             if self.is_reversed:</font>
<font color="red"> 173.                 values = reversed(values)</font>
<font color="red"> 174.             num_loopvars = len(self.loopvars)</font>
<font color="red"> 175.             unpack = num_loopvars &gt; 1</font>
<font color="black"> 176.             # Create a forloop value in the context.  We'll update counters on each</font>
<font color="black"> 177.             # iteration just below.</font>
<font color="red"> 178.             loop_dict = context['forloop'] = {'parentloop': parentloop}</font>
<font color="red"> 179.             for i, item in enumerate(values):</font>
<font color="black"> 180.                 # Shortcuts for current loop iteration number.</font>
<font color="red"> 181.                 loop_dict['counter0'] = i</font>
<font color="red"> 182.                 loop_dict['counter'] = i + 1</font>
<font color="black"> 183.                 # Reverse counter iteration numbers.</font>
<font color="red"> 184.                 loop_dict['revcounter'] = len_values - i</font>
<font color="red"> 185.                 loop_dict['revcounter0'] = len_values - i - 1</font>
<font color="black"> 186.                 # Boolean values designating first and last times through loop.</font>
<font color="red"> 187.                 loop_dict['first'] = (i == 0)</font>
<font color="red"> 188.                 loop_dict['last'] = (i == len_values - 1)</font>
<font color="black"> 189. </font>
<font color="red"> 190.                 pop_context = False</font>
<font color="red"> 191.                 if unpack:</font>
<font color="black"> 192.                     # If there are multiple loop variables, unpack the item into</font>
<font color="black"> 193.                     # them.</font>
<font color="black"> 194. </font>
<font color="black"> 195.                     # To complete this deprecation, remove from here to the</font>
<font color="black"> 196.                     # try/except block as well as the try/except itself,</font>
<font color="black"> 197.                     # leaving `unpacked_vars = ...` and the &quot;else&quot; statements.</font>
<font color="red"> 198.                     if not isinstance(item, (list, tuple)):</font>
<font color="red"> 199.                         len_item = 1</font>
<font color="black"> 200.                     else:</font>
<font color="red"> 201.                         len_item = len(item)</font>
<font color="black"> 202.                     # Check loop variable count before unpacking</font>
<font color="red"> 203.                     if num_loopvars != len_item:</font>
<font color="red"> 204.                         warnings.warn(</font>
<font color="red"> 205.                             &quot;Need {} values to unpack in for loop; got {}. &quot;</font>
<font color="black"> 206.                             &quot;This will raise an exception in Django 1.10.&quot;</font>
<font color="red"> 207.                             .format(num_loopvars, len_item),</font>
<font color="red"> 208.                             RemovedInDjango110Warning)</font>
<font color="red"> 209.                     try:</font>
<font color="red"> 210.                         unpacked_vars = dict(zip(self.loopvars, item))</font>
<font color="red"> 211.                     except TypeError:</font>
<font color="red"> 212.                         pass</font>
<font color="black"> 213.                     else:</font>
<font color="red"> 214.                         pop_context = True</font>
<font color="red"> 215.                         context.update(unpacked_vars)</font>
<font color="black"> 216.                 else:</font>
<font color="red"> 217.                     context[self.loopvars[0]] = item</font>
<font color="black"> 218. </font>
<font color="red"> 219.                 for node in self.nodelist_loop:</font>
<font color="red"> 220.                     nodelist.append(node.render_annotated(context))</font>
<font color="black"> 221. </font>
<font color="red"> 222.                 if pop_context:</font>
<font color="black"> 223.                     # The loop variables were pushed on to the context so pop them</font>
<font color="black"> 224.                     # off again. This is necessary because the tag lets the length</font>
<font color="black"> 225.                     # of loopvars differ to the length of each set of items and we</font>
<font color="black"> 226.                     # don't want to leave any vars from the previous loop on the</font>
<font color="black"> 227.                     # context.</font>
<font color="red"> 228.                     context.pop()</font>
<font color="red"> 229.         return mark_safe(''.join(force_text(n) for n in nodelist))</font>
<font color="black"> 230. </font>
<font color="black"> 231. </font>
<font color="green"> 232. class IfChangedNode(Node):</font>
<font color="green"> 233.     child_nodelists = ('nodelist_true', 'nodelist_false')</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def __init__(self, nodelist_true, nodelist_false, *varlist):</font>
<font color="red"> 236.         self.nodelist_true, self.nodelist_false = nodelist_true, nodelist_false</font>
<font color="red"> 237.         self._varlist = varlist</font>
<font color="black"> 238. </font>
<font color="green"> 239.     def render(self, context):</font>
<font color="black"> 240.         # Init state storage</font>
<font color="red"> 241.         state_frame = self._get_context_stack_frame(context)</font>
<font color="red"> 242.         if self not in state_frame:</font>
<font color="red"> 243.             state_frame[self] = None</font>
<font color="black"> 244. </font>
<font color="red"> 245.         nodelist_true_output = None</font>
<font color="red"> 246.         try:</font>
<font color="red"> 247.             if self._varlist:</font>
<font color="black"> 248.                 # Consider multiple parameters.  This automatically behaves</font>
<font color="black"> 249.                 # like an OR evaluation of the multiple variables.</font>
<font color="red"> 250.                 compare_to = [var.resolve(context, True) for var in self._varlist]</font>
<font color="black"> 251.             else:</font>
<font color="black"> 252.                 # The &quot;{% ifchanged %}&quot; syntax (without any variables) compares the rendered output.</font>
<font color="red"> 253.                 compare_to = nodelist_true_output = self.nodelist_true.render(context)</font>
<font color="red"> 254.         except VariableDoesNotExist:</font>
<font color="red"> 255.             compare_to = None</font>
<font color="black"> 256. </font>
<font color="red"> 257.         if compare_to != state_frame[self]:</font>
<font color="red"> 258.             state_frame[self] = compare_to</font>
<font color="black"> 259.             # render true block if not already rendered</font>
<font color="red"> 260.             return nodelist_true_output or self.nodelist_true.render(context)</font>
<font color="red"> 261.         elif self.nodelist_false:</font>
<font color="red"> 262.             return self.nodelist_false.render(context)</font>
<font color="red"> 263.         return ''</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def _get_context_stack_frame(self, context):</font>
<font color="black"> 266.         # The Context object behaves like a stack where each template tag can create a new scope.</font>
<font color="black"> 267.         # Find the place where to store the state to detect changes.</font>
<font color="red"> 268.         if 'forloop' in context:</font>
<font color="black"> 269.             # Ifchanged is bound to the local for loop.</font>
<font color="black"> 270.             # When there is a loop-in-loop, the state is bound to the inner loop,</font>
<font color="black"> 271.             # so it resets when the outer loop continues.</font>
<font color="red"> 272.             return context['forloop']</font>
<font color="black"> 273.         else:</font>
<font color="black"> 274.             # Using ifchanged outside loops. Effectively this is a no-op because the state is associated with 'self'.</font>
<font color="red"> 275.             return context.render_context</font>
<font color="black"> 276. </font>
<font color="black"> 277. </font>
<font color="green"> 278. class IfEqualNode(Node):</font>
<font color="green"> 279.     child_nodelists = ('nodelist_true', 'nodelist_false')</font>
<font color="black"> 280. </font>
<font color="green"> 281.     def __init__(self, var1, var2, nodelist_true, nodelist_false, negate):</font>
<font color="red"> 282.         self.var1, self.var2 = var1, var2</font>
<font color="red"> 283.         self.nodelist_true, self.nodelist_false = nodelist_true, nodelist_false</font>
<font color="red"> 284.         self.negate = negate</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def __repr__(self):</font>
<font color="red"> 287.         return &quot;&lt;IfEqualNode&gt;&quot;</font>
<font color="black"> 288. </font>
<font color="green"> 289.     def render(self, context):</font>
<font color="red"> 290.         val1 = self.var1.resolve(context, True)</font>
<font color="red"> 291.         val2 = self.var2.resolve(context, True)</font>
<font color="red"> 292.         if (self.negate and val1 != val2) or (not self.negate and val1 == val2):</font>
<font color="red"> 293.             return self.nodelist_true.render(context)</font>
<font color="red"> 294.         return self.nodelist_false.render(context)</font>
<font color="black"> 295. </font>
<font color="black"> 296. </font>
<font color="green"> 297. class IfNode(Node):</font>
<font color="black"> 298. </font>
<font color="green"> 299.     def __init__(self, conditions_nodelists):</font>
<font color="red"> 300.         self.conditions_nodelists = conditions_nodelists</font>
<font color="black"> 301. </font>
<font color="green"> 302.     def __repr__(self):</font>
<font color="red"> 303.         return &quot;&lt;IfNode&gt;&quot;</font>
<font color="black"> 304. </font>
<font color="green"> 305.     def __iter__(self):</font>
<font color="red"> 306.         for _, nodelist in self.conditions_nodelists:</font>
<font color="red"> 307.             for node in nodelist:</font>
<font color="red"> 308.                 yield node</font>
<font color="black"> 309. </font>
<font color="green"> 310.     @property</font>
<font color="black"> 311.     def nodelist(self):</font>
<font color="red"> 312.         return NodeList(node for _, nodelist in self.conditions_nodelists for node in nodelist)</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def render(self, context):</font>
<font color="red"> 315.         for condition, nodelist in self.conditions_nodelists:</font>
<font color="black"> 316. </font>
<font color="red"> 317.             if condition is not None:           # if / elif clause</font>
<font color="red"> 318.                 try:</font>
<font color="red"> 319.                     match = condition.eval(context)</font>
<font color="red"> 320.                 except VariableDoesNotExist:</font>
<font color="red"> 321.                     match = None</font>
<font color="black"> 322.             else:                               # else clause</font>
<font color="red"> 323.                 match = True</font>
<font color="black"> 324. </font>
<font color="red"> 325.             if match:</font>
<font color="red"> 326.                 return nodelist.render(context)</font>
<font color="black"> 327. </font>
<font color="red"> 328.         return ''</font>
<font color="black"> 329. </font>
<font color="black"> 330. </font>
<font color="green"> 331. class LoremNode(Node):</font>
<font color="green"> 332.     def __init__(self, count, method, common):</font>
<font color="red"> 333.         self.count, self.method, self.common = count, method, common</font>
<font color="black"> 334. </font>
<font color="green"> 335.     def render(self, context):</font>
<font color="red"> 336.         try:</font>
<font color="red"> 337.             count = int(self.count.resolve(context))</font>
<font color="red"> 338.         except (ValueError, TypeError):</font>
<font color="red"> 339.             count = 1</font>
<font color="red"> 340.         if self.method == 'w':</font>
<font color="red"> 341.             return words(count, common=self.common)</font>
<font color="black"> 342.         else:</font>
<font color="red"> 343.             paras = paragraphs(count, common=self.common)</font>
<font color="red"> 344.         if self.method == 'p':</font>
<font color="red"> 345.             paras = ['&lt;p&gt;%s&lt;/p&gt;' % p for p in paras]</font>
<font color="red"> 346.         return '\n\n'.join(paras)</font>
<font color="black"> 347. </font>
<font color="black"> 348. </font>
<font color="green"> 349. class RegroupNode(Node):</font>
<font color="green"> 350.     def __init__(self, target, expression, var_name):</font>
<font color="red"> 351.         self.target, self.expression = target, expression</font>
<font color="red"> 352.         self.var_name = var_name</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def resolve_expression(self, obj, context):</font>
<font color="black"> 355.         # This method is called for each object in self.target. See regroup()</font>
<font color="black"> 356.         # for the reason why we temporarily put the object in the context.</font>
<font color="red"> 357.         context[self.var_name] = obj</font>
<font color="red"> 358.         return self.expression.resolve(context, True)</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def render(self, context):</font>
<font color="red"> 361.         obj_list = self.target.resolve(context, True)</font>
<font color="red"> 362.         if obj_list is None:</font>
<font color="black"> 363.             # target variable wasn't found in context; fail silently.</font>
<font color="red"> 364.             context[self.var_name] = []</font>
<font color="red"> 365.             return ''</font>
<font color="black"> 366.         # List of dictionaries in the format:</font>
<font color="black"> 367.         # {'grouper': 'key', 'list': [list of contents]}.</font>
<font color="black"> 368.         context[self.var_name] = [</font>
<font color="red"> 369.             {'grouper': key, 'list': list(val)}</font>
<font color="black"> 370.             for key, val in</font>
<font color="red"> 371.             groupby(obj_list, lambda obj: self.resolve_expression(obj, context))</font>
<font color="black"> 372.         ]</font>
<font color="red"> 373.         return ''</font>
<font color="black"> 374. </font>
<font color="black"> 375. </font>
<font color="green"> 376. def include_is_allowed(filepath, allowed_include_roots):</font>
<font color="red"> 377.     filepath = os.path.abspath(filepath)</font>
<font color="red"> 378.     for root in allowed_include_roots:</font>
<font color="red"> 379.         if filepath.startswith(root):</font>
<font color="red"> 380.             return True</font>
<font color="red"> 381.     return False</font>
<font color="black"> 382. </font>
<font color="black"> 383. </font>
<font color="green"> 384. class SsiNode(Node):</font>
<font color="green"> 385.     def __init__(self, filepath, parsed):</font>
<font color="red"> 386.         self.filepath = filepath</font>
<font color="red"> 387.         self.parsed = parsed</font>
<font color="black"> 388. </font>
<font color="green"> 389.     def render(self, context):</font>
<font color="red"> 390.         filepath = self.filepath.resolve(context)</font>
<font color="black"> 391. </font>
<font color="red"> 392.         if not include_is_allowed(filepath, context.template.engine.allowed_include_roots):</font>
<font color="red"> 393.             if settings.DEBUG:</font>
<font color="red"> 394.                 return &quot;[Didn't have permission to include file]&quot;</font>
<font color="black"> 395.             else:</font>
<font color="red"> 396.                 return ''  # Fail silently for invalid includes.</font>
<font color="red"> 397.         try:</font>
<font color="red"> 398.             with open(filepath, 'r') as fp:</font>
<font color="red"> 399.                 output = fp.read()</font>
<font color="red"> 400.         except IOError:</font>
<font color="red"> 401.             output = ''</font>
<font color="red"> 402.         if self.parsed:</font>
<font color="red"> 403.             try:</font>
<font color="red"> 404.                 t = Template(output, name=filepath, engine=context.template.engine)</font>
<font color="red"> 405.                 return t.render(context)</font>
<font color="red"> 406.             except TemplateSyntaxError as e:</font>
<font color="red"> 407.                 if settings.DEBUG:</font>
<font color="red"> 408.                     return &quot;[Included template had syntax error: %s]&quot; % e</font>
<font color="black"> 409.                 else:</font>
<font color="red"> 410.                     return ''  # Fail silently for invalid included templates.</font>
<font color="red"> 411.         return output</font>
<font color="black"> 412. </font>
<font color="black"> 413. </font>
<font color="green"> 414. class LoadNode(Node):</font>
<font color="green"> 415.     def render(self, context):</font>
<font color="red"> 416.         return ''</font>
<font color="black"> 417. </font>
<font color="black"> 418. </font>
<font color="green"> 419. class NowNode(Node):</font>
<font color="green"> 420.     def __init__(self, format_string, asvar=None):</font>
<font color="red"> 421.         self.format_string = format_string</font>
<font color="red"> 422.         self.asvar = asvar</font>
<font color="black"> 423. </font>
<font color="green"> 424.     def render(self, context):</font>
<font color="red"> 425.         tzinfo = timezone.get_current_timezone() if settings.USE_TZ else None</font>
<font color="red"> 426.         formatted = date(datetime.now(tz=tzinfo), self.format_string)</font>
<font color="black"> 427. </font>
<font color="red"> 428.         if self.asvar:</font>
<font color="red"> 429.             context[self.asvar] = formatted</font>
<font color="red"> 430.             return ''</font>
<font color="black"> 431.         else:</font>
<font color="red"> 432.             return formatted</font>
<font color="black"> 433. </font>
<font color="black"> 434. </font>
<font color="green"> 435. class SpacelessNode(Node):</font>
<font color="green"> 436.     def __init__(self, nodelist):</font>
<font color="red"> 437.         self.nodelist = nodelist</font>
<font color="black"> 438. </font>
<font color="green"> 439.     def render(self, context):</font>
<font color="red"> 440.         from django.utils.html import strip_spaces_between_tags</font>
<font color="red"> 441.         return strip_spaces_between_tags(self.nodelist.render(context).strip())</font>
<font color="black"> 442. </font>
<font color="black"> 443. </font>
<font color="green"> 444. class TemplateTagNode(Node):</font>
<font color="green"> 445.     mapping = {'openblock': BLOCK_TAG_START,</font>
<font color="green"> 446.                'closeblock': BLOCK_TAG_END,</font>
<font color="green"> 447.                'openvariable': VARIABLE_TAG_START,</font>
<font color="green"> 448.                'closevariable': VARIABLE_TAG_END,</font>
<font color="green"> 449.                'openbrace': SINGLE_BRACE_START,</font>
<font color="green"> 450.                'closebrace': SINGLE_BRACE_END,</font>
<font color="green"> 451.                'opencomment': COMMENT_TAG_START,</font>
<font color="green"> 452.                'closecomment': COMMENT_TAG_END,</font>
<font color="black"> 453.                }</font>
<font color="black"> 454. </font>
<font color="green"> 455.     def __init__(self, tagtype):</font>
<font color="red"> 456.         self.tagtype = tagtype</font>
<font color="black"> 457. </font>
<font color="green"> 458.     def render(self, context):</font>
<font color="red"> 459.         return self.mapping.get(self.tagtype, '')</font>
<font color="black"> 460. </font>
<font color="black"> 461. </font>
<font color="green"> 462. class URLNode(Node):</font>
<font color="green"> 463.     def __init__(self, view_name, args, kwargs, asvar):</font>
<font color="red"> 464.         self.view_name = view_name</font>
<font color="red"> 465.         self.args = args</font>
<font color="red"> 466.         self.kwargs = kwargs</font>
<font color="red"> 467.         self.asvar = asvar</font>
<font color="black"> 468. </font>
<font color="green"> 469.     def render(self, context):</font>
<font color="red"> 470.         from django.core.urlresolvers import reverse, NoReverseMatch</font>
<font color="red"> 471.         args = [arg.resolve(context) for arg in self.args]</font>
<font color="black"> 472.         kwargs = {</font>
<font color="red"> 473.             smart_text(k, 'ascii'): v.resolve(context)</font>
<font color="red"> 474.             for k, v in self.kwargs.items()</font>
<font color="black"> 475.         }</font>
<font color="black"> 476. </font>
<font color="red"> 477.         view_name = self.view_name.resolve(context)</font>
<font color="black"> 478. </font>
<font color="red"> 479.         try:</font>
<font color="red"> 480.             current_app = context.request.current_app</font>
<font color="red"> 481.         except AttributeError:</font>
<font color="black"> 482.             # Leave only the else block when the deprecation path for</font>
<font color="black"> 483.             # Context.current_app completes in Django 1.10.</font>
<font color="black"> 484.             # Can also remove the Context.is_current_app_set property.</font>
<font color="red"> 485.             if context.is_current_app_set:</font>
<font color="red"> 486.                 current_app = context.current_app</font>
<font color="black"> 487.             else:</font>
<font color="red"> 488.                 try:</font>
<font color="red"> 489.                     current_app = context.request.resolver_match.namespace</font>
<font color="red"> 490.                 except AttributeError:</font>
<font color="red"> 491.                     current_app = None</font>
<font color="black"> 492. </font>
<font color="black"> 493.         # Try to look up the URL twice: once given the view name, and again</font>
<font color="black"> 494.         # relative to what we guess is the &quot;main&quot; app. If they both fail,</font>
<font color="black"> 495.         # re-raise the NoReverseMatch unless we're using the</font>
<font color="black"> 496.         # {% url ... as var %} construct in which case return nothing.</font>
<font color="red"> 497.         url = ''</font>
<font color="red"> 498.         try:</font>
<font color="red"> 499.             url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)</font>
<font color="red"> 500.         except NoReverseMatch:</font>
<font color="red"> 501.             exc_info = sys.exc_info()</font>
<font color="red"> 502.             if settings.SETTINGS_MODULE:</font>
<font color="red"> 503.                 project_name = settings.SETTINGS_MODULE.split('.')[0]</font>
<font color="red"> 504.                 try:</font>
<font color="red"> 505.                     url = reverse(project_name + '.' + view_name,</font>
<font color="red"> 506.                               args=args, kwargs=kwargs,</font>
<font color="red"> 507.                               current_app=current_app)</font>
<font color="red"> 508.                 except NoReverseMatch:</font>
<font color="red"> 509.                     if self.asvar is None:</font>
<font color="black"> 510.                         # Re-raise the original exception, not the one with</font>
<font color="black"> 511.                         # the path relative to the project. This makes a</font>
<font color="black"> 512.                         # better error message.</font>
<font color="red"> 513.                         six.reraise(*exc_info)</font>
<font color="black"> 514.             else:</font>
<font color="red"> 515.                 if self.asvar is None:</font>
<font color="red"> 516.                     raise</font>
<font color="black"> 517. </font>
<font color="red"> 518.         if self.asvar:</font>
<font color="red"> 519.             context[self.asvar] = url</font>
<font color="red"> 520.             return ''</font>
<font color="black"> 521.         else:</font>
<font color="red"> 522.             if context.autoescape:</font>
<font color="red"> 523.                 url = conditional_escape(url)</font>
<font color="red"> 524.             return url</font>
<font color="black"> 525. </font>
<font color="black"> 526. </font>
<font color="green"> 527. class VerbatimNode(Node):</font>
<font color="green"> 528.     def __init__(self, content):</font>
<font color="red"> 529.         self.content = content</font>
<font color="black"> 530. </font>
<font color="green"> 531.     def render(self, context):</font>
<font color="red"> 532.         return self.content</font>
<font color="black"> 533. </font>
<font color="black"> 534. </font>
<font color="green"> 535. class WidthRatioNode(Node):</font>
<font color="green"> 536.     def __init__(self, val_expr, max_expr, max_width, asvar=None):</font>
<font color="red"> 537.         self.val_expr = val_expr</font>
<font color="red"> 538.         self.max_expr = max_expr</font>
<font color="red"> 539.         self.max_width = max_width</font>
<font color="red"> 540.         self.asvar = asvar</font>
<font color="black"> 541. </font>
<font color="green"> 542.     def render(self, context):</font>
<font color="red"> 543.         try:</font>
<font color="red"> 544.             value = self.val_expr.resolve(context)</font>
<font color="red"> 545.             max_value = self.max_expr.resolve(context)</font>
<font color="red"> 546.             max_width = int(self.max_width.resolve(context))</font>
<font color="red"> 547.         except VariableDoesNotExist:</font>
<font color="red"> 548.             return ''</font>
<font color="red"> 549.         except (ValueError, TypeError):</font>
<font color="red"> 550.             raise TemplateSyntaxError(&quot;widthratio final argument must be a number&quot;)</font>
<font color="red"> 551.         try:</font>
<font color="red"> 552.             value = float(value)</font>
<font color="red"> 553.             max_value = float(max_value)</font>
<font color="red"> 554.             ratio = (value / max_value) * max_width</font>
<font color="red"> 555.             result = str(int(round(ratio)))</font>
<font color="red"> 556.         except ZeroDivisionError:</font>
<font color="red"> 557.             return '0'</font>
<font color="red"> 558.         except (ValueError, TypeError, OverflowError):</font>
<font color="red"> 559.             return ''</font>
<font color="black"> 560. </font>
<font color="red"> 561.         if self.asvar:</font>
<font color="red"> 562.             context[self.asvar] = result</font>
<font color="red"> 563.             return ''</font>
<font color="black"> 564.         else:</font>
<font color="red"> 565.             return result</font>
<font color="black"> 566. </font>
<font color="black"> 567. </font>
<font color="green"> 568. class WithNode(Node):</font>
<font color="green"> 569.     def __init__(self, var, name, nodelist, extra_context=None):</font>
<font color="red"> 570.         self.nodelist = nodelist</font>
<font color="black"> 571.         # var and name are legacy attributes, being left in case they are used</font>
<font color="black"> 572.         # by third-party subclasses of this Node.</font>
<font color="red"> 573.         self.extra_context = extra_context or {}</font>
<font color="red"> 574.         if name:</font>
<font color="red"> 575.             self.extra_context[name] = var</font>
<font color="black"> 576. </font>
<font color="green"> 577.     def __repr__(self):</font>
<font color="red"> 578.         return &quot;&lt;WithNode&gt;&quot;</font>
<font color="black"> 579. </font>
<font color="green"> 580.     def render(self, context):</font>
<font color="red"> 581.         values = {key: val.resolve(context) for key, val in</font>
<font color="red"> 582.                   six.iteritems(self.extra_context)}</font>
<font color="red"> 583.         with context.push(**values):</font>
<font color="red"> 584.             return self.nodelist.render(context)</font>
<font color="black"> 585. </font>
<font color="black"> 586. </font>
<font color="green"> 587. @register.tag</font>
<font color="black"> 588. def autoescape(parser, token):</font>
<font color="black"> 589.     &quot;&quot;&quot;</font>
<font color="black"> 590.     Force autoescape behavior for this block.</font>
<font color="black"> 591.     &quot;&quot;&quot;</font>
<font color="black"> 592.     # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</font>
<font color="red"> 593.     args = token.contents.split()</font>
<font color="red"> 594.     if len(args) != 2:</font>
<font color="red"> 595.         raise TemplateSyntaxError(&quot;'autoescape' tag requires exactly one argument.&quot;)</font>
<font color="red"> 596.     arg = args[1]</font>
<font color="red"> 597.     if arg not in ('on', 'off'):</font>
<font color="red"> 598.         raise TemplateSyntaxError(&quot;'autoescape' argument should be 'on' or 'off'&quot;)</font>
<font color="red"> 599.     nodelist = parser.parse(('endautoescape',))</font>
<font color="red"> 600.     parser.delete_first_token()</font>
<font color="red"> 601.     return AutoEscapeControlNode((arg == 'on'), nodelist)</font>
<font color="black"> 602. </font>
<font color="black"> 603. </font>
<font color="green"> 604. @register.tag</font>
<font color="black"> 605. def comment(parser, token):</font>
<font color="black"> 606.     &quot;&quot;&quot;</font>
<font color="black"> 607.     Ignores everything between ``{% comment %}`` and ``{% endcomment %}``.</font>
<font color="black"> 608.     &quot;&quot;&quot;</font>
<font color="red"> 609.     parser.skip_past('endcomment')</font>
<font color="red"> 610.     return CommentNode()</font>
<font color="black"> 611. </font>
<font color="black"> 612. </font>
<font color="green"> 613. @register.tag</font>
<font color="black"> 614. def cycle(parser, token):</font>
<font color="black"> 615.     &quot;&quot;&quot;</font>
<font color="black"> 616.     Cycles among the given strings each time this tag is encountered.</font>
<font color="black"> 617. </font>
<font color="black"> 618.     Within a loop, cycles among the given strings each time through</font>
<font color="black"> 619.     the loop::</font>
<font color="black"> 620. </font>
<font color="black"> 621.         {% for o in some_list %}</font>
<font color="black"> 622.             &lt;tr class=&quot;{% cycle 'row1' 'row2' %}&quot;&gt;</font>
<font color="black"> 623.                 ...</font>
<font color="black"> 624.             &lt;/tr&gt;</font>
<font color="black"> 625.         {% endfor %}</font>
<font color="black"> 626. </font>
<font color="black"> 627.     Outside of a loop, give the values a unique name the first time you call</font>
<font color="black"> 628.     it, then use that name each successive time through::</font>
<font color="black"> 629. </font>
<font color="black"> 630.             &lt;tr class=&quot;{% cycle 'row1' 'row2' 'row3' as rowcolors %}&quot;&gt;...&lt;/tr&gt;</font>
<font color="black"> 631.             &lt;tr class=&quot;{% cycle rowcolors %}&quot;&gt;...&lt;/tr&gt;</font>
<font color="black"> 632.             &lt;tr class=&quot;{% cycle rowcolors %}&quot;&gt;...&lt;/tr&gt;</font>
<font color="black"> 633. </font>
<font color="black"> 634.     You can use any number of values, separated by spaces. Commas can also</font>
<font color="black"> 635.     be used to separate values; if a comma is used, the cycle values are</font>
<font color="black"> 636.     interpreted as literal strings.</font>
<font color="black"> 637. </font>
<font color="black"> 638.     The optional flag &quot;silent&quot; can be used to prevent the cycle declaration</font>
<font color="black"> 639.     from returning any value::</font>
<font color="black"> 640. </font>
<font color="black"> 641.         {% for o in some_list %}</font>
<font color="black"> 642.             {% cycle 'row1' 'row2' as rowcolors silent %}</font>
<font color="black"> 643.             &lt;tr class=&quot;{{ rowcolors }}&quot;&gt;{% include &quot;subtemplate.html &quot; %}&lt;/tr&gt;</font>
<font color="black"> 644.         {% endfor %}</font>
<font color="black"> 645.     &quot;&quot;&quot;</font>
<font color="black"> 646.     # Note: This returns the exact same node on each {% cycle name %} call;</font>
<font color="black"> 647.     # that is, the node object returned from {% cycle a b c as name %} and the</font>
<font color="black"> 648.     # one returned from {% cycle name %} are the exact same object. This</font>
<font color="black"> 649.     # shouldn't cause problems (heh), but if it does, now you know.</font>
<font color="black"> 650.     #</font>
<font color="black"> 651.     # Ugly hack warning: This stuffs the named template dict into parser so</font>
<font color="black"> 652.     # that names are only unique within each template (as opposed to using</font>
<font color="black"> 653.     # a global variable, which would make cycle names have to be unique across</font>
<font color="black"> 654.     # *all* templates.</font>
<font color="black"> 655. </font>
<font color="red"> 656.     args = token.split_contents()</font>
<font color="black"> 657. </font>
<font color="red"> 658.     if len(args) &lt; 2:</font>
<font color="red"> 659.         raise TemplateSyntaxError(&quot;'cycle' tag requires at least two arguments&quot;)</font>
<font color="black"> 660. </font>
<font color="red"> 661.     if ',' in args[1]:</font>
<font color="red"> 662.         warnings.warn(</font>
<font color="red"> 663.             &quot;The old {% cycle %} syntax with comma-separated arguments is deprecated.&quot;,</font>
<font color="red"> 664.             RemovedInDjango110Warning,</font>
<font color="black"> 665.         )</font>
<font color="black"> 666.         # Backwards compatibility: {% cycle a,b %} or {% cycle a,b as foo %}</font>
<font color="black"> 667.         # case.</font>
<font color="red"> 668.         args[1:2] = ['&quot;%s&quot;' % arg for arg in args[1].split(&quot;,&quot;)]</font>
<font color="black"> 669. </font>
<font color="red"> 670.     if len(args) == 2:</font>
<font color="black"> 671.         # {% cycle foo %} case.</font>
<font color="red"> 672.         name = args[1]</font>
<font color="red"> 673.         if not hasattr(parser, '_namedCycleNodes'):</font>
<font color="red"> 674.             raise TemplateSyntaxError(&quot;No named cycles in template. '%s' is not defined&quot; % name)</font>
<font color="red"> 675.         if name not in parser._namedCycleNodes:</font>
<font color="red"> 676.             raise TemplateSyntaxError(&quot;Named cycle '%s' does not exist&quot; % name)</font>
<font color="red"> 677.         return parser._namedCycleNodes[name]</font>
<font color="black"> 678. </font>
<font color="red"> 679.     as_form = False</font>
<font color="black"> 680. </font>
<font color="red"> 681.     if len(args) &gt; 4:</font>
<font color="black"> 682.         # {% cycle ... as foo [silent] %} case.</font>
<font color="red"> 683.         if args[-3] == &quot;as&quot;:</font>
<font color="red"> 684.             if args[-1] != &quot;silent&quot;:</font>
<font color="red"> 685.                 raise TemplateSyntaxError(&quot;Only 'silent' flag is allowed after cycle's name, not '%s'.&quot; % args[-1])</font>
<font color="red"> 686.             as_form = True</font>
<font color="red"> 687.             silent = True</font>
<font color="red"> 688.             args = args[:-1]</font>
<font color="red"> 689.         elif args[-2] == &quot;as&quot;:</font>
<font color="red"> 690.             as_form = True</font>
<font color="red"> 691.             silent = False</font>
<font color="black"> 692. </font>
<font color="red"> 693.     if as_form:</font>
<font color="red"> 694.         name = args[-1]</font>
<font color="red"> 695.         values = [parser.compile_filter(arg) for arg in args[1:-2]]</font>
<font color="red"> 696.         node = CycleNode(values, name, silent=silent)</font>
<font color="red"> 697.         if not hasattr(parser, '_namedCycleNodes'):</font>
<font color="red"> 698.             parser._namedCycleNodes = {}</font>
<font color="red"> 699.         parser._namedCycleNodes[name] = node</font>
<font color="black"> 700.     else:</font>
<font color="red"> 701.         values = [parser.compile_filter(arg) for arg in args[1:]]</font>
<font color="red"> 702.         node = CycleNode(values)</font>
<font color="red"> 703.     return node</font>
<font color="black"> 704. </font>
<font color="black"> 705. </font>
<font color="green"> 706. @register.tag</font>
<font color="black"> 707. def csrf_token(parser, token):</font>
<font color="red"> 708.     return CsrfTokenNode()</font>
<font color="black"> 709. </font>
<font color="black"> 710. </font>
<font color="green"> 711. @register.tag</font>
<font color="black"> 712. def debug(parser, token):</font>
<font color="black"> 713.     &quot;&quot;&quot;</font>
<font color="black"> 714.     Outputs a whole load of debugging information, including the current</font>
<font color="black"> 715.     context and imported modules.</font>
<font color="black"> 716. </font>
<font color="black"> 717.     Sample usage::</font>
<font color="black"> 718. </font>
<font color="black"> 719.         &lt;pre&gt;</font>
<font color="black"> 720.             {% debug %}</font>
<font color="black"> 721.         &lt;/pre&gt;</font>
<font color="black"> 722.     &quot;&quot;&quot;</font>
<font color="red"> 723.     return DebugNode()</font>
<font color="black"> 724. </font>
<font color="black"> 725. </font>
<font color="green"> 726. @register.tag('filter')</font>
<font color="black"> 727. def do_filter(parser, token):</font>
<font color="black"> 728.     &quot;&quot;&quot;</font>
<font color="black"> 729.     Filters the contents of the block through variable filters.</font>
<font color="black"> 730. </font>
<font color="black"> 731.     Filters can also be piped through each other, and they can have</font>
<font color="black"> 732.     arguments -- just like in variable syntax.</font>
<font color="black"> 733. </font>
<font color="black"> 734.     Sample usage::</font>
<font color="black"> 735. </font>
<font color="black"> 736.         {% filter force_escape|lower %}</font>
<font color="black"> 737.             This text will be HTML-escaped, and will appear in lowercase.</font>
<font color="black"> 738.         {% endfilter %}</font>
<font color="black"> 739. </font>
<font color="black"> 740.     Note that the ``escape`` and ``safe`` filters are not acceptable arguments.</font>
<font color="black"> 741.     Instead, use the ``autoescape`` tag to manage autoescaping for blocks of</font>
<font color="black"> 742.     template code.</font>
<font color="black"> 743.     &quot;&quot;&quot;</font>
<font color="black"> 744.     # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</font>
<font color="red"> 745.     _, rest = token.contents.split(None, 1)</font>
<font color="red"> 746.     filter_expr = parser.compile_filter(&quot;var|%s&quot; % (rest))</font>
<font color="red"> 747.     for func, unused in filter_expr.filters:</font>
<font color="red"> 748.         filter_name = getattr(func, '_filter_name', None)</font>
<font color="red"> 749.         if filter_name in ('escape', 'safe'):</font>
<font color="red"> 750.             raise TemplateSyntaxError('&quot;filter %s&quot; is not permitted.  Use the &quot;autoescape&quot; tag instead.' % filter_name)</font>
<font color="red"> 751.     nodelist = parser.parse(('endfilter',))</font>
<font color="red"> 752.     parser.delete_first_token()</font>
<font color="red"> 753.     return FilterNode(filter_expr, nodelist)</font>
<font color="black"> 754. </font>
<font color="black"> 755. </font>
<font color="green"> 756. @register.tag</font>
<font color="black"> 757. def firstof(parser, token):</font>
<font color="black"> 758.     &quot;&quot;&quot;</font>
<font color="black"> 759.     Outputs the first variable passed that is not False, without escaping.</font>
<font color="black"> 760. </font>
<font color="black"> 761.     Outputs nothing if all the passed variables are False.</font>
<font color="black"> 762. </font>
<font color="black"> 763.     Sample usage::</font>
<font color="black"> 764. </font>
<font color="black"> 765.         {% firstof var1 var2 var3 as myvar %}</font>
<font color="black"> 766. </font>
<font color="black"> 767.     This is equivalent to::</font>
<font color="black"> 768. </font>
<font color="black"> 769.         {% if var1 %}</font>
<font color="black"> 770.             {{ var1|safe }}</font>
<font color="black"> 771.         {% elif var2 %}</font>
<font color="black"> 772.             {{ var2|safe }}</font>
<font color="black"> 773.         {% elif var3 %}</font>
<font color="black"> 774.             {{ var3|safe }}</font>
<font color="black"> 775.         {% endif %}</font>
<font color="black"> 776. </font>
<font color="black"> 777.     but obviously much cleaner!</font>
<font color="black"> 778. </font>
<font color="black"> 779.     You can also use a literal string as a fallback value in case all</font>
<font color="black"> 780.     passed variables are False::</font>
<font color="black"> 781. </font>
<font color="black"> 782.         {% firstof var1 var2 var3 &quot;fallback value&quot; %}</font>
<font color="black"> 783. </font>
<font color="black"> 784.     If you want to disable auto-escaping of variables you can use::</font>
<font color="black"> 785. </font>
<font color="black"> 786.         {% autoescape off %}</font>
<font color="black"> 787.             {% firstof var1 var2 var3 &quot;&lt;strong&gt;fallback value&lt;/strong&gt;&quot; %}</font>
<font color="black"> 788.         {% autoescape %}</font>
<font color="black"> 789. </font>
<font color="black"> 790.     Or if only some variables should be escaped, you can use::</font>
<font color="black"> 791. </font>
<font color="black"> 792.         {% firstof var1 var2|safe var3 &quot;&lt;strong&gt;fallback value&lt;/strong&gt;&quot;|safe %}</font>
<font color="black"> 793.     &quot;&quot;&quot;</font>
<font color="red"> 794.     bits = token.split_contents()[1:]</font>
<font color="red"> 795.     asvar = None</font>
<font color="red"> 796.     if len(bits) &lt; 1:</font>
<font color="red"> 797.         raise TemplateSyntaxError(&quot;'firstof' statement requires at least one argument&quot;)</font>
<font color="black"> 798. </font>
<font color="red"> 799.     if len(bits) &gt;= 2 and bits[-2] == 'as':</font>
<font color="red"> 800.         asvar = bits[-1]</font>
<font color="red"> 801.         bits = bits[:-2]</font>
<font color="red"> 802.     return FirstOfNode([parser.compile_filter(bit) for bit in bits], asvar)</font>
<font color="black"> 803. </font>
<font color="black"> 804. </font>
<font color="green"> 805. @register.tag('for')</font>
<font color="black"> 806. def do_for(parser, token):</font>
<font color="black"> 807.     &quot;&quot;&quot;</font>
<font color="black"> 808.     Loops over each item in an array.</font>
<font color="black"> 809. </font>
<font color="black"> 810.     For example, to display a list of athletes given ``athlete_list``::</font>
<font color="black"> 811. </font>
<font color="black"> 812.         &lt;ul&gt;</font>
<font color="black"> 813.         {% for athlete in athlete_list %}</font>
<font color="black"> 814.             &lt;li&gt;{{ athlete.name }}&lt;/li&gt;</font>
<font color="black"> 815.         {% endfor %}</font>
<font color="black"> 816.         &lt;/ul&gt;</font>
<font color="black"> 817. </font>
<font color="black"> 818.     You can loop over a list in reverse by using</font>
<font color="black"> 819.     ``{% for obj in list reversed %}``.</font>
<font color="black"> 820. </font>
<font color="black"> 821.     You can also unpack multiple values from a two-dimensional array::</font>
<font color="black"> 822. </font>
<font color="black"> 823.         {% for key,value in dict.items %}</font>
<font color="black"> 824.             {{ key }}: {{ value }}</font>
<font color="black"> 825.         {% endfor %}</font>
<font color="black"> 826. </font>
<font color="black"> 827.     The ``for`` tag can take an optional ``{% empty %}`` clause that will</font>
<font color="black"> 828.     be displayed if the given array is empty or could not be found::</font>
<font color="black"> 829. </font>
<font color="black"> 830.         &lt;ul&gt;</font>
<font color="black"> 831.           {% for athlete in athlete_list %}</font>
<font color="black"> 832.             &lt;li&gt;{{ athlete.name }}&lt;/li&gt;</font>
<font color="black"> 833.           {% empty %}</font>
<font color="black"> 834.             &lt;li&gt;Sorry, no athletes in this list.&lt;/li&gt;</font>
<font color="black"> 835.           {% endfor %}</font>
<font color="black"> 836.         &lt;ul&gt;</font>
<font color="black"> 837. </font>
<font color="black"> 838.     The above is equivalent to -- but shorter, cleaner, and possibly faster</font>
<font color="black"> 839.     than -- the following::</font>
<font color="black"> 840. </font>
<font color="black"> 841.         &lt;ul&gt;</font>
<font color="black"> 842.           {% if althete_list %}</font>
<font color="black"> 843.             {% for athlete in athlete_list %}</font>
<font color="black"> 844.               &lt;li&gt;{{ athlete.name }}&lt;/li&gt;</font>
<font color="black"> 845.             {% endfor %}</font>
<font color="black"> 846.           {% else %}</font>
<font color="black"> 847.             &lt;li&gt;Sorry, no athletes in this list.&lt;/li&gt;</font>
<font color="black"> 848.           {% endif %}</font>
<font color="black"> 849.         &lt;/ul&gt;</font>
<font color="black"> 850. </font>
<font color="black"> 851.     The for loop sets a number of variables available within the loop:</font>
<font color="black"> 852. </font>
<font color="black"> 853.         ==========================  ================================================</font>
<font color="black"> 854.         Variable                    Description</font>
<font color="black"> 855.         ==========================  ================================================</font>
<font color="black"> 856.         ``forloop.counter``         The current iteration of the loop (1-indexed)</font>
<font color="black"> 857.         ``forloop.counter0``        The current iteration of the loop (0-indexed)</font>
<font color="black"> 858.         ``forloop.revcounter``      The number of iterations from the end of the</font>
<font color="black"> 859.                                     loop (1-indexed)</font>
<font color="black"> 860.         ``forloop.revcounter0``     The number of iterations from the end of the</font>
<font color="black"> 861.                                     loop (0-indexed)</font>
<font color="black"> 862.         ``forloop.first``           True if this is the first time through the loop</font>
<font color="black"> 863.         ``forloop.last``            True if this is the last time through the loop</font>
<font color="black"> 864.         ``forloop.parentloop``      For nested loops, this is the loop &quot;above&quot; the</font>
<font color="black"> 865.                                     current one</font>
<font color="black"> 866.         ==========================  ================================================</font>
<font color="black"> 867.     &quot;&quot;&quot;</font>
<font color="red"> 868.     bits = token.split_contents()</font>
<font color="red"> 869.     if len(bits) &lt; 4:</font>
<font color="red"> 870.         raise TemplateSyntaxError(&quot;'for' statements should have at least four&quot;</font>
<font color="red"> 871.                                   &quot; words: %s&quot; % token.contents)</font>
<font color="black"> 872. </font>
<font color="red"> 873.     is_reversed = bits[-1] == 'reversed'</font>
<font color="red"> 874.     in_index = -3 if is_reversed else -2</font>
<font color="red"> 875.     if bits[in_index] != 'in':</font>
<font color="red"> 876.         raise TemplateSyntaxError(&quot;'for' statements should use the format&quot;</font>
<font color="red"> 877.                                   &quot; 'for x in y': %s&quot; % token.contents)</font>
<font color="black"> 878. </font>
<font color="red"> 879.     loopvars = re.split(r' *, *', ' '.join(bits[1:in_index]))</font>
<font color="red"> 880.     for var in loopvars:</font>
<font color="red"> 881.         if not var or ' ' in var:</font>
<font color="red"> 882.             raise TemplateSyntaxError(&quot;'for' tag received an invalid argument:&quot;</font>
<font color="red"> 883.                                       &quot; %s&quot; % token.contents)</font>
<font color="black"> 884. </font>
<font color="red"> 885.     sequence = parser.compile_filter(bits[in_index + 1])</font>
<font color="red"> 886.     nodelist_loop = parser.parse(('empty', 'endfor',))</font>
<font color="red"> 887.     token = parser.next_token()</font>
<font color="red"> 888.     if token.contents == 'empty':</font>
<font color="red"> 889.         nodelist_empty = parser.parse(('endfor',))</font>
<font color="red"> 890.         parser.delete_first_token()</font>
<font color="black"> 891.     else:</font>
<font color="red"> 892.         nodelist_empty = None</font>
<font color="red"> 893.     return ForNode(loopvars, sequence, is_reversed, nodelist_loop, nodelist_empty)</font>
<font color="black"> 894. </font>
<font color="black"> 895. </font>
<font color="green"> 896. def do_ifequal(parser, token, negate):</font>
<font color="red"> 897.     bits = list(token.split_contents())</font>
<font color="red"> 898.     if len(bits) != 3:</font>
<font color="red"> 899.         raise TemplateSyntaxError(&quot;%r takes two arguments&quot; % bits[0])</font>
<font color="red"> 900.     end_tag = 'end' + bits[0]</font>
<font color="red"> 901.     nodelist_true = parser.parse(('else', end_tag))</font>
<font color="red"> 902.     token = parser.next_token()</font>
<font color="red"> 903.     if token.contents == 'else':</font>
<font color="red"> 904.         nodelist_false = parser.parse((end_tag,))</font>
<font color="red"> 905.         parser.delete_first_token()</font>
<font color="black"> 906.     else:</font>
<font color="red"> 907.         nodelist_false = NodeList()</font>
<font color="red"> 908.     val1 = parser.compile_filter(bits[1])</font>
<font color="red"> 909.     val2 = parser.compile_filter(bits[2])</font>
<font color="red"> 910.     return IfEqualNode(val1, val2, nodelist_true, nodelist_false, negate)</font>
<font color="black"> 911. </font>
<font color="black"> 912. </font>
<font color="green"> 913. @register.tag</font>
<font color="black"> 914. def ifequal(parser, token):</font>
<font color="black"> 915.     &quot;&quot;&quot;</font>
<font color="black"> 916.     Outputs the contents of the block if the two arguments equal each other.</font>
<font color="black"> 917. </font>
<font color="black"> 918.     Examples::</font>
<font color="black"> 919. </font>
<font color="black"> 920.         {% ifequal user.id comment.user_id %}</font>
<font color="black"> 921.             ...</font>
<font color="black"> 922.         {% endifequal %}</font>
<font color="black"> 923. </font>
<font color="black"> 924.         {% ifnotequal user.id comment.user_id %}</font>
<font color="black"> 925.             ...</font>
<font color="black"> 926.         {% else %}</font>
<font color="black"> 927.             ...</font>
<font color="black"> 928.         {% endifnotequal %}</font>
<font color="black"> 929.     &quot;&quot;&quot;</font>
<font color="red"> 930.     return do_ifequal(parser, token, False)</font>
<font color="black"> 931. </font>
<font color="black"> 932. </font>
<font color="green"> 933. @register.tag</font>
<font color="black"> 934. def ifnotequal(parser, token):</font>
<font color="black"> 935.     &quot;&quot;&quot;</font>
<font color="black"> 936.     Outputs the contents of the block if the two arguments are not equal.</font>
<font color="black"> 937.     See ifequal.</font>
<font color="black"> 938.     &quot;&quot;&quot;</font>
<font color="red"> 939.     return do_ifequal(parser, token, True)</font>
<font color="black"> 940. </font>
<font color="black"> 941. </font>
<font color="green"> 942. class TemplateLiteral(Literal):</font>
<font color="green"> 943.     def __init__(self, value, text):</font>
<font color="red"> 944.         self.value = value</font>
<font color="red"> 945.         self.text = text  # for better error messages</font>
<font color="black"> 946. </font>
<font color="green"> 947.     def display(self):</font>
<font color="red"> 948.         return self.text</font>
<font color="black"> 949. </font>
<font color="green"> 950.     def eval(self, context):</font>
<font color="red"> 951.         return self.value.resolve(context, ignore_failures=True)</font>
<font color="black"> 952. </font>
<font color="black"> 953. </font>
<font color="green"> 954. class TemplateIfParser(IfParser):</font>
<font color="green"> 955.     error_class = TemplateSyntaxError</font>
<font color="black"> 956. </font>
<font color="green"> 957.     def __init__(self, parser, *args, **kwargs):</font>
<font color="red"> 958.         self.template_parser = parser</font>
<font color="red"> 959.         super(TemplateIfParser, self).__init__(*args, **kwargs)</font>
<font color="black"> 960. </font>
<font color="green"> 961.     def create_var(self, value):</font>
<font color="red"> 962.         return TemplateLiteral(self.template_parser.compile_filter(value), value)</font>
<font color="black"> 963. </font>
<font color="black"> 964. </font>
<font color="green"> 965. @register.tag('if')</font>
<font color="black"> 966. def do_if(parser, token):</font>
<font color="black"> 967.     &quot;&quot;&quot;</font>
<font color="black"> 968.     The ``{% if %}`` tag evaluates a variable, and if that variable is &quot;true&quot;</font>
<font color="black"> 969.     (i.e., exists, is not empty, and is not a false boolean value), the</font>
<font color="black"> 970.     contents of the block are output:</font>
<font color="black"> 971. </font>
<font color="black"> 972.     ::</font>
<font color="black"> 973. </font>
<font color="black"> 974.         {% if athlete_list %}</font>
<font color="black"> 975.             Number of athletes: {{ athlete_list|count }}</font>
<font color="black"> 976.         {% elif athlete_in_locker_room_list %}</font>
<font color="black"> 977.             Athletes should be out of the locker room soon!</font>
<font color="black"> 978.         {% else %}</font>
<font color="black"> 979.             No athletes.</font>
<font color="black"> 980.         {% endif %}</font>
<font color="black"> 981. </font>
<font color="black"> 982.     In the above, if ``athlete_list`` is not empty, the number of athletes will</font>
<font color="black"> 983.     be displayed by the ``{{ athlete_list|count }}`` variable.</font>
<font color="black"> 984. </font>
<font color="black"> 985.     As you can see, the ``if`` tag may take one or several `` {% elif %}``</font>
<font color="black"> 986.     clauses, as well as an ``{% else %}`` clause that will be displayed if all</font>
<font color="black"> 987.     previous conditions fail. These clauses are optional.</font>
<font color="black"> 988. </font>
<font color="black"> 989.     ``if`` tags may use ``or``, ``and`` or ``not`` to test a number of</font>
<font color="black"> 990.     variables or to negate a given variable::</font>
<font color="black"> 991. </font>
<font color="black"> 992.         {% if not athlete_list %}</font>
<font color="black"> 993.             There are no athletes.</font>
<font color="black"> 994.         {% endif %}</font>
<font color="black"> 995. </font>
<font color="black"> 996.         {% if athlete_list or coach_list %}</font>
<font color="black"> 997.             There are some athletes or some coaches.</font>
<font color="black"> 998.         {% endif %}</font>
<font color="black"> 999. </font>
<font color="black">1000.         {% if athlete_list and coach_list %}</font>
<font color="black">1001.             Both athletes and coaches are available.</font>
<font color="black">1002.         {% endif %}</font>
<font color="black">1003. </font>
<font color="black">1004.         {% if not athlete_list or coach_list %}</font>
<font color="black">1005.             There are no athletes, or there are some coaches.</font>
<font color="black">1006.         {% endif %}</font>
<font color="black">1007. </font>
<font color="black">1008.         {% if athlete_list and not coach_list %}</font>
<font color="black">1009.             There are some athletes and absolutely no coaches.</font>
<font color="black">1010.         {% endif %}</font>
<font color="black">1011. </font>
<font color="black">1012.     Comparison operators are also available, and the use of filters is also</font>
<font color="black">1013.     allowed, for example::</font>
<font color="black">1014. </font>
<font color="black">1015.         {% if articles|length &gt;= 5 %}...{% endif %}</font>
<font color="black">1016. </font>
<font color="black">1017.     Arguments and operators _must_ have a space between them, so</font>
<font color="black">1018.     ``{% if 1&gt;2 %}`` is not a valid if tag.</font>
<font color="black">1019. </font>
<font color="black">1020.     All supported operators are: ``or``, ``and``, ``in``, ``not in``</font>
<font color="black">1021.     ``==``, ``!=``, ``&gt;``, ``&gt;=``, ``&lt;`` and ``&lt;=``.</font>
<font color="black">1022. </font>
<font color="black">1023.     Operator precedence follows Python.</font>
<font color="black">1024.     &quot;&quot;&quot;</font>
<font color="black">1025.     # {% if ... %}</font>
<font color="red">1026.     bits = token.split_contents()[1:]</font>
<font color="red">1027.     condition = TemplateIfParser(parser, bits).parse()</font>
<font color="red">1028.     nodelist = parser.parse(('elif', 'else', 'endif'))</font>
<font color="red">1029.     conditions_nodelists = [(condition, nodelist)]</font>
<font color="red">1030.     token = parser.next_token()</font>
<font color="black">1031. </font>
<font color="black">1032.     # {% elif ... %} (repeatable)</font>
<font color="red">1033.     while token.contents.startswith('elif'):</font>
<font color="red">1034.         bits = token.split_contents()[1:]</font>
<font color="red">1035.         condition = TemplateIfParser(parser, bits).parse()</font>
<font color="red">1036.         nodelist = parser.parse(('elif', 'else', 'endif'))</font>
<font color="red">1037.         conditions_nodelists.append((condition, nodelist))</font>
<font color="red">1038.         token = parser.next_token()</font>
<font color="black">1039. </font>
<font color="black">1040.     # {% else %} (optional)</font>
<font color="red">1041.     if token.contents == 'else':</font>
<font color="red">1042.         nodelist = parser.parse(('endif',))</font>
<font color="red">1043.         conditions_nodelists.append((None, nodelist))</font>
<font color="red">1044.         token = parser.next_token()</font>
<font color="black">1045. </font>
<font color="black">1046.     # {% endif %}</font>
<font color="red">1047.     assert token.contents == 'endif'</font>
<font color="black">1048. </font>
<font color="red">1049.     return IfNode(conditions_nodelists)</font>
<font color="black">1050. </font>
<font color="black">1051. </font>
<font color="green">1052. @register.tag</font>
<font color="black">1053. def ifchanged(parser, token):</font>
<font color="black">1054.     &quot;&quot;&quot;</font>
<font color="black">1055.     Checks if a value has changed from the last iteration of a loop.</font>
<font color="black">1056. </font>
<font color="black">1057.     The ``{% ifchanged %}`` block tag is used within a loop. It has two</font>
<font color="black">1058.     possible uses.</font>
<font color="black">1059. </font>
<font color="black">1060.     1. Checks its own rendered contents against its previous state and only</font>
<font color="black">1061.        displays the content if it has changed. For example, this displays a</font>
<font color="black">1062.        list of days, only displaying the month if it changes::</font>
<font color="black">1063. </font>
<font color="black">1064.             &lt;h1&gt;Archive for {{ year }}&lt;/h1&gt;</font>
<font color="black">1065. </font>
<font color="black">1066.             {% for date in days %}</font>
<font color="black">1067.                 {% ifchanged %}&lt;h3&gt;{{ date|date:&quot;F&quot; }}&lt;/h3&gt;{% endifchanged %}</font>
<font color="black">1068.                 &lt;a href=&quot;{{ date|date:&quot;M/d&quot;|lower }}/&quot;&gt;{{ date|date:&quot;j&quot; }}&lt;/a&gt;</font>
<font color="black">1069.             {% endfor %}</font>
<font color="black">1070. </font>
<font color="black">1071.     2. If given one or more variables, check whether any variable has changed.</font>
<font color="black">1072.        For example, the following shows the date every time it changes, while</font>
<font color="black">1073.        showing the hour if either the hour or the date has changed::</font>
<font color="black">1074. </font>
<font color="black">1075.             {% for date in days %}</font>
<font color="black">1076.                 {% ifchanged date.date %} {{ date.date }} {% endifchanged %}</font>
<font color="black">1077.                 {% ifchanged date.hour date.date %}</font>
<font color="black">1078.                     {{ date.hour }}</font>
<font color="black">1079.                 {% endifchanged %}</font>
<font color="black">1080.             {% endfor %}</font>
<font color="black">1081.     &quot;&quot;&quot;</font>
<font color="red">1082.     bits = token.split_contents()</font>
<font color="red">1083.     nodelist_true = parser.parse(('else', 'endifchanged'))</font>
<font color="red">1084.     token = parser.next_token()</font>
<font color="red">1085.     if token.contents == 'else':</font>
<font color="red">1086.         nodelist_false = parser.parse(('endifchanged',))</font>
<font color="red">1087.         parser.delete_first_token()</font>
<font color="black">1088.     else:</font>
<font color="red">1089.         nodelist_false = NodeList()</font>
<font color="red">1090.     values = [parser.compile_filter(bit) for bit in bits[1:]]</font>
<font color="red">1091.     return IfChangedNode(nodelist_true, nodelist_false, *values)</font>
<font color="black">1092. </font>
<font color="black">1093. </font>
<font color="green">1094. @register.tag</font>
<font color="black">1095. def ssi(parser, token):</font>
<font color="black">1096.     &quot;&quot;&quot;</font>
<font color="black">1097.     Outputs the contents of a given file into the page.</font>
<font color="black">1098. </font>
<font color="black">1099.     Like a simple &quot;include&quot; tag, the ``ssi`` tag includes the contents</font>
<font color="black">1100.     of another file -- which must be specified using an absolute path --</font>
<font color="black">1101.     in the current page::</font>
<font color="black">1102. </font>
<font color="black">1103.         {% ssi &quot;/home/html/ljworld.com/includes/right_generic.html&quot; %}</font>
<font color="black">1104. </font>
<font color="black">1105.     If the optional &quot;parsed&quot; parameter is given, the contents of the included</font>
<font color="black">1106.     file are evaluated as template code, with the current context::</font>
<font color="black">1107. </font>
<font color="black">1108.         {% ssi &quot;/home/html/ljworld.com/includes/right_generic.html&quot; parsed %}</font>
<font color="black">1109.     &quot;&quot;&quot;</font>
<font color="red">1110.     warnings.warn(</font>
<font color="red">1111.         &quot;The {% ssi %} tag is deprecated. Use the {% include %} tag instead.&quot;,</font>
<font color="red">1112.         RemovedInDjango110Warning,</font>
<font color="black">1113.     )</font>
<font color="black">1114. </font>
<font color="red">1115.     bits = token.split_contents()</font>
<font color="red">1116.     parsed = False</font>
<font color="red">1117.     if len(bits) not in (2, 3):</font>
<font color="red">1118.         raise TemplateSyntaxError(&quot;'ssi' tag takes one argument: the path to&quot;</font>
<font color="black">1119.                                   &quot; the file to be included&quot;)</font>
<font color="red">1120.     if len(bits) == 3:</font>
<font color="red">1121.         if bits[2] == 'parsed':</font>
<font color="red">1122.             parsed = True</font>
<font color="black">1123.         else:</font>
<font color="red">1124.             raise TemplateSyntaxError(&quot;Second (optional) argument to %s tag&quot;</font>
<font color="red">1125.                                       &quot; must be 'parsed'&quot; % bits[0])</font>
<font color="red">1126.     filepath = parser.compile_filter(bits[1])</font>
<font color="red">1127.     return SsiNode(filepath, parsed)</font>
<font color="black">1128. </font>
<font color="black">1129. </font>
<font color="green">1130. def find_library(parser, name):</font>
<font color="red">1131.     try:</font>
<font color="red">1132.         return parser.libraries[name]</font>
<font color="red">1133.     except KeyError:</font>
<font color="red">1134.         raise TemplateSyntaxError(</font>
<font color="red">1135.             &quot;'%s' is not a registered tag library. Must be one of:\n%s&quot; % (</font>
<font color="red">1136.                 name, &quot;\n&quot;.join(sorted(parser.libraries.keys())),</font>
<font color="black">1137.             ),</font>
<font color="black">1138.         )</font>
<font color="black">1139. </font>
<font color="black">1140. </font>
<font color="green">1141. def load_from_library(library, label, names):</font>
<font color="black">1142.     &quot;&quot;&quot;</font>
<font color="black">1143.     Return a subset of tags and filters from a library.</font>
<font color="black">1144.     &quot;&quot;&quot;</font>
<font color="red">1145.     subset = Library()</font>
<font color="red">1146.     for name in names:</font>
<font color="red">1147.         found = False</font>
<font color="red">1148.         if name in library.tags:</font>
<font color="red">1149.             found = True</font>
<font color="red">1150.             subset.tags[name] = library.tags[name]</font>
<font color="red">1151.         if name in library.filters:</font>
<font color="red">1152.             found = True</font>
<font color="red">1153.             subset.filters[name] = library.filters[name]</font>
<font color="red">1154.         if found is False:</font>
<font color="red">1155.             raise TemplateSyntaxError(</font>
<font color="red">1156.                 &quot;'%s' is not a valid tag or filter in tag library '%s'&quot; % (</font>
<font color="red">1157.                     name, label,</font>
<font color="black">1158.                 ),</font>
<font color="black">1159.             )</font>
<font color="red">1160.     return subset</font>
<font color="black">1161. </font>
<font color="black">1162. </font>
<font color="green">1163. @register.tag</font>
<font color="black">1164. def load(parser, token):</font>
<font color="black">1165.     &quot;&quot;&quot;</font>
<font color="black">1166.     Loads a custom template tag library into the parser.</font>
<font color="black">1167. </font>
<font color="black">1168.     For example, to load the template tags in</font>
<font color="black">1169.     ``django/templatetags/news/photos.py``::</font>
<font color="black">1170. </font>
<font color="black">1171.         {% load news.photos %}</font>
<font color="black">1172. </font>
<font color="black">1173.     Can also be used to load an individual tag/filter from</font>
<font color="black">1174.     a library::</font>
<font color="black">1175. </font>
<font color="black">1176.         {% load byline from news %}</font>
<font color="black">1177.     &quot;&quot;&quot;</font>
<font color="black">1178.     # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</font>
<font color="red">1179.     bits = token.contents.split()</font>
<font color="red">1180.     if len(bits) &gt;= 4 and bits[-2] == &quot;from&quot;:</font>
<font color="black">1181.         # from syntax is used; load individual tags from the library</font>
<font color="red">1182.         name = bits[-1]</font>
<font color="red">1183.         lib = find_library(parser, name)</font>
<font color="red">1184.         subset = load_from_library(lib, name, bits[1:-2])</font>
<font color="red">1185.         parser.add_library(subset)</font>
<font color="black">1186.     else:</font>
<font color="black">1187.         # one or more libraries are specified; load and add them to the parser</font>
<font color="red">1188.         for name in bits[1:]:</font>
<font color="red">1189.             lib = find_library(parser, name)</font>
<font color="red">1190.             parser.add_library(lib)</font>
<font color="red">1191.     return LoadNode()</font>
<font color="black">1192. </font>
<font color="black">1193. </font>
<font color="green">1194. @register.tag</font>
<font color="black">1195. def lorem(parser, token):</font>
<font color="black">1196.     &quot;&quot;&quot;</font>
<font color="black">1197.     Creates random Latin text useful for providing test data in templates.</font>
<font color="black">1198. </font>
<font color="black">1199.     Usage format::</font>
<font color="black">1200. </font>
<font color="black">1201.         {% lorem [count] [method] [random] %}</font>
<font color="black">1202. </font>
<font color="black">1203.     ``count`` is a number (or variable) containing the number of paragraphs or</font>
<font color="black">1204.     words to generate (default is 1).</font>
<font color="black">1205. </font>
<font color="black">1206.     ``method`` is either ``w`` for words, ``p`` for HTML paragraphs, ``b`` for</font>
<font color="black">1207.     plain-text paragraph blocks (default is ``b``).</font>
<font color="black">1208. </font>
<font color="black">1209.     ``random`` is the word ``random``, which if given, does not use the common</font>
<font color="black">1210.     paragraph (starting &quot;Lorem ipsum dolor sit amet, consectetuer...&quot;).</font>
<font color="black">1211. </font>
<font color="black">1212.     Examples:</font>
<font color="black">1213. </font>
<font color="black">1214.     * ``{% lorem %}`` will output the common &quot;lorem ipsum&quot; paragraph</font>
<font color="black">1215.     * ``{% lorem 3 p %}`` will output the common &quot;lorem ipsum&quot; paragraph</font>
<font color="black">1216.       and two random paragraphs each wrapped in HTML ``&lt;p&gt;`` tags</font>
<font color="black">1217.     * ``{% lorem 2 w random %}`` will output two random latin words</font>
<font color="black">1218.     &quot;&quot;&quot;</font>
<font color="red">1219.     bits = list(token.split_contents())</font>
<font color="red">1220.     tagname = bits[0]</font>
<font color="black">1221.     # Random bit</font>
<font color="red">1222.     common = bits[-1] != 'random'</font>
<font color="red">1223.     if not common:</font>
<font color="red">1224.         bits.pop()</font>
<font color="black">1225.     # Method bit</font>
<font color="red">1226.     if bits[-1] in ('w', 'p', 'b'):</font>
<font color="red">1227.         method = bits.pop()</font>
<font color="black">1228.     else:</font>
<font color="red">1229.         method = 'b'</font>
<font color="black">1230.     # Count bit</font>
<font color="red">1231.     if len(bits) &gt; 1:</font>
<font color="red">1232.         count = bits.pop()</font>
<font color="black">1233.     else:</font>
<font color="red">1234.         count = '1'</font>
<font color="red">1235.     count = parser.compile_filter(count)</font>
<font color="red">1236.     if len(bits) != 1:</font>
<font color="red">1237.         raise TemplateSyntaxError(&quot;Incorrect format for %r tag&quot; % tagname)</font>
<font color="red">1238.     return LoremNode(count, method, common)</font>
<font color="black">1239. </font>
<font color="black">1240. </font>
<font color="green">1241. @register.tag</font>
<font color="black">1242. def now(parser, token):</font>
<font color="black">1243.     &quot;&quot;&quot;</font>
<font color="black">1244.     Displays the date, formatted according to the given string.</font>
<font color="black">1245. </font>
<font color="black">1246.     Uses the same format as PHP's ``date()`` function; see http://php.net/date</font>
<font color="black">1247.     for all the possible values.</font>
<font color="black">1248. </font>
<font color="black">1249.     Sample usage::</font>
<font color="black">1250. </font>
<font color="black">1251.         It is {% now &quot;jS F Y H:i&quot; %}</font>
<font color="black">1252.     &quot;&quot;&quot;</font>
<font color="red">1253.     bits = token.split_contents()</font>
<font color="red">1254.     asvar = None</font>
<font color="red">1255.     if len(bits) == 4 and bits[-2] == 'as':</font>
<font color="red">1256.         asvar = bits[-1]</font>
<font color="red">1257.         bits = bits[:-2]</font>
<font color="red">1258.     if len(bits) != 2:</font>
<font color="red">1259.         raise TemplateSyntaxError(&quot;'now' statement takes one argument&quot;)</font>
<font color="red">1260.     format_string = bits[1][1:-1]</font>
<font color="red">1261.     return NowNode(format_string, asvar)</font>
<font color="black">1262. </font>
<font color="black">1263. </font>
<font color="green">1264. @register.tag</font>
<font color="black">1265. def regroup(parser, token):</font>
<font color="black">1266.     &quot;&quot;&quot;</font>
<font color="black">1267.     Regroups a list of alike objects by a common attribute.</font>
<font color="black">1268. </font>
<font color="black">1269.     This complex tag is best illustrated by use of an example:  say that</font>
<font color="black">1270.     ``people`` is a list of ``Person`` objects that have ``first_name``,</font>
<font color="black">1271.     ``last_name``, and ``gender`` attributes, and you'd like to display a list</font>
<font color="black">1272.     that looks like:</font>
<font color="black">1273. </font>
<font color="black">1274.         * Male:</font>
<font color="black">1275.             * George Bush</font>
<font color="black">1276.             * Bill Clinton</font>
<font color="black">1277.         * Female:</font>
<font color="black">1278.             * Margaret Thatcher</font>
<font color="black">1279.             * Colendeeza Rice</font>
<font color="black">1280.         * Unknown:</font>
<font color="black">1281.             * Pat Smith</font>
<font color="black">1282. </font>
<font color="black">1283.     The following snippet of template code would accomplish this dubious task::</font>
<font color="black">1284. </font>
<font color="black">1285.         {% regroup people by gender as grouped %}</font>
<font color="black">1286.         &lt;ul&gt;</font>
<font color="black">1287.         {% for group in grouped %}</font>
<font color="black">1288.             &lt;li&gt;{{ group.grouper }}</font>
<font color="black">1289.             &lt;ul&gt;</font>
<font color="black">1290.                 {% for item in group.list %}</font>
<font color="black">1291.                 &lt;li&gt;{{ item }}&lt;/li&gt;</font>
<font color="black">1292.                 {% endfor %}</font>
<font color="black">1293.             &lt;/ul&gt;</font>
<font color="black">1294.         {% endfor %}</font>
<font color="black">1295.         &lt;/ul&gt;</font>
<font color="black">1296. </font>
<font color="black">1297.     As you can see, ``{% regroup %}`` populates a variable with a list of</font>
<font color="black">1298.     objects with ``grouper`` and ``list`` attributes.  ``grouper`` contains the</font>
<font color="black">1299.     item that was grouped by; ``list`` contains the list of objects that share</font>
<font color="black">1300.     that ``grouper``.  In this case, ``grouper`` would be ``Male``, ``Female``</font>
<font color="black">1301.     and ``Unknown``, and ``list`` is the list of people with those genders.</font>
<font color="black">1302. </font>
<font color="black">1303.     Note that ``{% regroup %}`` does not work when the list to be grouped is not</font>
<font color="black">1304.     sorted by the key you are grouping by!  This means that if your list of</font>
<font color="black">1305.     people was not sorted by gender, you'd need to make sure it is sorted</font>
<font color="black">1306.     before using it, i.e.::</font>
<font color="black">1307. </font>
<font color="black">1308.         {% regroup people|dictsort:&quot;gender&quot; by gender as grouped %}</font>
<font color="black">1309.     &quot;&quot;&quot;</font>
<font color="red">1310.     bits = token.split_contents()</font>
<font color="red">1311.     if len(bits) != 6:</font>
<font color="red">1312.         raise TemplateSyntaxError(&quot;'regroup' tag takes five arguments&quot;)</font>
<font color="red">1313.     target = parser.compile_filter(bits[1])</font>
<font color="red">1314.     if bits[2] != 'by':</font>
<font color="red">1315.         raise TemplateSyntaxError(&quot;second argument to 'regroup' tag must be 'by'&quot;)</font>
<font color="red">1316.     if bits[4] != 'as':</font>
<font color="red">1317.         raise TemplateSyntaxError(&quot;next-to-last argument to 'regroup' tag must&quot;</font>
<font color="black">1318.                                   &quot; be 'as'&quot;)</font>
<font color="red">1319.     var_name = bits[5]</font>
<font color="black">1320.     # RegroupNode will take each item in 'target', put it in the context under</font>
<font color="black">1321.     # 'var_name', evaluate 'var_name'.'expression' in the current context, and</font>
<font color="black">1322.     # group by the resulting value. After all items are processed, it will</font>
<font color="black">1323.     # save the final result in the context under 'var_name', thus clearing the</font>
<font color="black">1324.     # temporary values. This hack is necessary because the template engine</font>
<font color="black">1325.     # doesn't provide a context-aware equivalent of Python's getattr.</font>
<font color="red">1326.     expression = parser.compile_filter(var_name +</font>
<font color="red">1327.                                        VARIABLE_ATTRIBUTE_SEPARATOR +</font>
<font color="red">1328.                                        bits[3])</font>
<font color="red">1329.     return RegroupNode(target, expression, var_name)</font>
<font color="black">1330. </font>
<font color="black">1331. </font>
<font color="green">1332. @register.tag</font>
<font color="black">1333. def spaceless(parser, token):</font>
<font color="black">1334.     &quot;&quot;&quot;</font>
<font color="black">1335.     Removes whitespace between HTML tags, including tab and newline characters.</font>
<font color="black">1336. </font>
<font color="black">1337.     Example usage::</font>
<font color="black">1338. </font>
<font color="black">1339.         {% spaceless %}</font>
<font color="black">1340.             &lt;p&gt;</font>
<font color="black">1341.                 &lt;a href=&quot;foo/&quot;&gt;Foo&lt;/a&gt;</font>
<font color="black">1342.             &lt;/p&gt;</font>
<font color="black">1343.         {% endspaceless %}</font>
<font color="black">1344. </font>
<font color="black">1345.     This example would return this HTML::</font>
<font color="black">1346. </font>
<font color="black">1347.         &lt;p&gt;&lt;a href=&quot;foo/&quot;&gt;Foo&lt;/a&gt;&lt;/p&gt;</font>
<font color="black">1348. </font>
<font color="black">1349.     Only space between *tags* is normalized -- not space between tags and text.</font>
<font color="black">1350.     In this example, the space around ``Hello`` won't be stripped::</font>
<font color="black">1351. </font>
<font color="black">1352.         {% spaceless %}</font>
<font color="black">1353.             &lt;strong&gt;</font>
<font color="black">1354.                 Hello</font>
<font color="black">1355.             &lt;/strong&gt;</font>
<font color="black">1356.         {% endspaceless %}</font>
<font color="black">1357.     &quot;&quot;&quot;</font>
<font color="red">1358.     nodelist = parser.parse(('endspaceless',))</font>
<font color="red">1359.     parser.delete_first_token()</font>
<font color="red">1360.     return SpacelessNode(nodelist)</font>
<font color="black">1361. </font>
<font color="black">1362. </font>
<font color="green">1363. @register.tag</font>
<font color="black">1364. def templatetag(parser, token):</font>
<font color="black">1365.     &quot;&quot;&quot;</font>
<font color="black">1366.     Outputs one of the bits used to compose template tags.</font>
<font color="black">1367. </font>
<font color="black">1368.     Since the template system has no concept of &quot;escaping&quot;, to display one of</font>
<font color="black">1369.     the bits used in template tags, you must use the ``{% templatetag %}`` tag.</font>
<font color="black">1370. </font>
<font color="black">1371.     The argument tells which template bit to output:</font>
<font color="black">1372. </font>
<font color="black">1373.         ==================  =======</font>
<font color="black">1374.         Argument            Outputs</font>
<font color="black">1375.         ==================  =======</font>
<font color="black">1376.         ``openblock``       ``{%``</font>
<font color="black">1377.         ``closeblock``      ``%}``</font>
<font color="black">1378.         ``openvariable``    ``{{``</font>
<font color="black">1379.         ``closevariable``   ``}}``</font>
<font color="black">1380.         ``openbrace``       ``{``</font>
<font color="black">1381.         ``closebrace``      ``}``</font>
<font color="black">1382.         ``opencomment``     ``{#``</font>
<font color="black">1383.         ``closecomment``    ``#}``</font>
<font color="black">1384.         ==================  =======</font>
<font color="black">1385.     &quot;&quot;&quot;</font>
<font color="black">1386.     # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</font>
<font color="red">1387.     bits = token.contents.split()</font>
<font color="red">1388.     if len(bits) != 2:</font>
<font color="red">1389.         raise TemplateSyntaxError(&quot;'templatetag' statement takes one argument&quot;)</font>
<font color="red">1390.     tag = bits[1]</font>
<font color="red">1391.     if tag not in TemplateTagNode.mapping:</font>
<font color="red">1392.         raise TemplateSyntaxError(&quot;Invalid templatetag argument: '%s'.&quot;</font>
<font color="black">1393.                                   &quot; Must be one of: %s&quot; %</font>
<font color="red">1394.                                   (tag, list(TemplateTagNode.mapping)))</font>
<font color="red">1395.     return TemplateTagNode(tag)</font>
<font color="black">1396. </font>
<font color="black">1397. </font>
<font color="green">1398. @register.tag</font>
<font color="black">1399. def url(parser, token):</font>
<font color="black">1400.     &quot;&quot;&quot;</font>
<font color="black">1401.     Returns an absolute URL matching given view with its parameters.</font>
<font color="black">1402. </font>
<font color="black">1403.     This is a way to define links that aren't tied to a particular URL</font>
<font color="black">1404.     configuration::</font>
<font color="black">1405. </font>
<font color="black">1406.         {% url &quot;path.to.some_view&quot; arg1 arg2 %}</font>
<font color="black">1407. </font>
<font color="black">1408.         or</font>
<font color="black">1409. </font>
<font color="black">1410.         {% url &quot;path.to.some_view&quot; name1=value1 name2=value2 %}</font>
<font color="black">1411. </font>
<font color="black">1412.     The first argument is a path to a view. It can be an absolute Python path</font>
<font color="black">1413.     or just ``app_name.view_name`` without the project name if the view is</font>
<font color="black">1414.     located inside the project.</font>
<font color="black">1415. </font>
<font color="black">1416.     Other arguments are space-separated values that will be filled in place of</font>
<font color="black">1417.     positional and keyword arguments in the URL. Don't mix positional and</font>
<font color="black">1418.     keyword arguments.</font>
<font color="black">1419. </font>
<font color="black">1420.     All arguments for the URL should be present.</font>
<font color="black">1421. </font>
<font color="black">1422.     For example if you have a view ``app_name.client`` taking client's id and</font>
<font color="black">1423.     the corresponding line in a URLconf looks like this::</font>
<font color="black">1424. </font>
<font color="black">1425.         ('^client/(\d+)/$', 'app_name.client')</font>
<font color="black">1426. </font>
<font color="black">1427.     and this app's URLconf is included into the project's URLconf under some</font>
<font color="black">1428.     path::</font>
<font color="black">1429. </font>
<font color="black">1430.         ('^clients/', include('project_name.app_name.urls'))</font>
<font color="black">1431. </font>
<font color="black">1432.     then in a template you can create a link for a certain client like this::</font>
<font color="black">1433. </font>
<font color="black">1434.         {% url &quot;app_name.client&quot; client.id %}</font>
<font color="black">1435. </font>
<font color="black">1436.     The URL will look like ``/clients/client/123/``.</font>
<font color="black">1437. </font>
<font color="black">1438.     The first argument can also be a named URL instead of the Python path to</font>
<font color="black">1439.     the view callable. For example if the URLconf entry looks like this::</font>
<font color="black">1440. </font>
<font color="black">1441.         url('^client/(\d+)/$', name='client-detail-view')</font>
<font color="black">1442. </font>
<font color="black">1443.     then in the template you can use::</font>
<font color="black">1444. </font>
<font color="black">1445.         {% url &quot;client-detail-view&quot; client.id %}</font>
<font color="black">1446. </font>
<font color="black">1447.     There is even another possible value type for the first argument. It can be</font>
<font color="black">1448.     the name of a template variable that will be evaluated to obtain the view</font>
<font color="black">1449.     name or the URL name, e.g.::</font>
<font color="black">1450. </font>
<font color="black">1451.         {% with view_path=&quot;app_name.client&quot; %}</font>
<font color="black">1452.         {% url view_path client.id %}</font>
<font color="black">1453.         {% endwith %}</font>
<font color="black">1454. </font>
<font color="black">1455.         or,</font>
<font color="black">1456. </font>
<font color="black">1457.         {% with url_name=&quot;client-detail-view&quot; %}</font>
<font color="black">1458.         {% url url_name client.id %}</font>
<font color="black">1459.         {% endwith %}</font>
<font color="black">1460.     &quot;&quot;&quot;</font>
<font color="red">1461.     bits = token.split_contents()</font>
<font color="red">1462.     if len(bits) &lt; 2:</font>
<font color="red">1463.         raise TemplateSyntaxError(&quot;'%s' takes at least one argument&quot;</font>
<font color="red">1464.                                   &quot; (path to a view)&quot; % bits[0])</font>
<font color="red">1465.     viewname = parser.compile_filter(bits[1])</font>
<font color="red">1466.     args = []</font>
<font color="red">1467.     kwargs = {}</font>
<font color="red">1468.     asvar = None</font>
<font color="red">1469.     bits = bits[2:]</font>
<font color="red">1470.     if len(bits) &gt;= 2 and bits[-2] == 'as':</font>
<font color="red">1471.         asvar = bits[-1]</font>
<font color="red">1472.         bits = bits[:-2]</font>
<font color="black">1473. </font>
<font color="red">1474.     if len(bits):</font>
<font color="red">1475.         for bit in bits:</font>
<font color="red">1476.             match = kwarg_re.match(bit)</font>
<font color="red">1477.             if not match:</font>
<font color="red">1478.                 raise TemplateSyntaxError(&quot;Malformed arguments to url tag&quot;)</font>
<font color="red">1479.             name, value = match.groups()</font>
<font color="red">1480.             if name:</font>
<font color="red">1481.                 kwargs[name] = parser.compile_filter(value)</font>
<font color="black">1482.             else:</font>
<font color="red">1483.                 args.append(parser.compile_filter(value))</font>
<font color="black">1484. </font>
<font color="red">1485.     return URLNode(viewname, args, kwargs, asvar)</font>
<font color="black">1486. </font>
<font color="black">1487. </font>
<font color="green">1488. @register.tag</font>
<font color="black">1489. def verbatim(parser, token):</font>
<font color="black">1490.     &quot;&quot;&quot;</font>
<font color="black">1491.     Stops the template engine from rendering the contents of this block tag.</font>
<font color="black">1492. </font>
<font color="black">1493.     Usage::</font>
<font color="black">1494. </font>
<font color="black">1495.         {% verbatim %}</font>
<font color="black">1496.             {% don't process this %}</font>
<font color="black">1497.         {% endverbatim %}</font>
<font color="black">1498. </font>
<font color="black">1499.     You can also designate a specific closing tag block (allowing the</font>
<font color="black">1500.     unrendered use of ``{% endverbatim %}``)::</font>
<font color="black">1501. </font>
<font color="black">1502.         {% verbatim myblock %}</font>
<font color="black">1503.             ...</font>
<font color="black">1504.         {% endverbatim myblock %}</font>
<font color="black">1505.     &quot;&quot;&quot;</font>
<font color="red">1506.     nodelist = parser.parse(('endverbatim',))</font>
<font color="red">1507.     parser.delete_first_token()</font>
<font color="red">1508.     return VerbatimNode(nodelist.render(Context()))</font>
<font color="black">1509. </font>
<font color="black">1510. </font>
<font color="green">1511. @register.tag</font>
<font color="black">1512. def widthratio(parser, token):</font>
<font color="black">1513.     &quot;&quot;&quot;</font>
<font color="black">1514.     For creating bar charts and such, this tag calculates the ratio of a given</font>
<font color="black">1515.     value to a maximum value, and then applies that ratio to a constant.</font>
<font color="black">1516. </font>
<font color="black">1517.     For example::</font>
<font color="black">1518. </font>
<font color="black">1519.         &lt;img src=&quot;bar.png&quot; alt=&quot;Bar&quot;</font>
<font color="black">1520.              height=&quot;10&quot; width=&quot;{% widthratio this_value max_value max_width %}&quot; /&gt;</font>
<font color="black">1521. </font>
<font color="black">1522.     If ``this_value`` is 175, ``max_value`` is 200, and ``max_width`` is 100,</font>
<font color="black">1523.     the image in the above example will be 88 pixels wide</font>
<font color="black">1524.     (because 175/200 = .875; .875 * 100 = 87.5 which is rounded up to 88).</font>
<font color="black">1525. </font>
<font color="black">1526.     In some cases you might want to capture the result of widthratio in a</font>
<font color="black">1527.     variable. It can be useful for instance in a blocktrans like this::</font>
<font color="black">1528. </font>
<font color="black">1529.         {% widthratio this_value max_value max_width as width %}</font>
<font color="black">1530.         {% blocktrans %}The width is: {{ width }}{% endblocktrans %}</font>
<font color="black">1531.     &quot;&quot;&quot;</font>
<font color="red">1532.     bits = token.split_contents()</font>
<font color="red">1533.     if len(bits) == 4:</font>
<font color="red">1534.         tag, this_value_expr, max_value_expr, max_width = bits</font>
<font color="red">1535.         asvar = None</font>
<font color="red">1536.     elif len(bits) == 6:</font>
<font color="red">1537.         tag, this_value_expr, max_value_expr, max_width, as_, asvar = bits</font>
<font color="red">1538.         if as_ != 'as':</font>
<font color="red">1539.             raise TemplateSyntaxError(&quot;Invalid syntax in widthratio tag. Expecting 'as' keyword&quot;)</font>
<font color="black">1540.     else:</font>
<font color="red">1541.         raise TemplateSyntaxError(&quot;widthratio takes at least three arguments&quot;)</font>
<font color="black">1542. </font>
<font color="red">1543.     return WidthRatioNode(parser.compile_filter(this_value_expr),</font>
<font color="red">1544.                           parser.compile_filter(max_value_expr),</font>
<font color="red">1545.                           parser.compile_filter(max_width),</font>
<font color="red">1546.                           asvar=asvar)</font>
<font color="black">1547. </font>
<font color="black">1548. </font>
<font color="green">1549. @register.tag('with')</font>
<font color="black">1550. def do_with(parser, token):</font>
<font color="black">1551.     &quot;&quot;&quot;</font>
<font color="black">1552.     Adds one or more values to the context (inside of this block) for caching</font>
<font color="black">1553.     and easy access.</font>
<font color="black">1554. </font>
<font color="black">1555.     For example::</font>
<font color="black">1556. </font>
<font color="black">1557.         {% with total=person.some_sql_method %}</font>
<font color="black">1558.             {{ total }} object{{ total|pluralize }}</font>
<font color="black">1559.         {% endwith %}</font>
<font color="black">1560. </font>
<font color="black">1561.     Multiple values can be added to the context::</font>
<font color="black">1562. </font>
<font color="black">1563.         {% with foo=1 bar=2 %}</font>
<font color="black">1564.             ...</font>
<font color="black">1565.         {% endwith %}</font>
<font color="black">1566. </font>
<font color="black">1567.     The legacy format of ``{% with person.some_sql_method as total %}`` is</font>
<font color="black">1568.     still accepted.</font>
<font color="black">1569.     &quot;&quot;&quot;</font>
<font color="red">1570.     bits = token.split_contents()</font>
<font color="red">1571.     remaining_bits = bits[1:]</font>
<font color="red">1572.     extra_context = token_kwargs(remaining_bits, parser, support_legacy=True)</font>
<font color="red">1573.     if not extra_context:</font>
<font color="red">1574.         raise TemplateSyntaxError(&quot;%r expected at least one variable &quot;</font>
<font color="red">1575.                                   &quot;assignment&quot; % bits[0])</font>
<font color="red">1576.     if remaining_bits:</font>
<font color="red">1577.         raise TemplateSyntaxError(&quot;%r received an invalid token: %r&quot; %</font>
<font color="red">1578.                                   (bits[0], remaining_bits[0]))</font>
<font color="red">1579.     nodelist = parser.parse(('endwith',))</font>
<font color="red">1580.     parser.delete_first_token()</font>
<font color="red">1581.     return WithNode(None, None, nodelist, extra_context=extra_context)</font>
</pre>

