source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/regex_helper.py</b><br>


file stats: <b>202 lines, 27 executed: 13.4% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Functions for reversing a regular expression (used in reverse URL resolving).</font>
<font color="black">   3. Used internally by Django and not intended for external use.</font>
<font color="black">   4. </font>
<font color="black">   5. This is not, and is not intended to be, a complete reg-exp decompiler. It</font>
<font color="black">   6. should be good enough for a large class of URLS, however.</font>
<font color="green">   7. &quot;&quot;&quot;</font>
<font color="green">   8. from __future__ import unicode_literals</font>
<font color="black">   9. </font>
<font color="green">  10. from django.utils import six</font>
<font color="green">  11. from django.utils.six.moves import zip</font>
<font color="black">  12. </font>
<font color="black">  13. # Mapping of an escape character to a representative of that class. So, e.g.,</font>
<font color="black">  14. # &quot;\w&quot; is replaced by &quot;x&quot; in a reverse URL. A value of None means to ignore</font>
<font color="black">  15. # this sequence. Any missing key is mapped to itself.</font>
<font color="green">  16. ESCAPE_MAPPINGS = {</font>
<font color="green">  17.     &quot;A&quot;: None,</font>
<font color="green">  18.     &quot;b&quot;: None,</font>
<font color="green">  19.     &quot;B&quot;: None,</font>
<font color="green">  20.     &quot;d&quot;: &quot;0&quot;,</font>
<font color="green">  21.     &quot;D&quot;: &quot;x&quot;,</font>
<font color="green">  22.     &quot;s&quot;: &quot; &quot;,</font>
<font color="green">  23.     &quot;S&quot;: &quot;x&quot;,</font>
<font color="green">  24.     &quot;w&quot;: &quot;x&quot;,</font>
<font color="green">  25.     &quot;W&quot;: &quot;!&quot;,</font>
<font color="green">  26.     &quot;Z&quot;: None,</font>
<font color="black">  27. }</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. class Choice(list):</font>
<font color="black">  31.     &quot;&quot;&quot;</font>
<font color="black">  32.     Used to represent multiple possibilities at this point in a pattern string.</font>
<font color="black">  33.     We use a distinguished type, rather than a list, so that the usage in the</font>
<font color="black">  34.     code is clear.</font>
<font color="green">  35.     &quot;&quot;&quot;</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. class Group(list):</font>
<font color="black">  39.     &quot;&quot;&quot;</font>
<font color="black">  40.     Used to represent a capturing group in the pattern string.</font>
<font color="green">  41.     &quot;&quot;&quot;</font>
<font color="black">  42. </font>
<font color="black">  43. </font>
<font color="green">  44. class NonCapture(list):</font>
<font color="black">  45.     &quot;&quot;&quot;</font>
<font color="black">  46.     Used to represent a non-capturing group in the pattern string.</font>
<font color="green">  47.     &quot;&quot;&quot;</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="green">  50. def normalize(pattern):</font>
<font color="black">  51.     &quot;&quot;&quot;</font>
<font color="black">  52.     Given a reg-exp pattern, normalizes it to an iterable of forms that</font>
<font color="black">  53.     suffice for reverse matching. This does the following:</font>
<font color="black">  54. </font>
<font color="black">  55.     (1) For any repeating sections, keeps the minimum number of occurrences</font>
<font color="black">  56.         permitted (this means zero for optional groups).</font>
<font color="black">  57.     (2) If an optional group includes parameters, include one occurrence of</font>
<font color="black">  58.         that group (along with the zero occurrence case from step (1)).</font>
<font color="black">  59.     (3) Select the first (essentially an arbitrary) element from any character</font>
<font color="black">  60.         class. Select an arbitrary character for any unordered class (e.g. '.'</font>
<font color="black">  61.         or '\w') in the pattern.</font>
<font color="black">  62.     (4) Ignore comments, look-ahead and look-behind assertions, and any of the</font>
<font color="black">  63.         reg-exp flags that won't change what we construct (&quot;iLmsu&quot;). &quot;(?x)&quot; is</font>
<font color="black">  64.         an error, however.</font>
<font color="black">  65.     (5) Raise an error on any disjunctive ('|') constructs.</font>
<font color="black">  66. </font>
<font color="black">  67.     Django's URLs for forward resolving are either all positional arguments or</font>
<font color="black">  68.     all keyword arguments. That is assumed here, as well. Although reverse</font>
<font color="black">  69.     resolving can be done using positional args when keyword args are</font>
<font color="black">  70.     specified, the two cannot be mixed in the same reverse() call.</font>
<font color="black">  71.     &quot;&quot;&quot;</font>
<font color="black">  72.     # Do a linear scan to work out the special features of this pattern. The</font>
<font color="black">  73.     # idea is that we scan once here and collect all the information we need to</font>
<font color="black">  74.     # make future decisions.</font>
<font color="red">  75.     result = []</font>
<font color="red">  76.     non_capturing_groups = []</font>
<font color="red">  77.     consume_next = True</font>
<font color="red">  78.     pattern_iter = next_char(iter(pattern))</font>
<font color="red">  79.     num_args = 0</font>
<font color="black">  80. </font>
<font color="black">  81.     # A &quot;while&quot; loop is used here because later on we need to be able to peek</font>
<font color="black">  82.     # at the next character and possibly go around without consuming another</font>
<font color="black">  83.     # one at the top of the loop.</font>
<font color="red">  84.     try:</font>
<font color="red">  85.         ch, escaped = next(pattern_iter)</font>
<font color="red">  86.     except StopIteration:</font>
<font color="red">  87.         return [('', [])]</font>
<font color="black">  88. </font>
<font color="red">  89.     try:</font>
<font color="red">  90.         while True:</font>
<font color="red">  91.             if escaped:</font>
<font color="red">  92.                 result.append(ch)</font>
<font color="red">  93.             elif ch == '.':</font>
<font color="black">  94.                 # Replace &quot;any character&quot; with an arbitrary representative.</font>
<font color="red">  95.                 result.append(&quot;.&quot;)</font>
<font color="red">  96.             elif ch == '|':</font>
<font color="black">  97.                 # FIXME: One day we'll should do this, but not in 1.0.</font>
<font color="red">  98.                 raise NotImplementedError('Awaiting Implementation')</font>
<font color="red">  99.             elif ch == &quot;^&quot;:</font>
<font color="red"> 100.                 pass</font>
<font color="red"> 101.             elif ch == '$':</font>
<font color="red"> 102.                 break</font>
<font color="red"> 103.             elif ch == ')':</font>
<font color="black"> 104.                 # This can only be the end of a non-capturing group, since all</font>
<font color="black"> 105.                 # other unescaped parentheses are handled by the grouping</font>
<font color="black"> 106.                 # section later (and the full group is handled there).</font>
<font color="black"> 107.                 #</font>
<font color="black"> 108.                 # We regroup everything inside the capturing group so that it</font>
<font color="black"> 109.                 # can be quantified, if necessary.</font>
<font color="red"> 110.                 start = non_capturing_groups.pop()</font>
<font color="red"> 111.                 inner = NonCapture(result[start:])</font>
<font color="red"> 112.                 result = result[:start] + [inner]</font>
<font color="red"> 113.             elif ch == '[':</font>
<font color="black"> 114.                 # Replace ranges with the first character in the range.</font>
<font color="red"> 115.                 ch, escaped = next(pattern_iter)</font>
<font color="red"> 116.                 result.append(ch)</font>
<font color="red"> 117.                 ch, escaped = next(pattern_iter)</font>
<font color="red"> 118.                 while escaped or ch != ']':</font>
<font color="red"> 119.                     ch, escaped = next(pattern_iter)</font>
<font color="red"> 120.             elif ch == '(':</font>
<font color="black"> 121.                 # Some kind of group.</font>
<font color="red"> 122.                 ch, escaped = next(pattern_iter)</font>
<font color="red"> 123.                 if ch != '?' or escaped:</font>
<font color="black"> 124.                     # A positional group</font>
<font color="red"> 125.                     name = &quot;_%d&quot; % num_args</font>
<font color="red"> 126.                     num_args += 1</font>
<font color="red"> 127.                     result.append(Group(((&quot;%%(%s)s&quot; % name), name)))</font>
<font color="red"> 128.                     walk_to_end(ch, pattern_iter)</font>
<font color="black"> 129.                 else:</font>
<font color="red"> 130.                     ch, escaped = next(pattern_iter)</font>
<font color="red"> 131.                     if ch in &quot;iLmsu#!=&lt;&quot;:</font>
<font color="black"> 132.                         # All of these are ignorable. Walk to the end of the</font>
<font color="black"> 133.                         # group.</font>
<font color="red"> 134.                         walk_to_end(ch, pattern_iter)</font>
<font color="red"> 135.                     elif ch == ':':</font>
<font color="black"> 136.                         # Non-capturing group</font>
<font color="red"> 137.                         non_capturing_groups.append(len(result))</font>
<font color="red"> 138.                     elif ch != 'P':</font>
<font color="black"> 139.                         # Anything else, other than a named group, is something</font>
<font color="black"> 140.                         # we cannot reverse.</font>
<font color="red"> 141.                         raise ValueError(&quot;Non-reversible reg-exp portion: '(?%s'&quot; % ch)</font>
<font color="black"> 142.                     else:</font>
<font color="red"> 143.                         ch, escaped = next(pattern_iter)</font>
<font color="red"> 144.                         if ch not in ('&lt;', '='):</font>
<font color="red"> 145.                             raise ValueError(&quot;Non-reversible reg-exp portion: '(?P%s'&quot; % ch)</font>
<font color="black"> 146.                         # We are in a named capturing group. Extra the name and</font>
<font color="black"> 147.                         # then skip to the end.</font>
<font color="red"> 148.                         if ch == '&lt;':</font>
<font color="red"> 149.                             terminal_char = '&gt;'</font>
<font color="black"> 150.                         # We are in a named backreference.</font>
<font color="black"> 151.                         else:</font>
<font color="red"> 152.                             terminal_char = ')'</font>
<font color="red"> 153.                         name = []</font>
<font color="red"> 154.                         ch, escaped = next(pattern_iter)</font>
<font color="red"> 155.                         while ch != terminal_char:</font>
<font color="red"> 156.                             name.append(ch)</font>
<font color="red"> 157.                             ch, escaped = next(pattern_iter)</font>
<font color="red"> 158.                         param = ''.join(name)</font>
<font color="black"> 159.                         # Named backreferences have already consumed the</font>
<font color="black"> 160.                         # parenthesis.</font>
<font color="red"> 161.                         if terminal_char != ')':</font>
<font color="red"> 162.                             result.append(Group(((&quot;%%(%s)s&quot; % param), param)))</font>
<font color="red"> 163.                             walk_to_end(ch, pattern_iter)</font>
<font color="black"> 164.                         else:</font>
<font color="red"> 165.                             result.append(Group(((&quot;%%(%s)s&quot; % param), None)))</font>
<font color="red"> 166.             elif ch in &quot;*?+{&quot;:</font>
<font color="black"> 167.                 # Quantifiers affect the previous item in the result list.</font>
<font color="red"> 168.                 count, ch = get_quantifier(ch, pattern_iter)</font>
<font color="red"> 169.                 if ch:</font>
<font color="black"> 170.                     # We had to look ahead, but it wasn't need to compute the</font>
<font color="black"> 171.                     # quantifier, so use this character next time around the</font>
<font color="black"> 172.                     # main loop.</font>
<font color="red"> 173.                     consume_next = False</font>
<font color="black"> 174. </font>
<font color="red"> 175.                 if count == 0:</font>
<font color="red"> 176.                     if contains(result[-1], Group):</font>
<font color="black"> 177.                         # If we are quantifying a capturing group (or</font>
<font color="black"> 178.                         # something containing such a group) and the minimum is</font>
<font color="black"> 179.                         # zero, we must also handle the case of one occurrence</font>
<font color="black"> 180.                         # being present. All the quantifiers (except {0,0},</font>
<font color="black"> 181.                         # which we conveniently ignore) that have a 0 minimum</font>
<font color="black"> 182.                         # also allow a single occurrence.</font>
<font color="red"> 183.                         result[-1] = Choice([None, result[-1]])</font>
<font color="black"> 184.                     else:</font>
<font color="red"> 185.                         result.pop()</font>
<font color="red"> 186.                 elif count &gt; 1:</font>
<font color="red"> 187.                     result.extend([result[-1]] * (count - 1))</font>
<font color="black"> 188.             else:</font>
<font color="black"> 189.                 # Anything else is a literal.</font>
<font color="red"> 190.                 result.append(ch)</font>
<font color="black"> 191. </font>
<font color="red"> 192.             if consume_next:</font>
<font color="red"> 193.                 ch, escaped = next(pattern_iter)</font>
<font color="black"> 194.             else:</font>
<font color="red"> 195.                 consume_next = True</font>
<font color="red"> 196.     except StopIteration:</font>
<font color="red"> 197.         pass</font>
<font color="red"> 198.     except NotImplementedError:</font>
<font color="black"> 199.         # A case of using the disjunctive form. No results for you!</font>
<font color="red"> 200.         return [('', [])]</font>
<font color="black"> 201. </font>
<font color="red"> 202.     return list(zip(*flatten_result(result)))</font>
<font color="black"> 203. </font>
<font color="black"> 204. </font>
<font color="green"> 205. def next_char(input_iter):</font>
<font color="black"> 206.     &quot;&quot;&quot;</font>
<font color="black"> 207.     An iterator that yields the next character from &quot;pattern_iter&quot;, respecting</font>
<font color="black"> 208.     escape sequences. An escaped character is replaced by a representative of</font>
<font color="black"> 209.     its class (e.g. \w -&gt; &quot;x&quot;). If the escaped character is one that is</font>
<font color="black"> 210.     skipped, it is not returned (the next character is returned instead).</font>
<font color="black"> 211. </font>
<font color="black"> 212.     Yields the next character, along with a boolean indicating whether it is a</font>
<font color="black"> 213.     raw (unescaped) character or not.</font>
<font color="black"> 214.     &quot;&quot;&quot;</font>
<font color="red"> 215.     for ch in input_iter:</font>
<font color="red"> 216.         if ch != '\\':</font>
<font color="red"> 217.             yield ch, False</font>
<font color="red"> 218.             continue</font>
<font color="red"> 219.         ch = next(input_iter)</font>
<font color="red"> 220.         representative = ESCAPE_MAPPINGS.get(ch, ch)</font>
<font color="red"> 221.         if representative is None:</font>
<font color="red"> 222.             continue</font>
<font color="red"> 223.         yield representative, True</font>
<font color="black"> 224. </font>
<font color="black"> 225. </font>
<font color="green"> 226. def walk_to_end(ch, input_iter):</font>
<font color="black"> 227.     &quot;&quot;&quot;</font>
<font color="black"> 228.     The iterator is currently inside a capturing group. We want to walk to the</font>
<font color="black"> 229.     close of this group, skipping over any nested groups and handling escaped</font>
<font color="black"> 230.     parentheses correctly.</font>
<font color="black"> 231.     &quot;&quot;&quot;</font>
<font color="red"> 232.     if ch == '(':</font>
<font color="red"> 233.         nesting = 1</font>
<font color="black"> 234.     else:</font>
<font color="red"> 235.         nesting = 0</font>
<font color="red"> 236.     for ch, escaped in input_iter:</font>
<font color="red"> 237.         if escaped:</font>
<font color="red"> 238.             continue</font>
<font color="red"> 239.         elif ch == '(':</font>
<font color="red"> 240.             nesting += 1</font>
<font color="red"> 241.         elif ch == ')':</font>
<font color="red"> 242.             if not nesting:</font>
<font color="red"> 243.                 return</font>
<font color="red"> 244.             nesting -= 1</font>
<font color="black"> 245. </font>
<font color="black"> 246. </font>
<font color="green"> 247. def get_quantifier(ch, input_iter):</font>
<font color="black"> 248.     &quot;&quot;&quot;</font>
<font color="black"> 249.     Parse a quantifier from the input, where &quot;ch&quot; is the first character in the</font>
<font color="black"> 250.     quantifier.</font>
<font color="black"> 251. </font>
<font color="black"> 252.     Returns the minimum number of occurrences permitted by the quantifier and</font>
<font color="black"> 253.     either None or the next character from the input_iter if the next character</font>
<font color="black"> 254.     is not part of the quantifier.</font>
<font color="black"> 255.     &quot;&quot;&quot;</font>
<font color="red"> 256.     if ch in '*?+':</font>
<font color="red"> 257.         try:</font>
<font color="red"> 258.             ch2, escaped = next(input_iter)</font>
<font color="red"> 259.         except StopIteration:</font>
<font color="red"> 260.             ch2 = None</font>
<font color="red"> 261.         if ch2 == '?':</font>
<font color="red"> 262.             ch2 = None</font>
<font color="red"> 263.         if ch == '+':</font>
<font color="red"> 264.             return 1, ch2</font>
<font color="red"> 265.         return 0, ch2</font>
<font color="black"> 266. </font>
<font color="red"> 267.     quant = []</font>
<font color="red"> 268.     while ch != '}':</font>
<font color="red"> 269.         ch, escaped = next(input_iter)</font>
<font color="red"> 270.         quant.append(ch)</font>
<font color="red"> 271.     quant = quant[:-1]</font>
<font color="red"> 272.     values = ''.join(quant).split(',')</font>
<font color="black"> 273. </font>
<font color="black"> 274.     # Consume the trailing '?', if necessary.</font>
<font color="red"> 275.     try:</font>
<font color="red"> 276.         ch, escaped = next(input_iter)</font>
<font color="red"> 277.     except StopIteration:</font>
<font color="red"> 278.         ch = None</font>
<font color="red"> 279.     if ch == '?':</font>
<font color="red"> 280.         ch = None</font>
<font color="red"> 281.     return int(values[0]), ch</font>
<font color="black"> 282. </font>
<font color="black"> 283. </font>
<font color="green"> 284. def contains(source, inst):</font>
<font color="black"> 285.     &quot;&quot;&quot;</font>
<font color="black"> 286.     Returns True if the &quot;source&quot; contains an instance of &quot;inst&quot;. False,</font>
<font color="black"> 287.     otherwise.</font>
<font color="black"> 288.     &quot;&quot;&quot;</font>
<font color="red"> 289.     if isinstance(source, inst):</font>
<font color="red"> 290.         return True</font>
<font color="red"> 291.     if isinstance(source, NonCapture):</font>
<font color="red"> 292.         for elt in source:</font>
<font color="red"> 293.             if contains(elt, inst):</font>
<font color="red"> 294.                 return True</font>
<font color="red"> 295.     return False</font>
<font color="black"> 296. </font>
<font color="black"> 297. </font>
<font color="green"> 298. def flatten_result(source):</font>
<font color="black"> 299.     &quot;&quot;&quot;</font>
<font color="black"> 300.     Turns the given source sequence into a list of reg-exp possibilities and</font>
<font color="black"> 301.     their arguments. Returns a list of strings and a list of argument lists.</font>
<font color="black"> 302.     Each of the two lists will be of the same length.</font>
<font color="black"> 303.     &quot;&quot;&quot;</font>
<font color="red"> 304.     if source is None:</font>
<font color="red"> 305.         return [''], [[]]</font>
<font color="red"> 306.     if isinstance(source, Group):</font>
<font color="red"> 307.         if source[1] is None:</font>
<font color="red"> 308.             params = []</font>
<font color="black"> 309.         else:</font>
<font color="red"> 310.             params = [source[1]]</font>
<font color="red"> 311.         return [source[0]], [params]</font>
<font color="red"> 312.     result = ['']</font>
<font color="red"> 313.     result_args = [[]]</font>
<font color="red"> 314.     pos = last = 0</font>
<font color="red"> 315.     for pos, elt in enumerate(source):</font>
<font color="red"> 316.         if isinstance(elt, six.string_types):</font>
<font color="red"> 317.             continue</font>
<font color="red"> 318.         piece = ''.join(source[last:pos])</font>
<font color="red"> 319.         if isinstance(elt, Group):</font>
<font color="red"> 320.             piece += elt[0]</font>
<font color="red"> 321.             param = elt[1]</font>
<font color="black"> 322.         else:</font>
<font color="red"> 323.             param = None</font>
<font color="red"> 324.         last = pos + 1</font>
<font color="red"> 325.         for i in range(len(result)):</font>
<font color="red"> 326.             result[i] += piece</font>
<font color="red"> 327.             if param:</font>
<font color="red"> 328.                 result_args[i].append(param)</font>
<font color="red"> 329.         if isinstance(elt, (Choice, NonCapture)):</font>
<font color="red"> 330.             if isinstance(elt, NonCapture):</font>
<font color="red"> 331.                 elt = [elt]</font>
<font color="red"> 332.             inner_result, inner_args = [], []</font>
<font color="red"> 333.             for item in elt:</font>
<font color="red"> 334.                 res, args = flatten_result(item)</font>
<font color="red"> 335.                 inner_result.extend(res)</font>
<font color="red"> 336.                 inner_args.extend(args)</font>
<font color="red"> 337.             new_result = []</font>
<font color="red"> 338.             new_args = []</font>
<font color="red"> 339.             for item, args in zip(result, result_args):</font>
<font color="red"> 340.                 for i_item, i_args in zip(inner_result, inner_args):</font>
<font color="red"> 341.                     new_result.append(item + i_item)</font>
<font color="red"> 342.                     new_args.append(args[:] + i_args)</font>
<font color="red"> 343.             result = new_result</font>
<font color="red"> 344.             result_args = new_args</font>
<font color="red"> 345.     if pos &gt;= last:</font>
<font color="red"> 346.         piece = ''.join(source[last:])</font>
<font color="red"> 347.         for i in range(len(result)):</font>
<font color="red"> 348.             result[i] += piece</font>
<font color="red"> 349.     return result, result_args</font>
</pre>

