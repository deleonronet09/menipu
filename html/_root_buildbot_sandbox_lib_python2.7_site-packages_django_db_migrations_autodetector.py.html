source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/migrations/autodetector.py</b><br>


file stats: <b>739 lines, 51 executed: 6.9% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import datetime</font>
<font color="green">   4. import re</font>
<font color="green">   5. from itertools import chain</font>
<font color="black">   6. </font>
<font color="green">   7. from django.conf import settings</font>
<font color="green">   8. from django.db import models</font>
<font color="green">   9. from django.db.migrations import operations</font>
<font color="green">  10. from django.db.migrations.migration import Migration</font>
<font color="green">  11. from django.db.migrations.operations.models import AlterModelOptions</font>
<font color="green">  12. from django.db.migrations.optimizer import MigrationOptimizer</font>
<font color="green">  13. from django.db.migrations.questioner import MigrationQuestioner</font>
<font color="green">  14. from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject</font>
<font color="green">  15. from django.utils import six</font>
<font color="black">  16. </font>
<font color="green">  17. from .topological_sort import stable_topological_sort</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. class MigrationAutodetector(object):</font>
<font color="black">  21.     &quot;&quot;&quot;</font>
<font color="black">  22.     Takes a pair of ProjectStates, and compares them to see what the</font>
<font color="black">  23.     first would need doing to make it match the second (the second</font>
<font color="black">  24.     usually being the project's current state).</font>
<font color="black">  25. </font>
<font color="black">  26.     Note that this naturally operates on entire projects at a time,</font>
<font color="black">  27.     as it's likely that changes interact (for example, you can't</font>
<font color="black">  28.     add a ForeignKey without having a migration to add the table it</font>
<font color="black">  29.     depends on first). A user interface may offer single-app usage</font>
<font color="black">  30.     if it wishes, with the caveat that it may not always be possible.</font>
<font color="green">  31.     &quot;&quot;&quot;</font>
<font color="black">  32. </font>
<font color="green">  33.     def __init__(self, from_state, to_state, questioner=None):</font>
<font color="red">  34.         self.from_state = from_state</font>
<font color="red">  35.         self.to_state = to_state</font>
<font color="red">  36.         self.questioner = questioner or MigrationQuestioner()</font>
<font color="red">  37.         self.existing_apps = {app for app, model in from_state.models}</font>
<font color="black">  38. </font>
<font color="green">  39.     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):</font>
<font color="black">  40.         &quot;&quot;&quot;</font>
<font color="black">  41.         Main entry point to produce a list of appliable changes.</font>
<font color="black">  42.         Takes a graph to base names on and an optional set of apps</font>
<font color="black">  43.         to try and restrict to (restriction is not guaranteed)</font>
<font color="black">  44.         &quot;&quot;&quot;</font>
<font color="red">  45.         changes = self._detect_changes(convert_apps, graph)</font>
<font color="red">  46.         changes = self.arrange_for_graph(changes, graph, migration_name)</font>
<font color="red">  47.         if trim_to_apps:</font>
<font color="red">  48.             changes = self._trim_to_apps(changes, trim_to_apps)</font>
<font color="red">  49.         return changes</font>
<font color="black">  50. </font>
<font color="green">  51.     def deep_deconstruct(self, obj):</font>
<font color="black">  52.         &quot;&quot;&quot;</font>
<font color="black">  53.         Recursive deconstruction for a field and its arguments.</font>
<font color="black">  54.         Used for full comparison for rename/alter; sometimes a single-level</font>
<font color="black">  55.         deconstruction will not compare correctly.</font>
<font color="black">  56.         &quot;&quot;&quot;</font>
<font color="red">  57.         if isinstance(obj, list):</font>
<font color="red">  58.             return [self.deep_deconstruct(value) for value in obj]</font>
<font color="red">  59.         elif isinstance(obj, tuple):</font>
<font color="red">  60.             return tuple(self.deep_deconstruct(value) for value in obj)</font>
<font color="red">  61.         elif isinstance(obj, dict):</font>
<font color="black">  62.             return {</font>
<font color="red">  63.                 key: self.deep_deconstruct(value)</font>
<font color="red">  64.                 for key, value in obj.items()</font>
<font color="black">  65.             }</font>
<font color="red">  66.         elif isinstance(obj, COMPILED_REGEX_TYPE):</font>
<font color="red">  67.             return RegexObject(obj)</font>
<font color="red">  68.         elif isinstance(obj, type):</font>
<font color="black">  69.             # If this is a type that implements 'deconstruct' as an instance method,</font>
<font color="black">  70.             # avoid treating this as being deconstructible itself - see #22951</font>
<font color="red">  71.             return obj</font>
<font color="red">  72.         elif hasattr(obj, 'deconstruct'):</font>
<font color="red">  73.             deconstructed = obj.deconstruct()</font>
<font color="red">  74.             if isinstance(obj, models.Field):</font>
<font color="black">  75.                 # we have a field which also returns a name</font>
<font color="red">  76.                 deconstructed = deconstructed[1:]</font>
<font color="red">  77.             path, args, kwargs = deconstructed</font>
<font color="black">  78.             return (</font>
<font color="red">  79.                 path,</font>
<font color="red">  80.                 [self.deep_deconstruct(value) for value in args],</font>
<font color="black">  81.                 {</font>
<font color="red">  82.                     key: self.deep_deconstruct(value)</font>
<font color="red">  83.                     for key, value in kwargs.items()</font>
<font color="black">  84.                 },</font>
<font color="black">  85.             )</font>
<font color="black">  86.         else:</font>
<font color="red">  87.             return obj</font>
<font color="black">  88. </font>
<font color="green">  89.     def only_relation_agnostic_fields(self, fields):</font>
<font color="black">  90.         &quot;&quot;&quot;</font>
<font color="black">  91.         Return a definition of the fields that ignores field names and</font>
<font color="black">  92.         what related fields actually relate to.</font>
<font color="black">  93.         Used for detecting renames (as, of course, the related fields</font>
<font color="black">  94.         change during renames)</font>
<font color="black">  95.         &quot;&quot;&quot;</font>
<font color="red">  96.         fields_def = []</font>
<font color="red">  97.         for name, field in sorted(fields):</font>
<font color="red">  98.             deconstruction = self.deep_deconstruct(field)</font>
<font color="red">  99.             if field.remote_field and field.remote_field.model:</font>
<font color="red"> 100.                 del deconstruction[2]['to']</font>
<font color="red"> 101.             fields_def.append(deconstruction)</font>
<font color="red"> 102.         return fields_def</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def _detect_changes(self, convert_apps=None, graph=None):</font>
<font color="black"> 105.         &quot;&quot;&quot;</font>
<font color="black"> 106.         Returns a dict of migration plans which will achieve the</font>
<font color="black"> 107.         change from from_state to to_state. The dict has app labels</font>
<font color="black"> 108.         as keys and a list of migrations as values.</font>
<font color="black"> 109. </font>
<font color="black"> 110.         The resulting migrations aren't specially named, but the names</font>
<font color="black"> 111.         do matter for dependencies inside the set.</font>
<font color="black"> 112. </font>
<font color="black"> 113.         convert_apps is the list of apps to convert to use migrations</font>
<font color="black"> 114.         (i.e. to make initial migrations for, in the usual case)</font>
<font color="black"> 115. </font>
<font color="black"> 116.         graph is an optional argument that, if provided, can help improve</font>
<font color="black"> 117.         dependency generation and avoid potential circular dependencies.</font>
<font color="black"> 118.         &quot;&quot;&quot;</font>
<font color="black"> 119. </font>
<font color="black"> 120.         # The first phase is generating all the operations for each app</font>
<font color="black"> 121.         # and gathering them into a big per-app list.</font>
<font color="black"> 122.         # We'll then go through that list later and order it and split</font>
<font color="black"> 123.         # into migrations to resolve dependencies caused by M2Ms and FKs.</font>
<font color="red"> 124.         self.generated_operations = {}</font>
<font color="black"> 125. </font>
<font color="black"> 126.         # Prepare some old/new state and model lists, separating</font>
<font color="black"> 127.         # proxy models and ignoring unmigrated apps.</font>
<font color="red"> 128.         self.old_apps = self.from_state.concrete_apps</font>
<font color="red"> 129.         self.new_apps = self.to_state.apps</font>
<font color="red"> 130.         self.old_model_keys = []</font>
<font color="red"> 131.         self.old_proxy_keys = []</font>
<font color="red"> 132.         self.old_unmanaged_keys = []</font>
<font color="red"> 133.         self.new_model_keys = []</font>
<font color="red"> 134.         self.new_proxy_keys = []</font>
<font color="red"> 135.         self.new_unmanaged_keys = []</font>
<font color="red"> 136.         for al, mn in sorted(self.from_state.models.keys()):</font>
<font color="red"> 137.             model = self.old_apps.get_model(al, mn)</font>
<font color="red"> 138.             if not model._meta.managed:</font>
<font color="red"> 139.                 self.old_unmanaged_keys.append((al, mn))</font>
<font color="red"> 140.             elif al not in self.from_state.real_apps:</font>
<font color="red"> 141.                 if model._meta.proxy:</font>
<font color="red"> 142.                     self.old_proxy_keys.append((al, mn))</font>
<font color="black"> 143.                 else:</font>
<font color="red"> 144.                     self.old_model_keys.append((al, mn))</font>
<font color="black"> 145. </font>
<font color="red"> 146.         for al, mn in sorted(self.to_state.models.keys()):</font>
<font color="red"> 147.             model = self.new_apps.get_model(al, mn)</font>
<font color="red"> 148.             if not model._meta.managed:</font>
<font color="red"> 149.                 self.new_unmanaged_keys.append((al, mn))</font>
<font color="black"> 150.             elif (</font>
<font color="red"> 151.                 al not in self.from_state.real_apps or</font>
<font color="red"> 152.                 (convert_apps and al in convert_apps)</font>
<font color="black"> 153.             ):</font>
<font color="red"> 154.                 if model._meta.proxy:</font>
<font color="red"> 155.                     self.new_proxy_keys.append((al, mn))</font>
<font color="black"> 156.                 else:</font>
<font color="red"> 157.                     self.new_model_keys.append((al, mn))</font>
<font color="black"> 158. </font>
<font color="black"> 159.         # Renames have to come first</font>
<font color="red"> 160.         self.generate_renamed_models()</font>
<font color="black"> 161. </font>
<font color="black"> 162.         # Prepare lists of fields and generate through model map</font>
<font color="red"> 163.         self._prepare_field_lists()</font>
<font color="red"> 164.         self._generate_through_model_map()</font>
<font color="black"> 165. </font>
<font color="black"> 166.         # Generate non-rename model operations</font>
<font color="red"> 167.         self.generate_deleted_models()</font>
<font color="red"> 168.         self.generate_created_models()</font>
<font color="red"> 169.         self.generate_deleted_proxies()</font>
<font color="red"> 170.         self.generate_created_proxies()</font>
<font color="red"> 171.         self.generate_altered_options()</font>
<font color="red"> 172.         self.generate_altered_managers()</font>
<font color="black"> 173. </font>
<font color="black"> 174.         # Generate field operations</font>
<font color="red"> 175.         self.generate_renamed_fields()</font>
<font color="red"> 176.         self.generate_removed_fields()</font>
<font color="red"> 177.         self.generate_added_fields()</font>
<font color="red"> 178.         self.generate_altered_fields()</font>
<font color="red"> 179.         self.generate_altered_unique_together()</font>
<font color="red"> 180.         self.generate_altered_index_together()</font>
<font color="red"> 181.         self.generate_altered_db_table()</font>
<font color="red"> 182.         self.generate_altered_order_with_respect_to()</font>
<font color="black"> 183. </font>
<font color="red"> 184.         self._sort_migrations()</font>
<font color="red"> 185.         self._build_migration_list(graph)</font>
<font color="red"> 186.         self._optimize_migrations()</font>
<font color="black"> 187. </font>
<font color="red"> 188.         return self.migrations</font>
<font color="black"> 189. </font>
<font color="green"> 190.     def _prepare_field_lists(self):</font>
<font color="black"> 191.         &quot;&quot;&quot;</font>
<font color="black"> 192.         Prepare field lists, and prepare a list of the fields that used</font>
<font color="black"> 193.         through models in the old state so we can make dependencies</font>
<font color="black"> 194.         from the through model deletion to the field that uses it.</font>
<font color="black"> 195.         &quot;&quot;&quot;</font>
<font color="red"> 196.         self.kept_model_keys = set(self.old_model_keys).intersection(self.new_model_keys)</font>
<font color="red"> 197.         self.kept_proxy_keys = set(self.old_proxy_keys).intersection(self.new_proxy_keys)</font>
<font color="red"> 198.         self.kept_unmanaged_keys = set(self.old_unmanaged_keys).intersection(self.new_unmanaged_keys)</font>
<font color="red"> 199.         self.through_users = {}</font>
<font color="red"> 200.         self.old_field_keys = set()</font>
<font color="red"> 201.         self.new_field_keys = set()</font>
<font color="red"> 202.         for app_label, model_name in sorted(self.kept_model_keys):</font>
<font color="red"> 203.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red"> 204.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red"> 205.             new_model_state = self.to_state.models[app_label, model_name]</font>
<font color="red"> 206.             self.old_field_keys.update((app_label, model_name, x) for x, y in old_model_state.fields)</font>
<font color="red"> 207.             self.new_field_keys.update((app_label, model_name, x) for x, y in new_model_state.fields)</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def _generate_through_model_map(self):</font>
<font color="black"> 210.         &quot;&quot;&quot;</font>
<font color="black"> 211.         Through model map generation</font>
<font color="black"> 212.         &quot;&quot;&quot;</font>
<font color="red"> 213.         for app_label, model_name in sorted(self.old_model_keys):</font>
<font color="red"> 214.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red"> 215.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red"> 216.             for field_name, field in old_model_state.fields:</font>
<font color="red"> 217.                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)</font>
<font color="red"> 218.                 if (hasattr(old_field, &quot;remote_field&quot;) and getattr(old_field.remote_field, &quot;through&quot;, None)</font>
<font color="red"> 219.                         and not old_field.remote_field.through._meta.auto_created):</font>
<font color="black"> 220.                     through_key = (</font>
<font color="red"> 221.                         old_field.remote_field.through._meta.app_label,</font>
<font color="red"> 222.                         old_field.remote_field.through._meta.model_name,</font>
<font color="black"> 223.                     )</font>
<font color="red"> 224.                     self.through_users[through_key] = (app_label, old_model_name, field_name)</font>
<font color="black"> 225. </font>
<font color="green"> 226.     def _build_migration_list(self, graph=None):</font>
<font color="black"> 227.         &quot;&quot;&quot;</font>
<font color="black"> 228.         We need to chop the lists of operations up into migrations with</font>
<font color="black"> 229.         dependencies on each other. We do this by stepping up an app's list of</font>
<font color="black"> 230.         operations until we find one that has an outgoing dependency that isn't</font>
<font color="black"> 231.         in another app's migration yet (hasn't been chopped off its list). We</font>
<font color="black"> 232.         then chop off the operations before it into a migration and move onto</font>
<font color="black"> 233.         the next app. If we loop back around without doing anything, there's a</font>
<font color="black"> 234.         circular dependency (which _should_ be impossible as the operations are</font>
<font color="black"> 235.         all split at this point so they can't depend and be depended on).</font>
<font color="black"> 236.         &quot;&quot;&quot;</font>
<font color="red"> 237.         self.migrations = {}</font>
<font color="red"> 238.         num_ops = sum(len(x) for x in self.generated_operations.values())</font>
<font color="red"> 239.         chop_mode = False</font>
<font color="red"> 240.         while num_ops:</font>
<font color="black"> 241.             # On every iteration, we step through all the apps and see if there</font>
<font color="black"> 242.             # is a completed set of operations.</font>
<font color="black"> 243.             # If we find that a subset of the operations are complete we can</font>
<font color="black"> 244.             # try to chop it off from the rest and continue, but we only</font>
<font color="black"> 245.             # do this if we've already been through the list once before</font>
<font color="black"> 246.             # without any chopping and nothing has changed.</font>
<font color="red"> 247.             for app_label in sorted(self.generated_operations.keys()):</font>
<font color="red"> 248.                 chopped = []</font>
<font color="red"> 249.                 dependencies = set()</font>
<font color="red"> 250.                 for operation in list(self.generated_operations[app_label]):</font>
<font color="red"> 251.                     deps_satisfied = True</font>
<font color="red"> 252.                     operation_dependencies = set()</font>
<font color="red"> 253.                     for dep in operation._auto_deps:</font>
<font color="red"> 254.                         is_swappable_dep = False</font>
<font color="red"> 255.                         if dep[0] == &quot;__setting__&quot;:</font>
<font color="black"> 256.                             # We need to temporarily resolve the swappable dependency to prevent</font>
<font color="black"> 257.                             # circular references. While keeping the dependency checks on the</font>
<font color="black"> 258.                             # resolved model we still add the swappable dependencies.</font>
<font color="black"> 259.                             # See #23322</font>
<font color="red"> 260.                             resolved_app_label, resolved_object_name = getattr(settings, dep[1]).split('.')</font>
<font color="red"> 261.                             original_dep = dep</font>
<font color="red"> 262.                             dep = (resolved_app_label, resolved_object_name.lower(), dep[2], dep[3])</font>
<font color="red"> 263.                             is_swappable_dep = True</font>
<font color="red"> 264.                         if dep[0] != app_label and dep[0] != &quot;__setting__&quot;:</font>
<font color="black"> 265.                             # External app dependency. See if it's not yet</font>
<font color="black"> 266.                             # satisfied.</font>
<font color="red"> 267.                             for other_operation in self.generated_operations.get(dep[0], []):</font>
<font color="red"> 268.                                 if self.check_dependency(other_operation, dep):</font>
<font color="red"> 269.                                     deps_satisfied = False</font>
<font color="red"> 270.                                     break</font>
<font color="red"> 271.                             if not deps_satisfied:</font>
<font color="red"> 272.                                 break</font>
<font color="black"> 273.                             else:</font>
<font color="red"> 274.                                 if is_swappable_dep:</font>
<font color="red"> 275.                                     operation_dependencies.add((original_dep[0], original_dep[1]))</font>
<font color="red"> 276.                                 elif dep[0] in self.migrations:</font>
<font color="red"> 277.                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))</font>
<font color="black"> 278.                                 else:</font>
<font color="black"> 279.                                     # If we can't find the other app, we add a first/last dependency,</font>
<font color="black"> 280.                                     # but only if we've already been through once and checked everything</font>
<font color="red"> 281.                                     if chop_mode:</font>
<font color="black"> 282.                                         # If the app already exists, we add a dependency on the last migration,</font>
<font color="black"> 283.                                         # as we don't know which migration contains the target field.</font>
<font color="black"> 284.                                         # If it's not yet migrated or has no migrations, we use __first__</font>
<font color="red"> 285.                                         if graph and graph.leaf_nodes(dep[0]):</font>
<font color="red"> 286.                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])</font>
<font color="black"> 287.                                         else:</font>
<font color="red"> 288.                                             operation_dependencies.add((dep[0], &quot;__first__&quot;))</font>
<font color="black"> 289.                                     else:</font>
<font color="red"> 290.                                         deps_satisfied = False</font>
<font color="red"> 291.                     if deps_satisfied:</font>
<font color="red"> 292.                         chopped.append(operation)</font>
<font color="red"> 293.                         dependencies.update(operation_dependencies)</font>
<font color="red"> 294.                         self.generated_operations[app_label] = self.generated_operations[app_label][1:]</font>
<font color="black"> 295.                     else:</font>
<font color="red"> 296.                         break</font>
<font color="black"> 297.                 # Make a migration! Well, only if there's stuff to put in it</font>
<font color="red"> 298.                 if dependencies or chopped:</font>
<font color="red"> 299.                     if not self.generated_operations[app_label] or chop_mode:</font>
<font color="red"> 300.                         subclass = type(str(&quot;Migration&quot;), (Migration,), {&quot;operations&quot;: [], &quot;dependencies&quot;: []})</font>
<font color="red"> 301.                         instance = subclass(&quot;auto_%i&quot; % (len(self.migrations.get(app_label, [])) + 1), app_label)</font>
<font color="red"> 302.                         instance.dependencies = list(dependencies)</font>
<font color="red"> 303.                         instance.operations = chopped</font>
<font color="red"> 304.                         instance.initial = app_label not in self.existing_apps</font>
<font color="red"> 305.                         self.migrations.setdefault(app_label, []).append(instance)</font>
<font color="red"> 306.                         chop_mode = False</font>
<font color="black"> 307.                     else:</font>
<font color="red"> 308.                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]</font>
<font color="red"> 309.             new_num_ops = sum(len(x) for x in self.generated_operations.values())</font>
<font color="red"> 310.             if new_num_ops == num_ops:</font>
<font color="red"> 311.                 if not chop_mode:</font>
<font color="red"> 312.                     chop_mode = True</font>
<font color="black"> 313.                 else:</font>
<font color="red"> 314.                     raise ValueError(&quot;Cannot resolve operation dependencies: %r&quot; % self.generated_operations)</font>
<font color="red"> 315.             num_ops = new_num_ops</font>
<font color="black"> 316. </font>
<font color="green"> 317.     def _sort_migrations(self):</font>
<font color="black"> 318.         &quot;&quot;&quot;</font>
<font color="black"> 319.         Reorder to make things possible. The order we have already isn't bad,</font>
<font color="black"> 320.         but we need to pull a few things around so FKs work nicely inside the</font>
<font color="black"> 321.         same app</font>
<font color="black"> 322.         &quot;&quot;&quot;</font>
<font color="red"> 323.         for app_label, ops in sorted(self.generated_operations.items()):</font>
<font color="black"> 324.             # construct a dependency graph for intra-app dependencies</font>
<font color="red"> 325.             dependency_graph = {op: set() for op in ops}</font>
<font color="red"> 326.             for op in ops:</font>
<font color="red"> 327.                 for dep in op._auto_deps:</font>
<font color="red"> 328.                     if dep[0] == app_label:</font>
<font color="red"> 329.                         for op2 in ops:</font>
<font color="red"> 330.                             if self.check_dependency(op2, dep):</font>
<font color="red"> 331.                                 dependency_graph[op].add(op2)</font>
<font color="black"> 332. </font>
<font color="black"> 333.             # we use a stable sort for deterministic tests &amp; general behavior</font>
<font color="red"> 334.             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)</font>
<font color="black"> 335. </font>
<font color="green"> 336.     def _optimize_migrations(self):</font>
<font color="black"> 337.         # Add in internal dependencies among the migrations</font>
<font color="red"> 338.         for app_label, migrations in self.migrations.items():</font>
<font color="red"> 339.             for m1, m2 in zip(migrations, migrations[1:]):</font>
<font color="red"> 340.                 m2.dependencies.append((app_label, m1.name))</font>
<font color="black"> 341. </font>
<font color="black"> 342.         # De-dupe dependencies</font>
<font color="red"> 343.         for app_label, migrations in self.migrations.items():</font>
<font color="red"> 344.             for migration in migrations:</font>
<font color="red"> 345.                 migration.dependencies = list(set(migration.dependencies))</font>
<font color="black"> 346. </font>
<font color="black"> 347.         # Optimize migrations</font>
<font color="red"> 348.         for app_label, migrations in self.migrations.items():</font>
<font color="red"> 349.             for migration in migrations:</font>
<font color="red"> 350.                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label=app_label)</font>
<font color="black"> 351. </font>
<font color="green"> 352.     def check_dependency(self, operation, dependency):</font>
<font color="black"> 353.         &quot;&quot;&quot;</font>
<font color="black"> 354.         Returns ``True`` if the given operation depends on the given dependency,</font>
<font color="black"> 355.         ``False`` otherwise.</font>
<font color="black"> 356.         &quot;&quot;&quot;</font>
<font color="black"> 357.         # Created model</font>
<font color="red"> 358.         if dependency[2] is None and dependency[3] is True:</font>
<font color="black"> 359.             return (</font>
<font color="red"> 360.                 isinstance(operation, operations.CreateModel) and</font>
<font color="red"> 361.                 operation.name_lower == dependency[1].lower()</font>
<font color="black"> 362.             )</font>
<font color="black"> 363.         # Created field</font>
<font color="red"> 364.         elif dependency[2] is not None and dependency[3] is True:</font>
<font color="black"> 365.             return (</font>
<font color="black"> 366.                 (</font>
<font color="red"> 367.                     isinstance(operation, operations.CreateModel) and</font>
<font color="red"> 368.                     operation.name_lower == dependency[1].lower() and</font>
<font color="red"> 369.                     any(dependency[2] == x for x, y in operation.fields)</font>
<font color="black"> 370.                 ) or</font>
<font color="black"> 371.                 (</font>
<font color="red"> 372.                     isinstance(operation, operations.AddField) and</font>
<font color="red"> 373.                     operation.model_name_lower == dependency[1].lower() and</font>
<font color="red"> 374.                     operation.name_lower == dependency[2].lower()</font>
<font color="black"> 375.                 )</font>
<font color="black"> 376.             )</font>
<font color="black"> 377.         # Removed field</font>
<font color="red"> 378.         elif dependency[2] is not None and dependency[3] is False:</font>
<font color="black"> 379.             return (</font>
<font color="red"> 380.                 isinstance(operation, operations.RemoveField) and</font>
<font color="red"> 381.                 operation.model_name_lower == dependency[1].lower() and</font>
<font color="red"> 382.                 operation.name_lower == dependency[2].lower()</font>
<font color="black"> 383.             )</font>
<font color="black"> 384.         # Removed model</font>
<font color="red"> 385.         elif dependency[2] is None and dependency[3] is False:</font>
<font color="black"> 386.             return (</font>
<font color="red"> 387.                 isinstance(operation, operations.DeleteModel) and</font>
<font color="red"> 388.                 operation.name_lower == dependency[1].lower()</font>
<font color="black"> 389.             )</font>
<font color="black"> 390.         # Field being altered</font>
<font color="red"> 391.         elif dependency[2] is not None and dependency[3] == &quot;alter&quot;:</font>
<font color="black"> 392.             return (</font>
<font color="red"> 393.                 isinstance(operation, operations.AlterField) and</font>
<font color="red"> 394.                 operation.model_name_lower == dependency[1].lower() and</font>
<font color="red"> 395.                 operation.name_lower == dependency[2].lower()</font>
<font color="black"> 396.             )</font>
<font color="black"> 397.         # order_with_respect_to being unset for a field</font>
<font color="red"> 398.         elif dependency[2] is not None and dependency[3] == &quot;order_wrt_unset&quot;:</font>
<font color="black"> 399.             return (</font>
<font color="red"> 400.                 isinstance(operation, operations.AlterOrderWithRespectTo) and</font>
<font color="red"> 401.                 operation.name_lower == dependency[1].lower() and</font>
<font color="red"> 402.                 (operation.order_with_respect_to or &quot;&quot;).lower() != dependency[2].lower()</font>
<font color="black"> 403.             )</font>
<font color="black"> 404.         # Field is removed and part of an index/unique_together</font>
<font color="red"> 405.         elif dependency[2] is not None and dependency[3] == &quot;foo_together_change&quot;:</font>
<font color="black"> 406.             return (</font>
<font color="red"> 407.                 isinstance(operation, (operations.AlterUniqueTogether,</font>
<font color="red"> 408.                                        operations.AlterIndexTogether)) and</font>
<font color="red"> 409.                 operation.name_lower == dependency[1].lower()</font>
<font color="black"> 410.             )</font>
<font color="black"> 411.         # Unknown dependency. Raise an error.</font>
<font color="black"> 412.         else:</font>
<font color="red"> 413.             raise ValueError(&quot;Can't handle dependency %r&quot; % (dependency, ))</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def add_operation(self, app_label, operation, dependencies=None, beginning=False):</font>
<font color="black"> 416.         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)</font>
<font color="red"> 417.         operation._auto_deps = dependencies or []</font>
<font color="red"> 418.         if beginning:</font>
<font color="red"> 419.             self.generated_operations.setdefault(app_label, []).insert(0, operation)</font>
<font color="black"> 420.         else:</font>
<font color="red"> 421.             self.generated_operations.setdefault(app_label, []).append(operation)</font>
<font color="black"> 422. </font>
<font color="green"> 423.     def swappable_first_key(self, item):</font>
<font color="black"> 424.         &quot;&quot;&quot;</font>
<font color="black"> 425.         Sorting key function that places potential swappable models first in</font>
<font color="black"> 426.         lists of created models (only real way to solve #22783)</font>
<font color="black"> 427.         &quot;&quot;&quot;</font>
<font color="red"> 428.         try:</font>
<font color="red"> 429.             model = self.new_apps.get_model(item[0], item[1])</font>
<font color="red"> 430.             base_names = [base.__name__ for base in model.__bases__]</font>
<font color="red"> 431.             string_version = &quot;%s.%s&quot; % (item[0], item[1])</font>
<font color="black"> 432.             if (</font>
<font color="red"> 433.                 model._meta.swappable or</font>
<font color="red"> 434.                 &quot;AbstractUser&quot; in base_names or</font>
<font color="red"> 435.                 &quot;AbstractBaseUser&quot; in base_names or</font>
<font color="red"> 436.                 settings.AUTH_USER_MODEL.lower() == string_version.lower()</font>
<font color="black"> 437.             ):</font>
<font color="red"> 438.                 return (&quot;___&quot; + item[0], &quot;___&quot; + item[1])</font>
<font color="red"> 439.         except LookupError:</font>
<font color="red"> 440.             pass</font>
<font color="red"> 441.         return item</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def generate_renamed_models(self):</font>
<font color="black"> 444.         &quot;&quot;&quot;</font>
<font color="black"> 445.         Finds any renamed models, and generates the operations for them,</font>
<font color="black"> 446.         and removes the old entry from the model lists.</font>
<font color="black"> 447.         Must be run before other model-level generation.</font>
<font color="black"> 448.         &quot;&quot;&quot;</font>
<font color="red"> 449.         self.renamed_models = {}</font>
<font color="red"> 450.         self.renamed_models_rel = {}</font>
<font color="red"> 451.         added_models = set(self.new_model_keys) - set(self.old_model_keys)</font>
<font color="red"> 452.         for app_label, model_name in sorted(added_models):</font>
<font color="red"> 453.             model_state = self.to_state.models[app_label, model_name]</font>
<font color="red"> 454.             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)</font>
<font color="black"> 455. </font>
<font color="red"> 456.             removed_models = set(self.old_model_keys) - set(self.new_model_keys)</font>
<font color="red"> 457.             for rem_app_label, rem_model_name in removed_models:</font>
<font color="red"> 458.                 if rem_app_label == app_label:</font>
<font color="red"> 459.                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]</font>
<font color="red"> 460.                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)</font>
<font color="red"> 461.                     if model_fields_def == rem_model_fields_def:</font>
<font color="red"> 462.                         if self.questioner.ask_rename_model(rem_model_state, model_state):</font>
<font color="red"> 463.                             self.add_operation(</font>
<font color="red"> 464.                                 app_label,</font>
<font color="red"> 465.                                 operations.RenameModel(</font>
<font color="red"> 466.                                     old_name=rem_model_state.name,</font>
<font color="red"> 467.                                     new_name=model_state.name,</font>
<font color="black"> 468.                                 )</font>
<font color="black"> 469.                             )</font>
<font color="red"> 470.                             self.renamed_models[app_label, model_name] = rem_model_name</font>
<font color="red"> 471.                             renamed_models_rel_key = '%s.%s' % (rem_model_state.app_label, rem_model_state.name)</font>
<font color="red"> 472.                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (</font>
<font color="red"> 473.                                 model_state.app_label,</font>
<font color="red"> 474.                                 model_state.name,</font>
<font color="black"> 475.                             )</font>
<font color="red"> 476.                             self.old_model_keys.remove((rem_app_label, rem_model_name))</font>
<font color="red"> 477.                             self.old_model_keys.append((app_label, model_name))</font>
<font color="red"> 478.                             break</font>
<font color="black"> 479. </font>
<font color="green"> 480.     def generate_created_models(self):</font>
<font color="black"> 481.         &quot;&quot;&quot;</font>
<font color="black"> 482.         Find all new models (both managed and unmanaged) and make create</font>
<font color="black"> 483.         operations for them as well as separate operations to create any</font>
<font color="black"> 484.         foreign key or M2M relationships (we'll optimize these back in later</font>
<font color="black"> 485.         if we can).</font>
<font color="black"> 486. </font>
<font color="black"> 487.         We also defer any model options that refer to collections of fields</font>
<font color="black"> 488.         that might be deferred (e.g. unique_together, index_together).</font>
<font color="black"> 489.         &quot;&quot;&quot;</font>
<font color="red"> 490.         old_keys = set(self.old_model_keys).union(self.old_unmanaged_keys)</font>
<font color="red"> 491.         added_models = set(self.new_model_keys) - old_keys</font>
<font color="red"> 492.         added_unmanaged_models = set(self.new_unmanaged_keys) - old_keys</font>
<font color="red"> 493.         all_added_models = chain(</font>
<font color="red"> 494.             sorted(added_models, key=self.swappable_first_key, reverse=True),</font>
<font color="red"> 495.             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)</font>
<font color="black"> 496.         )</font>
<font color="red"> 497.         for app_label, model_name in all_added_models:</font>
<font color="red"> 498.             model_state = self.to_state.models[app_label, model_name]</font>
<font color="red"> 499.             model_opts = self.new_apps.get_model(app_label, model_name)._meta</font>
<font color="black"> 500.             # Gather related fields</font>
<font color="red"> 501.             related_fields = {}</font>
<font color="red"> 502.             primary_key_rel = None</font>
<font color="red"> 503.             for field in model_opts.local_fields:</font>
<font color="red"> 504.                 if field.remote_field:</font>
<font color="red"> 505.                     if field.remote_field.model:</font>
<font color="red"> 506.                         if field.primary_key:</font>
<font color="red"> 507.                             primary_key_rel = field.remote_field.model</font>
<font color="red"> 508.                         elif not field.remote_field.parent_link:</font>
<font color="red"> 509.                             related_fields[field.name] = field</font>
<font color="black"> 510.                     # through will be none on M2Ms on swapped-out models;</font>
<font color="black"> 511.                     # we can treat lack of through as auto_created=True, though.</font>
<font color="red"> 512.                     if (getattr(field.remote_field, &quot;through&quot;, None)</font>
<font color="red"> 513.                             and not field.remote_field.through._meta.auto_created):</font>
<font color="red"> 514.                         related_fields[field.name] = field</font>
<font color="red"> 515.             for field in model_opts.local_many_to_many:</font>
<font color="red"> 516.                 if field.remote_field.model:</font>
<font color="red"> 517.                     related_fields[field.name] = field</font>
<font color="red"> 518.                 if getattr(field.remote_field, &quot;through&quot;, None) and not field.remote_field.through._meta.auto_created:</font>
<font color="red"> 519.                     related_fields[field.name] = field</font>
<font color="black"> 520.             # Are there unique/index_together to defer?</font>
<font color="red"> 521.             unique_together = model_state.options.pop('unique_together', None)</font>
<font color="red"> 522.             index_together = model_state.options.pop('index_together', None)</font>
<font color="red"> 523.             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)</font>
<font color="black"> 524.             # Depend on the deletion of any possible proxy version of us</font>
<font color="black"> 525.             dependencies = [</font>
<font color="red"> 526.                 (app_label, model_name, None, False),</font>
<font color="black"> 527.             ]</font>
<font color="black"> 528.             # Depend on all bases</font>
<font color="red"> 529.             for base in model_state.bases:</font>
<font color="red"> 530.                 if isinstance(base, six.string_types) and &quot;.&quot; in base:</font>
<font color="red"> 531.                     base_app_label, base_name = base.split(&quot;.&quot;, 1)</font>
<font color="red"> 532.                     dependencies.append((base_app_label, base_name, None, True))</font>
<font color="black"> 533.             # Depend on the other end of the primary key if it's a relation</font>
<font color="red"> 534.             if primary_key_rel:</font>
<font color="red"> 535.                 dependencies.append((</font>
<font color="red"> 536.                     primary_key_rel._meta.app_label,</font>
<font color="red"> 537.                     primary_key_rel._meta.object_name,</font>
<font color="red"> 538.                     None,</font>
<font color="red"> 539.                     True</font>
<font color="black"> 540.                 ))</font>
<font color="black"> 541.             # Generate creation operation</font>
<font color="red"> 542.             self.add_operation(</font>
<font color="red"> 543.                 app_label,</font>
<font color="red"> 544.                 operations.CreateModel(</font>
<font color="red"> 545.                     name=model_state.name,</font>
<font color="red"> 546.                     fields=[d for d in model_state.fields if d[0] not in related_fields],</font>
<font color="red"> 547.                     options=model_state.options,</font>
<font color="red"> 548.                     bases=model_state.bases,</font>
<font color="red"> 549.                     managers=model_state.managers,</font>
<font color="black"> 550.                 ),</font>
<font color="red"> 551.                 dependencies=dependencies,</font>
<font color="red"> 552.                 beginning=True,</font>
<font color="black"> 553.             )</font>
<font color="black"> 554. </font>
<font color="black"> 555.             # Don't add operations which modify the database for unmanaged models</font>
<font color="red"> 556.             if not model_opts.managed:</font>
<font color="red"> 557.                 continue</font>
<font color="black"> 558. </font>
<font color="black"> 559.             # Generate operations for each related field</font>
<font color="red"> 560.             for name, field in sorted(related_fields.items()):</font>
<font color="black"> 561.                 # Account for FKs to swappable models</font>
<font color="red"> 562.                 swappable_setting = getattr(field, 'swappable_setting', None)</font>
<font color="red"> 563.                 if swappable_setting is not None:</font>
<font color="red"> 564.                     dep_app_label = &quot;__setting__&quot;</font>
<font color="red"> 565.                     dep_object_name = swappable_setting</font>
<font color="black"> 566.                 else:</font>
<font color="red"> 567.                     dep_app_label = field.remote_field.model._meta.app_label</font>
<font color="red"> 568.                     dep_object_name = field.remote_field.model._meta.object_name</font>
<font color="red"> 569.                 dependencies = [(dep_app_label, dep_object_name, None, True)]</font>
<font color="red"> 570.                 if getattr(field.remote_field, &quot;through&quot;, None) and not field.remote_field.through._meta.auto_created:</font>
<font color="red"> 571.                     dependencies.append((</font>
<font color="red"> 572.                         field.remote_field.through._meta.app_label,</font>
<font color="red"> 573.                         field.remote_field.through._meta.object_name,</font>
<font color="red"> 574.                         None,</font>
<font color="red"> 575.                         True</font>
<font color="black"> 576.                     ))</font>
<font color="black"> 577.                 # Depend on our own model being created</font>
<font color="red"> 578.                 dependencies.append((app_label, model_name, None, True))</font>
<font color="black"> 579.                 # Make operation</font>
<font color="red"> 580.                 self.add_operation(</font>
<font color="red"> 581.                     app_label,</font>
<font color="red"> 582.                     operations.AddField(</font>
<font color="red"> 583.                         model_name=model_name,</font>
<font color="red"> 584.                         name=name,</font>
<font color="red"> 585.                         field=field,</font>
<font color="black"> 586.                     ),</font>
<font color="red"> 587.                     dependencies=list(set(dependencies)),</font>
<font color="black"> 588.                 )</font>
<font color="black"> 589.             # Generate other opns</font>
<font color="black"> 590.             related_dependencies = [</font>
<font color="red"> 591.                 (app_label, model_name, name, True)</font>
<font color="red"> 592.                 for name, field in sorted(related_fields.items())</font>
<font color="black"> 593.             ]</font>
<font color="red"> 594.             related_dependencies.append((app_label, model_name, None, True))</font>
<font color="red"> 595.             if unique_together:</font>
<font color="red"> 596.                 self.add_operation(</font>
<font color="red"> 597.                     app_label,</font>
<font color="red"> 598.                     operations.AlterUniqueTogether(</font>
<font color="red"> 599.                         name=model_name,</font>
<font color="red"> 600.                         unique_together=unique_together,</font>
<font color="black"> 601.                     ),</font>
<font color="red"> 602.                     dependencies=related_dependencies</font>
<font color="black"> 603.                 )</font>
<font color="red"> 604.             if index_together:</font>
<font color="red"> 605.                 self.add_operation(</font>
<font color="red"> 606.                     app_label,</font>
<font color="red"> 607.                     operations.AlterIndexTogether(</font>
<font color="red"> 608.                         name=model_name,</font>
<font color="red"> 609.                         index_together=index_together,</font>
<font color="black"> 610.                     ),</font>
<font color="red"> 611.                     dependencies=related_dependencies</font>
<font color="black"> 612.                 )</font>
<font color="red"> 613.             if order_with_respect_to:</font>
<font color="red"> 614.                 self.add_operation(</font>
<font color="red"> 615.                     app_label,</font>
<font color="red"> 616.                     operations.AlterOrderWithRespectTo(</font>
<font color="red"> 617.                         name=model_name,</font>
<font color="red"> 618.                         order_with_respect_to=order_with_respect_to,</font>
<font color="black"> 619.                     ),</font>
<font color="black"> 620.                     dependencies=[</font>
<font color="red"> 621.                         (app_label, model_name, order_with_respect_to, True),</font>
<font color="red"> 622.                         (app_label, model_name, None, True),</font>
<font color="black"> 623.                     ]</font>
<font color="black"> 624.                 )</font>
<font color="black"> 625. </font>
<font color="green"> 626.     def generate_created_proxies(self):</font>
<font color="black"> 627.         &quot;&quot;&quot;</font>
<font color="black"> 628.         Makes CreateModel statements for proxy models.</font>
<font color="black"> 629.         We use the same statements as that way there's less code duplication,</font>
<font color="black"> 630.         but of course for proxy models we can skip all that pointless field</font>
<font color="black"> 631.         stuff and just chuck out an operation.</font>
<font color="black"> 632.         &quot;&quot;&quot;</font>
<font color="red"> 633.         added = set(self.new_proxy_keys) - set(self.old_proxy_keys)</font>
<font color="red"> 634.         for app_label, model_name in sorted(added):</font>
<font color="red"> 635.             model_state = self.to_state.models[app_label, model_name]</font>
<font color="red"> 636.             assert model_state.options.get(&quot;proxy&quot;)</font>
<font color="black"> 637.             # Depend on the deletion of any possible non-proxy version of us</font>
<font color="black"> 638.             dependencies = [</font>
<font color="red"> 639.                 (app_label, model_name, None, False),</font>
<font color="black"> 640.             ]</font>
<font color="black"> 641.             # Depend on all bases</font>
<font color="red"> 642.             for base in model_state.bases:</font>
<font color="red"> 643.                 if isinstance(base, six.string_types) and &quot;.&quot; in base:</font>
<font color="red"> 644.                     base_app_label, base_name = base.split(&quot;.&quot;, 1)</font>
<font color="red"> 645.                     dependencies.append((base_app_label, base_name, None, True))</font>
<font color="black"> 646.             # Generate creation operation</font>
<font color="red"> 647.             self.add_operation(</font>
<font color="red"> 648.                 app_label,</font>
<font color="red"> 649.                 operations.CreateModel(</font>
<font color="red"> 650.                     name=model_state.name,</font>
<font color="red"> 651.                     fields=[],</font>
<font color="red"> 652.                     options=model_state.options,</font>
<font color="red"> 653.                     bases=model_state.bases,</font>
<font color="red"> 654.                     managers=model_state.managers,</font>
<font color="black"> 655.                 ),</font>
<font color="black"> 656.                 # Depend on the deletion of any possible non-proxy version of us</font>
<font color="red"> 657.                 dependencies=dependencies,</font>
<font color="black"> 658.             )</font>
<font color="black"> 659. </font>
<font color="green"> 660.     def generate_deleted_models(self):</font>
<font color="black"> 661.         &quot;&quot;&quot;</font>
<font color="black"> 662.         Find all deleted models (managed and unmanaged) and make delete</font>
<font color="black"> 663.         operations for them as well as separate operations to delete any</font>
<font color="black"> 664.         foreign key or M2M relationships (we'll optimize these back in later</font>
<font color="black"> 665.         if we can).</font>
<font color="black"> 666. </font>
<font color="black"> 667.         We also bring forward removal of any model options that refer to</font>
<font color="black"> 668.         collections of fields - the inverse of generate_created_models().</font>
<font color="black"> 669.         &quot;&quot;&quot;</font>
<font color="red"> 670.         new_keys = set(self.new_model_keys).union(self.new_unmanaged_keys)</font>
<font color="red"> 671.         deleted_models = set(self.old_model_keys) - new_keys</font>
<font color="red"> 672.         deleted_unmanaged_models = set(self.old_unmanaged_keys) - new_keys</font>
<font color="red"> 673.         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))</font>
<font color="red"> 674.         for app_label, model_name in all_deleted_models:</font>
<font color="red"> 675.             model_state = self.from_state.models[app_label, model_name]</font>
<font color="red"> 676.             model = self.old_apps.get_model(app_label, model_name)</font>
<font color="red"> 677.             if not model._meta.managed:</font>
<font color="black"> 678.                 # Skip here, no need to handle fields for unmanaged models</font>
<font color="red"> 679.                 continue</font>
<font color="black"> 680. </font>
<font color="black"> 681.             # Gather related fields</font>
<font color="red"> 682.             related_fields = {}</font>
<font color="red"> 683.             for field in model._meta.local_fields:</font>
<font color="red"> 684.                 if field.remote_field:</font>
<font color="red"> 685.                     if field.remote_field.model:</font>
<font color="red"> 686.                         related_fields[field.name] = field</font>
<font color="black"> 687.                     # through will be none on M2Ms on swapped-out models;</font>
<font color="black"> 688.                     # we can treat lack of through as auto_created=True, though.</font>
<font color="red"> 689.                     if (getattr(field.remote_field, &quot;through&quot;, None)</font>
<font color="red"> 690.                             and not field.remote_field.through._meta.auto_created):</font>
<font color="red"> 691.                         related_fields[field.name] = field</font>
<font color="red"> 692.             for field in model._meta.local_many_to_many:</font>
<font color="red"> 693.                 if field.remote_field.model:</font>
<font color="red"> 694.                     related_fields[field.name] = field</font>
<font color="red"> 695.                 if getattr(field.remote_field, &quot;through&quot;, None) and not field.remote_field.through._meta.auto_created:</font>
<font color="red"> 696.                     related_fields[field.name] = field</font>
<font color="black"> 697.             # Generate option removal first</font>
<font color="red"> 698.             unique_together = model_state.options.pop('unique_together', None)</font>
<font color="red"> 699.             index_together = model_state.options.pop('index_together', None)</font>
<font color="red"> 700.             if unique_together:</font>
<font color="red"> 701.                 self.add_operation(</font>
<font color="red"> 702.                     app_label,</font>
<font color="red"> 703.                     operations.AlterUniqueTogether(</font>
<font color="red"> 704.                         name=model_name,</font>
<font color="red"> 705.                         unique_together=None,</font>
<font color="black"> 706.                     )</font>
<font color="black"> 707.                 )</font>
<font color="red"> 708.             if index_together:</font>
<font color="red"> 709.                 self.add_operation(</font>
<font color="red"> 710.                     app_label,</font>
<font color="red"> 711.                     operations.AlterIndexTogether(</font>
<font color="red"> 712.                         name=model_name,</font>
<font color="red"> 713.                         index_together=None,</font>
<font color="black"> 714.                     )</font>
<font color="black"> 715.                 )</font>
<font color="black"> 716.             # Then remove each related field</font>
<font color="red"> 717.             for name, field in sorted(related_fields.items()):</font>
<font color="red"> 718.                 self.add_operation(</font>
<font color="red"> 719.                     app_label,</font>
<font color="red"> 720.                     operations.RemoveField(</font>
<font color="red"> 721.                         model_name=model_name,</font>
<font color="red"> 722.                         name=name,</font>
<font color="black"> 723.                     )</font>
<font color="black"> 724.                 )</font>
<font color="black"> 725.             # Finally, remove the model.</font>
<font color="black"> 726.             # This depends on both the removal/alteration of all incoming fields</font>
<font color="black"> 727.             # and the removal of all its own related fields, and if it's</font>
<font color="black"> 728.             # a through model the field that references it.</font>
<font color="red"> 729.             dependencies = []</font>
<font color="red"> 730.             for related_object in model._meta.related_objects:</font>
<font color="red"> 731.                 related_object_app_label = related_object.related_model._meta.app_label</font>
<font color="red"> 732.                 object_name = related_object.related_model._meta.object_name</font>
<font color="red"> 733.                 field_name = related_object.field.name</font>
<font color="red"> 734.                 dependencies.append((related_object_app_label, object_name, field_name, False))</font>
<font color="red"> 735.                 if not related_object.many_to_many:</font>
<font color="red"> 736.                     dependencies.append((related_object_app_label, object_name, field_name, &quot;alter&quot;))</font>
<font color="black"> 737. </font>
<font color="red"> 738.             for name, field in sorted(related_fields.items()):</font>
<font color="red"> 739.                 dependencies.append((app_label, model_name, name, False))</font>
<font color="black"> 740.             # We're referenced in another field's through=</font>
<font color="red"> 741.             through_user = self.through_users.get((app_label, model_state.name_lower))</font>
<font color="red"> 742.             if through_user:</font>
<font color="red"> 743.                 dependencies.append((through_user[0], through_user[1], through_user[2], False))</font>
<font color="black"> 744.             # Finally, make the operation, deduping any dependencies</font>
<font color="red"> 745.             self.add_operation(</font>
<font color="red"> 746.                 app_label,</font>
<font color="red"> 747.                 operations.DeleteModel(</font>
<font color="red"> 748.                     name=model_state.name,</font>
<font color="black"> 749.                 ),</font>
<font color="red"> 750.                 dependencies=list(set(dependencies)),</font>
<font color="black"> 751.             )</font>
<font color="black"> 752. </font>
<font color="green"> 753.     def generate_deleted_proxies(self):</font>
<font color="black"> 754.         &quot;&quot;&quot;</font>
<font color="black"> 755.         Makes DeleteModel statements for proxy models.</font>
<font color="black"> 756.         &quot;&quot;&quot;</font>
<font color="red"> 757.         deleted = set(self.old_proxy_keys) - set(self.new_proxy_keys)</font>
<font color="red"> 758.         for app_label, model_name in sorted(deleted):</font>
<font color="red"> 759.             model_state = self.from_state.models[app_label, model_name]</font>
<font color="red"> 760.             assert model_state.options.get(&quot;proxy&quot;)</font>
<font color="red"> 761.             self.add_operation(</font>
<font color="red"> 762.                 app_label,</font>
<font color="red"> 763.                 operations.DeleteModel(</font>
<font color="red"> 764.                     name=model_state.name,</font>
<font color="black"> 765.                 ),</font>
<font color="black"> 766.             )</font>
<font color="black"> 767. </font>
<font color="green"> 768.     def generate_renamed_fields(self):</font>
<font color="black"> 769.         &quot;&quot;&quot;</font>
<font color="black"> 770.         Works out renamed fields</font>
<font color="black"> 771.         &quot;&quot;&quot;</font>
<font color="red"> 772.         self.renamed_fields = {}</font>
<font color="red"> 773.         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):</font>
<font color="red"> 774.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red"> 775.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red"> 776.             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)</font>
<font color="black"> 777.             # Scan to see if this is actually a rename!</font>
<font color="red"> 778.             field_dec = self.deep_deconstruct(field)</font>
<font color="red"> 779.             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):</font>
<font color="red"> 780.                 if rem_app_label == app_label and rem_model_name == model_name:</font>
<font color="red"> 781.                     old_field_dec = self.deep_deconstruct(old_model_state.get_field_by_name(rem_field_name))</font>
<font color="red"> 782.                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:</font>
<font color="red"> 783.                         old_rel_to = old_field_dec[2]['to']</font>
<font color="red"> 784.                         if old_rel_to in self.renamed_models_rel:</font>
<font color="red"> 785.                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]</font>
<font color="red"> 786.                     if old_field_dec == field_dec:</font>
<font color="red"> 787.                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):</font>
<font color="red"> 788.                             self.add_operation(</font>
<font color="red"> 789.                                 app_label,</font>
<font color="red"> 790.                                 operations.RenameField(</font>
<font color="red"> 791.                                     model_name=model_name,</font>
<font color="red"> 792.                                     old_name=rem_field_name,</font>
<font color="red"> 793.                                     new_name=field_name,</font>
<font color="black"> 794.                                 )</font>
<font color="black"> 795.                             )</font>
<font color="red"> 796.                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))</font>
<font color="red"> 797.                             self.old_field_keys.add((app_label, model_name, field_name))</font>
<font color="red"> 798.                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name</font>
<font color="red"> 799.                             break</font>
<font color="black"> 800. </font>
<font color="green"> 801.     def generate_added_fields(self):</font>
<font color="black"> 802.         &quot;&quot;&quot;</font>
<font color="black"> 803.         Fields that have been added</font>
<font color="black"> 804.         &quot;&quot;&quot;</font>
<font color="red"> 805.         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):</font>
<font color="red"> 806.             self._generate_added_field(app_label, model_name, field_name)</font>
<font color="black"> 807. </font>
<font color="green"> 808.     def _generate_added_field(self, app_label, model_name, field_name):</font>
<font color="red"> 809.         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)</font>
<font color="black"> 810.         # Fields that are foreignkeys/m2ms depend on stuff</font>
<font color="red"> 811.         dependencies = []</font>
<font color="red"> 812.         if field.remote_field and field.remote_field.model:</font>
<font color="black"> 813.             # Account for FKs to swappable models</font>
<font color="red"> 814.             swappable_setting = getattr(field, 'swappable_setting', None)</font>
<font color="red"> 815.             if swappable_setting is not None:</font>
<font color="red"> 816.                 dep_app_label = &quot;__setting__&quot;</font>
<font color="red"> 817.                 dep_object_name = swappable_setting</font>
<font color="black"> 818.             else:</font>
<font color="red"> 819.                 dep_app_label = field.remote_field.model._meta.app_label</font>
<font color="red"> 820.                 dep_object_name = field.remote_field.model._meta.object_name</font>
<font color="red"> 821.             dependencies = [(dep_app_label, dep_object_name, None, True)]</font>
<font color="red"> 822.             if getattr(field.remote_field, &quot;through&quot;, None) and not field.remote_field.through._meta.auto_created:</font>
<font color="red"> 823.                 dependencies.append((</font>
<font color="red"> 824.                     field.remote_field.through._meta.app_label,</font>
<font color="red"> 825.                     field.remote_field.through._meta.object_name,</font>
<font color="red"> 826.                     None,</font>
<font color="red"> 827.                     True,</font>
<font color="black"> 828.                 ))</font>
<font color="black"> 829.         # You can't just add NOT NULL fields with no default or fields</font>
<font color="black"> 830.         # which don't allow empty strings as default.</font>
<font color="red"> 831.         preserve_default = True</font>
<font color="red"> 832.         if (not field.null and not field.has_default() and</font>
<font color="red"> 833.                 not isinstance(field, models.ManyToManyField) and</font>
<font color="red"> 834.                 not (field.blank and field.empty_strings_allowed)):</font>
<font color="red"> 835.             field = field.clone()</font>
<font color="red"> 836.             field.default = self.questioner.ask_not_null_addition(field_name, model_name)</font>
<font color="red"> 837.             preserve_default = False</font>
<font color="red"> 838.         self.add_operation(</font>
<font color="red"> 839.             app_label,</font>
<font color="red"> 840.             operations.AddField(</font>
<font color="red"> 841.                 model_name=model_name,</font>
<font color="red"> 842.                 name=field_name,</font>
<font color="red"> 843.                 field=field,</font>
<font color="red"> 844.                 preserve_default=preserve_default,</font>
<font color="black"> 845.             ),</font>
<font color="red"> 846.             dependencies=dependencies,</font>
<font color="black"> 847.         )</font>
<font color="black"> 848. </font>
<font color="green"> 849.     def generate_removed_fields(self):</font>
<font color="black"> 850.         &quot;&quot;&quot;</font>
<font color="black"> 851.         Fields that have been removed.</font>
<font color="black"> 852.         &quot;&quot;&quot;</font>
<font color="red"> 853.         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):</font>
<font color="red"> 854.             self._generate_removed_field(app_label, model_name, field_name)</font>
<font color="black"> 855. </font>
<font color="green"> 856.     def _generate_removed_field(self, app_label, model_name, field_name):</font>
<font color="red"> 857.         self.add_operation(</font>
<font color="red"> 858.             app_label,</font>
<font color="red"> 859.             operations.RemoveField(</font>
<font color="red"> 860.                 model_name=model_name,</font>
<font color="red"> 861.                 name=field_name,</font>
<font color="black"> 862.             ),</font>
<font color="black"> 863.             # We might need to depend on the removal of an</font>
<font color="black"> 864.             # order_with_respect_to or index/unique_together operation;</font>
<font color="black"> 865.             # this is safely ignored if there isn't one</font>
<font color="black"> 866.             dependencies=[</font>
<font color="red"> 867.                 (app_label, model_name, field_name, &quot;order_wrt_unset&quot;),</font>
<font color="red"> 868.                 (app_label, model_name, field_name, &quot;foo_together_change&quot;),</font>
<font color="black"> 869.             ],</font>
<font color="black"> 870.         )</font>
<font color="black"> 871. </font>
<font color="green"> 872.     def generate_altered_fields(self):</font>
<font color="black"> 873.         &quot;&quot;&quot;</font>
<font color="black"> 874.         Fields that have been altered.</font>
<font color="black"> 875.         &quot;&quot;&quot;</font>
<font color="red"> 876.         for app_label, model_name, field_name in sorted(self.old_field_keys.intersection(self.new_field_keys)):</font>
<font color="black"> 877.             # Did the field change?</font>
<font color="red"> 878.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red"> 879.             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)</font>
<font color="red"> 880.             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)</font>
<font color="red"> 881.             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)</font>
<font color="black"> 882.             # Implement any model renames on relations; these are handled by RenameModel</font>
<font color="black"> 883.             # so we need to exclude them from the comparison</font>
<font color="red"> 884.             if hasattr(new_field, &quot;remote_field&quot;) and getattr(new_field.remote_field, &quot;model&quot;, None):</font>
<font color="black"> 885.                 rename_key = (</font>
<font color="red"> 886.                     new_field.remote_field.model._meta.app_label,</font>
<font color="red"> 887.                     new_field.remote_field.model._meta.model_name,</font>
<font color="black"> 888.                 )</font>
<font color="red"> 889.                 if rename_key in self.renamed_models:</font>
<font color="red"> 890.                     new_field.remote_field.model = old_field.remote_field.model</font>
<font color="red"> 891.             old_field_dec = self.deep_deconstruct(old_field)</font>
<font color="red"> 892.             new_field_dec = self.deep_deconstruct(new_field)</font>
<font color="red"> 893.             if old_field_dec != new_field_dec:</font>
<font color="black"> 894.                 both_m2m = (</font>
<font color="red"> 895.                     isinstance(old_field, models.ManyToManyField) and</font>
<font color="red"> 896.                     isinstance(new_field, models.ManyToManyField)</font>
<font color="black"> 897.                 )</font>
<font color="black"> 898.                 neither_m2m = (</font>
<font color="red"> 899.                     not isinstance(old_field, models.ManyToManyField) and</font>
<font color="red"> 900.                     not isinstance(new_field, models.ManyToManyField)</font>
<font color="black"> 901.                 )</font>
<font color="red"> 902.                 if both_m2m or neither_m2m:</font>
<font color="black"> 903.                     # Either both fields are m2m or neither is</font>
<font color="red"> 904.                     preserve_default = True</font>
<font color="red"> 905.                     if (old_field.null and not new_field.null and not new_field.has_default() and</font>
<font color="red"> 906.                             not isinstance(new_field, models.ManyToManyField)):</font>
<font color="red"> 907.                         field = new_field.clone()</font>
<font color="red"> 908.                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)</font>
<font color="red"> 909.                         if new_default is not models.NOT_PROVIDED:</font>
<font color="red"> 910.                             field.default = new_default</font>
<font color="red"> 911.                             preserve_default = False</font>
<font color="black"> 912.                     else:</font>
<font color="red"> 913.                         field = new_field</font>
<font color="red"> 914.                     self.add_operation(</font>
<font color="red"> 915.                         app_label,</font>
<font color="red"> 916.                         operations.AlterField(</font>
<font color="red"> 917.                             model_name=model_name,</font>
<font color="red"> 918.                             name=field_name,</font>
<font color="red"> 919.                             field=field,</font>
<font color="red"> 920.                             preserve_default=preserve_default,</font>
<font color="black"> 921.                         )</font>
<font color="black"> 922.                     )</font>
<font color="black"> 923.                 else:</font>
<font color="black"> 924.                     # We cannot alter between m2m and concrete fields</font>
<font color="red"> 925.                     self._generate_removed_field(app_label, model_name, field_name)</font>
<font color="red"> 926.                     self._generate_added_field(app_label, model_name, field_name)</font>
<font color="black"> 927. </font>
<font color="green"> 928.     def _generate_altered_foo_together(self, operation):</font>
<font color="red"> 929.         option_name = operation.option_name</font>
<font color="red"> 930.         for app_label, model_name in sorted(self.kept_model_keys):</font>
<font color="red"> 931.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red"> 932.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red"> 933.             new_model_state = self.to_state.models[app_label, model_name]</font>
<font color="black"> 934. </font>
<font color="black"> 935.             # We run the old version through the field renames to account for those</font>
<font color="red"> 936.             old_value = old_model_state.options.get(option_name) or set()</font>
<font color="red"> 937.             if old_value:</font>
<font color="black"> 938.                 old_value = {</font>
<font color="red"> 939.                     tuple(</font>
<font color="red"> 940.                         self.renamed_fields.get((app_label, model_name, n), n)</font>
<font color="red"> 941.                         for n in unique</font>
<font color="black"> 942.                     )</font>
<font color="red"> 943.                     for unique in old_value</font>
<font color="black"> 944.                 }</font>
<font color="black"> 945. </font>
<font color="red"> 946.             new_value = new_model_state.options.get(option_name) or set()</font>
<font color="red"> 947.             if new_value:</font>
<font color="red"> 948.                 new_value = set(new_value)</font>
<font color="black"> 949. </font>
<font color="red"> 950.             if old_value != new_value:</font>
<font color="red"> 951.                 self.add_operation(</font>
<font color="red"> 952.                     app_label,</font>
<font color="red"> 953.                     operation(</font>
<font color="red"> 954.                         name=model_name,</font>
<font color="red"> 955.                         **{option_name: new_value}</font>
<font color="black"> 956.                     )</font>
<font color="black"> 957.                 )</font>
<font color="black"> 958. </font>
<font color="green"> 959.     def generate_altered_unique_together(self):</font>
<font color="red"> 960.         self._generate_altered_foo_together(operations.AlterUniqueTogether)</font>
<font color="black"> 961. </font>
<font color="green"> 962.     def generate_altered_index_together(self):</font>
<font color="red"> 963.         self._generate_altered_foo_together(operations.AlterIndexTogether)</font>
<font color="black"> 964. </font>
<font color="green"> 965.     def generate_altered_db_table(self):</font>
<font color="red"> 966.         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys).union(self.kept_unmanaged_keys)</font>
<font color="red"> 967.         for app_label, model_name in sorted(models_to_check):</font>
<font color="red"> 968.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red"> 969.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red"> 970.             new_model_state = self.to_state.models[app_label, model_name]</font>
<font color="red"> 971.             old_db_table_name = old_model_state.options.get('db_table')</font>
<font color="red"> 972.             new_db_table_name = new_model_state.options.get('db_table')</font>
<font color="red"> 973.             if old_db_table_name != new_db_table_name:</font>
<font color="red"> 974.                 self.add_operation(</font>
<font color="red"> 975.                     app_label,</font>
<font color="red"> 976.                     operations.AlterModelTable(</font>
<font color="red"> 977.                         name=model_name,</font>
<font color="red"> 978.                         table=new_db_table_name,</font>
<font color="black"> 979.                     )</font>
<font color="black"> 980.                 )</font>
<font color="black"> 981. </font>
<font color="green"> 982.     def generate_altered_options(self):</font>
<font color="black"> 983.         &quot;&quot;&quot;</font>
<font color="black"> 984.         Works out if any non-schema-affecting options have changed and</font>
<font color="black"> 985.         makes an operation to represent them in state changes (in case Python</font>
<font color="black"> 986.         code in migrations needs them)</font>
<font color="black"> 987.         &quot;&quot;&quot;</font>
<font color="red"> 988.         models_to_check = self.kept_model_keys.union(</font>
<font color="red"> 989.             self.kept_proxy_keys</font>
<font color="black"> 990.         ).union(</font>
<font color="red"> 991.             self.kept_unmanaged_keys</font>
<font color="black"> 992.         ).union(</font>
<font color="black"> 993.             # unmanaged converted to managed</font>
<font color="red"> 994.             set(self.old_unmanaged_keys).intersection(self.new_model_keys)</font>
<font color="black"> 995.         ).union(</font>
<font color="black"> 996.             # managed converted to unmanaged</font>
<font color="red"> 997.             set(self.old_model_keys).intersection(self.new_unmanaged_keys)</font>
<font color="black"> 998.         )</font>
<font color="black"> 999. </font>
<font color="red">1000.         for app_label, model_name in sorted(models_to_check):</font>
<font color="red">1001.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red">1002.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red">1003.             new_model_state = self.to_state.models[app_label, model_name]</font>
<font color="red">1004.             old_options = dict(</font>
<font color="red">1005.                 option for option in old_model_state.options.items()</font>
<font color="red">1006.                 if option[0] in AlterModelOptions.ALTER_OPTION_KEYS</font>
<font color="black">1007.             )</font>
<font color="red">1008.             new_options = dict(</font>
<font color="red">1009.                 option for option in new_model_state.options.items()</font>
<font color="red">1010.                 if option[0] in AlterModelOptions.ALTER_OPTION_KEYS</font>
<font color="black">1011.             )</font>
<font color="red">1012.             if old_options != new_options:</font>
<font color="red">1013.                 self.add_operation(</font>
<font color="red">1014.                     app_label,</font>
<font color="red">1015.                     operations.AlterModelOptions(</font>
<font color="red">1016.                         name=model_name,</font>
<font color="red">1017.                         options=new_options,</font>
<font color="black">1018.                     )</font>
<font color="black">1019.                 )</font>
<font color="black">1020. </font>
<font color="green">1021.     def generate_altered_order_with_respect_to(self):</font>
<font color="red">1022.         for app_label, model_name in sorted(self.kept_model_keys):</font>
<font color="red">1023.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red">1024.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red">1025.             new_model_state = self.to_state.models[app_label, model_name]</font>
<font color="red">1026.             if (old_model_state.options.get(&quot;order_with_respect_to&quot;) !=</font>
<font color="red">1027.                     new_model_state.options.get(&quot;order_with_respect_to&quot;)):</font>
<font color="black">1028.                 # Make sure it comes second if we're adding</font>
<font color="black">1029.                 # (removal dependency is part of RemoveField)</font>
<font color="red">1030.                 dependencies = []</font>
<font color="red">1031.                 if new_model_state.options.get(&quot;order_with_respect_to&quot;):</font>
<font color="red">1032.                     dependencies.append((</font>
<font color="red">1033.                         app_label,</font>
<font color="red">1034.                         model_name,</font>
<font color="red">1035.                         new_model_state.options[&quot;order_with_respect_to&quot;],</font>
<font color="red">1036.                         True,</font>
<font color="black">1037.                     ))</font>
<font color="black">1038.                 # Actually generate the operation</font>
<font color="red">1039.                 self.add_operation(</font>
<font color="red">1040.                     app_label,</font>
<font color="red">1041.                     operations.AlterOrderWithRespectTo(</font>
<font color="red">1042.                         name=model_name,</font>
<font color="red">1043.                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),</font>
<font color="black">1044.                     ),</font>
<font color="red">1045.                     dependencies=dependencies,</font>
<font color="black">1046.                 )</font>
<font color="black">1047. </font>
<font color="green">1048.     def generate_altered_managers(self):</font>
<font color="red">1049.         for app_label, model_name in sorted(self.kept_model_keys):</font>
<font color="red">1050.             old_model_name = self.renamed_models.get((app_label, model_name), model_name)</font>
<font color="red">1051.             old_model_state = self.from_state.models[app_label, old_model_name]</font>
<font color="red">1052.             new_model_state = self.to_state.models[app_label, model_name]</font>
<font color="red">1053.             if old_model_state.managers != new_model_state.managers:</font>
<font color="red">1054.                 self.add_operation(</font>
<font color="red">1055.                     app_label,</font>
<font color="red">1056.                     operations.AlterModelManagers(</font>
<font color="red">1057.                         name=model_name,</font>
<font color="red">1058.                         managers=new_model_state.managers,</font>
<font color="black">1059.                     )</font>
<font color="black">1060.                 )</font>
<font color="black">1061. </font>
<font color="green">1062.     def arrange_for_graph(self, changes, graph, migration_name=None):</font>
<font color="black">1063.         &quot;&quot;&quot;</font>
<font color="black">1064.         Takes in a result from changes() and a MigrationGraph,</font>
<font color="black">1065.         and fixes the names and dependencies of the changes so they</font>
<font color="black">1066.         extend the graph from the leaf nodes for each app.</font>
<font color="black">1067.         &quot;&quot;&quot;</font>
<font color="red">1068.         leaves = graph.leaf_nodes()</font>
<font color="red">1069.         name_map = {}</font>
<font color="red">1070.         for app_label, migrations in list(changes.items()):</font>
<font color="red">1071.             if not migrations:</font>
<font color="red">1072.                 continue</font>
<font color="black">1073.             # Find the app label's current leaf node</font>
<font color="red">1074.             app_leaf = None</font>
<font color="red">1075.             for leaf in leaves:</font>
<font color="red">1076.                 if leaf[0] == app_label:</font>
<font color="red">1077.                     app_leaf = leaf</font>
<font color="red">1078.                     break</font>
<font color="black">1079.             # Do they want an initial migration for this app?</font>
<font color="red">1080.             if app_leaf is None and not self.questioner.ask_initial(app_label):</font>
<font color="black">1081.                 # They don't.</font>
<font color="red">1082.                 for migration in migrations:</font>
<font color="red">1083.                     name_map[(app_label, migration.name)] = (app_label, &quot;__first__&quot;)</font>
<font color="red">1084.                 del changes[app_label]</font>
<font color="red">1085.                 continue</font>
<font color="black">1086.             # Work out the next number in the sequence</font>
<font color="red">1087.             if app_leaf is None:</font>
<font color="red">1088.                 next_number = 1</font>
<font color="black">1089.             else:</font>
<font color="red">1090.                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1</font>
<font color="black">1091.             # Name each migration</font>
<font color="red">1092.             for i, migration in enumerate(migrations):</font>
<font color="red">1093.                 if i == 0 and app_leaf:</font>
<font color="red">1094.                     migration.dependencies.append(app_leaf)</font>
<font color="red">1095.                 if i == 0 and not app_leaf:</font>
<font color="red">1096.                     new_name = &quot;0001_%s&quot; % migration_name if migration_name else &quot;0001_initial&quot;</font>
<font color="black">1097.                 else:</font>
<font color="red">1098.                     new_name = &quot;%04i_%s&quot; % (</font>
<font color="red">1099.                         next_number,</font>
<font color="red">1100.                         migration_name or self.suggest_name(migration.operations)[:100],</font>
<font color="black">1101.                     )</font>
<font color="red">1102.                 name_map[(app_label, migration.name)] = (app_label, new_name)</font>
<font color="red">1103.                 next_number += 1</font>
<font color="red">1104.                 migration.name = new_name</font>
<font color="black">1105.         # Now fix dependencies</font>
<font color="red">1106.         for app_label, migrations in changes.items():</font>
<font color="red">1107.             for migration in migrations:</font>
<font color="red">1108.                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]</font>
<font color="red">1109.         return changes</font>
<font color="black">1110. </font>
<font color="green">1111.     def _trim_to_apps(self, changes, app_labels):</font>
<font color="black">1112.         &quot;&quot;&quot;</font>
<font color="black">1113.         Takes changes from arrange_for_graph and set of app labels and</font>
<font color="black">1114.         returns a modified set of changes which trims out as many migrations</font>
<font color="black">1115.         that are not in app_labels as possible.</font>
<font color="black">1116.         Note that some other migrations may still be present, as they may be</font>
<font color="black">1117.         required dependencies.</font>
<font color="black">1118.         &quot;&quot;&quot;</font>
<font color="black">1119.         # Gather other app dependencies in a first pass</font>
<font color="red">1120.         app_dependencies = {}</font>
<font color="red">1121.         for app_label, migrations in changes.items():</font>
<font color="red">1122.             for migration in migrations:</font>
<font color="red">1123.                 for dep_app_label, name in migration.dependencies:</font>
<font color="red">1124.                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)</font>
<font color="red">1125.         required_apps = set(app_labels)</font>
<font color="black">1126.         # Keep resolving till there's no change</font>
<font color="red">1127.         old_required_apps = None</font>
<font color="red">1128.         while old_required_apps != required_apps:</font>
<font color="red">1129.             old_required_apps = set(required_apps)</font>
<font color="red">1130.             for app_label in list(required_apps):</font>
<font color="red">1131.                 required_apps.update(app_dependencies.get(app_label, set()))</font>
<font color="black">1132.         # Remove all migrations that aren't needed</font>
<font color="red">1133.         for app_label in list(changes.keys()):</font>
<font color="red">1134.             if app_label not in required_apps:</font>
<font color="red">1135.                 del changes[app_label]</font>
<font color="red">1136.         return changes</font>
<font color="black">1137. </font>
<font color="green">1138.     @classmethod</font>
<font color="black">1139.     def suggest_name(cls, ops):</font>
<font color="black">1140.         &quot;&quot;&quot;</font>
<font color="black">1141.         Given a set of operations, suggests a name for the migration</font>
<font color="black">1142.         they might represent. Names are not guaranteed to be unique,</font>
<font color="black">1143.         but we put some effort in to the fallback name to avoid VCS conflicts</font>
<font color="black">1144.         if we can.</font>
<font color="black">1145.         &quot;&quot;&quot;</font>
<font color="red">1146.         if len(ops) == 1:</font>
<font color="red">1147.             if isinstance(ops[0], operations.CreateModel):</font>
<font color="red">1148.                 return ops[0].name_lower</font>
<font color="red">1149.             elif isinstance(ops[0], operations.DeleteModel):</font>
<font color="red">1150.                 return &quot;delete_%s&quot; % ops[0].name_lower</font>
<font color="red">1151.             elif isinstance(ops[0], operations.AddField):</font>
<font color="red">1152.                 return &quot;%s_%s&quot; % (ops[0].model_name_lower, ops[0].name_lower)</font>
<font color="red">1153.             elif isinstance(ops[0], operations.RemoveField):</font>
<font color="red">1154.                 return &quot;remove_%s_%s&quot; % (ops[0].model_name_lower, ops[0].name_lower)</font>
<font color="red">1155.         elif len(ops) &gt; 1:</font>
<font color="red">1156.             if all(isinstance(o, operations.CreateModel) for o in ops):</font>
<font color="red">1157.                 return &quot;_&quot;.join(sorted(o.name_lower for o in ops))</font>
<font color="red">1158.         return &quot;auto_%s&quot; % datetime.datetime.now().strftime(&quot;%Y%m%d_%H%M&quot;)</font>
<font color="black">1159. </font>
<font color="green">1160.     @classmethod</font>
<font color="black">1161.     def parse_number(cls, name):</font>
<font color="black">1162.         &quot;&quot;&quot;</font>
<font color="black">1163.         Given a migration name, tries to extract a number from the</font>
<font color="black">1164.         beginning of it. If no number found, returns None.</font>
<font color="black">1165.         &quot;&quot;&quot;</font>
<font color="red">1166.         match = re.match(r'^\d+', name)</font>
<font color="red">1167.         if match:</font>
<font color="red">1168.             return int(match.group())</font>
<font color="red">1169.         return None</font>
</pre>

