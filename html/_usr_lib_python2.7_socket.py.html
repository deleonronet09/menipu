source file: <b>/usr/lib/python2.7/socket.py</b><br>


file stats: <b>367 lines, 81 executed: 22.1% covered</b>
<pre>
<font color="black">   1. # Wrapper module for _socket, providing some additional facilities</font>
<font color="black">   2. # implemented in Python.</font>
<font color="black">   3. </font>
<font color="black">   4. &quot;&quot;&quot;\</font>
<font color="black">   5. This module provides socket operations and some related functions.</font>
<font color="black">   6. On Unix, it supports IP (Internet Protocol) and Unix domain sockets.</font>
<font color="black">   7. On other systems, it only supports IP. Functions specific for a</font>
<font color="black">   8. socket are available as methods of the socket object.</font>
<font color="black">   9. </font>
<font color="black">  10. Functions:</font>
<font color="black">  11. </font>
<font color="black">  12. socket() -- create a new socket object</font>
<font color="black">  13. socketpair() -- create a pair of new socket objects [*]</font>
<font color="black">  14. fromfd() -- create a socket object from an open file descriptor [*]</font>
<font color="black">  15. gethostname() -- return the current hostname</font>
<font color="black">  16. gethostbyname() -- map a hostname to its IP number</font>
<font color="black">  17. gethostbyaddr() -- map an IP number or hostname to DNS info</font>
<font color="black">  18. getservbyname() -- map a service name and a protocol name to a port number</font>
<font color="black">  19. getprotobyname() -- map a protocol name (e.g. 'tcp') to a number</font>
<font color="black">  20. ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order</font>
<font color="black">  21. htons(), htonl() -- convert 16, 32 bit int from host to network byte order</font>
<font color="black">  22. inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format</font>
<font color="black">  23. inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)</font>
<font color="black">  24. ssl() -- secure socket layer support (only available if configured)</font>
<font color="black">  25. socket.getdefaulttimeout() -- get the default timeout value</font>
<font color="black">  26. socket.setdefaulttimeout() -- set the default timeout value</font>
<font color="black">  27. create_connection() -- connects to an address, with an optional timeout and</font>
<font color="black">  28.                        optional source address.</font>
<font color="black">  29. </font>
<font color="black">  30.  [*] not available on all platforms!</font>
<font color="black">  31. </font>
<font color="black">  32. Special objects:</font>
<font color="black">  33. </font>
<font color="black">  34. SocketType -- type object for socket objects</font>
<font color="black">  35. error -- exception raised for I/O errors</font>
<font color="black">  36. has_ipv6 -- boolean value indicating if IPv6 is supported</font>
<font color="black">  37. </font>
<font color="black">  38. Integer constants:</font>
<font color="black">  39. </font>
<font color="black">  40. AF_INET, AF_UNIX -- socket domains (first argument to socket() call)</font>
<font color="black">  41. SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)</font>
<font color="black">  42. </font>
<font color="black">  43. Many other constants may be defined; these may be used in calls to</font>
<font color="black">  44. the setsockopt() and getsockopt() methods.</font>
<font color="green">  45. &quot;&quot;&quot;</font>
<font color="black">  46. </font>
<font color="green">  47. import _socket</font>
<font color="green">  48. from _socket import *</font>
<font color="green">  49. from functools import partial</font>
<font color="green">  50. from types import MethodType</font>
<font color="black">  51. </font>
<font color="green">  52. try:</font>
<font color="green">  53.     import _ssl</font>
<font color="red">  54. except ImportError:</font>
<font color="black">  55.     # no SSL support</font>
<font color="red">  56.     pass</font>
<font color="black">  57. else:</font>
<font color="green">  58.     def ssl(sock, keyfile=None, certfile=None):</font>
<font color="black">  59.         # we do an internal import here because the ssl</font>
<font color="black">  60.         # module imports the socket module</font>
<font color="red">  61.         import ssl as _realssl</font>
<font color="red">  62.         warnings.warn(&quot;socket.ssl() is deprecated.  Use ssl.wrap_socket() instead.&quot;,</font>
<font color="red">  63.                       DeprecationWarning, stacklevel=2)</font>
<font color="red">  64.         return _realssl.sslwrap_simple(sock, keyfile, certfile)</font>
<font color="black">  65. </font>
<font color="black">  66.     # we need to import the same constants we used to...</font>
<font color="green">  67.     from _ssl import SSLError as sslerror</font>
<font color="green">  68.     from _ssl import \</font>
<font color="black">  69.          RAND_add, \</font>
<font color="black">  70.          RAND_egd, \</font>
<font color="black">  71.          RAND_status, \</font>
<font color="black">  72.          SSL_ERROR_ZERO_RETURN, \</font>
<font color="black">  73.          SSL_ERROR_WANT_READ, \</font>
<font color="black">  74.          SSL_ERROR_WANT_WRITE, \</font>
<font color="black">  75.          SSL_ERROR_WANT_X509_LOOKUP, \</font>
<font color="black">  76.          SSL_ERROR_SYSCALL, \</font>
<font color="black">  77.          SSL_ERROR_SSL, \</font>
<font color="black">  78.          SSL_ERROR_WANT_CONNECT, \</font>
<font color="black">  79.          SSL_ERROR_EOF, \</font>
<font color="black">  80.          SSL_ERROR_INVALID_ERROR_CODE</font>
<font color="black">  81. </font>
<font color="green">  82. import os, sys, warnings</font>
<font color="black">  83. </font>
<font color="green">  84. try:</font>
<font color="green">  85.     from cStringIO import StringIO</font>
<font color="red">  86. except ImportError:</font>
<font color="red">  87.     from StringIO import StringIO</font>
<font color="black">  88. </font>
<font color="green">  89. try:</font>
<font color="green">  90.     import errno</font>
<font color="red">  91. except ImportError:</font>
<font color="red">  92.     errno = None</font>
<font color="green">  93. EBADF = getattr(errno, 'EBADF', 9)</font>
<font color="green">  94. EINTR = getattr(errno, 'EINTR', 4)</font>
<font color="black">  95. </font>
<font color="green">  96. __all__ = [&quot;getfqdn&quot;, &quot;create_connection&quot;]</font>
<font color="green">  97. __all__.extend(os._get_exports_list(_socket))</font>
<font color="black">  98. </font>
<font color="black">  99. </font>
<font color="green"> 100. _realsocket = socket</font>
<font color="black"> 101. </font>
<font color="black"> 102. # WSA error codes</font>
<font color="green"> 103. if sys.platform.lower().startswith(&quot;win&quot;):</font>
<font color="red"> 104.     errorTab = {}</font>
<font color="red"> 105.     errorTab[10004] = &quot;The operation was interrupted.&quot;</font>
<font color="red"> 106.     errorTab[10009] = &quot;A bad file handle was passed.&quot;</font>
<font color="red"> 107.     errorTab[10013] = &quot;Permission denied.&quot;</font>
<font color="red"> 108.     errorTab[10014] = &quot;A fault occurred on the network??&quot; # WSAEFAULT</font>
<font color="red"> 109.     errorTab[10022] = &quot;An invalid operation was attempted.&quot;</font>
<font color="red"> 110.     errorTab[10035] = &quot;The socket operation would block&quot;</font>
<font color="red"> 111.     errorTab[10036] = &quot;A blocking operation is already in progress.&quot;</font>
<font color="red"> 112.     errorTab[10048] = &quot;The network address is in use.&quot;</font>
<font color="red"> 113.     errorTab[10054] = &quot;The connection has been reset.&quot;</font>
<font color="red"> 114.     errorTab[10058] = &quot;The network has been shut down.&quot;</font>
<font color="red"> 115.     errorTab[10060] = &quot;The operation timed out.&quot;</font>
<font color="red"> 116.     errorTab[10061] = &quot;Connection refused.&quot;</font>
<font color="red"> 117.     errorTab[10063] = &quot;The name is too long.&quot;</font>
<font color="red"> 118.     errorTab[10064] = &quot;The host is down.&quot;</font>
<font color="red"> 119.     errorTab[10065] = &quot;The host is unreachable.&quot;</font>
<font color="red"> 120.     __all__.append(&quot;errorTab&quot;)</font>
<font color="black"> 121. </font>
<font color="black"> 122. </font>
<font color="black"> 123. </font>
<font color="green"> 124. def getfqdn(name=''):</font>
<font color="black"> 125.     &quot;&quot;&quot;Get fully qualified domain name from name.</font>
<font color="black"> 126. </font>
<font color="black"> 127.     An empty argument is interpreted as meaning the local host.</font>
<font color="black"> 128. </font>
<font color="black"> 129.     First the hostname returned by gethostbyaddr() is checked, then</font>
<font color="black"> 130.     possibly existing aliases. In case no FQDN is available, hostname</font>
<font color="black"> 131.     from gethostname() is returned.</font>
<font color="black"> 132.     &quot;&quot;&quot;</font>
<font color="red"> 133.     name = name.strip()</font>
<font color="red"> 134.     if not name or name == '0.0.0.0':</font>
<font color="red"> 135.         name = gethostname()</font>
<font color="red"> 136.     try:</font>
<font color="red"> 137.         hostname, aliases, ipaddrs = gethostbyaddr(name)</font>
<font color="red"> 138.     except error:</font>
<font color="red"> 139.         pass</font>
<font color="black"> 140.     else:</font>
<font color="red"> 141.         aliases.insert(0, hostname)</font>
<font color="red"> 142.         for name in aliases:</font>
<font color="red"> 143.             if '.' in name:</font>
<font color="red"> 144.                 break</font>
<font color="black"> 145.         else:</font>
<font color="red"> 146.             name = hostname</font>
<font color="red"> 147.     return name</font>
<font color="black"> 148. </font>
<font color="black"> 149. </font>
<font color="black"> 150. _socketmethods = (</font>
<font color="green"> 151.     'bind', 'connect', 'connect_ex', 'fileno', 'listen',</font>
<font color="green"> 152.     'getpeername', 'getsockname', 'getsockopt', 'setsockopt',</font>
<font color="green"> 153.     'sendall', 'setblocking',</font>
<font color="green"> 154.     'settimeout', 'gettimeout', 'shutdown')</font>
<font color="black"> 155. </font>
<font color="green"> 156. if os.name == &quot;nt&quot;:</font>
<font color="red"> 157.     _socketmethods = _socketmethods + ('ioctl',)</font>
<font color="black"> 158. </font>
<font color="green"> 159. if sys.platform == &quot;riscos&quot;:</font>
<font color="red"> 160.     _socketmethods = _socketmethods + ('sleeptaskw',)</font>
<font color="black"> 161. </font>
<font color="black"> 162. # All the method names that must be delegated to either the real socket</font>
<font color="black"> 163. # object or the _closedsocket object.</font>
<font color="green"> 164. _delegate_methods = (&quot;recv&quot;, &quot;recvfrom&quot;, &quot;recv_into&quot;, &quot;recvfrom_into&quot;,</font>
<font color="green"> 165.                      &quot;send&quot;, &quot;sendto&quot;)</font>
<font color="black"> 166. </font>
<font color="green"> 167. class _closedsocket(object):</font>
<font color="green"> 168.     __slots__ = []</font>
<font color="green"> 169.     def _dummy(*args):</font>
<font color="red"> 170.         raise error(EBADF, 'Bad file descriptor')</font>
<font color="black"> 171.     # All _delegate_methods must also be initialized here.</font>
<font color="green"> 172.     send = recv = recv_into = sendto = recvfrom = recvfrom_into = _dummy</font>
<font color="green"> 173.     __getattr__ = _dummy</font>
<font color="black"> 174. </font>
<font color="black"> 175. # Wrapper around platform socket objects. This implements</font>
<font color="black"> 176. # a platform-independent dup() functionality. The</font>
<font color="black"> 177. # implementation currently relies on reference counting</font>
<font color="black"> 178. # to close the underlying socket object.</font>
<font color="green"> 179. class _socketobject(object):</font>
<font color="black"> 180. </font>
<font color="green"> 181.     __doc__ = _realsocket.__doc__</font>
<font color="black"> 182. </font>
<font color="green"> 183.     __slots__ = [&quot;_sock&quot;, &quot;__weakref__&quot;] + list(_delegate_methods)</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, _sock=None):</font>
<font color="red"> 186.         if _sock is None:</font>
<font color="red"> 187.             _sock = _realsocket(family, type, proto)</font>
<font color="red"> 188.         self._sock = _sock</font>
<font color="red"> 189.         for method in _delegate_methods:</font>
<font color="red"> 190.             setattr(self, method, getattr(_sock, method))</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def close(self, _closedsocket=_closedsocket,</font>
<font color="green"> 193.               _delegate_methods=_delegate_methods, setattr=setattr):</font>
<font color="black"> 194.         # This function should not reference any globals. See issue #808164.</font>
<font color="red"> 195.         self._sock = _closedsocket()</font>
<font color="red"> 196.         dummy = self._sock._dummy</font>
<font color="red"> 197.         for method in _delegate_methods:</font>
<font color="red"> 198.             setattr(self, method, dummy)</font>
<font color="green"> 199.     close.__doc__ = _realsocket.close.__doc__</font>
<font color="black"> 200. </font>
<font color="green"> 201.     def accept(self):</font>
<font color="red"> 202.         sock, addr = self._sock.accept()</font>
<font color="red"> 203.         return _socketobject(_sock=sock), addr</font>
<font color="green"> 204.     accept.__doc__ = _realsocket.accept.__doc__</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def dup(self):</font>
<font color="black"> 207.         &quot;&quot;&quot;dup() -&gt; socket object</font>
<font color="black"> 208. </font>
<font color="black"> 209.         Return a new socket object connected to the same system resource.&quot;&quot;&quot;</font>
<font color="red"> 210.         return _socketobject(_sock=self._sock)</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def makefile(self, mode='r', bufsize=-1):</font>
<font color="black"> 213.         &quot;&quot;&quot;makefile([mode[, bufsize]]) -&gt; file object</font>
<font color="black"> 214. </font>
<font color="black"> 215.         Return a regular file object corresponding to the socket.  The mode</font>
<font color="black"> 216.         and bufsize arguments are as for the built-in open() function.&quot;&quot;&quot;</font>
<font color="red"> 217.         return _fileobject(self._sock, mode, bufsize)</font>
<font color="black"> 218. </font>
<font color="green"> 219.     family = property(lambda self: self._sock.family, doc=&quot;the socket family&quot;)</font>
<font color="green"> 220.     type = property(lambda self: self._sock.type, doc=&quot;the socket type&quot;)</font>
<font color="green"> 221.     proto = property(lambda self: self._sock.proto, doc=&quot;the socket protocol&quot;)</font>
<font color="black"> 222. </font>
<font color="green"> 223. def meth(name,self,*args):</font>
<font color="red"> 224.     return getattr(self._sock,name)(*args)</font>
<font color="black"> 225. </font>
<font color="green"> 226. for _m in _socketmethods:</font>
<font color="green"> 227.     p = partial(meth,_m)</font>
<font color="green"> 228.     p.__name__ = _m</font>
<font color="green"> 229.     p.__doc__ = getattr(_realsocket,_m).__doc__</font>
<font color="green"> 230.     m = MethodType(p,None,_socketobject)</font>
<font color="green"> 231.     setattr(_socketobject,_m,m)</font>
<font color="black"> 232. </font>
<font color="green"> 233. socket = SocketType = _socketobject</font>
<font color="black"> 234. </font>
<font color="green"> 235. class _fileobject(object):</font>
<font color="green"> 236.     &quot;&quot;&quot;Faux file object attached to a socket object.&quot;&quot;&quot;</font>
<font color="black"> 237. </font>
<font color="green"> 238.     default_bufsize = 8192</font>
<font color="green"> 239.     name = &quot;&lt;socket&gt;&quot;</font>
<font color="black"> 240. </font>
<font color="green"> 241.     __slots__ = [&quot;mode&quot;, &quot;bufsize&quot;, &quot;softspace&quot;,</font>
<font color="black"> 242.                  # &quot;closed&quot; is a property, see below</font>
<font color="green"> 243.                  &quot;_sock&quot;, &quot;_rbufsize&quot;, &quot;_wbufsize&quot;, &quot;_rbuf&quot;, &quot;_wbuf&quot;, &quot;_wbuf_len&quot;,</font>
<font color="green"> 244.                  &quot;_close&quot;]</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def __init__(self, sock, mode='rb', bufsize=-1, close=False):</font>
<font color="red"> 247.         self._sock = sock</font>
<font color="red"> 248.         self.mode = mode # Not actually used in this version</font>
<font color="red"> 249.         if bufsize &lt; 0:</font>
<font color="red"> 250.             bufsize = self.default_bufsize</font>
<font color="red"> 251.         self.bufsize = bufsize</font>
<font color="red"> 252.         self.softspace = False</font>
<font color="black"> 253.         # _rbufsize is the suggested recv buffer size.  It is *strictly*</font>
<font color="black"> 254.         # obeyed within readline() for recv calls.  If it is larger than</font>
<font color="black"> 255.         # default_bufsize it will be used for recv calls within read().</font>
<font color="red"> 256.         if bufsize == 0:</font>
<font color="red"> 257.             self._rbufsize = 1</font>
<font color="red"> 258.         elif bufsize == 1:</font>
<font color="red"> 259.             self._rbufsize = self.default_bufsize</font>
<font color="black"> 260.         else:</font>
<font color="red"> 261.             self._rbufsize = bufsize</font>
<font color="red"> 262.         self._wbufsize = bufsize</font>
<font color="black"> 263.         # We use StringIO for the read buffer to avoid holding a list</font>
<font color="black"> 264.         # of variously sized string objects which have been known to</font>
<font color="black"> 265.         # fragment the heap due to how they are malloc()ed and often</font>
<font color="black"> 266.         # realloc()ed down much smaller than their original allocation.</font>
<font color="red"> 267.         self._rbuf = StringIO()</font>
<font color="red"> 268.         self._wbuf = [] # A list of strings</font>
<font color="red"> 269.         self._wbuf_len = 0</font>
<font color="red"> 270.         self._close = close</font>
<font color="black"> 271. </font>
<font color="green"> 272.     def _getclosed(self):</font>
<font color="red"> 273.         return self._sock is None</font>
<font color="green"> 274.     closed = property(_getclosed, doc=&quot;True if the file is closed&quot;)</font>
<font color="black"> 275. </font>
<font color="green"> 276.     def close(self):</font>
<font color="red"> 277.         try:</font>
<font color="red"> 278.             if self._sock:</font>
<font color="red"> 279.                 self.flush()</font>
<font color="black"> 280.         finally:</font>
<font color="red"> 281.             if self._close:</font>
<font color="red"> 282.                 self._sock.close()</font>
<font color="red"> 283.             self._sock = None</font>
<font color="black"> 284. </font>
<font color="green"> 285.     def __del__(self):</font>
<font color="red"> 286.         try:</font>
<font color="red"> 287.             self.close()</font>
<font color="red"> 288.         except:</font>
<font color="black"> 289.             # close() may fail if __init__ didn't complete</font>
<font color="red"> 290.             pass</font>
<font color="black"> 291. </font>
<font color="green"> 292.     def flush(self):</font>
<font color="red"> 293.         if self._wbuf:</font>
<font color="red"> 294.             data = &quot;&quot;.join(self._wbuf)</font>
<font color="red"> 295.             self._wbuf = []</font>
<font color="red"> 296.             self._wbuf_len = 0</font>
<font color="red"> 297.             buffer_size = max(self._rbufsize, self.default_bufsize)</font>
<font color="red"> 298.             data_size = len(data)</font>
<font color="red"> 299.             write_offset = 0</font>
<font color="red"> 300.             view = memoryview(data)</font>
<font color="red"> 301.             try:</font>
<font color="red"> 302.                 while write_offset &lt; data_size:</font>
<font color="red"> 303.                     self._sock.sendall(view[write_offset:write_offset+buffer_size])</font>
<font color="red"> 304.                     write_offset += buffer_size</font>
<font color="black"> 305.             finally:</font>
<font color="red"> 306.                 if write_offset &lt; data_size:</font>
<font color="red"> 307.                     remainder = data[write_offset:]</font>
<font color="red"> 308.                     del view, data  # explicit free</font>
<font color="red"> 309.                     self._wbuf.append(remainder)</font>
<font color="red"> 310.                     self._wbuf_len = len(remainder)</font>
<font color="black"> 311. </font>
<font color="green"> 312.     def fileno(self):</font>
<font color="red"> 313.         return self._sock.fileno()</font>
<font color="black"> 314. </font>
<font color="green"> 315.     def write(self, data):</font>
<font color="red"> 316.         data = str(data) # XXX Should really reject non-string non-buffers</font>
<font color="red"> 317.         if not data:</font>
<font color="red"> 318.             return</font>
<font color="red"> 319.         self._wbuf.append(data)</font>
<font color="red"> 320.         self._wbuf_len += len(data)</font>
<font color="red"> 321.         if (self._wbufsize == 0 or</font>
<font color="red"> 322.             (self._wbufsize == 1 and '\n' in data) or</font>
<font color="red"> 323.             (self._wbufsize &gt; 1 and self._wbuf_len &gt;= self._wbufsize)):</font>
<font color="red"> 324.             self.flush()</font>
<font color="black"> 325. </font>
<font color="green"> 326.     def writelines(self, list):</font>
<font color="black"> 327.         # XXX We could do better here for very long lists</font>
<font color="black"> 328.         # XXX Should really reject non-string non-buffers</font>
<font color="red"> 329.         lines = filter(None, map(str, list))</font>
<font color="red"> 330.         self._wbuf_len += sum(map(len, lines))</font>
<font color="red"> 331.         self._wbuf.extend(lines)</font>
<font color="red"> 332.         if (self._wbufsize &lt;= 1 or</font>
<font color="red"> 333.             self._wbuf_len &gt;= self._wbufsize):</font>
<font color="red"> 334.             self.flush()</font>
<font color="black"> 335. </font>
<font color="green"> 336.     def read(self, size=-1):</font>
<font color="black"> 337.         # Use max, disallow tiny reads in a loop as they are very inefficient.</font>
<font color="black"> 338.         # We never leave read() with any leftover data from a new recv() call</font>
<font color="black"> 339.         # in our internal buffer.</font>
<font color="red"> 340.         rbufsize = max(self._rbufsize, self.default_bufsize)</font>
<font color="black"> 341.         # Our use of StringIO rather than lists of string objects returned by</font>
<font color="black"> 342.         # recv() minimizes memory usage and fragmentation that occurs when</font>
<font color="black"> 343.         # rbufsize is large compared to the typical return value of recv().</font>
<font color="red"> 344.         buf = self._rbuf</font>
<font color="red"> 345.         buf.seek(0, 2)  # seek end</font>
<font color="red"> 346.         if size &lt; 0:</font>
<font color="black"> 347.             # Read until EOF</font>
<font color="red"> 348.             self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.</font>
<font color="red"> 349.             while True:</font>
<font color="red"> 350.                 try:</font>
<font color="red"> 351.                     data = self._sock.recv(rbufsize)</font>
<font color="red"> 352.                 except error, e:</font>
<font color="red"> 353.                     if e.args[0] == EINTR:</font>
<font color="red"> 354.                         continue</font>
<font color="red"> 355.                     raise</font>
<font color="red"> 356.                 if not data:</font>
<font color="red"> 357.                     break</font>
<font color="red"> 358.                 buf.write(data)</font>
<font color="red"> 359.             return buf.getvalue()</font>
<font color="black"> 360.         else:</font>
<font color="black"> 361.             # Read until size bytes or EOF seen, whichever comes first</font>
<font color="red"> 362.             buf_len = buf.tell()</font>
<font color="red"> 363.             if buf_len &gt;= size:</font>
<font color="black"> 364.                 # Already have size bytes in our buffer?  Extract and return.</font>
<font color="red"> 365.                 buf.seek(0)</font>
<font color="red"> 366.                 rv = buf.read(size)</font>
<font color="red"> 367.                 self._rbuf = StringIO()</font>
<font color="red"> 368.                 self._rbuf.write(buf.read())</font>
<font color="red"> 369.                 return rv</font>
<font color="black"> 370. </font>
<font color="red"> 371.             self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.</font>
<font color="red"> 372.             while True:</font>
<font color="red"> 373.                 left = size - buf_len</font>
<font color="black"> 374.                 # recv() will malloc the amount of memory given as its</font>
<font color="black"> 375.                 # parameter even though it often returns much less data</font>
<font color="black"> 376.                 # than that.  The returned data string is short lived</font>
<font color="black"> 377.                 # as we copy it into a StringIO and free it.  This avoids</font>
<font color="black"> 378.                 # fragmentation issues on many platforms.</font>
<font color="red"> 379.                 try:</font>
<font color="red"> 380.                     data = self._sock.recv(left)</font>
<font color="red"> 381.                 except error, e:</font>
<font color="red"> 382.                     if e.args[0] == EINTR:</font>
<font color="red"> 383.                         continue</font>
<font color="red"> 384.                     raise</font>
<font color="red"> 385.                 if not data:</font>
<font color="red"> 386.                     break</font>
<font color="red"> 387.                 n = len(data)</font>
<font color="red"> 388.                 if n == size and not buf_len:</font>
<font color="black"> 389.                     # Shortcut.  Avoid buffer data copies when:</font>
<font color="black"> 390.                     # - We have no data in our buffer.</font>
<font color="black"> 391.                     # AND</font>
<font color="black"> 392.                     # - Our call to recv returned exactly the</font>
<font color="black"> 393.                     #   number of bytes we were asked to read.</font>
<font color="red"> 394.                     return data</font>
<font color="red"> 395.                 if n == left:</font>
<font color="red"> 396.                     buf.write(data)</font>
<font color="red"> 397.                     del data  # explicit free</font>
<font color="red"> 398.                     break</font>
<font color="red"> 399.                 assert n &lt;= left, &quot;recv(%d) returned %d bytes&quot; % (left, n)</font>
<font color="red"> 400.                 buf.write(data)</font>
<font color="red"> 401.                 buf_len += n</font>
<font color="red"> 402.                 del data  # explicit free</font>
<font color="black"> 403.                 #assert buf_len == buf.tell()</font>
<font color="red"> 404.             return buf.getvalue()</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def readline(self, size=-1):</font>
<font color="red"> 407.         buf = self._rbuf</font>
<font color="red"> 408.         buf.seek(0, 2)  # seek end</font>
<font color="red"> 409.         if buf.tell() &gt; 0:</font>
<font color="black"> 410.             # check if we already have it in our buffer</font>
<font color="red"> 411.             buf.seek(0)</font>
<font color="red"> 412.             bline = buf.readline(size)</font>
<font color="red"> 413.             if bline.endswith('\n') or len(bline) == size:</font>
<font color="red"> 414.                 self._rbuf = StringIO()</font>
<font color="red"> 415.                 self._rbuf.write(buf.read())</font>
<font color="red"> 416.                 return bline</font>
<font color="red"> 417.             del bline</font>
<font color="red"> 418.         if size &lt; 0:</font>
<font color="black"> 419.             # Read until \n or EOF, whichever comes first</font>
<font color="red"> 420.             if self._rbufsize &lt;= 1:</font>
<font color="black"> 421.                 # Speed up unbuffered case</font>
<font color="red"> 422.                 buf.seek(0)</font>
<font color="red"> 423.                 buffers = [buf.read()]</font>
<font color="red"> 424.                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.</font>
<font color="red"> 425.                 data = None</font>
<font color="red"> 426.                 recv = self._sock.recv</font>
<font color="red"> 427.                 while True:</font>
<font color="red"> 428.                     try:</font>
<font color="red"> 429.                         while data != &quot;\n&quot;:</font>
<font color="red"> 430.                             data = recv(1)</font>
<font color="red"> 431.                             if not data:</font>
<font color="red"> 432.                                 break</font>
<font color="red"> 433.                             buffers.append(data)</font>
<font color="red"> 434.                     except error, e:</font>
<font color="black"> 435.                         # The try..except to catch EINTR was moved outside the</font>
<font color="black"> 436.                         # recv loop to avoid the per byte overhead.</font>
<font color="red"> 437.                         if e.args[0] == EINTR:</font>
<font color="red"> 438.                             continue</font>
<font color="red"> 439.                         raise</font>
<font color="red"> 440.                     break</font>
<font color="red"> 441.                 return &quot;&quot;.join(buffers)</font>
<font color="black"> 442. </font>
<font color="red"> 443.             buf.seek(0, 2)  # seek end</font>
<font color="red"> 444.             self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.</font>
<font color="red"> 445.             while True:</font>
<font color="red"> 446.                 try:</font>
<font color="red"> 447.                     data = self._sock.recv(self._rbufsize)</font>
<font color="red"> 448.                 except error, e:</font>
<font color="red"> 449.                     if e.args[0] == EINTR:</font>
<font color="red"> 450.                         continue</font>
<font color="red"> 451.                     raise</font>
<font color="red"> 452.                 if not data:</font>
<font color="red"> 453.                     break</font>
<font color="red"> 454.                 nl = data.find('\n')</font>
<font color="red"> 455.                 if nl &gt;= 0:</font>
<font color="red"> 456.                     nl += 1</font>
<font color="red"> 457.                     buf.write(data[:nl])</font>
<font color="red"> 458.                     self._rbuf.write(data[nl:])</font>
<font color="red"> 459.                     del data</font>
<font color="red"> 460.                     break</font>
<font color="red"> 461.                 buf.write(data)</font>
<font color="red"> 462.             return buf.getvalue()</font>
<font color="black"> 463.         else:</font>
<font color="black"> 464.             # Read until size bytes or \n or EOF seen, whichever comes first</font>
<font color="red"> 465.             buf.seek(0, 2)  # seek end</font>
<font color="red"> 466.             buf_len = buf.tell()</font>
<font color="red"> 467.             if buf_len &gt;= size:</font>
<font color="red"> 468.                 buf.seek(0)</font>
<font color="red"> 469.                 rv = buf.read(size)</font>
<font color="red"> 470.                 self._rbuf = StringIO()</font>
<font color="red"> 471.                 self._rbuf.write(buf.read())</font>
<font color="red"> 472.                 return rv</font>
<font color="red"> 473.             self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.</font>
<font color="red"> 474.             while True:</font>
<font color="red"> 475.                 try:</font>
<font color="red"> 476.                     data = self._sock.recv(self._rbufsize)</font>
<font color="red"> 477.                 except error, e:</font>
<font color="red"> 478.                     if e.args[0] == EINTR:</font>
<font color="red"> 479.                         continue</font>
<font color="red"> 480.                     raise</font>
<font color="red"> 481.                 if not data:</font>
<font color="red"> 482.                     break</font>
<font color="red"> 483.                 left = size - buf_len</font>
<font color="black"> 484.                 # did we just receive a newline?</font>
<font color="red"> 485.                 nl = data.find('\n', 0, left)</font>
<font color="red"> 486.                 if nl &gt;= 0:</font>
<font color="red"> 487.                     nl += 1</font>
<font color="black"> 488.                     # save the excess data to _rbuf</font>
<font color="red"> 489.                     self._rbuf.write(data[nl:])</font>
<font color="red"> 490.                     if buf_len:</font>
<font color="red"> 491.                         buf.write(data[:nl])</font>
<font color="red"> 492.                         break</font>
<font color="black"> 493.                     else:</font>
<font color="black"> 494.                         # Shortcut.  Avoid data copy through buf when returning</font>
<font color="black"> 495.                         # a substring of our first recv().</font>
<font color="red"> 496.                         return data[:nl]</font>
<font color="red"> 497.                 n = len(data)</font>
<font color="red"> 498.                 if n == size and not buf_len:</font>
<font color="black"> 499.                     # Shortcut.  Avoid data copy through buf when</font>
<font color="black"> 500.                     # returning exactly all of our first recv().</font>
<font color="red"> 501.                     return data</font>
<font color="red"> 502.                 if n &gt;= left:</font>
<font color="red"> 503.                     buf.write(data[:left])</font>
<font color="red"> 504.                     self._rbuf.write(data[left:])</font>
<font color="red"> 505.                     break</font>
<font color="red"> 506.                 buf.write(data)</font>
<font color="red"> 507.                 buf_len += n</font>
<font color="black"> 508.                 #assert buf_len == buf.tell()</font>
<font color="red"> 509.             return buf.getvalue()</font>
<font color="black"> 510. </font>
<font color="green"> 511.     def readlines(self, sizehint=0):</font>
<font color="red"> 512.         total = 0</font>
<font color="red"> 513.         list = []</font>
<font color="red"> 514.         while True:</font>
<font color="red"> 515.             line = self.readline()</font>
<font color="red"> 516.             if not line:</font>
<font color="red"> 517.                 break</font>
<font color="red"> 518.             list.append(line)</font>
<font color="red"> 519.             total += len(line)</font>
<font color="red"> 520.             if sizehint and total &gt;= sizehint:</font>
<font color="red"> 521.                 break</font>
<font color="red"> 522.         return list</font>
<font color="black"> 523. </font>
<font color="black"> 524.     # Iterator protocols</font>
<font color="black"> 525. </font>
<font color="green"> 526.     def __iter__(self):</font>
<font color="red"> 527.         return self</font>
<font color="black"> 528. </font>
<font color="green"> 529.     def next(self):</font>
<font color="red"> 530.         line = self.readline()</font>
<font color="red"> 531.         if not line:</font>
<font color="red"> 532.             raise StopIteration</font>
<font color="red"> 533.         return line</font>
<font color="black"> 534. </font>
<font color="green"> 535. _GLOBAL_DEFAULT_TIMEOUT = object()</font>
<font color="black"> 536. </font>
<font color="green"> 537. def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,</font>
<font color="green"> 538.                       source_address=None):</font>
<font color="black"> 539.     &quot;&quot;&quot;Connect to *address* and return the socket object.</font>
<font color="black"> 540. </font>
<font color="black"> 541.     Convenience function.  Connect to *address* (a 2-tuple ``(host,</font>
<font color="black"> 542.     port)``) and return the socket object.  Passing the optional</font>
<font color="black"> 543.     *timeout* parameter will set the timeout on the socket instance</font>
<font color="black"> 544.     before attempting to connect.  If no *timeout* is supplied, the</font>
<font color="black"> 545.     global default timeout setting returned by :func:`getdefaulttimeout`</font>
<font color="black"> 546.     is used.  If *source_address* is set it must be a tuple of (host, port)</font>
<font color="black"> 547.     for the socket to bind as a source address before making the connection.</font>
<font color="black"> 548.     An host of '' or port 0 tells the OS to use the default.</font>
<font color="black"> 549.     &quot;&quot;&quot;</font>
<font color="black"> 550. </font>
<font color="red"> 551.     host, port = address</font>
<font color="red"> 552.     err = None</font>
<font color="red"> 553.     for res in getaddrinfo(host, port, 0, SOCK_STREAM):</font>
<font color="red"> 554.         af, socktype, proto, canonname, sa = res</font>
<font color="red"> 555.         sock = None</font>
<font color="red"> 556.         try:</font>
<font color="red"> 557.             sock = socket(af, socktype, proto)</font>
<font color="red"> 558.             if timeout is not _GLOBAL_DEFAULT_TIMEOUT:</font>
<font color="red"> 559.                 sock.settimeout(timeout)</font>
<font color="red"> 560.             if source_address:</font>
<font color="red"> 561.                 sock.bind(source_address)</font>
<font color="red"> 562.             sock.connect(sa)</font>
<font color="red"> 563.             return sock</font>
<font color="black"> 564. </font>
<font color="red"> 565.         except error as _:</font>
<font color="red"> 566.             err = _</font>
<font color="red"> 567.             if sock is not None:</font>
<font color="red"> 568.                 sock.close()</font>
<font color="black"> 569. </font>
<font color="red"> 570.     if err is not None:</font>
<font color="red"> 571.         raise err</font>
<font color="black"> 572.     else:</font>
<font color="red"> 573.         raise error(&quot;getaddrinfo returns an empty list&quot;)</font>
</pre>

