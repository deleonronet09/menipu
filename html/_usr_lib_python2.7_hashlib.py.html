source file: <b>/usr/lib/python2.7/hashlib.py</b><br>


file stats: <b>58 lines, 21 executed: 36.2% covered</b>
<pre>
<font color="black">   1. # $Id$</font>
<font color="black">   2. #</font>
<font color="black">   3. #  Copyright (C) 2005   Gregory P. Smith (greg@krypto.org)</font>
<font color="black">   4. #  Licensed to PSF under a Contributor Agreement.</font>
<font color="black">   5. #</font>
<font color="black">   6. </font>
<font color="black">   7. __doc__ = &quot;&quot;&quot;hashlib module - A common interface to many hash functions.</font>
<font color="black">   8. </font>
<font color="black">   9. new(name, string='') - returns a new hash object implementing the</font>
<font color="black">  10.                        given hash function; initializing the hash</font>
<font color="black">  11.                        using the given string data.</font>
<font color="black">  12. </font>
<font color="black">  13. Named constructor functions are also available, these are much faster</font>
<font color="black">  14. than using new():</font>
<font color="black">  15. </font>
<font color="black">  16. md5(), sha1(), sha224(), sha256(), sha384(), and sha512()</font>
<font color="black">  17. </font>
<font color="black">  18. More algorithms may be available on your platform but the above are</font>
<font color="black">  19. guaranteed to exist.</font>
<font color="black">  20. </font>
<font color="black">  21. NOTE: If you want the adler32 or crc32 hash functions they are available in</font>
<font color="black">  22. the zlib module.</font>
<font color="black">  23. </font>
<font color="black">  24. Choose your hash function wisely.  Some have known collision weaknesses.</font>
<font color="black">  25. sha384 and sha512 will be slow on 32 bit platforms.</font>
<font color="black">  26. </font>
<font color="black">  27. Hash objects have these methods:</font>
<font color="black">  28.  - update(arg): Update the hash object with the string arg. Repeated calls</font>
<font color="black">  29.                 are equivalent to a single call with the concatenation of all</font>
<font color="black">  30.                 the arguments.</font>
<font color="black">  31.  - digest():    Return the digest of the strings passed to the update() method</font>
<font color="black">  32.                 so far. This may contain non-ASCII characters, including</font>
<font color="black">  33.                 NUL bytes.</font>
<font color="black">  34.  - hexdigest(): Like digest() except the digest is returned as a string of</font>
<font color="black">  35.                 double length, containing only hexadecimal digits.</font>
<font color="black">  36.  - copy():      Return a copy (clone) of the hash object. This can be used to</font>
<font color="black">  37.                 efficiently compute the digests of strings that share a common</font>
<font color="black">  38.                 initial substring.</font>
<font color="black">  39. </font>
<font color="black">  40. For example, to obtain the digest of the string 'Nobody inspects the</font>
<font color="black">  41. spammish repetition':</font>
<font color="black">  42. </font>
<font color="black">  43.     &gt;&gt;&gt; import hashlib</font>
<font color="black">  44.     &gt;&gt;&gt; m = hashlib.md5()</font>
<font color="black">  45.     &gt;&gt;&gt; m.update(&quot;Nobody inspects&quot;)</font>
<font color="black">  46.     &gt;&gt;&gt; m.update(&quot; the spammish repetition&quot;)</font>
<font color="black">  47.     &gt;&gt;&gt; m.digest()</font>
<font color="black">  48.     '\\xbbd\\x9c\\x83\\xdd\\x1e\\xa5\\xc9\\xd9\\xde\\xc9\\xa1\\x8d\\xf0\\xff\\xe9'</font>
<font color="black">  49. </font>
<font color="black">  50. More condensed:</font>
<font color="black">  51. </font>
<font color="black">  52.     &gt;&gt;&gt; hashlib.sha224(&quot;Nobody inspects the spammish repetition&quot;).hexdigest()</font>
<font color="black">  53.     'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'</font>
<font color="black">  54. </font>
<font color="green">  55. &quot;&quot;&quot;</font>
<font color="black">  56. </font>
<font color="black">  57. # This tuple and __get_builtin_constructor() must be modified if a new</font>
<font color="black">  58. # always available algorithm is added.</font>
<font color="green">  59. __always_supported = ('md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512')</font>
<font color="black">  60. </font>
<font color="green">  61. algorithms = __always_supported</font>
<font color="black">  62. </font>
<font color="green">  63. __all__ = __always_supported + ('new', 'algorithms')</font>
<font color="black">  64. </font>
<font color="black">  65. </font>
<font color="green">  66. def __get_builtin_constructor(name):</font>
<font color="red">  67.     try:</font>
<font color="red">  68.         if name in ('SHA1', 'sha1'):</font>
<font color="red">  69.             import _sha</font>
<font color="red">  70.             return _sha.new</font>
<font color="red">  71.         elif name in ('MD5', 'md5'):</font>
<font color="red">  72.             import _md5</font>
<font color="red">  73.             return _md5.new</font>
<font color="red">  74.         elif name in ('SHA256', 'sha256', 'SHA224', 'sha224'):</font>
<font color="red">  75.             import _sha256</font>
<font color="red">  76.             bs = name[3:]</font>
<font color="red">  77.             if bs == '256':</font>
<font color="red">  78.                 return _sha256.sha256</font>
<font color="red">  79.             elif bs == '224':</font>
<font color="red">  80.                 return _sha256.sha224</font>
<font color="red">  81.         elif name in ('SHA512', 'sha512', 'SHA384', 'sha384'):</font>
<font color="red">  82.             import _sha512</font>
<font color="red">  83.             bs = name[3:]</font>
<font color="red">  84.             if bs == '512':</font>
<font color="red">  85.                 return _sha512.sha512</font>
<font color="red">  86.             elif bs == '384':</font>
<font color="red">  87.                 return _sha512.sha384</font>
<font color="red">  88.     except ImportError:</font>
<font color="red">  89.         pass  # no extension module, this hash is unsupported.</font>
<font color="black">  90. </font>
<font color="red">  91.     raise ValueError('unsupported hash type ' + name)</font>
<font color="black">  92. </font>
<font color="black">  93. </font>
<font color="green">  94. def __get_openssl_constructor(name):</font>
<font color="green">  95.     try:</font>
<font color="green">  96.         f = getattr(_hashlib, 'openssl_' + name)</font>
<font color="black">  97.         # Allow the C module to raise ValueError.  The function will be</font>
<font color="black">  98.         # defined but the hash not actually available thanks to OpenSSL.</font>
<font color="green">  99.         f()</font>
<font color="black"> 100.         # Use the C function directly (very fast)</font>
<font color="green"> 101.         return f</font>
<font color="red"> 102.     except (AttributeError, ValueError):</font>
<font color="red"> 103.         return __get_builtin_constructor(name)</font>
<font color="black"> 104. </font>
<font color="black"> 105. </font>
<font color="green"> 106. def __py_new(name, string=''):</font>
<font color="black"> 107.     &quot;&quot;&quot;new(name, string='') - Return a new hashing object using the named algorithm;</font>
<font color="black"> 108.     optionally initialized with a string.</font>
<font color="black"> 109.     &quot;&quot;&quot;</font>
<font color="red"> 110.     return __get_builtin_constructor(name)(string)</font>
<font color="black"> 111. </font>
<font color="black"> 112. </font>
<font color="green"> 113. def __hash_new(name, string=''):</font>
<font color="black"> 114.     &quot;&quot;&quot;new(name, string='') - Return a new hashing object using the named algorithm;</font>
<font color="black"> 115.     optionally initialized with a string.</font>
<font color="black"> 116.     &quot;&quot;&quot;</font>
<font color="red"> 117.     try:</font>
<font color="red"> 118.         return _hashlib.new(name, string)</font>
<font color="red"> 119.     except ValueError:</font>
<font color="black"> 120.         # If the _hashlib module (OpenSSL) doesn't support the named</font>
<font color="black"> 121.         # hash, try using our builtin implementations.</font>
<font color="black"> 122.         # This allows for SHA224/256 and SHA384/512 support even though</font>
<font color="black"> 123.         # the OpenSSL library prior to 0.9.8 doesn't provide them.</font>
<font color="red"> 124.         return __get_builtin_constructor(name)(string)</font>
<font color="black"> 125. </font>
<font color="black"> 126. </font>
<font color="green"> 127. try:</font>
<font color="green"> 128.     import _hashlib</font>
<font color="green"> 129.     new = __hash_new</font>
<font color="green"> 130.     __get_hash = __get_openssl_constructor</font>
<font color="red"> 131. except ImportError:</font>
<font color="red"> 132.     new = __py_new</font>
<font color="red"> 133.     __get_hash = __get_builtin_constructor</font>
<font color="black"> 134. </font>
<font color="green"> 135. for __func_name in __always_supported:</font>
<font color="black"> 136.     # try them all, some may not work due to the OpenSSL</font>
<font color="black"> 137.     # version not supporting that algorithm.</font>
<font color="green"> 138.     try:</font>
<font color="green"> 139.         globals()[__func_name] = __get_hash(__func_name)</font>
<font color="red"> 140.     except ValueError:</font>
<font color="red"> 141.         import logging</font>
<font color="red"> 142.         logging.exception('code for hash %s was not found.', __func_name)</font>
<font color="black"> 143. </font>
<font color="black"> 144. # Cleanup locals()</font>
<font color="green"> 145. del __always_supported, __func_name, __get_hash</font>
<font color="green"> 146. del __py_new, __hash_new, __get_openssl_constructor</font>
</pre>

