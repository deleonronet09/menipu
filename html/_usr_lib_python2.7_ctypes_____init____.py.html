source file: <b>/usr/lib/python2.7/ctypes/__init__.py</b><br>


file stats: <b>351 lines, 201 executed: 57.3% covered</b>
<pre>
<font color="black">   1. ######################################################################</font>
<font color="black">   2. #  This file should be kept compatible with Python 2.3, see PEP 291. #</font>
<font color="black">   3. ######################################################################</font>
<font color="green">   4. &quot;&quot;&quot;create and manipulate C data types in Python&quot;&quot;&quot;</font>
<font color="black">   5. </font>
<font color="green">   6. import os as _os, sys as _sys</font>
<font color="black">   7. </font>
<font color="green">   8. __version__ = &quot;1.1.0&quot;</font>
<font color="black">   9. </font>
<font color="green">  10. from _ctypes import Union, Structure, Array</font>
<font color="green">  11. from _ctypes import _Pointer</font>
<font color="green">  12. from _ctypes import CFuncPtr as _CFuncPtr</font>
<font color="green">  13. from _ctypes import __version__ as _ctypes_version</font>
<font color="green">  14. from _ctypes import RTLD_LOCAL, RTLD_GLOBAL</font>
<font color="green">  15. from _ctypes import ArgumentError</font>
<font color="black">  16. </font>
<font color="green">  17. from struct import calcsize as _calcsize</font>
<font color="black">  18. </font>
<font color="green">  19. if __version__ != _ctypes_version:</font>
<font color="red">  20.     raise Exception(&quot;Version number mismatch&quot;, __version__, _ctypes_version)</font>
<font color="black">  21. </font>
<font color="green">  22. if _os.name in (&quot;nt&quot;, &quot;ce&quot;):</font>
<font color="red">  23.     from _ctypes import FormatError</font>
<font color="black">  24. </font>
<font color="green">  25. DEFAULT_MODE = RTLD_LOCAL</font>
<font color="green">  26. if _os.name == &quot;posix&quot; and _sys.platform == &quot;darwin&quot;:</font>
<font color="black">  27.     # On OS X 10.3, we use RTLD_GLOBAL as default mode</font>
<font color="black">  28.     # because RTLD_LOCAL does not work at least on some</font>
<font color="black">  29.     # libraries.  OS X 10.3 is Darwin 7, so we check for</font>
<font color="black">  30.     # that.</font>
<font color="black">  31. </font>
<font color="red">  32.     if int(_os.uname()[2].split('.')[0]) &lt; 8:</font>
<font color="red">  33.         DEFAULT_MODE = RTLD_GLOBAL</font>
<font color="black">  34. </font>
<font color="green">  35. from _ctypes import FUNCFLAG_CDECL as _FUNCFLAG_CDECL, \</font>
<font color="black">  36.      FUNCFLAG_PYTHONAPI as _FUNCFLAG_PYTHONAPI, \</font>
<font color="black">  37.      FUNCFLAG_USE_ERRNO as _FUNCFLAG_USE_ERRNO, \</font>
<font color="black">  38.      FUNCFLAG_USE_LASTERROR as _FUNCFLAG_USE_LASTERROR</font>
<font color="black">  39. </font>
<font color="black">  40. &quot;&quot;&quot;</font>
<font color="black">  41. WINOLEAPI -&gt; HRESULT</font>
<font color="black">  42. WINOLEAPI_(type)</font>
<font color="black">  43. </font>
<font color="black">  44. STDMETHODCALLTYPE</font>
<font color="black">  45. </font>
<font color="black">  46. STDMETHOD(name)</font>
<font color="black">  47. STDMETHOD_(type, name)</font>
<font color="black">  48. </font>
<font color="black">  49. STDAPICALLTYPE</font>
<font color="black">  50. &quot;&quot;&quot;</font>
<font color="black">  51. </font>
<font color="green">  52. def create_string_buffer(init, size=None):</font>
<font color="black">  53.     &quot;&quot;&quot;create_string_buffer(aString) -&gt; character array</font>
<font color="black">  54.     create_string_buffer(anInteger) -&gt; character array</font>
<font color="black">  55.     create_string_buffer(aString, anInteger) -&gt; character array</font>
<font color="black">  56.     &quot;&quot;&quot;</font>
<font color="red">  57.     if isinstance(init, (str, unicode)):</font>
<font color="red">  58.         if size is None:</font>
<font color="red">  59.             size = len(init)+1</font>
<font color="red">  60.         buftype = c_char * size</font>
<font color="red">  61.         buf = buftype()</font>
<font color="red">  62.         buf.value = init</font>
<font color="red">  63.         return buf</font>
<font color="red">  64.     elif isinstance(init, (int, long)):</font>
<font color="red">  65.         buftype = c_char * init</font>
<font color="red">  66.         buf = buftype()</font>
<font color="red">  67.         return buf</font>
<font color="red">  68.     raise TypeError(init)</font>
<font color="black">  69. </font>
<font color="green">  70. def c_buffer(init, size=None):</font>
<font color="black">  71. ##    &quot;deprecated, use create_string_buffer instead&quot;</font>
<font color="black">  72. ##    import warnings</font>
<font color="black">  73. ##    warnings.warn(&quot;c_buffer is deprecated, use create_string_buffer instead&quot;,</font>
<font color="black">  74. ##                  DeprecationWarning, stacklevel=2)</font>
<font color="red">  75.     return create_string_buffer(init, size)</font>
<font color="black">  76. </font>
<font color="green">  77. _c_functype_cache = {}</font>
<font color="green">  78. def CFUNCTYPE(restype, *argtypes, **kw):</font>
<font color="black">  79.     &quot;&quot;&quot;CFUNCTYPE(restype, *argtypes,</font>
<font color="black">  80.                  use_errno=False, use_last_error=False) -&gt; function prototype.</font>
<font color="black">  81. </font>
<font color="black">  82.     restype: the result type</font>
<font color="black">  83.     argtypes: a sequence specifying the argument types</font>
<font color="black">  84. </font>
<font color="black">  85.     The function prototype can be called in different ways to create a</font>
<font color="black">  86.     callable object:</font>
<font color="black">  87. </font>
<font color="black">  88.     prototype(integer address) -&gt; foreign function</font>
<font color="black">  89.     prototype(callable) -&gt; create and return a C callable function from callable</font>
<font color="black">  90.     prototype(integer index, method name[, paramflags]) -&gt; foreign function calling a COM method</font>
<font color="black">  91.     prototype((ordinal number, dll object)[, paramflags]) -&gt; foreign function exported by ordinal</font>
<font color="black">  92.     prototype((function name, dll object)[, paramflags]) -&gt; foreign function exported by name</font>
<font color="black">  93.     &quot;&quot;&quot;</font>
<font color="green">  94.     flags = _FUNCFLAG_CDECL</font>
<font color="green">  95.     if kw.pop(&quot;use_errno&quot;, False):</font>
<font color="red">  96.         flags |= _FUNCFLAG_USE_ERRNO</font>
<font color="green">  97.     if kw.pop(&quot;use_last_error&quot;, False):</font>
<font color="red">  98.         flags |= _FUNCFLAG_USE_LASTERROR</font>
<font color="green">  99.     if kw:</font>
<font color="red"> 100.         raise ValueError(&quot;unexpected keyword argument(s) %s&quot; % kw.keys())</font>
<font color="green"> 101.     try:</font>
<font color="green"> 102.         return _c_functype_cache[(restype, argtypes, flags)]</font>
<font color="green"> 103.     except KeyError:</font>
<font color="green"> 104.         class CFunctionType(_CFuncPtr):</font>
<font color="green"> 105.             _argtypes_ = argtypes</font>
<font color="green"> 106.             _restype_ = restype</font>
<font color="green"> 107.             _flags_ = flags</font>
<font color="green"> 108.         _c_functype_cache[(restype, argtypes, flags)] = CFunctionType</font>
<font color="green"> 109.         return CFunctionType</font>
<font color="black"> 110. </font>
<font color="green"> 111. if _os.name in (&quot;nt&quot;, &quot;ce&quot;):</font>
<font color="red"> 112.     from _ctypes import LoadLibrary as _dlopen</font>
<font color="red"> 113.     from _ctypes import FUNCFLAG_STDCALL as _FUNCFLAG_STDCALL</font>
<font color="red"> 114.     if _os.name == &quot;ce&quot;:</font>
<font color="black"> 115.         # 'ce' doesn't have the stdcall calling convention</font>
<font color="red"> 116.         _FUNCFLAG_STDCALL = _FUNCFLAG_CDECL</font>
<font color="black"> 117. </font>
<font color="red"> 118.     _win_functype_cache = {}</font>
<font color="red"> 119.     def WINFUNCTYPE(restype, *argtypes, **kw):</font>
<font color="black"> 120.         # docstring set later (very similar to CFUNCTYPE.__doc__)</font>
<font color="red"> 121.         flags = _FUNCFLAG_STDCALL</font>
<font color="red"> 122.         if kw.pop(&quot;use_errno&quot;, False):</font>
<font color="red"> 123.             flags |= _FUNCFLAG_USE_ERRNO</font>
<font color="red"> 124.         if kw.pop(&quot;use_last_error&quot;, False):</font>
<font color="red"> 125.             flags |= _FUNCFLAG_USE_LASTERROR</font>
<font color="red"> 126.         if kw:</font>
<font color="red"> 127.             raise ValueError(&quot;unexpected keyword argument(s) %s&quot; % kw.keys())</font>
<font color="red"> 128.         try:</font>
<font color="red"> 129.             return _win_functype_cache[(restype, argtypes, flags)]</font>
<font color="red"> 130.         except KeyError:</font>
<font color="red"> 131.             class WinFunctionType(_CFuncPtr):</font>
<font color="red"> 132.                 _argtypes_ = argtypes</font>
<font color="red"> 133.                 _restype_ = restype</font>
<font color="red"> 134.                 _flags_ = flags</font>
<font color="red"> 135.             _win_functype_cache[(restype, argtypes, flags)] = WinFunctionType</font>
<font color="red"> 136.             return WinFunctionType</font>
<font color="red"> 137.     if WINFUNCTYPE.__doc__:</font>
<font color="red"> 138.         WINFUNCTYPE.__doc__ = CFUNCTYPE.__doc__.replace(&quot;CFUNCTYPE&quot;, &quot;WINFUNCTYPE&quot;)</font>
<font color="black"> 139. </font>
<font color="green"> 140. elif _os.name == &quot;posix&quot;:</font>
<font color="green"> 141.     from _ctypes import dlopen as _dlopen</font>
<font color="black"> 142. </font>
<font color="green"> 143. from _ctypes import sizeof, byref, addressof, alignment, resize</font>
<font color="green"> 144. from _ctypes import get_errno, set_errno</font>
<font color="green"> 145. from _ctypes import _SimpleCData</font>
<font color="black"> 146. </font>
<font color="green"> 147. def _check_size(typ, typecode=None):</font>
<font color="black"> 148.     # Check if sizeof(ctypes_type) against struct.calcsize.  This</font>
<font color="black"> 149.     # should protect somewhat against a misconfigured libffi.</font>
<font color="green"> 150.     from struct import calcsize</font>
<font color="green"> 151.     if typecode is None:</font>
<font color="black"> 152.         # Most _type_ codes are the same as used in struct</font>
<font color="green"> 153.         typecode = typ._type_</font>
<font color="green"> 154.     actual, required = sizeof(typ), calcsize(typecode)</font>
<font color="green"> 155.     if actual != required:</font>
<font color="red"> 156.         raise SystemError(&quot;sizeof(%s) wrong: %d instead of %d&quot; % \</font>
<font color="red"> 157.                           (typ, actual, required))</font>
<font color="black"> 158. </font>
<font color="green"> 159. class py_object(_SimpleCData):</font>
<font color="green"> 160.     _type_ = &quot;O&quot;</font>
<font color="green"> 161.     def __repr__(self):</font>
<font color="red"> 162.         try:</font>
<font color="red"> 163.             return super(py_object, self).__repr__()</font>
<font color="red"> 164.         except ValueError:</font>
<font color="red"> 165.             return &quot;%s(&lt;NULL&gt;)&quot; % type(self).__name__</font>
<font color="green"> 166. _check_size(py_object, &quot;P&quot;)</font>
<font color="black"> 167. </font>
<font color="green"> 168. class c_short(_SimpleCData):</font>
<font color="green"> 169.     _type_ = &quot;h&quot;</font>
<font color="green"> 170. _check_size(c_short)</font>
<font color="black"> 171. </font>
<font color="green"> 172. class c_ushort(_SimpleCData):</font>
<font color="green"> 173.     _type_ = &quot;H&quot;</font>
<font color="green"> 174. _check_size(c_ushort)</font>
<font color="black"> 175. </font>
<font color="green"> 176. class c_long(_SimpleCData):</font>
<font color="green"> 177.     _type_ = &quot;l&quot;</font>
<font color="green"> 178. _check_size(c_long)</font>
<font color="black"> 179. </font>
<font color="green"> 180. class c_ulong(_SimpleCData):</font>
<font color="green"> 181.     _type_ = &quot;L&quot;</font>
<font color="green"> 182. _check_size(c_ulong)</font>
<font color="black"> 183. </font>
<font color="green"> 184. if _calcsize(&quot;i&quot;) == _calcsize(&quot;l&quot;):</font>
<font color="black"> 185.     # if int and long have the same size, make c_int an alias for c_long</font>
<font color="red"> 186.     c_int = c_long</font>
<font color="red"> 187.     c_uint = c_ulong</font>
<font color="black"> 188. else:</font>
<font color="green"> 189.     class c_int(_SimpleCData):</font>
<font color="green"> 190.         _type_ = &quot;i&quot;</font>
<font color="green"> 191.     _check_size(c_int)</font>
<font color="black"> 192. </font>
<font color="green"> 193.     class c_uint(_SimpleCData):</font>
<font color="green"> 194.         _type_ = &quot;I&quot;</font>
<font color="green"> 195.     _check_size(c_uint)</font>
<font color="black"> 196. </font>
<font color="green"> 197. class c_float(_SimpleCData):</font>
<font color="green"> 198.     _type_ = &quot;f&quot;</font>
<font color="green"> 199. _check_size(c_float)</font>
<font color="black"> 200. </font>
<font color="green"> 201. class c_double(_SimpleCData):</font>
<font color="green"> 202.     _type_ = &quot;d&quot;</font>
<font color="green"> 203. _check_size(c_double)</font>
<font color="black"> 204. </font>
<font color="green"> 205. class c_longdouble(_SimpleCData):</font>
<font color="green"> 206.     _type_ = &quot;g&quot;</font>
<font color="green"> 207. if sizeof(c_longdouble) == sizeof(c_double):</font>
<font color="red"> 208.     c_longdouble = c_double</font>
<font color="black"> 209. </font>
<font color="green"> 210. if _calcsize(&quot;l&quot;) == _calcsize(&quot;q&quot;):</font>
<font color="black"> 211.     # if long and long long have the same size, make c_longlong an alias for c_long</font>
<font color="green"> 212.     c_longlong = c_long</font>
<font color="green"> 213.     c_ulonglong = c_ulong</font>
<font color="black"> 214. else:</font>
<font color="red"> 215.     class c_longlong(_SimpleCData):</font>
<font color="red"> 216.         _type_ = &quot;q&quot;</font>
<font color="red"> 217.     _check_size(c_longlong)</font>
<font color="black"> 218. </font>
<font color="red"> 219.     class c_ulonglong(_SimpleCData):</font>
<font color="red"> 220.         _type_ = &quot;Q&quot;</font>
<font color="black"> 221.     ##    def from_param(cls, val):</font>
<font color="black"> 222.     ##        return ('d', float(val), val)</font>
<font color="black"> 223.     ##    from_param = classmethod(from_param)</font>
<font color="red"> 224.     _check_size(c_ulonglong)</font>
<font color="black"> 225. </font>
<font color="green"> 226. class c_ubyte(_SimpleCData):</font>
<font color="green"> 227.     _type_ = &quot;B&quot;</font>
<font color="green"> 228. c_ubyte.__ctype_le__ = c_ubyte.__ctype_be__ = c_ubyte</font>
<font color="black"> 229. # backward compatibility:</font>
<font color="black"> 230. ##c_uchar = c_ubyte</font>
<font color="green"> 231. _check_size(c_ubyte)</font>
<font color="black"> 232. </font>
<font color="green"> 233. class c_byte(_SimpleCData):</font>
<font color="green"> 234.     _type_ = &quot;b&quot;</font>
<font color="green"> 235. c_byte.__ctype_le__ = c_byte.__ctype_be__ = c_byte</font>
<font color="green"> 236. _check_size(c_byte)</font>
<font color="black"> 237. </font>
<font color="green"> 238. class c_char(_SimpleCData):</font>
<font color="green"> 239.     _type_ = &quot;c&quot;</font>
<font color="green"> 240. c_char.__ctype_le__ = c_char.__ctype_be__ = c_char</font>
<font color="green"> 241. _check_size(c_char)</font>
<font color="black"> 242. </font>
<font color="green"> 243. class c_char_p(_SimpleCData):</font>
<font color="green"> 244.     _type_ = &quot;z&quot;</font>
<font color="green"> 245.     if _os.name == &quot;nt&quot;:</font>
<font color="red"> 246.         def __repr__(self):</font>
<font color="red"> 247.             if not windll.kernel32.IsBadStringPtrA(self, -1):</font>
<font color="red"> 248.                 return &quot;%s(%r)&quot; % (self.__class__.__name__, self.value)</font>
<font color="red"> 249.             return &quot;%s(%s)&quot; % (self.__class__.__name__, cast(self, c_void_p).value)</font>
<font color="black"> 250.     else:</font>
<font color="green"> 251.         def __repr__(self):</font>
<font color="red"> 252.             return &quot;%s(%s)&quot; % (self.__class__.__name__, cast(self, c_void_p).value)</font>
<font color="green"> 253. _check_size(c_char_p, &quot;P&quot;)</font>
<font color="black"> 254. </font>
<font color="green"> 255. class c_void_p(_SimpleCData):</font>
<font color="green"> 256.     _type_ = &quot;P&quot;</font>
<font color="green"> 257. c_voidp = c_void_p # backwards compatibility (to a bug)</font>
<font color="green"> 258. _check_size(c_void_p)</font>
<font color="black"> 259. </font>
<font color="green"> 260. class c_bool(_SimpleCData):</font>
<font color="green"> 261.     _type_ = &quot;?&quot;</font>
<font color="black"> 262. </font>
<font color="green"> 263. from _ctypes import POINTER, pointer, _pointer_type_cache</font>
<font color="black"> 264. </font>
<font color="green"> 265. def _reset_cache():</font>
<font color="green"> 266.     _pointer_type_cache.clear()</font>
<font color="green"> 267.     _c_functype_cache.clear()</font>
<font color="green"> 268.     if _os.name in (&quot;nt&quot;, &quot;ce&quot;):</font>
<font color="red"> 269.         _win_functype_cache.clear()</font>
<font color="black"> 270.     # _SimpleCData.c_wchar_p_from_param</font>
<font color="green"> 271.     POINTER(c_wchar).from_param = c_wchar_p.from_param</font>
<font color="black"> 272.     # _SimpleCData.c_char_p_from_param</font>
<font color="green"> 273.     POINTER(c_char).from_param = c_char_p.from_param</font>
<font color="green"> 274.     _pointer_type_cache[None] = c_void_p</font>
<font color="black"> 275.     # XXX for whatever reasons, creating the first instance of a callback</font>
<font color="black"> 276.     # function is needed for the unittests on Win64 to succeed.  This MAY</font>
<font color="black"> 277.     # be a compiler bug, since the problem occurs only when _ctypes is</font>
<font color="black"> 278.     # compiled with the MS SDK compiler.  Or an uninitialized variable?</font>
<font color="green"> 279.     CFUNCTYPE(c_int)(lambda: None)</font>
<font color="black"> 280. </font>
<font color="green"> 281. try:</font>
<font color="green"> 282.     from _ctypes import set_conversion_mode</font>
<font color="red"> 283. except ImportError:</font>
<font color="red"> 284.     pass</font>
<font color="black"> 285. else:</font>
<font color="green"> 286.     if _os.name in (&quot;nt&quot;, &quot;ce&quot;):</font>
<font color="red"> 287.         set_conversion_mode(&quot;mbcs&quot;, &quot;ignore&quot;)</font>
<font color="black"> 288.     else:</font>
<font color="green"> 289.         set_conversion_mode(&quot;ascii&quot;, &quot;strict&quot;)</font>
<font color="black"> 290. </font>
<font color="green"> 291.     class c_wchar_p(_SimpleCData):</font>
<font color="green"> 292.         _type_ = &quot;Z&quot;</font>
<font color="black"> 293. </font>
<font color="green"> 294.     class c_wchar(_SimpleCData):</font>
<font color="green"> 295.         _type_ = &quot;u&quot;</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def create_unicode_buffer(init, size=None):</font>
<font color="black"> 298.         &quot;&quot;&quot;create_unicode_buffer(aString) -&gt; character array</font>
<font color="black"> 299.         create_unicode_buffer(anInteger) -&gt; character array</font>
<font color="black"> 300.         create_unicode_buffer(aString, anInteger) -&gt; character array</font>
<font color="black"> 301.         &quot;&quot;&quot;</font>
<font color="red"> 302.         if isinstance(init, (str, unicode)):</font>
<font color="red"> 303.             if size is None:</font>
<font color="red"> 304.                 size = len(init)+1</font>
<font color="red"> 305.             buftype = c_wchar * size</font>
<font color="red"> 306.             buf = buftype()</font>
<font color="red"> 307.             buf.value = init</font>
<font color="red"> 308.             return buf</font>
<font color="red"> 309.         elif isinstance(init, (int, long)):</font>
<font color="red"> 310.             buftype = c_wchar * init</font>
<font color="red"> 311.             buf = buftype()</font>
<font color="red"> 312.             return buf</font>
<font color="red"> 313.         raise TypeError(init)</font>
<font color="black"> 314. </font>
<font color="black"> 315. # XXX Deprecated</font>
<font color="green"> 316. def SetPointerType(pointer, cls):</font>
<font color="red"> 317.     if _pointer_type_cache.get(cls, None) is not None:</font>
<font color="red"> 318.         raise RuntimeError(&quot;This type already exists in the cache&quot;)</font>
<font color="red"> 319.     if id(pointer) not in _pointer_type_cache:</font>
<font color="red"> 320.         raise RuntimeError(&quot;What's this???&quot;)</font>
<font color="red"> 321.     pointer.set_type(cls)</font>
<font color="red"> 322.     _pointer_type_cache[cls] = pointer</font>
<font color="red"> 323.     del _pointer_type_cache[id(pointer)]</font>
<font color="black"> 324. </font>
<font color="black"> 325. # XXX Deprecated</font>
<font color="green"> 326. def ARRAY(typ, len):</font>
<font color="red"> 327.     return typ * len</font>
<font color="black"> 328. </font>
<font color="black"> 329. ################################################################</font>
<font color="black"> 330. </font>
<font color="black"> 331. </font>
<font color="green"> 332. class CDLL(object):</font>
<font color="black"> 333.     &quot;&quot;&quot;An instance of this class represents a loaded dll/shared</font>
<font color="black"> 334.     library, exporting functions using the standard C calling</font>
<font color="black"> 335.     convention (named 'cdecl' on Windows).</font>
<font color="black"> 336. </font>
<font color="black"> 337.     The exported functions can be accessed as attributes, or by</font>
<font color="black"> 338.     indexing with the function name.  Examples:</font>
<font color="black"> 339. </font>
<font color="black"> 340.     &lt;obj&gt;.qsort -&gt; callable object</font>
<font color="black"> 341.     &lt;obj&gt;['qsort'] -&gt; callable object</font>
<font color="black"> 342. </font>
<font color="black"> 343.     Calling the functions releases the Python GIL during the call and</font>
<font color="black"> 344.     reacquires it afterwards.</font>
<font color="green"> 345.     &quot;&quot;&quot;</font>
<font color="green"> 346.     _func_flags_ = _FUNCFLAG_CDECL</font>
<font color="green"> 347.     _func_restype_ = c_int</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def __init__(self, name, mode=DEFAULT_MODE, handle=None,</font>
<font color="green"> 350.                  use_errno=False,</font>
<font color="green"> 351.                  use_last_error=False):</font>
<font color="green"> 352.         self._name = name</font>
<font color="green"> 353.         flags = self._func_flags_</font>
<font color="green"> 354.         if use_errno:</font>
<font color="red"> 355.             flags |= _FUNCFLAG_USE_ERRNO</font>
<font color="green"> 356.         if use_last_error:</font>
<font color="red"> 357.             flags |= _FUNCFLAG_USE_LASTERROR</font>
<font color="black"> 358. </font>
<font color="green"> 359.         class _FuncPtr(_CFuncPtr):</font>
<font color="green"> 360.             _flags_ = flags</font>
<font color="green"> 361.             _restype_ = self._func_restype_</font>
<font color="green"> 362.         self._FuncPtr = _FuncPtr</font>
<font color="black"> 363. </font>
<font color="green"> 364.         if handle is None:</font>
<font color="green"> 365.             self._handle = _dlopen(self._name, mode)</font>
<font color="black"> 366.         else:</font>
<font color="red"> 367.             self._handle = handle</font>
<font color="black"> 368. </font>
<font color="green"> 369.     def __repr__(self):</font>
<font color="red"> 370.         return &quot;&lt;%s '%s', handle %x at %x&gt;&quot; % \</font>
<font color="red"> 371.                (self.__class__.__name__, self._name,</font>
<font color="red"> 372.                 (self._handle &amp; (_sys.maxint*2 + 1)),</font>
<font color="red"> 373.                 id(self) &amp; (_sys.maxint*2 + 1))</font>
<font color="black"> 374. </font>
<font color="green"> 375.     def __getattr__(self, name):</font>
<font color="green"> 376.         if name.startswith('__') and name.endswith('__'):</font>
<font color="red"> 377.             raise AttributeError(name)</font>
<font color="green"> 378.         func = self.__getitem__(name)</font>
<font color="green"> 379.         setattr(self, name, func)</font>
<font color="green"> 380.         return func</font>
<font color="black"> 381. </font>
<font color="green"> 382.     def __getitem__(self, name_or_ordinal):</font>
<font color="green"> 383.         func = self._FuncPtr((name_or_ordinal, self))</font>
<font color="green"> 384.         if not isinstance(name_or_ordinal, (int, long)):</font>
<font color="green"> 385.             func.__name__ = name_or_ordinal</font>
<font color="green"> 386.         return func</font>
<font color="black"> 387. </font>
<font color="green"> 388. class PyDLL(CDLL):</font>
<font color="black"> 389.     &quot;&quot;&quot;This class represents the Python library itself.  It allows to</font>
<font color="black"> 390.     access Python API functions.  The GIL is not released, and</font>
<font color="black"> 391.     Python exceptions are handled correctly.</font>
<font color="green"> 392.     &quot;&quot;&quot;</font>
<font color="green"> 393.     _func_flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI</font>
<font color="black"> 394. </font>
<font color="green"> 395. if _os.name in (&quot;nt&quot;, &quot;ce&quot;):</font>
<font color="black"> 396. </font>
<font color="red"> 397.     class WinDLL(CDLL):</font>
<font color="black"> 398.         &quot;&quot;&quot;This class represents a dll exporting functions using the</font>
<font color="black"> 399.         Windows stdcall calling convention.</font>
<font color="red"> 400.         &quot;&quot;&quot;</font>
<font color="red"> 401.         _func_flags_ = _FUNCFLAG_STDCALL</font>
<font color="black"> 402. </font>
<font color="black"> 403.     # XXX Hm, what about HRESULT as normal parameter?</font>
<font color="black"> 404.     # Mustn't it derive from c_long then?</font>
<font color="red"> 405.     from _ctypes import _check_HRESULT, _SimpleCData</font>
<font color="red"> 406.     class HRESULT(_SimpleCData):</font>
<font color="red"> 407.         _type_ = &quot;l&quot;</font>
<font color="black"> 408.         # _check_retval_ is called with the function's result when it</font>
<font color="black"> 409.         # is used as restype.  It checks for the FAILED bit, and</font>
<font color="black"> 410.         # raises a WindowsError if it is set.</font>
<font color="black"> 411.         #</font>
<font color="black"> 412.         # The _check_retval_ method is implemented in C, so that the</font>
<font color="black"> 413.         # method definition itself is not included in the traceback</font>
<font color="black"> 414.         # when it raises an error - that is what we want (and Python</font>
<font color="black"> 415.         # doesn't have a way to raise an exception in the caller's</font>
<font color="black"> 416.         # frame).</font>
<font color="red"> 417.         _check_retval_ = _check_HRESULT</font>
<font color="black"> 418. </font>
<font color="red"> 419.     class OleDLL(CDLL):</font>
<font color="black"> 420.         &quot;&quot;&quot;This class represents a dll exporting functions using the</font>
<font color="black"> 421.         Windows stdcall calling convention, and returning HRESULT.</font>
<font color="black"> 422.         HRESULT error values are automatically raised as WindowsError</font>
<font color="black"> 423.         exceptions.</font>
<font color="red"> 424.         &quot;&quot;&quot;</font>
<font color="red"> 425.         _func_flags_ = _FUNCFLAG_STDCALL</font>
<font color="red"> 426.         _func_restype_ = HRESULT</font>
<font color="black"> 427. </font>
<font color="green"> 428. class LibraryLoader(object):</font>
<font color="green"> 429.     def __init__(self, dlltype):</font>
<font color="green"> 430.         self._dlltype = dlltype</font>
<font color="black"> 431. </font>
<font color="green"> 432.     def __getattr__(self, name):</font>
<font color="red"> 433.         if name[0] == '_':</font>
<font color="red"> 434.             raise AttributeError(name)</font>
<font color="red"> 435.         dll = self._dlltype(name)</font>
<font color="red"> 436.         setattr(self, name, dll)</font>
<font color="red"> 437.         return dll</font>
<font color="black"> 438. </font>
<font color="green"> 439.     def __getitem__(self, name):</font>
<font color="red"> 440.         return getattr(self, name)</font>
<font color="black"> 441. </font>
<font color="green"> 442.     def LoadLibrary(self, name):</font>
<font color="red"> 443.         return self._dlltype(name)</font>
<font color="black"> 444. </font>
<font color="green"> 445. cdll = LibraryLoader(CDLL)</font>
<font color="green"> 446. pydll = LibraryLoader(PyDLL)</font>
<font color="black"> 447. </font>
<font color="green"> 448. if _os.name in (&quot;nt&quot;, &quot;ce&quot;):</font>
<font color="red"> 449.     pythonapi = PyDLL(&quot;python dll&quot;, None, _sys.dllhandle)</font>
<font color="green"> 450. elif _sys.platform == &quot;cygwin&quot;:</font>
<font color="red"> 451.     pythonapi = PyDLL(&quot;libpython%d.%d.dll&quot; % _sys.version_info[:2])</font>
<font color="black"> 452. else:</font>
<font color="green"> 453.     pythonapi = PyDLL(None)</font>
<font color="black"> 454. </font>
<font color="black"> 455. </font>
<font color="green"> 456. if _os.name in (&quot;nt&quot;, &quot;ce&quot;):</font>
<font color="red"> 457.     windll = LibraryLoader(WinDLL)</font>
<font color="red"> 458.     oledll = LibraryLoader(OleDLL)</font>
<font color="black"> 459. </font>
<font color="red"> 460.     if _os.name == &quot;nt&quot;:</font>
<font color="red"> 461.         GetLastError = windll.kernel32.GetLastError</font>
<font color="black"> 462.     else:</font>
<font color="red"> 463.         GetLastError = windll.coredll.GetLastError</font>
<font color="red"> 464.     from _ctypes import get_last_error, set_last_error</font>
<font color="black"> 465. </font>
<font color="red"> 466.     def WinError(code=None, descr=None):</font>
<font color="red"> 467.         if code is None:</font>
<font color="red"> 468.             code = GetLastError()</font>
<font color="red"> 469.         if descr is None:</font>
<font color="red"> 470.             descr = FormatError(code).strip()</font>
<font color="red"> 471.         return WindowsError(code, descr)</font>
<font color="black"> 472. </font>
<font color="green"> 473. if sizeof(c_uint) == sizeof(c_void_p):</font>
<font color="red"> 474.     c_size_t = c_uint</font>
<font color="red"> 475.     c_ssize_t = c_int</font>
<font color="green"> 476. elif sizeof(c_ulong) == sizeof(c_void_p):</font>
<font color="green"> 477.     c_size_t = c_ulong</font>
<font color="green"> 478.     c_ssize_t = c_long</font>
<font color="red"> 479. elif sizeof(c_ulonglong) == sizeof(c_void_p):</font>
<font color="red"> 480.     c_size_t = c_ulonglong</font>
<font color="red"> 481.     c_ssize_t = c_longlong</font>
<font color="black"> 482. </font>
<font color="black"> 483. # functions</font>
<font color="black"> 484. </font>
<font color="green"> 485. from _ctypes import _memmove_addr, _memset_addr, _string_at_addr, _cast_addr</font>
<font color="black"> 486. </font>
<font color="black"> 487. ## void *memmove(void *, const void *, size_t);</font>
<font color="green"> 488. memmove = CFUNCTYPE(c_void_p, c_void_p, c_void_p, c_size_t)(_memmove_addr)</font>
<font color="black"> 489. </font>
<font color="black"> 490. ## void *memset(void *, int, size_t)</font>
<font color="green"> 491. memset = CFUNCTYPE(c_void_p, c_void_p, c_int, c_size_t)(_memset_addr)</font>
<font color="black"> 492. </font>
<font color="green"> 493. def PYFUNCTYPE(restype, *argtypes):</font>
<font color="green"> 494.     class CFunctionType(_CFuncPtr):</font>
<font color="green"> 495.         _argtypes_ = argtypes</font>
<font color="green"> 496.         _restype_ = restype</font>
<font color="green"> 497.         _flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI</font>
<font color="green"> 498.     return CFunctionType</font>
<font color="black"> 499. </font>
<font color="green"> 500. _cast = PYFUNCTYPE(py_object, c_void_p, py_object, py_object)(_cast_addr)</font>
<font color="green"> 501. def cast(obj, typ):</font>
<font color="red"> 502.     return _cast(obj, obj, typ)</font>
<font color="black"> 503. </font>
<font color="green"> 504. _string_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_string_at_addr)</font>
<font color="green"> 505. def string_at(ptr, size=-1):</font>
<font color="black"> 506.     &quot;&quot;&quot;string_at(addr[, size]) -&gt; string</font>
<font color="black"> 507. </font>
<font color="black"> 508.     Return the string at addr.&quot;&quot;&quot;</font>
<font color="red"> 509.     return _string_at(ptr, size)</font>
<font color="black"> 510. </font>
<font color="green"> 511. try:</font>
<font color="green"> 512.     from _ctypes import _wstring_at_addr</font>
<font color="red"> 513. except ImportError:</font>
<font color="red"> 514.     pass</font>
<font color="black"> 515. else:</font>
<font color="green"> 516.     _wstring_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_wstring_at_addr)</font>
<font color="green"> 517.     def wstring_at(ptr, size=-1):</font>
<font color="black"> 518.         &quot;&quot;&quot;wstring_at(addr[, size]) -&gt; string</font>
<font color="black"> 519. </font>
<font color="black"> 520.         Return the string at addr.&quot;&quot;&quot;</font>
<font color="red"> 521.         return _wstring_at(ptr, size)</font>
<font color="black"> 522. </font>
<font color="black"> 523. </font>
<font color="green"> 524. if _os.name in (&quot;nt&quot;, &quot;ce&quot;): # COM stuff</font>
<font color="red"> 525.     def DllGetClassObject(rclsid, riid, ppv):</font>
<font color="red"> 526.         try:</font>
<font color="red"> 527.             ccom = __import__(&quot;comtypes.server.inprocserver&quot;, globals(), locals(), ['*'])</font>
<font color="red"> 528.         except ImportError:</font>
<font color="red"> 529.             return -2147221231 # CLASS_E_CLASSNOTAVAILABLE</font>
<font color="black"> 530.         else:</font>
<font color="red"> 531.             return ccom.DllGetClassObject(rclsid, riid, ppv)</font>
<font color="black"> 532. </font>
<font color="red"> 533.     def DllCanUnloadNow():</font>
<font color="red"> 534.         try:</font>
<font color="red"> 535.             ccom = __import__(&quot;comtypes.server.inprocserver&quot;, globals(), locals(), ['*'])</font>
<font color="red"> 536.         except ImportError:</font>
<font color="red"> 537.             return 0 # S_OK</font>
<font color="red"> 538.         return ccom.DllCanUnloadNow()</font>
<font color="black"> 539. </font>
<font color="green"> 540. from ctypes._endian import BigEndianStructure, LittleEndianStructure</font>
<font color="black"> 541. </font>
<font color="black"> 542. # Fill in specifically-sized types</font>
<font color="green"> 543. c_int8 = c_byte</font>
<font color="green"> 544. c_uint8 = c_ubyte</font>
<font color="green"> 545. for kind in [c_short, c_int, c_long, c_longlong]:</font>
<font color="green"> 546.     if sizeof(kind) == 2: c_int16 = kind</font>
<font color="green"> 547.     elif sizeof(kind) == 4: c_int32 = kind</font>
<font color="green"> 548.     elif sizeof(kind) == 8: c_int64 = kind</font>
<font color="green"> 549. for kind in [c_ushort, c_uint, c_ulong, c_ulonglong]:</font>
<font color="green"> 550.     if sizeof(kind) == 2: c_uint16 = kind</font>
<font color="green"> 551.     elif sizeof(kind) == 4: c_uint32 = kind</font>
<font color="green"> 552.     elif sizeof(kind) == 8: c_uint64 = kind</font>
<font color="green"> 553. del(kind)</font>
<font color="black"> 554. </font>
<font color="green"> 555. _reset_cache()</font>
</pre>

