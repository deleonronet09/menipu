source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/forms/forms.py</b><br>


file stats: <b>282 lines, 74 executed: 26.2% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Form classes</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. from __future__ import unicode_literals</font>
<font color="black">   6. </font>
<font color="green">   7. import copy</font>
<font color="green">   8. from collections import OrderedDict</font>
<font color="black">   9. </font>
<font color="green">  10. from django.core.exceptions import NON_FIELD_ERRORS, ValidationError</font>
<font color="black">  11. # BoundField is imported for backwards compatibility in Django 1.9</font>
<font color="green">  12. from django.forms.boundfield import BoundField  # NOQA</font>
<font color="green">  13. from django.forms.fields import Field, FileField</font>
<font color="black">  14. # pretty_name is imported for backwards compatibility in Django 1.9</font>
<font color="green">  15. from django.forms.utils import ErrorDict, ErrorList, pretty_name  # NOQA</font>
<font color="green">  16. from django.forms.widgets import Media, MediaDefiningClass</font>
<font color="green">  17. from django.utils import six</font>
<font color="green">  18. from django.utils.encoding import force_text, python_2_unicode_compatible</font>
<font color="green">  19. from django.utils.functional import cached_property</font>
<font color="green">  20. from django.utils.html import conditional_escape, html_safe</font>
<font color="green">  21. from django.utils.safestring import mark_safe</font>
<font color="green">  22. from django.utils.translation import ugettext as _</font>
<font color="black">  23. </font>
<font color="green">  24. __all__ = ('BaseForm', 'Form')</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. class DeclarativeFieldsMetaclass(MediaDefiningClass):</font>
<font color="black">  28.     &quot;&quot;&quot;</font>
<font color="black">  29.     Metaclass that collects Fields declared on the base classes.</font>
<font color="green">  30.     &quot;&quot;&quot;</font>
<font color="green">  31.     def __new__(mcs, name, bases, attrs):</font>
<font color="black">  32.         # Collect fields from current class.</font>
<font color="green">  33.         current_fields = []</font>
<font color="green">  34.         for key, value in list(attrs.items()):</font>
<font color="green">  35.             if isinstance(value, Field):</font>
<font color="green">  36.                 current_fields.append((key, value))</font>
<font color="green">  37.                 attrs.pop(key)</font>
<font color="green">  38.         current_fields.sort(key=lambda x: x[1].creation_counter)</font>
<font color="green">  39.         attrs['declared_fields'] = OrderedDict(current_fields)</font>
<font color="black">  40. </font>
<font color="green">  41.         new_class = (super(DeclarativeFieldsMetaclass, mcs)</font>
<font color="green">  42.             .__new__(mcs, name, bases, attrs))</font>
<font color="black">  43. </font>
<font color="black">  44.         # Walk through the MRO.</font>
<font color="green">  45.         declared_fields = OrderedDict()</font>
<font color="green">  46.         for base in reversed(new_class.__mro__):</font>
<font color="black">  47.             # Collect fields from base class.</font>
<font color="green">  48.             if hasattr(base, 'declared_fields'):</font>
<font color="green">  49.                 declared_fields.update(base.declared_fields)</font>
<font color="black">  50. </font>
<font color="black">  51.             # Field shadowing.</font>
<font color="green">  52.             for attr, value in base.__dict__.items():</font>
<font color="green">  53.                 if value is None and attr in declared_fields:</font>
<font color="red">  54.                     declared_fields.pop(attr)</font>
<font color="black">  55. </font>
<font color="green">  56.         new_class.base_fields = declared_fields</font>
<font color="green">  57.         new_class.declared_fields = declared_fields</font>
<font color="black">  58. </font>
<font color="green">  59.         return new_class</font>
<font color="black">  60. </font>
<font color="black">  61. </font>
<font color="green">  62. @html_safe</font>
<font color="green">  63. @python_2_unicode_compatible</font>
<font color="green">  64. class BaseForm(object):</font>
<font color="black">  65.     # This is the main implementation of all the Form logic. Note that this</font>
<font color="black">  66.     # class is different than Form. See the comments by the Form class for more</font>
<font color="black">  67.     # information. Any improvements to the form API should be made to *this*</font>
<font color="black">  68.     # class, not to the Form class.</font>
<font color="green">  69.     field_order = None</font>
<font color="green">  70.     prefix = None</font>
<font color="black">  71. </font>
<font color="green">  72.     def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,</font>
<font color="green">  73.                  initial=None, error_class=ErrorList, label_suffix=None,</font>
<font color="green">  74.                  empty_permitted=False, field_order=None):</font>
<font color="red">  75.         self.is_bound = data is not None or files is not None</font>
<font color="red">  76.         self.data = data or {}</font>
<font color="red">  77.         self.files = files or {}</font>
<font color="red">  78.         self.auto_id = auto_id</font>
<font color="red">  79.         if prefix is not None:</font>
<font color="red">  80.             self.prefix = prefix</font>
<font color="red">  81.         self.initial = initial or {}</font>
<font color="red">  82.         self.error_class = error_class</font>
<font color="black">  83.         # Translators: This is the default suffix added to form field labels</font>
<font color="red">  84.         self.label_suffix = label_suffix if label_suffix is not None else _(':')</font>
<font color="red">  85.         self.empty_permitted = empty_permitted</font>
<font color="red">  86.         self._errors = None  # Stores the errors after clean() has been called.</font>
<font color="black">  87. </font>
<font color="black">  88.         # The base_fields class attribute is the *class-wide* definition of</font>
<font color="black">  89.         # fields. Because a particular *instance* of the class might want to</font>
<font color="black">  90.         # alter self.fields, we create self.fields here by copying base_fields.</font>
<font color="black">  91.         # Instances should always modify self.fields; they should not modify</font>
<font color="black">  92.         # self.base_fields.</font>
<font color="red">  93.         self.fields = copy.deepcopy(self.base_fields)</font>
<font color="red">  94.         self._bound_fields_cache = {}</font>
<font color="red">  95.         self.order_fields(self.field_order if field_order is None else field_order)</font>
<font color="black">  96. </font>
<font color="green">  97.     def order_fields(self, field_order):</font>
<font color="black">  98.         &quot;&quot;&quot;</font>
<font color="black">  99.         Rearranges the fields according to field_order.</font>
<font color="black"> 100. </font>
<font color="black"> 101.         field_order is a list of field names specifying the order. Fields not</font>
<font color="black"> 102.         included in the list are appended in the default order for backward</font>
<font color="black"> 103.         compatibility with subclasses not overriding field_order. If field_order</font>
<font color="black"> 104.         is None, all fields are kept in the order defined in the class.</font>
<font color="black"> 105.         Unknown fields in field_order are ignored to allow disabling fields in</font>
<font color="black"> 106.         form subclasses without redefining ordering.</font>
<font color="black"> 107.         &quot;&quot;&quot;</font>
<font color="red"> 108.         if field_order is None:</font>
<font color="red"> 109.             return</font>
<font color="red"> 110.         fields = OrderedDict()</font>
<font color="red"> 111.         for key in field_order:</font>
<font color="red"> 112.             try:</font>
<font color="red"> 113.                 fields[key] = self.fields.pop(key)</font>
<font color="red"> 114.             except KeyError:  # ignore unknown fields</font>
<font color="red"> 115.                 pass</font>
<font color="red"> 116.         fields.update(self.fields)  # add remaining fields in original order</font>
<font color="red"> 117.         self.fields = fields</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def __str__(self):</font>
<font color="red"> 120.         return self.as_table()</font>
<font color="black"> 121. </font>
<font color="green"> 122.     def __repr__(self):</font>
<font color="red"> 123.         if self._errors is None:</font>
<font color="red"> 124.             is_valid = &quot;Unknown&quot;</font>
<font color="black"> 125.         else:</font>
<font color="red"> 126.             is_valid = self.is_bound and not bool(self._errors)</font>
<font color="red"> 127.         return '&lt;%(cls)s bound=%(bound)s, valid=%(valid)s, fields=(%(fields)s)&gt;' % {</font>
<font color="red"> 128.             'cls': self.__class__.__name__,</font>
<font color="red"> 129.             'bound': self.is_bound,</font>
<font color="red"> 130.             'valid': is_valid,</font>
<font color="red"> 131.             'fields': ';'.join(self.fields),</font>
<font color="black"> 132.         }</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def __iter__(self):</font>
<font color="red"> 135.         for name in self.fields:</font>
<font color="red"> 136.             yield self[name]</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def __getitem__(self, name):</font>
<font color="black"> 139.         &quot;Returns a BoundField with the given name.&quot;</font>
<font color="red"> 140.         try:</font>
<font color="red"> 141.             field = self.fields[name]</font>
<font color="red"> 142.         except KeyError:</font>
<font color="red"> 143.             raise KeyError(</font>
<font color="red"> 144.                 &quot;Key %r not found in '%s'&quot; % (name, self.__class__.__name__))</font>
<font color="red"> 145.         if name not in self._bound_fields_cache:</font>
<font color="red"> 146.             self._bound_fields_cache[name] = field.get_bound_field(self, name)</font>
<font color="red"> 147.         return self._bound_fields_cache[name]</font>
<font color="black"> 148. </font>
<font color="green"> 149.     @property</font>
<font color="black"> 150.     def errors(self):</font>
<font color="black"> 151.         &quot;Returns an ErrorDict for the data provided for the form&quot;</font>
<font color="red"> 152.         if self._errors is None:</font>
<font color="red"> 153.             self.full_clean()</font>
<font color="red"> 154.         return self._errors</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def is_valid(self):</font>
<font color="black"> 157.         &quot;&quot;&quot;</font>
<font color="black"> 158.         Returns True if the form has no errors. Otherwise, False. If errors are</font>
<font color="black"> 159.         being ignored, returns False.</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="red"> 161.         return self.is_bound and not self.errors</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def add_prefix(self, field_name):</font>
<font color="black"> 164.         &quot;&quot;&quot;</font>
<font color="black"> 165.         Returns the field name with a prefix appended, if this Form has a</font>
<font color="black"> 166.         prefix set.</font>
<font color="black"> 167. </font>
<font color="black"> 168.         Subclasses may wish to override.</font>
<font color="black"> 169.         &quot;&quot;&quot;</font>
<font color="red"> 170.         return '%s-%s' % (self.prefix, field_name) if self.prefix else field_name</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def add_initial_prefix(self, field_name):</font>
<font color="black"> 173.         &quot;&quot;&quot;</font>
<font color="black"> 174.         Add a 'initial' prefix for checking dynamic initial values</font>
<font color="black"> 175.         &quot;&quot;&quot;</font>
<font color="red"> 176.         return 'initial-%s' % self.add_prefix(field_name)</font>
<font color="black"> 177. </font>
<font color="green"> 178.     def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row):</font>
<font color="black"> 179.         &quot;Helper function for outputting HTML. Used by as_table(), as_ul(), as_p().&quot;</font>
<font color="red"> 180.         top_errors = self.non_field_errors()  # Errors that should be displayed above all fields.</font>
<font color="red"> 181.         output, hidden_fields = [], []</font>
<font color="black"> 182. </font>
<font color="red"> 183.         for name, field in self.fields.items():</font>
<font color="red"> 184.             html_class_attr = ''</font>
<font color="red"> 185.             bf = self[name]</font>
<font color="black"> 186.             # Escape and cache in local variable.</font>
<font color="red"> 187.             bf_errors = self.error_class([conditional_escape(error) for error in bf.errors])</font>
<font color="red"> 188.             if bf.is_hidden:</font>
<font color="red"> 189.                 if bf_errors:</font>
<font color="red"> 190.                     top_errors.extend(</font>
<font color="red"> 191.                         [_('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': force_text(e)}</font>
<font color="red"> 192.                          for e in bf_errors])</font>
<font color="red"> 193.                 hidden_fields.append(six.text_type(bf))</font>
<font color="black"> 194.             else:</font>
<font color="black"> 195.                 # Create a 'class=&quot;...&quot;' attribute if the row should have any</font>
<font color="black"> 196.                 # CSS classes applied.</font>
<font color="red"> 197.                 css_classes = bf.css_classes()</font>
<font color="red"> 198.                 if css_classes:</font>
<font color="red"> 199.                     html_class_attr = ' class=&quot;%s&quot;' % css_classes</font>
<font color="black"> 200. </font>
<font color="red"> 201.                 if errors_on_separate_row and bf_errors:</font>
<font color="red"> 202.                     output.append(error_row % force_text(bf_errors))</font>
<font color="black"> 203. </font>
<font color="red"> 204.                 if bf.label:</font>
<font color="red"> 205.                     label = conditional_escape(force_text(bf.label))</font>
<font color="red"> 206.                     label = bf.label_tag(label) or ''</font>
<font color="black"> 207.                 else:</font>
<font color="red"> 208.                     label = ''</font>
<font color="black"> 209. </font>
<font color="red"> 210.                 if field.help_text:</font>
<font color="red"> 211.                     help_text = help_text_html % force_text(field.help_text)</font>
<font color="black"> 212.                 else:</font>
<font color="red"> 213.                     help_text = ''</font>
<font color="black"> 214. </font>
<font color="red"> 215.                 output.append(normal_row % {</font>
<font color="red"> 216.                     'errors': force_text(bf_errors),</font>
<font color="red"> 217.                     'label': force_text(label),</font>
<font color="red"> 218.                     'field': six.text_type(bf),</font>
<font color="red"> 219.                     'help_text': help_text,</font>
<font color="red"> 220.                     'html_class_attr': html_class_attr,</font>
<font color="red"> 221.                     'css_classes': css_classes,</font>
<font color="red"> 222.                     'field_name': bf.html_name,</font>
<font color="black"> 223.                 })</font>
<font color="black"> 224. </font>
<font color="red"> 225.         if top_errors:</font>
<font color="red"> 226.             output.insert(0, error_row % force_text(top_errors))</font>
<font color="black"> 227. </font>
<font color="red"> 228.         if hidden_fields:  # Insert any hidden fields in the last row.</font>
<font color="red"> 229.             str_hidden = ''.join(hidden_fields)</font>
<font color="red"> 230.             if output:</font>
<font color="red"> 231.                 last_row = output[-1]</font>
<font color="black"> 232.                 # Chop off the trailing row_ender (e.g. '&lt;/td&gt;&lt;/tr&gt;') and</font>
<font color="black"> 233.                 # insert the hidden fields.</font>
<font color="red"> 234.                 if not last_row.endswith(row_ender):</font>
<font color="black"> 235.                     # This can happen in the as_p() case (and possibly others</font>
<font color="black"> 236.                     # that users write): if there are only top errors, we may</font>
<font color="black"> 237.                     # not be able to conscript the last row for our purposes,</font>
<font color="black"> 238.                     # so insert a new, empty row.</font>
<font color="red"> 239.                     last_row = (normal_row % {</font>
<font color="red"> 240.                         'errors': '',</font>
<font color="red"> 241.                         'label': '',</font>
<font color="red"> 242.                         'field': '',</font>
<font color="red"> 243.                         'help_text': '',</font>
<font color="red"> 244.                         'html_class_attr': html_class_attr,</font>
<font color="red"> 245.                         'css_classes': '',</font>
<font color="red"> 246.                         'field_name': '',</font>
<font color="black"> 247.                     })</font>
<font color="red"> 248.                     output.append(last_row)</font>
<font color="red"> 249.                 output[-1] = last_row[:-len(row_ender)] + str_hidden + row_ender</font>
<font color="black"> 250.             else:</font>
<font color="black"> 251.                 # If there aren't any rows in the output, just append the</font>
<font color="black"> 252.                 # hidden fields.</font>
<font color="red"> 253.                 output.append(str_hidden)</font>
<font color="red"> 254.         return mark_safe('\n'.join(output))</font>
<font color="black"> 255. </font>
<font color="green"> 256.     def as_table(self):</font>
<font color="black"> 257.         &quot;Returns this form rendered as HTML &lt;tr&gt;s -- excluding the &lt;table&gt;&lt;/table&gt;.&quot;</font>
<font color="red"> 258.         return self._html_output(</font>
<font color="red"> 259.             normal_row='&lt;tr%(html_class_attr)s&gt;&lt;th&gt;%(label)s&lt;/th&gt;&lt;td&gt;%(errors)s%(field)s%(help_text)s&lt;/td&gt;&lt;/tr&gt;',</font>
<font color="red"> 260.             error_row='&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;',</font>
<font color="red"> 261.             row_ender='&lt;/td&gt;&lt;/tr&gt;',</font>
<font color="red"> 262.             help_text_html='&lt;br /&gt;&lt;span class=&quot;helptext&quot;&gt;%s&lt;/span&gt;',</font>
<font color="red"> 263.             errors_on_separate_row=False)</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def as_ul(self):</font>
<font color="black"> 266.         &quot;Returns this form rendered as HTML &lt;li&gt;s -- excluding the &lt;ul&gt;&lt;/ul&gt;.&quot;</font>
<font color="red"> 267.         return self._html_output(</font>
<font color="red"> 268.             normal_row='&lt;li%(html_class_attr)s&gt;%(errors)s%(label)s %(field)s%(help_text)s&lt;/li&gt;',</font>
<font color="red"> 269.             error_row='&lt;li&gt;%s&lt;/li&gt;',</font>
<font color="red"> 270.             row_ender='&lt;/li&gt;',</font>
<font color="red"> 271.             help_text_html=' &lt;span class=&quot;helptext&quot;&gt;%s&lt;/span&gt;',</font>
<font color="red"> 272.             errors_on_separate_row=False)</font>
<font color="black"> 273. </font>
<font color="green"> 274.     def as_p(self):</font>
<font color="black"> 275.         &quot;Returns this form rendered as HTML &lt;p&gt;s.&quot;</font>
<font color="red"> 276.         return self._html_output(</font>
<font color="red"> 277.             normal_row='&lt;p%(html_class_attr)s&gt;%(label)s %(field)s%(help_text)s&lt;/p&gt;',</font>
<font color="red"> 278.             error_row='%s',</font>
<font color="red"> 279.             row_ender='&lt;/p&gt;',</font>
<font color="red"> 280.             help_text_html=' &lt;span class=&quot;helptext&quot;&gt;%s&lt;/span&gt;',</font>
<font color="red"> 281.             errors_on_separate_row=True)</font>
<font color="black"> 282. </font>
<font color="green"> 283.     def non_field_errors(self):</font>
<font color="black"> 284.         &quot;&quot;&quot;</font>
<font color="black"> 285.         Returns an ErrorList of errors that aren't associated with a particular</font>
<font color="black"> 286.         field -- i.e., from Form.clean(). Returns an empty ErrorList if there</font>
<font color="black"> 287.         are none.</font>
<font color="black"> 288.         &quot;&quot;&quot;</font>
<font color="red"> 289.         return self.errors.get(NON_FIELD_ERRORS, self.error_class(error_class='nonfield'))</font>
<font color="black"> 290. </font>
<font color="green"> 291.     def add_error(self, field, error):</font>
<font color="black"> 292.         &quot;&quot;&quot;</font>
<font color="black"> 293.         Update the content of `self._errors`.</font>
<font color="black"> 294. </font>
<font color="black"> 295.         The `field` argument is the name of the field to which the errors</font>
<font color="black"> 296.         should be added. If its value is None the errors will be treated as</font>
<font color="black"> 297.         NON_FIELD_ERRORS.</font>
<font color="black"> 298. </font>
<font color="black"> 299.         The `error` argument can be a single error, a list of errors, or a</font>
<font color="black"> 300.         dictionary that maps field names to lists of errors. What we define as</font>
<font color="black"> 301.         an &quot;error&quot; can be either a simple string or an instance of</font>
<font color="black"> 302.         ValidationError with its message attribute set and what we define as</font>
<font color="black"> 303.         list or dictionary can be an actual `list` or `dict` or an instance</font>
<font color="black"> 304.         of ValidationError with its `error_list` or `error_dict` attribute set.</font>
<font color="black"> 305. </font>
<font color="black"> 306.         If `error` is a dictionary, the `field` argument *must* be None and</font>
<font color="black"> 307.         errors will be added to the fields that correspond to the keys of the</font>
<font color="black"> 308.         dictionary.</font>
<font color="black"> 309.         &quot;&quot;&quot;</font>
<font color="red"> 310.         if not isinstance(error, ValidationError):</font>
<font color="black"> 311.             # Normalize to ValidationError and let its constructor</font>
<font color="black"> 312.             # do the hard work of making sense of the input.</font>
<font color="red"> 313.             error = ValidationError(error)</font>
<font color="black"> 314. </font>
<font color="red"> 315.         if hasattr(error, 'error_dict'):</font>
<font color="red"> 316.             if field is not None:</font>
<font color="red"> 317.                 raise TypeError(</font>
<font color="red"> 318.                     &quot;The argument `field` must be `None` when the `error` &quot;</font>
<font color="black"> 319.                     &quot;argument contains errors for multiple fields.&quot;</font>
<font color="black"> 320.                 )</font>
<font color="black"> 321.             else:</font>
<font color="red"> 322.                 error = error.error_dict</font>
<font color="black"> 323.         else:</font>
<font color="red"> 324.             error = {field or NON_FIELD_ERRORS: error.error_list}</font>
<font color="black"> 325. </font>
<font color="red"> 326.         for field, error_list in error.items():</font>
<font color="red"> 327.             if field not in self.errors:</font>
<font color="red"> 328.                 if field != NON_FIELD_ERRORS and field not in self.fields:</font>
<font color="red"> 329.                     raise ValueError(</font>
<font color="red"> 330.                         &quot;'%s' has no field named '%s'.&quot; % (self.__class__.__name__, field))</font>
<font color="red"> 331.                 if field == NON_FIELD_ERRORS:</font>
<font color="red"> 332.                     self._errors[field] = self.error_class(error_class='nonfield')</font>
<font color="black"> 333.                 else:</font>
<font color="red"> 334.                     self._errors[field] = self.error_class()</font>
<font color="red"> 335.             self._errors[field].extend(error_list)</font>
<font color="red"> 336.             if field in self.cleaned_data:</font>
<font color="red"> 337.                 del self.cleaned_data[field]</font>
<font color="black"> 338. </font>
<font color="green"> 339.     def has_error(self, field, code=None):</font>
<font color="red"> 340.         if code is None:</font>
<font color="red"> 341.             return field in self.errors</font>
<font color="red"> 342.         if field in self.errors:</font>
<font color="red"> 343.             for error in self.errors.as_data()[field]:</font>
<font color="red"> 344.                 if error.code == code:</font>
<font color="red"> 345.                     return True</font>
<font color="red"> 346.         return False</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def full_clean(self):</font>
<font color="black"> 349.         &quot;&quot;&quot;</font>
<font color="black"> 350.         Cleans all of self.data and populates self._errors and</font>
<font color="black"> 351.         self.cleaned_data.</font>
<font color="black"> 352.         &quot;&quot;&quot;</font>
<font color="red"> 353.         self._errors = ErrorDict()</font>
<font color="red"> 354.         if not self.is_bound:  # Stop further processing.</font>
<font color="red"> 355.             return</font>
<font color="red"> 356.         self.cleaned_data = {}</font>
<font color="black"> 357.         # If the form is permitted to be empty, and none of the form data has</font>
<font color="black"> 358.         # changed from the initial data, short circuit any validation.</font>
<font color="red"> 359.         if self.empty_permitted and not self.has_changed():</font>
<font color="red"> 360.             return</font>
<font color="black"> 361. </font>
<font color="red"> 362.         self._clean_fields()</font>
<font color="red"> 363.         self._clean_form()</font>
<font color="red"> 364.         self._post_clean()</font>
<font color="black"> 365. </font>
<font color="green"> 366.     def _clean_fields(self):</font>
<font color="red"> 367.         for name, field in self.fields.items():</font>
<font color="black"> 368.             # value_from_datadict() gets the data from the data dictionaries.</font>
<font color="black"> 369.             # Each widget type knows how to retrieve its own data, because some</font>
<font color="black"> 370.             # widgets split data over several HTML fields.</font>
<font color="red"> 371.             if field.disabled:</font>
<font color="red"> 372.                 value = self.initial.get(name, field.initial)</font>
<font color="black"> 373.             else:</font>
<font color="red"> 374.                 value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name))</font>
<font color="red"> 375.             try:</font>
<font color="red"> 376.                 if isinstance(field, FileField):</font>
<font color="red"> 377.                     initial = self.initial.get(name, field.initial)</font>
<font color="red"> 378.                     value = field.clean(value, initial)</font>
<font color="black"> 379.                 else:</font>
<font color="red"> 380.                     value = field.clean(value)</font>
<font color="red"> 381.                 self.cleaned_data[name] = value</font>
<font color="red"> 382.                 if hasattr(self, 'clean_%s' % name):</font>
<font color="red"> 383.                     value = getattr(self, 'clean_%s' % name)()</font>
<font color="red"> 384.                     self.cleaned_data[name] = value</font>
<font color="red"> 385.             except ValidationError as e:</font>
<font color="red"> 386.                 self.add_error(name, e)</font>
<font color="black"> 387. </font>
<font color="green"> 388.     def _clean_form(self):</font>
<font color="red"> 389.         try:</font>
<font color="red"> 390.             cleaned_data = self.clean()</font>
<font color="red"> 391.         except ValidationError as e:</font>
<font color="red"> 392.             self.add_error(None, e)</font>
<font color="black"> 393.         else:</font>
<font color="red"> 394.             if cleaned_data is not None:</font>
<font color="red"> 395.                 self.cleaned_data = cleaned_data</font>
<font color="black"> 396. </font>
<font color="green"> 397.     def _post_clean(self):</font>
<font color="black"> 398.         &quot;&quot;&quot;</font>
<font color="black"> 399.         An internal hook for performing additional cleaning after form cleaning</font>
<font color="black"> 400.         is complete. Used for model validation in model forms.</font>
<font color="black"> 401.         &quot;&quot;&quot;</font>
<font color="red"> 402.         pass</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def clean(self):</font>
<font color="black"> 405.         &quot;&quot;&quot;</font>
<font color="black"> 406.         Hook for doing any extra form-wide cleaning after Field.clean() has been</font>
<font color="black"> 407.         called on every field. Any ValidationError raised by this method will</font>
<font color="black"> 408.         not be associated with a particular field; it will have a special-case</font>
<font color="black"> 409.         association with the field named '__all__'.</font>
<font color="black"> 410.         &quot;&quot;&quot;</font>
<font color="red"> 411.         return self.cleaned_data</font>
<font color="black"> 412. </font>
<font color="green"> 413.     def has_changed(self):</font>
<font color="black"> 414.         &quot;&quot;&quot;</font>
<font color="black"> 415.         Returns True if data differs from initial.</font>
<font color="black"> 416.         &quot;&quot;&quot;</font>
<font color="red"> 417.         return bool(self.changed_data)</font>
<font color="black"> 418. </font>
<font color="green"> 419.     @cached_property</font>
<font color="black"> 420.     def changed_data(self):</font>
<font color="red"> 421.         data = []</font>
<font color="red"> 422.         for name, field in self.fields.items():</font>
<font color="red"> 423.             prefixed_name = self.add_prefix(name)</font>
<font color="red"> 424.             data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)</font>
<font color="red"> 425.             if not field.show_hidden_initial:</font>
<font color="red"> 426.                 initial_value = self.initial.get(name, field.initial)</font>
<font color="red"> 427.                 if callable(initial_value):</font>
<font color="red"> 428.                     initial_value = initial_value()</font>
<font color="black"> 429.             else:</font>
<font color="red"> 430.                 initial_prefixed_name = self.add_initial_prefix(name)</font>
<font color="red"> 431.                 hidden_widget = field.hidden_widget()</font>
<font color="red"> 432.                 try:</font>
<font color="red"> 433.                     initial_value = field.to_python(hidden_widget.value_from_datadict(</font>
<font color="red"> 434.                         self.data, self.files, initial_prefixed_name))</font>
<font color="red"> 435.                 except ValidationError:</font>
<font color="black"> 436.                     # Always assume data has changed if validation fails.</font>
<font color="red"> 437.                     data.append(name)</font>
<font color="red"> 438.                     continue</font>
<font color="red"> 439.             if field.has_changed(initial_value, data_value):</font>
<font color="red"> 440.                 data.append(name)</font>
<font color="red"> 441.         return data</font>
<font color="black"> 442. </font>
<font color="green"> 443.     @property</font>
<font color="black"> 444.     def media(self):</font>
<font color="black"> 445.         &quot;&quot;&quot;</font>
<font color="black"> 446.         Provide a description of all media required to render the widgets on this form</font>
<font color="black"> 447.         &quot;&quot;&quot;</font>
<font color="red"> 448.         media = Media()</font>
<font color="red"> 449.         for field in self.fields.values():</font>
<font color="red"> 450.             media = media + field.widget.media</font>
<font color="red"> 451.         return media</font>
<font color="black"> 452. </font>
<font color="green"> 453.     def is_multipart(self):</font>
<font color="black"> 454.         &quot;&quot;&quot;</font>
<font color="black"> 455.         Returns True if the form needs to be multipart-encoded, i.e. it has</font>
<font color="black"> 456.         FileInput. Otherwise, False.</font>
<font color="black"> 457.         &quot;&quot;&quot;</font>
<font color="red"> 458.         for field in self.fields.values():</font>
<font color="red"> 459.             if field.widget.needs_multipart_form:</font>
<font color="red"> 460.                 return True</font>
<font color="red"> 461.         return False</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def hidden_fields(self):</font>
<font color="black"> 464.         &quot;&quot;&quot;</font>
<font color="black"> 465.         Returns a list of all the BoundField objects that are hidden fields.</font>
<font color="black"> 466.         Useful for manual form layout in templates.</font>
<font color="black"> 467.         &quot;&quot;&quot;</font>
<font color="red"> 468.         return [field for field in self if field.is_hidden]</font>
<font color="black"> 469. </font>
<font color="green"> 470.     def visible_fields(self):</font>
<font color="black"> 471.         &quot;&quot;&quot;</font>
<font color="black"> 472.         Returns a list of BoundField objects that aren't hidden fields.</font>
<font color="black"> 473.         The opposite of the hidden_fields() method.</font>
<font color="black"> 474.         &quot;&quot;&quot;</font>
<font color="red"> 475.         return [field for field in self if not field.is_hidden]</font>
<font color="black"> 476. </font>
<font color="black"> 477. </font>
<font color="green"> 478. class Form(six.with_metaclass(DeclarativeFieldsMetaclass, BaseForm)):</font>
<font color="green"> 479.     &quot;A collection of Fields, plus their associated data.&quot;</font>
<font color="black"> 480.     # This is a separate class from BaseForm in order to abstract the way</font>
<font color="black"> 481.     # self.fields is specified. This class (Form) is the one that does the</font>
<font color="black"> 482.     # fancy metaclass stuff purely for the semantic sugar -- it allows one</font>
<font color="black"> 483.     # to define a form using declarative syntax.</font>
<font color="black"> 484.     # BaseForm itself has no way of designating self.fields.</font>
</pre>

