source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/contrib/auth/hashers.py</b><br>


file stats: <b>283 lines, 98 executed: 34.6% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import base64</font>
<font color="green">   4. import binascii</font>
<font color="green">   5. import hashlib</font>
<font color="green">   6. import importlib</font>
<font color="green">   7. from collections import OrderedDict</font>
<font color="black">   8. </font>
<font color="green">   9. from django.conf import settings</font>
<font color="green">  10. from django.core.exceptions import ImproperlyConfigured</font>
<font color="green">  11. from django.core.signals import setting_changed</font>
<font color="green">  12. from django.dispatch import receiver</font>
<font color="green">  13. from django.utils import lru_cache</font>
<font color="green">  14. from django.utils.crypto import (</font>
<font color="black">  15.     constant_time_compare, get_random_string, pbkdf2,</font>
<font color="black">  16. )</font>
<font color="green">  17. from django.utils.encoding import force_bytes, force_str, force_text</font>
<font color="green">  18. from django.utils.module_loading import import_string</font>
<font color="green">  19. from django.utils.translation import ugettext_noop as _</font>
<font color="black">  20. </font>
<font color="green">  21. UNUSABLE_PASSWORD_PREFIX = '!'  # This will never be a valid encoded hash</font>
<font color="green">  22. UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX</font>
<font color="black">  23. </font>
<font color="black">  24. </font>
<font color="green">  25. def is_password_usable(encoded):</font>
<font color="red">  26.     if encoded is None or encoded.startswith(UNUSABLE_PASSWORD_PREFIX):</font>
<font color="red">  27.         return False</font>
<font color="red">  28.     try:</font>
<font color="red">  29.         identify_hasher(encoded)</font>
<font color="red">  30.     except ValueError:</font>
<font color="red">  31.         return False</font>
<font color="red">  32.     return True</font>
<font color="black">  33. </font>
<font color="black">  34. </font>
<font color="green">  35. def check_password(password, encoded, setter=None, preferred='default'):</font>
<font color="black">  36.     &quot;&quot;&quot;</font>
<font color="black">  37.     Returns a boolean of whether the raw password matches the three</font>
<font color="black">  38.     part encoded digest.</font>
<font color="black">  39. </font>
<font color="black">  40.     If setter is specified, it'll be called when you need to</font>
<font color="black">  41.     regenerate the password.</font>
<font color="black">  42.     &quot;&quot;&quot;</font>
<font color="red">  43.     if password is None or not is_password_usable(encoded):</font>
<font color="red">  44.         return False</font>
<font color="black">  45. </font>
<font color="red">  46.     preferred = get_hasher(preferred)</font>
<font color="red">  47.     hasher = identify_hasher(encoded)</font>
<font color="black">  48. </font>
<font color="red">  49.     must_update = hasher.algorithm != preferred.algorithm</font>
<font color="red">  50.     if not must_update:</font>
<font color="red">  51.         must_update = preferred.must_update(encoded)</font>
<font color="red">  52.     is_correct = hasher.verify(password, encoded)</font>
<font color="red">  53.     if setter and is_correct and must_update:</font>
<font color="red">  54.         setter(password)</font>
<font color="red">  55.     return is_correct</font>
<font color="black">  56. </font>
<font color="black">  57. </font>
<font color="green">  58. def make_password(password, salt=None, hasher='default'):</font>
<font color="black">  59.     &quot;&quot;&quot;</font>
<font color="black">  60.     Turn a plain-text password into a hash for database storage</font>
<font color="black">  61. </font>
<font color="black">  62.     Same as encode() but generates a new random salt.</font>
<font color="black">  63.     If password is None then a concatenation of</font>
<font color="black">  64.     UNUSABLE_PASSWORD_PREFIX and a random string will be returned</font>
<font color="black">  65.     which disallows logins. Additional random string reduces chances</font>
<font color="black">  66.     of gaining access to staff or superuser accounts.</font>
<font color="black">  67.     See ticket #20079 for more info.</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="red">  69.     if password is None:</font>
<font color="red">  70.         return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)</font>
<font color="red">  71.     hasher = get_hasher(hasher)</font>
<font color="black">  72. </font>
<font color="red">  73.     if not salt:</font>
<font color="red">  74.         salt = hasher.salt()</font>
<font color="black">  75. </font>
<font color="red">  76.     return hasher.encode(password, salt)</font>
<font color="black">  77. </font>
<font color="black">  78. </font>
<font color="green">  79. @lru_cache.lru_cache()</font>
<font color="black">  80. def get_hashers():</font>
<font color="red">  81.     hashers = []</font>
<font color="red">  82.     for hasher_path in settings.PASSWORD_HASHERS:</font>
<font color="red">  83.         hasher_cls = import_string(hasher_path)</font>
<font color="red">  84.         hasher = hasher_cls()</font>
<font color="red">  85.         if not getattr(hasher, 'algorithm'):</font>
<font color="red">  86.             raise ImproperlyConfigured(&quot;hasher doesn't specify an &quot;</font>
<font color="red">  87.                                        &quot;algorithm name: %s&quot; % hasher_path)</font>
<font color="red">  88.         hashers.append(hasher)</font>
<font color="red">  89.     return hashers</font>
<font color="black">  90. </font>
<font color="black">  91. </font>
<font color="green">  92. @lru_cache.lru_cache()</font>
<font color="black">  93. def get_hashers_by_algorithm():</font>
<font color="red">  94.     return {hasher.algorithm: hasher for hasher in get_hashers()}</font>
<font color="black">  95. </font>
<font color="black">  96. </font>
<font color="green">  97. @receiver(setting_changed)</font>
<font color="black">  98. def reset_hashers(**kwargs):</font>
<font color="red">  99.     if kwargs['setting'] == 'PASSWORD_HASHERS':</font>
<font color="red"> 100.         get_hashers.cache_clear()</font>
<font color="red"> 101.         get_hashers_by_algorithm.cache_clear()</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. def get_hasher(algorithm='default'):</font>
<font color="black"> 105.     &quot;&quot;&quot;</font>
<font color="black"> 106.     Returns an instance of a loaded password hasher.</font>
<font color="black"> 107. </font>
<font color="black"> 108.     If algorithm is 'default', the default hasher will be returned.</font>
<font color="black"> 109.     This function will also lazy import hashers specified in your</font>
<font color="black"> 110.     settings file if needed.</font>
<font color="black"> 111.     &quot;&quot;&quot;</font>
<font color="red"> 112.     if hasattr(algorithm, 'algorithm'):</font>
<font color="red"> 113.         return algorithm</font>
<font color="black"> 114. </font>
<font color="red"> 115.     elif algorithm == 'default':</font>
<font color="red"> 116.         return get_hashers()[0]</font>
<font color="black"> 117. </font>
<font color="black"> 118.     else:</font>
<font color="red"> 119.         hashers = get_hashers_by_algorithm()</font>
<font color="red"> 120.         try:</font>
<font color="red"> 121.             return hashers[algorithm]</font>
<font color="red"> 122.         except KeyError:</font>
<font color="red"> 123.             raise ValueError(&quot;Unknown password hashing algorithm '%s'. &quot;</font>
<font color="black"> 124.                              &quot;Did you specify it in the PASSWORD_HASHERS &quot;</font>
<font color="red"> 125.                              &quot;setting?&quot; % algorithm)</font>
<font color="black"> 126. </font>
<font color="black"> 127. </font>
<font color="green"> 128. def identify_hasher(encoded):</font>
<font color="black"> 129.     &quot;&quot;&quot;</font>
<font color="black"> 130.     Returns an instance of a loaded password hasher.</font>
<font color="black"> 131. </font>
<font color="black"> 132.     Identifies hasher algorithm by examining encoded hash, and calls</font>
<font color="black"> 133.     get_hasher() to return hasher. Raises ValueError if</font>
<font color="black"> 134.     algorithm cannot be identified, or if hasher is not loaded.</font>
<font color="black"> 135.     &quot;&quot;&quot;</font>
<font color="black"> 136.     # Ancient versions of Django created plain MD5 passwords and accepted</font>
<font color="black"> 137.     # MD5 passwords with an empty salt.</font>
<font color="red"> 138.     if ((len(encoded) == 32 and '$' not in encoded) or</font>
<font color="red"> 139.             (len(encoded) == 37 and encoded.startswith('md5$$'))):</font>
<font color="red"> 140.         algorithm = 'unsalted_md5'</font>
<font color="black"> 141.     # Ancient versions of Django accepted SHA1 passwords with an empty salt.</font>
<font color="red"> 142.     elif len(encoded) == 46 and encoded.startswith('sha1$$'):</font>
<font color="red"> 143.         algorithm = 'unsalted_sha1'</font>
<font color="black"> 144.     else:</font>
<font color="red"> 145.         algorithm = encoded.split('$', 1)[0]</font>
<font color="red"> 146.     return get_hasher(algorithm)</font>
<font color="black"> 147. </font>
<font color="black"> 148. </font>
<font color="green"> 149. def mask_hash(hash, show=6, char=&quot;*&quot;):</font>
<font color="black"> 150.     &quot;&quot;&quot;</font>
<font color="black"> 151.     Returns the given hash, with only the first ``show`` number shown. The</font>
<font color="black"> 152.     rest are masked with ``char`` for security reasons.</font>
<font color="black"> 153.     &quot;&quot;&quot;</font>
<font color="red"> 154.     masked = hash[:show]</font>
<font color="red"> 155.     masked += char * len(hash[show:])</font>
<font color="red"> 156.     return masked</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="green"> 159. class BasePasswordHasher(object):</font>
<font color="black"> 160.     &quot;&quot;&quot;</font>
<font color="black"> 161.     Abstract base class for password hashers</font>
<font color="black"> 162. </font>
<font color="black"> 163.     When creating your own hasher, you need to override algorithm,</font>
<font color="black"> 164.     verify(), encode() and safe_summary().</font>
<font color="black"> 165. </font>
<font color="black"> 166.     PasswordHasher objects are immutable.</font>
<font color="green"> 167.     &quot;&quot;&quot;</font>
<font color="green"> 168.     algorithm = None</font>
<font color="green"> 169.     library = None</font>
<font color="black"> 170. </font>
<font color="green"> 171.     def _load_library(self):</font>
<font color="red"> 172.         if self.library is not None:</font>
<font color="red"> 173.             if isinstance(self.library, (tuple, list)):</font>
<font color="red"> 174.                 name, mod_path = self.library</font>
<font color="black"> 175.             else:</font>
<font color="red"> 176.                 mod_path = self.library</font>
<font color="red"> 177.             try:</font>
<font color="red"> 178.                 module = importlib.import_module(mod_path)</font>
<font color="red"> 179.             except ImportError as e:</font>
<font color="red"> 180.                 raise ValueError(&quot;Couldn't load %r algorithm library: %s&quot; %</font>
<font color="red"> 181.                                  (self.__class__.__name__, e))</font>
<font color="red"> 182.             return module</font>
<font color="red"> 183.         raise ValueError(&quot;Hasher %r doesn't specify a library attribute&quot; %</font>
<font color="red"> 184.                          self.__class__.__name__)</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def salt(self):</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="black"> 188.         Generates a cryptographically secure nonce salt in ASCII</font>
<font color="black"> 189.         &quot;&quot;&quot;</font>
<font color="red"> 190.         return get_random_string()</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def verify(self, password, encoded):</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="black"> 194.         Checks if the given password is correct</font>
<font color="black"> 195.         &quot;&quot;&quot;</font>
<font color="red"> 196.         raise NotImplementedError('subclasses of BasePasswordHasher must provide a verify() method')</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def encode(self, password, salt):</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="black"> 200.         Creates an encoded database value</font>
<font color="black"> 201. </font>
<font color="black"> 202.         The result is normally formatted as &quot;algorithm$salt$hash&quot; and</font>
<font color="black"> 203.         must be fewer than 128 characters.</font>
<font color="black"> 204.         &quot;&quot;&quot;</font>
<font color="red"> 205.         raise NotImplementedError('subclasses of BasePasswordHasher must provide an encode() method')</font>
<font color="black"> 206. </font>
<font color="green"> 207.     def safe_summary(self, encoded):</font>
<font color="black"> 208.         &quot;&quot;&quot;</font>
<font color="black"> 209.         Returns a summary of safe values</font>
<font color="black"> 210. </font>
<font color="black"> 211.         The result is a dictionary and will be used where the password field</font>
<font color="black"> 212.         must be displayed to construct a safe representation of the password.</font>
<font color="black"> 213.         &quot;&quot;&quot;</font>
<font color="red"> 214.         raise NotImplementedError('subclasses of BasePasswordHasher must provide a safe_summary() method')</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def must_update(self, encoded):</font>
<font color="red"> 217.         return False</font>
<font color="black"> 218. </font>
<font color="black"> 219. </font>
<font color="green"> 220. class PBKDF2PasswordHasher(BasePasswordHasher):</font>
<font color="black"> 221.     &quot;&quot;&quot;</font>
<font color="black"> 222.     Secure password hashing using the PBKDF2 algorithm (recommended)</font>
<font color="black"> 223. </font>
<font color="black"> 224.     Configured to use PBKDF2 + HMAC + SHA256.</font>
<font color="black"> 225.     The result is a 64 byte binary string.  Iterations may be changed</font>
<font color="black"> 226.     safely but you must rename the algorithm if you change SHA256.</font>
<font color="green"> 227.     &quot;&quot;&quot;</font>
<font color="green"> 228.     algorithm = &quot;pbkdf2_sha256&quot;</font>
<font color="green"> 229.     iterations = 24000</font>
<font color="green"> 230.     digest = hashlib.sha256</font>
<font color="black"> 231. </font>
<font color="green"> 232.     def encode(self, password, salt, iterations=None):</font>
<font color="red"> 233.         assert password is not None</font>
<font color="red"> 234.         assert salt and '$' not in salt</font>
<font color="red"> 235.         if not iterations:</font>
<font color="red"> 236.             iterations = self.iterations</font>
<font color="red"> 237.         hash = pbkdf2(password, salt, iterations, digest=self.digest)</font>
<font color="red"> 238.         hash = base64.b64encode(hash).decode('ascii').strip()</font>
<font color="red"> 239.         return &quot;%s$%d$%s$%s&quot; % (self.algorithm, iterations, salt, hash)</font>
<font color="black"> 240. </font>
<font color="green"> 241.     def verify(self, password, encoded):</font>
<font color="red"> 242.         algorithm, iterations, salt, hash = encoded.split('$', 3)</font>
<font color="red"> 243.         assert algorithm == self.algorithm</font>
<font color="red"> 244.         encoded_2 = self.encode(password, salt, int(iterations))</font>
<font color="red"> 245.         return constant_time_compare(encoded, encoded_2)</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def safe_summary(self, encoded):</font>
<font color="red"> 248.         algorithm, iterations, salt, hash = encoded.split('$', 3)</font>
<font color="red"> 249.         assert algorithm == self.algorithm</font>
<font color="red"> 250.         return OrderedDict([</font>
<font color="red"> 251.             (_('algorithm'), algorithm),</font>
<font color="red"> 252.             (_('iterations'), iterations),</font>
<font color="red"> 253.             (_('salt'), mask_hash(salt)),</font>
<font color="red"> 254.             (_('hash'), mask_hash(hash)),</font>
<font color="black"> 255.         ])</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def must_update(self, encoded):</font>
<font color="red"> 258.         algorithm, iterations, salt, hash = encoded.split('$', 3)</font>
<font color="red"> 259.         return int(iterations) != self.iterations</font>
<font color="black"> 260. </font>
<font color="black"> 261. </font>
<font color="green"> 262. class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):</font>
<font color="black"> 263.     &quot;&quot;&quot;</font>
<font color="black"> 264.     Alternate PBKDF2 hasher which uses SHA1, the default PRF</font>
<font color="black"> 265.     recommended by PKCS #5. This is compatible with other</font>
<font color="black"> 266.     implementations of PBKDF2, such as openssl's</font>
<font color="black"> 267.     PKCS5_PBKDF2_HMAC_SHA1().</font>
<font color="green"> 268.     &quot;&quot;&quot;</font>
<font color="green"> 269.     algorithm = &quot;pbkdf2_sha1&quot;</font>
<font color="green"> 270.     digest = hashlib.sha1</font>
<font color="black"> 271. </font>
<font color="black"> 272. </font>
<font color="green"> 273. class BCryptSHA256PasswordHasher(BasePasswordHasher):</font>
<font color="black"> 274.     &quot;&quot;&quot;</font>
<font color="black"> 275.     Secure password hashing using the bcrypt algorithm (recommended)</font>
<font color="black"> 276. </font>
<font color="black"> 277.     This is considered by many to be the most secure algorithm but you</font>
<font color="black"> 278.     must first install the bcrypt library.  Please be warned that</font>
<font color="black"> 279.     this library depends on native C code and might cause portability</font>
<font color="black"> 280.     issues.</font>
<font color="green"> 281.     &quot;&quot;&quot;</font>
<font color="green"> 282.     algorithm = &quot;bcrypt_sha256&quot;</font>
<font color="green"> 283.     digest = hashlib.sha256</font>
<font color="green"> 284.     library = (&quot;bcrypt&quot;, &quot;bcrypt&quot;)</font>
<font color="green"> 285.     rounds = 12</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def salt(self):</font>
<font color="red"> 288.         bcrypt = self._load_library()</font>
<font color="red"> 289.         return bcrypt.gensalt(rounds=self.rounds)</font>
<font color="black"> 290. </font>
<font color="green"> 291.     def encode(self, password, salt):</font>
<font color="red"> 292.         bcrypt = self._load_library()</font>
<font color="black"> 293.         # Need to reevaluate the force_bytes call once bcrypt is supported on</font>
<font color="black"> 294.         # Python 3</font>
<font color="black"> 295. </font>
<font color="black"> 296.         # Hash the password prior to using bcrypt to prevent password truncation</font>
<font color="black"> 297.         #   See: https://code.djangoproject.com/ticket/20138</font>
<font color="red"> 298.         if self.digest is not None:</font>
<font color="black"> 299.             # We use binascii.hexlify here because Python3 decided that a hex encoded</font>
<font color="black"> 300.             #   bytestring is somehow a unicode.</font>
<font color="red"> 301.             password = binascii.hexlify(self.digest(force_bytes(password)).digest())</font>
<font color="black"> 302.         else:</font>
<font color="red"> 303.             password = force_bytes(password)</font>
<font color="black"> 304. </font>
<font color="red"> 305.         data = bcrypt.hashpw(password, salt)</font>
<font color="red"> 306.         return &quot;%s$%s&quot; % (self.algorithm, force_text(data))</font>
<font color="black"> 307. </font>
<font color="green"> 308.     def verify(self, password, encoded):</font>
<font color="red"> 309.         algorithm, data = encoded.split('$', 1)</font>
<font color="red"> 310.         assert algorithm == self.algorithm</font>
<font color="red"> 311.         bcrypt = self._load_library()</font>
<font color="black"> 312. </font>
<font color="black"> 313.         # Hash the password prior to using bcrypt to prevent password truncation</font>
<font color="black"> 314.         #   See: https://code.djangoproject.com/ticket/20138</font>
<font color="red"> 315.         if self.digest is not None:</font>
<font color="black"> 316.             # We use binascii.hexlify here because Python3 decided that a hex encoded</font>
<font color="black"> 317.             #   bytestring is somehow a unicode.</font>
<font color="red"> 318.             password = binascii.hexlify(self.digest(force_bytes(password)).digest())</font>
<font color="black"> 319.         else:</font>
<font color="red"> 320.             password = force_bytes(password)</font>
<font color="black"> 321. </font>
<font color="black"> 322.         # Ensure that our data is a bytestring</font>
<font color="red"> 323.         data = force_bytes(data)</font>
<font color="black"> 324.         # force_bytes() necessary for py-bcrypt compatibility</font>
<font color="red"> 325.         hashpw = force_bytes(bcrypt.hashpw(password, data))</font>
<font color="black"> 326. </font>
<font color="red"> 327.         return constant_time_compare(data, hashpw)</font>
<font color="black"> 328. </font>
<font color="green"> 329.     def safe_summary(self, encoded):</font>
<font color="red"> 330.         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)</font>
<font color="red"> 331.         assert algorithm == self.algorithm</font>
<font color="red"> 332.         salt, checksum = data[:22], data[22:]</font>
<font color="red"> 333.         return OrderedDict([</font>
<font color="red"> 334.             (_('algorithm'), algorithm),</font>
<font color="red"> 335.             (_('work factor'), work_factor),</font>
<font color="red"> 336.             (_('salt'), mask_hash(salt)),</font>
<font color="red"> 337.             (_('checksum'), mask_hash(checksum)),</font>
<font color="black"> 338.         ])</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def must_update(self, encoded):</font>
<font color="red"> 341.         algorithm, empty, algostr, rounds, data = encoded.split('$', 4)</font>
<font color="red"> 342.         return int(rounds) != self.rounds</font>
<font color="black"> 343. </font>
<font color="black"> 344. </font>
<font color="green"> 345. class BCryptPasswordHasher(BCryptSHA256PasswordHasher):</font>
<font color="black"> 346.     &quot;&quot;&quot;</font>
<font color="black"> 347.     Secure password hashing using the bcrypt algorithm</font>
<font color="black"> 348. </font>
<font color="black"> 349.     This is considered by many to be the most secure algorithm but you</font>
<font color="black"> 350.     must first install the bcrypt library.  Please be warned that</font>
<font color="black"> 351.     this library depends on native C code and might cause portability</font>
<font color="black"> 352.     issues.</font>
<font color="black"> 353. </font>
<font color="black"> 354.     This hasher does not first hash the password which means it is subject to</font>
<font color="black"> 355.     the 72 character bcrypt password truncation, most use cases should prefer</font>
<font color="black"> 356.     the BCryptSha512PasswordHasher.</font>
<font color="black"> 357. </font>
<font color="black"> 358.     See: https://code.djangoproject.com/ticket/20138</font>
<font color="green"> 359.     &quot;&quot;&quot;</font>
<font color="green"> 360.     algorithm = &quot;bcrypt&quot;</font>
<font color="green"> 361.     digest = None</font>
<font color="black"> 362. </font>
<font color="black"> 363. </font>
<font color="green"> 364. class SHA1PasswordHasher(BasePasswordHasher):</font>
<font color="black"> 365.     &quot;&quot;&quot;</font>
<font color="black"> 366.     The SHA1 password hashing algorithm (not recommended)</font>
<font color="green"> 367.     &quot;&quot;&quot;</font>
<font color="green"> 368.     algorithm = &quot;sha1&quot;</font>
<font color="black"> 369. </font>
<font color="green"> 370.     def encode(self, password, salt):</font>
<font color="red"> 371.         assert password is not None</font>
<font color="red"> 372.         assert salt and '$' not in salt</font>
<font color="red"> 373.         hash = hashlib.sha1(force_bytes(salt + password)).hexdigest()</font>
<font color="red"> 374.         return &quot;%s$%s$%s&quot; % (self.algorithm, salt, hash)</font>
<font color="black"> 375. </font>
<font color="green"> 376.     def verify(self, password, encoded):</font>
<font color="red"> 377.         algorithm, salt, hash = encoded.split('$', 2)</font>
<font color="red"> 378.         assert algorithm == self.algorithm</font>
<font color="red"> 379.         encoded_2 = self.encode(password, salt)</font>
<font color="red"> 380.         return constant_time_compare(encoded, encoded_2)</font>
<font color="black"> 381. </font>
<font color="green"> 382.     def safe_summary(self, encoded):</font>
<font color="red"> 383.         algorithm, salt, hash = encoded.split('$', 2)</font>
<font color="red"> 384.         assert algorithm == self.algorithm</font>
<font color="red"> 385.         return OrderedDict([</font>
<font color="red"> 386.             (_('algorithm'), algorithm),</font>
<font color="red"> 387.             (_('salt'), mask_hash(salt, show=2)),</font>
<font color="red"> 388.             (_('hash'), mask_hash(hash)),</font>
<font color="black"> 389.         ])</font>
<font color="black"> 390. </font>
<font color="black"> 391. </font>
<font color="green"> 392. class MD5PasswordHasher(BasePasswordHasher):</font>
<font color="black"> 393.     &quot;&quot;&quot;</font>
<font color="black"> 394.     The Salted MD5 password hashing algorithm (not recommended)</font>
<font color="green"> 395.     &quot;&quot;&quot;</font>
<font color="green"> 396.     algorithm = &quot;md5&quot;</font>
<font color="black"> 397. </font>
<font color="green"> 398.     def encode(self, password, salt):</font>
<font color="red"> 399.         assert password is not None</font>
<font color="red"> 400.         assert salt and '$' not in salt</font>
<font color="red"> 401.         hash = hashlib.md5(force_bytes(salt + password)).hexdigest()</font>
<font color="red"> 402.         return &quot;%s$%s$%s&quot; % (self.algorithm, salt, hash)</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def verify(self, password, encoded):</font>
<font color="red"> 405.         algorithm, salt, hash = encoded.split('$', 2)</font>
<font color="red"> 406.         assert algorithm == self.algorithm</font>
<font color="red"> 407.         encoded_2 = self.encode(password, salt)</font>
<font color="red"> 408.         return constant_time_compare(encoded, encoded_2)</font>
<font color="black"> 409. </font>
<font color="green"> 410.     def safe_summary(self, encoded):</font>
<font color="red"> 411.         algorithm, salt, hash = encoded.split('$', 2)</font>
<font color="red"> 412.         assert algorithm == self.algorithm</font>
<font color="red"> 413.         return OrderedDict([</font>
<font color="red"> 414.             (_('algorithm'), algorithm),</font>
<font color="red"> 415.             (_('salt'), mask_hash(salt, show=2)),</font>
<font color="red"> 416.             (_('hash'), mask_hash(hash)),</font>
<font color="black"> 417.         ])</font>
<font color="black"> 418. </font>
<font color="black"> 419. </font>
<font color="green"> 420. class UnsaltedSHA1PasswordHasher(BasePasswordHasher):</font>
<font color="black"> 421.     &quot;&quot;&quot;</font>
<font color="black"> 422.     Very insecure algorithm that you should *never* use; stores SHA1 hashes</font>
<font color="black"> 423.     with an empty salt.</font>
<font color="black"> 424. </font>
<font color="black"> 425.     This class is implemented because Django used to accept such password</font>
<font color="black"> 426.     hashes. Some older Django installs still have these values lingering</font>
<font color="black"> 427.     around so we need to handle and upgrade them properly.</font>
<font color="green"> 428.     &quot;&quot;&quot;</font>
<font color="green"> 429.     algorithm = &quot;unsalted_sha1&quot;</font>
<font color="black"> 430. </font>
<font color="green"> 431.     def salt(self):</font>
<font color="red"> 432.         return ''</font>
<font color="black"> 433. </font>
<font color="green"> 434.     def encode(self, password, salt):</font>
<font color="red"> 435.         assert salt == ''</font>
<font color="red"> 436.         hash = hashlib.sha1(force_bytes(password)).hexdigest()</font>
<font color="red"> 437.         return 'sha1$$%s' % hash</font>
<font color="black"> 438. </font>
<font color="green"> 439.     def verify(self, password, encoded):</font>
<font color="red"> 440.         encoded_2 = self.encode(password, '')</font>
<font color="red"> 441.         return constant_time_compare(encoded, encoded_2)</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def safe_summary(self, encoded):</font>
<font color="red"> 444.         assert encoded.startswith('sha1$$')</font>
<font color="red"> 445.         hash = encoded[6:]</font>
<font color="red"> 446.         return OrderedDict([</font>
<font color="red"> 447.             (_('algorithm'), self.algorithm),</font>
<font color="red"> 448.             (_('hash'), mask_hash(hash)),</font>
<font color="black"> 449.         ])</font>
<font color="black"> 450. </font>
<font color="black"> 451. </font>
<font color="green"> 452. class UnsaltedMD5PasswordHasher(BasePasswordHasher):</font>
<font color="black"> 453.     &quot;&quot;&quot;</font>
<font color="black"> 454.     Incredibly insecure algorithm that you should *never* use; stores unsalted</font>
<font color="black"> 455.     MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an</font>
<font color="black"> 456.     empty salt.</font>
<font color="black"> 457. </font>
<font color="black"> 458.     This class is implemented because Django used to store passwords this way</font>
<font color="black"> 459.     and to accept such password hashes. Some older Django installs still have</font>
<font color="black"> 460.     these values lingering around so we need to handle and upgrade them</font>
<font color="black"> 461.     properly.</font>
<font color="green"> 462.     &quot;&quot;&quot;</font>
<font color="green"> 463.     algorithm = &quot;unsalted_md5&quot;</font>
<font color="black"> 464. </font>
<font color="green"> 465.     def salt(self):</font>
<font color="red"> 466.         return ''</font>
<font color="black"> 467. </font>
<font color="green"> 468.     def encode(self, password, salt):</font>
<font color="red"> 469.         assert salt == ''</font>
<font color="red"> 470.         return hashlib.md5(force_bytes(password)).hexdigest()</font>
<font color="black"> 471. </font>
<font color="green"> 472.     def verify(self, password, encoded):</font>
<font color="red"> 473.         if len(encoded) == 37 and encoded.startswith('md5$$'):</font>
<font color="red"> 474.             encoded = encoded[5:]</font>
<font color="red"> 475.         encoded_2 = self.encode(password, '')</font>
<font color="red"> 476.         return constant_time_compare(encoded, encoded_2)</font>
<font color="black"> 477. </font>
<font color="green"> 478.     def safe_summary(self, encoded):</font>
<font color="red"> 479.         return OrderedDict([</font>
<font color="red"> 480.             (_('algorithm'), self.algorithm),</font>
<font color="red"> 481.             (_('hash'), mask_hash(encoded, show=3)),</font>
<font color="black"> 482.         ])</font>
<font color="black"> 483. </font>
<font color="black"> 484. </font>
<font color="green"> 485. class CryptPasswordHasher(BasePasswordHasher):</font>
<font color="black"> 486.     &quot;&quot;&quot;</font>
<font color="black"> 487.     Password hashing using UNIX crypt (not recommended)</font>
<font color="black"> 488. </font>
<font color="black"> 489.     The crypt module is not supported on all platforms.</font>
<font color="green"> 490.     &quot;&quot;&quot;</font>
<font color="green"> 491.     algorithm = &quot;crypt&quot;</font>
<font color="green"> 492.     library = &quot;crypt&quot;</font>
<font color="black"> 493. </font>
<font color="green"> 494.     def salt(self):</font>
<font color="red"> 495.         return get_random_string(2)</font>
<font color="black"> 496. </font>
<font color="green"> 497.     def encode(self, password, salt):</font>
<font color="red"> 498.         crypt = self._load_library()</font>
<font color="red"> 499.         assert len(salt) == 2</font>
<font color="red"> 500.         data = crypt.crypt(force_str(password), salt)</font>
<font color="black"> 501.         # we don't need to store the salt, but Django used to do this</font>
<font color="red"> 502.         return &quot;%s$%s$%s&quot; % (self.algorithm, '', data)</font>
<font color="black"> 503. </font>
<font color="green"> 504.     def verify(self, password, encoded):</font>
<font color="red"> 505.         crypt = self._load_library()</font>
<font color="red"> 506.         algorithm, salt, data = encoded.split('$', 2)</font>
<font color="red"> 507.         assert algorithm == self.algorithm</font>
<font color="red"> 508.         return constant_time_compare(data, crypt.crypt(force_str(password), data))</font>
<font color="black"> 509. </font>
<font color="green"> 510.     def safe_summary(self, encoded):</font>
<font color="red"> 511.         algorithm, salt, data = encoded.split('$', 2)</font>
<font color="red"> 512.         assert algorithm == self.algorithm</font>
<font color="red"> 513.         return OrderedDict([</font>
<font color="red"> 514.             (_('algorithm'), algorithm),</font>
<font color="red"> 515.             (_('salt'), salt),</font>
<font color="red"> 516.             (_('hash'), mask_hash(data, show=3)),</font>
<font color="black"> 517.         ])</font>
</pre>

