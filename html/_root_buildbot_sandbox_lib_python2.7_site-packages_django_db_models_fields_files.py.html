source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/fields/files.py</b><br>


file stats: <b>274 lines, 82 executed: 29.9% covered</b>
<pre>
<font color="green">   1. import datetime</font>
<font color="green">   2. import os</font>
<font color="green">   3. import warnings</font>
<font color="black">   4. </font>
<font color="green">   5. from django import forms</font>
<font color="green">   6. from django.core import checks</font>
<font color="green">   7. from django.core.files.base import File</font>
<font color="green">   8. from django.core.files.images import ImageFile</font>
<font color="green">   9. from django.core.files.storage import default_storage</font>
<font color="green">  10. from django.db.models import signals</font>
<font color="green">  11. from django.db.models.fields import Field</font>
<font color="green">  12. from django.utils import six</font>
<font color="green">  13. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  14. from django.utils.encoding import force_str, force_text</font>
<font color="green">  15. from django.utils.inspect import func_supports_parameter</font>
<font color="green">  16. from django.utils.translation import ugettext_lazy as _</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. class FieldFile(File):</font>
<font color="green">  20.     def __init__(self, instance, field, name):</font>
<font color="red">  21.         super(FieldFile, self).__init__(None, name)</font>
<font color="red">  22.         self.instance = instance</font>
<font color="red">  23.         self.field = field</font>
<font color="red">  24.         self.storage = field.storage</font>
<font color="red">  25.         self._committed = True</font>
<font color="black">  26. </font>
<font color="green">  27.     def __eq__(self, other):</font>
<font color="black">  28.         # Older code may be expecting FileField values to be simple strings.</font>
<font color="black">  29.         # By overriding the == operator, it can remain backwards compatibility.</font>
<font color="red">  30.         if hasattr(other, 'name'):</font>
<font color="red">  31.             return self.name == other.name</font>
<font color="red">  32.         return self.name == other</font>
<font color="black">  33. </font>
<font color="green">  34.     def __ne__(self, other):</font>
<font color="red">  35.         return not self.__eq__(other)</font>
<font color="black">  36. </font>
<font color="green">  37.     def __hash__(self):</font>
<font color="red">  38.         return hash(self.name)</font>
<font color="black">  39. </font>
<font color="black">  40.     # The standard File contains most of the necessary properties, but</font>
<font color="black">  41.     # FieldFiles can be instantiated without a name, so that needs to</font>
<font color="black">  42.     # be checked for here.</font>
<font color="black">  43. </font>
<font color="green">  44.     def _require_file(self):</font>
<font color="red">  45.         if not self:</font>
<font color="red">  46.             raise ValueError(&quot;The '%s' attribute has no file associated with it.&quot; % self.field.name)</font>
<font color="black">  47. </font>
<font color="green">  48.     def _get_file(self):</font>
<font color="red">  49.         self._require_file()</font>
<font color="red">  50.         if not hasattr(self, '_file') or self._file is None:</font>
<font color="red">  51.             self._file = self.storage.open(self.name, 'rb')</font>
<font color="red">  52.         return self._file</font>
<font color="black">  53. </font>
<font color="green">  54.     def _set_file(self, file):</font>
<font color="red">  55.         self._file = file</font>
<font color="black">  56. </font>
<font color="green">  57.     def _del_file(self):</font>
<font color="red">  58.         del self._file</font>
<font color="black">  59. </font>
<font color="green">  60.     file = property(_get_file, _set_file, _del_file)</font>
<font color="black">  61. </font>
<font color="green">  62.     def _get_path(self):</font>
<font color="red">  63.         self._require_file()</font>
<font color="red">  64.         return self.storage.path(self.name)</font>
<font color="green">  65.     path = property(_get_path)</font>
<font color="black">  66. </font>
<font color="green">  67.     def _get_url(self):</font>
<font color="red">  68.         self._require_file()</font>
<font color="red">  69.         return self.storage.url(self.name)</font>
<font color="green">  70.     url = property(_get_url)</font>
<font color="black">  71. </font>
<font color="green">  72.     def _get_size(self):</font>
<font color="red">  73.         self._require_file()</font>
<font color="red">  74.         if not self._committed:</font>
<font color="red">  75.             return self.file.size</font>
<font color="red">  76.         return self.storage.size(self.name)</font>
<font color="green">  77.     size = property(_get_size)</font>
<font color="black">  78. </font>
<font color="green">  79.     def open(self, mode='rb'):</font>
<font color="red">  80.         self._require_file()</font>
<font color="red">  81.         self.file.open(mode)</font>
<font color="black">  82.     # open() doesn't alter the file's contents, but it does reset the pointer</font>
<font color="green">  83.     open.alters_data = True</font>
<font color="black">  84. </font>
<font color="black">  85.     # In addition to the standard File API, FieldFiles have extra methods</font>
<font color="black">  86.     # to further manipulate the underlying file, as well as update the</font>
<font color="black">  87.     # associated model instance.</font>
<font color="black">  88. </font>
<font color="green">  89.     def save(self, name, content, save=True):</font>
<font color="red">  90.         name = self.field.generate_filename(self.instance, name)</font>
<font color="black">  91. </font>
<font color="red">  92.         if func_supports_parameter(self.storage.save, 'max_length'):</font>
<font color="red">  93.             self.name = self.storage.save(name, content, max_length=self.field.max_length)</font>
<font color="black">  94.         else:</font>
<font color="red">  95.             warnings.warn(</font>
<font color="red">  96.                 'Backwards compatibility for storage backends without '</font>
<font color="black">  97.                 'support for the `max_length` argument in '</font>
<font color="black">  98.                 'Storage.save() will be removed in Django 1.10.',</font>
<font color="red">  99.                 RemovedInDjango110Warning, stacklevel=2</font>
<font color="black"> 100.             )</font>
<font color="red"> 101.             self.name = self.storage.save(name, content)</font>
<font color="black"> 102. </font>
<font color="red"> 103.         setattr(self.instance, self.field.name, self.name)</font>
<font color="black"> 104. </font>
<font color="black"> 105.         # Update the filesize cache</font>
<font color="red"> 106.         self._size = content.size</font>
<font color="red"> 107.         self._committed = True</font>
<font color="black"> 108. </font>
<font color="black"> 109.         # Save the object because it has changed, unless save is False</font>
<font color="red"> 110.         if save:</font>
<font color="red"> 111.             self.instance.save()</font>
<font color="green"> 112.     save.alters_data = True</font>
<font color="black"> 113. </font>
<font color="green"> 114.     def delete(self, save=True):</font>
<font color="red"> 115.         if not self:</font>
<font color="red"> 116.             return</font>
<font color="black"> 117.         # Only close the file if it's already open, which we know by the</font>
<font color="black"> 118.         # presence of self._file</font>
<font color="red"> 119.         if hasattr(self, '_file'):</font>
<font color="red"> 120.             self.close()</font>
<font color="red"> 121.             del self.file</font>
<font color="black"> 122. </font>
<font color="red"> 123.         self.storage.delete(self.name)</font>
<font color="black"> 124. </font>
<font color="red"> 125.         self.name = None</font>
<font color="red"> 126.         setattr(self.instance, self.field.name, self.name)</font>
<font color="black"> 127. </font>
<font color="black"> 128.         # Delete the filesize cache</font>
<font color="red"> 129.         if hasattr(self, '_size'):</font>
<font color="red"> 130.             del self._size</font>
<font color="red"> 131.         self._committed = False</font>
<font color="black"> 132. </font>
<font color="red"> 133.         if save:</font>
<font color="red"> 134.             self.instance.save()</font>
<font color="green"> 135.     delete.alters_data = True</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def _get_closed(self):</font>
<font color="red"> 138.         file = getattr(self, '_file', None)</font>
<font color="red"> 139.         return file is None or file.closed</font>
<font color="green"> 140.     closed = property(_get_closed)</font>
<font color="black"> 141. </font>
<font color="green"> 142.     def close(self):</font>
<font color="red"> 143.         file = getattr(self, '_file', None)</font>
<font color="red"> 144.         if file is not None:</font>
<font color="red"> 145.             file.close()</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def __getstate__(self):</font>
<font color="black"> 148.         # FieldFile needs access to its associated model field and an instance</font>
<font color="black"> 149.         # it's attached to in order to work properly, but the only necessary</font>
<font color="black"> 150.         # data to be pickled is the file's name itself. Everything else will</font>
<font color="black"> 151.         # be restored later, by FileDescriptor below.</font>
<font color="red"> 152.         return {'name': self.name, 'closed': False, '_committed': True, '_file': None}</font>
<font color="black"> 153. </font>
<font color="black"> 154. </font>
<font color="green"> 155. class FileDescriptor(object):</font>
<font color="black"> 156.     &quot;&quot;&quot;</font>
<font color="black"> 157.     The descriptor for the file attribute on the model instance. Returns a</font>
<font color="black"> 158.     FieldFile when accessed so you can do stuff like::</font>
<font color="black"> 159. </font>
<font color="black"> 160.         &gt;&gt;&gt; from myapp.models import MyModel</font>
<font color="black"> 161.         &gt;&gt;&gt; instance = MyModel.objects.get(pk=1)</font>
<font color="black"> 162.         &gt;&gt;&gt; instance.file.size</font>
<font color="black"> 163. </font>
<font color="black"> 164.     Assigns a file object on assignment so you can do::</font>
<font color="black"> 165. </font>
<font color="black"> 166.         &gt;&gt;&gt; with open('/tmp/hello.world', 'r') as f:</font>
<font color="black"> 167.         ...     instance.file = File(f)</font>
<font color="green"> 168.     &quot;&quot;&quot;</font>
<font color="green"> 169.     def __init__(self, field):</font>
<font color="red"> 170.         self.field = field</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def __get__(self, instance=None, owner=None):</font>
<font color="red"> 173.         if instance is None:</font>
<font color="red"> 174.             raise AttributeError(</font>
<font color="red"> 175.                 &quot;The '%s' attribute can only be accessed from %s instances.&quot;</font>
<font color="red"> 176.                 % (self.field.name, owner.__name__))</font>
<font color="black"> 177. </font>
<font color="black"> 178.         # This is slightly complicated, so worth an explanation.</font>
<font color="black"> 179.         # instance.file`needs to ultimately return some instance of `File`,</font>
<font color="black"> 180.         # probably a subclass. Additionally, this returned object needs to have</font>
<font color="black"> 181.         # the FieldFile API so that users can easily do things like</font>
<font color="black"> 182.         # instance.file.path and have that delegated to the file storage engine.</font>
<font color="black"> 183.         # Easy enough if we're strict about assignment in __set__, but if you</font>
<font color="black"> 184.         # peek below you can see that we're not. So depending on the current</font>
<font color="black"> 185.         # value of the field we have to dynamically construct some sort of</font>
<font color="black"> 186.         # &quot;thing&quot; to return.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         # The instance dict contains whatever was originally assigned</font>
<font color="black"> 189.         # in __set__.</font>
<font color="red"> 190.         file = instance.__dict__[self.field.name]</font>
<font color="black"> 191. </font>
<font color="black"> 192.         # If this value is a string (instance.file = &quot;path/to/file&quot;) or None</font>
<font color="black"> 193.         # then we simply wrap it with the appropriate attribute class according</font>
<font color="black"> 194.         # to the file field. [This is FieldFile for FileFields and</font>
<font color="black"> 195.         # ImageFieldFile for ImageFields; it's also conceivable that user</font>
<font color="black"> 196.         # subclasses might also want to subclass the attribute class]. This</font>
<font color="black"> 197.         # object understands how to convert a path to a file, and also how to</font>
<font color="black"> 198.         # handle None.</font>
<font color="red"> 199.         if isinstance(file, six.string_types) or file is None:</font>
<font color="red"> 200.             attr = self.field.attr_class(instance, self.field, file)</font>
<font color="red"> 201.             instance.__dict__[self.field.name] = attr</font>
<font color="black"> 202. </font>
<font color="black"> 203.         # Other types of files may be assigned as well, but they need to have</font>
<font color="black"> 204.         # the FieldFile interface added to them. Thus, we wrap any other type of</font>
<font color="black"> 205.         # File inside a FieldFile (well, the field's attr_class, which is</font>
<font color="black"> 206.         # usually FieldFile).</font>
<font color="red"> 207.         elif isinstance(file, File) and not isinstance(file, FieldFile):</font>
<font color="red"> 208.             file_copy = self.field.attr_class(instance, self.field, file.name)</font>
<font color="red"> 209.             file_copy.file = file</font>
<font color="red"> 210.             file_copy._committed = False</font>
<font color="red"> 211.             instance.__dict__[self.field.name] = file_copy</font>
<font color="black"> 212. </font>
<font color="black"> 213.         # Finally, because of the (some would say boneheaded) way pickle works,</font>
<font color="black"> 214.         # the underlying FieldFile might not actually itself have an associated</font>
<font color="black"> 215.         # file. So we need to reset the details of the FieldFile in those cases.</font>
<font color="red"> 216.         elif isinstance(file, FieldFile) and not hasattr(file, 'field'):</font>
<font color="red"> 217.             file.instance = instance</font>
<font color="red"> 218.             file.field = self.field</font>
<font color="red"> 219.             file.storage = self.field.storage</font>
<font color="black"> 220. </font>
<font color="black"> 221.         # That was fun, wasn't it?</font>
<font color="red"> 222.         return instance.__dict__[self.field.name]</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def __set__(self, instance, value):</font>
<font color="red"> 225.         instance.__dict__[self.field.name] = value</font>
<font color="black"> 226. </font>
<font color="black"> 227. </font>
<font color="green"> 228. class FileField(Field):</font>
<font color="black"> 229. </font>
<font color="black"> 230.     # The class to wrap instance attributes in. Accessing the file object off</font>
<font color="black"> 231.     # the instance will always return an instance of attr_class.</font>
<font color="green"> 232.     attr_class = FieldFile</font>
<font color="black"> 233. </font>
<font color="black"> 234.     # The descriptor to use for accessing the attribute off of the class.</font>
<font color="green"> 235.     descriptor_class = FileDescriptor</font>
<font color="black"> 236. </font>
<font color="green"> 237.     description = _(&quot;File&quot;)</font>
<font color="black"> 238. </font>
<font color="green"> 239.     def __init__(self, verbose_name=None, name=None, upload_to='', storage=None, **kwargs):</font>
<font color="red"> 240.         self._primary_key_set_explicitly = 'primary_key' in kwargs</font>
<font color="red"> 241.         self._unique_set_explicitly = 'unique' in kwargs</font>
<font color="black"> 242. </font>
<font color="red"> 243.         self.storage = storage or default_storage</font>
<font color="red"> 244.         self.upload_to = upload_to</font>
<font color="black"> 245. </font>
<font color="red"> 246.         kwargs['max_length'] = kwargs.get('max_length', 100)</font>
<font color="red"> 247.         super(FileField, self).__init__(verbose_name, name, **kwargs)</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def check(self, **kwargs):</font>
<font color="red"> 250.         errors = super(FileField, self).check(**kwargs)</font>
<font color="red"> 251.         errors.extend(self._check_unique())</font>
<font color="red"> 252.         errors.extend(self._check_primary_key())</font>
<font color="red"> 253.         return errors</font>
<font color="black"> 254. </font>
<font color="green"> 255.     def _check_unique(self):</font>
<font color="red"> 256.         if self._unique_set_explicitly:</font>
<font color="black"> 257.             return [</font>
<font color="red"> 258.                 checks.Error(</font>
<font color="red"> 259.                     &quot;'unique' is not a valid argument for a %s.&quot; % self.__class__.__name__,</font>
<font color="red"> 260.                     hint=None,</font>
<font color="red"> 261.                     obj=self,</font>
<font color="red"> 262.                     id='fields.E200',</font>
<font color="black"> 263.                 )</font>
<font color="black"> 264.             ]</font>
<font color="black"> 265.         else:</font>
<font color="red"> 266.             return []</font>
<font color="black"> 267. </font>
<font color="green"> 268.     def _check_primary_key(self):</font>
<font color="red"> 269.         if self._primary_key_set_explicitly:</font>
<font color="black"> 270.             return [</font>
<font color="red"> 271.                 checks.Error(</font>
<font color="red"> 272.                     &quot;'primary_key' is not a valid argument for a %s.&quot; % self.__class__.__name__,</font>
<font color="red"> 273.                     hint=None,</font>
<font color="red"> 274.                     obj=self,</font>
<font color="red"> 275.                     id='fields.E201',</font>
<font color="black"> 276.                 )</font>
<font color="black"> 277.             ]</font>
<font color="black"> 278.         else:</font>
<font color="red"> 279.             return []</font>
<font color="black"> 280. </font>
<font color="green"> 281.     def deconstruct(self):</font>
<font color="red"> 282.         name, path, args, kwargs = super(FileField, self).deconstruct()</font>
<font color="red"> 283.         if kwargs.get(&quot;max_length&quot;) == 100:</font>
<font color="red"> 284.             del kwargs[&quot;max_length&quot;]</font>
<font color="red"> 285.         kwargs['upload_to'] = self.upload_to</font>
<font color="red"> 286.         if self.storage is not default_storage:</font>
<font color="red"> 287.             kwargs['storage'] = self.storage</font>
<font color="red"> 288.         return name, path, args, kwargs</font>
<font color="black"> 289. </font>
<font color="green"> 290.     def get_internal_type(self):</font>
<font color="red"> 291.         return &quot;FileField&quot;</font>
<font color="black"> 292. </font>
<font color="green"> 293.     def get_prep_lookup(self, lookup_type, value):</font>
<font color="red"> 294.         if hasattr(value, 'name'):</font>
<font color="red"> 295.             value = value.name</font>
<font color="red"> 296.         return super(FileField, self).get_prep_lookup(lookup_type, value)</font>
<font color="black"> 297. </font>
<font color="green"> 298.     def get_prep_value(self, value):</font>
<font color="black"> 299.         &quot;Returns field's value prepared for saving into a database.&quot;</font>
<font color="red"> 300.         value = super(FileField, self).get_prep_value(value)</font>
<font color="black"> 301.         # Need to convert File objects provided via a form to unicode for database insertion</font>
<font color="red"> 302.         if value is None:</font>
<font color="red"> 303.             return None</font>
<font color="red"> 304.         return six.text_type(value)</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def pre_save(self, model_instance, add):</font>
<font color="black"> 307.         &quot;Returns field's value just before saving.&quot;</font>
<font color="red"> 308.         file = super(FileField, self).pre_save(model_instance, add)</font>
<font color="red"> 309.         if file and not file._committed:</font>
<font color="black"> 310.             # Commit the file to storage prior to saving the model</font>
<font color="red"> 311.             file.save(file.name, file, save=False)</font>
<font color="red"> 312.         return file</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def contribute_to_class(self, cls, name, **kwargs):</font>
<font color="red"> 315.         super(FileField, self).contribute_to_class(cls, name, **kwargs)</font>
<font color="red"> 316.         setattr(cls, self.name, self.descriptor_class(self))</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def get_directory_name(self):</font>
<font color="red"> 319.         return os.path.normpath(force_text(datetime.datetime.now().strftime(force_str(self.upload_to))))</font>
<font color="black"> 320. </font>
<font color="green"> 321.     def get_filename(self, filename):</font>
<font color="red"> 322.         return os.path.normpath(self.storage.get_valid_name(os.path.basename(filename)))</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def generate_filename(self, instance, filename):</font>
<font color="black"> 325.         # If upload_to is a callable, make sure that the path it returns is</font>
<font color="black"> 326.         # passed through get_valid_name() of the underlying storage.</font>
<font color="red"> 327.         if callable(self.upload_to):</font>
<font color="red"> 328.             directory_name, filename = os.path.split(self.upload_to(instance, filename))</font>
<font color="red"> 329.             filename = self.storage.get_valid_name(filename)</font>
<font color="red"> 330.             return os.path.normpath(os.path.join(directory_name, filename))</font>
<font color="black"> 331. </font>
<font color="red"> 332.         return os.path.join(self.get_directory_name(), self.get_filename(filename))</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def save_form_data(self, instance, data):</font>
<font color="black"> 335.         # Important: None means &quot;no change&quot;, other false value means &quot;clear&quot;</font>
<font color="black"> 336.         # This subtle distinction (rather than a more explicit marker) is</font>
<font color="black"> 337.         # needed because we need to consume values that are also sane for a</font>
<font color="black"> 338.         # regular (non Model-) Form to find in its cleaned_data dictionary.</font>
<font color="red"> 339.         if data is not None:</font>
<font color="black"> 340.             # This value will be converted to unicode and stored in the</font>
<font color="black"> 341.             # database, so leaving False as-is is not acceptable.</font>
<font color="red"> 342.             if not data:</font>
<font color="red"> 343.                 data = ''</font>
<font color="red"> 344.             setattr(instance, self.name, data)</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def formfield(self, **kwargs):</font>
<font color="red"> 347.         defaults = {'form_class': forms.FileField, 'max_length': self.max_length}</font>
<font color="black"> 348.         # If a file has been provided previously, then the form doesn't require</font>
<font color="black"> 349.         # that a new file is provided this time.</font>
<font color="black"> 350.         # The code to mark the form field as not required is used by</font>
<font color="black"> 351.         # form_for_instance, but can probably be removed once form_for_instance</font>
<font color="black"> 352.         # is gone. ModelForm uses a different method to check for an existing file.</font>
<font color="red"> 353.         if 'initial' in kwargs:</font>
<font color="red"> 354.             defaults['required'] = False</font>
<font color="red"> 355.         defaults.update(kwargs)</font>
<font color="red"> 356.         return super(FileField, self).formfield(**defaults)</font>
<font color="black"> 357. </font>
<font color="black"> 358. </font>
<font color="green"> 359. class ImageFileDescriptor(FileDescriptor):</font>
<font color="black"> 360.     &quot;&quot;&quot;</font>
<font color="black"> 361.     Just like the FileDescriptor, but for ImageFields. The only difference is</font>
<font color="black"> 362.     assigning the width/height to the width_field/height_field, if appropriate.</font>
<font color="green"> 363.     &quot;&quot;&quot;</font>
<font color="green"> 364.     def __set__(self, instance, value):</font>
<font color="red"> 365.         previous_file = instance.__dict__.get(self.field.name)</font>
<font color="red"> 366.         super(ImageFileDescriptor, self).__set__(instance, value)</font>
<font color="black"> 367. </font>
<font color="black"> 368.         # To prevent recalculating image dimensions when we are instantiating</font>
<font color="black"> 369.         # an object from the database (bug #11084), only update dimensions if</font>
<font color="black"> 370.         # the field had a value before this assignment.  Since the default</font>
<font color="black"> 371.         # value for FileField subclasses is an instance of field.attr_class,</font>
<font color="black"> 372.         # previous_file will only be None when we are called from</font>
<font color="black"> 373.         # Model.__init__().  The ImageField.update_dimension_fields method</font>
<font color="black"> 374.         # hooked up to the post_init signal handles the Model.__init__() cases.</font>
<font color="black"> 375.         # Assignment happening outside of Model.__init__() will trigger the</font>
<font color="black"> 376.         # update right here.</font>
<font color="red"> 377.         if previous_file is not None:</font>
<font color="red"> 378.             self.field.update_dimension_fields(instance, force=True)</font>
<font color="black"> 379. </font>
<font color="black"> 380. </font>
<font color="green"> 381. class ImageFieldFile(ImageFile, FieldFile):</font>
<font color="green"> 382.     def delete(self, save=True):</font>
<font color="black"> 383.         # Clear the image dimensions cache</font>
<font color="red"> 384.         if hasattr(self, '_dimensions_cache'):</font>
<font color="red"> 385.             del self._dimensions_cache</font>
<font color="red"> 386.         super(ImageFieldFile, self).delete(save)</font>
<font color="black"> 387. </font>
<font color="black"> 388. </font>
<font color="green"> 389. class ImageField(FileField):</font>
<font color="green"> 390.     attr_class = ImageFieldFile</font>
<font color="green"> 391.     descriptor_class = ImageFileDescriptor</font>
<font color="green"> 392.     description = _(&quot;Image&quot;)</font>
<font color="black"> 393. </font>
<font color="green"> 394.     def __init__(self, verbose_name=None, name=None, width_field=None,</font>
<font color="green"> 395.             height_field=None, **kwargs):</font>
<font color="red"> 396.         self.width_field, self.height_field = width_field, height_field</font>
<font color="red"> 397.         super(ImageField, self).__init__(verbose_name, name, **kwargs)</font>
<font color="black"> 398. </font>
<font color="green"> 399.     def check(self, **kwargs):</font>
<font color="red"> 400.         errors = super(ImageField, self).check(**kwargs)</font>
<font color="red"> 401.         errors.extend(self._check_image_library_installed())</font>
<font color="red"> 402.         return errors</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def _check_image_library_installed(self):</font>
<font color="red"> 405.         try:</font>
<font color="red"> 406.             from PIL import Image  # NOQA</font>
<font color="red"> 407.         except ImportError:</font>
<font color="black"> 408.             return [</font>
<font color="red"> 409.                 checks.Error(</font>
<font color="red"> 410.                     'Cannot use ImageField because Pillow is not installed.',</font>
<font color="red"> 411.                     hint=('Get Pillow at https://pypi.python.org/pypi/Pillow '</font>
<font color="black"> 412.                           'or run command &quot;pip install Pillow&quot;.'),</font>
<font color="red"> 413.                     obj=self,</font>
<font color="red"> 414.                     id='fields.E210',</font>
<font color="black"> 415.                 )</font>
<font color="black"> 416.             ]</font>
<font color="black"> 417.         else:</font>
<font color="red"> 418.             return []</font>
<font color="black"> 419. </font>
<font color="green"> 420.     def deconstruct(self):</font>
<font color="red"> 421.         name, path, args, kwargs = super(ImageField, self).deconstruct()</font>
<font color="red"> 422.         if self.width_field:</font>
<font color="red"> 423.             kwargs['width_field'] = self.width_field</font>
<font color="red"> 424.         if self.height_field:</font>
<font color="red"> 425.             kwargs['height_field'] = self.height_field</font>
<font color="red"> 426.         return name, path, args, kwargs</font>
<font color="black"> 427. </font>
<font color="green"> 428.     def contribute_to_class(self, cls, name, **kwargs):</font>
<font color="red"> 429.         super(ImageField, self).contribute_to_class(cls, name, **kwargs)</font>
<font color="black"> 430.         # Attach update_dimension_fields so that dimension fields declared</font>
<font color="black"> 431.         # after their corresponding image field don't stay cleared by</font>
<font color="black"> 432.         # Model.__init__, see bug #11196.</font>
<font color="black"> 433.         # Only run post-initialization dimension update on non-abstract models</font>
<font color="red"> 434.         if not cls._meta.abstract:</font>
<font color="red"> 435.             signals.post_init.connect(self.update_dimension_fields, sender=cls)</font>
<font color="black"> 436. </font>
<font color="green"> 437.     def update_dimension_fields(self, instance, force=False, *args, **kwargs):</font>
<font color="black"> 438.         &quot;&quot;&quot;</font>
<font color="black"> 439.         Updates field's width and height fields, if defined.</font>
<font color="black"> 440. </font>
<font color="black"> 441.         This method is hooked up to model's post_init signal to update</font>
<font color="black"> 442.         dimensions after instantiating a model instance.  However, dimensions</font>
<font color="black"> 443.         won't be updated if the dimensions fields are already populated.  This</font>
<font color="black"> 444.         avoids unnecessary recalculation when loading an object from the</font>
<font color="black"> 445.         database.</font>
<font color="black"> 446. </font>
<font color="black"> 447.         Dimensions can be forced to update with force=True, which is how</font>
<font color="black"> 448.         ImageFileDescriptor.__set__ calls this method.</font>
<font color="black"> 449.         &quot;&quot;&quot;</font>
<font color="black"> 450.         # Nothing to update if the field doesn't have dimension fields.</font>
<font color="red"> 451.         has_dimension_fields = self.width_field or self.height_field</font>
<font color="red"> 452.         if not has_dimension_fields:</font>
<font color="red"> 453.             return</font>
<font color="black"> 454. </font>
<font color="black"> 455.         # getattr will call the ImageFileDescriptor's __get__ method, which</font>
<font color="black"> 456.         # coerces the assigned value into an instance of self.attr_class</font>
<font color="black"> 457.         # (ImageFieldFile in this case).</font>
<font color="red"> 458.         file = getattr(instance, self.attname)</font>
<font color="black"> 459. </font>
<font color="black"> 460.         # Nothing to update if we have no file and not being forced to update.</font>
<font color="red"> 461.         if not file and not force:</font>
<font color="red"> 462.             return</font>
<font color="black"> 463. </font>
<font color="black"> 464.         dimension_fields_filled = not(</font>
<font color="red"> 465.             (self.width_field and not getattr(instance, self.width_field))</font>
<font color="red"> 466.             or (self.height_field and not getattr(instance, self.height_field))</font>
<font color="black"> 467.         )</font>
<font color="black"> 468.         # When both dimension fields have values, we are most likely loading</font>
<font color="black"> 469.         # data from the database or updating an image field that already had</font>
<font color="black"> 470.         # an image stored.  In the first case, we don't want to update the</font>
<font color="black"> 471.         # dimension fields because we are already getting their values from the</font>
<font color="black"> 472.         # database.  In the second case, we do want to update the dimensions</font>
<font color="black"> 473.         # fields and will skip this return because force will be True since we</font>
<font color="black"> 474.         # were called from ImageFileDescriptor.__set__.</font>
<font color="red"> 475.         if dimension_fields_filled and not force:</font>
<font color="red"> 476.             return</font>
<font color="black"> 477. </font>
<font color="black"> 478.         # file should be an instance of ImageFieldFile or should be None.</font>
<font color="red"> 479.         if file:</font>
<font color="red"> 480.             width = file.width</font>
<font color="red"> 481.             height = file.height</font>
<font color="black"> 482.         else:</font>
<font color="black"> 483.             # No file, so clear dimensions fields.</font>
<font color="red"> 484.             width = None</font>
<font color="red"> 485.             height = None</font>
<font color="black"> 486. </font>
<font color="black"> 487.         # Update the width and height fields.</font>
<font color="red"> 488.         if self.width_field:</font>
<font color="red"> 489.             setattr(instance, self.width_field, width)</font>
<font color="red"> 490.         if self.height_field:</font>
<font color="red"> 491.             setattr(instance, self.height_field, height)</font>
<font color="black"> 492. </font>
<font color="green"> 493.     def formfield(self, **kwargs):</font>
<font color="red"> 494.         defaults = {'form_class': forms.ImageField}</font>
<font color="red"> 495.         defaults.update(kwargs)</font>
<font color="red"> 496.         return super(ImageField, self).formfield(**defaults)</font>
</pre>

