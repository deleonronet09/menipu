source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/sql/query.py</b><br>


file stats: <b>1131 lines, 463 executed: 40.9% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Create SQL statements for QuerySets.</font>
<font color="black">   3. </font>
<font color="black">   4. The code in here encapsulates all of the SQL construction so that QuerySets</font>
<font color="black">   5. themselves do not have to (and could be backed by things other than SQL</font>
<font color="black">   6. databases). The abstraction barrier only works one way: this module has to know</font>
<font color="black">   7. all about the internals of models in order to get the information it needs.</font>
<font color="green">   8. &quot;&quot;&quot;</font>
<font color="green">   9. import copy</font>
<font color="green">  10. import warnings</font>
<font color="green">  11. from collections import Counter, Iterator, Mapping, OrderedDict</font>
<font color="green">  12. from itertools import chain, count, product</font>
<font color="green">  13. from string import ascii_uppercase</font>
<font color="black">  14. </font>
<font color="green">  15. from django.core.exceptions import FieldDoesNotExist, FieldError</font>
<font color="green">  16. from django.db import DEFAULT_DB_ALIAS, connections</font>
<font color="green">  17. from django.db.models.aggregates import Count</font>
<font color="green">  18. from django.db.models.constants import LOOKUP_SEP</font>
<font color="green">  19. from django.db.models.expressions import Col, Ref</font>
<font color="green">  20. from django.db.models.fields.related_lookups import MultiColSource</font>
<font color="green">  21. from django.db.models.query_utils import (</font>
<font color="black">  22.     Q, PathInfo, check_rel_lookup_compatibility, refs_expression,</font>
<font color="black">  23. )</font>
<font color="green">  24. from django.db.models.sql.constants import (</font>
<font color="black">  25.     INNER, LOUTER, ORDER_DIR, ORDER_PATTERN, QUERY_TERMS, SINGLE,</font>
<font color="black">  26. )</font>
<font color="green">  27. from django.db.models.sql.datastructures import (</font>
<font color="black">  28.     BaseTable, Empty, EmptyResultSet, Join, MultiJoin,</font>
<font color="black">  29. )</font>
<font color="green">  30. from django.db.models.sql.where import (</font>
<font color="black">  31.     AND, OR, ExtraWhere, NothingNode, WhereNode,</font>
<font color="black">  32. )</font>
<font color="green">  33. from django.utils import six</font>
<font color="green">  34. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  35. from django.utils.encoding import force_text</font>
<font color="green">  36. from django.utils.tree import Node</font>
<font color="black">  37. </font>
<font color="green">  38. __all__ = ['Query', 'RawQuery']</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. def get_field_names_from_opts(opts):</font>
<font color="red">  42.     return set(chain.from_iterable(</font>
<font color="red">  43.         (f.name, f.attname) if f.concrete else (f.name,)</font>
<font color="red">  44.         for f in opts.get_fields()</font>
<font color="black">  45.     ))</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. class RawQuery(object):</font>
<font color="black">  49.     &quot;&quot;&quot;</font>
<font color="black">  50.     A single raw SQL query</font>
<font color="green">  51.     &quot;&quot;&quot;</font>
<font color="black">  52. </font>
<font color="green">  53.     def __init__(self, sql, using, params=None, context=None):</font>
<font color="red">  54.         self.params = params or ()</font>
<font color="red">  55.         self.sql = sql</font>
<font color="red">  56.         self.using = using</font>
<font color="red">  57.         self.cursor = None</font>
<font color="black">  58. </font>
<font color="black">  59.         # Mirror some properties of a normal query so that</font>
<font color="black">  60.         # the compiler can be used to process results.</font>
<font color="red">  61.         self.low_mark, self.high_mark = 0, None  # Used for offset/limit</font>
<font color="red">  62.         self.extra_select = {}</font>
<font color="red">  63.         self.annotation_select = {}</font>
<font color="red">  64.         self.context = context or {}</font>
<font color="black">  65. </font>
<font color="green">  66.     def clone(self, using):</font>
<font color="red">  67.         return RawQuery(self.sql, using, params=self.params, context=self.context.copy())</font>
<font color="black">  68. </font>
<font color="green">  69.     def get_columns(self):</font>
<font color="red">  70.         if self.cursor is None:</font>
<font color="red">  71.             self._execute_query()</font>
<font color="red">  72.         converter = connections[self.using].introspection.column_name_converter</font>
<font color="red">  73.         return [converter(column_meta[0])</font>
<font color="red">  74.                 for column_meta in self.cursor.description]</font>
<font color="black">  75. </font>
<font color="green">  76.     def __iter__(self):</font>
<font color="black">  77.         # Always execute a new query for a new iterator.</font>
<font color="black">  78.         # This could be optimized with a cache at the expense of RAM.</font>
<font color="red">  79.         self._execute_query()</font>
<font color="red">  80.         if not connections[self.using].features.can_use_chunked_reads:</font>
<font color="black">  81.             # If the database can't use chunked reads we need to make sure we</font>
<font color="black">  82.             # evaluate the entire query up front.</font>
<font color="red">  83.             result = list(self.cursor)</font>
<font color="black">  84.         else:</font>
<font color="red">  85.             result = self.cursor</font>
<font color="red">  86.         return iter(result)</font>
<font color="black">  87. </font>
<font color="green">  88.     def __repr__(self):</font>
<font color="red">  89.         return &quot;&lt;RawQuery: %s&gt;&quot; % self</font>
<font color="black">  90. </font>
<font color="green">  91.     @property</font>
<font color="black">  92.     def params_type(self):</font>
<font color="red">  93.         return dict if isinstance(self.params, Mapping) else tuple</font>
<font color="black">  94. </font>
<font color="green">  95.     def __str__(self):</font>
<font color="red">  96.         return self.sql % self.params_type(self.params)</font>
<font color="black">  97. </font>
<font color="green">  98.     def _execute_query(self):</font>
<font color="red">  99.         connection = connections[self.using]</font>
<font color="black"> 100. </font>
<font color="black"> 101.         # Adapt parameters to the database, as much as possible considering</font>
<font color="black"> 102.         # that the target type isn't known. See #17755.</font>
<font color="red"> 103.         params_type = self.params_type</font>
<font color="red"> 104.         adapter = connection.ops.adapt_unknown_value</font>
<font color="red"> 105.         if params_type is tuple:</font>
<font color="red"> 106.             params = tuple(adapter(val) for val in self.params)</font>
<font color="red"> 107.         elif params_type is dict:</font>
<font color="red"> 108.             params = dict((key, adapter(val)) for key, val in six.iteritems(self.params))</font>
<font color="black"> 109.         else:</font>
<font color="red"> 110.             raise RuntimeError(&quot;Unexpected params type: %s&quot; % params_type)</font>
<font color="black"> 111. </font>
<font color="red"> 112.         self.cursor = connection.cursor()</font>
<font color="red"> 113.         self.cursor.execute(self.sql, params)</font>
<font color="black"> 114. </font>
<font color="black"> 115. </font>
<font color="green"> 116. class Query(object):</font>
<font color="black"> 117.     &quot;&quot;&quot;</font>
<font color="black"> 118.     A single SQL query.</font>
<font color="green"> 119.     &quot;&quot;&quot;</font>
<font color="black"> 120. </font>
<font color="green"> 121.     alias_prefix = 'T'</font>
<font color="green"> 122.     subq_aliases = frozenset([alias_prefix])</font>
<font color="green"> 123.     query_terms = QUERY_TERMS</font>
<font color="black"> 124. </font>
<font color="green"> 125.     compiler = 'SQLCompiler'</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def __init__(self, model, where=WhereNode):</font>
<font color="green"> 128.         self.model = model</font>
<font color="green"> 129.         self.alias_refcount = {}</font>
<font color="black"> 130.         # alias_map is the most important data structure regarding joins.</font>
<font color="black"> 131.         # It's used for recording which joins exist in the query and what</font>
<font color="black"> 132.         # types they are. The key is the alias of the joined table (possibly</font>
<font color="black"> 133.         # the table name) and the value is a Join-like object (see</font>
<font color="black"> 134.         # sql.datastructures.Join for more information).</font>
<font color="green"> 135.         self.alias_map = {}</font>
<font color="black"> 136.         # Sometimes the query contains references to aliases in outer queries (as</font>
<font color="black"> 137.         # a result of split_exclude). Correct alias quoting needs to know these</font>
<font color="black"> 138.         # aliases too.</font>
<font color="green"> 139.         self.external_aliases = set()</font>
<font color="green"> 140.         self.table_map = {}     # Maps table names to list of aliases.</font>
<font color="green"> 141.         self.default_cols = True</font>
<font color="green"> 142.         self.default_ordering = True</font>
<font color="green"> 143.         self.standard_ordering = True</font>
<font color="green"> 144.         self.used_aliases = set()</font>
<font color="green"> 145.         self.filter_is_sticky = False</font>
<font color="black"> 146. </font>
<font color="black"> 147.         # SQL-related attributes</font>
<font color="black"> 148.         # Select and related select clauses are expressions to use in the</font>
<font color="black"> 149.         # SELECT clause of the query.</font>
<font color="black"> 150.         # The select is used for cases where we want to set up the select</font>
<font color="black"> 151.         # clause to contain other than default fields (values(), subqueries...)</font>
<font color="black"> 152.         # Note that annotations go to annotations dictionary.</font>
<font color="green"> 153.         self.select = []</font>
<font color="green"> 154.         self.tables = []    # Aliases in the order they are created.</font>
<font color="green"> 155.         self.where = where()</font>
<font color="green"> 156.         self.where_class = where</font>
<font color="black"> 157.         # The group_by attribute can have one of the following forms:</font>
<font color="black"> 158.         #  - None: no group by at all in the query</font>
<font color="black"> 159.         #  - A list of expressions: group by (at least) those expressions.</font>
<font color="black"> 160.         #    String refs are also allowed for now.</font>
<font color="black"> 161.         #  - True: group by all select fields of the model</font>
<font color="black"> 162.         # See compiler.get_group_by() for details.</font>
<font color="green"> 163.         self.group_by = None</font>
<font color="green"> 164.         self.order_by = []</font>
<font color="green"> 165.         self.low_mark, self.high_mark = 0, None  # Used for offset/limit</font>
<font color="green"> 166.         self.distinct = False</font>
<font color="green"> 167.         self.distinct_fields = []</font>
<font color="green"> 168.         self.select_for_update = False</font>
<font color="green"> 169.         self.select_for_update_nowait = False</font>
<font color="black"> 170. </font>
<font color="green"> 171.         self.select_related = False</font>
<font color="black"> 172.         # Arbitrary limit for select_related to prevents infinite recursion.</font>
<font color="green"> 173.         self.max_depth = 5</font>
<font color="black"> 174. </font>
<font color="black"> 175.         # Holds the selects defined by a call to values() or values_list()</font>
<font color="black"> 176.         # excluding annotation_select and extra_select.</font>
<font color="green"> 177.         self.values_select = []</font>
<font color="black"> 178. </font>
<font color="black"> 179.         # SQL annotation-related attributes</font>
<font color="black"> 180.         # The _annotations will be an OrderedDict when used. Due to the cost</font>
<font color="black"> 181.         # of creating OrderedDict this attribute is created lazily (in</font>
<font color="black"> 182.         # self.annotations property).</font>
<font color="green"> 183.         self._annotations = None  # Maps alias -&gt; Annotation Expression</font>
<font color="green"> 184.         self.annotation_select_mask = None</font>
<font color="green"> 185.         self._annotation_select_cache = None</font>
<font color="black"> 186. </font>
<font color="black"> 187.         # These are for extensions. The contents are more or less appended</font>
<font color="black"> 188.         # verbatim to the appropriate clause.</font>
<font color="black"> 189.         # The _extra attribute is an OrderedDict, lazily created similarly to</font>
<font color="black"> 190.         # .annotations</font>
<font color="green"> 191.         self._extra = None  # Maps col_alias -&gt; (col_sql, params).</font>
<font color="green"> 192.         self.extra_select_mask = None</font>
<font color="green"> 193.         self._extra_select_cache = None</font>
<font color="black"> 194. </font>
<font color="green"> 195.         self.extra_tables = ()</font>
<font color="green"> 196.         self.extra_order_by = ()</font>
<font color="black"> 197. </font>
<font color="black"> 198.         # A tuple that is a set of model field names and either True, if these</font>
<font color="black"> 199.         # are the fields to defer, or False if these are the only fields to</font>
<font color="black"> 200.         # load.</font>
<font color="green"> 201.         self.deferred_loading = (set(), True)</font>
<font color="black"> 202. </font>
<font color="green"> 203.         self.context = {}</font>
<font color="black"> 204. </font>
<font color="green"> 205.     @property</font>
<font color="black"> 206.     def extra(self):</font>
<font color="red"> 207.         if self._extra is None:</font>
<font color="red"> 208.             self._extra = OrderedDict()</font>
<font color="red"> 209.         return self._extra</font>
<font color="black"> 210. </font>
<font color="green"> 211.     @property</font>
<font color="black"> 212.     def annotations(self):</font>
<font color="green"> 213.         if self._annotations is None:</font>
<font color="green"> 214.             self._annotations = OrderedDict()</font>
<font color="green"> 215.         return self._annotations</font>
<font color="black"> 216. </font>
<font color="green"> 217.     @property</font>
<font color="black"> 218.     def aggregates(self):</font>
<font color="red"> 219.         warnings.warn(</font>
<font color="red"> 220.             &quot;The aggregates property is deprecated. Use annotations instead.&quot;,</font>
<font color="red"> 221.             RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 222.         return self.annotations</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def __str__(self):</font>
<font color="black"> 225.         &quot;&quot;&quot;</font>
<font color="black"> 226.         Returns the query as a string of SQL with the parameter values</font>
<font color="black"> 227.         substituted in (use sql_with_params() to see the unsubstituted string).</font>
<font color="black"> 228. </font>
<font color="black"> 229.         Parameter values won't necessarily be quoted correctly, since that is</font>
<font color="black"> 230.         done by the database interface at execution time.</font>
<font color="black"> 231.         &quot;&quot;&quot;</font>
<font color="red"> 232.         sql, params = self.sql_with_params()</font>
<font color="red"> 233.         return sql % params</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def sql_with_params(self):</font>
<font color="black"> 236.         &quot;&quot;&quot;</font>
<font color="black"> 237.         Returns the query as an SQL string and the parameters that will be</font>
<font color="black"> 238.         substituted into the query.</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="red"> 240.         return self.get_compiler(DEFAULT_DB_ALIAS).as_sql()</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def __deepcopy__(self, memo):</font>
<font color="red"> 243.         result = self.clone(memo=memo)</font>
<font color="red"> 244.         memo[id(self)] = result</font>
<font color="red"> 245.         return result</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def _prepare(self):</font>
<font color="red"> 248.         return self</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def get_compiler(self, using=None, connection=None):</font>
<font color="green"> 251.         if using is None and connection is None:</font>
<font color="red"> 252.             raise ValueError(&quot;Need either using or connection&quot;)</font>
<font color="green"> 253.         if using:</font>
<font color="green"> 254.             connection = connections[using]</font>
<font color="green"> 255.         return connection.ops.compiler(self.compiler)(self, connection, using)</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def get_meta(self):</font>
<font color="black"> 258.         &quot;&quot;&quot;</font>
<font color="black"> 259.         Returns the Options instance (the model._meta) from which to start</font>
<font color="black"> 260.         processing. Normally, this is self.model._meta, but it can be changed</font>
<font color="black"> 261.         by subclasses.</font>
<font color="black"> 262.         &quot;&quot;&quot;</font>
<font color="green"> 263.         return self.model._meta</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def clone(self, klass=None, memo=None, **kwargs):</font>
<font color="black"> 266.         &quot;&quot;&quot;</font>
<font color="black"> 267.         Creates a copy of the current instance. The 'kwargs' parameter can be</font>
<font color="black"> 268.         used by clients to update attributes after copying has taken place.</font>
<font color="black"> 269.         &quot;&quot;&quot;</font>
<font color="green"> 270.         obj = Empty()</font>
<font color="green"> 271.         obj.__class__ = klass or self.__class__</font>
<font color="green"> 272.         obj.model = self.model</font>
<font color="green"> 273.         obj.alias_refcount = self.alias_refcount.copy()</font>
<font color="green"> 274.         obj.alias_map = self.alias_map.copy()</font>
<font color="green"> 275.         obj.external_aliases = self.external_aliases.copy()</font>
<font color="green"> 276.         obj.table_map = self.table_map.copy()</font>
<font color="green"> 277.         obj.default_cols = self.default_cols</font>
<font color="green"> 278.         obj.default_ordering = self.default_ordering</font>
<font color="green"> 279.         obj.standard_ordering = self.standard_ordering</font>
<font color="green"> 280.         obj.select = self.select[:]</font>
<font color="green"> 281.         obj.tables = self.tables[:]</font>
<font color="green"> 282.         obj.where = self.where.clone()</font>
<font color="green"> 283.         obj.where_class = self.where_class</font>
<font color="green"> 284.         if self.group_by is None:</font>
<font color="green"> 285.             obj.group_by = None</font>
<font color="red"> 286.         elif self.group_by is True:</font>
<font color="red"> 287.             obj.group_by = True</font>
<font color="black"> 288.         else:</font>
<font color="red"> 289.             obj.group_by = self.group_by[:]</font>
<font color="green"> 290.         obj.order_by = self.order_by[:]</font>
<font color="green"> 291.         obj.low_mark, obj.high_mark = self.low_mark, self.high_mark</font>
<font color="green"> 292.         obj.distinct = self.distinct</font>
<font color="green"> 293.         obj.distinct_fields = self.distinct_fields[:]</font>
<font color="green"> 294.         obj.select_for_update = self.select_for_update</font>
<font color="green"> 295.         obj.select_for_update_nowait = self.select_for_update_nowait</font>
<font color="green"> 296.         obj.select_related = self.select_related</font>
<font color="green"> 297.         obj.values_select = self.values_select[:]</font>
<font color="green"> 298.         obj._annotations = self._annotations.copy() if self._annotations is not None else None</font>
<font color="green"> 299.         if self.annotation_select_mask is None:</font>
<font color="green"> 300.             obj.annotation_select_mask = None</font>
<font color="black"> 301.         else:</font>
<font color="red"> 302.             obj.annotation_select_mask = self.annotation_select_mask.copy()</font>
<font color="black"> 303.         # _annotation_select_cache cannot be copied, as doing so breaks the</font>
<font color="black"> 304.         # (necessary) state in which both annotations and</font>
<font color="black"> 305.         # _annotation_select_cache point to the same underlying objects.</font>
<font color="black"> 306.         # It will get re-populated in the cloned queryset the next time it's</font>
<font color="black"> 307.         # used.</font>
<font color="green"> 308.         obj._annotation_select_cache = None</font>
<font color="green"> 309.         obj.max_depth = self.max_depth</font>
<font color="green"> 310.         obj._extra = self._extra.copy() if self._extra is not None else None</font>
<font color="green"> 311.         if self.extra_select_mask is None:</font>
<font color="green"> 312.             obj.extra_select_mask = None</font>
<font color="black"> 313.         else:</font>
<font color="red"> 314.             obj.extra_select_mask = self.extra_select_mask.copy()</font>
<font color="green"> 315.         if self._extra_select_cache is None:</font>
<font color="green"> 316.             obj._extra_select_cache = None</font>
<font color="black"> 317.         else:</font>
<font color="red"> 318.             obj._extra_select_cache = self._extra_select_cache.copy()</font>
<font color="green"> 319.         obj.extra_tables = self.extra_tables</font>
<font color="green"> 320.         obj.extra_order_by = self.extra_order_by</font>
<font color="green"> 321.         obj.deferred_loading = copy.copy(self.deferred_loading[0]), self.deferred_loading[1]</font>
<font color="green"> 322.         if self.filter_is_sticky and self.used_aliases:</font>
<font color="red"> 323.             obj.used_aliases = self.used_aliases.copy()</font>
<font color="black"> 324.         else:</font>
<font color="green"> 325.             obj.used_aliases = set()</font>
<font color="green"> 326.         obj.filter_is_sticky = False</font>
<font color="green"> 327.         if 'alias_prefix' in self.__dict__:</font>
<font color="red"> 328.             obj.alias_prefix = self.alias_prefix</font>
<font color="green"> 329.         if 'subq_aliases' in self.__dict__:</font>
<font color="red"> 330.             obj.subq_aliases = self.subq_aliases.copy()</font>
<font color="black"> 331. </font>
<font color="green"> 332.         obj.__dict__.update(kwargs)</font>
<font color="green"> 333.         if hasattr(obj, '_setup_query'):</font>
<font color="red"> 334.             obj._setup_query()</font>
<font color="green"> 335.         obj.context = self.context.copy()</font>
<font color="green"> 336.         return obj</font>
<font color="black"> 337. </font>
<font color="green"> 338.     def add_context(self, key, value):</font>
<font color="red"> 339.         self.context[key] = value</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def get_context(self, key, default=None):</font>
<font color="red"> 342.         return self.context.get(key, default)</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def relabeled_clone(self, change_map):</font>
<font color="red"> 345.         clone = self.clone()</font>
<font color="red"> 346.         clone.change_aliases(change_map)</font>
<font color="red"> 347.         return clone</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def rewrite_cols(self, annotation, col_cnt):</font>
<font color="black"> 350.         # We must make sure the inner query has the referred columns in it.</font>
<font color="black"> 351.         # If we are aggregating over an annotation, then Django uses Ref()</font>
<font color="black"> 352.         # instances to note this. However, if we are annotating over a column</font>
<font color="black"> 353.         # of a related model, then it might be that column isn't part of the</font>
<font color="black"> 354.         # SELECT clause of the inner query, and we must manually make sure</font>
<font color="black"> 355.         # the column is selected. An example case is:</font>
<font color="black"> 356.         #    .aggregate(Sum('author__awards'))</font>
<font color="black"> 357.         # Resolving this expression results in a join to author, but there</font>
<font color="black"> 358.         # is no guarantee the awards column of author is in the select clause</font>
<font color="black"> 359.         # of the query. Thus we must manually add the column to the inner</font>
<font color="black"> 360.         # query.</font>
<font color="red"> 361.         orig_exprs = annotation.get_source_expressions()</font>
<font color="red"> 362.         new_exprs = []</font>
<font color="red"> 363.         for expr in orig_exprs:</font>
<font color="red"> 364.             if isinstance(expr, Ref):</font>
<font color="black"> 365.                 # Its already a Ref to subquery (see resolve_ref() for</font>
<font color="black"> 366.                 # details)</font>
<font color="red"> 367.                 new_exprs.append(expr)</font>
<font color="red"> 368.             elif isinstance(expr, Col):</font>
<font color="black"> 369.                 # Reference to column. Make sure the referenced column</font>
<font color="black"> 370.                 # is selected.</font>
<font color="red"> 371.                 col_cnt += 1</font>
<font color="red"> 372.                 col_alias = '__col%d' % col_cnt</font>
<font color="red"> 373.                 self.annotations[col_alias] = expr</font>
<font color="red"> 374.                 self.append_annotation_mask([col_alias])</font>
<font color="red"> 375.                 new_exprs.append(Ref(col_alias, expr))</font>
<font color="black"> 376.             else:</font>
<font color="black"> 377.                 # Some other expression not referencing database values</font>
<font color="black"> 378.                 # directly. Its subexpression might contain Cols.</font>
<font color="red"> 379.                 new_expr, col_cnt = self.rewrite_cols(expr, col_cnt)</font>
<font color="red"> 380.                 new_exprs.append(new_expr)</font>
<font color="red"> 381.         annotation.set_source_expressions(new_exprs)</font>
<font color="red"> 382.         return annotation, col_cnt</font>
<font color="black"> 383. </font>
<font color="green"> 384.     def get_aggregation(self, using, added_aggregate_names):</font>
<font color="black"> 385.         &quot;&quot;&quot;</font>
<font color="black"> 386.         Returns the dictionary with the values of the existing aggregations.</font>
<font color="black"> 387.         &quot;&quot;&quot;</font>
<font color="red"> 388.         if not self.annotation_select:</font>
<font color="red"> 389.             return {}</font>
<font color="red"> 390.         has_limit = self.low_mark != 0 or self.high_mark is not None</font>
<font color="red"> 391.         has_existing_annotations = any(</font>
<font color="red"> 392.             annotation for alias, annotation</font>
<font color="red"> 393.             in self.annotations.items()</font>
<font color="red"> 394.             if alias not in added_aggregate_names</font>
<font color="black"> 395.         )</font>
<font color="black"> 396.         # Decide if we need to use a subquery.</font>
<font color="black"> 397.         #</font>
<font color="black"> 398.         # Existing annotations would cause incorrect results as get_aggregation()</font>
<font color="black"> 399.         # must produce just one result and thus must not use GROUP BY. But we</font>
<font color="black"> 400.         # aren't smart enough to remove the existing annotations from the</font>
<font color="black"> 401.         # query, so those would force us to use GROUP BY.</font>
<font color="black"> 402.         #</font>
<font color="black"> 403.         # If the query has limit or distinct, then those operations must be</font>
<font color="black"> 404.         # done in a subquery so that we are aggregating on the limit and/or</font>
<font color="black"> 405.         # distinct results instead of applying the distinct and limit after the</font>
<font color="black"> 406.         # aggregation.</font>
<font color="red"> 407.         if (isinstance(self.group_by, list) or has_limit or has_existing_annotations or</font>
<font color="red"> 408.                 self.distinct):</font>
<font color="red"> 409.             from django.db.models.sql.subqueries import AggregateQuery</font>
<font color="red"> 410.             outer_query = AggregateQuery(self.model)</font>
<font color="red"> 411.             inner_query = self.clone()</font>
<font color="red"> 412.             inner_query.select_for_update = False</font>
<font color="red"> 413.             inner_query.select_related = False</font>
<font color="red"> 414.             if not has_limit and not self.distinct_fields:</font>
<font color="black"> 415.                 # Queries with distinct_fields need ordering and when a limit</font>
<font color="black"> 416.                 # is applied we must take the slice from the ordered query.</font>
<font color="black"> 417.                 # Otherwise no need for ordering.</font>
<font color="red"> 418.                 inner_query.clear_ordering(True)</font>
<font color="red"> 419.             if not inner_query.distinct:</font>
<font color="black"> 420.                 # If the inner query uses default select and it has some</font>
<font color="black"> 421.                 # aggregate annotations, then we must make sure the inner</font>
<font color="black"> 422.                 # query is grouped by the main model's primary key. However,</font>
<font color="black"> 423.                 # clearing the select clause can alter results if distinct is</font>
<font color="black"> 424.                 # used.</font>
<font color="red"> 425.                 if inner_query.default_cols and has_existing_annotations:</font>
<font color="red"> 426.                     inner_query.group_by = [self.model._meta.pk.get_col(inner_query.get_initial_alias())]</font>
<font color="red"> 427.                 inner_query.default_cols = False</font>
<font color="black"> 428. </font>
<font color="red"> 429.             relabels = {t: 'subquery' for t in inner_query.tables}</font>
<font color="red"> 430.             relabels[None] = 'subquery'</font>
<font color="black"> 431.             # Remove any aggregates marked for reduction from the subquery</font>
<font color="black"> 432.             # and move them to the outer AggregateQuery.</font>
<font color="red"> 433.             col_cnt = 0</font>
<font color="red"> 434.             for alias, expression in list(inner_query.annotation_select.items()):</font>
<font color="red"> 435.                 if expression.is_summary:</font>
<font color="red"> 436.                     expression, col_cnt = inner_query.rewrite_cols(expression, col_cnt)</font>
<font color="red"> 437.                     outer_query.annotations[alias] = expression.relabeled_clone(relabels)</font>
<font color="red"> 438.                     del inner_query.annotations[alias]</font>
<font color="black"> 439.                 # Make sure the annotation_select wont use cached results.</font>
<font color="red"> 440.                 inner_query.set_annotation_mask(inner_query.annotation_select_mask)</font>
<font color="red"> 441.             if inner_query.select == [] and not inner_query.default_cols and not inner_query.annotation_select_mask:</font>
<font color="black"> 442.                 # In case of Model.objects[0:3].count(), there would be no</font>
<font color="black"> 443.                 # field selected in the inner query, yet we must use a subquery.</font>
<font color="black"> 444.                 # So, make sure at least one field is selected.</font>
<font color="red"> 445.                 inner_query.select = [self.model._meta.pk.get_col(inner_query.get_initial_alias())]</font>
<font color="red"> 446.             try:</font>
<font color="red"> 447.                 outer_query.add_subquery(inner_query, using)</font>
<font color="red"> 448.             except EmptyResultSet:</font>
<font color="black"> 449.                 return {</font>
<font color="red"> 450.                     alias: None</font>
<font color="red"> 451.                     for alias in outer_query.annotation_select</font>
<font color="black"> 452.                 }</font>
<font color="black"> 453.         else:</font>
<font color="red"> 454.             outer_query = self</font>
<font color="red"> 455.             self.select = []</font>
<font color="red"> 456.             self.default_cols = False</font>
<font color="red"> 457.             self._extra = {}</font>
<font color="black"> 458. </font>
<font color="red"> 459.         outer_query.clear_ordering(True)</font>
<font color="red"> 460.         outer_query.clear_limits()</font>
<font color="red"> 461.         outer_query.select_for_update = False</font>
<font color="red"> 462.         outer_query.select_related = False</font>
<font color="red"> 463.         compiler = outer_query.get_compiler(using)</font>
<font color="red"> 464.         result = compiler.execute_sql(SINGLE)</font>
<font color="red"> 465.         if result is None:</font>
<font color="red"> 466.             result = [None for q in outer_query.annotation_select.items()]</font>
<font color="black"> 467. </font>
<font color="red"> 468.         converters = compiler.get_converters(outer_query.annotation_select.values())</font>
<font color="red"> 469.         result = compiler.apply_converters(result, converters)</font>
<font color="black"> 470. </font>
<font color="black"> 471.         return {</font>
<font color="red"> 472.             alias: val</font>
<font color="red"> 473.             for (alias, annotation), val</font>
<font color="red"> 474.             in zip(outer_query.annotation_select.items(), result)</font>
<font color="black"> 475.         }</font>
<font color="black"> 476. </font>
<font color="green"> 477.     def get_count(self, using):</font>
<font color="black"> 478.         &quot;&quot;&quot;</font>
<font color="black"> 479.         Performs a COUNT() query using the current filter constraints.</font>
<font color="black"> 480.         &quot;&quot;&quot;</font>
<font color="red"> 481.         obj = self.clone()</font>
<font color="red"> 482.         obj.add_annotation(Count('*'), alias='__count', is_summary=True)</font>
<font color="red"> 483.         number = obj.get_aggregation(using, ['__count'])['__count']</font>
<font color="red"> 484.         if number is None:</font>
<font color="red"> 485.             number = 0</font>
<font color="red"> 486.         return number</font>
<font color="black"> 487. </font>
<font color="green"> 488.     def has_filters(self):</font>
<font color="red"> 489.         return self.where</font>
<font color="black"> 490. </font>
<font color="green"> 491.     def has_results(self, using):</font>
<font color="red"> 492.         q = self.clone()</font>
<font color="red"> 493.         if not q.distinct:</font>
<font color="red"> 494.             if q.group_by is True:</font>
<font color="red"> 495.                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)</font>
<font color="red"> 496.                 q.set_group_by()</font>
<font color="red"> 497.             q.clear_select_clause()</font>
<font color="red"> 498.         q.clear_ordering(True)</font>
<font color="red"> 499.         q.set_limits(high=1)</font>
<font color="red"> 500.         compiler = q.get_compiler(using=using)</font>
<font color="red"> 501.         return compiler.has_results()</font>
<font color="black"> 502. </font>
<font color="green"> 503.     def combine(self, rhs, connector):</font>
<font color="black"> 504.         &quot;&quot;&quot;</font>
<font color="black"> 505.         Merge the 'rhs' query into the current one (with any 'rhs' effects</font>
<font color="black"> 506.         being applied *after* (that is, &quot;to the right of&quot;) anything in the</font>
<font color="black"> 507.         current query. 'rhs' is not modified during a call to this function.</font>
<font color="black"> 508. </font>
<font color="black"> 509.         The 'connector' parameter describes how to connect filters from the</font>
<font color="black"> 510.         'rhs' query.</font>
<font color="black"> 511.         &quot;&quot;&quot;</font>
<font color="red"> 512.         assert self.model == rhs.model, \</font>
<font color="red"> 513.             &quot;Cannot combine queries on two different base models.&quot;</font>
<font color="red"> 514.         assert self.can_filter(), \</font>
<font color="red"> 515.             &quot;Cannot combine queries once a slice has been taken.&quot;</font>
<font color="red"> 516.         assert self.distinct == rhs.distinct, \</font>
<font color="red"> 517.             &quot;Cannot combine a unique query with a non-unique query.&quot;</font>
<font color="red"> 518.         assert self.distinct_fields == rhs.distinct_fields, \</font>
<font color="red"> 519.             &quot;Cannot combine queries with different distinct fields.&quot;</font>
<font color="black"> 520. </font>
<font color="black"> 521.         # Work out how to relabel the rhs aliases, if necessary.</font>
<font color="red"> 522.         change_map = {}</font>
<font color="red"> 523.         conjunction = (connector == AND)</font>
<font color="black"> 524. </font>
<font color="black"> 525.         # Determine which existing joins can be reused. When combining the</font>
<font color="black"> 526.         # query with AND we must recreate all joins for m2m filters. When</font>
<font color="black"> 527.         # combining with OR we can reuse joins. The reason is that in AND</font>
<font color="black"> 528.         # case a single row can't fulfill a condition like:</font>
<font color="black"> 529.         #     revrel__col=1 &amp; revrel__col=2</font>
<font color="black"> 530.         # But, there might be two different related rows matching this</font>
<font color="black"> 531.         # condition. In OR case a single True is enough, so single row is</font>
<font color="black"> 532.         # enough, too.</font>
<font color="black"> 533.         #</font>
<font color="black"> 534.         # Note that we will be creating duplicate joins for non-m2m joins in</font>
<font color="black"> 535.         # the AND case. The results will be correct but this creates too many</font>
<font color="black"> 536.         # joins. This is something that could be fixed later on.</font>
<font color="red"> 537.         reuse = set() if conjunction else set(self.tables)</font>
<font color="black"> 538.         # Base table must be present in the query - this is the same</font>
<font color="black"> 539.         # table on both sides.</font>
<font color="red"> 540.         self.get_initial_alias()</font>
<font color="red"> 541.         joinpromoter = JoinPromoter(connector, 2, False)</font>
<font color="red"> 542.         joinpromoter.add_votes(</font>
<font color="red"> 543.             j for j in self.alias_map if self.alias_map[j].join_type == INNER)</font>
<font color="red"> 544.         rhs_votes = set()</font>
<font color="black"> 545.         # Now, add the joins from rhs query into the new query (skipping base</font>
<font color="black"> 546.         # table).</font>
<font color="red"> 547.         for alias in rhs.tables[1:]:</font>
<font color="red"> 548.             join = rhs.alias_map[alias]</font>
<font color="black"> 549.             # If the left side of the join was already relabeled, use the</font>
<font color="black"> 550.             # updated alias.</font>
<font color="red"> 551.             join = join.relabeled_clone(change_map)</font>
<font color="red"> 552.             new_alias = self.join(join, reuse=reuse)</font>
<font color="red"> 553.             if join.join_type == INNER:</font>
<font color="red"> 554.                 rhs_votes.add(new_alias)</font>
<font color="black"> 555.             # We can't reuse the same join again in the query. If we have two</font>
<font color="black"> 556.             # distinct joins for the same connection in rhs query, then the</font>
<font color="black"> 557.             # combined query must have two joins, too.</font>
<font color="red"> 558.             reuse.discard(new_alias)</font>
<font color="red"> 559.             if alias != new_alias:</font>
<font color="red"> 560.                 change_map[alias] = new_alias</font>
<font color="red"> 561.             if not rhs.alias_refcount[alias]:</font>
<font color="black"> 562.                 # The alias was unused in the rhs query. Unref it so that it</font>
<font color="black"> 563.                 # will be unused in the new query, too. We have to add and</font>
<font color="black"> 564.                 # unref the alias so that join promotion has information of</font>
<font color="black"> 565.                 # the join type for the unused alias.</font>
<font color="red"> 566.                 self.unref_alias(new_alias)</font>
<font color="red"> 567.         joinpromoter.add_votes(rhs_votes)</font>
<font color="red"> 568.         joinpromoter.update_join_types(self)</font>
<font color="black"> 569. </font>
<font color="black"> 570.         # Now relabel a copy of the rhs where-clause and add it to the current</font>
<font color="black"> 571.         # one.</font>
<font color="red"> 572.         w = rhs.where.clone()</font>
<font color="red"> 573.         w.relabel_aliases(change_map)</font>
<font color="red"> 574.         self.where.add(w, connector)</font>
<font color="black"> 575. </font>
<font color="black"> 576.         # Selection columns and extra extensions are those provided by 'rhs'.</font>
<font color="red"> 577.         self.select = []</font>
<font color="red"> 578.         for col in rhs.select:</font>
<font color="red"> 579.             self.add_select(col.relabeled_clone(change_map))</font>
<font color="black"> 580. </font>
<font color="red"> 581.         if connector == OR:</font>
<font color="black"> 582.             # It would be nice to be able to handle this, but the queries don't</font>
<font color="black"> 583.             # really make sense (or return consistent value sets). Not worth</font>
<font color="black"> 584.             # the extra complexity when you can write a real query instead.</font>
<font color="red"> 585.             if self._extra and rhs._extra:</font>
<font color="red"> 586.                 raise ValueError(&quot;When merging querysets using 'or', you &quot;</font>
<font color="black"> 587.                         &quot;cannot have extra(select=...) on both sides.&quot;)</font>
<font color="red"> 588.         self.extra.update(rhs.extra)</font>
<font color="red"> 589.         extra_select_mask = set()</font>
<font color="red"> 590.         if self.extra_select_mask is not None:</font>
<font color="red"> 591.             extra_select_mask.update(self.extra_select_mask)</font>
<font color="red"> 592.         if rhs.extra_select_mask is not None:</font>
<font color="red"> 593.             extra_select_mask.update(rhs.extra_select_mask)</font>
<font color="red"> 594.         if extra_select_mask:</font>
<font color="red"> 595.             self.set_extra_mask(extra_select_mask)</font>
<font color="red"> 596.         self.extra_tables += rhs.extra_tables</font>
<font color="black"> 597. </font>
<font color="black"> 598.         # Ordering uses the 'rhs' ordering, unless it has none, in which case</font>
<font color="black"> 599.         # the current ordering is used.</font>
<font color="red"> 600.         self.order_by = rhs.order_by[:] if rhs.order_by else self.order_by</font>
<font color="red"> 601.         self.extra_order_by = rhs.extra_order_by or self.extra_order_by</font>
<font color="black"> 602. </font>
<font color="green"> 603.     def deferred_to_data(self, target, callback):</font>
<font color="black"> 604.         &quot;&quot;&quot;</font>
<font color="black"> 605.         Converts the self.deferred_loading data structure to an alternate data</font>
<font color="black"> 606.         structure, describing the field that *will* be loaded. This is used to</font>
<font color="black"> 607.         compute the columns to select from the database and also by the</font>
<font color="black"> 608.         QuerySet class to work out which fields are being initialized on each</font>
<font color="black"> 609.         model. Models that have all their fields included aren't mentioned in</font>
<font color="black"> 610.         the result, only those that have field restrictions in place.</font>
<font color="black"> 611. </font>
<font color="black"> 612.         The &quot;target&quot; parameter is the instance that is populated (in place).</font>
<font color="black"> 613.         The &quot;callback&quot; is a function that is called whenever a (model, field)</font>
<font color="black"> 614.         pair need to be added to &quot;target&quot;. It accepts three parameters:</font>
<font color="black"> 615.         &quot;target&quot;, and the model and list of fields being added for that model.</font>
<font color="black"> 616.         &quot;&quot;&quot;</font>
<font color="green"> 617.         field_names, defer = self.deferred_loading</font>
<font color="green"> 618.         if not field_names:</font>
<font color="green"> 619.             return</font>
<font color="red"> 620.         orig_opts = self.get_meta()</font>
<font color="red"> 621.         seen = {}</font>
<font color="red"> 622.         must_include = {orig_opts.concrete_model: {orig_opts.pk}}</font>
<font color="red"> 623.         for field_name in field_names:</font>
<font color="red"> 624.             parts = field_name.split(LOOKUP_SEP)</font>
<font color="red"> 625.             cur_model = self.model._meta.concrete_model</font>
<font color="red"> 626.             opts = orig_opts</font>
<font color="red"> 627.             for name in parts[:-1]:</font>
<font color="red"> 628.                 old_model = cur_model</font>
<font color="red"> 629.                 source = opts.get_field(name)</font>
<font color="red"> 630.                 if is_reverse_o2o(source):</font>
<font color="red"> 631.                     cur_model = source.related_model</font>
<font color="black"> 632.                 else:</font>
<font color="red"> 633.                     cur_model = source.remote_field.model</font>
<font color="red"> 634.                 opts = cur_model._meta</font>
<font color="black"> 635.                 # Even if we're &quot;just passing through&quot; this model, we must add</font>
<font color="black"> 636.                 # both the current model's pk and the related reference field</font>
<font color="black"> 637.                 # (if it's not a reverse relation) to the things we select.</font>
<font color="red"> 638.                 if not is_reverse_o2o(source):</font>
<font color="red"> 639.                     must_include[old_model].add(source)</font>
<font color="red"> 640.                 add_to_dict(must_include, cur_model, opts.pk)</font>
<font color="red"> 641.             field = opts.get_field(parts[-1])</font>
<font color="red"> 642.             is_reverse_object = field.auto_created and not field.concrete</font>
<font color="red"> 643.             model = field.related_model if is_reverse_object else field.model</font>
<font color="red"> 644.             model = model._meta.concrete_model</font>
<font color="red"> 645.             if model == opts.model:</font>
<font color="red"> 646.                 model = cur_model</font>
<font color="red"> 647.             if not is_reverse_o2o(field):</font>
<font color="red"> 648.                 add_to_dict(seen, model, field)</font>
<font color="black"> 649. </font>
<font color="red"> 650.         if defer:</font>
<font color="black"> 651.             # We need to load all fields for each model, except those that</font>
<font color="black"> 652.             # appear in &quot;seen&quot; (for all models that appear in &quot;seen&quot;). The only</font>
<font color="black"> 653.             # slight complexity here is handling fields that exist on parent</font>
<font color="black"> 654.             # models.</font>
<font color="red"> 655.             workset = {}</font>
<font color="red"> 656.             for model, values in six.iteritems(seen):</font>
<font color="red"> 657.                 for field in model._meta.fields:</font>
<font color="red"> 658.                     if field in values:</font>
<font color="red"> 659.                         continue</font>
<font color="red"> 660.                     m = field.model._meta.concrete_model</font>
<font color="red"> 661.                     add_to_dict(workset, m, field)</font>
<font color="red"> 662.             for model, values in six.iteritems(must_include):</font>
<font color="black"> 663.                 # If we haven't included a model in workset, we don't add the</font>
<font color="black"> 664.                 # corresponding must_include fields for that model, since an</font>
<font color="black"> 665.                 # empty set means &quot;include all fields&quot;. That's why there's no</font>
<font color="black"> 666.                 # &quot;else&quot; branch here.</font>
<font color="red"> 667.                 if model in workset:</font>
<font color="red"> 668.                     workset[model].update(values)</font>
<font color="red"> 669.             for model, values in six.iteritems(workset):</font>
<font color="red"> 670.                 callback(target, model, values)</font>
<font color="black"> 671.         else:</font>
<font color="red"> 672.             for model, values in six.iteritems(must_include):</font>
<font color="red"> 673.                 if model in seen:</font>
<font color="red"> 674.                     seen[model].update(values)</font>
<font color="black"> 675.                 else:</font>
<font color="black"> 676.                     # As we've passed through this model, but not explicitly</font>
<font color="black"> 677.                     # included any fields, we have to make sure it's mentioned</font>
<font color="black"> 678.                     # so that only the &quot;must include&quot; fields are pulled in.</font>
<font color="red"> 679.                     seen[model] = values</font>
<font color="black"> 680.             # Now ensure that every model in the inheritance chain is mentioned</font>
<font color="black"> 681.             # in the parent list. Again, it must be mentioned to ensure that</font>
<font color="black"> 682.             # only &quot;must include&quot; fields are pulled in.</font>
<font color="red"> 683.             for model in orig_opts.get_parent_list():</font>
<font color="red"> 684.                 if model not in seen:</font>
<font color="red"> 685.                     seen[model] = set()</font>
<font color="red"> 686.             for model, values in six.iteritems(seen):</font>
<font color="red"> 687.                 callback(target, model, values)</font>
<font color="black"> 688. </font>
<font color="green"> 689.     def table_alias(self, table_name, create=False):</font>
<font color="black"> 690.         &quot;&quot;&quot;</font>
<font color="black"> 691.         Returns a table alias for the given table_name and whether this is a</font>
<font color="black"> 692.         new alias or not.</font>
<font color="black"> 693. </font>
<font color="black"> 694.         If 'create' is true, a new alias is always created. Otherwise, the</font>
<font color="black"> 695.         most recently created alias for the table (if one exists) is reused.</font>
<font color="black"> 696.         &quot;&quot;&quot;</font>
<font color="green"> 697.         alias_list = self.table_map.get(table_name)</font>
<font color="green"> 698.         if not create and alias_list:</font>
<font color="red"> 699.             alias = alias_list[0]</font>
<font color="red"> 700.             self.alias_refcount[alias] += 1</font>
<font color="red"> 701.             return alias, False</font>
<font color="black"> 702. </font>
<font color="black"> 703.         # Create a new alias for this table.</font>
<font color="green"> 704.         if alias_list:</font>
<font color="red"> 705.             alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)</font>
<font color="red"> 706.             alias_list.append(alias)</font>
<font color="black"> 707.         else:</font>
<font color="black"> 708.             # The first occurrence of a table uses the table name directly.</font>
<font color="green"> 709.             alias = table_name</font>
<font color="green"> 710.             self.table_map[alias] = [alias]</font>
<font color="green"> 711.         self.alias_refcount[alias] = 1</font>
<font color="green"> 712.         self.tables.append(alias)</font>
<font color="green"> 713.         return alias, True</font>
<font color="black"> 714. </font>
<font color="green"> 715.     def ref_alias(self, alias):</font>
<font color="black"> 716.         &quot;&quot;&quot; Increases the reference count for this alias. &quot;&quot;&quot;</font>
<font color="green"> 717.         self.alias_refcount[alias] += 1</font>
<font color="black"> 718. </font>
<font color="green"> 719.     def unref_alias(self, alias, amount=1):</font>
<font color="black"> 720.         &quot;&quot;&quot; Decreases the reference count for this alias. &quot;&quot;&quot;</font>
<font color="green"> 721.         self.alias_refcount[alias] -= amount</font>
<font color="black"> 722. </font>
<font color="green"> 723.     def promote_joins(self, aliases):</font>
<font color="black"> 724.         &quot;&quot;&quot;</font>
<font color="black"> 725.         Promotes recursively the join type of given aliases and its children to</font>
<font color="black"> 726.         an outer join. If 'unconditional' is False, the join is only promoted if</font>
<font color="black"> 727.         it is nullable or the parent join is an outer join.</font>
<font color="black"> 728. </font>
<font color="black"> 729.         The children promotion is done to avoid join chains that contain a LOUTER</font>
<font color="black"> 730.         b INNER c. So, if we have currently a INNER b INNER c and a-&gt;b is promoted,</font>
<font color="black"> 731.         then we must also promote b-&gt;c automatically, or otherwise the promotion</font>
<font color="black"> 732.         of a-&gt;b doesn't actually change anything in the query results.</font>
<font color="black"> 733.         &quot;&quot;&quot;</font>
<font color="green"> 734.         aliases = list(aliases)</font>
<font color="green"> 735.         while aliases:</font>
<font color="red"> 736.             alias = aliases.pop(0)</font>
<font color="red"> 737.             if self.alias_map[alias].join_type is None:</font>
<font color="black"> 738.                 # This is the base table (first FROM entry) - this table</font>
<font color="black"> 739.                 # isn't really joined at all in the query, so we should not</font>
<font color="black"> 740.                 # alter its join type.</font>
<font color="red"> 741.                 continue</font>
<font color="black"> 742.             # Only the first alias (skipped above) should have None join_type</font>
<font color="red"> 743.             assert self.alias_map[alias].join_type is not None</font>
<font color="red"> 744.             parent_alias = self.alias_map[alias].parent_alias</font>
<font color="black"> 745.             parent_louter = (</font>
<font color="red"> 746.                 parent_alias</font>
<font color="red"> 747.                 and self.alias_map[parent_alias].join_type == LOUTER)</font>
<font color="red"> 748.             already_louter = self.alias_map[alias].join_type == LOUTER</font>
<font color="red"> 749.             if ((self.alias_map[alias].nullable or parent_louter) and</font>
<font color="red"> 750.                     not already_louter):</font>
<font color="red"> 751.                 self.alias_map[alias] = self.alias_map[alias].promote()</font>
<font color="black"> 752.                 # Join type of 'alias' changed, so re-examine all aliases that</font>
<font color="black"> 753.                 # refer to this one.</font>
<font color="red"> 754.                 aliases.extend(</font>
<font color="red"> 755.                     join for join in self.alias_map.keys()</font>
<font color="red"> 756.                     if (self.alias_map[join].parent_alias == alias</font>
<font color="red"> 757.                         and join not in aliases))</font>
<font color="black"> 758. </font>
<font color="green"> 759.     def demote_joins(self, aliases):</font>
<font color="black"> 760.         &quot;&quot;&quot;</font>
<font color="black"> 761.         Change join type from LOUTER to INNER for all joins in aliases.</font>
<font color="black"> 762. </font>
<font color="black"> 763.         Similarly to promote_joins(), this method must ensure no join chains</font>
<font color="black"> 764.         containing first an outer, then an inner join are generated. If we</font>
<font color="black"> 765.         are demoting b-&gt;c join in chain a LOUTER b LOUTER c then we must</font>
<font color="black"> 766.         demote a-&gt;b automatically, or otherwise the demotion of b-&gt;c doesn't</font>
<font color="black"> 767.         actually change anything in the query results. .</font>
<font color="black"> 768.         &quot;&quot;&quot;</font>
<font color="green"> 769.         aliases = list(aliases)</font>
<font color="green"> 770.         while aliases:</font>
<font color="green"> 771.             alias = aliases.pop(0)</font>
<font color="green"> 772.             if self.alias_map[alias].join_type == LOUTER:</font>
<font color="red"> 773.                 self.alias_map[alias] = self.alias_map[alias].demote()</font>
<font color="red"> 774.                 parent_alias = self.alias_map[alias].parent_alias</font>
<font color="red"> 775.                 if self.alias_map[parent_alias].join_type == INNER:</font>
<font color="red"> 776.                     aliases.append(parent_alias)</font>
<font color="black"> 777. </font>
<font color="green"> 778.     def reset_refcounts(self, to_counts):</font>
<font color="black"> 779.         &quot;&quot;&quot;</font>
<font color="black"> 780.         This method will reset reference counts for aliases so that they match</font>
<font color="black"> 781.         the value passed in :param to_counts:.</font>
<font color="black"> 782.         &quot;&quot;&quot;</font>
<font color="green"> 783.         for alias, cur_refcount in self.alias_refcount.copy().items():</font>
<font color="green"> 784.             unref_amount = cur_refcount - to_counts.get(alias, 0)</font>
<font color="green"> 785.             self.unref_alias(alias, unref_amount)</font>
<font color="black"> 786. </font>
<font color="green"> 787.     def change_aliases(self, change_map):</font>
<font color="black"> 788.         &quot;&quot;&quot;</font>
<font color="black"> 789.         Changes the aliases in change_map (which maps old-alias -&gt; new-alias),</font>
<font color="black"> 790.         relabelling any references to them in select columns and the where</font>
<font color="black"> 791.         clause.</font>
<font color="black"> 792.         &quot;&quot;&quot;</font>
<font color="red"> 793.         assert set(change_map.keys()).intersection(set(change_map.values())) == set()</font>
<font color="black"> 794. </font>
<font color="red"> 795.         def relabel_column(col):</font>
<font color="red"> 796.             if isinstance(col, (list, tuple)):</font>
<font color="red"> 797.                 old_alias = col[0]</font>
<font color="red"> 798.                 return (change_map.get(old_alias, old_alias), col[1])</font>
<font color="black"> 799.             else:</font>
<font color="red"> 800.                 return col.relabeled_clone(change_map)</font>
<font color="black"> 801.         # 1. Update references in &quot;select&quot; (normal columns plus aliases),</font>
<font color="black"> 802.         # &quot;group by&quot; and &quot;where&quot;.</font>
<font color="red"> 803.         self.where.relabel_aliases(change_map)</font>
<font color="red"> 804.         if isinstance(self.group_by, list):</font>
<font color="red"> 805.             self.group_by = [relabel_column(col) for col in self.group_by]</font>
<font color="red"> 806.         self.select = [col.relabeled_clone(change_map) for col in self.select]</font>
<font color="red"> 807.         if self._annotations:</font>
<font color="red"> 808.             self._annotations = OrderedDict(</font>
<font color="red"> 809.                 (key, relabel_column(col)) for key, col in self._annotations.items())</font>
<font color="black"> 810. </font>
<font color="black"> 811.         # 2. Rename the alias in the internal table/alias datastructures.</font>
<font color="red"> 812.         for old_alias, new_alias in six.iteritems(change_map):</font>
<font color="red"> 813.             if old_alias not in self.alias_map:</font>
<font color="red"> 814.                 continue</font>
<font color="red"> 815.             alias_data = self.alias_map[old_alias].relabeled_clone(change_map)</font>
<font color="red"> 816.             self.alias_map[new_alias] = alias_data</font>
<font color="red"> 817.             self.alias_refcount[new_alias] = self.alias_refcount[old_alias]</font>
<font color="red"> 818.             del self.alias_refcount[old_alias]</font>
<font color="red"> 819.             del self.alias_map[old_alias]</font>
<font color="black"> 820. </font>
<font color="red"> 821.             table_aliases = self.table_map[alias_data.table_name]</font>
<font color="red"> 822.             for pos, alias in enumerate(table_aliases):</font>
<font color="red"> 823.                 if alias == old_alias:</font>
<font color="red"> 824.                     table_aliases[pos] = new_alias</font>
<font color="red"> 825.                     break</font>
<font color="red"> 826.             for pos, alias in enumerate(self.tables):</font>
<font color="red"> 827.                 if alias == old_alias:</font>
<font color="red"> 828.                     self.tables[pos] = new_alias</font>
<font color="red"> 829.                     break</font>
<font color="red"> 830.         self.external_aliases = {change_map.get(alias, alias)</font>
<font color="red"> 831.                                  for alias in self.external_aliases}</font>
<font color="black"> 832. </font>
<font color="green"> 833.     def bump_prefix(self, outer_query):</font>
<font color="black"> 834.         &quot;&quot;&quot;</font>
<font color="black"> 835.         Changes the alias prefix to the next letter in the alphabet in a way</font>
<font color="black"> 836.         that the outer query's aliases and this query's aliases will not</font>
<font color="black"> 837.         conflict. Even tables that previously had no alias will get an alias</font>
<font color="black"> 838.         after this call.</font>
<font color="black"> 839.         &quot;&quot;&quot;</font>
<font color="red"> 840.         def prefix_gen():</font>
<font color="black"> 841.             &quot;&quot;&quot;</font>
<font color="black"> 842.             Generates a sequence of characters in alphabetical order:</font>
<font color="black"> 843.                 -&gt; 'A', 'B', 'C', ...</font>
<font color="black"> 844. </font>
<font color="black"> 845.             When the alphabet is finished, the sequence will continue with the</font>
<font color="black"> 846.             Cartesian product:</font>
<font color="black"> 847.                 -&gt; 'AA', 'AB', 'AC', ...</font>
<font color="black"> 848.             &quot;&quot;&quot;</font>
<font color="red"> 849.             alphabet = ascii_uppercase</font>
<font color="red"> 850.             prefix = chr(ord(self.alias_prefix) + 1)</font>
<font color="red"> 851.             yield prefix</font>
<font color="red"> 852.             for n in count(1):</font>
<font color="red"> 853.                 seq = alphabet[alphabet.index(prefix):] if prefix else alphabet</font>
<font color="red"> 854.                 for s in product(seq, repeat=n):</font>
<font color="red"> 855.                     yield ''.join(s)</font>
<font color="red"> 856.                 prefix = None</font>
<font color="black"> 857. </font>
<font color="red"> 858.         if self.alias_prefix != outer_query.alias_prefix:</font>
<font color="black"> 859.             # No clashes between self and outer query should be possible.</font>
<font color="red"> 860.             return</font>
<font color="black"> 861. </font>
<font color="red"> 862.         local_recursion_limit = 127  # explicitly avoid infinite loop</font>
<font color="red"> 863.         for pos, prefix in enumerate(prefix_gen()):</font>
<font color="red"> 864.             if prefix not in self.subq_aliases:</font>
<font color="red"> 865.                 self.alias_prefix = prefix</font>
<font color="red"> 866.                 break</font>
<font color="red"> 867.             if pos &gt; local_recursion_limit:</font>
<font color="red"> 868.                 raise RuntimeError(</font>
<font color="red"> 869.                     'Maximum recursion depth exceeded: too many subqueries.'</font>
<font color="black"> 870.                 )</font>
<font color="red"> 871.         self.subq_aliases = self.subq_aliases.union([self.alias_prefix])</font>
<font color="red"> 872.         outer_query.subq_aliases = outer_query.subq_aliases.union(self.subq_aliases)</font>
<font color="red"> 873.         change_map = OrderedDict()</font>
<font color="red"> 874.         for pos, alias in enumerate(self.tables):</font>
<font color="red"> 875.             new_alias = '%s%d' % (self.alias_prefix, pos)</font>
<font color="red"> 876.             change_map[alias] = new_alias</font>
<font color="red"> 877.             self.tables[pos] = new_alias</font>
<font color="red"> 878.         self.change_aliases(change_map)</font>
<font color="black"> 879. </font>
<font color="green"> 880.     def get_initial_alias(self):</font>
<font color="black"> 881.         &quot;&quot;&quot;</font>
<font color="black"> 882.         Returns the first alias for this query, after increasing its reference</font>
<font color="black"> 883.         count.</font>
<font color="black"> 884.         &quot;&quot;&quot;</font>
<font color="green"> 885.         if self.tables:</font>
<font color="green"> 886.             alias = self.tables[0]</font>
<font color="green"> 887.             self.ref_alias(alias)</font>
<font color="black"> 888.         else:</font>
<font color="green"> 889.             alias = self.join(BaseTable(self.get_meta().db_table, None))</font>
<font color="green"> 890.         return alias</font>
<font color="black"> 891. </font>
<font color="green"> 892.     def count_active_tables(self):</font>
<font color="black"> 893.         &quot;&quot;&quot;</font>
<font color="black"> 894.         Returns the number of tables in this query with a non-zero reference</font>
<font color="black"> 895.         count. Note that after execution, the reference counts are zeroed, so</font>
<font color="black"> 896.         tables added in compiler will not be seen by this method.</font>
<font color="black"> 897.         &quot;&quot;&quot;</font>
<font color="red"> 898.         return len([1 for count in self.alias_refcount.values() if count])</font>
<font color="black"> 899. </font>
<font color="green"> 900.     def join(self, join, reuse=None):</font>
<font color="black"> 901.         &quot;&quot;&quot;</font>
<font color="black"> 902.         Returns an alias for the join in 'connection', either reusing an</font>
<font color="black"> 903.         existing alias for that join or creating a new one. 'connection' is a</font>
<font color="black"> 904.         tuple (lhs, table, join_cols) where 'lhs' is either an existing</font>
<font color="black"> 905.         table alias or a table name. 'join_cols' is a tuple of tuples containing</font>
<font color="black"> 906.         columns to join on ((l_id1, r_id1), (l_id2, r_id2)). The join corresponds</font>
<font color="black"> 907.         to the SQL equivalent of::</font>
<font color="black"> 908. </font>
<font color="black"> 909.             lhs.l_id1 = table.r_id1 AND lhs.l_id2 = table.r_id2</font>
<font color="black"> 910. </font>
<font color="black"> 911.         The 'reuse' parameter can be either None which means all joins</font>
<font color="black"> 912.         (matching the connection) are reusable, or it can be a set containing</font>
<font color="black"> 913.         the aliases that can be reused.</font>
<font color="black"> 914. </font>
<font color="black"> 915.         A join is always created as LOUTER if the lhs alias is LOUTER to make</font>
<font color="black"> 916.         sure we do not generate chains like t1 LOUTER t2 INNER t3. All new</font>
<font color="black"> 917.         joins are created as LOUTER if nullable is True.</font>
<font color="black"> 918. </font>
<font color="black"> 919.         If 'nullable' is True, the join can potentially involve NULL values and</font>
<font color="black"> 920.         is a candidate for promotion (to &quot;left outer&quot;) when combining querysets.</font>
<font color="black"> 921. </font>
<font color="black"> 922.         The 'join_field' is the field we are joining along (if any).</font>
<font color="black"> 923.         &quot;&quot;&quot;</font>
<font color="green"> 924.         reuse = [a for a, j in self.alias_map.items()</font>
<font color="green"> 925.                  if (reuse is None or a in reuse) and j == join]</font>
<font color="green"> 926.         if reuse:</font>
<font color="green"> 927.             self.ref_alias(reuse[0])</font>
<font color="green"> 928.             return reuse[0]</font>
<font color="black"> 929. </font>
<font color="black"> 930.         # No reuse is possible, so we need a new alias.</font>
<font color="green"> 931.         alias, _ = self.table_alias(join.table_name, create=True)</font>
<font color="green"> 932.         if join.join_type:</font>
<font color="green"> 933.             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:</font>
<font color="red"> 934.                 join_type = LOUTER</font>
<font color="black"> 935.             else:</font>
<font color="green"> 936.                 join_type = INNER</font>
<font color="green"> 937.             join.join_type = join_type</font>
<font color="green"> 938.         join.table_alias = alias</font>
<font color="green"> 939.         self.alias_map[alias] = join</font>
<font color="green"> 940.         return alias</font>
<font color="black"> 941. </font>
<font color="green"> 942.     def join_parent_model(self, opts, model, alias, seen):</font>
<font color="black"> 943.         &quot;&quot;&quot;</font>
<font color="black"> 944.         Makes sure the given 'model' is joined in the query. If 'model' isn't</font>
<font color="black"> 945.         a parent of 'opts' or if it is None this method is a no-op.</font>
<font color="black"> 946. </font>
<font color="black"> 947.         The 'alias' is the root alias for starting the join, 'seen' is a dict</font>
<font color="black"> 948.         of model -&gt; alias of existing joins. It must also contain a mapping</font>
<font color="black"> 949.         of None -&gt; some alias. This will be returned in the no-op case.</font>
<font color="black"> 950.         &quot;&quot;&quot;</font>
<font color="green"> 951.         if model in seen:</font>
<font color="green"> 952.             return seen[model]</font>
<font color="red"> 953.         chain = opts.get_base_chain(model)</font>
<font color="red"> 954.         if not chain:</font>
<font color="red"> 955.             return alias</font>
<font color="red"> 956.         curr_opts = opts</font>
<font color="red"> 957.         for int_model in chain:</font>
<font color="red"> 958.             if int_model in seen:</font>
<font color="red"> 959.                 curr_opts = int_model._meta</font>
<font color="red"> 960.                 alias = seen[int_model]</font>
<font color="red"> 961.                 continue</font>
<font color="black"> 962.             # Proxy model have elements in base chain</font>
<font color="black"> 963.             # with no parents, assign the new options</font>
<font color="black"> 964.             # object and skip to the next base in that</font>
<font color="black"> 965.             # case</font>
<font color="red"> 966.             if not curr_opts.parents[int_model]:</font>
<font color="red"> 967.                 curr_opts = int_model._meta</font>
<font color="red"> 968.                 continue</font>
<font color="red"> 969.             link_field = curr_opts.get_ancestor_link(int_model)</font>
<font color="red"> 970.             _, _, _, joins, _ = self.setup_joins(</font>
<font color="red"> 971.                 [link_field.name], curr_opts, alias)</font>
<font color="red"> 972.             curr_opts = int_model._meta</font>
<font color="red"> 973.             alias = seen[int_model] = joins[-1]</font>
<font color="red"> 974.         return alias or seen[None]</font>
<font color="black"> 975. </font>
<font color="green"> 976.     def add_aggregate(self, aggregate, model, alias, is_summary):</font>
<font color="red"> 977.         warnings.warn(</font>
<font color="red"> 978.             &quot;add_aggregate() is deprecated. Use add_annotation() instead.&quot;,</font>
<font color="red"> 979.             RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 980.         self.add_annotation(aggregate, alias, is_summary)</font>
<font color="black"> 981. </font>
<font color="green"> 982.     def add_annotation(self, annotation, alias, is_summary=False):</font>
<font color="black"> 983.         &quot;&quot;&quot;</font>
<font color="black"> 984.         Adds a single annotation expression to the Query</font>
<font color="black"> 985.         &quot;&quot;&quot;</font>
<font color="red"> 986.         annotation = annotation.resolve_expression(self, allow_joins=True, reuse=None,</font>
<font color="red"> 987.                                                    summarize=is_summary)</font>
<font color="red"> 988.         self.append_annotation_mask([alias])</font>
<font color="red"> 989.         self.annotations[alias] = annotation</font>
<font color="black"> 990. </font>
<font color="green"> 991.     def prepare_lookup_value(self, value, lookups, can_reuse, allow_joins=True):</font>
<font color="black"> 992.         # Default lookup if none given is exact.</font>
<font color="green"> 993.         used_joins = []</font>
<font color="green"> 994.         if len(lookups) == 0:</font>
<font color="red"> 995.             lookups = ['exact']</font>
<font color="black"> 996.         # Interpret '__exact=None' as the sql 'is NULL'; otherwise, reject all</font>
<font color="black"> 997.         # uses of None as a query value.</font>
<font color="green"> 998.         if value is None:</font>
<font color="red"> 999.             if lookups[-1] not in ('exact', 'iexact'):</font>
<font color="red">1000.                 raise ValueError(&quot;Cannot use None as a query value&quot;)</font>
<font color="red">1001.             lookups[-1] = 'isnull'</font>
<font color="red">1002.             value = True</font>
<font color="green">1003.         elif hasattr(value, 'resolve_expression'):</font>
<font color="red">1004.             pre_joins = self.alias_refcount.copy()</font>
<font color="red">1005.             value = value.resolve_expression(self, reuse=can_reuse, allow_joins=allow_joins)</font>
<font color="red">1006.             used_joins = [k for k, v in self.alias_refcount.items() if v &gt; pre_joins.get(k, 0)]</font>
<font color="black">1007.         # Subqueries need to use a different set of aliases than the</font>
<font color="black">1008.         # outer query. Call bump_prefix to change aliases of the inner</font>
<font color="black">1009.         # query (the value).</font>
<font color="green">1010.         if hasattr(value, 'query') and hasattr(value.query, 'bump_prefix'):</font>
<font color="red">1011.             value = value._clone()</font>
<font color="red">1012.             value.query.bump_prefix(self)</font>
<font color="green">1013.         if hasattr(value, 'bump_prefix'):</font>
<font color="red">1014.             value = value.clone()</font>
<font color="red">1015.             value.bump_prefix(self)</font>
<font color="black">1016.         # For Oracle '' is equivalent to null. The check needs to be done</font>
<font color="black">1017.         # at this stage because join promotion can't be done at compiler</font>
<font color="black">1018.         # stage. Using DEFAULT_DB_ALIAS isn't nice, but it is the best we</font>
<font color="black">1019.         # can do here. Similar thing is done in is_nullable(), too.</font>
<font color="green">1020.         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and</font>
<font color="red">1021.                 lookups[-1] == 'exact' and value == ''):</font>
<font color="red">1022.             value = True</font>
<font color="red">1023.             lookups[-1] = 'isnull'</font>
<font color="green">1024.         return value, lookups, used_joins</font>
<font color="black">1025. </font>
<font color="green">1026.     def solve_lookup_type(self, lookup):</font>
<font color="black">1027.         &quot;&quot;&quot;</font>
<font color="black">1028.         Solve the lookup type from the lookup (eg: 'foobar__id__icontains')</font>
<font color="black">1029.         &quot;&quot;&quot;</font>
<font color="green">1030.         lookup_splitted = lookup.split(LOOKUP_SEP)</font>
<font color="green">1031.         if self._annotations:</font>
<font color="red">1032.             expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)</font>
<font color="red">1033.             if expression:</font>
<font color="red">1034.                 return expression_lookups, (), expression</font>
<font color="green">1035.         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())</font>
<font color="green">1036.         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]</font>
<font color="green">1037.         if len(lookup_parts) == 0:</font>
<font color="green">1038.             lookup_parts = ['exact']</font>
<font color="green">1039.         elif len(lookup_parts) &gt; 1:</font>
<font color="red">1040.             if not field_parts:</font>
<font color="red">1041.                 raise FieldError(</font>
<font color="red">1042.                     'Invalid lookup &quot;%s&quot; for model %s&quot;.' %</font>
<font color="red">1043.                     (lookup, self.get_meta().model.__name__))</font>
<font color="green">1044.         return lookup_parts, field_parts, False</font>
<font color="black">1045. </font>
<font color="green">1046.     def check_query_object_type(self, value, opts, field):</font>
<font color="black">1047.         &quot;&quot;&quot;</font>
<font color="black">1048.         Checks whether the object passed while querying is of the correct type.</font>
<font color="black">1049.         If not, it raises a ValueError specifying the wrong object.</font>
<font color="black">1050.         &quot;&quot;&quot;</font>
<font color="green">1051.         if hasattr(value, '_meta'):</font>
<font color="green">1052.             if not check_rel_lookup_compatibility(value._meta.model, opts, field):</font>
<font color="red">1053.                 raise ValueError(</font>
<font color="red">1054.                     'Cannot query &quot;%s&quot;: Must be &quot;%s&quot; instance.' %</font>
<font color="red">1055.                     (value, opts.object_name))</font>
<font color="black">1056. </font>
<font color="green">1057.     def check_related_objects(self, field, value, opts):</font>
<font color="black">1058.         &quot;&quot;&quot;</font>
<font color="black">1059.         Checks the type of object passed to query relations.</font>
<font color="black">1060.         &quot;&quot;&quot;</font>
<font color="green">1061.         if field.is_relation:</font>
<font color="black">1062.             # QuerySets implement is_compatible_query_object_type() to</font>
<font color="black">1063.             # determine compatibility with the given field.</font>
<font color="green">1064.             if hasattr(value, 'is_compatible_query_object_type'):</font>
<font color="red">1065.                 if not value.is_compatible_query_object_type(opts, field):</font>
<font color="red">1066.                     raise ValueError(</font>
<font color="red">1067.                         'Cannot use QuerySet for &quot;%s&quot;: Use a QuerySet for &quot;%s&quot;.' %</font>
<font color="red">1068.                         (value.model._meta.model_name, opts.object_name)</font>
<font color="black">1069.                     )</font>
<font color="green">1070.             elif hasattr(value, '_meta'):</font>
<font color="red">1071.                 self.check_query_object_type(value, opts, field)</font>
<font color="green">1072.             elif hasattr(value, '__iter__'):</font>
<font color="green">1073.                 for v in value:</font>
<font color="green">1074.                     self.check_query_object_type(v, opts, field)</font>
<font color="black">1075. </font>
<font color="green">1076.     def build_lookup(self, lookups, lhs, rhs):</font>
<font color="black">1077.         &quot;&quot;&quot;</font>
<font color="black">1078.         Tries to extract transforms and lookup from given lhs.</font>
<font color="black">1079. </font>
<font color="black">1080.         The lhs value is something that works like SQLExpression.</font>
<font color="black">1081.         The rhs value is what the lookup is going to compare against.</font>
<font color="black">1082.         The lookups is a list of names to extract using get_lookup()</font>
<font color="black">1083.         and get_transform().</font>
<font color="black">1084.         &quot;&quot;&quot;</font>
<font color="green">1085.         lookups = lookups[:]</font>
<font color="green">1086.         while lookups:</font>
<font color="green">1087.             name = lookups[0]</font>
<font color="black">1088.             # If there is just one part left, try first get_lookup() so</font>
<font color="black">1089.             # that if the lhs supports both transform and lookup for the</font>
<font color="black">1090.             # name, then lookup will be picked.</font>
<font color="green">1091.             if len(lookups) == 1:</font>
<font color="green">1092.                 final_lookup = lhs.get_lookup(name)</font>
<font color="green">1093.                 if not final_lookup:</font>
<font color="black">1094.                     # We didn't find a lookup. We are going to interpret</font>
<font color="black">1095.                     # the name as transform, and do an Exact lookup against</font>
<font color="black">1096.                     # it.</font>
<font color="red">1097.                     lhs = self.try_transform(lhs, name, lookups)</font>
<font color="red">1098.                     final_lookup = lhs.get_lookup('exact')</font>
<font color="green">1099.                 return final_lookup(lhs, rhs)</font>
<font color="red">1100.             lhs = self.try_transform(lhs, name, lookups)</font>
<font color="red">1101.             lookups = lookups[1:]</font>
<font color="black">1102. </font>
<font color="green">1103.     def try_transform(self, lhs, name, rest_of_lookups):</font>
<font color="black">1104.         &quot;&quot;&quot;</font>
<font color="black">1105.         Helper method for build_lookup. Tries to fetch and initialize</font>
<font color="black">1106.         a transform for name parameter from lhs.</font>
<font color="black">1107.         &quot;&quot;&quot;</font>
<font color="red">1108.         transform_class = lhs.get_transform(name)</font>
<font color="red">1109.         if transform_class:</font>
<font color="red">1110.             return transform_class(lhs)</font>
<font color="black">1111.         else:</font>
<font color="red">1112.             raise FieldError(</font>
<font color="red">1113.                 &quot;Unsupported lookup '%s' for %s or join on the field not &quot;</font>
<font color="black">1114.                 &quot;permitted.&quot; %</font>
<font color="red">1115.                 (name, lhs.output_field.__class__.__name__))</font>
<font color="black">1116. </font>
<font color="green">1117.     def build_filter(self, filter_expr, branch_negated=False, current_negated=False,</font>
<font color="green">1118.                      can_reuse=None, connector=AND, allow_joins=True, split_subq=True):</font>
<font color="black">1119.         &quot;&quot;&quot;</font>
<font color="black">1120.         Builds a WhereNode for a single filter clause, but doesn't add it</font>
<font color="black">1121.         to this Query. Query.add_q() will then add this filter to the where</font>
<font color="black">1122.         Node.</font>
<font color="black">1123. </font>
<font color="black">1124.         The 'branch_negated' tells us if the current branch contains any</font>
<font color="black">1125.         negations. This will be used to determine if subqueries are needed.</font>
<font color="black">1126. </font>
<font color="black">1127.         The 'current_negated' is used to determine if the current filter is</font>
<font color="black">1128.         negated or not and this will be used to determine if IS NULL filtering</font>
<font color="black">1129.         is needed.</font>
<font color="black">1130. </font>
<font color="black">1131.         The difference between current_netageted and branch_negated is that</font>
<font color="black">1132.         branch_negated is set on first negation, but current_negated is</font>
<font color="black">1133.         flipped for each negation.</font>
<font color="black">1134. </font>
<font color="black">1135.         Note that add_filter will not do any negating itself, that is done</font>
<font color="black">1136.         upper in the code by add_q().</font>
<font color="black">1137. </font>
<font color="black">1138.         The 'can_reuse' is a set of reusable joins for multijoins.</font>
<font color="black">1139. </font>
<font color="black">1140.         The method will create a filter clause that can be added to the current</font>
<font color="black">1141.         query. However, if the filter isn't added to the query then the caller</font>
<font color="black">1142.         is responsible for unreffing the joins used.</font>
<font color="black">1143.         &quot;&quot;&quot;</font>
<font color="green">1144.         if isinstance(filter_expr, dict):</font>
<font color="red">1145.             raise FieldError(&quot;Cannot parse keyword query as dict&quot;)</font>
<font color="green">1146.         arg, value = filter_expr</font>
<font color="green">1147.         if not arg:</font>
<font color="red">1148.             raise FieldError(&quot;Cannot parse keyword query %r&quot; % arg)</font>
<font color="green">1149.         lookups, parts, reffed_expression = self.solve_lookup_type(arg)</font>
<font color="green">1150.         if not allow_joins and len(parts) &gt; 1:</font>
<font color="red">1151.             raise FieldError(&quot;Joined field references are not permitted in this query&quot;)</font>
<font color="black">1152. </font>
<font color="black">1153.         # Work out the lookup type and remove it from the end of 'parts',</font>
<font color="black">1154.         # if necessary.</font>
<font color="green">1155.         value, lookups, used_joins = self.prepare_lookup_value(value, lookups, can_reuse, allow_joins)</font>
<font color="black">1156. </font>
<font color="green">1157.         clause = self.where_class()</font>
<font color="green">1158.         if reffed_expression:</font>
<font color="red">1159.             condition = self.build_lookup(lookups, reffed_expression, value)</font>
<font color="red">1160.             clause.add(condition, AND)</font>
<font color="red">1161.             return clause, []</font>
<font color="black">1162. </font>
<font color="green">1163.         opts = self.get_meta()</font>
<font color="green">1164.         alias = self.get_initial_alias()</font>
<font color="green">1165.         allow_many = not branch_negated or not split_subq</font>
<font color="black">1166. </font>
<font color="green">1167.         try:</font>
<font color="green">1168.             field, sources, opts, join_list, path = self.setup_joins(</font>
<font color="green">1169.                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many)</font>
<font color="black">1170. </font>
<font color="black">1171.             # Prevent iterator from being consumed by check_related_objects()</font>
<font color="green">1172.             if isinstance(value, Iterator):</font>
<font color="red">1173.                 value = list(value)</font>
<font color="green">1174.             self.check_related_objects(field, value, opts)</font>
<font color="black">1175. </font>
<font color="black">1176.             # split_exclude() needs to know which joins were generated for the</font>
<font color="black">1177.             # lookup parts</font>
<font color="green">1178.             self._lookup_joins = join_list</font>
<font color="red">1179.         except MultiJoin as e:</font>
<font color="red">1180.             return self.split_exclude(filter_expr, LOOKUP_SEP.join(parts[:e.level]),</font>
<font color="red">1181.                                       can_reuse, e.names_with_path)</font>
<font color="black">1182. </font>
<font color="green">1183.         if can_reuse is not None:</font>
<font color="green">1184.             can_reuse.update(join_list)</font>
<font color="green">1185.         used_joins = set(used_joins).union(set(join_list))</font>
<font color="green">1186.         targets, alias, join_list = self.trim_joins(sources, join_list, path)</font>
<font color="black">1187. </font>
<font color="green">1188.         if field.is_relation:</font>
<font color="black">1189.             # No support for transforms for relational fields</font>
<font color="green">1190.             num_lookups = len(lookups)</font>
<font color="green">1191.             if num_lookups &gt; 1:</font>
<font color="red">1192.                 raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))</font>
<font color="green">1193.             assert num_lookups &gt; 0  # Likely a bug in Django if this fails.</font>
<font color="green">1194.             lookup_class = field.get_lookup(lookups[0])</font>
<font color="green">1195.             if len(targets) == 1:</font>
<font color="green">1196.                 lhs = targets[0].get_col(alias, field)</font>
<font color="black">1197.             else:</font>
<font color="red">1198.                 lhs = MultiColSource(alias, targets, sources, field)</font>
<font color="green">1199.             condition = lookup_class(lhs, value)</font>
<font color="green">1200.             lookup_type = lookup_class.lookup_name</font>
<font color="black">1201.         else:</font>
<font color="green">1202.             col = targets[0].get_col(alias, field)</font>
<font color="green">1203.             condition = self.build_lookup(lookups, col, value)</font>
<font color="green">1204.             lookup_type = condition.lookup_name</font>
<font color="black">1205. </font>
<font color="green">1206.         clause.add(condition, AND)</font>
<font color="black">1207. </font>
<font color="green">1208.         require_outer = lookup_type == 'isnull' and value is True and not current_negated</font>
<font color="green">1209.         if current_negated and (lookup_type != 'isnull' or value is False):</font>
<font color="red">1210.             require_outer = True</font>
<font color="red">1211.             if (lookup_type != 'isnull' and (</font>
<font color="red">1212.                     self.is_nullable(targets[0]) or</font>
<font color="red">1213.                     self.alias_map[join_list[-1]].join_type == LOUTER)):</font>
<font color="black">1214.                 # The condition added here will be SQL like this:</font>
<font color="black">1215.                 # NOT (col IS NOT NULL), where the first NOT is added in</font>
<font color="black">1216.                 # upper layers of code. The reason for addition is that if col</font>
<font color="black">1217.                 # is null, then col != someval will result in SQL &quot;unknown&quot;</font>
<font color="black">1218.                 # which isn't the same as in Python. The Python None handling</font>
<font color="black">1219.                 # is wanted, and it can be gotten by</font>
<font color="black">1220.                 # (col IS NULL OR col != someval)</font>
<font color="black">1221.                 #   &lt;=&gt;</font>
<font color="black">1222.                 # NOT (col IS NOT NULL AND col = someval).</font>
<font color="red">1223.                 lookup_class = targets[0].get_lookup('isnull')</font>
<font color="red">1224.                 clause.add(lookup_class(targets[0].get_col(alias, sources[0]), False), AND)</font>
<font color="green">1225.         return clause, used_joins if not require_outer else ()</font>
<font color="black">1226. </font>
<font color="green">1227.     def add_filter(self, filter_clause):</font>
<font color="red">1228.         self.add_q(Q(**{filter_clause[0]: filter_clause[1]}))</font>
<font color="black">1229. </font>
<font color="green">1230.     def add_q(self, q_object):</font>
<font color="black">1231.         &quot;&quot;&quot;</font>
<font color="black">1232.         A preprocessor for the internal _add_q(). Responsible for doing final</font>
<font color="black">1233.         join promotion.</font>
<font color="black">1234.         &quot;&quot;&quot;</font>
<font color="black">1235.         # For join promotion this case is doing an AND for the added q_object</font>
<font color="black">1236.         # and existing conditions. So, any existing inner join forces the join</font>
<font color="black">1237.         # type to remain inner. Existing outer joins can however be demoted.</font>
<font color="black">1238.         # (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if</font>
<font color="black">1239.         # rel_a doesn't produce any rows, then the whole condition must fail.</font>
<font color="black">1240.         # So, demotion is OK.</font>
<font color="green">1241.         existing_inner = set(</font>
<font color="green">1242.             (a for a in self.alias_map if self.alias_map[a].join_type == INNER))</font>
<font color="green">1243.         clause, _ = self._add_q(q_object, self.used_aliases)</font>
<font color="green">1244.         if clause:</font>
<font color="green">1245.             self.where.add(clause, AND)</font>
<font color="green">1246.         self.demote_joins(existing_inner)</font>
<font color="black">1247. </font>
<font color="green">1248.     def _add_q(self, q_object, used_aliases, branch_negated=False,</font>
<font color="green">1249.                current_negated=False, allow_joins=True, split_subq=True):</font>
<font color="black">1250.         &quot;&quot;&quot;</font>
<font color="black">1251.         Adds a Q-object to the current filter.</font>
<font color="black">1252.         &quot;&quot;&quot;</font>
<font color="green">1253.         connector = q_object.connector</font>
<font color="green">1254.         current_negated = current_negated ^ q_object.negated</font>
<font color="green">1255.         branch_negated = branch_negated or q_object.negated</font>
<font color="green">1256.         target_clause = self.where_class(connector=connector,</font>
<font color="green">1257.                                          negated=q_object.negated)</font>
<font color="green">1258.         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)</font>
<font color="green">1259.         for child in q_object.children:</font>
<font color="green">1260.             if isinstance(child, Node):</font>
<font color="red">1261.                 child_clause, needed_inner = self._add_q(</font>
<font color="red">1262.                     child, used_aliases, branch_negated,</font>
<font color="red">1263.                     current_negated, allow_joins, split_subq)</font>
<font color="red">1264.                 joinpromoter.add_votes(needed_inner)</font>
<font color="black">1265.             else:</font>
<font color="green">1266.                 child_clause, needed_inner = self.build_filter(</font>
<font color="green">1267.                     child, can_reuse=used_aliases, branch_negated=branch_negated,</font>
<font color="green">1268.                     current_negated=current_negated, connector=connector,</font>
<font color="green">1269.                     allow_joins=allow_joins, split_subq=split_subq,</font>
<font color="black">1270.                 )</font>
<font color="green">1271.                 joinpromoter.add_votes(needed_inner)</font>
<font color="green">1272.             if child_clause:</font>
<font color="green">1273.                 target_clause.add(child_clause, connector)</font>
<font color="green">1274.         needed_inner = joinpromoter.update_join_types(self)</font>
<font color="green">1275.         return target_clause, needed_inner</font>
<font color="black">1276. </font>
<font color="green">1277.     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):</font>
<font color="black">1278.         &quot;&quot;&quot;</font>
<font color="black">1279.         Walks the list of names and turns them into PathInfo tuples. Note that</font>
<font color="black">1280.         a single name in 'names' can generate multiple PathInfos (m2m for</font>
<font color="black">1281.         example).</font>
<font color="black">1282. </font>
<font color="black">1283.         'names' is the path of names to travel, 'opts' is the model Options we</font>
<font color="black">1284.         start the name resolving from, 'allow_many' is as for setup_joins().</font>
<font color="black">1285.         If fail_on_missing is set to True, then a name that can't be resolved</font>
<font color="black">1286.         will generate a FieldError.</font>
<font color="black">1287. </font>
<font color="black">1288.         Returns a list of PathInfo tuples. In addition returns the final field</font>
<font color="black">1289.         (the last used join field), and target (which is a field guaranteed to</font>
<font color="black">1290.         contain the same value as the final field). Finally, the method returns</font>
<font color="black">1291.         those names that weren't found (which are likely transforms and the</font>
<font color="black">1292.         final lookup).</font>
<font color="black">1293.         &quot;&quot;&quot;</font>
<font color="green">1294.         path, names_with_path = [], []</font>
<font color="green">1295.         for pos, name in enumerate(names):</font>
<font color="green">1296.             cur_names_with_path = (name, [])</font>
<font color="green">1297.             if name == 'pk':</font>
<font color="red">1298.                 name = opts.pk.name</font>
<font color="black">1299. </font>
<font color="green">1300.             field = None</font>
<font color="green">1301.             try:</font>
<font color="green">1302.                 field = opts.get_field(name)</font>
<font color="green">1303.             except FieldDoesNotExist:</font>
<font color="green">1304.                 if name in self.annotation_select:</font>
<font color="red">1305.                     field = self.annotation_select[name].output_field</font>
<font color="black">1306. </font>
<font color="green">1307.             if field is not None:</font>
<font color="black">1308.                 # Fields that contain one-to-many relations with a generic</font>
<font color="black">1309.                 # model (like a GenericForeignKey) cannot generate reverse</font>
<font color="black">1310.                 # relations and therefore cannot be used for reverse querying.</font>
<font color="green">1311.                 if field.is_relation and not field.related_model:</font>
<font color="red">1312.                     raise FieldError(</font>
<font color="red">1313.                         &quot;Field %r does not generate an automatic reverse &quot;</font>
<font color="black">1314.                         &quot;relation and therefore cannot be used for reverse &quot;</font>
<font color="black">1315.                         &quot;querying. If it is a GenericForeignKey, consider &quot;</font>
<font color="red">1316.                         &quot;adding a GenericRelation.&quot; % name</font>
<font color="black">1317.                     )</font>
<font color="green">1318.                 try:</font>
<font color="green">1319.                     model = field.model._meta.concrete_model</font>
<font color="red">1320.                 except AttributeError:</font>
<font color="red">1321.                     model = None</font>
<font color="black">1322.             else:</font>
<font color="black">1323.                 # We didn't find the current field, so move position back</font>
<font color="black">1324.                 # one step.</font>
<font color="green">1325.                 pos -= 1</font>
<font color="green">1326.                 if pos == -1 or fail_on_missing:</font>
<font color="red">1327.                     field_names = list(get_field_names_from_opts(opts))</font>
<font color="red">1328.                     available = sorted(field_names + list(self.annotation_select))</font>
<font color="red">1329.                     raise FieldError(&quot;Cannot resolve keyword %r into field. &quot;</font>
<font color="red">1330.                                      &quot;Choices are: %s&quot; % (name, &quot;, &quot;.join(available)))</font>
<font color="green">1331.                 break</font>
<font color="black">1332.             # Check if we need any joins for concrete inheritance cases (the</font>
<font color="black">1333.             # field lives in parent, but we are currently in one of its</font>
<font color="black">1334.             # children)</font>
<font color="green">1335.             if model is not opts.model:</font>
<font color="black">1336.                 # The field lives on a base class of the current model.</font>
<font color="black">1337.                 # Skip the chain of proxy to the concrete proxied model</font>
<font color="red">1338.                 proxied_model = opts.concrete_model</font>
<font color="black">1339. </font>
<font color="red">1340.                 for int_model in opts.get_base_chain(model):</font>
<font color="red">1341.                     if int_model is proxied_model:</font>
<font color="red">1342.                         opts = int_model._meta</font>
<font color="black">1343.                     else:</font>
<font color="red">1344.                         final_field = opts.parents[int_model]</font>
<font color="red">1345.                         targets = (final_field.remote_field.get_related_field(),)</font>
<font color="red">1346.                         opts = int_model._meta</font>
<font color="red">1347.                         path.append(PathInfo(final_field.model._meta, opts, targets, final_field, False, True))</font>
<font color="red">1348.                         cur_names_with_path[1].append(</font>
<font color="red">1349.                             PathInfo(final_field.model._meta, opts, targets, final_field, False, True)</font>
<font color="black">1350.                         )</font>
<font color="green">1351.             if hasattr(field, 'get_path_info'):</font>
<font color="green">1352.                 pathinfos = field.get_path_info()</font>
<font color="green">1353.                 if not allow_many:</font>
<font color="red">1354.                     for inner_pos, p in enumerate(pathinfos):</font>
<font color="red">1355.                         if p.m2m:</font>
<font color="red">1356.                             cur_names_with_path[1].extend(pathinfos[0:inner_pos + 1])</font>
<font color="red">1357.                             names_with_path.append(cur_names_with_path)</font>
<font color="red">1358.                             raise MultiJoin(pos + 1, names_with_path)</font>
<font color="green">1359.                 last = pathinfos[-1]</font>
<font color="green">1360.                 path.extend(pathinfos)</font>
<font color="green">1361.                 final_field = last.join_field</font>
<font color="green">1362.                 opts = last.to_opts</font>
<font color="green">1363.                 targets = last.target_fields</font>
<font color="green">1364.                 cur_names_with_path[1].extend(pathinfos)</font>
<font color="green">1365.                 names_with_path.append(cur_names_with_path)</font>
<font color="black">1366.             else:</font>
<font color="black">1367.                 # Local non-relational field.</font>
<font color="green">1368.                 final_field = field</font>
<font color="green">1369.                 targets = (field,)</font>
<font color="green">1370.                 if fail_on_missing and pos + 1 != len(names):</font>
<font color="red">1371.                     raise FieldError(</font>
<font color="red">1372.                         &quot;Cannot resolve keyword %r into field. Join on '%s'&quot;</font>
<font color="red">1373.                         &quot; not permitted.&quot; % (names[pos + 1], name))</font>
<font color="green">1374.                 break</font>
<font color="green">1375.         return path, final_field, targets, names[pos + 1:]</font>
<font color="black">1376. </font>
<font color="green">1377.     def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True):</font>
<font color="black">1378.         &quot;&quot;&quot;</font>
<font color="black">1379.         Compute the necessary table joins for the passage through the fields</font>
<font color="black">1380.         given in 'names'. 'opts' is the Options class for the current model</font>
<font color="black">1381.         (which gives the table we are starting from), 'alias' is the alias for</font>
<font color="black">1382.         the table to start the joining from.</font>
<font color="black">1383. </font>
<font color="black">1384.         The 'can_reuse' defines the reverse foreign key joins we can reuse. It</font>
<font color="black">1385.         can be None in which case all joins are reusable or a set of aliases</font>
<font color="black">1386.         that can be reused. Note that non-reverse foreign keys are always</font>
<font color="black">1387.         reusable when using setup_joins().</font>
<font color="black">1388. </font>
<font color="black">1389.         If 'allow_many' is False, then any reverse foreign key seen will</font>
<font color="black">1390.         generate a MultiJoin exception.</font>
<font color="black">1391. </font>
<font color="black">1392.         Returns the final field involved in the joins, the target field (used</font>
<font color="black">1393.         for any 'where' constraint), the final 'opts' value, the joins and the</font>
<font color="black">1394.         field path travelled to generate the joins.</font>
<font color="black">1395. </font>
<font color="black">1396.         The target field is the field containing the concrete value. Final</font>
<font color="black">1397.         field can be something different, for example foreign key pointing to</font>
<font color="black">1398.         that value. Final field is needed for example in some value</font>
<font color="black">1399.         conversions (convert 'obj' in fk__id=obj to pk val using the foreign</font>
<font color="black">1400.         key field for example).</font>
<font color="black">1401.         &quot;&quot;&quot;</font>
<font color="green">1402.         joins = [alias]</font>
<font color="black">1403.         # First, generate the path for the names</font>
<font color="green">1404.         path, final_field, targets, rest = self.names_to_path(</font>
<font color="green">1405.             names, opts, allow_many, fail_on_missing=True)</font>
<font color="black">1406. </font>
<font color="black">1407.         # Then, add the path to the query's joins. Note that we can't trim</font>
<font color="black">1408.         # joins at this stage - we will need the information about join type</font>
<font color="black">1409.         # of the trimmed joins.</font>
<font color="green">1410.         for join in path:</font>
<font color="green">1411.             opts = join.to_opts</font>
<font color="green">1412.             if join.direct:</font>
<font color="green">1413.                 nullable = self.is_nullable(join.join_field)</font>
<font color="black">1414.             else:</font>
<font color="red">1415.                 nullable = True</font>
<font color="green">1416.             connection = Join(opts.db_table, alias, None, INNER, join.join_field, nullable)</font>
<font color="green">1417.             reuse = can_reuse if join.m2m else None</font>
<font color="green">1418.             alias = self.join(connection, reuse=reuse)</font>
<font color="green">1419.             joins.append(alias)</font>
<font color="green">1420.         return final_field, targets, opts, joins, path</font>
<font color="black">1421. </font>
<font color="green">1422.     def trim_joins(self, targets, joins, path):</font>
<font color="black">1423.         &quot;&quot;&quot;</font>
<font color="black">1424.         The 'target' parameter is the final field being joined to, 'joins'</font>
<font color="black">1425.         is the full list of join aliases. The 'path' contain the PathInfos</font>
<font color="black">1426.         used to create the joins.</font>
<font color="black">1427. </font>
<font color="black">1428.         Returns the final target field and table alias and the new active</font>
<font color="black">1429.         joins.</font>
<font color="black">1430. </font>
<font color="black">1431.         We will always trim any direct join if we have the target column</font>
<font color="black">1432.         available already in the previous table. Reverse joins can't be</font>
<font color="black">1433.         trimmed as we don't know if there is anything on the other side of</font>
<font color="black">1434.         the join.</font>
<font color="black">1435.         &quot;&quot;&quot;</font>
<font color="green">1436.         joins = joins[:]</font>
<font color="green">1437.         for pos, info in enumerate(reversed(path)):</font>
<font color="green">1438.             if len(joins) == 1 or not info.direct:</font>
<font color="red">1439.                 break</font>
<font color="green">1440.             join_targets = set(t.column for t in info.join_field.foreign_related_fields)</font>
<font color="green">1441.             cur_targets = set(t.column for t in targets)</font>
<font color="green">1442.             if not cur_targets.issubset(join_targets):</font>
<font color="green">1443.                 break</font>
<font color="green">1444.             targets = tuple(r[0] for r in info.join_field.related_fields if r[1].column in cur_targets)</font>
<font color="green">1445.             self.unref_alias(joins.pop())</font>
<font color="green">1446.         return targets, joins[-1], joins</font>
<font color="black">1447. </font>
<font color="green">1448.     def resolve_ref(self, name, allow_joins=True, reuse=None, summarize=False):</font>
<font color="red">1449.         if not allow_joins and LOOKUP_SEP in name:</font>
<font color="red">1450.             raise FieldError(&quot;Joined field references are not permitted in this query&quot;)</font>
<font color="red">1451.         if name in self.annotations:</font>
<font color="red">1452.             if summarize:</font>
<font color="black">1453.                 # Summarize currently means we are doing an aggregate() query</font>
<font color="black">1454.                 # which is executed as a wrapped subquery if any of the</font>
<font color="black">1455.                 # aggregate() elements reference an existing annotation. In</font>
<font color="black">1456.                 # that case we need to return a Ref to the subquery's annotation.</font>
<font color="red">1457.                 return Ref(name, self.annotation_select[name])</font>
<font color="black">1458.             else:</font>
<font color="red">1459.                 return self.annotation_select[name]</font>
<font color="black">1460.         else:</font>
<font color="red">1461.             field_list = name.split(LOOKUP_SEP)</font>
<font color="red">1462.             field, sources, opts, join_list, path = self.setup_joins(</font>
<font color="red">1463.                 field_list, self.get_meta(),</font>
<font color="red">1464.                 self.get_initial_alias(), reuse)</font>
<font color="red">1465.             targets, _, join_list = self.trim_joins(sources, join_list, path)</font>
<font color="red">1466.             if len(targets) &gt; 1:</font>
<font color="red">1467.                 raise FieldError(&quot;Referencing multicolumn fields with F() objects &quot;</font>
<font color="black">1468.                                  &quot;isn't supported&quot;)</font>
<font color="red">1469.             if reuse is not None:</font>
<font color="red">1470.                 reuse.update(join_list)</font>
<font color="red">1471.             col = targets[0].get_col(join_list[-1], sources[0])</font>
<font color="red">1472.             return col</font>
<font color="black">1473. </font>
<font color="green">1474.     def split_exclude(self, filter_expr, prefix, can_reuse, names_with_path):</font>
<font color="black">1475.         &quot;&quot;&quot;</font>
<font color="black">1476.         When doing an exclude against any kind of N-to-many relation, we need</font>
<font color="black">1477.         to use a subquery. This method constructs the nested query, given the</font>
<font color="black">1478.         original exclude filter (filter_expr) and the portion up to the first</font>
<font color="black">1479.         N-to-many relation field.</font>
<font color="black">1480. </font>
<font color="black">1481.         As an example we could have original filter ~Q(child__name='foo').</font>
<font color="black">1482.         We would get here with filter_expr = child__name, prefix = child and</font>
<font color="black">1483.         can_reuse is a set of joins usable for filters in the original query.</font>
<font color="black">1484. </font>
<font color="black">1485.         We will turn this into equivalent of:</font>
<font color="black">1486.             WHERE NOT (pk IN (SELECT parent_id FROM thetable</font>
<font color="black">1487.                               WHERE name = 'foo' AND parent_id IS NOT NULL))</font>
<font color="black">1488. </font>
<font color="black">1489.         It might be worth it to consider using WHERE NOT EXISTS as that has</font>
<font color="black">1490.         saner null handling, and is easier for the backend's optimizer to</font>
<font color="black">1491.         handle.</font>
<font color="black">1492.         &quot;&quot;&quot;</font>
<font color="black">1493.         # Generate the inner query.</font>
<font color="red">1494.         query = Query(self.model)</font>
<font color="red">1495.         query.add_filter(filter_expr)</font>
<font color="red">1496.         query.clear_ordering(True)</font>
<font color="black">1497.         # Try to have as simple as possible subquery -&gt; trim leading joins from</font>
<font color="black">1498.         # the subquery.</font>
<font color="red">1499.         trimmed_prefix, contains_louter = query.trim_start(names_with_path)</font>
<font color="black">1500. </font>
<font color="black">1501.         # Add extra check to make sure the selected field will not be null</font>
<font color="black">1502.         # since we are adding an IN &lt;subquery&gt; clause. This prevents the</font>
<font color="black">1503.         # database from tripping over IN (...,NULL,...) selects and returning</font>
<font color="black">1504.         # nothing</font>
<font color="red">1505.         col = query.select[0]</font>
<font color="red">1506.         select_field = col.target</font>
<font color="red">1507.         alias = col.alias</font>
<font color="red">1508.         if self.is_nullable(select_field):</font>
<font color="red">1509.             lookup_class = select_field.get_lookup('isnull')</font>
<font color="red">1510.             lookup = lookup_class(select_field.get_col(alias), False)</font>
<font color="red">1511.             query.where.add(lookup, AND)</font>
<font color="red">1512.         if alias in can_reuse:</font>
<font color="red">1513.             pk = select_field.model._meta.pk</font>
<font color="black">1514.             # Need to add a restriction so that outer query's filters are in effect for</font>
<font color="black">1515.             # the subquery, too.</font>
<font color="red">1516.             query.bump_prefix(self)</font>
<font color="red">1517.             lookup_class = select_field.get_lookup('exact')</font>
<font color="black">1518.             # Note that the query.select[0].alias is different from alias</font>
<font color="black">1519.             # due to bump_prefix above.</font>
<font color="red">1520.             lookup = lookup_class(pk.get_col(query.select[0].alias),</font>
<font color="red">1521.                                   pk.get_col(alias))</font>
<font color="red">1522.             query.where.add(lookup, AND)</font>
<font color="red">1523.             query.external_aliases.add(alias)</font>
<font color="black">1524. </font>
<font color="red">1525.         condition, needed_inner = self.build_filter(</font>
<font color="red">1526.             ('%s__in' % trimmed_prefix, query),</font>
<font color="red">1527.             current_negated=True, branch_negated=True, can_reuse=can_reuse)</font>
<font color="red">1528.         if contains_louter:</font>
<font color="red">1529.             or_null_condition, _ = self.build_filter(</font>
<font color="red">1530.                 ('%s__isnull' % trimmed_prefix, True),</font>
<font color="red">1531.                 current_negated=True, branch_negated=True, can_reuse=can_reuse)</font>
<font color="red">1532.             condition.add(or_null_condition, OR)</font>
<font color="black">1533.             # Note that the end result will be:</font>
<font color="black">1534.             # (outercol NOT IN innerq AND outercol IS NOT NULL) OR outercol IS NULL.</font>
<font color="black">1535.             # This might look crazy but due to how IN works, this seems to be</font>
<font color="black">1536.             # correct. If the IS NOT NULL check is removed then outercol NOT</font>
<font color="black">1537.             # IN will return UNKNOWN. If the IS NULL check is removed, then if</font>
<font color="black">1538.             # outercol IS NULL we will not match the row.</font>
<font color="red">1539.         return condition, needed_inner</font>
<font color="black">1540. </font>
<font color="green">1541.     def set_empty(self):</font>
<font color="red">1542.         self.where.add(NothingNode(), AND)</font>
<font color="black">1543. </font>
<font color="green">1544.     def is_empty(self):</font>
<font color="red">1545.         return any(isinstance(c, NothingNode) for c in self.where.children)</font>
<font color="black">1546. </font>
<font color="green">1547.     def set_limits(self, low=None, high=None):</font>
<font color="black">1548.         &quot;&quot;&quot;</font>
<font color="black">1549.         Adjusts the limits on the rows retrieved. We use low/high to set these,</font>
<font color="black">1550.         as it makes it more Pythonic to read and write. When the SQL query is</font>
<font color="black">1551.         created, they are converted to the appropriate offset and limit values.</font>
<font color="black">1552. </font>
<font color="black">1553.         Any limits passed in here are applied relative to the existing</font>
<font color="black">1554.         constraints. So low is added to the current low value and both will be</font>
<font color="black">1555.         clamped to any existing high value.</font>
<font color="black">1556.         &quot;&quot;&quot;</font>
<font color="red">1557.         if high is not None:</font>
<font color="red">1558.             if self.high_mark is not None:</font>
<font color="red">1559.                 self.high_mark = min(self.high_mark, self.low_mark + high)</font>
<font color="black">1560.             else:</font>
<font color="red">1561.                 self.high_mark = self.low_mark + high</font>
<font color="red">1562.         if low is not None:</font>
<font color="red">1563.             if self.high_mark is not None:</font>
<font color="red">1564.                 self.low_mark = min(self.high_mark, self.low_mark + low)</font>
<font color="black">1565.             else:</font>
<font color="red">1566.                 self.low_mark = self.low_mark + low</font>
<font color="black">1567. </font>
<font color="green">1568.     def clear_limits(self):</font>
<font color="black">1569.         &quot;&quot;&quot;</font>
<font color="black">1570.         Clears any existing limits.</font>
<font color="black">1571.         &quot;&quot;&quot;</font>
<font color="red">1572.         self.low_mark, self.high_mark = 0, None</font>
<font color="black">1573. </font>
<font color="green">1574.     def can_filter(self):</font>
<font color="black">1575.         &quot;&quot;&quot;</font>
<font color="black">1576.         Returns True if adding filters to this instance is still possible.</font>
<font color="black">1577. </font>
<font color="black">1578.         Typically, this means no limits or offsets have been put on the results.</font>
<font color="black">1579.         &quot;&quot;&quot;</font>
<font color="green">1580.         return not self.low_mark and self.high_mark is None</font>
<font color="black">1581. </font>
<font color="green">1582.     def clear_select_clause(self):</font>
<font color="black">1583.         &quot;&quot;&quot;</font>
<font color="black">1584.         Removes all fields from SELECT clause.</font>
<font color="black">1585.         &quot;&quot;&quot;</font>
<font color="red">1586.         self.select = []</font>
<font color="red">1587.         self.default_cols = False</font>
<font color="red">1588.         self.select_related = False</font>
<font color="red">1589.         self.set_extra_mask(())</font>
<font color="red">1590.         self.set_annotation_mask(())</font>
<font color="black">1591. </font>
<font color="green">1592.     def clear_select_fields(self):</font>
<font color="black">1593.         &quot;&quot;&quot;</font>
<font color="black">1594.         Clears the list of fields to select (but not extra_select columns).</font>
<font color="black">1595.         Some queryset types completely replace any existing list of select</font>
<font color="black">1596.         columns.</font>
<font color="black">1597.         &quot;&quot;&quot;</font>
<font color="green">1598.         self.select = []</font>
<font color="green">1599.         self.values_select = []</font>
<font color="black">1600. </font>
<font color="green">1601.     def add_select(self, col):</font>
<font color="green">1602.         self.default_cols = False</font>
<font color="green">1603.         self.select.append(col)</font>
<font color="black">1604. </font>
<font color="green">1605.     def set_select(self, cols):</font>
<font color="red">1606.         self.default_cols = False</font>
<font color="red">1607.         self.select = cols</font>
<font color="black">1608. </font>
<font color="green">1609.     def add_distinct_fields(self, *field_names):</font>
<font color="black">1610.         &quot;&quot;&quot;</font>
<font color="black">1611.         Adds and resolves the given fields to the query's &quot;distinct on&quot; clause.</font>
<font color="black">1612.         &quot;&quot;&quot;</font>
<font color="red">1613.         self.distinct_fields = field_names</font>
<font color="red">1614.         self.distinct = True</font>
<font color="black">1615. </font>
<font color="green">1616.     def add_fields(self, field_names, allow_m2m=True):</font>
<font color="black">1617.         &quot;&quot;&quot;</font>
<font color="black">1618.         Adds the given (model) fields to the select set. The field names are</font>
<font color="black">1619.         added in the order specified.</font>
<font color="black">1620.         &quot;&quot;&quot;</font>
<font color="green">1621.         alias = self.get_initial_alias()</font>
<font color="green">1622.         opts = self.get_meta()</font>
<font color="black">1623. </font>
<font color="green">1624.         try:</font>
<font color="green">1625.             for name in field_names:</font>
<font color="black">1626.                 # Join promotion note - we must not remove any rows here, so</font>
<font color="black">1627.                 # if there is no existing joins, use outer join.</font>
<font color="green">1628.                 _, targets, _, joins, path = self.setup_joins(</font>
<font color="green">1629.                     name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)</font>
<font color="green">1630.                 targets, final_alias, joins = self.trim_joins(targets, joins, path)</font>
<font color="green">1631.                 for target in targets:</font>
<font color="green">1632.                     self.add_select(target.get_col(final_alias))</font>
<font color="red">1633.         except MultiJoin:</font>
<font color="red">1634.             raise FieldError(&quot;Invalid field name: '%s'&quot; % name)</font>
<font color="red">1635.         except FieldError:</font>
<font color="red">1636.             if LOOKUP_SEP in name:</font>
<font color="black">1637.                 # For lookups spanning over relationships, show the error</font>
<font color="black">1638.                 # from the model on which the lookup failed.</font>
<font color="red">1639.                 raise</font>
<font color="black">1640.             else:</font>
<font color="red">1641.                 names = sorted(list(get_field_names_from_opts(opts)) + list(self.extra)</font>
<font color="red">1642.                                + list(self.annotation_select))</font>
<font color="red">1643.                 raise FieldError(&quot;Cannot resolve keyword %r into field. &quot;</font>
<font color="red">1644.                                  &quot;Choices are: %s&quot; % (name, &quot;, &quot;.join(names)))</font>
<font color="black">1645. </font>
<font color="green">1646.     def add_ordering(self, *ordering):</font>
<font color="black">1647.         &quot;&quot;&quot;</font>
<font color="black">1648.         Adds items from the 'ordering' sequence to the query's &quot;order by&quot;</font>
<font color="black">1649.         clause. These items are either field names (not column names) --</font>
<font color="black">1650.         possibly with a direction prefix ('-' or '?') -- or OrderBy</font>
<font color="black">1651.         expressions.</font>
<font color="black">1652. </font>
<font color="black">1653.         If 'ordering' is empty, all ordering is cleared from the query.</font>
<font color="black">1654.         &quot;&quot;&quot;</font>
<font color="green">1655.         errors = []</font>
<font color="green">1656.         for item in ordering:</font>
<font color="green">1657.             if not hasattr(item, 'resolve_expression') and not ORDER_PATTERN.match(item):</font>
<font color="red">1658.                 errors.append(item)</font>
<font color="green">1659.             if getattr(item, 'contains_aggregate', False):</font>
<font color="red">1660.                 raise FieldError(</font>
<font color="red">1661.                     'Using an aggregate in order_by() without also including '</font>
<font color="red">1662.                     'it in annotate() is not allowed: %s' % item</font>
<font color="black">1663.                 )</font>
<font color="green">1664.         if errors:</font>
<font color="red">1665.             raise FieldError('Invalid order_by arguments: %s' % errors)</font>
<font color="green">1666.         if ordering:</font>
<font color="green">1667.             self.order_by.extend(ordering)</font>
<font color="black">1668.         else:</font>
<font color="green">1669.             self.default_ordering = False</font>
<font color="black">1670. </font>
<font color="green">1671.     def clear_ordering(self, force_empty):</font>
<font color="black">1672.         &quot;&quot;&quot;</font>
<font color="black">1673.         Removes any ordering settings. If 'force_empty' is True, there will be</font>
<font color="black">1674.         no ordering in the resulting query (not even the model's default).</font>
<font color="black">1675.         &quot;&quot;&quot;</font>
<font color="green">1676.         self.order_by = []</font>
<font color="green">1677.         self.extra_order_by = ()</font>
<font color="green">1678.         if force_empty:</font>
<font color="red">1679.             self.default_ordering = False</font>
<font color="black">1680. </font>
<font color="green">1681.     def set_group_by(self):</font>
<font color="black">1682.         &quot;&quot;&quot;</font>
<font color="black">1683.         Expands the GROUP BY clause required by the query.</font>
<font color="black">1684. </font>
<font color="black">1685.         This will usually be the set of all non-aggregate fields in the</font>
<font color="black">1686.         return data. If the database backend supports grouping by the</font>
<font color="black">1687.         primary key, and the query would be equivalent, the optimization</font>
<font color="black">1688.         will be made automatically.</font>
<font color="black">1689.         &quot;&quot;&quot;</font>
<font color="red">1690.         self.group_by = []</font>
<font color="black">1691. </font>
<font color="red">1692.         for col in self.select:</font>
<font color="red">1693.             self.group_by.append(col)</font>
<font color="black">1694. </font>
<font color="red">1695.         if self.annotation_select:</font>
<font color="red">1696.             for alias, annotation in six.iteritems(self.annotation_select):</font>
<font color="red">1697.                 for col in annotation.get_group_by_cols():</font>
<font color="red">1698.                     self.group_by.append(col)</font>
<font color="black">1699. </font>
<font color="green">1700.     def add_select_related(self, fields):</font>
<font color="black">1701.         &quot;&quot;&quot;</font>
<font color="black">1702.         Sets up the select_related data structure so that we only select</font>
<font color="black">1703.         certain related models (as opposed to all models, when</font>
<font color="black">1704.         self.select_related=True).</font>
<font color="black">1705.         &quot;&quot;&quot;</font>
<font color="red">1706.         if isinstance(self.select_related, bool):</font>
<font color="red">1707.             field_dict = {}</font>
<font color="black">1708.         else:</font>
<font color="red">1709.             field_dict = self.select_related</font>
<font color="red">1710.         for field in fields:</font>
<font color="red">1711.             d = field_dict</font>
<font color="red">1712.             for part in field.split(LOOKUP_SEP):</font>
<font color="red">1713.                 d = d.setdefault(part, {})</font>
<font color="red">1714.         self.select_related = field_dict</font>
<font color="black">1715. </font>
<font color="green">1716.     def add_extra(self, select, select_params, where, params, tables, order_by):</font>
<font color="black">1717.         &quot;&quot;&quot;</font>
<font color="black">1718.         Adds data to the various extra_* attributes for user-created additions</font>
<font color="black">1719.         to the query.</font>
<font color="black">1720.         &quot;&quot;&quot;</font>
<font color="red">1721.         if select:</font>
<font color="black">1722.             # We need to pair any placeholder markers in the 'select'</font>
<font color="black">1723.             # dictionary with their parameters in 'select_params' so that</font>
<font color="black">1724.             # subsequent updates to the select dictionary also adjust the</font>
<font color="black">1725.             # parameters appropriately.</font>
<font color="red">1726.             select_pairs = OrderedDict()</font>
<font color="red">1727.             if select_params:</font>
<font color="red">1728.                 param_iter = iter(select_params)</font>
<font color="black">1729.             else:</font>
<font color="red">1730.                 param_iter = iter([])</font>
<font color="red">1731.             for name, entry in select.items():</font>
<font color="red">1732.                 entry = force_text(entry)</font>
<font color="red">1733.                 entry_params = []</font>
<font color="red">1734.                 pos = entry.find(&quot;%s&quot;)</font>
<font color="red">1735.                 while pos != -1:</font>
<font color="red">1736.                     if pos == 0 or entry[pos - 1] != '%':</font>
<font color="red">1737.                         entry_params.append(next(param_iter))</font>
<font color="red">1738.                     pos = entry.find(&quot;%s&quot;, pos + 2)</font>
<font color="red">1739.                 select_pairs[name] = (entry, entry_params)</font>
<font color="black">1740.             # This is order preserving, since self.extra_select is an OrderedDict.</font>
<font color="red">1741.             self.extra.update(select_pairs)</font>
<font color="red">1742.         if where or params:</font>
<font color="red">1743.             self.where.add(ExtraWhere(where, params), AND)</font>
<font color="red">1744.         if tables:</font>
<font color="red">1745.             self.extra_tables += tuple(tables)</font>
<font color="red">1746.         if order_by:</font>
<font color="red">1747.             self.extra_order_by = order_by</font>
<font color="black">1748. </font>
<font color="green">1749.     def clear_deferred_loading(self):</font>
<font color="black">1750.         &quot;&quot;&quot;</font>
<font color="black">1751.         Remove any fields from the deferred loading set.</font>
<font color="black">1752.         &quot;&quot;&quot;</font>
<font color="green">1753.         self.deferred_loading = (set(), True)</font>
<font color="black">1754. </font>
<font color="green">1755.     def add_deferred_loading(self, field_names):</font>
<font color="black">1756.         &quot;&quot;&quot;</font>
<font color="black">1757.         Add the given list of model field names to the set of fields to</font>
<font color="black">1758.         exclude from loading from the database when automatic column selection</font>
<font color="black">1759.         is done. The new field names are added to any existing field names that</font>
<font color="black">1760.         are deferred (or removed from any existing field names that are marked</font>
<font color="black">1761.         as the only ones for immediate loading).</font>
<font color="black">1762.         &quot;&quot;&quot;</font>
<font color="black">1763.         # Fields on related models are stored in the literal double-underscore</font>
<font color="black">1764.         # format, so that we can use a set datastructure. We do the foo__bar</font>
<font color="black">1765.         # splitting and handling when computing the SQL column names (as part of</font>
<font color="black">1766.         # get_columns()).</font>
<font color="red">1767.         existing, defer = self.deferred_loading</font>
<font color="red">1768.         if defer:</font>
<font color="black">1769.             # Add to existing deferred names.</font>
<font color="red">1770.             self.deferred_loading = existing.union(field_names), True</font>
<font color="black">1771.         else:</font>
<font color="black">1772.             # Remove names from the set of any existing &quot;immediate load&quot; names.</font>
<font color="red">1773.             self.deferred_loading = existing.difference(field_names), False</font>
<font color="black">1774. </font>
<font color="green">1775.     def add_immediate_loading(self, field_names):</font>
<font color="black">1776.         &quot;&quot;&quot;</font>
<font color="black">1777.         Add the given list of model field names to the set of fields to</font>
<font color="black">1778.         retrieve when the SQL is executed (&quot;immediate loading&quot; fields). The</font>
<font color="black">1779.         field names replace any existing immediate loading field names. If</font>
<font color="black">1780.         there are field names already specified for deferred loading, those</font>
<font color="black">1781.         names are removed from the new field_names before storing the new names</font>
<font color="black">1782.         for immediate loading. (That is, immediate loading overrides any</font>
<font color="black">1783.         existing immediate values, but respects existing deferrals.)</font>
<font color="black">1784.         &quot;&quot;&quot;</font>
<font color="red">1785.         existing, defer = self.deferred_loading</font>
<font color="red">1786.         field_names = set(field_names)</font>
<font color="red">1787.         if 'pk' in field_names:</font>
<font color="red">1788.             field_names.remove('pk')</font>
<font color="red">1789.             field_names.add(self.get_meta().pk.name)</font>
<font color="black">1790. </font>
<font color="red">1791.         if defer:</font>
<font color="black">1792.             # Remove any existing deferred names from the current set before</font>
<font color="black">1793.             # setting the new names.</font>
<font color="red">1794.             self.deferred_loading = field_names.difference(existing), False</font>
<font color="black">1795.         else:</font>
<font color="black">1796.             # Replace any existing &quot;immediate load&quot; field names.</font>
<font color="red">1797.             self.deferred_loading = field_names, False</font>
<font color="black">1798. </font>
<font color="green">1799.     def get_loaded_field_names(self):</font>
<font color="black">1800.         &quot;&quot;&quot;</font>
<font color="black">1801.         If any fields are marked to be deferred, returns a dictionary mapping</font>
<font color="black">1802.         models to a set of names in those fields that will be loaded. If a</font>
<font color="black">1803.         model is not in the returned dictionary, none of its fields are</font>
<font color="black">1804.         deferred.</font>
<font color="black">1805. </font>
<font color="black">1806.         If no fields are marked for deferral, returns an empty dictionary.</font>
<font color="black">1807.         &quot;&quot;&quot;</font>
<font color="black">1808.         # We cache this because we call this function multiple times</font>
<font color="black">1809.         # (compiler.fill_related_selections, query.iterator)</font>
<font color="red">1810.         try:</font>
<font color="red">1811.             return self._loaded_field_names_cache</font>
<font color="red">1812.         except AttributeError:</font>
<font color="red">1813.             collection = {}</font>
<font color="red">1814.             self.deferred_to_data(collection, self.get_loaded_field_names_cb)</font>
<font color="red">1815.             self._loaded_field_names_cache = collection</font>
<font color="red">1816.             return collection</font>
<font color="black">1817. </font>
<font color="green">1818.     def get_loaded_field_names_cb(self, target, model, fields):</font>
<font color="black">1819.         &quot;&quot;&quot;</font>
<font color="black">1820.         Callback used by get_deferred_field_names().</font>
<font color="black">1821.         &quot;&quot;&quot;</font>
<font color="red">1822.         target[model] = {f.attname for f in fields}</font>
<font color="black">1823. </font>
<font color="green">1824.     def set_aggregate_mask(self, names):</font>
<font color="red">1825.         warnings.warn(</font>
<font color="red">1826.             &quot;set_aggregate_mask() is deprecated. Use set_annotation_mask() instead.&quot;,</font>
<font color="red">1827.             RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red">1828.         self.set_annotation_mask(names)</font>
<font color="black">1829. </font>
<font color="green">1830.     def set_annotation_mask(self, names):</font>
<font color="black">1831.         &quot;Set the mask of annotations that will actually be returned by the SELECT&quot;</font>
<font color="green">1832.         if names is None:</font>
<font color="red">1833.             self.annotation_select_mask = None</font>
<font color="black">1834.         else:</font>
<font color="green">1835.             self.annotation_select_mask = set(names)</font>
<font color="green">1836.         self._annotation_select_cache = None</font>
<font color="black">1837. </font>
<font color="green">1838.     def append_aggregate_mask(self, names):</font>
<font color="red">1839.         warnings.warn(</font>
<font color="red">1840.             &quot;append_aggregate_mask() is deprecated. Use append_annotation_mask() instead.&quot;,</font>
<font color="red">1841.             RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red">1842.         self.append_annotation_mask(names)</font>
<font color="black">1843. </font>
<font color="green">1844.     def append_annotation_mask(self, names):</font>
<font color="red">1845.         if self.annotation_select_mask is not None:</font>
<font color="red">1846.             self.set_annotation_mask(set(names).union(self.annotation_select_mask))</font>
<font color="black">1847. </font>
<font color="green">1848.     def set_extra_mask(self, names):</font>
<font color="black">1849.         &quot;&quot;&quot;</font>
<font color="black">1850.         Set the mask of extra select items that will be returned by SELECT,</font>
<font color="black">1851.         we don't actually remove them from the Query since they might be used</font>
<font color="black">1852.         later</font>
<font color="black">1853.         &quot;&quot;&quot;</font>
<font color="green">1854.         if names is None:</font>
<font color="red">1855.             self.extra_select_mask = None</font>
<font color="black">1856.         else:</font>
<font color="green">1857.             self.extra_select_mask = set(names)</font>
<font color="green">1858.         self._extra_select_cache = None</font>
<font color="black">1859. </font>
<font color="green">1860.     @property</font>
<font color="black">1861.     def annotation_select(self):</font>
<font color="black">1862.         &quot;&quot;&quot;The OrderedDict of aggregate columns that are not masked, and should</font>
<font color="black">1863.         be used in the SELECT clause.</font>
<font color="black">1864. </font>
<font color="black">1865.         This result is cached for optimization purposes.</font>
<font color="black">1866.         &quot;&quot;&quot;</font>
<font color="green">1867.         if self._annotation_select_cache is not None:</font>
<font color="red">1868.             return self._annotation_select_cache</font>
<font color="green">1869.         elif not self._annotations:</font>
<font color="green">1870.             return {}</font>
<font color="red">1871.         elif self.annotation_select_mask is not None:</font>
<font color="red">1872.             self._annotation_select_cache = OrderedDict(</font>
<font color="red">1873.                 (k, v) for k, v in self.annotations.items()</font>
<font color="red">1874.                 if k in self.annotation_select_mask</font>
<font color="black">1875.             )</font>
<font color="red">1876.             return self._annotation_select_cache</font>
<font color="black">1877.         else:</font>
<font color="red">1878.             return self.annotations</font>
<font color="black">1879. </font>
<font color="green">1880.     @property</font>
<font color="black">1881.     def aggregate_select(self):</font>
<font color="red">1882.         warnings.warn(</font>
<font color="red">1883.             &quot;aggregate_select() is deprecated. Use annotation_select() instead.&quot;,</font>
<font color="red">1884.             RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red">1885.         return self.annotation_select</font>
<font color="black">1886. </font>
<font color="green">1887.     @property</font>
<font color="black">1888.     def extra_select(self):</font>
<font color="green">1889.         if self._extra_select_cache is not None:</font>
<font color="red">1890.             return self._extra_select_cache</font>
<font color="green">1891.         if not self._extra:</font>
<font color="green">1892.             return {}</font>
<font color="red">1893.         elif self.extra_select_mask is not None:</font>
<font color="red">1894.             self._extra_select_cache = OrderedDict(</font>
<font color="red">1895.                 (k, v) for k, v in self.extra.items()</font>
<font color="red">1896.                 if k in self.extra_select_mask</font>
<font color="black">1897.             )</font>
<font color="red">1898.             return self._extra_select_cache</font>
<font color="black">1899.         else:</font>
<font color="red">1900.             return self.extra</font>
<font color="black">1901. </font>
<font color="green">1902.     def trim_start(self, names_with_path):</font>
<font color="black">1903.         &quot;&quot;&quot;</font>
<font color="black">1904.         Trims joins from the start of the join path. The candidates for trim</font>
<font color="black">1905.         are the PathInfos in names_with_path structure that are m2m joins.</font>
<font color="black">1906. </font>
<font color="black">1907.         Also sets the select column so the start matches the join.</font>
<font color="black">1908. </font>
<font color="black">1909.         This method is meant to be used for generating the subquery joins &amp;</font>
<font color="black">1910.         cols in split_exclude().</font>
<font color="black">1911. </font>
<font color="black">1912.         Returns a lookup usable for doing outerq.filter(lookup=self). Returns</font>
<font color="black">1913.         also if the joins in the prefix contain a LEFT OUTER join.</font>
<font color="black">1914.         _&quot;&quot;&quot;</font>
<font color="red">1915.         all_paths = []</font>
<font color="red">1916.         for _, paths in names_with_path:</font>
<font color="red">1917.             all_paths.extend(paths)</font>
<font color="red">1918.         contains_louter = False</font>
<font color="black">1919.         # Trim and operate only on tables that were generated for</font>
<font color="black">1920.         # the lookup part of the query. That is, avoid trimming</font>
<font color="black">1921.         # joins generated for F() expressions.</font>
<font color="red">1922.         lookup_tables = [t for t in self.tables if t in self._lookup_joins or t == self.tables[0]]</font>
<font color="red">1923.         for trimmed_paths, path in enumerate(all_paths):</font>
<font color="red">1924.             if path.m2m:</font>
<font color="red">1925.                 break</font>
<font color="red">1926.             if self.alias_map[lookup_tables[trimmed_paths + 1]].join_type == LOUTER:</font>
<font color="red">1927.                 contains_louter = True</font>
<font color="red">1928.             alias = lookup_tables[trimmed_paths]</font>
<font color="red">1929.             self.unref_alias(alias)</font>
<font color="black">1930.         # The path.join_field is a Rel, lets get the other side's field</font>
<font color="red">1931.         join_field = path.join_field.field</font>
<font color="black">1932.         # Build the filter prefix.</font>
<font color="red">1933.         paths_in_prefix = trimmed_paths</font>
<font color="red">1934.         trimmed_prefix = []</font>
<font color="red">1935.         for name, path in names_with_path:</font>
<font color="red">1936.             if paths_in_prefix - len(path) &lt; 0:</font>
<font color="red">1937.                 break</font>
<font color="red">1938.             trimmed_prefix.append(name)</font>
<font color="red">1939.             paths_in_prefix -= len(path)</font>
<font color="red">1940.         trimmed_prefix.append(</font>
<font color="red">1941.             join_field.foreign_related_fields[0].name)</font>
<font color="red">1942.         trimmed_prefix = LOOKUP_SEP.join(trimmed_prefix)</font>
<font color="black">1943.         # Lets still see if we can trim the first join from the inner query</font>
<font color="black">1944.         # (that is, self). We can't do this for LEFT JOINs because we would</font>
<font color="black">1945.         # miss those rows that have nothing on the outer side.</font>
<font color="red">1946.         if self.alias_map[lookup_tables[trimmed_paths + 1]].join_type != LOUTER:</font>
<font color="red">1947.             select_fields = [r[0] for r in join_field.related_fields]</font>
<font color="red">1948.             select_alias = lookup_tables[trimmed_paths + 1]</font>
<font color="red">1949.             self.unref_alias(lookup_tables[trimmed_paths])</font>
<font color="red">1950.             extra_restriction = join_field.get_extra_restriction(</font>
<font color="red">1951.                 self.where_class, None, lookup_tables[trimmed_paths + 1])</font>
<font color="red">1952.             if extra_restriction:</font>
<font color="red">1953.                 self.where.add(extra_restriction, AND)</font>
<font color="black">1954.         else:</font>
<font color="black">1955.             # TODO: It might be possible to trim more joins from the start of the</font>
<font color="black">1956.             # inner query if it happens to have a longer join chain containing the</font>
<font color="black">1957.             # values in select_fields. Lets punt this one for now.</font>
<font color="red">1958.             select_fields = [r[1] for r in join_field.related_fields]</font>
<font color="red">1959.             select_alias = lookup_tables[trimmed_paths]</font>
<font color="black">1960.         # The found starting point is likely a Join instead of a BaseTable reference.</font>
<font color="black">1961.         # But the first entry in the query's FROM clause must not be a JOIN.</font>
<font color="red">1962.         for table in self.tables:</font>
<font color="red">1963.             if self.alias_refcount[table] &gt; 0:</font>
<font color="red">1964.                 self.alias_map[table] = BaseTable(self.alias_map[table].table_name, table)</font>
<font color="red">1965.                 break</font>
<font color="red">1966.         self.set_select([f.get_col(select_alias) for f in select_fields])</font>
<font color="red">1967.         return trimmed_prefix, contains_louter</font>
<font color="black">1968. </font>
<font color="green">1969.     def is_nullable(self, field):</font>
<font color="black">1970.         &quot;&quot;&quot;</font>
<font color="black">1971.         A helper to check if the given field should be treated as nullable.</font>
<font color="black">1972. </font>
<font color="black">1973.         Some backends treat '' as null and Django treats such fields as</font>
<font color="black">1974.         nullable for those backends. In such situations field.null can be</font>
<font color="black">1975.         False even if we should treat the field as nullable.</font>
<font color="black">1976.         &quot;&quot;&quot;</font>
<font color="black">1977.         # We need to use DEFAULT_DB_ALIAS here, as QuerySet does not have</font>
<font color="black">1978.         # (nor should it have) knowledge of which connection is going to be</font>
<font color="black">1979.         # used. The proper fix would be to defer all decisions where</font>
<font color="black">1980.         # is_nullable() is needed to the compiler stage, but that is not easy</font>
<font color="black">1981.         # to do currently.</font>
<font color="green">1982.         if ((connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls)</font>
<font color="red">1983.                 and field.empty_strings_allowed):</font>
<font color="red">1984.             return True</font>
<font color="black">1985.         else:</font>
<font color="green">1986.             return field.null</font>
<font color="black">1987. </font>
<font color="black">1988. </font>
<font color="green">1989. def get_order_dir(field, default='ASC'):</font>
<font color="black">1990.     &quot;&quot;&quot;</font>
<font color="black">1991.     Returns the field name and direction for an order specification. For</font>
<font color="black">1992.     example, '-foo' is returned as ('foo', 'DESC').</font>
<font color="black">1993. </font>
<font color="black">1994.     The 'default' param is used to indicate which way no prefix (or a '+'</font>
<font color="black">1995.     prefix) should sort. The '-' prefix always sorts the opposite way.</font>
<font color="black">1996.     &quot;&quot;&quot;</font>
<font color="green">1997.     dirn = ORDER_DIR[default]</font>
<font color="green">1998.     if field[0] == '-':</font>
<font color="red">1999.         return field[1:], dirn[1]</font>
<font color="green">2000.     return field, dirn[0]</font>
<font color="black">2001. </font>
<font color="black">2002. </font>
<font color="green">2003. def add_to_dict(data, key, value):</font>
<font color="black">2004.     &quot;&quot;&quot;</font>
<font color="black">2005.     A helper function to add &quot;value&quot; to the set of values for &quot;key&quot;, whether or</font>
<font color="black">2006.     not &quot;key&quot; already exists.</font>
<font color="black">2007.     &quot;&quot;&quot;</font>
<font color="red">2008.     if key in data:</font>
<font color="red">2009.         data[key].add(value)</font>
<font color="black">2010.     else:</font>
<font color="red">2011.         data[key] = {value}</font>
<font color="black">2012. </font>
<font color="black">2013. </font>
<font color="green">2014. def is_reverse_o2o(field):</font>
<font color="black">2015.     &quot;&quot;&quot;</font>
<font color="black">2016.     A little helper to check if the given field is reverse-o2o. The field is</font>
<font color="black">2017.     expected to be some sort of relation field or related object.</font>
<font color="black">2018.     &quot;&quot;&quot;</font>
<font color="red">2019.     return field.is_relation and field.one_to_one and not field.concrete</font>
<font color="black">2020. </font>
<font color="black">2021. </font>
<font color="green">2022. class JoinPromoter(object):</font>
<font color="black">2023.     &quot;&quot;&quot;</font>
<font color="black">2024.     A class to abstract away join promotion problems for complex filter</font>
<font color="black">2025.     conditions.</font>
<font color="green">2026.     &quot;&quot;&quot;</font>
<font color="black">2027. </font>
<font color="green">2028.     def __init__(self, connector, num_children, negated):</font>
<font color="green">2029.         self.connector = connector</font>
<font color="green">2030.         self.negated = negated</font>
<font color="green">2031.         if self.negated:</font>
<font color="red">2032.             if connector == AND:</font>
<font color="red">2033.                 self.effective_connector = OR</font>
<font color="black">2034.             else:</font>
<font color="red">2035.                 self.effective_connector = AND</font>
<font color="black">2036.         else:</font>
<font color="green">2037.             self.effective_connector = self.connector</font>
<font color="green">2038.         self.num_children = num_children</font>
<font color="black">2039.         # Maps of table alias to how many times it is seen as required for</font>
<font color="black">2040.         # inner and/or outer joins.</font>
<font color="green">2041.         self.votes = Counter()</font>
<font color="black">2042. </font>
<font color="green">2043.     def add_votes(self, votes):</font>
<font color="black">2044.         &quot;&quot;&quot;</font>
<font color="black">2045.         Add single vote per item to self.votes. Parameter can be any</font>
<font color="black">2046.         iterable.</font>
<font color="black">2047.         &quot;&quot;&quot;</font>
<font color="green">2048.         self.votes.update(votes)</font>
<font color="black">2049. </font>
<font color="green">2050.     def update_join_types(self, query):</font>
<font color="black">2051.         &quot;&quot;&quot;</font>
<font color="black">2052.         Change join types so that the generated query is as efficient as</font>
<font color="black">2053.         possible, but still correct. So, change as many joins as possible</font>
<font color="black">2054.         to INNER, but don't make OUTER joins INNER if that could remove</font>
<font color="black">2055.         results from the query.</font>
<font color="black">2056.         &quot;&quot;&quot;</font>
<font color="green">2057.         to_promote = set()</font>
<font color="green">2058.         to_demote = set()</font>
<font color="black">2059.         # The effective_connector is used so that NOT (a AND b) is treated</font>
<font color="black">2060.         # similarly to (a OR b) for join promotion.</font>
<font color="green">2061.         for table, votes in self.votes.items():</font>
<font color="black">2062.             # We must use outer joins in OR case when the join isn't contained</font>
<font color="black">2063.             # in all of the joins. Otherwise the INNER JOIN itself could remove</font>
<font color="black">2064.             # valid results. Consider the case where a model with rel_a and</font>
<font color="black">2065.             # rel_b relations is queried with rel_a__col=1 | rel_b__col=2. Now,</font>
<font color="black">2066.             # if rel_a join doesn't produce any results is null (for example</font>
<font color="black">2067.             # reverse foreign key or null value in direct foreign key), and</font>
<font color="black">2068.             # there is a matching row in rel_b with col=2, then an INNER join</font>
<font color="black">2069.             # to rel_a would remove a valid match from the query. So, we need</font>
<font color="black">2070.             # to promote any existing INNER to LOUTER (it is possible this</font>
<font color="black">2071.             # promotion in turn will be demoted later on).</font>
<font color="green">2072.             if self.effective_connector == 'OR' and votes &lt; self.num_children:</font>
<font color="red">2073.                 to_promote.add(table)</font>
<font color="black">2074.             # If connector is AND and there is a filter that can match only</font>
<font color="black">2075.             # when there is a joinable row, then use INNER. For example, in</font>
<font color="black">2076.             # rel_a__col=1 &amp; rel_b__col=2, if either of the rels produce NULL</font>
<font color="black">2077.             # as join output, then the col=1 or col=2 can't match (as</font>
<font color="black">2078.             # NULL=anything is always false).</font>
<font color="black">2079.             # For the OR case, if all children voted for a join to be inner,</font>
<font color="black">2080.             # then we can use INNER for the join. For example:</font>
<font color="black">2081.             #     (rel_a__col__icontains=Alex | rel_a__col__icontains=Russell)</font>
<font color="black">2082.             # then if rel_a doesn't produce any rows, the whole condition</font>
<font color="black">2083.             # can't match. Hence we can safely use INNER join.</font>
<font color="green">2084.             if self.effective_connector == 'AND' or (</font>
<font color="red">2085.                     self.effective_connector == 'OR' and votes == self.num_children):</font>
<font color="green">2086.                 to_demote.add(table)</font>
<font color="black">2087.             # Finally, what happens in cases where we have:</font>
<font color="black">2088.             #    (rel_a__col=1|rel_b__col=2) &amp; rel_a__col__gte=0</font>
<font color="black">2089.             # Now, we first generate the OR clause, and promote joins for it</font>
<font color="black">2090.             # in the first if branch above. Both rel_a and rel_b are promoted</font>
<font color="black">2091.             # to LOUTER joins. After that we do the AND case. The OR case</font>
<font color="black">2092.             # voted no inner joins but the rel_a__col__gte=0 votes inner join</font>
<font color="black">2093.             # for rel_a. We demote it back to INNER join (in AND case a single</font>
<font color="black">2094.             # vote is enough). The demotion is OK, if rel_a doesn't produce</font>
<font color="black">2095.             # rows, then the rel_a__col__gte=0 clause can't be true, and thus</font>
<font color="black">2096.             # the whole clause must be false. So, it is safe to use INNER</font>
<font color="black">2097.             # join.</font>
<font color="black">2098.             # Note that in this example we could just as well have the __gte</font>
<font color="black">2099.             # clause and the OR clause swapped. Or we could replace the __gte</font>
<font color="black">2100.             # clause with an OR clause containing rel_a__col=1|rel_a__col=2,</font>
<font color="black">2101.             # and again we could safely demote to INNER.</font>
<font color="green">2102.         query.promote_joins(to_promote)</font>
<font color="green">2103.         query.demote_joins(to_demote)</font>
<font color="green">2104.         return to_demote</font>
</pre>

