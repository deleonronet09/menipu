source file: <b>/usr/lib/python2.7/unittest/loader.py</b><br>


file stats: <b>209 lines, 107 executed: 51.2% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Loading unittests.&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="green">   3. import os</font>
<font color="green">   4. import re</font>
<font color="green">   5. import sys</font>
<font color="green">   6. import traceback</font>
<font color="green">   7. import types</font>
<font color="black">   8. </font>
<font color="green">   9. from functools import cmp_to_key as _CmpToKey</font>
<font color="green">  10. from fnmatch import fnmatch</font>
<font color="black">  11. </font>
<font color="green">  12. from . import case, suite</font>
<font color="black">  13. </font>
<font color="green">  14. __unittest = True</font>
<font color="black">  15. </font>
<font color="black">  16. # what about .pyc or .pyo (etc)</font>
<font color="black">  17. # we would need to avoid loading the same tests multiple times</font>
<font color="black">  18. # from '.py', '.pyc' *and* '.pyo'</font>
<font color="green">  19. VALID_MODULE_NAME = re.compile(r'[_a-z]\w*\.py$', re.IGNORECASE)</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. def _make_failed_import_test(name, suiteClass):</font>
<font color="red">  23.     message = 'Failed to import test module: %s\n%s' % (name, traceback.format_exc())</font>
<font color="red">  24.     return _make_failed_test('ModuleImportFailure', name, ImportError(message),</font>
<font color="red">  25.                              suiteClass)</font>
<font color="black">  26. </font>
<font color="green">  27. def _make_failed_load_tests(name, exception, suiteClass):</font>
<font color="red">  28.     return _make_failed_test('LoadTestsFailure', name, exception, suiteClass)</font>
<font color="black">  29. </font>
<font color="green">  30. def _make_failed_test(classname, methodname, exception, suiteClass):</font>
<font color="red">  31.     def testFailure(self):</font>
<font color="red">  32.         raise exception</font>
<font color="red">  33.     attrs = {methodname: testFailure}</font>
<font color="red">  34.     TestClass = type(classname, (case.TestCase,), attrs)</font>
<font color="red">  35.     return suiteClass((TestClass(methodname),))</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. class TestLoader(object):</font>
<font color="black">  39.     &quot;&quot;&quot;</font>
<font color="black">  40.     This class is responsible for loading tests according to various criteria</font>
<font color="black">  41.     and returning them wrapped in a TestSuite</font>
<font color="green">  42.     &quot;&quot;&quot;</font>
<font color="green">  43.     testMethodPrefix = 'test'</font>
<font color="green">  44.     sortTestMethodsUsing = cmp</font>
<font color="green">  45.     suiteClass = suite.TestSuite</font>
<font color="green">  46.     _top_level_dir = None</font>
<font color="black">  47. </font>
<font color="green">  48.     def loadTestsFromTestCase(self, testCaseClass):</font>
<font color="black">  49.         &quot;&quot;&quot;Return a suite of all tests cases contained in testCaseClass&quot;&quot;&quot;</font>
<font color="green">  50.         if issubclass(testCaseClass, suite.TestSuite):</font>
<font color="red">  51.             raise TypeError(&quot;Test cases should not be derived from TestSuite.&quot; \</font>
<font color="black">  52.                                 &quot; Maybe you meant to derive from TestCase?&quot;)</font>
<font color="green">  53.         testCaseNames = self.getTestCaseNames(testCaseClass)</font>
<font color="green">  54.         if not testCaseNames and hasattr(testCaseClass, 'runTest'):</font>
<font color="red">  55.             testCaseNames = ['runTest']</font>
<font color="green">  56.         loaded_suite = self.suiteClass(map(testCaseClass, testCaseNames))</font>
<font color="green">  57.         return loaded_suite</font>
<font color="black">  58. </font>
<font color="green">  59.     def loadTestsFromModule(self, module, use_load_tests=True):</font>
<font color="black">  60.         &quot;&quot;&quot;Return a suite of all tests cases contained in the given module&quot;&quot;&quot;</font>
<font color="green">  61.         tests = []</font>
<font color="green">  62.         for name in dir(module):</font>
<font color="green">  63.             obj = getattr(module, name)</font>
<font color="green">  64.             if isinstance(obj, type) and issubclass(obj, case.TestCase):</font>
<font color="green">  65.                 tests.append(self.loadTestsFromTestCase(obj))</font>
<font color="black">  66. </font>
<font color="green">  67.         load_tests = getattr(module, 'load_tests', None)</font>
<font color="green">  68.         tests = self.suiteClass(tests)</font>
<font color="green">  69.         if use_load_tests and load_tests is not None:</font>
<font color="red">  70.             try:</font>
<font color="red">  71.                 return load_tests(self, tests, None)</font>
<font color="red">  72.             except Exception, e:</font>
<font color="red">  73.                 return _make_failed_load_tests(module.__name__, e,</font>
<font color="red">  74.                                                self.suiteClass)</font>
<font color="green">  75.         return tests</font>
<font color="black">  76. </font>
<font color="green">  77.     def loadTestsFromName(self, name, module=None):</font>
<font color="black">  78.         &quot;&quot;&quot;Return a suite of all tests cases given a string specifier.</font>
<font color="black">  79. </font>
<font color="black">  80.         The name may resolve either to a module, a test case class, a</font>
<font color="black">  81.         test method within a test case class, or a callable object which</font>
<font color="black">  82.         returns a TestCase or TestSuite instance.</font>
<font color="black">  83. </font>
<font color="black">  84.         The method optionally resolves the names relative to a given module.</font>
<font color="black">  85.         &quot;&quot;&quot;</font>
<font color="red">  86.         parts = name.split('.')</font>
<font color="red">  87.         if module is None:</font>
<font color="red">  88.             parts_copy = parts[:]</font>
<font color="red">  89.             while parts_copy:</font>
<font color="red">  90.                 try:</font>
<font color="red">  91.                     module = __import__('.'.join(parts_copy))</font>
<font color="red">  92.                     break</font>
<font color="red">  93.                 except ImportError:</font>
<font color="red">  94.                     del parts_copy[-1]</font>
<font color="red">  95.                     if not parts_copy:</font>
<font color="red">  96.                         raise</font>
<font color="red">  97.             parts = parts[1:]</font>
<font color="red">  98.         obj = module</font>
<font color="red">  99.         for part in parts:</font>
<font color="red"> 100.             parent, obj = obj, getattr(obj, part)</font>
<font color="black"> 101. </font>
<font color="red"> 102.         if isinstance(obj, types.ModuleType):</font>
<font color="red"> 103.             return self.loadTestsFromModule(obj)</font>
<font color="red"> 104.         elif isinstance(obj, type) and issubclass(obj, case.TestCase):</font>
<font color="red"> 105.             return self.loadTestsFromTestCase(obj)</font>
<font color="red"> 106.         elif (isinstance(obj, types.UnboundMethodType) and</font>
<font color="red"> 107.               isinstance(parent, type) and</font>
<font color="red"> 108.               issubclass(parent, case.TestCase)):</font>
<font color="red"> 109.             name = parts[-1]</font>
<font color="red"> 110.             inst = parent(name)</font>
<font color="red"> 111.             return self.suiteClass([inst])</font>
<font color="red"> 112.         elif isinstance(obj, suite.TestSuite):</font>
<font color="red"> 113.             return obj</font>
<font color="red"> 114.         elif hasattr(obj, '__call__'):</font>
<font color="red"> 115.             test = obj()</font>
<font color="red"> 116.             if isinstance(test, suite.TestSuite):</font>
<font color="red"> 117.                 return test</font>
<font color="red"> 118.             elif isinstance(test, case.TestCase):</font>
<font color="red"> 119.                 return self.suiteClass([test])</font>
<font color="black"> 120.             else:</font>
<font color="red"> 121.                 raise TypeError(&quot;calling %s returned %s, not a test&quot; %</font>
<font color="red"> 122.                                 (obj, test))</font>
<font color="black"> 123.         else:</font>
<font color="red"> 124.             raise TypeError(&quot;don't know how to make test from: %s&quot; % obj)</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def loadTestsFromNames(self, names, module=None):</font>
<font color="black"> 127.         &quot;&quot;&quot;Return a suite of all tests cases found using the given sequence</font>
<font color="black"> 128.         of string specifiers. See 'loadTestsFromName()'.</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="red"> 130.         suites = [self.loadTestsFromName(name, module) for name in names]</font>
<font color="red"> 131.         return self.suiteClass(suites)</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def getTestCaseNames(self, testCaseClass):</font>
<font color="black"> 134.         &quot;&quot;&quot;Return a sorted sequence of method names found within testCaseClass</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="green"> 136.         def isTestMethod(attrname, testCaseClass=testCaseClass,</font>
<font color="green"> 137.                          prefix=self.testMethodPrefix):</font>
<font color="green"> 138.             return attrname.startswith(prefix) and \</font>
<font color="green"> 139.                 hasattr(getattr(testCaseClass, attrname), '__call__')</font>
<font color="green"> 140.         testFnNames = filter(isTestMethod, dir(testCaseClass))</font>
<font color="green"> 141.         if self.sortTestMethodsUsing:</font>
<font color="green"> 142.             testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))</font>
<font color="green"> 143.         return testFnNames</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def discover(self, start_dir, pattern='test*.py', top_level_dir=None):</font>
<font color="black"> 146.         &quot;&quot;&quot;Find and return all test modules from the specified start</font>
<font color="black"> 147.         directory, recursing into subdirectories to find them. Only test files</font>
<font color="black"> 148.         that match the pattern will be loaded. (Using shell style pattern</font>
<font color="black"> 149.         matching.)</font>
<font color="black"> 150. </font>
<font color="black"> 151.         All test modules must be importable from the top level of the project.</font>
<font color="black"> 152.         If the start directory is not the top level directory then the top</font>
<font color="black"> 153.         level directory must be specified separately.</font>
<font color="black"> 154. </font>
<font color="black"> 155.         If a test package name (directory with '__init__.py') matches the</font>
<font color="black"> 156.         pattern then the package will be checked for a 'load_tests' function. If</font>
<font color="black"> 157.         this exists then it will be called with loader, tests, pattern.</font>
<font color="black"> 158. </font>
<font color="black"> 159.         If load_tests exists then discovery does  *not* recurse into the package,</font>
<font color="black"> 160.         load_tests is responsible for loading all tests in the package.</font>
<font color="black"> 161. </font>
<font color="black"> 162.         The pattern is deliberately not stored as a loader attribute so that</font>
<font color="black"> 163.         packages can continue discovery themselves. top_level_dir is stored so</font>
<font color="black"> 164.         load_tests does not need to pass this argument in to loader.discover().</font>
<font color="black"> 165.         &quot;&quot;&quot;</font>
<font color="green"> 166.         set_implicit_top = False</font>
<font color="green"> 167.         if top_level_dir is None and self._top_level_dir is not None:</font>
<font color="black"> 168.             # make top_level_dir optional if called from load_tests in a package</font>
<font color="red"> 169.             top_level_dir = self._top_level_dir</font>
<font color="green"> 170.         elif top_level_dir is None:</font>
<font color="red"> 171.             set_implicit_top = True</font>
<font color="red"> 172.             top_level_dir = start_dir</font>
<font color="black"> 173. </font>
<font color="green"> 174.         top_level_dir = os.path.abspath(top_level_dir)</font>
<font color="black"> 175. </font>
<font color="green"> 176.         if not top_level_dir in sys.path:</font>
<font color="black"> 177.             # all test modules must be importable from the top level directory</font>
<font color="black"> 178.             # should we *unconditionally* put the start directory in first</font>
<font color="black"> 179.             # in sys.path to minimise likelihood of conflicts between installed</font>
<font color="black"> 180.             # modules and development versions?</font>
<font color="green"> 181.             sys.path.insert(0, top_level_dir)</font>
<font color="green"> 182.         self._top_level_dir = top_level_dir</font>
<font color="black"> 183. </font>
<font color="green"> 184.         is_not_importable = False</font>
<font color="green"> 185.         if os.path.isdir(os.path.abspath(start_dir)):</font>
<font color="green"> 186.             start_dir = os.path.abspath(start_dir)</font>
<font color="green"> 187.             if start_dir != top_level_dir:</font>
<font color="red"> 188.                 is_not_importable = not os.path.isfile(os.path.join(start_dir, '__init__.py'))</font>
<font color="black"> 189.         else:</font>
<font color="black"> 190.             # support for discovery from dotted module names</font>
<font color="red"> 191.             try:</font>
<font color="red"> 192.                 __import__(start_dir)</font>
<font color="red"> 193.             except ImportError:</font>
<font color="red"> 194.                 is_not_importable = True</font>
<font color="black"> 195.             else:</font>
<font color="red"> 196.                 the_module = sys.modules[start_dir]</font>
<font color="red"> 197.                 top_part = start_dir.split('.')[0]</font>
<font color="red"> 198.                 start_dir = os.path.abspath(os.path.dirname((the_module.__file__)))</font>
<font color="red"> 199.                 if set_implicit_top:</font>
<font color="red"> 200.                     self._top_level_dir = self._get_directory_containing_module(top_part)</font>
<font color="red"> 201.                     sys.path.remove(top_level_dir)</font>
<font color="black"> 202. </font>
<font color="green"> 203.         if is_not_importable:</font>
<font color="red"> 204.             raise ImportError('Start directory is not importable: %r' % start_dir)</font>
<font color="black"> 205. </font>
<font color="green"> 206.         tests = list(self._find_tests(start_dir, pattern))</font>
<font color="green"> 207.         return self.suiteClass(tests)</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def _get_directory_containing_module(self, module_name):</font>
<font color="red"> 210.         module = sys.modules[module_name]</font>
<font color="red"> 211.         full_path = os.path.abspath(module.__file__)</font>
<font color="black"> 212. </font>
<font color="red"> 213.         if os.path.basename(full_path).lower().startswith('__init__.py'):</font>
<font color="red"> 214.             return os.path.dirname(os.path.dirname(full_path))</font>
<font color="black"> 215.         else:</font>
<font color="black"> 216.             # here we have been given a module rather than a package - so</font>
<font color="black"> 217.             # all we can do is search the *same* directory the module is in</font>
<font color="black"> 218.             # should an exception be raised instead</font>
<font color="red"> 219.             return os.path.dirname(full_path)</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def _get_name_from_path(self, path):</font>
<font color="green"> 222.         path = os.path.splitext(os.path.normpath(path))[0]</font>
<font color="black"> 223. </font>
<font color="green"> 224.         _relpath = os.path.relpath(path, self._top_level_dir)</font>
<font color="green"> 225.         assert not os.path.isabs(_relpath), &quot;Path must be within the project&quot;</font>
<font color="green"> 226.         assert not _relpath.startswith('..'), &quot;Path must be within the project&quot;</font>
<font color="black"> 227. </font>
<font color="green"> 228.         name = _relpath.replace(os.path.sep, '.')</font>
<font color="green"> 229.         return name</font>
<font color="black"> 230. </font>
<font color="green"> 231.     def _get_module_from_name(self, name):</font>
<font color="green"> 232.         __import__(name)</font>
<font color="green"> 233.         return sys.modules[name]</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def _match_path(self, path, full_path, pattern):</font>
<font color="black"> 236.         # override this method to use alternative matching strategy</font>
<font color="green"> 237.         return fnmatch(path, pattern)</font>
<font color="black"> 238. </font>
<font color="green"> 239.     def _find_tests(self, start_dir, pattern):</font>
<font color="black"> 240.         &quot;&quot;&quot;Used by discovery. Yields test suites it loads.&quot;&quot;&quot;</font>
<font color="green"> 241.         paths = os.listdir(start_dir)</font>
<font color="black"> 242. </font>
<font color="green"> 243.         for path in paths:</font>
<font color="green"> 244.             full_path = os.path.join(start_dir, path)</font>
<font color="green"> 245.             if os.path.isfile(full_path):</font>
<font color="green"> 246.                 if not VALID_MODULE_NAME.match(path):</font>
<font color="black"> 247.                     # valid Python identifiers only</font>
<font color="green"> 248.                     continue</font>
<font color="green"> 249.                 if not self._match_path(path, full_path, pattern):</font>
<font color="green"> 250.                     continue</font>
<font color="black"> 251.                 # if the test file matches, load it</font>
<font color="green"> 252.                 name = self._get_name_from_path(full_path)</font>
<font color="green"> 253.                 try:</font>
<font color="green"> 254.                     module = self._get_module_from_name(name)</font>
<font color="red"> 255.                 except:</font>
<font color="red"> 256.                     yield _make_failed_import_test(name, self.suiteClass)</font>
<font color="black"> 257.                 else:</font>
<font color="green"> 258.                     mod_file = os.path.abspath(getattr(module, '__file__', full_path))</font>
<font color="green"> 259.                     realpath = os.path.splitext(mod_file)[0]</font>
<font color="green"> 260.                     fullpath_noext = os.path.splitext(full_path)[0]</font>
<font color="green"> 261.                     if realpath.lower() != fullpath_noext.lower():</font>
<font color="red"> 262.                         module_dir = os.path.dirname(realpath)</font>
<font color="red"> 263.                         mod_name = os.path.splitext(os.path.basename(full_path))[0]</font>
<font color="red"> 264.                         expected_dir = os.path.dirname(full_path)</font>
<font color="red"> 265.                         msg = (&quot;%r module incorrectly imported from %r. Expected %r. &quot;</font>
<font color="black"> 266.                                &quot;Is this module globally installed?&quot;)</font>
<font color="red"> 267.                         raise ImportError(msg % (mod_name, module_dir, expected_dir))</font>
<font color="green"> 268.                     yield self.loadTestsFromModule(module)</font>
<font color="green"> 269.             elif os.path.isdir(full_path):</font>
<font color="green"> 270.                 if not os.path.isfile(os.path.join(full_path, '__init__.py')):</font>
<font color="red"> 271.                     continue</font>
<font color="black"> 272. </font>
<font color="green"> 273.                 load_tests = None</font>
<font color="green"> 274.                 tests = None</font>
<font color="green"> 275.                 if fnmatch(path, pattern):</font>
<font color="black"> 276.                     # only check load_tests if the package directory itself matches the filter</font>
<font color="red"> 277.                     name = self._get_name_from_path(full_path)</font>
<font color="red"> 278.                     package = self._get_module_from_name(name)</font>
<font color="red"> 279.                     load_tests = getattr(package, 'load_tests', None)</font>
<font color="red"> 280.                     tests = self.loadTestsFromModule(package, use_load_tests=False)</font>
<font color="black"> 281. </font>
<font color="green"> 282.                 if load_tests is None:</font>
<font color="green"> 283.                     if tests is not None:</font>
<font color="black"> 284.                         # tests loaded from package file</font>
<font color="red"> 285.                         yield tests</font>
<font color="black"> 286.                     # recurse into the package</font>
<font color="green"> 287.                     for test in self._find_tests(full_path, pattern):</font>
<font color="red"> 288.                         yield test</font>
<font color="black"> 289.                 else:</font>
<font color="red"> 290.                     try:</font>
<font color="red"> 291.                         yield load_tests(self, tests, pattern)</font>
<font color="red"> 292.                     except Exception, e:</font>
<font color="red"> 293.                         yield _make_failed_load_tests(package.__name__, e,</font>
<font color="red"> 294.                                                       self.suiteClass)</font>
<font color="black"> 295. </font>
<font color="green"> 296. defaultTestLoader = TestLoader()</font>
<font color="black"> 297. </font>
<font color="black"> 298. </font>
<font color="green"> 299. def _makeLoader(prefix, sortUsing, suiteClass=None):</font>
<font color="red"> 300.     loader = TestLoader()</font>
<font color="red"> 301.     loader.sortTestMethodsUsing = sortUsing</font>
<font color="red"> 302.     loader.testMethodPrefix = prefix</font>
<font color="red"> 303.     if suiteClass:</font>
<font color="red"> 304.         loader.suiteClass = suiteClass</font>
<font color="red"> 305.     return loader</font>
<font color="black"> 306. </font>
<font color="green"> 307. def getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):</font>
<font color="red"> 308.     return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)</font>
<font color="black"> 309. </font>
<font color="green"> 310. def makeSuite(testCaseClass, prefix='test', sortUsing=cmp,</font>
<font color="green"> 311.               suiteClass=suite.TestSuite):</font>
<font color="red"> 312.     return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)</font>
<font color="black"> 313. </font>
<font color="green"> 314. def findTestCases(module, prefix='test', sortUsing=cmp,</font>
<font color="green"> 315.                   suiteClass=suite.TestSuite):</font>
<font color="red"> 316.     return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)</font>
</pre>

