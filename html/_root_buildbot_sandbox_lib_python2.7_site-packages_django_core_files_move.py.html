source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/files/move.py</b><br>


file stats: <b>40 lines, 7 executed: 17.5% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Move a file in the safest way possible::</font>
<font color="black">   3. </font>
<font color="black">   4.     &gt;&gt;&gt; from django.core.files.move import file_move_safe</font>
<font color="black">   5.     &gt;&gt;&gt; file_move_safe(&quot;/tmp/old_file&quot;, &quot;/tmp/new_file&quot;)</font>
<font color="green">   6. &quot;&quot;&quot;</font>
<font color="black">   7. </font>
<font color="green">   8. import os</font>
<font color="green">   9. from shutil import copystat</font>
<font color="black">  10. </font>
<font color="green">  11. from django.core.files import locks</font>
<font color="black">  12. </font>
<font color="green">  13. __all__ = ['file_move_safe']</font>
<font color="black">  14. </font>
<font color="black">  15. </font>
<font color="green">  16. def _samefile(src, dst):</font>
<font color="black">  17.     # Macintosh, Unix.</font>
<font color="red">  18.     if hasattr(os.path, 'samefile'):</font>
<font color="red">  19.         try:</font>
<font color="red">  20.             return os.path.samefile(src, dst)</font>
<font color="red">  21.         except OSError:</font>
<font color="red">  22.             return False</font>
<font color="black">  23. </font>
<font color="black">  24.     # All other platforms: check for same pathname.</font>
<font color="red">  25.     return (os.path.normcase(os.path.abspath(src)) ==</font>
<font color="red">  26.             os.path.normcase(os.path.abspath(dst)))</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. def file_move_safe(old_file_name, new_file_name, chunk_size=1024 * 64, allow_overwrite=False):</font>
<font color="black">  30.     &quot;&quot;&quot;</font>
<font color="black">  31.     Moves a file from one location to another in the safest way possible.</font>
<font color="black">  32. </font>
<font color="black">  33.     First, tries ``os.rename``, which is simple but will break across filesystems.</font>
<font color="black">  34.     If that fails, streams manually from one file to another in pure Python.</font>
<font color="black">  35. </font>
<font color="black">  36.     If the destination file exists and ``allow_overwrite`` is ``False``, this</font>
<font color="black">  37.     function will throw an ``IOError``.</font>
<font color="black">  38.     &quot;&quot;&quot;</font>
<font color="black">  39. </font>
<font color="black">  40.     # There's no reason to move if we don't have to.</font>
<font color="red">  41.     if _samefile(old_file_name, new_file_name):</font>
<font color="red">  42.         return</font>
<font color="black">  43. </font>
<font color="red">  44.     try:</font>
<font color="black">  45.         # If the destination file exists and allow_overwrite is False then raise an IOError</font>
<font color="red">  46.         if not allow_overwrite and os.access(new_file_name, os.F_OK):</font>
<font color="red">  47.             raise IOError(&quot;Destination file %s exists and allow_overwrite is False&quot; % new_file_name)</font>
<font color="black">  48. </font>
<font color="red">  49.         os.rename(old_file_name, new_file_name)</font>
<font color="red">  50.         return</font>
<font color="red">  51.     except OSError:</font>
<font color="black">  52.         # This will happen with os.rename if moving to another filesystem</font>
<font color="black">  53.         # or when moving opened files on certain operating systems</font>
<font color="red">  54.         pass</font>
<font color="black">  55. </font>
<font color="black">  56.     # first open the old file, so that it won't go away</font>
<font color="red">  57.     with open(old_file_name, 'rb') as old_file:</font>
<font color="black">  58.         # now open the new file, not forgetting allow_overwrite</font>
<font color="red">  59.         fd = os.open(new_file_name, (os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0) |</font>
<font color="red">  60.                                      (os.O_EXCL if not allow_overwrite else 0)))</font>
<font color="red">  61.         try:</font>
<font color="red">  62.             locks.lock(fd, locks.LOCK_EX)</font>
<font color="red">  63.             current_chunk = None</font>
<font color="red">  64.             while current_chunk != b'':</font>
<font color="red">  65.                 current_chunk = old_file.read(chunk_size)</font>
<font color="red">  66.                 os.write(fd, current_chunk)</font>
<font color="black">  67.         finally:</font>
<font color="red">  68.             locks.unlock(fd)</font>
<font color="red">  69.             os.close(fd)</font>
<font color="red">  70.     copystat(old_file_name, new_file_name)</font>
<font color="black">  71. </font>
<font color="red">  72.     try:</font>
<font color="red">  73.         os.remove(old_file_name)</font>
<font color="red">  74.     except OSError as e:</font>
<font color="black">  75.         # Certain operating systems (Cygwin and Windows)</font>
<font color="black">  76.         # fail when deleting opened files, ignore it.  (For the</font>
<font color="black">  77.         # systems where this happens, temporary files will be auto-deleted</font>
<font color="black">  78.         # on close anyway.)</font>
<font color="red">  79.         if getattr(e, 'winerror', 0) != 32 and getattr(e, 'errno', 0) != 13:</font>
<font color="red">  80.             raise</font>
</pre>

