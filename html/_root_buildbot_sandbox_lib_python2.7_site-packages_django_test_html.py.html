source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/test/html.py</b><br>


file stats: <b>170 lines, 39 executed: 22.9% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Comparing two html documents.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. from __future__ import unicode_literals</font>
<font color="black">   6. </font>
<font color="green">   7. import re</font>
<font color="black">   8. </font>
<font color="green">   9. from django.utils import six</font>
<font color="green">  10. from django.utils.encoding import force_text, python_2_unicode_compatible</font>
<font color="green">  11. from django.utils.html_parser import HTMLParseError, HTMLParser</font>
<font color="black">  12. </font>
<font color="green">  13. WHITESPACE = re.compile('\s+')</font>
<font color="black">  14. </font>
<font color="black">  15. </font>
<font color="green">  16. def normalize_whitespace(string):</font>
<font color="red">  17.     return WHITESPACE.sub(' ', string)</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. @python_2_unicode_compatible</font>
<font color="green">  21. class Element(object):</font>
<font color="green">  22.     def __init__(self, name, attributes):</font>
<font color="red">  23.         self.name = name</font>
<font color="red">  24.         self.attributes = sorted(attributes)</font>
<font color="red">  25.         self.children = []</font>
<font color="black">  26. </font>
<font color="green">  27.     def append(self, element):</font>
<font color="red">  28.         if isinstance(element, six.string_types):</font>
<font color="red">  29.             element = force_text(element)</font>
<font color="red">  30.             element = normalize_whitespace(element)</font>
<font color="red">  31.             if self.children:</font>
<font color="red">  32.                 if isinstance(self.children[-1], six.string_types):</font>
<font color="red">  33.                     self.children[-1] += element</font>
<font color="red">  34.                     self.children[-1] = normalize_whitespace(self.children[-1])</font>
<font color="red">  35.                     return</font>
<font color="red">  36.         elif self.children:</font>
<font color="black">  37.             # removing last children if it is only whitespace</font>
<font color="black">  38.             # this can result in incorrect dom representations since</font>
<font color="black">  39.             # whitespace between inline tags like &lt;span&gt; is significant</font>
<font color="red">  40.             if isinstance(self.children[-1], six.string_types):</font>
<font color="red">  41.                 if self.children[-1].isspace():</font>
<font color="red">  42.                     self.children.pop()</font>
<font color="red">  43.         if element:</font>
<font color="red">  44.             self.children.append(element)</font>
<font color="black">  45. </font>
<font color="green">  46.     def finalize(self):</font>
<font color="red">  47.         def rstrip_last_element(children):</font>
<font color="red">  48.             if children:</font>
<font color="red">  49.                 if isinstance(children[-1], six.string_types):</font>
<font color="red">  50.                     children[-1] = children[-1].rstrip()</font>
<font color="red">  51.                     if not children[-1]:</font>
<font color="red">  52.                         children.pop()</font>
<font color="red">  53.                         children = rstrip_last_element(children)</font>
<font color="red">  54.             return children</font>
<font color="black">  55. </font>
<font color="red">  56.         rstrip_last_element(self.children)</font>
<font color="red">  57.         for i, child in enumerate(self.children):</font>
<font color="red">  58.             if isinstance(child, six.string_types):</font>
<font color="red">  59.                 self.children[i] = child.strip()</font>
<font color="red">  60.             elif hasattr(child, 'finalize'):</font>
<font color="red">  61.                 child.finalize()</font>
<font color="black">  62. </font>
<font color="green">  63.     def __eq__(self, element):</font>
<font color="red">  64.         if not hasattr(element, 'name'):</font>
<font color="red">  65.             return False</font>
<font color="red">  66.         if hasattr(element, 'name') and self.name != element.name:</font>
<font color="red">  67.             return False</font>
<font color="red">  68.         if len(self.attributes) != len(element.attributes):</font>
<font color="red">  69.             return False</font>
<font color="red">  70.         if self.attributes != element.attributes:</font>
<font color="black">  71.             # attributes without a value is same as attribute with value that</font>
<font color="black">  72.             # equals the attributes name:</font>
<font color="black">  73.             # &lt;input checked&gt; == &lt;input checked=&quot;checked&quot;&gt;</font>
<font color="red">  74.             for i in range(len(self.attributes)):</font>
<font color="red">  75.                 attr, value = self.attributes[i]</font>
<font color="red">  76.                 other_attr, other_value = element.attributes[i]</font>
<font color="red">  77.                 if value is None:</font>
<font color="red">  78.                     value = attr</font>
<font color="red">  79.                 if other_value is None:</font>
<font color="red">  80.                     other_value = other_attr</font>
<font color="red">  81.                 if attr != other_attr or value != other_value:</font>
<font color="red">  82.                     return False</font>
<font color="red">  83.         if self.children != element.children:</font>
<font color="red">  84.             return False</font>
<font color="red">  85.         return True</font>
<font color="black">  86. </font>
<font color="green">  87.     def __hash__(self):</font>
<font color="red">  88.         return hash((self.name,) + tuple(a for a in self.attributes))</font>
<font color="black">  89. </font>
<font color="green">  90.     def __ne__(self, element):</font>
<font color="red">  91.         return not self.__eq__(element)</font>
<font color="black">  92. </font>
<font color="green">  93.     def _count(self, element, count=True):</font>
<font color="red">  94.         if not isinstance(element, six.string_types):</font>
<font color="red">  95.             if self == element:</font>
<font color="red">  96.                 return 1</font>
<font color="red">  97.         i = 0</font>
<font color="red">  98.         for child in self.children:</font>
<font color="black">  99.             # child is text content and element is also text content, then</font>
<font color="black"> 100.             # make a simple &quot;text&quot; in &quot;text&quot;</font>
<font color="red"> 101.             if isinstance(child, six.string_types):</font>
<font color="red"> 102.                 if isinstance(element, six.string_types):</font>
<font color="red"> 103.                     if count:</font>
<font color="red"> 104.                         i += child.count(element)</font>
<font color="red"> 105.                     elif element in child:</font>
<font color="red"> 106.                         return 1</font>
<font color="black"> 107.             else:</font>
<font color="red"> 108.                 i += child._count(element, count=count)</font>
<font color="red"> 109.                 if not count and i:</font>
<font color="red"> 110.                     return i</font>
<font color="red"> 111.         return i</font>
<font color="black"> 112. </font>
<font color="green"> 113.     def __contains__(self, element):</font>
<font color="red"> 114.         return self._count(element, count=False) &gt; 0</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def count(self, element):</font>
<font color="red"> 117.         return self._count(element, count=True)</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def __getitem__(self, key):</font>
<font color="red"> 120.         return self.children[key]</font>
<font color="black"> 121. </font>
<font color="green"> 122.     def __str__(self):</font>
<font color="red"> 123.         output = '&lt;%s' % self.name</font>
<font color="red"> 124.         for key, value in self.attributes:</font>
<font color="red"> 125.             if value:</font>
<font color="red"> 126.                 output += ' %s=&quot;%s&quot;' % (key, value)</font>
<font color="black"> 127.             else:</font>
<font color="red"> 128.                 output += ' %s' % key</font>
<font color="red"> 129.         if self.children:</font>
<font color="red"> 130.             output += '&gt;\n'</font>
<font color="red"> 131.             output += ''.join(six.text_type(c) for c in self.children)</font>
<font color="red"> 132.             output += '\n&lt;/%s&gt;' % self.name</font>
<font color="black"> 133.         else:</font>
<font color="red"> 134.             output += ' /&gt;'</font>
<font color="red"> 135.         return output</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def __repr__(self):</font>
<font color="red"> 138.         return six.text_type(self)</font>
<font color="black"> 139. </font>
<font color="black"> 140. </font>
<font color="green"> 141. @python_2_unicode_compatible</font>
<font color="green"> 142. class RootElement(Element):</font>
<font color="green"> 143.     def __init__(self):</font>
<font color="red"> 144.         super(RootElement, self).__init__(None, ())</font>
<font color="black"> 145. </font>
<font color="green"> 146.     def __str__(self):</font>
<font color="red"> 147.         return ''.join(six.text_type(c) for c in self.children)</font>
<font color="black"> 148. </font>
<font color="black"> 149. </font>
<font color="green"> 150. class Parser(HTMLParser):</font>
<font color="black"> 151.     SELF_CLOSING_TAGS = ('br', 'hr', 'input', 'img', 'meta', 'spacer',</font>
<font color="green"> 152.         'link', 'frame', 'base', 'col')</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def __init__(self):</font>
<font color="red"> 155.         HTMLParser.__init__(self)</font>
<font color="red"> 156.         self.root = RootElement()</font>
<font color="red"> 157.         self.open_tags = []</font>
<font color="red"> 158.         self.element_positions = {}</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def error(self, msg):</font>
<font color="red"> 161.         raise HTMLParseError(msg, self.getpos())</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def format_position(self, position=None, element=None):</font>
<font color="red"> 164.         if not position and element:</font>
<font color="red"> 165.             position = self.element_positions[element]</font>
<font color="red"> 166.         if position is None:</font>
<font color="red"> 167.             position = self.getpos()</font>
<font color="red"> 168.         if hasattr(position, 'lineno'):</font>
<font color="red"> 169.             position = position.lineno, position.offset</font>
<font color="red"> 170.         return 'Line %d, Column %d' % position</font>
<font color="black"> 171. </font>
<font color="green"> 172.     @property</font>
<font color="black"> 173.     def current(self):</font>
<font color="red"> 174.         if self.open_tags:</font>
<font color="red"> 175.             return self.open_tags[-1]</font>
<font color="black"> 176.         else:</font>
<font color="red"> 177.             return self.root</font>
<font color="black"> 178. </font>
<font color="green"> 179.     def handle_startendtag(self, tag, attrs):</font>
<font color="red"> 180.         self.handle_starttag(tag, attrs)</font>
<font color="red"> 181.         if tag not in self.SELF_CLOSING_TAGS:</font>
<font color="red"> 182.             self.handle_endtag(tag)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def handle_starttag(self, tag, attrs):</font>
<font color="black"> 185.         # Special case handling of 'class' attribute, so that comparisons of DOM</font>
<font color="black"> 186.         # instances are not sensitive to ordering of classes.</font>
<font color="black"> 187.         attrs = [</font>
<font color="red"> 188.             (name, &quot; &quot;.join(sorted(value.split(&quot; &quot;))))</font>
<font color="black"> 189.             if name == &quot;class&quot;</font>
<font color="black"> 190.             else (name, value)</font>
<font color="red"> 191.             for name, value in attrs</font>
<font color="black"> 192.         ]</font>
<font color="red"> 193.         element = Element(tag, attrs)</font>
<font color="red"> 194.         self.current.append(element)</font>
<font color="red"> 195.         if tag not in self.SELF_CLOSING_TAGS:</font>
<font color="red"> 196.             self.open_tags.append(element)</font>
<font color="red"> 197.         self.element_positions[element] = self.getpos()</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def handle_endtag(self, tag):</font>
<font color="red"> 200.         if not self.open_tags:</font>
<font color="red"> 201.             self.error(&quot;Unexpected end tag `%s` (%s)&quot; % (</font>
<font color="red"> 202.                 tag, self.format_position()))</font>
<font color="red"> 203.         element = self.open_tags.pop()</font>
<font color="red"> 204.         while element.name != tag:</font>
<font color="red"> 205.             if not self.open_tags:</font>
<font color="red"> 206.                 self.error(&quot;Unexpected end tag `%s` (%s)&quot; % (</font>
<font color="red"> 207.                     tag, self.format_position()))</font>
<font color="red"> 208.             element = self.open_tags.pop()</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def handle_data(self, data):</font>
<font color="red"> 211.         self.current.append(data)</font>
<font color="black"> 212. </font>
<font color="green"> 213.     def handle_charref(self, name):</font>
<font color="red"> 214.         self.current.append('&amp;%s;' % name)</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def handle_entityref(self, name):</font>
<font color="red"> 217.         self.current.append('&amp;%s;' % name)</font>
<font color="black"> 218. </font>
<font color="black"> 219. </font>
<font color="green"> 220. def parse_html(html):</font>
<font color="black"> 221.     &quot;&quot;&quot;</font>
<font color="black"> 222.     Takes a string that contains *valid* HTML and turns it into a Python object</font>
<font color="black"> 223.     structure that can be easily compared against other HTML on semantic</font>
<font color="black"> 224.     equivalence. Syntactical differences like which quotation is used on</font>
<font color="black"> 225.     arguments will be ignored.</font>
<font color="black"> 226.     &quot;&quot;&quot;</font>
<font color="red"> 227.     parser = Parser()</font>
<font color="red"> 228.     parser.feed(html)</font>
<font color="red"> 229.     parser.close()</font>
<font color="red"> 230.     document = parser.root</font>
<font color="red"> 231.     document.finalize()</font>
<font color="black"> 232.     # Removing ROOT element if it's not necessary</font>
<font color="red"> 233.     if len(document.children) == 1:</font>
<font color="red"> 234.         if not isinstance(document.children[0], six.string_types):</font>
<font color="red"> 235.             document = document.children[0]</font>
<font color="red"> 236.     return document</font>
</pre>

