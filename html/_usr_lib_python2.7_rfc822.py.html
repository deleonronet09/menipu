source file: <b>/usr/lib/python2.7/rfc822.py</b><br>


file stats: <b>591 lines, 82 executed: 13.9% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;RFC 2822 message manipulation.</font>
<font color="black">   2. </font>
<font color="black">   3. Note: This is only a very rough sketch of a full RFC-822 parser; in particular</font>
<font color="black">   4. the tokenizing of addresses does not adhere to all the quoting rules.</font>
<font color="black">   5. </font>
<font color="black">   6. Note: RFC 2822 is a long awaited update to RFC 822.  This module should</font>
<font color="black">   7. conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some</font>
<font color="black">   8. effort at RFC 2822 updates have been made, but a thorough audit has not been</font>
<font color="black">   9. performed.  Consider any RFC 2822 non-conformance to be a bug.</font>
<font color="black">  10. </font>
<font color="black">  11.     RFC 2822: http://www.faqs.org/rfcs/rfc2822.html</font>
<font color="black">  12.     RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)</font>
<font color="black">  13. </font>
<font color="black">  14. Directions for use:</font>
<font color="black">  15. </font>
<font color="black">  16. To create a Message object: first open a file, e.g.:</font>
<font color="black">  17. </font>
<font color="black">  18.   fp = open(file, 'r')</font>
<font color="black">  19. </font>
<font color="black">  20. You can use any other legal way of getting an open file object, e.g. use</font>
<font color="black">  21. sys.stdin or call os.popen().  Then pass the open file object to the Message()</font>
<font color="black">  22. constructor:</font>
<font color="black">  23. </font>
<font color="black">  24.   m = Message(fp)</font>
<font color="black">  25. </font>
<font color="black">  26. This class can work with any input object that supports a readline method.  If</font>
<font color="black">  27. the input object has seek and tell capability, the rewindbody method will</font>
<font color="black">  28. work; also illegal lines will be pushed back onto the input stream.  If the</font>
<font color="black">  29. input object lacks seek but has an `unread' method that can push back a line</font>
<font color="black">  30. of input, Message will use that to push back illegal lines.  Thus this class</font>
<font color="black">  31. can be used to parse messages coming from a buffered stream.</font>
<font color="black">  32. </font>
<font color="black">  33. The optional `seekable' argument is provided as a workaround for certain stdio</font>
<font color="black">  34. libraries in which tell() discards buffered data before discovering that the</font>
<font color="black">  35. lseek() system call doesn't work.  For maximum portability, you should set the</font>
<font color="black">  36. seekable argument to zero to prevent that initial \code{tell} when passing in</font>
<font color="black">  37. an unseekable object such as a file object created from a socket object.  If</font>
<font color="black">  38. it is 1 on entry -- which it is by default -- the tell() method of the open</font>
<font color="black">  39. file object is called once; if this raises an exception, seekable is reset to</font>
<font color="black">  40. 0.  For other nonzero values of seekable, this test is not made.</font>
<font color="black">  41. </font>
<font color="black">  42. To get the text of a particular header there are several methods:</font>
<font color="black">  43. </font>
<font color="black">  44.   str = m.getheader(name)</font>
<font color="black">  45.   str = m.getrawheader(name)</font>
<font color="black">  46. </font>
<font color="black">  47. where name is the name of the header, e.g. 'Subject'.  The difference is that</font>
<font color="black">  48. getheader() strips the leading and trailing whitespace, while getrawheader()</font>
<font color="black">  49. doesn't.  Both functions retain embedded whitespace (including newlines)</font>
<font color="black">  50. exactly as they are specified in the header, and leave the case of the text</font>
<font color="black">  51. unchanged.</font>
<font color="black">  52. </font>
<font color="black">  53. For addresses and address lists there are functions</font>
<font color="black">  54. </font>
<font color="black">  55.   realname, mailaddress = m.getaddr(name)</font>
<font color="black">  56.   list = m.getaddrlist(name)</font>
<font color="black">  57. </font>
<font color="black">  58. where the latter returns a list of (realname, mailaddr) tuples.</font>
<font color="black">  59. </font>
<font color="black">  60. There is also a method</font>
<font color="black">  61. </font>
<font color="black">  62.   time = m.getdate(name)</font>
<font color="black">  63. </font>
<font color="black">  64. which parses a Date-like field and returns a time-compatible tuple,</font>
<font color="black">  65. i.e. a tuple such as returned by time.localtime() or accepted by</font>
<font color="black">  66. time.mktime().</font>
<font color="black">  67. </font>
<font color="black">  68. See the class definition for lower level access methods.</font>
<font color="black">  69. </font>
<font color="black">  70. There are also some utility functions here.</font>
<font color="green">  71. &quot;&quot;&quot;</font>
<font color="black">  72. # Cleanup and extensions by Eric S. Raymond &lt;esr@thyrsus.com&gt;</font>
<font color="black">  73. </font>
<font color="green">  74. import time</font>
<font color="black">  75. </font>
<font color="green">  76. from warnings import warnpy3k</font>
<font color="green">  77. warnpy3k(&quot;in 3.x, rfc822 has been removed in favor of the email package&quot;,</font>
<font color="green">  78.          stacklevel=2)</font>
<font color="black">  79. </font>
<font color="green">  80. __all__ = [&quot;Message&quot;,&quot;AddressList&quot;,&quot;parsedate&quot;,&quot;parsedate_tz&quot;,&quot;mktime_tz&quot;]</font>
<font color="black">  81. </font>
<font color="green">  82. _blanklines = ('\r\n', '\n')            # Optimization for islast()</font>
<font color="black">  83. </font>
<font color="black">  84. </font>
<font color="green">  85. class Message:</font>
<font color="green">  86.     &quot;&quot;&quot;Represents a single RFC 2822-compliant message.&quot;&quot;&quot;</font>
<font color="black">  87. </font>
<font color="green">  88.     def __init__(self, fp, seekable = 1):</font>
<font color="black">  89.         &quot;&quot;&quot;Initialize the class instance and read the headers.&quot;&quot;&quot;</font>
<font color="red">  90.         if seekable == 1:</font>
<font color="black">  91.             # Exercise tell() to make sure it works</font>
<font color="black">  92.             # (and then assume seek() works, too)</font>
<font color="red">  93.             try:</font>
<font color="red">  94.                 fp.tell()</font>
<font color="red">  95.             except (AttributeError, IOError):</font>
<font color="red">  96.                 seekable = 0</font>
<font color="red">  97.         self.fp = fp</font>
<font color="red">  98.         self.seekable = seekable</font>
<font color="red">  99.         self.startofheaders = None</font>
<font color="red"> 100.         self.startofbody = None</font>
<font color="black"> 101.         #</font>
<font color="red"> 102.         if self.seekable:</font>
<font color="red"> 103.             try:</font>
<font color="red"> 104.                 self.startofheaders = self.fp.tell()</font>
<font color="red"> 105.             except IOError:</font>
<font color="red"> 106.                 self.seekable = 0</font>
<font color="black"> 107.         #</font>
<font color="red"> 108.         self.readheaders()</font>
<font color="black"> 109.         #</font>
<font color="red"> 110.         if self.seekable:</font>
<font color="red"> 111.             try:</font>
<font color="red"> 112.                 self.startofbody = self.fp.tell()</font>
<font color="red"> 113.             except IOError:</font>
<font color="red"> 114.                 self.seekable = 0</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def rewindbody(self):</font>
<font color="black"> 117.         &quot;&quot;&quot;Rewind the file to the start of the body (if seekable).&quot;&quot;&quot;</font>
<font color="red"> 118.         if not self.seekable:</font>
<font color="red"> 119.             raise IOError, &quot;unseekable file&quot;</font>
<font color="red"> 120.         self.fp.seek(self.startofbody)</font>
<font color="black"> 121. </font>
<font color="green"> 122.     def readheaders(self):</font>
<font color="black"> 123.         &quot;&quot;&quot;Read header lines.</font>
<font color="black"> 124. </font>
<font color="black"> 125.         Read header lines up to the entirely blank line that terminates them.</font>
<font color="black"> 126.         The (normally blank) line that ends the headers is skipped, but not</font>
<font color="black"> 127.         included in the returned list.  If a non-header line ends the headers,</font>
<font color="black"> 128.         (which is an error), an attempt is made to backspace over it; it is</font>
<font color="black"> 129.         never included in the returned list.</font>
<font color="black"> 130. </font>
<font color="black"> 131.         The variable self.status is set to the empty string if all went well,</font>
<font color="black"> 132.         otherwise it is an error message.  The variable self.headers is a</font>
<font color="black"> 133.         completely uninterpreted list of lines contained in the header (so</font>
<font color="black"> 134.         printing them will reproduce the header exactly as it appears in the</font>
<font color="black"> 135.         file).</font>
<font color="black"> 136.         &quot;&quot;&quot;</font>
<font color="red"> 137.         self.dict = {}</font>
<font color="red"> 138.         self.unixfrom = ''</font>
<font color="red"> 139.         self.headers = lst = []</font>
<font color="red"> 140.         self.status = ''</font>
<font color="red"> 141.         headerseen = &quot;&quot;</font>
<font color="red"> 142.         firstline = 1</font>
<font color="red"> 143.         startofline = unread = tell = None</font>
<font color="red"> 144.         if hasattr(self.fp, 'unread'):</font>
<font color="red"> 145.             unread = self.fp.unread</font>
<font color="red"> 146.         elif self.seekable:</font>
<font color="red"> 147.             tell = self.fp.tell</font>
<font color="red"> 148.         while 1:</font>
<font color="red"> 149.             if tell:</font>
<font color="red"> 150.                 try:</font>
<font color="red"> 151.                     startofline = tell()</font>
<font color="red"> 152.                 except IOError:</font>
<font color="red"> 153.                     startofline = tell = None</font>
<font color="red"> 154.                     self.seekable = 0</font>
<font color="red"> 155.             line = self.fp.readline()</font>
<font color="red"> 156.             if not line:</font>
<font color="red"> 157.                 self.status = 'EOF in headers'</font>
<font color="red"> 158.                 break</font>
<font color="black"> 159.             # Skip unix From name time lines</font>
<font color="red"> 160.             if firstline and line.startswith('From '):</font>
<font color="red"> 161.                 self.unixfrom = self.unixfrom + line</font>
<font color="red"> 162.                 continue</font>
<font color="red"> 163.             firstline = 0</font>
<font color="red"> 164.             if headerseen and line[0] in ' \t':</font>
<font color="black"> 165.                 # It's a continuation line.</font>
<font color="red"> 166.                 lst.append(line)</font>
<font color="red"> 167.                 x = (self.dict[headerseen] + &quot;\n &quot; + line.strip())</font>
<font color="red"> 168.                 self.dict[headerseen] = x.strip()</font>
<font color="red"> 169.                 continue</font>
<font color="red"> 170.             elif self.iscomment(line):</font>
<font color="black"> 171.                 # It's a comment.  Ignore it.</font>
<font color="red"> 172.                 continue</font>
<font color="red"> 173.             elif self.islast(line):</font>
<font color="black"> 174.                 # Note! No pushback here!  The delimiter line gets eaten.</font>
<font color="red"> 175.                 break</font>
<font color="red"> 176.             headerseen = self.isheader(line)</font>
<font color="red"> 177.             if headerseen:</font>
<font color="black"> 178.                 # It's a legal header line, save it.</font>
<font color="red"> 179.                 lst.append(line)</font>
<font color="red"> 180.                 self.dict[headerseen] = line[len(headerseen)+1:].strip()</font>
<font color="red"> 181.                 continue</font>
<font color="black"> 182.             else:</font>
<font color="black"> 183.                 # It's not a header line; throw it back and stop here.</font>
<font color="red"> 184.                 if not self.dict:</font>
<font color="red"> 185.                     self.status = 'No headers'</font>
<font color="black"> 186.                 else:</font>
<font color="red"> 187.                     self.status = 'Non-header line where header expected'</font>
<font color="black"> 188.                 # Try to undo the read.</font>
<font color="red"> 189.                 if unread:</font>
<font color="red"> 190.                     unread(line)</font>
<font color="red"> 191.                 elif tell:</font>
<font color="red"> 192.                     self.fp.seek(startofline)</font>
<font color="black"> 193.                 else:</font>
<font color="red"> 194.                     self.status = self.status + '; bad seek'</font>
<font color="red"> 195.                 break</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def isheader(self, line):</font>
<font color="black"> 198.         &quot;&quot;&quot;Determine whether a given line is a legal header.</font>
<font color="black"> 199. </font>
<font color="black"> 200.         This method should return the header name, suitably canonicalized.</font>
<font color="black"> 201.         You may override this method in order to use Message parsing on tagged</font>
<font color="black"> 202.         data in RFC 2822-like formats with special header formats.</font>
<font color="black"> 203.         &quot;&quot;&quot;</font>
<font color="red"> 204.         i = line.find(':')</font>
<font color="red"> 205.         if i &gt; 0:</font>
<font color="red"> 206.             return line[:i].lower()</font>
<font color="red"> 207.         return None</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def islast(self, line):</font>
<font color="black"> 210.         &quot;&quot;&quot;Determine whether a line is a legal end of RFC 2822 headers.</font>
<font color="black"> 211. </font>
<font color="black"> 212.         You may override this method if your application wants to bend the</font>
<font color="black"> 213.         rules, e.g. to strip trailing whitespace, or to recognize MH template</font>
<font color="black"> 214.         separators ('--------').  For convenience (e.g. for code reading from</font>
<font color="black"> 215.         sockets) a line consisting of \\r\\n also matches.</font>
<font color="black"> 216.         &quot;&quot;&quot;</font>
<font color="red"> 217.         return line in _blanklines</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def iscomment(self, line):</font>
<font color="black"> 220.         &quot;&quot;&quot;Determine whether a line should be skipped entirely.</font>
<font color="black"> 221. </font>
<font color="black"> 222.         You may override this method in order to use Message parsing on tagged</font>
<font color="black"> 223.         data in RFC 2822-like formats that support embedded comments or</font>
<font color="black"> 224.         free-text data.</font>
<font color="black"> 225.         &quot;&quot;&quot;</font>
<font color="red"> 226.         return False</font>
<font color="black"> 227. </font>
<font color="green"> 228.     def getallmatchingheaders(self, name):</font>
<font color="black"> 229.         &quot;&quot;&quot;Find all header lines matching a given header name.</font>
<font color="black"> 230. </font>
<font color="black"> 231.         Look through the list of headers and find all lines matching a given</font>
<font color="black"> 232.         header name (and their continuation lines).  A list of the lines is</font>
<font color="black"> 233.         returned, without interpretation.  If the header does not occur, an</font>
<font color="black"> 234.         empty list is returned.  If the header occurs multiple times, all</font>
<font color="black"> 235.         occurrences are returned.  Case is not important in the header name.</font>
<font color="black"> 236.         &quot;&quot;&quot;</font>
<font color="red"> 237.         name = name.lower() + ':'</font>
<font color="red"> 238.         n = len(name)</font>
<font color="red"> 239.         lst = []</font>
<font color="red"> 240.         hit = 0</font>
<font color="red"> 241.         for line in self.headers:</font>
<font color="red"> 242.             if line[:n].lower() == name:</font>
<font color="red"> 243.                 hit = 1</font>
<font color="red"> 244.             elif not line[:1].isspace():</font>
<font color="red"> 245.                 hit = 0</font>
<font color="red"> 246.             if hit:</font>
<font color="red"> 247.                 lst.append(line)</font>
<font color="red"> 248.         return lst</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def getfirstmatchingheader(self, name):</font>
<font color="black"> 251.         &quot;&quot;&quot;Get the first header line matching name.</font>
<font color="black"> 252. </font>
<font color="black"> 253.         This is similar to getallmatchingheaders, but it returns only the</font>
<font color="black"> 254.         first matching header (and its continuation lines).</font>
<font color="black"> 255.         &quot;&quot;&quot;</font>
<font color="red"> 256.         name = name.lower() + ':'</font>
<font color="red"> 257.         n = len(name)</font>
<font color="red"> 258.         lst = []</font>
<font color="red"> 259.         hit = 0</font>
<font color="red"> 260.         for line in self.headers:</font>
<font color="red"> 261.             if hit:</font>
<font color="red"> 262.                 if not line[:1].isspace():</font>
<font color="red"> 263.                     break</font>
<font color="red"> 264.             elif line[:n].lower() == name:</font>
<font color="red"> 265.                 hit = 1</font>
<font color="red"> 266.             if hit:</font>
<font color="red"> 267.                 lst.append(line)</font>
<font color="red"> 268.         return lst</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def getrawheader(self, name):</font>
<font color="black"> 271.         &quot;&quot;&quot;A higher-level interface to getfirstmatchingheader().</font>
<font color="black"> 272. </font>
<font color="black"> 273.         Return a string containing the literal text of the header but with the</font>
<font color="black"> 274.         keyword stripped.  All leading, trailing and embedded whitespace is</font>
<font color="black"> 275.         kept in the string, however.  Return None if the header does not</font>
<font color="black"> 276.         occur.</font>
<font color="black"> 277.         &quot;&quot;&quot;</font>
<font color="black"> 278. </font>
<font color="red"> 279.         lst = self.getfirstmatchingheader(name)</font>
<font color="red"> 280.         if not lst:</font>
<font color="red"> 281.             return None</font>
<font color="red"> 282.         lst[0] = lst[0][len(name) + 1:]</font>
<font color="red"> 283.         return ''.join(lst)</font>
<font color="black"> 284. </font>
<font color="green"> 285.     def getheader(self, name, default=None):</font>
<font color="black"> 286.         &quot;&quot;&quot;Get the header value for a name.</font>
<font color="black"> 287. </font>
<font color="black"> 288.         This is the normal interface: it returns a stripped version of the</font>
<font color="black"> 289.         header value for a given header name, or None if it doesn't exist.</font>
<font color="black"> 290.         This uses the dictionary version which finds the *last* such header.</font>
<font color="black"> 291.         &quot;&quot;&quot;</font>
<font color="red"> 292.         return self.dict.get(name.lower(), default)</font>
<font color="green"> 293.     get = getheader</font>
<font color="black"> 294. </font>
<font color="green"> 295.     def getheaders(self, name):</font>
<font color="black"> 296.         &quot;&quot;&quot;Get all values for a header.</font>
<font color="black"> 297. </font>
<font color="black"> 298.         This returns a list of values for headers given more than once; each</font>
<font color="black"> 299.         value in the result list is stripped in the same way as the result of</font>
<font color="black"> 300.         getheader().  If the header is not given, return an empty list.</font>
<font color="black"> 301.         &quot;&quot;&quot;</font>
<font color="red"> 302.         result = []</font>
<font color="red"> 303.         current = ''</font>
<font color="red"> 304.         have_header = 0</font>
<font color="red"> 305.         for s in self.getallmatchingheaders(name):</font>
<font color="red"> 306.             if s[0].isspace():</font>
<font color="red"> 307.                 if current:</font>
<font color="red"> 308.                     current = &quot;%s\n %s&quot; % (current, s.strip())</font>
<font color="black"> 309.                 else:</font>
<font color="red"> 310.                     current = s.strip()</font>
<font color="black"> 311.             else:</font>
<font color="red"> 312.                 if have_header:</font>
<font color="red"> 313.                     result.append(current)</font>
<font color="red"> 314.                 current = s[s.find(&quot;:&quot;) + 1:].strip()</font>
<font color="red"> 315.                 have_header = 1</font>
<font color="red"> 316.         if have_header:</font>
<font color="red"> 317.             result.append(current)</font>
<font color="red"> 318.         return result</font>
<font color="black"> 319. </font>
<font color="green"> 320.     def getaddr(self, name):</font>
<font color="black"> 321.         &quot;&quot;&quot;Get a single address from a header, as a tuple.</font>
<font color="black"> 322. </font>
<font color="black"> 323.         An example return value:</font>
<font color="black"> 324.         ('Guido van Rossum', 'guido@cwi.nl')</font>
<font color="black"> 325.         &quot;&quot;&quot;</font>
<font color="black"> 326.         # New, by Ben Escoto</font>
<font color="red"> 327.         alist = self.getaddrlist(name)</font>
<font color="red"> 328.         if alist:</font>
<font color="red"> 329.             return alist[0]</font>
<font color="black"> 330.         else:</font>
<font color="red"> 331.             return (None, None)</font>
<font color="black"> 332. </font>
<font color="green"> 333.     def getaddrlist(self, name):</font>
<font color="black"> 334.         &quot;&quot;&quot;Get a list of addresses from a header.</font>
<font color="black"> 335. </font>
<font color="black"> 336.         Retrieves a list of addresses from a header, where each address is a</font>
<font color="black"> 337.         tuple as returned by getaddr().  Scans all named headers, so it works</font>
<font color="black"> 338.         properly with multiple To: or Cc: headers for example.</font>
<font color="black"> 339.         &quot;&quot;&quot;</font>
<font color="red"> 340.         raw = []</font>
<font color="red"> 341.         for h in self.getallmatchingheaders(name):</font>
<font color="red"> 342.             if h[0] in ' \t':</font>
<font color="red"> 343.                 raw.append(h)</font>
<font color="black"> 344.             else:</font>
<font color="red"> 345.                 if raw:</font>
<font color="red"> 346.                     raw.append(', ')</font>
<font color="red"> 347.                 i = h.find(':')</font>
<font color="red"> 348.                 if i &gt; 0:</font>
<font color="red"> 349.                     addr = h[i+1:]</font>
<font color="red"> 350.                 raw.append(addr)</font>
<font color="red"> 351.         alladdrs = ''.join(raw)</font>
<font color="red"> 352.         a = AddressList(alladdrs)</font>
<font color="red"> 353.         return a.addresslist</font>
<font color="black"> 354. </font>
<font color="green"> 355.     def getdate(self, name):</font>
<font color="black"> 356.         &quot;&quot;&quot;Retrieve a date field from a header.</font>
<font color="black"> 357. </font>
<font color="black"> 358.         Retrieves a date field from the named header, returning a tuple</font>
<font color="black"> 359.         compatible with time.mktime().</font>
<font color="black"> 360.         &quot;&quot;&quot;</font>
<font color="red"> 361.         try:</font>
<font color="red"> 362.             data = self[name]</font>
<font color="red"> 363.         except KeyError:</font>
<font color="red"> 364.             return None</font>
<font color="red"> 365.         return parsedate(data)</font>
<font color="black"> 366. </font>
<font color="green"> 367.     def getdate_tz(self, name):</font>
<font color="black"> 368.         &quot;&quot;&quot;Retrieve a date field from a header as a 10-tuple.</font>
<font color="black"> 369. </font>
<font color="black"> 370.         The first 9 elements make up a tuple compatible with time.mktime(),</font>
<font color="black"> 371.         and the 10th is the offset of the poster's time zone from GMT/UTC.</font>
<font color="black"> 372.         &quot;&quot;&quot;</font>
<font color="red"> 373.         try:</font>
<font color="red"> 374.             data = self[name]</font>
<font color="red"> 375.         except KeyError:</font>
<font color="red"> 376.             return None</font>
<font color="red"> 377.         return parsedate_tz(data)</font>
<font color="black"> 378. </font>
<font color="black"> 379. </font>
<font color="black"> 380.     # Access as a dictionary (only finds *last* header of each type):</font>
<font color="black"> 381. </font>
<font color="green"> 382.     def __len__(self):</font>
<font color="black"> 383.         &quot;&quot;&quot;Get the number of headers in a message.&quot;&quot;&quot;</font>
<font color="red"> 384.         return len(self.dict)</font>
<font color="black"> 385. </font>
<font color="green"> 386.     def __getitem__(self, name):</font>
<font color="black"> 387.         &quot;&quot;&quot;Get a specific header, as from a dictionary.&quot;&quot;&quot;</font>
<font color="red"> 388.         return self.dict[name.lower()]</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def __setitem__(self, name, value):</font>
<font color="black"> 391.         &quot;&quot;&quot;Set the value of a header.</font>
<font color="black"> 392. </font>
<font color="black"> 393.         Note: This is not a perfect inversion of __getitem__, because any</font>
<font color="black"> 394.         changed headers get stuck at the end of the raw-headers list rather</font>
<font color="black"> 395.         than where the altered header was.</font>
<font color="black"> 396.         &quot;&quot;&quot;</font>
<font color="red"> 397.         del self[name] # Won't fail if it doesn't exist</font>
<font color="red"> 398.         self.dict[name.lower()] = value</font>
<font color="red"> 399.         text = name + &quot;: &quot; + value</font>
<font color="red"> 400.         for line in text.split(&quot;\n&quot;):</font>
<font color="red"> 401.             self.headers.append(line + &quot;\n&quot;)</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def __delitem__(self, name):</font>
<font color="black"> 404.         &quot;&quot;&quot;Delete all occurrences of a specific header, if it is present.&quot;&quot;&quot;</font>
<font color="red"> 405.         name = name.lower()</font>
<font color="red"> 406.         if not name in self.dict:</font>
<font color="red"> 407.             return</font>
<font color="red"> 408.         del self.dict[name]</font>
<font color="red"> 409.         name = name + ':'</font>
<font color="red"> 410.         n = len(name)</font>
<font color="red"> 411.         lst = []</font>
<font color="red"> 412.         hit = 0</font>
<font color="red"> 413.         for i in range(len(self.headers)):</font>
<font color="red"> 414.             line = self.headers[i]</font>
<font color="red"> 415.             if line[:n].lower() == name:</font>
<font color="red"> 416.                 hit = 1</font>
<font color="red"> 417.             elif not line[:1].isspace():</font>
<font color="red"> 418.                 hit = 0</font>
<font color="red"> 419.             if hit:</font>
<font color="red"> 420.                 lst.append(i)</font>
<font color="red"> 421.         for i in reversed(lst):</font>
<font color="red"> 422.             del self.headers[i]</font>
<font color="black"> 423. </font>
<font color="green"> 424.     def setdefault(self, name, default=&quot;&quot;):</font>
<font color="red"> 425.         lowername = name.lower()</font>
<font color="red"> 426.         if lowername in self.dict:</font>
<font color="red"> 427.             return self.dict[lowername]</font>
<font color="black"> 428.         else:</font>
<font color="red"> 429.             text = name + &quot;: &quot; + default</font>
<font color="red"> 430.             for line in text.split(&quot;\n&quot;):</font>
<font color="red"> 431.                 self.headers.append(line + &quot;\n&quot;)</font>
<font color="red"> 432.             self.dict[lowername] = default</font>
<font color="red"> 433.             return default</font>
<font color="black"> 434. </font>
<font color="green"> 435.     def has_key(self, name):</font>
<font color="black"> 436.         &quot;&quot;&quot;Determine whether a message contains the named header.&quot;&quot;&quot;</font>
<font color="red"> 437.         return name.lower() in self.dict</font>
<font color="black"> 438. </font>
<font color="green"> 439.     def __contains__(self, name):</font>
<font color="black"> 440.         &quot;&quot;&quot;Determine whether a message contains the named header.&quot;&quot;&quot;</font>
<font color="red"> 441.         return name.lower() in self.dict</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def __iter__(self):</font>
<font color="red"> 444.         return iter(self.dict)</font>
<font color="black"> 445. </font>
<font color="green"> 446.     def keys(self):</font>
<font color="black"> 447.         &quot;&quot;&quot;Get all of a message's header field names.&quot;&quot;&quot;</font>
<font color="red"> 448.         return self.dict.keys()</font>
<font color="black"> 449. </font>
<font color="green"> 450.     def values(self):</font>
<font color="black"> 451.         &quot;&quot;&quot;Get all of a message's header field values.&quot;&quot;&quot;</font>
<font color="red"> 452.         return self.dict.values()</font>
<font color="black"> 453. </font>
<font color="green"> 454.     def items(self):</font>
<font color="black"> 455.         &quot;&quot;&quot;Get all of a message's headers.</font>
<font color="black"> 456. </font>
<font color="black"> 457.         Returns a list of name, value tuples.</font>
<font color="black"> 458.         &quot;&quot;&quot;</font>
<font color="red"> 459.         return self.dict.items()</font>
<font color="black"> 460. </font>
<font color="green"> 461.     def __str__(self):</font>
<font color="red"> 462.         return ''.join(self.headers)</font>
<font color="black"> 463. </font>
<font color="black"> 464. </font>
<font color="black"> 465. # Utility functions</font>
<font color="black"> 466. # -----------------</font>
<font color="black"> 467. </font>
<font color="black"> 468. # XXX Should fix unquote() and quote() to be really conformant.</font>
<font color="black"> 469. # XXX The inverses of the parse functions may also be useful.</font>
<font color="black"> 470. </font>
<font color="black"> 471. </font>
<font color="green"> 472. def unquote(s):</font>
<font color="black"> 473.     &quot;&quot;&quot;Remove quotes from a string.&quot;&quot;&quot;</font>
<font color="red"> 474.     if len(s) &gt; 1:</font>
<font color="red"> 475.         if s.startswith('&quot;') and s.endswith('&quot;'):</font>
<font color="red"> 476.             return s[1:-1].replace('\\\\', '\\').replace('\\&quot;', '&quot;')</font>
<font color="red"> 477.         if s.startswith('&lt;') and s.endswith('&gt;'):</font>
<font color="red"> 478.             return s[1:-1]</font>
<font color="red"> 479.     return s</font>
<font color="black"> 480. </font>
<font color="black"> 481. </font>
<font color="green"> 482. def quote(s):</font>
<font color="black"> 483.     &quot;&quot;&quot;Add quotes around a string.&quot;&quot;&quot;</font>
<font color="red"> 484.     return s.replace('\\', '\\\\').replace('&quot;', '\\&quot;')</font>
<font color="black"> 485. </font>
<font color="black"> 486. </font>
<font color="green"> 487. def parseaddr(address):</font>
<font color="black"> 488.     &quot;&quot;&quot;Parse an address into a (realname, mailaddr) tuple.&quot;&quot;&quot;</font>
<font color="red"> 489.     a = AddressList(address)</font>
<font color="red"> 490.     lst = a.addresslist</font>
<font color="red"> 491.     if not lst:</font>
<font color="red"> 492.         return (None, None)</font>
<font color="red"> 493.     return lst[0]</font>
<font color="black"> 494. </font>
<font color="black"> 495. </font>
<font color="green"> 496. class AddrlistClass:</font>
<font color="black"> 497.     &quot;&quot;&quot;Address parser class by Ben Escoto.</font>
<font color="black"> 498. </font>
<font color="black"> 499.     To understand what this class does, it helps to have a copy of</font>
<font color="black"> 500.     RFC 2822 in front of you.</font>
<font color="black"> 501. </font>
<font color="black"> 502.     http://www.faqs.org/rfcs/rfc2822.html</font>
<font color="black"> 503. </font>
<font color="black"> 504.     Note: this class interface is deprecated and may be removed in the future.</font>
<font color="black"> 505.     Use rfc822.AddressList instead.</font>
<font color="green"> 506.     &quot;&quot;&quot;</font>
<font color="black"> 507. </font>
<font color="green"> 508.     def __init__(self, field):</font>
<font color="black"> 509.         &quot;&quot;&quot;Initialize a new instance.</font>
<font color="black"> 510. </font>
<font color="black"> 511.         `field' is an unparsed address header field, containing one or more</font>
<font color="black"> 512.         addresses.</font>
<font color="black"> 513.         &quot;&quot;&quot;</font>
<font color="red"> 514.         self.specials = '()&lt;&gt;@,:;.\&quot;[]'</font>
<font color="red"> 515.         self.pos = 0</font>
<font color="red"> 516.         self.LWS = ' \t'</font>
<font color="red"> 517.         self.CR = '\r\n'</font>
<font color="red"> 518.         self.atomends = self.specials + self.LWS + self.CR</font>
<font color="black"> 519.         # Note that RFC 2822 now specifies `.' as obs-phrase, meaning that it</font>
<font color="black"> 520.         # is obsolete syntax.  RFC 2822 requires that we recognize obsolete</font>
<font color="black"> 521.         # syntax, so allow dots in phrases.</font>
<font color="red"> 522.         self.phraseends = self.atomends.replace('.', '')</font>
<font color="red"> 523.         self.field = field</font>
<font color="red"> 524.         self.commentlist = []</font>
<font color="black"> 525. </font>
<font color="green"> 526.     def gotonext(self):</font>
<font color="black"> 527.         &quot;&quot;&quot;Parse up to the start of the next address.&quot;&quot;&quot;</font>
<font color="red"> 528.         while self.pos &lt; len(self.field):</font>
<font color="red"> 529.             if self.field[self.pos] in self.LWS + '\n\r':</font>
<font color="red"> 530.                 self.pos = self.pos + 1</font>
<font color="red"> 531.             elif self.field[self.pos] == '(':</font>
<font color="red"> 532.                 self.commentlist.append(self.getcomment())</font>
<font color="red"> 533.             else: break</font>
<font color="black"> 534. </font>
<font color="green"> 535.     def getaddrlist(self):</font>
<font color="black"> 536.         &quot;&quot;&quot;Parse all addresses.</font>
<font color="black"> 537. </font>
<font color="black"> 538.         Returns a list containing all of the addresses.</font>
<font color="black"> 539.         &quot;&quot;&quot;</font>
<font color="red"> 540.         result = []</font>
<font color="red"> 541.         ad = self.getaddress()</font>
<font color="red"> 542.         while ad:</font>
<font color="red"> 543.             result += ad</font>
<font color="red"> 544.             ad = self.getaddress()</font>
<font color="red"> 545.         return result</font>
<font color="black"> 546. </font>
<font color="green"> 547.     def getaddress(self):</font>
<font color="black"> 548.         &quot;&quot;&quot;Parse the next address.&quot;&quot;&quot;</font>
<font color="red"> 549.         self.commentlist = []</font>
<font color="red"> 550.         self.gotonext()</font>
<font color="black"> 551. </font>
<font color="red"> 552.         oldpos = self.pos</font>
<font color="red"> 553.         oldcl = self.commentlist</font>
<font color="red"> 554.         plist = self.getphraselist()</font>
<font color="black"> 555. </font>
<font color="red"> 556.         self.gotonext()</font>
<font color="red"> 557.         returnlist = []</font>
<font color="black"> 558. </font>
<font color="red"> 559.         if self.pos &gt;= len(self.field):</font>
<font color="black"> 560.             # Bad email address technically, no domain.</font>
<font color="red"> 561.             if plist:</font>
<font color="red"> 562.                 returnlist = [(' '.join(self.commentlist), plist[0])]</font>
<font color="black"> 563. </font>
<font color="red"> 564.         elif self.field[self.pos] in '.@':</font>
<font color="black"> 565.             # email address is just an addrspec</font>
<font color="black"> 566.             # this isn't very efficient since we start over</font>
<font color="red"> 567.             self.pos = oldpos</font>
<font color="red"> 568.             self.commentlist = oldcl</font>
<font color="red"> 569.             addrspec = self.getaddrspec()</font>
<font color="red"> 570.             returnlist = [(' '.join(self.commentlist), addrspec)]</font>
<font color="black"> 571. </font>
<font color="red"> 572.         elif self.field[self.pos] == ':':</font>
<font color="black"> 573.             # address is a group</font>
<font color="red"> 574.             returnlist = []</font>
<font color="black"> 575. </font>
<font color="red"> 576.             fieldlen = len(self.field)</font>
<font color="red"> 577.             self.pos += 1</font>
<font color="red"> 578.             while self.pos &lt; len(self.field):</font>
<font color="red"> 579.                 self.gotonext()</font>
<font color="red"> 580.                 if self.pos &lt; fieldlen and self.field[self.pos] == ';':</font>
<font color="red"> 581.                     self.pos += 1</font>
<font color="red"> 582.                     break</font>
<font color="red"> 583.                 returnlist = returnlist + self.getaddress()</font>
<font color="black"> 584. </font>
<font color="red"> 585.         elif self.field[self.pos] == '&lt;':</font>
<font color="black"> 586.             # Address is a phrase then a route addr</font>
<font color="red"> 587.             routeaddr = self.getrouteaddr()</font>
<font color="black"> 588. </font>
<font color="red"> 589.             if self.commentlist:</font>
<font color="black"> 590.                 returnlist = [(' '.join(plist) + ' (' + \</font>
<font color="red"> 591.                          ' '.join(self.commentlist) + ')', routeaddr)]</font>
<font color="red"> 592.             else: returnlist = [(' '.join(plist), routeaddr)]</font>
<font color="black"> 593. </font>
<font color="black"> 594.         else:</font>
<font color="red"> 595.             if plist:</font>
<font color="red"> 596.                 returnlist = [(' '.join(self.commentlist), plist[0])]</font>
<font color="red"> 597.             elif self.field[self.pos] in self.specials:</font>
<font color="red"> 598.                 self.pos += 1</font>
<font color="black"> 599. </font>
<font color="red"> 600.         self.gotonext()</font>
<font color="red"> 601.         if self.pos &lt; len(self.field) and self.field[self.pos] == ',':</font>
<font color="red"> 602.             self.pos += 1</font>
<font color="red"> 603.         return returnlist</font>
<font color="black"> 604. </font>
<font color="green"> 605.     def getrouteaddr(self):</font>
<font color="black"> 606.         &quot;&quot;&quot;Parse a route address (Return-path value).</font>
<font color="black"> 607. </font>
<font color="black"> 608.         This method just skips all the route stuff and returns the addrspec.</font>
<font color="black"> 609.         &quot;&quot;&quot;</font>
<font color="red"> 610.         if self.field[self.pos] != '&lt;':</font>
<font color="red"> 611.             return</font>
<font color="black"> 612. </font>
<font color="red"> 613.         expectroute = 0</font>
<font color="red"> 614.         self.pos += 1</font>
<font color="red"> 615.         self.gotonext()</font>
<font color="red"> 616.         adlist = &quot;&quot;</font>
<font color="red"> 617.         while self.pos &lt; len(self.field):</font>
<font color="red"> 618.             if expectroute:</font>
<font color="red"> 619.                 self.getdomain()</font>
<font color="red"> 620.                 expectroute = 0</font>
<font color="red"> 621.             elif self.field[self.pos] == '&gt;':</font>
<font color="red"> 622.                 self.pos += 1</font>
<font color="red"> 623.                 break</font>
<font color="red"> 624.             elif self.field[self.pos] == '@':</font>
<font color="red"> 625.                 self.pos += 1</font>
<font color="red"> 626.                 expectroute = 1</font>
<font color="red"> 627.             elif self.field[self.pos] == ':':</font>
<font color="red"> 628.                 self.pos += 1</font>
<font color="black"> 629.             else:</font>
<font color="red"> 630.                 adlist = self.getaddrspec()</font>
<font color="red"> 631.                 self.pos += 1</font>
<font color="red"> 632.                 break</font>
<font color="red"> 633.             self.gotonext()</font>
<font color="black"> 634. </font>
<font color="red"> 635.         return adlist</font>
<font color="black"> 636. </font>
<font color="green"> 637.     def getaddrspec(self):</font>
<font color="black"> 638.         &quot;&quot;&quot;Parse an RFC 2822 addr-spec.&quot;&quot;&quot;</font>
<font color="red"> 639.         aslist = []</font>
<font color="black"> 640. </font>
<font color="red"> 641.         self.gotonext()</font>
<font color="red"> 642.         while self.pos &lt; len(self.field):</font>
<font color="red"> 643.             if self.field[self.pos] == '.':</font>
<font color="red"> 644.                 aslist.append('.')</font>
<font color="red"> 645.                 self.pos += 1</font>
<font color="red"> 646.             elif self.field[self.pos] == '&quot;':</font>
<font color="red"> 647.                 aslist.append('&quot;%s&quot;' % self.getquote())</font>
<font color="red"> 648.             elif self.field[self.pos] in self.atomends:</font>
<font color="red"> 649.                 break</font>
<font color="red"> 650.             else: aslist.append(self.getatom())</font>
<font color="red"> 651.             self.gotonext()</font>
<font color="black"> 652. </font>
<font color="red"> 653.         if self.pos &gt;= len(self.field) or self.field[self.pos] != '@':</font>
<font color="red"> 654.             return ''.join(aslist)</font>
<font color="black"> 655. </font>
<font color="red"> 656.         aslist.append('@')</font>
<font color="red"> 657.         self.pos += 1</font>
<font color="red"> 658.         self.gotonext()</font>
<font color="red"> 659.         return ''.join(aslist) + self.getdomain()</font>
<font color="black"> 660. </font>
<font color="green"> 661.     def getdomain(self):</font>
<font color="black"> 662.         &quot;&quot;&quot;Get the complete domain name from an address.&quot;&quot;&quot;</font>
<font color="red"> 663.         sdlist = []</font>
<font color="red"> 664.         while self.pos &lt; len(self.field):</font>
<font color="red"> 665.             if self.field[self.pos] in self.LWS:</font>
<font color="red"> 666.                 self.pos += 1</font>
<font color="red"> 667.             elif self.field[self.pos] == '(':</font>
<font color="red"> 668.                 self.commentlist.append(self.getcomment())</font>
<font color="red"> 669.             elif self.field[self.pos] == '[':</font>
<font color="red"> 670.                 sdlist.append(self.getdomainliteral())</font>
<font color="red"> 671.             elif self.field[self.pos] == '.':</font>
<font color="red"> 672.                 self.pos += 1</font>
<font color="red"> 673.                 sdlist.append('.')</font>
<font color="red"> 674.             elif self.field[self.pos] in self.atomends:</font>
<font color="red"> 675.                 break</font>
<font color="red"> 676.             else: sdlist.append(self.getatom())</font>
<font color="red"> 677.         return ''.join(sdlist)</font>
<font color="black"> 678. </font>
<font color="green"> 679.     def getdelimited(self, beginchar, endchars, allowcomments = 1):</font>
<font color="black"> 680.         &quot;&quot;&quot;Parse a header fragment delimited by special characters.</font>
<font color="black"> 681. </font>
<font color="black"> 682.         `beginchar' is the start character for the fragment.  If self is not</font>
<font color="black"> 683.         looking at an instance of `beginchar' then getdelimited returns the</font>
<font color="black"> 684.         empty string.</font>
<font color="black"> 685. </font>
<font color="black"> 686.         `endchars' is a sequence of allowable end-delimiting characters.</font>
<font color="black"> 687.         Parsing stops when one of these is encountered.</font>
<font color="black"> 688. </font>
<font color="black"> 689.         If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed</font>
<font color="black"> 690.         within the parsed fragment.</font>
<font color="black"> 691.         &quot;&quot;&quot;</font>
<font color="red"> 692.         if self.field[self.pos] != beginchar:</font>
<font color="red"> 693.             return ''</font>
<font color="black"> 694. </font>
<font color="red"> 695.         slist = ['']</font>
<font color="red"> 696.         quote = 0</font>
<font color="red"> 697.         self.pos += 1</font>
<font color="red"> 698.         while self.pos &lt; len(self.field):</font>
<font color="red"> 699.             if quote == 1:</font>
<font color="red"> 700.                 slist.append(self.field[self.pos])</font>
<font color="red"> 701.                 quote = 0</font>
<font color="red"> 702.             elif self.field[self.pos] in endchars:</font>
<font color="red"> 703.                 self.pos += 1</font>
<font color="red"> 704.                 break</font>
<font color="red"> 705.             elif allowcomments and self.field[self.pos] == '(':</font>
<font color="red"> 706.                 slist.append(self.getcomment())</font>
<font color="red"> 707.                 continue        # have already advanced pos from getcomment</font>
<font color="red"> 708.             elif self.field[self.pos] == '\\':</font>
<font color="red"> 709.                 quote = 1</font>
<font color="black"> 710.             else:</font>
<font color="red"> 711.                 slist.append(self.field[self.pos])</font>
<font color="red"> 712.             self.pos += 1</font>
<font color="black"> 713. </font>
<font color="red"> 714.         return ''.join(slist)</font>
<font color="black"> 715. </font>
<font color="green"> 716.     def getquote(self):</font>
<font color="black"> 717.         &quot;&quot;&quot;Get a quote-delimited fragment from self's field.&quot;&quot;&quot;</font>
<font color="red"> 718.         return self.getdelimited('&quot;', '&quot;\r', 0)</font>
<font color="black"> 719. </font>
<font color="green"> 720.     def getcomment(self):</font>
<font color="black"> 721.         &quot;&quot;&quot;Get a parenthesis-delimited fragment from self's field.&quot;&quot;&quot;</font>
<font color="red"> 722.         return self.getdelimited('(', ')\r', 1)</font>
<font color="black"> 723. </font>
<font color="green"> 724.     def getdomainliteral(self):</font>
<font color="black"> 725.         &quot;&quot;&quot;Parse an RFC 2822 domain-literal.&quot;&quot;&quot;</font>
<font color="red"> 726.         return '[%s]' % self.getdelimited('[', ']\r', 0)</font>
<font color="black"> 727. </font>
<font color="green"> 728.     def getatom(self, atomends=None):</font>
<font color="black"> 729.         &quot;&quot;&quot;Parse an RFC 2822 atom.</font>
<font color="black"> 730. </font>
<font color="black"> 731.         Optional atomends specifies a different set of end token delimiters</font>
<font color="black"> 732.         (the default is to use self.atomends).  This is used e.g. in</font>
<font color="black"> 733.         getphraselist() since phrase endings must not include the `.' (which</font>
<font color="black"> 734.         is legal in phrases).&quot;&quot;&quot;</font>
<font color="red"> 735.         atomlist = ['']</font>
<font color="red"> 736.         if atomends is None:</font>
<font color="red"> 737.             atomends = self.atomends</font>
<font color="black"> 738. </font>
<font color="red"> 739.         while self.pos &lt; len(self.field):</font>
<font color="red"> 740.             if self.field[self.pos] in atomends:</font>
<font color="red"> 741.                 break</font>
<font color="red"> 742.             else: atomlist.append(self.field[self.pos])</font>
<font color="red"> 743.             self.pos += 1</font>
<font color="black"> 744. </font>
<font color="red"> 745.         return ''.join(atomlist)</font>
<font color="black"> 746. </font>
<font color="green"> 747.     def getphraselist(self):</font>
<font color="black"> 748.         &quot;&quot;&quot;Parse a sequence of RFC 2822 phrases.</font>
<font color="black"> 749. </font>
<font color="black"> 750.         A phrase is a sequence of words, which are in turn either RFC 2822</font>
<font color="black"> 751.         atoms or quoted-strings.  Phrases are canonicalized by squeezing all</font>
<font color="black"> 752.         runs of continuous whitespace into one space.</font>
<font color="black"> 753.         &quot;&quot;&quot;</font>
<font color="red"> 754.         plist = []</font>
<font color="black"> 755. </font>
<font color="red"> 756.         while self.pos &lt; len(self.field):</font>
<font color="red"> 757.             if self.field[self.pos] in self.LWS:</font>
<font color="red"> 758.                 self.pos += 1</font>
<font color="red"> 759.             elif self.field[self.pos] == '&quot;':</font>
<font color="red"> 760.                 plist.append(self.getquote())</font>
<font color="red"> 761.             elif self.field[self.pos] == '(':</font>
<font color="red"> 762.                 self.commentlist.append(self.getcomment())</font>
<font color="red"> 763.             elif self.field[self.pos] in self.phraseends:</font>
<font color="red"> 764.                 break</font>
<font color="black"> 765.             else:</font>
<font color="red"> 766.                 plist.append(self.getatom(self.phraseends))</font>
<font color="black"> 767. </font>
<font color="red"> 768.         return plist</font>
<font color="black"> 769. </font>
<font color="green"> 770. class AddressList(AddrlistClass):</font>
<font color="green"> 771.     &quot;&quot;&quot;An AddressList encapsulates a list of parsed RFC 2822 addresses.&quot;&quot;&quot;</font>
<font color="green"> 772.     def __init__(self, field):</font>
<font color="red"> 773.         AddrlistClass.__init__(self, field)</font>
<font color="red"> 774.         if field:</font>
<font color="red"> 775.             self.addresslist = self.getaddrlist()</font>
<font color="black"> 776.         else:</font>
<font color="red"> 777.             self.addresslist = []</font>
<font color="black"> 778. </font>
<font color="green"> 779.     def __len__(self):</font>
<font color="red"> 780.         return len(self.addresslist)</font>
<font color="black"> 781. </font>
<font color="green"> 782.     def __str__(self):</font>
<font color="red"> 783.         return &quot;, &quot;.join(map(dump_address_pair, self.addresslist))</font>
<font color="black"> 784. </font>
<font color="green"> 785.     def __add__(self, other):</font>
<font color="black"> 786.         # Set union</font>
<font color="red"> 787.         newaddr = AddressList(None)</font>
<font color="red"> 788.         newaddr.addresslist = self.addresslist[:]</font>
<font color="red"> 789.         for x in other.addresslist:</font>
<font color="red"> 790.             if not x in self.addresslist:</font>
<font color="red"> 791.                 newaddr.addresslist.append(x)</font>
<font color="red"> 792.         return newaddr</font>
<font color="black"> 793. </font>
<font color="green"> 794.     def __iadd__(self, other):</font>
<font color="black"> 795.         # Set union, in-place</font>
<font color="red"> 796.         for x in other.addresslist:</font>
<font color="red"> 797.             if not x in self.addresslist:</font>
<font color="red"> 798.                 self.addresslist.append(x)</font>
<font color="red"> 799.         return self</font>
<font color="black"> 800. </font>
<font color="green"> 801.     def __sub__(self, other):</font>
<font color="black"> 802.         # Set difference</font>
<font color="red"> 803.         newaddr = AddressList(None)</font>
<font color="red"> 804.         for x in self.addresslist:</font>
<font color="red"> 805.             if not x in other.addresslist:</font>
<font color="red"> 806.                 newaddr.addresslist.append(x)</font>
<font color="red"> 807.         return newaddr</font>
<font color="black"> 808. </font>
<font color="green"> 809.     def __isub__(self, other):</font>
<font color="black"> 810.         # Set difference, in-place</font>
<font color="red"> 811.         for x in other.addresslist:</font>
<font color="red"> 812.             if x in self.addresslist:</font>
<font color="red"> 813.                 self.addresslist.remove(x)</font>
<font color="red"> 814.         return self</font>
<font color="black"> 815. </font>
<font color="green"> 816.     def __getitem__(self, index):</font>
<font color="black"> 817.         # Make indexing, slices, and 'in' work</font>
<font color="red"> 818.         return self.addresslist[index]</font>
<font color="black"> 819. </font>
<font color="green"> 820. def dump_address_pair(pair):</font>
<font color="black"> 821.     &quot;&quot;&quot;Dump a (name, address) pair in a canonicalized form.&quot;&quot;&quot;</font>
<font color="red"> 822.     if pair[0]:</font>
<font color="red"> 823.         return '&quot;' + pair[0] + '&quot; &lt;' + pair[1] + '&gt;'</font>
<font color="black"> 824.     else:</font>
<font color="red"> 825.         return pair[1]</font>
<font color="black"> 826. </font>
<font color="black"> 827. # Parse a date field</font>
<font color="black"> 828. </font>
<font color="green"> 829. _monthnames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul',</font>
<font color="green"> 830.                'aug', 'sep', 'oct', 'nov', 'dec',</font>
<font color="green"> 831.                'january', 'february', 'march', 'april', 'may', 'june', 'july',</font>
<font color="green"> 832.                'august', 'september', 'october', 'november', 'december']</font>
<font color="green"> 833. _daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']</font>
<font color="black"> 834. </font>
<font color="black"> 835. # The timezone table does not include the military time zones defined</font>
<font color="black"> 836. # in RFC822, other than Z.  According to RFC1123, the description in</font>
<font color="black"> 837. # RFC822 gets the signs wrong, so we can't rely on any such time</font>
<font color="black"> 838. # zones.  RFC1123 recommends that numeric timezone indicators be used</font>
<font color="black"> 839. # instead of timezone names.</font>
<font color="black"> 840. </font>
<font color="green"> 841. _timezones = {'UT':0, 'UTC':0, 'GMT':0, 'Z':0,</font>
<font color="green"> 842.               'AST': -400, 'ADT': -300,  # Atlantic (used in Canada)</font>
<font color="green"> 843.               'EST': -500, 'EDT': -400,  # Eastern</font>
<font color="green"> 844.               'CST': -600, 'CDT': -500,  # Central</font>
<font color="green"> 845.               'MST': -700, 'MDT': -600,  # Mountain</font>
<font color="green"> 846.               'PST': -800, 'PDT': -700   # Pacific</font>
<font color="black"> 847.               }</font>
<font color="black"> 848. </font>
<font color="black"> 849. </font>
<font color="green"> 850. def parsedate_tz(data):</font>
<font color="black"> 851.     &quot;&quot;&quot;Convert a date string to a time tuple.</font>
<font color="black"> 852. </font>
<font color="black"> 853.     Accounts for military timezones.</font>
<font color="black"> 854.     &quot;&quot;&quot;</font>
<font color="red"> 855.     if not data:</font>
<font color="red"> 856.         return None</font>
<font color="red"> 857.     data = data.split()</font>
<font color="red"> 858.     if data[0][-1] in (',', '.') or data[0].lower() in _daynames:</font>
<font color="black"> 859.         # There's a dayname here. Skip it</font>
<font color="red"> 860.         del data[0]</font>
<font color="black"> 861.     else:</font>
<font color="black"> 862.         # no space after the &quot;weekday,&quot;?</font>
<font color="red"> 863.         i = data[0].rfind(',')</font>
<font color="red"> 864.         if i &gt;= 0:</font>
<font color="red"> 865.             data[0] = data[0][i+1:]</font>
<font color="red"> 866.     if len(data) == 3: # RFC 850 date, deprecated</font>
<font color="red"> 867.         stuff = data[0].split('-')</font>
<font color="red"> 868.         if len(stuff) == 3:</font>
<font color="red"> 869.             data = stuff + data[1:]</font>
<font color="red"> 870.     if len(data) == 4:</font>
<font color="red"> 871.         s = data[3]</font>
<font color="red"> 872.         i = s.find('+')</font>
<font color="red"> 873.         if i &gt; 0:</font>
<font color="red"> 874.             data[3:] = [s[:i], s[i+1:]]</font>
<font color="black"> 875.         else:</font>
<font color="red"> 876.             data.append('') # Dummy tz</font>
<font color="red"> 877.     if len(data) &lt; 5:</font>
<font color="red"> 878.         return None</font>
<font color="red"> 879.     data = data[:5]</font>
<font color="red"> 880.     [dd, mm, yy, tm, tz] = data</font>
<font color="red"> 881.     mm = mm.lower()</font>
<font color="red"> 882.     if not mm in _monthnames:</font>
<font color="red"> 883.         dd, mm = mm, dd.lower()</font>
<font color="red"> 884.         if not mm in _monthnames:</font>
<font color="red"> 885.             return None</font>
<font color="red"> 886.     mm = _monthnames.index(mm)+1</font>
<font color="red"> 887.     if mm &gt; 12: mm = mm - 12</font>
<font color="red"> 888.     if dd[-1] == ',':</font>
<font color="red"> 889.         dd = dd[:-1]</font>
<font color="red"> 890.     i = yy.find(':')</font>
<font color="red"> 891.     if i &gt; 0:</font>
<font color="red"> 892.         yy, tm = tm, yy</font>
<font color="red"> 893.     if yy[-1] == ',':</font>
<font color="red"> 894.         yy = yy[:-1]</font>
<font color="red"> 895.     if not yy[0].isdigit():</font>
<font color="red"> 896.         yy, tz = tz, yy</font>
<font color="red"> 897.     if tm[-1] == ',':</font>
<font color="red"> 898.         tm = tm[:-1]</font>
<font color="red"> 899.     tm = tm.split(':')</font>
<font color="red"> 900.     if len(tm) == 2:</font>
<font color="red"> 901.         [thh, tmm] = tm</font>
<font color="red"> 902.         tss = '0'</font>
<font color="red"> 903.     elif len(tm) == 3:</font>
<font color="red"> 904.         [thh, tmm, tss] = tm</font>
<font color="black"> 905.     else:</font>
<font color="red"> 906.         return None</font>
<font color="red"> 907.     try:</font>
<font color="red"> 908.         yy = int(yy)</font>
<font color="red"> 909.         dd = int(dd)</font>
<font color="red"> 910.         thh = int(thh)</font>
<font color="red"> 911.         tmm = int(tmm)</font>
<font color="red"> 912.         tss = int(tss)</font>
<font color="red"> 913.     except ValueError:</font>
<font color="red"> 914.         return None</font>
<font color="red"> 915.     tzoffset = None</font>
<font color="red"> 916.     tz = tz.upper()</font>
<font color="red"> 917.     if tz in _timezones:</font>
<font color="red"> 918.         tzoffset = _timezones[tz]</font>
<font color="black"> 919.     else:</font>
<font color="red"> 920.         try:</font>
<font color="red"> 921.             tzoffset = int(tz)</font>
<font color="red"> 922.         except ValueError:</font>
<font color="red"> 923.             pass</font>
<font color="black"> 924.     # Convert a timezone offset into seconds ; -0500 -&gt; -18000</font>
<font color="red"> 925.     if tzoffset:</font>
<font color="red"> 926.         if tzoffset &lt; 0:</font>
<font color="red"> 927.             tzsign = -1</font>
<font color="red"> 928.             tzoffset = -tzoffset</font>
<font color="black"> 929.         else:</font>
<font color="red"> 930.             tzsign = 1</font>
<font color="red"> 931.         tzoffset = tzsign * ( (tzoffset//100)*3600 + (tzoffset % 100)*60)</font>
<font color="red"> 932.     return (yy, mm, dd, thh, tmm, tss, 0, 1, 0, tzoffset)</font>
<font color="black"> 933. </font>
<font color="black"> 934. </font>
<font color="green"> 935. def parsedate(data):</font>
<font color="black"> 936.     &quot;&quot;&quot;Convert a time string to a time tuple.&quot;&quot;&quot;</font>
<font color="red"> 937.     t = parsedate_tz(data)</font>
<font color="red"> 938.     if t is None:</font>
<font color="red"> 939.         return t</font>
<font color="red"> 940.     return t[:9]</font>
<font color="black"> 941. </font>
<font color="black"> 942. </font>
<font color="green"> 943. def mktime_tz(data):</font>
<font color="black"> 944.     &quot;&quot;&quot;Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp.&quot;&quot;&quot;</font>
<font color="red"> 945.     if data[9] is None:</font>
<font color="black"> 946.         # No zone info, so localtime is better assumption than GMT</font>
<font color="red"> 947.         return time.mktime(data[:8] + (-1,))</font>
<font color="black"> 948.     else:</font>
<font color="red"> 949.         t = time.mktime(data[:8] + (0,))</font>
<font color="red"> 950.         return t - data[9] - time.timezone</font>
<font color="black"> 951. </font>
<font color="green"> 952. def formatdate(timeval=None):</font>
<font color="black"> 953.     &quot;&quot;&quot;Returns time format preferred for Internet standards.</font>
<font color="black"> 954. </font>
<font color="black"> 955.     Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123</font>
<font color="black"> 956. </font>
<font color="black"> 957.     According to RFC 1123, day and month names must always be in</font>
<font color="black"> 958.     English.  If not for that, this code could use strftime().  It</font>
<font color="black"> 959.     can't because strftime() honors the locale and could generated</font>
<font color="black"> 960.     non-English names.</font>
<font color="black"> 961.     &quot;&quot;&quot;</font>
<font color="red"> 962.     if timeval is None:</font>
<font color="red"> 963.         timeval = time.time()</font>
<font color="red"> 964.     timeval = time.gmtime(timeval)</font>
<font color="red"> 965.     return &quot;%s, %02d %s %04d %02d:%02d:%02d GMT&quot; % (</font>
<font color="red"> 966.             (&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;)[timeval[6]],</font>
<font color="red"> 967.             timeval[2],</font>
<font color="black"> 968.             (&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,</font>
<font color="red"> 969.              &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)[timeval[1]-1],</font>
<font color="red"> 970.                                 timeval[0], timeval[3], timeval[4], timeval[5])</font>
<font color="black"> 971. </font>
<font color="black"> 972. </font>
<font color="black"> 973. # When used as script, run a small test program.</font>
<font color="black"> 974. # The first command line argument must be a filename containing one</font>
<font color="black"> 975. # message in RFC-822 format.</font>
<font color="black"> 976. </font>
<font color="green"> 977. if __name__ == '__main__':</font>
<font color="red"> 978.     import sys, os</font>
<font color="red"> 979.     file = os.path.join(os.environ['HOME'], 'Mail/inbox/1')</font>
<font color="red"> 980.     if sys.argv[1:]: file = sys.argv[1]</font>
<font color="red"> 981.     f = open(file, 'r')</font>
<font color="red"> 982.     m = Message(f)</font>
<font color="red"> 983.     print 'From:', m.getaddr('from')</font>
<font color="red"> 984.     print 'To:', m.getaddrlist('to')</font>
<font color="red"> 985.     print 'Subject:', m.getheader('subject')</font>
<font color="red"> 986.     print 'Date:', m.getheader('date')</font>
<font color="red"> 987.     date = m.getdate_tz('date')</font>
<font color="red"> 988.     tz = date[-1]</font>
<font color="red"> 989.     date = time.localtime(mktime_tz(date))</font>
<font color="red"> 990.     if date:</font>
<font color="red"> 991.         print 'ParsedDate:', time.asctime(date),</font>
<font color="red"> 992.         hhmmss = tz</font>
<font color="red"> 993.         hhmm, ss = divmod(hhmmss, 60)</font>
<font color="red"> 994.         hh, mm = divmod(hhmm, 60)</font>
<font color="red"> 995.         print &quot;%+03d%02d&quot; % (hh, mm),</font>
<font color="red"> 996.         if ss: print &quot;.%02d&quot; % ss,</font>
<font color="red"> 997.         print</font>
<font color="black"> 998.     else:</font>
<font color="red"> 999.         print 'ParsedDate:', None</font>
<font color="red">1000.     m.rewindbody()</font>
<font color="red">1001.     n = 0</font>
<font color="red">1002.     while f.readline():</font>
<font color="red">1003.         n += 1</font>
<font color="red">1004.     print 'Lines:', n</font>
<font color="red">1005.     print '-'*70</font>
<font color="red">1006.     print 'len =', len(m)</font>
<font color="red">1007.     if 'Date' in m: print 'Date =', m['Date']</font>
<font color="red">1008.     if 'X-Nonsense' in m: pass</font>
<font color="red">1009.     print 'keys =', m.keys()</font>
<font color="red">1010.     print 'values =', m.values()</font>
<font color="red">1011.     print 'items =', m.items()</font>
</pre>

