source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/datastructures.py</b><br>


file stats: <b>179 lines, 84 executed: 46.9% covered</b>
<pre>
<font color="green">   1. import copy</font>
<font color="green">   2. from collections import OrderedDict</font>
<font color="black">   3. </font>
<font color="green">   4. from django.utils import six</font>
<font color="black">   5. </font>
<font color="black">   6. </font>
<font color="green">   7. class OrderedSet(object):</font>
<font color="black">   8.     &quot;&quot;&quot;</font>
<font color="black">   9.     A set which keeps the ordering of the inserted items.</font>
<font color="black">  10.     Currently backs onto OrderedDict.</font>
<font color="green">  11.     &quot;&quot;&quot;</font>
<font color="black">  12. </font>
<font color="green">  13.     def __init__(self, iterable=None):</font>
<font color="green">  14.         self.dict = OrderedDict(((x, None) for x in iterable) if iterable else [])</font>
<font color="black">  15. </font>
<font color="green">  16.     def add(self, item):</font>
<font color="green">  17.         self.dict[item] = None</font>
<font color="black">  18. </font>
<font color="green">  19.     def remove(self, item):</font>
<font color="red">  20.         del self.dict[item]</font>
<font color="black">  21. </font>
<font color="green">  22.     def discard(self, item):</font>
<font color="red">  23.         try:</font>
<font color="red">  24.             self.remove(item)</font>
<font color="red">  25.         except KeyError:</font>
<font color="red">  26.             pass</font>
<font color="black">  27. </font>
<font color="green">  28.     def __iter__(self):</font>
<font color="green">  29.         return iter(self.dict.keys())</font>
<font color="black">  30. </font>
<font color="green">  31.     def __contains__(self, item):</font>
<font color="red">  32.         return item in self.dict</font>
<font color="black">  33. </font>
<font color="green">  34.     def __bool__(self):</font>
<font color="red">  35.         return bool(self.dict)</font>
<font color="black">  36. </font>
<font color="green">  37.     def __nonzero__(self):      # Python 2 compatibility</font>
<font color="red">  38.         return type(self).__bool__(self)</font>
<font color="black">  39. </font>
<font color="green">  40.     def __len__(self):</font>
<font color="green">  41.         return len(self.dict)</font>
<font color="black">  42. </font>
<font color="black">  43. </font>
<font color="green">  44. class MultiValueDictKeyError(KeyError):</font>
<font color="green">  45.     pass</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. class MultiValueDict(dict):</font>
<font color="black">  49.     &quot;&quot;&quot;</font>
<font color="black">  50.     A subclass of dictionary customized to handle multiple values for the</font>
<font color="black">  51.     same key.</font>
<font color="black">  52. </font>
<font color="black">  53.     &gt;&gt;&gt; d = MultiValueDict({'name': ['Adrian', 'Simon'], 'position': ['Developer']})</font>
<font color="black">  54.     &gt;&gt;&gt; d['name']</font>
<font color="black">  55.     'Simon'</font>
<font color="black">  56.     &gt;&gt;&gt; d.getlist('name')</font>
<font color="black">  57.     ['Adrian', 'Simon']</font>
<font color="black">  58.     &gt;&gt;&gt; d.getlist('doesnotexist')</font>
<font color="black">  59.     []</font>
<font color="black">  60.     &gt;&gt;&gt; d.getlist('doesnotexist', ['Adrian', 'Simon'])</font>
<font color="black">  61.     ['Adrian', 'Simon']</font>
<font color="black">  62.     &gt;&gt;&gt; d.get('lastname', 'nonexistent')</font>
<font color="black">  63.     'nonexistent'</font>
<font color="black">  64.     &gt;&gt;&gt; d.setlist('lastname', ['Holovaty', 'Willison'])</font>
<font color="black">  65. </font>
<font color="black">  66.     This class exists to solve the irritating problem raised by cgi.parse_qs,</font>
<font color="black">  67.     which returns a list for every key, even though most Web forms submit</font>
<font color="black">  68.     single name-value pairs.</font>
<font color="green">  69.     &quot;&quot;&quot;</font>
<font color="green">  70.     def __init__(self, key_to_list_mapping=()):</font>
<font color="red">  71.         super(MultiValueDict, self).__init__(key_to_list_mapping)</font>
<font color="black">  72. </font>
<font color="green">  73.     def __repr__(self):</font>
<font color="red">  74.         return &quot;&lt;%s: %s&gt;&quot; % (self.__class__.__name__,</font>
<font color="red">  75.                              super(MultiValueDict, self).__repr__())</font>
<font color="black">  76. </font>
<font color="green">  77.     def __getitem__(self, key):</font>
<font color="black">  78.         &quot;&quot;&quot;</font>
<font color="black">  79.         Returns the last data value for this key, or [] if it's an empty list;</font>
<font color="black">  80.         raises KeyError if not found.</font>
<font color="black">  81.         &quot;&quot;&quot;</font>
<font color="red">  82.         try:</font>
<font color="red">  83.             list_ = super(MultiValueDict, self).__getitem__(key)</font>
<font color="red">  84.         except KeyError:</font>
<font color="red">  85.             raise MultiValueDictKeyError(repr(key))</font>
<font color="red">  86.         try:</font>
<font color="red">  87.             return list_[-1]</font>
<font color="red">  88.         except IndexError:</font>
<font color="red">  89.             return []</font>
<font color="black">  90. </font>
<font color="green">  91.     def __setitem__(self, key, value):</font>
<font color="red">  92.         super(MultiValueDict, self).__setitem__(key, [value])</font>
<font color="black">  93. </font>
<font color="green">  94.     def __copy__(self):</font>
<font color="red">  95.         return self.__class__([</font>
<font color="red">  96.             (k, v[:])</font>
<font color="red">  97.             for k, v in self.lists()</font>
<font color="black">  98.         ])</font>
<font color="black">  99. </font>
<font color="green"> 100.     def __deepcopy__(self, memo=None):</font>
<font color="red"> 101.         if memo is None:</font>
<font color="red"> 102.             memo = {}</font>
<font color="red"> 103.         result = self.__class__()</font>
<font color="red"> 104.         memo[id(self)] = result</font>
<font color="red"> 105.         for key, value in dict.items(self):</font>
<font color="red"> 106.             dict.__setitem__(result, copy.deepcopy(key, memo),</font>
<font color="red"> 107.                              copy.deepcopy(value, memo))</font>
<font color="red"> 108.         return result</font>
<font color="black"> 109. </font>
<font color="green"> 110.     def __getstate__(self):</font>
<font color="red"> 111.         obj_dict = self.__dict__.copy()</font>
<font color="red"> 112.         obj_dict['_data'] = {k: self.getlist(k) for k in self}</font>
<font color="red"> 113.         return obj_dict</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def __setstate__(self, obj_dict):</font>
<font color="red"> 116.         data = obj_dict.pop('_data', {})</font>
<font color="red"> 117.         for k, v in data.items():</font>
<font color="red"> 118.             self.setlist(k, v)</font>
<font color="red"> 119.         self.__dict__.update(obj_dict)</font>
<font color="black"> 120. </font>
<font color="green"> 121.     def get(self, key, default=None):</font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="black"> 123.         Returns the last data value for the passed key. If key doesn't exist</font>
<font color="black"> 124.         or value is an empty list, then default is returned.</font>
<font color="black"> 125.         &quot;&quot;&quot;</font>
<font color="red"> 126.         try:</font>
<font color="red"> 127.             val = self[key]</font>
<font color="red"> 128.         except KeyError:</font>
<font color="red"> 129.             return default</font>
<font color="red"> 130.         if val == []:</font>
<font color="red"> 131.             return default</font>
<font color="red"> 132.         return val</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def getlist(self, key, default=None):</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="black"> 136.         Returns the list of values for the passed key. If key doesn't exist,</font>
<font color="black"> 137.         then a default value is returned.</font>
<font color="black"> 138.         &quot;&quot;&quot;</font>
<font color="red"> 139.         try:</font>
<font color="red"> 140.             return super(MultiValueDict, self).__getitem__(key)</font>
<font color="red"> 141.         except KeyError:</font>
<font color="red"> 142.             if default is None:</font>
<font color="red"> 143.                 return []</font>
<font color="red"> 144.             return default</font>
<font color="black"> 145. </font>
<font color="green"> 146.     def setlist(self, key, list_):</font>
<font color="red"> 147.         super(MultiValueDict, self).__setitem__(key, list_)</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def setdefault(self, key, default=None):</font>
<font color="red"> 150.         if key not in self:</font>
<font color="red"> 151.             self[key] = default</font>
<font color="black"> 152.             # Do not return default here because __setitem__() may store</font>
<font color="black"> 153.             # another value -- QueryDict.__setitem__() does. Look it up.</font>
<font color="red"> 154.         return self[key]</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def setlistdefault(self, key, default_list=None):</font>
<font color="red"> 157.         if key not in self:</font>
<font color="red"> 158.             if default_list is None:</font>
<font color="red"> 159.                 default_list = []</font>
<font color="red"> 160.             self.setlist(key, default_list)</font>
<font color="black"> 161.             # Do not return default_list here because setlist() may store</font>
<font color="black"> 162.             # another value -- QueryDict.setlist() does. Look it up.</font>
<font color="red"> 163.         return self.getlist(key)</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def appendlist(self, key, value):</font>
<font color="black"> 166.         &quot;&quot;&quot;Appends an item to the internal list associated with key.&quot;&quot;&quot;</font>
<font color="red"> 167.         self.setlistdefault(key).append(value)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def _iteritems(self):</font>
<font color="black"> 170.         &quot;&quot;&quot;</font>
<font color="black"> 171.         Yields (key, value) pairs, where value is the last item in the list</font>
<font color="black"> 172.         associated with the key.</font>
<font color="black"> 173.         &quot;&quot;&quot;</font>
<font color="red"> 174.         for key in self:</font>
<font color="red"> 175.             yield key, self[key]</font>
<font color="black"> 176. </font>
<font color="green"> 177.     def _iterlists(self):</font>
<font color="black"> 178.         &quot;&quot;&quot;Yields (key, list) pairs.&quot;&quot;&quot;</font>
<font color="red"> 179.         return six.iteritems(super(MultiValueDict, self))</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def _itervalues(self):</font>
<font color="black"> 182.         &quot;&quot;&quot;Yield the last value on every key list.&quot;&quot;&quot;</font>
<font color="red"> 183.         for key in self:</font>
<font color="red"> 184.             yield self[key]</font>
<font color="black"> 185. </font>
<font color="green"> 186.     if six.PY3:</font>
<font color="red"> 187.         items = _iteritems</font>
<font color="red"> 188.         lists = _iterlists</font>
<font color="red"> 189.         values = _itervalues</font>
<font color="black"> 190.     else:</font>
<font color="green"> 191.         iteritems = _iteritems</font>
<font color="green"> 192.         iterlists = _iterlists</font>
<font color="green"> 193.         itervalues = _itervalues</font>
<font color="black"> 194. </font>
<font color="green"> 195.         def items(self):</font>
<font color="red"> 196.             return list(self.iteritems())</font>
<font color="black"> 197. </font>
<font color="green"> 198.         def lists(self):</font>
<font color="red"> 199.             return list(self.iterlists())</font>
<font color="black"> 200. </font>
<font color="green"> 201.         def values(self):</font>
<font color="red"> 202.             return list(self.itervalues())</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def copy(self):</font>
<font color="black"> 205.         &quot;&quot;&quot;Returns a shallow copy of this object.&quot;&quot;&quot;</font>
<font color="red"> 206.         return copy.copy(self)</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def update(self, *args, **kwargs):</font>
<font color="black"> 209.         &quot;&quot;&quot;</font>
<font color="black"> 210.         update() extends rather than replaces existing key lists.</font>
<font color="black"> 211.         Also accepts keyword args.</font>
<font color="black"> 212.         &quot;&quot;&quot;</font>
<font color="red"> 213.         if len(args) &gt; 1:</font>
<font color="red"> 214.             raise TypeError(&quot;update expected at most 1 arguments, got %d&quot; % len(args))</font>
<font color="red"> 215.         if args:</font>
<font color="red"> 216.             other_dict = args[0]</font>
<font color="red"> 217.             if isinstance(other_dict, MultiValueDict):</font>
<font color="red"> 218.                 for key, value_list in other_dict.lists():</font>
<font color="red"> 219.                     self.setlistdefault(key).extend(value_list)</font>
<font color="black"> 220.             else:</font>
<font color="red"> 221.                 try:</font>
<font color="red"> 222.                     for key, value in other_dict.items():</font>
<font color="red"> 223.                         self.setlistdefault(key).append(value)</font>
<font color="red"> 224.                 except TypeError:</font>
<font color="red"> 225.                     raise ValueError(&quot;MultiValueDict.update() takes either a MultiValueDict or dictionary&quot;)</font>
<font color="red"> 226.         for key, value in six.iteritems(kwargs):</font>
<font color="red"> 227.             self.setlistdefault(key).append(value)</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def dict(self):</font>
<font color="black"> 230.         &quot;&quot;&quot;</font>
<font color="black"> 231.         Returns current object as a dict with singular values.</font>
<font color="black"> 232.         &quot;&quot;&quot;</font>
<font color="red"> 233.         return {key: self[key] for key in self}</font>
<font color="black"> 234. </font>
<font color="black"> 235. </font>
<font color="green"> 236. class ImmutableList(tuple):</font>
<font color="black"> 237.     &quot;&quot;&quot;</font>
<font color="black"> 238.     A tuple-like object that raises useful errors when it is asked to mutate.</font>
<font color="black"> 239. </font>
<font color="black"> 240.     Example::</font>
<font color="black"> 241. </font>
<font color="black"> 242.         &gt;&gt;&gt; a = ImmutableList(range(5), warning=&quot;You cannot mutate this.&quot;)</font>
<font color="black"> 243.         &gt;&gt;&gt; a[3] = '4'</font>
<font color="black"> 244.         Traceback (most recent call last):</font>
<font color="black"> 245.             ...</font>
<font color="black"> 246.         AttributeError: You cannot mutate this.</font>
<font color="green"> 247.     &quot;&quot;&quot;</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def __new__(cls, *args, **kwargs):</font>
<font color="green"> 250.         if 'warning' in kwargs:</font>
<font color="green"> 251.             warning = kwargs['warning']</font>
<font color="green"> 252.             del kwargs['warning']</font>
<font color="black"> 253.         else:</font>
<font color="red"> 254.             warning = 'ImmutableList object is immutable.'</font>
<font color="green"> 255.         self = tuple.__new__(cls, *args, **kwargs)</font>
<font color="green"> 256.         self.warning = warning</font>
<font color="green"> 257.         return self</font>
<font color="black"> 258. </font>
<font color="green"> 259.     def complain(self, *wargs, **kwargs):</font>
<font color="red"> 260.         if isinstance(self.warning, Exception):</font>
<font color="red"> 261.             raise self.warning</font>
<font color="black"> 262.         else:</font>
<font color="red"> 263.             raise AttributeError(self.warning)</font>
<font color="black"> 264. </font>
<font color="black"> 265.     # All list mutation functions complain.</font>
<font color="green"> 266.     __delitem__ = complain</font>
<font color="green"> 267.     __delslice__ = complain</font>
<font color="green"> 268.     __iadd__ = complain</font>
<font color="green"> 269.     __imul__ = complain</font>
<font color="green"> 270.     __setitem__ = complain</font>
<font color="green"> 271.     __setslice__ = complain</font>
<font color="green"> 272.     append = complain</font>
<font color="green"> 273.     extend = complain</font>
<font color="green"> 274.     insert = complain</font>
<font color="green"> 275.     pop = complain</font>
<font color="green"> 276.     remove = complain</font>
<font color="green"> 277.     sort = complain</font>
<font color="green"> 278.     reverse = complain</font>
<font color="black"> 279. </font>
<font color="black"> 280. </font>
<font color="green"> 281. class DictWrapper(dict):</font>
<font color="black"> 282.     &quot;&quot;&quot;</font>
<font color="black"> 283.     Wraps accesses to a dictionary so that certain values (those starting with</font>
<font color="black"> 284.     the specified prefix) are passed through a function before being returned.</font>
<font color="black"> 285.     The prefix is removed before looking up the real value.</font>
<font color="black"> 286. </font>
<font color="black"> 287.     Used by the SQL construction code to ensure that values are correctly</font>
<font color="black"> 288.     quoted before being used.</font>
<font color="green"> 289.     &quot;&quot;&quot;</font>
<font color="green"> 290.     def __init__(self, data, func, prefix):</font>
<font color="green"> 291.         super(DictWrapper, self).__init__(data)</font>
<font color="green"> 292.         self.func = func</font>
<font color="green"> 293.         self.prefix = prefix</font>
<font color="black"> 294. </font>
<font color="green"> 295.     def __getitem__(self, key):</font>
<font color="black"> 296.         &quot;&quot;&quot;</font>
<font color="black"> 297.         Retrieves the real value after stripping the prefix string (if</font>
<font color="black"> 298.         present). If the prefix is present, pass the value through self.func</font>
<font color="black"> 299.         before returning, otherwise return the raw value.</font>
<font color="black"> 300.         &quot;&quot;&quot;</font>
<font color="green"> 301.         if key.startswith(self.prefix):</font>
<font color="red"> 302.             use_func = True</font>
<font color="red"> 303.             key = key[len(self.prefix):]</font>
<font color="black"> 304.         else:</font>
<font color="green"> 305.             use_func = False</font>
<font color="green"> 306.         value = super(DictWrapper, self).__getitem__(key)</font>
<font color="green"> 307.         if use_func:</font>
<font color="red"> 308.             return self.func(value)</font>
<font color="green"> 309.         return value</font>
</pre>

