source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/datetime_safe.py</b><br>


file stats: <b>60 lines, 16 executed: 26.7% covered</b>
<pre>
<font color="black">   1. # Python's datetime strftime doesn't handle dates before 1900.</font>
<font color="black">   2. # These classes override date and datetime to support the formatting of a date</font>
<font color="black">   3. # through its full &quot;proleptic Gregorian&quot; date range.</font>
<font color="black">   4. #</font>
<font color="black">   5. # Based on code submitted to comp.lang.python by Andrew Dalke</font>
<font color="black">   6. #</font>
<font color="black">   7. # &gt;&gt;&gt; datetime_safe.date(1850, 8, 2).strftime(&quot;%Y/%m/%d was a %A&quot;)</font>
<font color="black">   8. # '1850/08/02 was a Friday'</font>
<font color="black">   9. </font>
<font color="green">  10. import re</font>
<font color="green">  11. import time as ttime</font>
<font color="green">  12. from datetime import (</font>
<font color="black">  13.     date as real_date, datetime as real_datetime, time as real_time,</font>
<font color="black">  14. )</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. class date(real_date):</font>
<font color="green">  18.     def strftime(self, fmt):</font>
<font color="red">  19.         return strftime(self, fmt)</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class datetime(real_datetime):</font>
<font color="green">  23.     def strftime(self, fmt):</font>
<font color="red">  24.         return strftime(self, fmt)</font>
<font color="black">  25. </font>
<font color="green">  26.     @classmethod</font>
<font color="black">  27.     def combine(cls, date, time):</font>
<font color="red">  28.         return cls(date.year, date.month, date.day,</font>
<font color="red">  29.                    time.hour, time.minute, time.second,</font>
<font color="red">  30.                    time.microsecond, time.tzinfo)</font>
<font color="black">  31. </font>
<font color="green">  32.     def date(self):</font>
<font color="red">  33.         return date(self.year, self.month, self.day)</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. class time(real_time):</font>
<font color="green">  37.     pass</font>
<font color="black">  38. </font>
<font color="black">  39. </font>
<font color="green">  40. def new_date(d):</font>
<font color="black">  41.     &quot;Generate a safe date from a datetime.date object.&quot;</font>
<font color="red">  42.     return date(d.year, d.month, d.day)</font>
<font color="black">  43. </font>
<font color="black">  44. </font>
<font color="green">  45. def new_datetime(d):</font>
<font color="black">  46.     &quot;&quot;&quot;</font>
<font color="black">  47.     Generate a safe datetime from a datetime.date or datetime.datetime object.</font>
<font color="black">  48.     &quot;&quot;&quot;</font>
<font color="red">  49.     kw = [d.year, d.month, d.day]</font>
<font color="red">  50.     if isinstance(d, real_datetime):</font>
<font color="red">  51.         kw.extend([d.hour, d.minute, d.second, d.microsecond, d.tzinfo])</font>
<font color="red">  52.     return datetime(*kw)</font>
<font color="black">  53. </font>
<font color="black">  54. # This library does not support strftime's &quot;%s&quot; or &quot;%y&quot; format strings.</font>
<font color="black">  55. # Allowed if there's an even number of &quot;%&quot;s because they are escaped.</font>
<font color="green">  56. _illegal_formatting = re.compile(r&quot;((^|[^%])(%%)*%[sy])&quot;)</font>
<font color="black">  57. </font>
<font color="black">  58. </font>
<font color="green">  59. def _findall(text, substr):</font>
<font color="black">  60.     # Also finds overlaps</font>
<font color="red">  61.     sites = []</font>
<font color="red">  62.     i = 0</font>
<font color="red">  63.     while 1:</font>
<font color="red">  64.         j = text.find(substr, i)</font>
<font color="red">  65.         if j == -1:</font>
<font color="red">  66.             break</font>
<font color="red">  67.         sites.append(j)</font>
<font color="red">  68.         i = j + 1</font>
<font color="red">  69.     return sites</font>
<font color="black">  70. </font>
<font color="black">  71. </font>
<font color="green">  72. def strftime(dt, fmt):</font>
<font color="red">  73.     if dt.year &gt;= 1900:</font>
<font color="red">  74.         return super(type(dt), dt).strftime(fmt)</font>
<font color="red">  75.     illegal_formatting = _illegal_formatting.search(fmt)</font>
<font color="red">  76.     if illegal_formatting:</font>
<font color="red">  77.         raise TypeError(&quot;strftime of dates before 1900 does not handle&quot; + illegal_formatting.group(0))</font>
<font color="black">  78. </font>
<font color="red">  79.     year = dt.year</font>
<font color="black">  80.     # For every non-leap year century, advance by</font>
<font color="black">  81.     # 6 years to get into the 28-year repeat cycle</font>
<font color="red">  82.     delta = 2000 - year</font>
<font color="red">  83.     off = 6 * (delta // 100 + delta // 400)</font>
<font color="red">  84.     year = year + off</font>
<font color="black">  85. </font>
<font color="black">  86.     # Move to around the year 2000</font>
<font color="red">  87.     year = year + ((2000 - year) // 28) * 28</font>
<font color="red">  88.     timetuple = dt.timetuple()</font>
<font color="red">  89.     s1 = ttime.strftime(fmt, (year,) + timetuple[1:])</font>
<font color="red">  90.     sites1 = _findall(s1, str(year))</font>
<font color="black">  91. </font>
<font color="red">  92.     s2 = ttime.strftime(fmt, (year + 28,) + timetuple[1:])</font>
<font color="red">  93.     sites2 = _findall(s2, str(year + 28))</font>
<font color="black">  94. </font>
<font color="red">  95.     sites = []</font>
<font color="red">  96.     for site in sites1:</font>
<font color="red">  97.         if site in sites2:</font>
<font color="red">  98.             sites.append(site)</font>
<font color="black">  99. </font>
<font color="red"> 100.     s = s1</font>
<font color="red"> 101.     syear = &quot;%04d&quot; % (dt.year,)</font>
<font color="red"> 102.     for site in sites:</font>
<font color="red"> 103.         s = s[:site] + syear + s[site + 4:]</font>
<font color="red"> 104.     return s</font>
</pre>

