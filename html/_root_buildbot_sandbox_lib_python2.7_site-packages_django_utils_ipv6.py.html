source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/ipv6.py</b><br>


file stats: <b>115 lines, 10 executed: 8.7% covered</b>
<pre>
<font color="black">   1. # This code was mostly based on ipaddr-py</font>
<font color="black">   2. # Copyright 2007 Google Inc. https://github.com/google/ipaddr-py</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).</font>
<font color="green">   4. from django.core.exceptions import ValidationError</font>
<font color="green">   5. from django.utils.six.moves import range</font>
<font color="green">   6. from django.utils.translation import ugettext_lazy as _</font>
<font color="black">   7. </font>
<font color="black">   8. </font>
<font color="green">   9. def clean_ipv6_address(ip_str, unpack_ipv4=False,</font>
<font color="green">  10.         error_message=_(&quot;This is not a valid IPv6 address.&quot;)):</font>
<font color="black">  11.     &quot;&quot;&quot;</font>
<font color="black">  12.     Cleans an IPv6 address string.</font>
<font color="black">  13. </font>
<font color="black">  14.     Validity is checked by calling is_valid_ipv6_address() - if an</font>
<font color="black">  15.     invalid address is passed, ValidationError is raised.</font>
<font color="black">  16. </font>
<font color="black">  17.     Replaces the longest continuous zero-sequence with &quot;::&quot; and</font>
<font color="black">  18.     removes leading zeroes and makes sure all hextets are lowercase.</font>
<font color="black">  19. </font>
<font color="black">  20.     Args:</font>
<font color="black">  21.         ip_str: A valid IPv6 address.</font>
<font color="black">  22.         unpack_ipv4: if an IPv4-mapped address is found,</font>
<font color="black">  23.         return the plain IPv4 address (default=False).</font>
<font color="black">  24.         error_message: An error message used in the ValidationError.</font>
<font color="black">  25. </font>
<font color="black">  26.     Returns:</font>
<font color="black">  27.         A compressed IPv6 address, or the same value</font>
<font color="black">  28.     &quot;&quot;&quot;</font>
<font color="red">  29.     best_doublecolon_start = -1</font>
<font color="red">  30.     best_doublecolon_len = 0</font>
<font color="red">  31.     doublecolon_start = -1</font>
<font color="red">  32.     doublecolon_len = 0</font>
<font color="black">  33. </font>
<font color="red">  34.     if not is_valid_ipv6_address(ip_str):</font>
<font color="red">  35.         raise ValidationError(error_message, code='invalid')</font>
<font color="black">  36. </font>
<font color="black">  37.     # This algorithm can only handle fully exploded</font>
<font color="black">  38.     # IP strings</font>
<font color="red">  39.     ip_str = _explode_shorthand_ip_string(ip_str)</font>
<font color="black">  40. </font>
<font color="red">  41.     ip_str = _sanitize_ipv4_mapping(ip_str)</font>
<font color="black">  42. </font>
<font color="black">  43.     # If needed, unpack the IPv4 and return straight away</font>
<font color="black">  44.     # - no need in running the rest of the algorithm</font>
<font color="red">  45.     if unpack_ipv4:</font>
<font color="red">  46.         ipv4_unpacked = _unpack_ipv4(ip_str)</font>
<font color="black">  47. </font>
<font color="red">  48.         if ipv4_unpacked:</font>
<font color="red">  49.             return ipv4_unpacked</font>
<font color="black">  50. </font>
<font color="red">  51.     hextets = ip_str.split(&quot;:&quot;)</font>
<font color="black">  52. </font>
<font color="red">  53.     for index in range(len(hextets)):</font>
<font color="black">  54.         # Remove leading zeroes</font>
<font color="red">  55.         hextets[index] = hextets[index].lstrip('0')</font>
<font color="red">  56.         if not hextets[index]:</font>
<font color="red">  57.             hextets[index] = '0'</font>
<font color="black">  58. </font>
<font color="black">  59.         # Determine best hextet to compress</font>
<font color="red">  60.         if hextets[index] == '0':</font>
<font color="red">  61.             doublecolon_len += 1</font>
<font color="red">  62.             if doublecolon_start == -1:</font>
<font color="black">  63.                 # Start of a sequence of zeros.</font>
<font color="red">  64.                 doublecolon_start = index</font>
<font color="red">  65.             if doublecolon_len &gt; best_doublecolon_len:</font>
<font color="black">  66.                 # This is the longest sequence of zeros so far.</font>
<font color="red">  67.                 best_doublecolon_len = doublecolon_len</font>
<font color="red">  68.                 best_doublecolon_start = doublecolon_start</font>
<font color="black">  69.         else:</font>
<font color="red">  70.             doublecolon_len = 0</font>
<font color="red">  71.             doublecolon_start = -1</font>
<font color="black">  72. </font>
<font color="black">  73.     # Compress the most suitable hextet</font>
<font color="red">  74.     if best_doublecolon_len &gt; 1:</font>
<font color="red">  75.         best_doublecolon_end = (best_doublecolon_start +</font>
<font color="red">  76.                                 best_doublecolon_len)</font>
<font color="black">  77.         # For zeros at the end of the address.</font>
<font color="red">  78.         if best_doublecolon_end == len(hextets):</font>
<font color="red">  79.             hextets += ['']</font>
<font color="red">  80.         hextets[best_doublecolon_start:best_doublecolon_end] = ['']</font>
<font color="black">  81.         # For zeros at the beginning of the address.</font>
<font color="red">  82.         if best_doublecolon_start == 0:</font>
<font color="red">  83.             hextets = [''] + hextets</font>
<font color="black">  84. </font>
<font color="red">  85.     result = &quot;:&quot;.join(hextets)</font>
<font color="black">  86. </font>
<font color="red">  87.     return result.lower()</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="green">  90. def _sanitize_ipv4_mapping(ip_str):</font>
<font color="black">  91.     &quot;&quot;&quot;</font>
<font color="black">  92.     Sanitize IPv4 mapping in an expanded IPv6 address.</font>
<font color="black">  93. </font>
<font color="black">  94.     This converts ::ffff:0a0a:0a0a to ::ffff:10.10.10.10.</font>
<font color="black">  95.     If there is nothing to sanitize, returns an unchanged</font>
<font color="black">  96.     string.</font>
<font color="black">  97. </font>
<font color="black">  98.     Args:</font>
<font color="black">  99.         ip_str: A string, the expanded IPv6 address.</font>
<font color="black"> 100. </font>
<font color="black"> 101.     Returns:</font>
<font color="black"> 102.         The sanitized output string, if applicable.</font>
<font color="black"> 103.     &quot;&quot;&quot;</font>
<font color="red"> 104.     if not ip_str.lower().startswith('0000:0000:0000:0000:0000:ffff:'):</font>
<font color="black"> 105.         # not an ipv4 mapping</font>
<font color="red"> 106.         return ip_str</font>
<font color="black"> 107. </font>
<font color="red"> 108.     hextets = ip_str.split(':')</font>
<font color="black"> 109. </font>
<font color="red"> 110.     if '.' in hextets[-1]:</font>
<font color="black"> 111.         # already sanitized</font>
<font color="red"> 112.         return ip_str</font>
<font color="black"> 113. </font>
<font color="red"> 114.     ipv4_address = &quot;%d.%d.%d.%d&quot; % (</font>
<font color="red"> 115.         int(hextets[6][0:2], 16),</font>
<font color="red"> 116.         int(hextets[6][2:4], 16),</font>
<font color="red"> 117.         int(hextets[7][0:2], 16),</font>
<font color="red"> 118.         int(hextets[7][2:4], 16),</font>
<font color="black"> 119.     )</font>
<font color="black"> 120. </font>
<font color="red"> 121.     result = ':'.join(hextets[0:6])</font>
<font color="red"> 122.     result += ':' + ipv4_address</font>
<font color="black"> 123. </font>
<font color="red"> 124.     return result</font>
<font color="black"> 125. </font>
<font color="black"> 126. </font>
<font color="green"> 127. def _unpack_ipv4(ip_str):</font>
<font color="black"> 128.     &quot;&quot;&quot;</font>
<font color="black"> 129.     Unpack an IPv4 address that was mapped in a compressed IPv6 address.</font>
<font color="black"> 130. </font>
<font color="black"> 131.     This converts 0000:0000:0000:0000:0000:ffff:10.10.10.10 to 10.10.10.10.</font>
<font color="black"> 132.     If there is nothing to sanitize, returns None.</font>
<font color="black"> 133. </font>
<font color="black"> 134.     Args:</font>
<font color="black"> 135.         ip_str: A string, the expanded IPv6 address.</font>
<font color="black"> 136. </font>
<font color="black"> 137.     Returns:</font>
<font color="black"> 138.         The unpacked IPv4 address, or None if there was nothing to unpack.</font>
<font color="black"> 139.     &quot;&quot;&quot;</font>
<font color="red"> 140.     if not ip_str.lower().startswith('0000:0000:0000:0000:0000:ffff:'):</font>
<font color="red"> 141.         return None</font>
<font color="black"> 142. </font>
<font color="red"> 143.     return ip_str.rsplit(':', 1)[1]</font>
<font color="black"> 144. </font>
<font color="black"> 145. </font>
<font color="green"> 146. def is_valid_ipv6_address(ip_str):</font>
<font color="black"> 147.     &quot;&quot;&quot;</font>
<font color="black"> 148.     Ensure we have a valid IPv6 address.</font>
<font color="black"> 149. </font>
<font color="black"> 150.     Args:</font>
<font color="black"> 151.         ip_str: A string, the IPv6 address.</font>
<font color="black"> 152. </font>
<font color="black"> 153.     Returns:</font>
<font color="black"> 154.         A boolean, True if this is a valid IPv6 address.</font>
<font color="black"> 155.     &quot;&quot;&quot;</font>
<font color="red"> 156.     from django.core.validators import validate_ipv4_address</font>
<font color="black"> 157. </font>
<font color="black"> 158.     # We need to have at least one ':'.</font>
<font color="red"> 159.     if ':' not in ip_str:</font>
<font color="red"> 160.         return False</font>
<font color="black"> 161. </font>
<font color="black"> 162.     # We can only have one '::' shortener.</font>
<font color="red"> 163.     if ip_str.count('::') &gt; 1:</font>
<font color="red"> 164.         return False</font>
<font color="black"> 165. </font>
<font color="black"> 166.     # '::' should be encompassed by start, digits or end.</font>
<font color="red"> 167.     if ':::' in ip_str:</font>
<font color="red"> 168.         return False</font>
<font color="black"> 169. </font>
<font color="black"> 170.     # A single colon can neither start nor end an address.</font>
<font color="red"> 171.     if ((ip_str.startswith(':') and not ip_str.startswith('::')) or</font>
<font color="red"> 172.             (ip_str.endswith(':') and not ip_str.endswith('::'))):</font>
<font color="red"> 173.         return False</font>
<font color="black"> 174. </font>
<font color="black"> 175.     # We can never have more than 7 ':' (1::2:3:4:5:6:7:8 is invalid)</font>
<font color="red"> 176.     if ip_str.count(':') &gt; 7:</font>
<font color="red"> 177.         return False</font>
<font color="black"> 178. </font>
<font color="black"> 179.     # If we have no concatenation, we need to have 8 fields with 7 ':'.</font>
<font color="red"> 180.     if '::' not in ip_str and ip_str.count(':') != 7:</font>
<font color="black"> 181.         # We might have an IPv4 mapped address.</font>
<font color="red"> 182.         if ip_str.count('.') != 3:</font>
<font color="red"> 183.             return False</font>
<font color="black"> 184. </font>
<font color="red"> 185.     ip_str = _explode_shorthand_ip_string(ip_str)</font>
<font color="black"> 186. </font>
<font color="black"> 187.     # Now that we have that all squared away, let's check that each of the</font>
<font color="black"> 188.     # hextets are between 0x0 and 0xFFFF.</font>
<font color="red"> 189.     for hextet in ip_str.split(':'):</font>
<font color="red"> 190.         if hextet.count('.') == 3:</font>
<font color="black"> 191.             # If we have an IPv4 mapped address, the IPv4 portion has to</font>
<font color="black"> 192.             # be at the end of the IPv6 portion.</font>
<font color="red"> 193.             if not ip_str.split(':')[-1] == hextet:</font>
<font color="red"> 194.                 return False</font>
<font color="red"> 195.             try:</font>
<font color="red"> 196.                 validate_ipv4_address(hextet)</font>
<font color="red"> 197.             except ValidationError:</font>
<font color="red"> 198.                 return False</font>
<font color="black"> 199.         else:</font>
<font color="red"> 200.             try:</font>
<font color="black"> 201.                 # a value error here means that we got a bad hextet,</font>
<font color="black"> 202.                 # something like 0xzzzz</font>
<font color="red"> 203.                 if int(hextet, 16) &lt; 0x0 or int(hextet, 16) &gt; 0xFFFF:</font>
<font color="red"> 204.                     return False</font>
<font color="red"> 205.             except ValueError:</font>
<font color="red"> 206.                 return False</font>
<font color="red"> 207.     return True</font>
<font color="black"> 208. </font>
<font color="black"> 209. </font>
<font color="green"> 210. def _explode_shorthand_ip_string(ip_str):</font>
<font color="black"> 211.     &quot;&quot;&quot;</font>
<font color="black"> 212.     Expand a shortened IPv6 address.</font>
<font color="black"> 213. </font>
<font color="black"> 214.     Args:</font>
<font color="black"> 215.         ip_str: A string, the IPv6 address.</font>
<font color="black"> 216. </font>
<font color="black"> 217.     Returns:</font>
<font color="black"> 218.         A string, the expanded IPv6 address.</font>
<font color="black"> 219.     &quot;&quot;&quot;</font>
<font color="red"> 220.     if not _is_shorthand_ip(ip_str):</font>
<font color="black"> 221.         # We've already got a longhand ip_str.</font>
<font color="red"> 222.         return ip_str</font>
<font color="black"> 223. </font>
<font color="red"> 224.     new_ip = []</font>
<font color="red"> 225.     hextet = ip_str.split('::')</font>
<font color="black"> 226. </font>
<font color="black"> 227.     # If there is a ::, we need to expand it with zeroes</font>
<font color="black"> 228.     # to get to 8 hextets - unless there is a dot in the last hextet,</font>
<font color="black"> 229.     # meaning we're doing v4-mapping</font>
<font color="red"> 230.     if '.' in ip_str.split(':')[-1]:</font>
<font color="red"> 231.         fill_to = 7</font>
<font color="black"> 232.     else:</font>
<font color="red"> 233.         fill_to = 8</font>
<font color="black"> 234. </font>
<font color="red"> 235.     if len(hextet) &gt; 1:</font>
<font color="red"> 236.         sep = len(hextet[0].split(':')) + len(hextet[1].split(':'))</font>
<font color="red"> 237.         new_ip = hextet[0].split(':')</font>
<font color="black"> 238. </font>
<font color="red"> 239.         for __ in range(fill_to - sep):</font>
<font color="red"> 240.             new_ip.append('0000')</font>
<font color="red"> 241.         new_ip += hextet[1].split(':')</font>
<font color="black"> 242. </font>
<font color="black"> 243.     else:</font>
<font color="red"> 244.         new_ip = ip_str.split(':')</font>
<font color="black"> 245. </font>
<font color="black"> 246.     # Now need to make sure every hextet is 4 lower case characters.</font>
<font color="black"> 247.     # If a hextet is &lt; 4 characters, we've got missing leading 0's.</font>
<font color="red"> 248.     ret_ip = []</font>
<font color="red"> 249.     for hextet in new_ip:</font>
<font color="red"> 250.         ret_ip.append(('0' * (4 - len(hextet)) + hextet).lower())</font>
<font color="red"> 251.     return ':'.join(ret_ip)</font>
<font color="black"> 252. </font>
<font color="black"> 253. </font>
<font color="green"> 254. def _is_shorthand_ip(ip_str):</font>
<font color="black"> 255.     &quot;&quot;&quot;Determine if the address is shortened.</font>
<font color="black"> 256. </font>
<font color="black"> 257.     Args:</font>
<font color="black"> 258.         ip_str: A string, the IPv6 address.</font>
<font color="black"> 259. </font>
<font color="black"> 260.     Returns:</font>
<font color="black"> 261.         A boolean, True if the address is shortened.</font>
<font color="black"> 262.     &quot;&quot;&quot;</font>
<font color="red"> 263.     if ip_str.count('::') == 1:</font>
<font color="red"> 264.         return True</font>
<font color="red"> 265.     if any(len(x) &lt; 4 for x in ip_str.split(':')):</font>
<font color="red"> 266.         return True</font>
<font color="red"> 267.     return False</font>
</pre>

