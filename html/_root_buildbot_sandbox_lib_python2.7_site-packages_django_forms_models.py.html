source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/forms/models.py</b><br>


file stats: <b>805 lines, 219 executed: 27.2% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Helper functions for creating Form classes from Django models</font>
<font color="black">   3. and database field objects.</font>
<font color="green">   4. &quot;&quot;&quot;</font>
<font color="black">   5. </font>
<font color="green">   6. from __future__ import unicode_literals</font>
<font color="black">   7. </font>
<font color="green">   8. from collections import OrderedDict</font>
<font color="green">   9. from itertools import chain</font>
<font color="black">  10. </font>
<font color="green">  11. from django.core.exceptions import (</font>
<font color="black">  12.     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,</font>
<font color="black">  13. )</font>
<font color="green">  14. from django.forms.fields import ChoiceField, Field</font>
<font color="green">  15. from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass</font>
<font color="green">  16. from django.forms.formsets import BaseFormSet, formset_factory</font>
<font color="green">  17. from django.forms.utils import ErrorList</font>
<font color="green">  18. from django.forms.widgets import (</font>
<font color="black">  19.     HiddenInput, MultipleHiddenInput, SelectMultiple,</font>
<font color="black">  20. )</font>
<font color="green">  21. from django.utils import six</font>
<font color="green">  22. from django.utils.encoding import force_text, smart_text</font>
<font color="green">  23. from django.utils.text import capfirst, get_text_list</font>
<font color="green">  24. from django.utils.translation import ugettext, ugettext_lazy as _</font>
<font color="black">  25. </font>
<font color="black">  26. __all__ = (</font>
<font color="green">  27.     'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model',</font>
<font color="green">  28.     'ModelChoiceField', 'ModelMultipleChoiceField', 'ALL_FIELDS',</font>
<font color="green">  29.     'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',</font>
<font color="green">  30.     'inlineformset_factory', 'modelform_factory',</font>
<font color="black">  31. )</font>
<font color="black">  32. </font>
<font color="green">  33. ALL_FIELDS = '__all__'</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. def construct_instance(form, instance, fields=None, exclude=None):</font>
<font color="black">  37.     &quot;&quot;&quot;</font>
<font color="black">  38.     Constructs and returns a model instance from the bound ``form``'s</font>
<font color="black">  39.     ``cleaned_data``, but does not save the returned instance to the</font>
<font color="black">  40.     database.</font>
<font color="black">  41.     &quot;&quot;&quot;</font>
<font color="red">  42.     from django.db import models</font>
<font color="red">  43.     opts = instance._meta</font>
<font color="black">  44. </font>
<font color="red">  45.     cleaned_data = form.cleaned_data</font>
<font color="red">  46.     file_field_list = []</font>
<font color="red">  47.     for f in opts.fields:</font>
<font color="red">  48.         if not f.editable or isinstance(f, models.AutoField) \</font>
<font color="red">  49.                 or f.name not in cleaned_data:</font>
<font color="red">  50.             continue</font>
<font color="red">  51.         if fields is not None and f.name not in fields:</font>
<font color="red">  52.             continue</font>
<font color="red">  53.         if exclude and f.name in exclude:</font>
<font color="red">  54.             continue</font>
<font color="black">  55.         # Defer saving file-type fields until after the other fields, so a</font>
<font color="black">  56.         # callable upload_to can use the values from other fields.</font>
<font color="red">  57.         if isinstance(f, models.FileField):</font>
<font color="red">  58.             file_field_list.append(f)</font>
<font color="black">  59.         else:</font>
<font color="red">  60.             f.save_form_data(instance, cleaned_data[f.name])</font>
<font color="black">  61. </font>
<font color="red">  62.     for f in file_field_list:</font>
<font color="red">  63.         f.save_form_data(instance, cleaned_data[f.name])</font>
<font color="black">  64. </font>
<font color="red">  65.     return instance</font>
<font color="black">  66. </font>
<font color="black">  67. </font>
<font color="black">  68. # ModelForms #################################################################</font>
<font color="black">  69. </font>
<font color="green">  70. def model_to_dict(instance, fields=None, exclude=None):</font>
<font color="black">  71.     &quot;&quot;&quot;</font>
<font color="black">  72.     Returns a dict containing the data in ``instance`` suitable for passing as</font>
<font color="black">  73.     a Form's ``initial`` keyword argument.</font>
<font color="black">  74. </font>
<font color="black">  75.     ``fields`` is an optional list of field names. If provided, only the named</font>
<font color="black">  76.     fields will be included in the returned dict.</font>
<font color="black">  77. </font>
<font color="black">  78.     ``exclude`` is an optional list of field names. If provided, the named</font>
<font color="black">  79.     fields will be excluded from the returned dict, even if they are listed in</font>
<font color="black">  80.     the ``fields`` argument.</font>
<font color="black">  81.     &quot;&quot;&quot;</font>
<font color="black">  82.     # avoid a circular import</font>
<font color="red">  83.     from django.db.models.fields.related import ManyToManyField</font>
<font color="red">  84.     opts = instance._meta</font>
<font color="red">  85.     data = {}</font>
<font color="red">  86.     for f in chain(opts.concrete_fields, opts.virtual_fields, opts.many_to_many):</font>
<font color="red">  87.         if not getattr(f, 'editable', False):</font>
<font color="red">  88.             continue</font>
<font color="red">  89.         if fields and f.name not in fields:</font>
<font color="red">  90.             continue</font>
<font color="red">  91.         if exclude and f.name in exclude:</font>
<font color="red">  92.             continue</font>
<font color="red">  93.         if isinstance(f, ManyToManyField):</font>
<font color="black">  94.             # If the object doesn't have a primary key yet, just use an empty</font>
<font color="black">  95.             # list for its m2m fields. Calling f.value_from_object will raise</font>
<font color="black">  96.             # an exception.</font>
<font color="red">  97.             if instance.pk is None:</font>
<font color="red">  98.                 data[f.name] = []</font>
<font color="black">  99.             else:</font>
<font color="black"> 100.                 # MultipleChoiceWidget needs a list of pks, not object instances.</font>
<font color="red"> 101.                 qs = f.value_from_object(instance)</font>
<font color="red"> 102.                 if qs._result_cache is not None:</font>
<font color="red"> 103.                     data[f.name] = [item.pk for item in qs]</font>
<font color="black"> 104.                 else:</font>
<font color="red"> 105.                     data[f.name] = list(qs.values_list('pk', flat=True))</font>
<font color="black"> 106.         else:</font>
<font color="red"> 107.             data[f.name] = f.value_from_object(instance)</font>
<font color="red"> 108.     return data</font>
<font color="black"> 109. </font>
<font color="black"> 110. </font>
<font color="green"> 111. def fields_for_model(model, fields=None, exclude=None, widgets=None,</font>
<font color="green"> 112.                      formfield_callback=None, localized_fields=None,</font>
<font color="green"> 113.                      labels=None, help_texts=None, error_messages=None,</font>
<font color="green"> 114.                      field_classes=None):</font>
<font color="black"> 115.     &quot;&quot;&quot;</font>
<font color="black"> 116.     Returns a ``OrderedDict`` containing form fields for the given model.</font>
<font color="black"> 117. </font>
<font color="black"> 118.     ``fields`` is an optional list of field names. If provided, only the named</font>
<font color="black"> 119.     fields will be included in the returned fields.</font>
<font color="black"> 120. </font>
<font color="black"> 121.     ``exclude`` is an optional list of field names. If provided, the named</font>
<font color="black"> 122.     fields will be excluded from the returned fields, even if they are listed</font>
<font color="black"> 123.     in the ``fields`` argument.</font>
<font color="black"> 124. </font>
<font color="black"> 125.     ``widgets`` is a dictionary of model field names mapped to a widget.</font>
<font color="black"> 126. </font>
<font color="black"> 127.     ``formfield_callback`` is a callable that takes a model field and returns</font>
<font color="black"> 128.     a form field.</font>
<font color="black"> 129. </font>
<font color="black"> 130.     ``localized_fields`` is a list of names of fields which should be localized.</font>
<font color="black"> 131. </font>
<font color="black"> 132.     ``labels`` is a dictionary of model field names mapped to a label.</font>
<font color="black"> 133. </font>
<font color="black"> 134.     ``help_texts`` is a dictionary of model field names mapped to a help text.</font>
<font color="black"> 135. </font>
<font color="black"> 136.     ``error_messages`` is a dictionary of model field names mapped to a</font>
<font color="black"> 137.     dictionary of error messages.</font>
<font color="black"> 138. </font>
<font color="black"> 139.     ``field_classes`` is a dictionary of model field names mapped to a form</font>
<font color="black"> 140.     field class.</font>
<font color="black"> 141.     &quot;&quot;&quot;</font>
<font color="green"> 142.     field_list = []</font>
<font color="green"> 143.     ignored = []</font>
<font color="green"> 144.     opts = model._meta</font>
<font color="black"> 145.     # Avoid circular import</font>
<font color="green"> 146.     from django.db.models.fields import Field as ModelField</font>
<font color="green"> 147.     sortable_virtual_fields = [f for f in opts.virtual_fields</font>
<font color="red"> 148.                                if isinstance(f, ModelField)]</font>
<font color="green"> 149.     for f in sorted(chain(opts.concrete_fields, sortable_virtual_fields, opts.many_to_many)):</font>
<font color="green"> 150.         if not getattr(f, 'editable', False):</font>
<font color="red"> 151.             continue</font>
<font color="green"> 152.         if fields is not None and f.name not in fields:</font>
<font color="green"> 153.             continue</font>
<font color="green"> 154.         if exclude and f.name in exclude:</font>
<font color="red"> 155.             continue</font>
<font color="black"> 156. </font>
<font color="green"> 157.         kwargs = {}</font>
<font color="green"> 158.         if widgets and f.name in widgets:</font>
<font color="red"> 159.             kwargs['widget'] = widgets[f.name]</font>
<font color="green"> 160.         if localized_fields == ALL_FIELDS or (localized_fields and f.name in localized_fields):</font>
<font color="red"> 161.             kwargs['localize'] = True</font>
<font color="green"> 162.         if labels and f.name in labels:</font>
<font color="red"> 163.             kwargs['label'] = labels[f.name]</font>
<font color="green"> 164.         if help_texts and f.name in help_texts:</font>
<font color="red"> 165.             kwargs['help_text'] = help_texts[f.name]</font>
<font color="green"> 166.         if error_messages and f.name in error_messages:</font>
<font color="red"> 167.             kwargs['error_messages'] = error_messages[f.name]</font>
<font color="green"> 168.         if field_classes and f.name in field_classes:</font>
<font color="red"> 169.             kwargs['form_class'] = field_classes[f.name]</font>
<font color="black"> 170. </font>
<font color="green"> 171.         if formfield_callback is None:</font>
<font color="green"> 172.             formfield = f.formfield(**kwargs)</font>
<font color="red"> 173.         elif not callable(formfield_callback):</font>
<font color="red"> 174.             raise TypeError('formfield_callback must be a function or callable')</font>
<font color="black"> 175.         else:</font>
<font color="red"> 176.             formfield = formfield_callback(f, **kwargs)</font>
<font color="black"> 177. </font>
<font color="green"> 178.         if formfield:</font>
<font color="green"> 179.             field_list.append((f.name, formfield))</font>
<font color="black"> 180.         else:</font>
<font color="green"> 181.             ignored.append(f.name)</font>
<font color="green"> 182.     field_dict = OrderedDict(field_list)</font>
<font color="green"> 183.     if fields:</font>
<font color="green"> 184.         field_dict = OrderedDict(</font>
<font color="green"> 185.             [(f, field_dict.get(f)) for f in fields</font>
<font color="green"> 186.                 if ((not exclude) or (exclude and f not in exclude)) and (f not in ignored)]</font>
<font color="black"> 187.         )</font>
<font color="green"> 188.     return field_dict</font>
<font color="black"> 189. </font>
<font color="black"> 190. </font>
<font color="green"> 191. class ModelFormOptions(object):</font>
<font color="green"> 192.     def __init__(self, options=None):</font>
<font color="green"> 193.         self.model = getattr(options, 'model', None)</font>
<font color="green"> 194.         self.fields = getattr(options, 'fields', None)</font>
<font color="green"> 195.         self.exclude = getattr(options, 'exclude', None)</font>
<font color="green"> 196.         self.widgets = getattr(options, 'widgets', None)</font>
<font color="green"> 197.         self.localized_fields = getattr(options, 'localized_fields', None)</font>
<font color="green"> 198.         self.labels = getattr(options, 'labels', None)</font>
<font color="green"> 199.         self.help_texts = getattr(options, 'help_texts', None)</font>
<font color="green"> 200.         self.error_messages = getattr(options, 'error_messages', None)</font>
<font color="green"> 201.         self.field_classes = getattr(options, 'field_classes', None)</font>
<font color="black"> 202. </font>
<font color="black"> 203. </font>
<font color="green"> 204. class ModelFormMetaclass(DeclarativeFieldsMetaclass):</font>
<font color="green"> 205.     def __new__(mcs, name, bases, attrs):</font>
<font color="green"> 206.         formfield_callback = attrs.pop('formfield_callback', None)</font>
<font color="black"> 207. </font>
<font color="green"> 208.         new_class = super(ModelFormMetaclass, mcs).__new__(mcs, name, bases, attrs)</font>
<font color="black"> 209. </font>
<font color="green"> 210.         if bases == (BaseModelForm,):</font>
<font color="green"> 211.             return new_class</font>
<font color="black"> 212. </font>
<font color="green"> 213.         opts = new_class._meta = ModelFormOptions(getattr(new_class, 'Meta', None))</font>
<font color="black"> 214. </font>
<font color="black"> 215.         # We check if a string was passed to `fields` or `exclude`,</font>
<font color="black"> 216.         # which is likely to be a mistake where the user typed ('foo') instead</font>
<font color="black"> 217.         # of ('foo',)</font>
<font color="green"> 218.         for opt in ['fields', 'exclude', 'localized_fields']:</font>
<font color="green"> 219.             value = getattr(opts, opt)</font>
<font color="green"> 220.             if isinstance(value, six.string_types) and value != ALL_FIELDS:</font>
<font color="red"> 221.                 msg = (&quot;%(model)s.Meta.%(opt)s cannot be a string. &quot;</font>
<font color="red"> 222.                        &quot;Did you mean to type: ('%(value)s',)?&quot; % {</font>
<font color="red"> 223.                            'model': new_class.__name__,</font>
<font color="red"> 224.                            'opt': opt,</font>
<font color="red"> 225.                            'value': value,</font>
<font color="black"> 226.                        })</font>
<font color="red"> 227.                 raise TypeError(msg)</font>
<font color="black"> 228. </font>
<font color="green"> 229.         if opts.model:</font>
<font color="black"> 230.             # If a model is defined, extract form fields from it.</font>
<font color="green"> 231.             if opts.fields is None and opts.exclude is None:</font>
<font color="red"> 232.                 raise ImproperlyConfigured(</font>
<font color="red"> 233.                     &quot;Creating a ModelForm without either the 'fields' attribute &quot;</font>
<font color="black"> 234.                     &quot;or the 'exclude' attribute is prohibited; form %s &quot;</font>
<font color="red"> 235.                     &quot;needs updating.&quot; % name</font>
<font color="black"> 236.                 )</font>
<font color="black"> 237. </font>
<font color="green"> 238.             if opts.fields == ALL_FIELDS:</font>
<font color="black"> 239.                 # Sentinel for fields_for_model to indicate &quot;get the list of</font>
<font color="black"> 240.                 # fields from the model&quot;</font>
<font color="green"> 241.                 opts.fields = None</font>
<font color="black"> 242. </font>
<font color="green"> 243.             fields = fields_for_model(opts.model, opts.fields, opts.exclude,</font>
<font color="green"> 244.                                       opts.widgets, formfield_callback,</font>
<font color="green"> 245.                                       opts.localized_fields, opts.labels,</font>
<font color="green"> 246.                                       opts.help_texts, opts.error_messages,</font>
<font color="green"> 247.                                       opts.field_classes)</font>
<font color="black"> 248. </font>
<font color="black"> 249.             # make sure opts.fields doesn't specify an invalid field</font>
<font color="green"> 250.             none_model_fields = [k for k, v in six.iteritems(fields) if not v]</font>
<font color="green"> 251.             missing_fields = (set(none_model_fields) -</font>
<font color="green"> 252.                               set(new_class.declared_fields.keys()))</font>
<font color="green"> 253.             if missing_fields:</font>
<font color="red"> 254.                 message = 'Unknown field(s) (%s) specified for %s'</font>
<font color="red"> 255.                 message = message % (', '.join(missing_fields),</font>
<font color="red"> 256.                                      opts.model.__name__)</font>
<font color="red"> 257.                 raise FieldError(message)</font>
<font color="black"> 258.             # Override default model fields with any custom declared ones</font>
<font color="black"> 259.             # (plus, include all the other declared fields).</font>
<font color="green"> 260.             fields.update(new_class.declared_fields)</font>
<font color="black"> 261.         else:</font>
<font color="red"> 262.             fields = new_class.declared_fields</font>
<font color="black"> 263. </font>
<font color="green"> 264.         new_class.base_fields = fields</font>
<font color="black"> 265. </font>
<font color="green"> 266.         return new_class</font>
<font color="black"> 267. </font>
<font color="black"> 268. </font>
<font color="green"> 269. class BaseModelForm(BaseForm):</font>
<font color="green"> 270.     def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,</font>
<font color="green"> 271.                  initial=None, error_class=ErrorList, label_suffix=None,</font>
<font color="green"> 272.                  empty_permitted=False, instance=None):</font>
<font color="red"> 273.         opts = self._meta</font>
<font color="red"> 274.         if opts.model is None:</font>
<font color="red"> 275.             raise ValueError('ModelForm has no model class specified.')</font>
<font color="red"> 276.         if instance is None:</font>
<font color="black"> 277.             # if we didn't get an instance, instantiate a new one</font>
<font color="red"> 278.             self.instance = opts.model()</font>
<font color="red"> 279.             object_data = {}</font>
<font color="black"> 280.         else:</font>
<font color="red"> 281.             self.instance = instance</font>
<font color="red"> 282.             object_data = model_to_dict(instance, opts.fields, opts.exclude)</font>
<font color="black"> 283.         # if initial was provided, it should override the values from instance</font>
<font color="red"> 284.         if initial is not None:</font>
<font color="red"> 285.             object_data.update(initial)</font>
<font color="black"> 286.         # self._validate_unique will be set to True by BaseModelForm.clean().</font>
<font color="black"> 287.         # It is False by default so overriding self.clean() and failing to call</font>
<font color="black"> 288.         # super will stop validate_unique from being called.</font>
<font color="red"> 289.         self._validate_unique = False</font>
<font color="red"> 290.         super(BaseModelForm, self).__init__(data, files, auto_id, prefix, object_data,</font>
<font color="red"> 291.                                             error_class, label_suffix, empty_permitted)</font>
<font color="black"> 292.         # Apply ``limit_choices_to`` to each field.</font>
<font color="red"> 293.         for field_name in self.fields:</font>
<font color="red"> 294.             formfield = self.fields[field_name]</font>
<font color="red"> 295.             if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):</font>
<font color="red"> 296.                 limit_choices_to = formfield.get_limit_choices_to()</font>
<font color="red"> 297.                 if limit_choices_to is not None:</font>
<font color="red"> 298.                     formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)</font>
<font color="black"> 299. </font>
<font color="green"> 300.     def _get_validation_exclusions(self):</font>
<font color="black"> 301.         &quot;&quot;&quot;</font>
<font color="black"> 302.         For backwards-compatibility, several types of fields need to be</font>
<font color="black"> 303.         excluded from model validation. See the following tickets for</font>
<font color="black"> 304.         details: #12507, #12521, #12553</font>
<font color="black"> 305.         &quot;&quot;&quot;</font>
<font color="red"> 306.         exclude = []</font>
<font color="black"> 307.         # Build up a list of fields that should be excluded from model field</font>
<font color="black"> 308.         # validation and unique checks.</font>
<font color="red"> 309.         for f in self.instance._meta.fields:</font>
<font color="red"> 310.             field = f.name</font>
<font color="black"> 311.             # Exclude fields that aren't on the form. The developer may be</font>
<font color="black"> 312.             # adding these values to the model after form validation.</font>
<font color="red"> 313.             if field not in self.fields:</font>
<font color="red"> 314.                 exclude.append(f.name)</font>
<font color="black"> 315. </font>
<font color="black"> 316.             # Don't perform model validation on fields that were defined</font>
<font color="black"> 317.             # manually on the form and excluded via the ModelForm's Meta</font>
<font color="black"> 318.             # class. See #12901.</font>
<font color="red"> 319.             elif self._meta.fields and field not in self._meta.fields:</font>
<font color="red"> 320.                 exclude.append(f.name)</font>
<font color="red"> 321.             elif self._meta.exclude and field in self._meta.exclude:</font>
<font color="red"> 322.                 exclude.append(f.name)</font>
<font color="black"> 323. </font>
<font color="black"> 324.             # Exclude fields that failed form validation. There's no need for</font>
<font color="black"> 325.             # the model fields to validate them as well.</font>
<font color="red"> 326.             elif field in self._errors.keys():</font>
<font color="red"> 327.                 exclude.append(f.name)</font>
<font color="black"> 328. </font>
<font color="black"> 329.             # Exclude empty fields that are not required by the form, if the</font>
<font color="black"> 330.             # underlying model field is required. This keeps the model field</font>
<font color="black"> 331.             # from raising a required error. Note: don't exclude the field from</font>
<font color="black"> 332.             # validation if the model field allows blanks. If it does, the blank</font>
<font color="black"> 333.             # value may be included in a unique check, so cannot be excluded</font>
<font color="black"> 334.             # from validation.</font>
<font color="black"> 335.             else:</font>
<font color="red"> 336.                 form_field = self.fields[field]</font>
<font color="red"> 337.                 field_value = self.cleaned_data.get(field)</font>
<font color="red"> 338.                 if not f.blank and not form_field.required and field_value in form_field.empty_values:</font>
<font color="red"> 339.                     exclude.append(f.name)</font>
<font color="red"> 340.         return exclude</font>
<font color="black"> 341. </font>
<font color="green"> 342.     def clean(self):</font>
<font color="red"> 343.         self._validate_unique = True</font>
<font color="red"> 344.         return self.cleaned_data</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def _update_errors(self, errors):</font>
<font color="black"> 347.         # Override any validation error messages defined at the model level</font>
<font color="black"> 348.         # with those defined at the form level.</font>
<font color="red"> 349.         opts = self._meta</font>
<font color="black"> 350. </font>
<font color="black"> 351.         # Allow the model generated by construct_instance() to raise</font>
<font color="black"> 352.         # ValidationError and have them handled in the same way as others.</font>
<font color="red"> 353.         if hasattr(errors, 'error_dict'):</font>
<font color="red"> 354.             error_dict = errors.error_dict</font>
<font color="black"> 355.         else:</font>
<font color="red"> 356.             error_dict = {NON_FIELD_ERRORS: errors}</font>
<font color="black"> 357. </font>
<font color="red"> 358.         for field, messages in error_dict.items():</font>
<font color="red"> 359.             if (field == NON_FIELD_ERRORS and opts.error_messages and</font>
<font color="red"> 360.                     NON_FIELD_ERRORS in opts.error_messages):</font>
<font color="red"> 361.                 error_messages = opts.error_messages[NON_FIELD_ERRORS]</font>
<font color="red"> 362.             elif field in self.fields:</font>
<font color="red"> 363.                 error_messages = self.fields[field].error_messages</font>
<font color="black"> 364.             else:</font>
<font color="red"> 365.                 continue</font>
<font color="black"> 366. </font>
<font color="red"> 367.             for message in messages:</font>
<font color="red"> 368.                 if (isinstance(message, ValidationError) and</font>
<font color="red"> 369.                         message.code in error_messages):</font>
<font color="red"> 370.                     message.message = error_messages[message.code]</font>
<font color="black"> 371. </font>
<font color="red"> 372.         self.add_error(None, errors)</font>
<font color="black"> 373. </font>
<font color="green"> 374.     def _post_clean(self):</font>
<font color="red"> 375.         opts = self._meta</font>
<font color="black"> 376. </font>
<font color="red"> 377.         exclude = self._get_validation_exclusions()</font>
<font color="black"> 378. </font>
<font color="red"> 379.         try:</font>
<font color="red"> 380.             self.instance = construct_instance(self, self.instance, opts.fields, exclude)</font>
<font color="red"> 381.         except ValidationError as e:</font>
<font color="red"> 382.             self._update_errors(e)</font>
<font color="black"> 383. </font>
<font color="black"> 384.         # Foreign Keys being used to represent inline relationships</font>
<font color="black"> 385.         # are excluded from basic field value validation. This is for two</font>
<font color="black"> 386.         # reasons: firstly, the value may not be supplied (#12507; the</font>
<font color="black"> 387.         # case of providing new values to the admin); secondly the</font>
<font color="black"> 388.         # object being referred to may not yet fully exist (#12749).</font>
<font color="black"> 389.         # However, these fields *must* be included in uniqueness checks,</font>
<font color="black"> 390.         # so this can't be part of _get_validation_exclusions().</font>
<font color="red"> 391.         for name, field in self.fields.items():</font>
<font color="red"> 392.             if isinstance(field, InlineForeignKeyField):</font>
<font color="red"> 393.                 exclude.append(name)</font>
<font color="black"> 394. </font>
<font color="red"> 395.         try:</font>
<font color="red"> 396.             self.instance.full_clean(exclude=exclude, validate_unique=False)</font>
<font color="red"> 397.         except ValidationError as e:</font>
<font color="red"> 398.             self._update_errors(e)</font>
<font color="black"> 399. </font>
<font color="black"> 400.         # Validate uniqueness if needed.</font>
<font color="red"> 401.         if self._validate_unique:</font>
<font color="red"> 402.             self.validate_unique()</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def validate_unique(self):</font>
<font color="black"> 405.         &quot;&quot;&quot;</font>
<font color="black"> 406.         Calls the instance's validate_unique() method and updates the form's</font>
<font color="black"> 407.         validation errors if any were raised.</font>
<font color="black"> 408.         &quot;&quot;&quot;</font>
<font color="red"> 409.         exclude = self._get_validation_exclusions()</font>
<font color="red"> 410.         try:</font>
<font color="red"> 411.             self.instance.validate_unique(exclude=exclude)</font>
<font color="red"> 412.         except ValidationError as e:</font>
<font color="red"> 413.             self._update_errors(e)</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def _save_m2m(self):</font>
<font color="black"> 416.         &quot;&quot;&quot;</font>
<font color="black"> 417.         Save the many-to-many fields and generic relations for this form.</font>
<font color="black"> 418.         &quot;&quot;&quot;</font>
<font color="red"> 419.         cleaned_data = self.cleaned_data</font>
<font color="red"> 420.         exclude = self._meta.exclude</font>
<font color="red"> 421.         fields = self._meta.fields</font>
<font color="red"> 422.         opts = self.instance._meta</font>
<font color="black"> 423.         # Note that for historical reasons we want to include also</font>
<font color="black"> 424.         # virtual_fields here. (GenericRelation was previously a fake</font>
<font color="black"> 425.         # m2m field).</font>
<font color="red"> 426.         for f in chain(opts.many_to_many, opts.virtual_fields):</font>
<font color="red"> 427.             if not hasattr(f, 'save_form_data'):</font>
<font color="red"> 428.                 continue</font>
<font color="red"> 429.             if fields and f.name not in fields:</font>
<font color="red"> 430.                 continue</font>
<font color="red"> 431.             if exclude and f.name in exclude:</font>
<font color="red"> 432.                 continue</font>
<font color="red"> 433.             if f.name in cleaned_data:</font>
<font color="red"> 434.                 f.save_form_data(self.instance, cleaned_data[f.name])</font>
<font color="black"> 435. </font>
<font color="green"> 436.     def save(self, commit=True):</font>
<font color="black"> 437.         &quot;&quot;&quot;</font>
<font color="black"> 438.         Save this form's self.instance object if commit=True. Otherwise, add</font>
<font color="black"> 439.         a save_m2m() method to the form which can be called after the instance</font>
<font color="black"> 440.         is saved manually at a later time. Return the model instance.</font>
<font color="black"> 441.         &quot;&quot;&quot;</font>
<font color="red"> 442.         if self.errors:</font>
<font color="red"> 443.             raise ValueError(</font>
<font color="red"> 444.                 &quot;The %s could not be %s because the data didn't validate.&quot; % (</font>
<font color="red"> 445.                     self.instance._meta.object_name,</font>
<font color="red"> 446.                     'created' if self.instance._state.adding else 'changed',</font>
<font color="black"> 447.                 )</font>
<font color="black"> 448.             )</font>
<font color="red"> 449.         if commit:</font>
<font color="black"> 450.             # If committing, save the instance and the m2m data immediately.</font>
<font color="red"> 451.             self.instance.save()</font>
<font color="red"> 452.             self._save_m2m()</font>
<font color="black"> 453.         else:</font>
<font color="black"> 454.             # If not committing, add a method to the form to allow deferred</font>
<font color="black"> 455.             # saving of m2m data.</font>
<font color="red"> 456.             self.save_m2m = self._save_m2m</font>
<font color="red"> 457.         return self.instance</font>
<font color="black"> 458. </font>
<font color="green"> 459.     save.alters_data = True</font>
<font color="black"> 460. </font>
<font color="black"> 461. </font>
<font color="green"> 462. class ModelForm(six.with_metaclass(ModelFormMetaclass, BaseModelForm)):</font>
<font color="green"> 463.     pass</font>
<font color="black"> 464. </font>
<font color="black"> 465. </font>
<font color="green"> 466. def modelform_factory(model, form=ModelForm, fields=None, exclude=None,</font>
<font color="green"> 467.                       formfield_callback=None, widgets=None, localized_fields=None,</font>
<font color="green"> 468.                       labels=None, help_texts=None, error_messages=None,</font>
<font color="green"> 469.                       field_classes=None):</font>
<font color="black"> 470.     &quot;&quot;&quot;</font>
<font color="black"> 471.     Returns a ModelForm containing form fields for the given model.</font>
<font color="black"> 472. </font>
<font color="black"> 473.     ``fields`` is an optional list of field names. If provided, only the named</font>
<font color="black"> 474.     fields will be included in the returned fields. If omitted or '__all__',</font>
<font color="black"> 475.     all fields will be used.</font>
<font color="black"> 476. </font>
<font color="black"> 477.     ``exclude`` is an optional list of field names. If provided, the named</font>
<font color="black"> 478.     fields will be excluded from the returned fields, even if they are listed</font>
<font color="black"> 479.     in the ``fields`` argument.</font>
<font color="black"> 480. </font>
<font color="black"> 481.     ``widgets`` is a dictionary of model field names mapped to a widget.</font>
<font color="black"> 482. </font>
<font color="black"> 483.     ``localized_fields`` is a list of names of fields which should be localized.</font>
<font color="black"> 484. </font>
<font color="black"> 485.     ``formfield_callback`` is a callable that takes a model field and returns</font>
<font color="black"> 486.     a form field.</font>
<font color="black"> 487. </font>
<font color="black"> 488.     ``labels`` is a dictionary of model field names mapped to a label.</font>
<font color="black"> 489. </font>
<font color="black"> 490.     ``help_texts`` is a dictionary of model field names mapped to a help text.</font>
<font color="black"> 491. </font>
<font color="black"> 492.     ``error_messages`` is a dictionary of model field names mapped to a</font>
<font color="black"> 493.     dictionary of error messages.</font>
<font color="black"> 494. </font>
<font color="black"> 495.     ``field_classes`` is a dictionary of model field names mapped to a form</font>
<font color="black"> 496.     field class.</font>
<font color="black"> 497.     &quot;&quot;&quot;</font>
<font color="black"> 498.     # Create the inner Meta class. FIXME: ideally, we should be able to</font>
<font color="black"> 499.     # construct a ModelForm without creating and passing in a temporary</font>
<font color="black"> 500.     # inner class.</font>
<font color="black"> 501. </font>
<font color="black"> 502.     # Build up a list of attributes that the Meta object will have.</font>
<font color="red"> 503.     attrs = {'model': model}</font>
<font color="red"> 504.     if fields is not None:</font>
<font color="red"> 505.         attrs['fields'] = fields</font>
<font color="red"> 506.     if exclude is not None:</font>
<font color="red"> 507.         attrs['exclude'] = exclude</font>
<font color="red"> 508.     if widgets is not None:</font>
<font color="red"> 509.         attrs['widgets'] = widgets</font>
<font color="red"> 510.     if localized_fields is not None:</font>
<font color="red"> 511.         attrs['localized_fields'] = localized_fields</font>
<font color="red"> 512.     if labels is not None:</font>
<font color="red"> 513.         attrs['labels'] = labels</font>
<font color="red"> 514.     if help_texts is not None:</font>
<font color="red"> 515.         attrs['help_texts'] = help_texts</font>
<font color="red"> 516.     if error_messages is not None:</font>
<font color="red"> 517.         attrs['error_messages'] = error_messages</font>
<font color="red"> 518.     if field_classes is not None:</font>
<font color="red"> 519.         attrs['field_classes'] = field_classes</font>
<font color="black"> 520. </font>
<font color="black"> 521.     # If parent form class already has an inner Meta, the Meta we're</font>
<font color="black"> 522.     # creating needs to inherit from the parent's inner meta.</font>
<font color="red"> 523.     parent = (object,)</font>
<font color="red"> 524.     if hasattr(form, 'Meta'):</font>
<font color="red"> 525.         parent = (form.Meta, object)</font>
<font color="red"> 526.     Meta = type(str('Meta'), parent, attrs)</font>
<font color="black"> 527. </font>
<font color="black"> 528.     # Give this new form class a reasonable name.</font>
<font color="red"> 529.     class_name = model.__name__ + str('Form')</font>
<font color="black"> 530. </font>
<font color="black"> 531.     # Class attributes for the new form class.</font>
<font color="red"> 532.     form_class_attrs = {</font>
<font color="red"> 533.         'Meta': Meta,</font>
<font color="red"> 534.         'formfield_callback': formfield_callback</font>
<font color="black"> 535.     }</font>
<font color="black"> 536. </font>
<font color="red"> 537.     if (getattr(Meta, 'fields', None) is None and</font>
<font color="red"> 538.             getattr(Meta, 'exclude', None) is None):</font>
<font color="red"> 539.         raise ImproperlyConfigured(</font>
<font color="red"> 540.             &quot;Calling modelform_factory without defining 'fields' or &quot;</font>
<font color="black"> 541.             &quot;'exclude' explicitly is prohibited.&quot;</font>
<font color="black"> 542.         )</font>
<font color="black"> 543. </font>
<font color="black"> 544.     # Instantiate type(form) in order to use the same metaclass as form.</font>
<font color="red"> 545.     return type(form)(class_name, (form,), form_class_attrs)</font>
<font color="black"> 546. </font>
<font color="black"> 547. </font>
<font color="black"> 548. # ModelFormSets ##############################################################</font>
<font color="black"> 549. </font>
<font color="green"> 550. class BaseModelFormSet(BaseFormSet):</font>
<font color="black"> 551.     &quot;&quot;&quot;</font>
<font color="black"> 552.     A ``FormSet`` for editing a queryset and/or adding new objects to it.</font>
<font color="green"> 553.     &quot;&quot;&quot;</font>
<font color="green"> 554.     model = None</font>
<font color="black"> 555. </font>
<font color="green"> 556.     def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,</font>
<font color="green"> 557.                  queryset=None, **kwargs):</font>
<font color="red"> 558.         self.queryset = queryset</font>
<font color="red"> 559.         self.initial_extra = kwargs.pop('initial', None)</font>
<font color="red"> 560.         defaults = {'data': data, 'files': files, 'auto_id': auto_id, 'prefix': prefix}</font>
<font color="red"> 561.         defaults.update(kwargs)</font>
<font color="red"> 562.         super(BaseModelFormSet, self).__init__(**defaults)</font>
<font color="black"> 563. </font>
<font color="green"> 564.     def initial_form_count(self):</font>
<font color="black"> 565.         &quot;&quot;&quot;Returns the number of forms that are required in this FormSet.&quot;&quot;&quot;</font>
<font color="red"> 566.         if not (self.data or self.files):</font>
<font color="red"> 567.             return len(self.get_queryset())</font>
<font color="red"> 568.         return super(BaseModelFormSet, self).initial_form_count()</font>
<font color="black"> 569. </font>
<font color="green"> 570.     def _existing_object(self, pk):</font>
<font color="red"> 571.         if not hasattr(self, '_object_dict'):</font>
<font color="red"> 572.             self._object_dict = {o.pk: o for o in self.get_queryset()}</font>
<font color="red"> 573.         return self._object_dict.get(pk)</font>
<font color="black"> 574. </font>
<font color="green"> 575.     def _get_to_python(self, field):</font>
<font color="black"> 576.         &quot;&quot;&quot;</font>
<font color="black"> 577.         If the field is a related field, fetch the concrete field's (that</font>
<font color="black"> 578.         is, the ultimate pointed-to field's) to_python.</font>
<font color="black"> 579.         &quot;&quot;&quot;</font>
<font color="red"> 580.         while field.remote_field is not None:</font>
<font color="red"> 581.             field = field.remote_field.get_related_field()</font>
<font color="red"> 582.         return field.to_python</font>
<font color="black"> 583. </font>
<font color="green"> 584.     def _construct_form(self, i, **kwargs):</font>
<font color="red"> 585.         if self.is_bound and i &lt; self.initial_form_count():</font>
<font color="red"> 586.             pk_key = &quot;%s-%s&quot; % (self.add_prefix(i), self.model._meta.pk.name)</font>
<font color="red"> 587.             pk = self.data[pk_key]</font>
<font color="red"> 588.             pk_field = self.model._meta.pk</font>
<font color="red"> 589.             to_python = self._get_to_python(pk_field)</font>
<font color="red"> 590.             pk = to_python(pk)</font>
<font color="red"> 591.             kwargs['instance'] = self._existing_object(pk)</font>
<font color="red"> 592.         if i &lt; self.initial_form_count() and 'instance' not in kwargs:</font>
<font color="red"> 593.             kwargs['instance'] = self.get_queryset()[i]</font>
<font color="red"> 594.         if i &gt;= self.initial_form_count() and self.initial_extra:</font>
<font color="black"> 595.             # Set initial values for extra forms</font>
<font color="red"> 596.             try:</font>
<font color="red"> 597.                 kwargs['initial'] = self.initial_extra[i - self.initial_form_count()]</font>
<font color="red"> 598.             except IndexError:</font>
<font color="red"> 599.                 pass</font>
<font color="red"> 600.         return super(BaseModelFormSet, self)._construct_form(i, **kwargs)</font>
<font color="black"> 601. </font>
<font color="green"> 602.     def get_queryset(self):</font>
<font color="red"> 603.         if not hasattr(self, '_queryset'):</font>
<font color="red"> 604.             if self.queryset is not None:</font>
<font color="red"> 605.                 qs = self.queryset</font>
<font color="black"> 606.             else:</font>
<font color="red"> 607.                 qs = self.model._default_manager.get_queryset()</font>
<font color="black"> 608. </font>
<font color="black"> 609.             # If the queryset isn't already ordered we need to add an</font>
<font color="black"> 610.             # artificial ordering here to make sure that all formsets</font>
<font color="black"> 611.             # constructed from this queryset have the same form order.</font>
<font color="red"> 612.             if not qs.ordered:</font>
<font color="red"> 613.                 qs = qs.order_by(self.model._meta.pk.name)</font>
<font color="black"> 614. </font>
<font color="black"> 615.             # Removed queryset limiting here. As per discussion re: #13023</font>
<font color="black"> 616.             # on django-dev, max_num should not prevent existing</font>
<font color="black"> 617.             # related objects/inlines from being displayed.</font>
<font color="red"> 618.             self._queryset = qs</font>
<font color="red"> 619.         return self._queryset</font>
<font color="black"> 620. </font>
<font color="green"> 621.     def save_new(self, form, commit=True):</font>
<font color="black"> 622.         &quot;&quot;&quot;Saves and returns a new model instance for the given form.&quot;&quot;&quot;</font>
<font color="red"> 623.         return form.save(commit=commit)</font>
<font color="black"> 624. </font>
<font color="green"> 625.     def save_existing(self, form, instance, commit=True):</font>
<font color="black"> 626.         &quot;&quot;&quot;Saves and returns an existing model instance for the given form.&quot;&quot;&quot;</font>
<font color="red"> 627.         return form.save(commit=commit)</font>
<font color="black"> 628. </font>
<font color="green"> 629.     def delete_existing(self, obj, commit=True):</font>
<font color="black"> 630.         &quot;&quot;&quot;Deletes an existing model instance.&quot;&quot;&quot;</font>
<font color="red"> 631.         if commit:</font>
<font color="red"> 632.             obj.delete()</font>
<font color="black"> 633. </font>
<font color="green"> 634.     def save(self, commit=True):</font>
<font color="black"> 635.         &quot;&quot;&quot;Saves model instances for every form, adding and changing instances</font>
<font color="black"> 636.         as necessary, and returns the list of instances.</font>
<font color="black"> 637.         &quot;&quot;&quot;</font>
<font color="red"> 638.         if not commit:</font>
<font color="red"> 639.             self.saved_forms = []</font>
<font color="black"> 640. </font>
<font color="red"> 641.             def save_m2m():</font>
<font color="red"> 642.                 for form in self.saved_forms:</font>
<font color="red"> 643.                     form.save_m2m()</font>
<font color="red"> 644.             self.save_m2m = save_m2m</font>
<font color="red"> 645.         return self.save_existing_objects(commit) + self.save_new_objects(commit)</font>
<font color="black"> 646. </font>
<font color="green"> 647.     save.alters_data = True</font>
<font color="black"> 648. </font>
<font color="green"> 649.     def clean(self):</font>
<font color="red"> 650.         self.validate_unique()</font>
<font color="black"> 651. </font>
<font color="green"> 652.     def validate_unique(self):</font>
<font color="black"> 653.         # Collect unique_checks and date_checks to run from all the forms.</font>
<font color="red"> 654.         all_unique_checks = set()</font>
<font color="red"> 655.         all_date_checks = set()</font>
<font color="red"> 656.         forms_to_delete = self.deleted_forms</font>
<font color="red"> 657.         valid_forms = [form for form in self.forms if form.is_valid() and form not in forms_to_delete]</font>
<font color="red"> 658.         for form in valid_forms:</font>
<font color="red"> 659.             exclude = form._get_validation_exclusions()</font>
<font color="red"> 660.             unique_checks, date_checks = form.instance._get_unique_checks(exclude=exclude)</font>
<font color="red"> 661.             all_unique_checks = all_unique_checks.union(set(unique_checks))</font>
<font color="red"> 662.             all_date_checks = all_date_checks.union(set(date_checks))</font>
<font color="black"> 663. </font>
<font color="red"> 664.         errors = []</font>
<font color="black"> 665.         # Do each of the unique checks (unique and unique_together)</font>
<font color="red"> 666.         for uclass, unique_check in all_unique_checks:</font>
<font color="red"> 667.             seen_data = set()</font>
<font color="red"> 668.             for form in valid_forms:</font>
<font color="black"> 669.                 # get data for each field of each of unique_check</font>
<font color="red"> 670.                 row_data = (form.cleaned_data[field]</font>
<font color="red"> 671.                             for field in unique_check if field in form.cleaned_data)</font>
<font color="black"> 672.                 # Reduce Model instances to their primary key values</font>
<font color="red"> 673.                 row_data = tuple(d._get_pk_val() if hasattr(d, '_get_pk_val') else d</font>
<font color="red"> 674.                                  for d in row_data)</font>
<font color="red"> 675.                 if row_data and None not in row_data:</font>
<font color="black"> 676.                     # if we've already seen it then we have a uniqueness failure</font>
<font color="red"> 677.                     if row_data in seen_data:</font>
<font color="black"> 678.                         # poke error messages into the right places and mark</font>
<font color="black"> 679.                         # the form as invalid</font>
<font color="red"> 680.                         errors.append(self.get_unique_error_message(unique_check))</font>
<font color="red"> 681.                         form._errors[NON_FIELD_ERRORS] = self.error_class([self.get_form_error()])</font>
<font color="black"> 682.                         # remove the data from the cleaned_data dict since it was invalid</font>
<font color="red"> 683.                         for field in unique_check:</font>
<font color="red"> 684.                             if field in form.cleaned_data:</font>
<font color="red"> 685.                                 del form.cleaned_data[field]</font>
<font color="black"> 686.                     # mark the data as seen</font>
<font color="red"> 687.                     seen_data.add(row_data)</font>
<font color="black"> 688.         # iterate over each of the date checks now</font>
<font color="red"> 689.         for date_check in all_date_checks:</font>
<font color="red"> 690.             seen_data = set()</font>
<font color="red"> 691.             uclass, lookup, field, unique_for = date_check</font>
<font color="red"> 692.             for form in valid_forms:</font>
<font color="black"> 693.                 # see if we have data for both fields</font>
<font color="red"> 694.                 if (form.cleaned_data and form.cleaned_data[field] is not None</font>
<font color="red"> 695.                         and form.cleaned_data[unique_for] is not None):</font>
<font color="black"> 696.                     # if it's a date lookup we need to get the data for all the fields</font>
<font color="red"> 697.                     if lookup == 'date':</font>
<font color="red"> 698.                         date = form.cleaned_data[unique_for]</font>
<font color="red"> 699.                         date_data = (date.year, date.month, date.day)</font>
<font color="black"> 700.                     # otherwise it's just the attribute on the date/datetime</font>
<font color="black"> 701.                     # object</font>
<font color="black"> 702.                     else:</font>
<font color="red"> 703.                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)</font>
<font color="red"> 704.                     data = (form.cleaned_data[field],) + date_data</font>
<font color="black"> 705.                     # if we've already seen it then we have a uniqueness failure</font>
<font color="red"> 706.                     if data in seen_data:</font>
<font color="black"> 707.                         # poke error messages into the right places and mark</font>
<font color="black"> 708.                         # the form as invalid</font>
<font color="red"> 709.                         errors.append(self.get_date_error_message(date_check))</font>
<font color="red"> 710.                         form._errors[NON_FIELD_ERRORS] = self.error_class([self.get_form_error()])</font>
<font color="black"> 711.                         # remove the data from the cleaned_data dict since it was invalid</font>
<font color="red"> 712.                         del form.cleaned_data[field]</font>
<font color="black"> 713.                     # mark the data as seen</font>
<font color="red"> 714.                     seen_data.add(data)</font>
<font color="black"> 715. </font>
<font color="red"> 716.         if errors:</font>
<font color="red"> 717.             raise ValidationError(errors)</font>
<font color="black"> 718. </font>
<font color="green"> 719.     def get_unique_error_message(self, unique_check):</font>
<font color="red"> 720.         if len(unique_check) == 1:</font>
<font color="red"> 721.             return ugettext(&quot;Please correct the duplicate data for %(field)s.&quot;) % {</font>
<font color="red"> 722.                 &quot;field&quot;: unique_check[0],</font>
<font color="black"> 723.             }</font>
<font color="black"> 724.         else:</font>
<font color="red"> 725.             return ugettext(&quot;Please correct the duplicate data for %(field)s, &quot;</font>
<font color="red"> 726.                 &quot;which must be unique.&quot;) % {</font>
<font color="red"> 727.                 &quot;field&quot;: get_text_list(unique_check, six.text_type(_(&quot;and&quot;))),</font>
<font color="black"> 728.             }</font>
<font color="black"> 729. </font>
<font color="green"> 730.     def get_date_error_message(self, date_check):</font>
<font color="red"> 731.         return ugettext(&quot;Please correct the duplicate data for %(field_name)s &quot;</font>
<font color="red"> 732.             &quot;which must be unique for the %(lookup)s in %(date_field)s.&quot;) % {</font>
<font color="red"> 733.             'field_name': date_check[2],</font>
<font color="red"> 734.             'date_field': date_check[3],</font>
<font color="red"> 735.             'lookup': six.text_type(date_check[1]),</font>
<font color="black"> 736.         }</font>
<font color="black"> 737. </font>
<font color="green"> 738.     def get_form_error(self):</font>
<font color="red"> 739.         return ugettext(&quot;Please correct the duplicate values below.&quot;)</font>
<font color="black"> 740. </font>
<font color="green"> 741.     def save_existing_objects(self, commit=True):</font>
<font color="red"> 742.         self.changed_objects = []</font>
<font color="red"> 743.         self.deleted_objects = []</font>
<font color="red"> 744.         if not self.initial_forms:</font>
<font color="red"> 745.             return []</font>
<font color="black"> 746. </font>
<font color="red"> 747.         saved_instances = []</font>
<font color="red"> 748.         forms_to_delete = self.deleted_forms</font>
<font color="red"> 749.         for form in self.initial_forms:</font>
<font color="red"> 750.             obj = form.instance</font>
<font color="red"> 751.             if form in forms_to_delete:</font>
<font color="black"> 752.                 # If the pk is None, it means that the object can't be</font>
<font color="black"> 753.                 # deleted again. Possible reason for this is that the</font>
<font color="black"> 754.                 # object was already deleted from the DB. Refs #14877.</font>
<font color="red"> 755.                 if obj.pk is None:</font>
<font color="red"> 756.                     continue</font>
<font color="red"> 757.                 self.deleted_objects.append(obj)</font>
<font color="red"> 758.                 self.delete_existing(obj, commit=commit)</font>
<font color="red"> 759.             elif form.has_changed():</font>
<font color="red"> 760.                 self.changed_objects.append((obj, form.changed_data))</font>
<font color="red"> 761.                 saved_instances.append(self.save_existing(form, obj, commit=commit))</font>
<font color="red"> 762.                 if not commit:</font>
<font color="red"> 763.                     self.saved_forms.append(form)</font>
<font color="red"> 764.         return saved_instances</font>
<font color="black"> 765. </font>
<font color="green"> 766.     def save_new_objects(self, commit=True):</font>
<font color="red"> 767.         self.new_objects = []</font>
<font color="red"> 768.         for form in self.extra_forms:</font>
<font color="red"> 769.             if not form.has_changed():</font>
<font color="red"> 770.                 continue</font>
<font color="black"> 771.             # If someone has marked an add form for deletion, don't save the</font>
<font color="black"> 772.             # object.</font>
<font color="red"> 773.             if self.can_delete and self._should_delete_form(form):</font>
<font color="red"> 774.                 continue</font>
<font color="red"> 775.             self.new_objects.append(self.save_new(form, commit=commit))</font>
<font color="red"> 776.             if not commit:</font>
<font color="red"> 777.                 self.saved_forms.append(form)</font>
<font color="red"> 778.         return self.new_objects</font>
<font color="black"> 779. </font>
<font color="green"> 780.     def add_fields(self, form, index):</font>
<font color="black"> 781.         &quot;&quot;&quot;Add a hidden field for the object's primary key.&quot;&quot;&quot;</font>
<font color="red"> 782.         from django.db.models import AutoField, OneToOneField, ForeignKey</font>
<font color="red"> 783.         self._pk_field = pk = self.model._meta.pk</font>
<font color="black"> 784.         # If a pk isn't editable, then it won't be on the form, so we need to</font>
<font color="black"> 785.         # add it here so we can tell which object is which when we get the</font>
<font color="black"> 786.         # data back. Generally, pk.editable should be false, but for some</font>
<font color="black"> 787.         # reason, auto_created pk fields and AutoField's editable attribute is</font>
<font color="black"> 788.         # True, so check for that as well.</font>
<font color="black"> 789. </font>
<font color="red"> 790.         def pk_is_not_editable(pk):</font>
<font color="black"> 791.             return (</font>
<font color="red"> 792.                 (not pk.editable) or (pk.auto_created or isinstance(pk, AutoField)) or (</font>
<font color="red"> 793.                     pk.remote_field and pk.remote_field.parent_link</font>
<font color="red"> 794.                     and pk_is_not_editable(pk.remote_field.model._meta.pk)</font>
<font color="black"> 795.                 )</font>
<font color="black"> 796.             )</font>
<font color="red"> 797.         if pk_is_not_editable(pk) or pk.name not in form.fields:</font>
<font color="red"> 798.             if form.is_bound:</font>
<font color="black"> 799.                 # If we're adding the related instance, ignore its primary key</font>
<font color="black"> 800.                 # as it could be an auto-generated default which isn't actually</font>
<font color="black"> 801.                 # in the database.</font>
<font color="red"> 802.                 pk_value = None if form.instance._state.adding else form.instance.pk</font>
<font color="black"> 803.             else:</font>
<font color="red"> 804.                 try:</font>
<font color="red"> 805.                     if index is not None:</font>
<font color="red"> 806.                         pk_value = self.get_queryset()[index].pk</font>
<font color="black"> 807.                     else:</font>
<font color="red"> 808.                         pk_value = None</font>
<font color="red"> 809.                 except IndexError:</font>
<font color="red"> 810.                     pk_value = None</font>
<font color="red"> 811.             if isinstance(pk, OneToOneField) or isinstance(pk, ForeignKey):</font>
<font color="red"> 812.                 qs = pk.remote_field.model._default_manager.get_queryset()</font>
<font color="black"> 813.             else:</font>
<font color="red"> 814.                 qs = self.model._default_manager.get_queryset()</font>
<font color="red"> 815.             qs = qs.using(form.instance._state.db)</font>
<font color="red"> 816.             if form._meta.widgets:</font>
<font color="red"> 817.                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)</font>
<font color="black"> 818.             else:</font>
<font color="red"> 819.                 widget = HiddenInput</font>
<font color="red"> 820.             form.fields[self._pk_field.name] = ModelChoiceField(qs, initial=pk_value, required=False, widget=widget)</font>
<font color="red"> 821.         super(BaseModelFormSet, self).add_fields(form, index)</font>
<font color="black"> 822. </font>
<font color="black"> 823. </font>
<font color="green"> 824. def modelformset_factory(model, form=ModelForm, formfield_callback=None,</font>
<font color="green"> 825.                          formset=BaseModelFormSet, extra=1, can_delete=False,</font>
<font color="green"> 826.                          can_order=False, max_num=None, fields=None, exclude=None,</font>
<font color="green"> 827.                          widgets=None, validate_max=False, localized_fields=None,</font>
<font color="green"> 828.                          labels=None, help_texts=None, error_messages=None,</font>
<font color="green"> 829.                          min_num=None, validate_min=False, field_classes=None):</font>
<font color="black"> 830.     &quot;&quot;&quot;</font>
<font color="black"> 831.     Returns a FormSet class for the given Django model class.</font>
<font color="black"> 832.     &quot;&quot;&quot;</font>
<font color="red"> 833.     meta = getattr(form, 'Meta', None)</font>
<font color="red"> 834.     if meta is None:</font>
<font color="red"> 835.         meta = type(str('Meta'), (object,), {})</font>
<font color="red"> 836.     if (getattr(meta, 'fields', fields) is None and</font>
<font color="red"> 837.             getattr(meta, 'exclude', exclude) is None):</font>
<font color="red"> 838.         raise ImproperlyConfigured(</font>
<font color="red"> 839.             &quot;Calling modelformset_factory without defining 'fields' or &quot;</font>
<font color="black"> 840.             &quot;'exclude' explicitly is prohibited.&quot;</font>
<font color="black"> 841.         )</font>
<font color="black"> 842. </font>
<font color="red"> 843.     form = modelform_factory(model, form=form, fields=fields, exclude=exclude,</font>
<font color="red"> 844.                              formfield_callback=formfield_callback,</font>
<font color="red"> 845.                              widgets=widgets, localized_fields=localized_fields,</font>
<font color="red"> 846.                              labels=labels, help_texts=help_texts,</font>
<font color="red"> 847.                              error_messages=error_messages, field_classes=field_classes)</font>
<font color="red"> 848.     FormSet = formset_factory(form, formset, extra=extra, min_num=min_num, max_num=max_num,</font>
<font color="red"> 849.                               can_order=can_order, can_delete=can_delete,</font>
<font color="red"> 850.                               validate_min=validate_min, validate_max=validate_max)</font>
<font color="red"> 851.     FormSet.model = model</font>
<font color="red"> 852.     return FormSet</font>
<font color="black"> 853. </font>
<font color="black"> 854. </font>
<font color="black"> 855. # InlineFormSets #############################################################</font>
<font color="black"> 856. </font>
<font color="green"> 857. class BaseInlineFormSet(BaseModelFormSet):</font>
<font color="green"> 858.     &quot;&quot;&quot;A formset for child objects related to a parent.&quot;&quot;&quot;</font>
<font color="green"> 859.     def __init__(self, data=None, files=None, instance=None,</font>
<font color="green"> 860.                  save_as_new=False, prefix=None, queryset=None, **kwargs):</font>
<font color="red"> 861.         if instance is None:</font>
<font color="red"> 862.             self.instance = self.fk.remote_field.model()</font>
<font color="black"> 863.         else:</font>
<font color="red"> 864.             self.instance = instance</font>
<font color="red"> 865.         self.save_as_new = save_as_new</font>
<font color="red"> 866.         if queryset is None:</font>
<font color="red"> 867.             queryset = self.model._default_manager</font>
<font color="red"> 868.         if self.instance.pk is not None:</font>
<font color="red"> 869.             qs = queryset.filter(**{self.fk.name: self.instance})</font>
<font color="black"> 870.         else:</font>
<font color="red"> 871.             qs = queryset.none()</font>
<font color="red"> 872.         super(BaseInlineFormSet, self).__init__(data, files, prefix=prefix,</font>
<font color="red"> 873.                                                 queryset=qs, **kwargs)</font>
<font color="black"> 874. </font>
<font color="green"> 875.     def initial_form_count(self):</font>
<font color="red"> 876.         if self.save_as_new:</font>
<font color="red"> 877.             return 0</font>
<font color="red"> 878.         return super(BaseInlineFormSet, self).initial_form_count()</font>
<font color="black"> 879. </font>
<font color="green"> 880.     def _construct_form(self, i, **kwargs):</font>
<font color="red"> 881.         form = super(BaseInlineFormSet, self)._construct_form(i, **kwargs)</font>
<font color="red"> 882.         if self.save_as_new:</font>
<font color="black"> 883.             # Remove the primary key from the form's data, we are only</font>
<font color="black"> 884.             # creating new instances</font>
<font color="red"> 885.             form.data[form.add_prefix(self._pk_field.name)] = None</font>
<font color="black"> 886. </font>
<font color="black"> 887.             # Remove the foreign key from the form's data</font>
<font color="red"> 888.             form.data[form.add_prefix(self.fk.name)] = None</font>
<font color="black"> 889. </font>
<font color="black"> 890.         # Set the fk value here so that the form can do its validation.</font>
<font color="red"> 891.         fk_value = self.instance.pk</font>
<font color="red"> 892.         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:</font>
<font color="red"> 893.             fk_value = getattr(self.instance, self.fk.remote_field.field_name)</font>
<font color="red"> 894.             fk_value = getattr(fk_value, 'pk', fk_value)</font>
<font color="red"> 895.         setattr(form.instance, self.fk.get_attname(), fk_value)</font>
<font color="red"> 896.         return form</font>
<font color="black"> 897. </font>
<font color="green"> 898.     @classmethod</font>
<font color="black"> 899.     def get_default_prefix(cls):</font>
<font color="red"> 900.         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace('+', '')</font>
<font color="black"> 901. </font>
<font color="green"> 902.     def save_new(self, form, commit=True):</font>
<font color="black"> 903.         # Ensure the latest copy of the related instance is present on each</font>
<font color="black"> 904.         # form (it may have been saved after the formset was originally</font>
<font color="black"> 905.         # instantiated).</font>
<font color="red"> 906.         setattr(form.instance, self.fk.name, self.instance)</font>
<font color="black"> 907.         # Use commit=False so we can assign the parent key afterwards, then</font>
<font color="black"> 908.         # save the object.</font>
<font color="red"> 909.         obj = form.save(commit=False)</font>
<font color="red"> 910.         pk_value = getattr(self.instance, self.fk.remote_field.field_name)</font>
<font color="red"> 911.         setattr(obj, self.fk.get_attname(), getattr(pk_value, 'pk', pk_value))</font>
<font color="red"> 912.         if commit:</font>
<font color="red"> 913.             obj.save()</font>
<font color="black"> 914.         # form.save_m2m() can be called via the formset later on if commit=False</font>
<font color="red"> 915.         if commit and hasattr(form, 'save_m2m'):</font>
<font color="red"> 916.             form.save_m2m()</font>
<font color="red"> 917.         return obj</font>
<font color="black"> 918. </font>
<font color="green"> 919.     def add_fields(self, form, index):</font>
<font color="red"> 920.         super(BaseInlineFormSet, self).add_fields(form, index)</font>
<font color="red"> 921.         if self._pk_field == self.fk:</font>
<font color="red"> 922.             name = self._pk_field.name</font>
<font color="red"> 923.             kwargs = {'pk_field': True}</font>
<font color="black"> 924.         else:</font>
<font color="black"> 925.             # The foreign key field might not be on the form, so we poke at the</font>
<font color="black"> 926.             # Model field to get the label, since we need that for error messages.</font>
<font color="red"> 927.             name = self.fk.name</font>
<font color="red"> 928.             kwargs = {</font>
<font color="red"> 929.                 'label': getattr(form.fields.get(name), 'label', capfirst(self.fk.verbose_name))</font>
<font color="black"> 930.             }</font>
<font color="red"> 931.             if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:</font>
<font color="red"> 932.                 kwargs['to_field'] = self.fk.remote_field.field_name</font>
<font color="black"> 933. </font>
<font color="black"> 934.         # If we're adding a new object, ignore a parent's auto-generated key</font>
<font color="black"> 935.         # as it will be regenerated on the save request.</font>
<font color="red"> 936.         if self.instance._state.adding:</font>
<font color="red"> 937.             if kwargs.get('to_field') is not None:</font>
<font color="red"> 938.                 to_field = self.instance._meta.get_field(kwargs['to_field'])</font>
<font color="black"> 939.             else:</font>
<font color="red"> 940.                 to_field = self.instance._meta.pk</font>
<font color="red"> 941.             if to_field.has_default():</font>
<font color="red"> 942.                 setattr(self.instance, to_field.attname, None)</font>
<font color="black"> 943. </font>
<font color="red"> 944.         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)</font>
<font color="black"> 945. </font>
<font color="black"> 946.         # Add the generated field to form._meta.fields if it's defined to make</font>
<font color="black"> 947.         # sure validation isn't skipped on that field.</font>
<font color="red"> 948.         if form._meta.fields:</font>
<font color="red"> 949.             if isinstance(form._meta.fields, tuple):</font>
<font color="red"> 950.                 form._meta.fields = list(form._meta.fields)</font>
<font color="red"> 951.             form._meta.fields.append(self.fk.name)</font>
<font color="black"> 952. </font>
<font color="green"> 953.     def get_unique_error_message(self, unique_check):</font>
<font color="red"> 954.         unique_check = [field for field in unique_check if field != self.fk.name]</font>
<font color="red"> 955.         return super(BaseInlineFormSet, self).get_unique_error_message(unique_check)</font>
<font color="black"> 956. </font>
<font color="black"> 957. </font>
<font color="green"> 958. def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):</font>
<font color="black"> 959.     &quot;&quot;&quot;</font>
<font color="black"> 960.     Finds and returns the ForeignKey from model to parent if there is one</font>
<font color="black"> 961.     (returns None if can_fail is True and no such field exists). If fk_name is</font>
<font color="black"> 962.     provided, assume it is the name of the ForeignKey field. Unless can_fail is</font>
<font color="black"> 963.     True, an exception is raised if there is no ForeignKey from model to</font>
<font color="black"> 964.     parent_model.</font>
<font color="black"> 965.     &quot;&quot;&quot;</font>
<font color="black"> 966.     # avoid circular import</font>
<font color="red"> 967.     from django.db.models import ForeignKey</font>
<font color="red"> 968.     opts = model._meta</font>
<font color="red"> 969.     if fk_name:</font>
<font color="red"> 970.         fks_to_parent = [f for f in opts.fields if f.name == fk_name]</font>
<font color="red"> 971.         if len(fks_to_parent) == 1:</font>
<font color="red"> 972.             fk = fks_to_parent[0]</font>
<font color="red"> 973.             if not isinstance(fk, ForeignKey) or \</font>
<font color="red"> 974.                     (fk.remote_field.model != parent_model and</font>
<font color="red"> 975.                      fk.remote_field.model not in parent_model._meta.get_parent_list()):</font>
<font color="red"> 976.                 raise ValueError(</font>
<font color="red"> 977.                     &quot;fk_name '%s' is not a ForeignKey to '%s'.&quot; % (fk_name, parent_model._meta.label)</font>
<font color="black"> 978.                 )</font>
<font color="red"> 979.         elif len(fks_to_parent) == 0:</font>
<font color="red"> 980.             raise ValueError(</font>
<font color="red"> 981.                 &quot;'%s' has no field named '%s'.&quot; % (model._meta.label, fk_name)</font>
<font color="black"> 982.             )</font>
<font color="black"> 983.     else:</font>
<font color="black"> 984.         # Try to discover what the ForeignKey from model to parent_model is</font>
<font color="black"> 985.         fks_to_parent = [</font>
<font color="red"> 986.             f for f in opts.fields</font>
<font color="red"> 987.             if isinstance(f, ForeignKey)</font>
<font color="red"> 988.             and (f.remote_field.model == parent_model</font>
<font color="red"> 989.                 or f.remote_field.model in parent_model._meta.get_parent_list())</font>
<font color="black"> 990.         ]</font>
<font color="red"> 991.         if len(fks_to_parent) == 1:</font>
<font color="red"> 992.             fk = fks_to_parent[0]</font>
<font color="red"> 993.         elif len(fks_to_parent) == 0:</font>
<font color="red"> 994.             if can_fail:</font>
<font color="red"> 995.                 return</font>
<font color="red"> 996.             raise ValueError(</font>
<font color="red"> 997.                 &quot;'%s' has no ForeignKey to '%s'.&quot; % (</font>
<font color="red"> 998.                     model._meta.label,</font>
<font color="red"> 999.                     parent_model._meta.label,</font>
<font color="black">1000.                 )</font>
<font color="black">1001.             )</font>
<font color="black">1002.         else:</font>
<font color="red">1003.             raise ValueError(</font>
<font color="red">1004.                 &quot;'%s' has more than one ForeignKey to '%s'.&quot; % (</font>
<font color="red">1005.                     model._meta.label,</font>
<font color="red">1006.                     parent_model._meta.label,</font>
<font color="black">1007.                 )</font>
<font color="black">1008.             )</font>
<font color="red">1009.     return fk</font>
<font color="black">1010. </font>
<font color="black">1011. </font>
<font color="green">1012. def inlineformset_factory(parent_model, model, form=ModelForm,</font>
<font color="green">1013.                           formset=BaseInlineFormSet, fk_name=None,</font>
<font color="green">1014.                           fields=None, exclude=None, extra=3, can_order=False,</font>
<font color="green">1015.                           can_delete=True, max_num=None, formfield_callback=None,</font>
<font color="green">1016.                           widgets=None, validate_max=False, localized_fields=None,</font>
<font color="green">1017.                           labels=None, help_texts=None, error_messages=None,</font>
<font color="green">1018.                           min_num=None, validate_min=False, field_classes=None):</font>
<font color="black">1019.     &quot;&quot;&quot;</font>
<font color="black">1020.     Returns an ``InlineFormSet`` for the given kwargs.</font>
<font color="black">1021. </font>
<font color="black">1022.     You must provide ``fk_name`` if ``model`` has more than one ``ForeignKey``</font>
<font color="black">1023.     to ``parent_model``.</font>
<font color="black">1024.     &quot;&quot;&quot;</font>
<font color="red">1025.     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)</font>
<font color="black">1026.     # enforce a max_num=1 when the foreign key to the parent model is unique.</font>
<font color="red">1027.     if fk.unique:</font>
<font color="red">1028.         max_num = 1</font>
<font color="red">1029.     kwargs = {</font>
<font color="red">1030.         'form': form,</font>
<font color="red">1031.         'formfield_callback': formfield_callback,</font>
<font color="red">1032.         'formset': formset,</font>
<font color="red">1033.         'extra': extra,</font>
<font color="red">1034.         'can_delete': can_delete,</font>
<font color="red">1035.         'can_order': can_order,</font>
<font color="red">1036.         'fields': fields,</font>
<font color="red">1037.         'exclude': exclude,</font>
<font color="red">1038.         'min_num': min_num,</font>
<font color="red">1039.         'max_num': max_num,</font>
<font color="red">1040.         'widgets': widgets,</font>
<font color="red">1041.         'validate_min': validate_min,</font>
<font color="red">1042.         'validate_max': validate_max,</font>
<font color="red">1043.         'localized_fields': localized_fields,</font>
<font color="red">1044.         'labels': labels,</font>
<font color="red">1045.         'help_texts': help_texts,</font>
<font color="red">1046.         'error_messages': error_messages,</font>
<font color="red">1047.         'field_classes': field_classes,</font>
<font color="black">1048.     }</font>
<font color="red">1049.     FormSet = modelformset_factory(model, **kwargs)</font>
<font color="red">1050.     FormSet.fk = fk</font>
<font color="red">1051.     return FormSet</font>
<font color="black">1052. </font>
<font color="black">1053. </font>
<font color="black">1054. # Fields #####################################################################</font>
<font color="black">1055. </font>
<font color="green">1056. class InlineForeignKeyField(Field):</font>
<font color="black">1057.     &quot;&quot;&quot;</font>
<font color="black">1058.     A basic integer field that deals with validating the given value to a</font>
<font color="black">1059.     given parent instance in an inline.</font>
<font color="green">1060.     &quot;&quot;&quot;</font>
<font color="green">1061.     widget = HiddenInput</font>
<font color="green">1062.     default_error_messages = {</font>
<font color="green">1063.         'invalid_choice': _('The inline foreign key did not match the parent instance primary key.'),</font>
<font color="black">1064.     }</font>
<font color="black">1065. </font>
<font color="green">1066.     def __init__(self, parent_instance, *args, **kwargs):</font>
<font color="red">1067.         self.parent_instance = parent_instance</font>
<font color="red">1068.         self.pk_field = kwargs.pop(&quot;pk_field&quot;, False)</font>
<font color="red">1069.         self.to_field = kwargs.pop(&quot;to_field&quot;, None)</font>
<font color="red">1070.         if self.parent_instance is not None:</font>
<font color="red">1071.             if self.to_field:</font>
<font color="red">1072.                 kwargs[&quot;initial&quot;] = getattr(self.parent_instance, self.to_field)</font>
<font color="black">1073.             else:</font>
<font color="red">1074.                 kwargs[&quot;initial&quot;] = self.parent_instance.pk</font>
<font color="red">1075.         kwargs[&quot;required&quot;] = False</font>
<font color="red">1076.         super(InlineForeignKeyField, self).__init__(*args, **kwargs)</font>
<font color="black">1077. </font>
<font color="green">1078.     def clean(self, value):</font>
<font color="red">1079.         if value in self.empty_values:</font>
<font color="red">1080.             if self.pk_field:</font>
<font color="red">1081.                 return None</font>
<font color="black">1082.             # if there is no value act as we did before.</font>
<font color="red">1083.             return self.parent_instance</font>
<font color="black">1084.         # ensure the we compare the values as equal types.</font>
<font color="red">1085.         if self.to_field:</font>
<font color="red">1086.             orig = getattr(self.parent_instance, self.to_field)</font>
<font color="black">1087.         else:</font>
<font color="red">1088.             orig = self.parent_instance.pk</font>
<font color="red">1089.         if force_text(value) != force_text(orig):</font>
<font color="red">1090.             raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')</font>
<font color="red">1091.         return self.parent_instance</font>
<font color="black">1092. </font>
<font color="green">1093.     def has_changed(self, initial, data):</font>
<font color="red">1094.         return False</font>
<font color="black">1095. </font>
<font color="black">1096. </font>
<font color="green">1097. class ModelChoiceIterator(object):</font>
<font color="green">1098.     def __init__(self, field):</font>
<font color="green">1099.         self.field = field</font>
<font color="green">1100.         self.queryset = field.queryset</font>
<font color="black">1101. </font>
<font color="green">1102.     def __iter__(self):</font>
<font color="red">1103.         if self.field.empty_label is not None:</font>
<font color="red">1104.             yield (&quot;&quot;, self.field.empty_label)</font>
<font color="red">1105.         queryset = self.queryset.all()</font>
<font color="black">1106.         # Can't use iterator() when queryset uses prefetch_related()</font>
<font color="red">1107.         if not queryset._prefetch_related_lookups:</font>
<font color="red">1108.             queryset = queryset.iterator()</font>
<font color="red">1109.         for obj in queryset:</font>
<font color="red">1110.             yield self.choice(obj)</font>
<font color="black">1111. </font>
<font color="green">1112.     def __len__(self):</font>
<font color="red">1113.         return (len(self.queryset) +</font>
<font color="red">1114.             (1 if self.field.empty_label is not None else 0))</font>
<font color="black">1115. </font>
<font color="green">1116.     def choice(self, obj):</font>
<font color="red">1117.         return (self.field.prepare_value(obj), self.field.label_from_instance(obj))</font>
<font color="black">1118. </font>
<font color="black">1119. </font>
<font color="green">1120. class ModelChoiceField(ChoiceField):</font>
<font color="green">1121.     &quot;&quot;&quot;A ChoiceField whose choices are a model QuerySet.&quot;&quot;&quot;</font>
<font color="black">1122.     # This class is a subclass of ChoiceField for purity, but it doesn't</font>
<font color="black">1123.     # actually use any of ChoiceField's implementation.</font>
<font color="green">1124.     default_error_messages = {</font>
<font color="green">1125.         'invalid_choice': _('Select a valid choice. That choice is not one of'</font>
<font color="black">1126.                             ' the available choices.'),</font>
<font color="black">1127.     }</font>
<font color="black">1128. </font>
<font color="green">1129.     def __init__(self, queryset, empty_label=&quot;---------&quot;,</font>
<font color="green">1130.                  required=True, widget=None, label=None, initial=None,</font>
<font color="green">1131.                  help_text='', to_field_name=None, limit_choices_to=None,</font>
<font color="black">1132.                  *args, **kwargs):</font>
<font color="green">1133.         if required and (initial is not None):</font>
<font color="red">1134.             self.empty_label = None</font>
<font color="black">1135.         else:</font>
<font color="green">1136.             self.empty_label = empty_label</font>
<font color="black">1137. </font>
<font color="black">1138.         # Call Field instead of ChoiceField __init__() because we don't need</font>
<font color="black">1139.         # ChoiceField.__init__().</font>
<font color="green">1140.         Field.__init__(self, required, widget, label, initial, help_text,</font>
<font color="green">1141.                        *args, **kwargs)</font>
<font color="green">1142.         self.queryset = queryset</font>
<font color="green">1143.         self.limit_choices_to = limit_choices_to   # limit the queryset later.</font>
<font color="green">1144.         self.to_field_name = to_field_name</font>
<font color="black">1145. </font>
<font color="green">1146.     def get_limit_choices_to(self):</font>
<font color="black">1147.         &quot;&quot;&quot;</font>
<font color="black">1148.         Returns ``limit_choices_to`` for this form field.</font>
<font color="black">1149. </font>
<font color="black">1150.         If it is a callable, it will be invoked and the result will be</font>
<font color="black">1151.         returned.</font>
<font color="black">1152.         &quot;&quot;&quot;</font>
<font color="red">1153.         if callable(self.limit_choices_to):</font>
<font color="red">1154.             return self.limit_choices_to()</font>
<font color="red">1155.         return self.limit_choices_to</font>
<font color="black">1156. </font>
<font color="green">1157.     def __deepcopy__(self, memo):</font>
<font color="red">1158.         result = super(ChoiceField, self).__deepcopy__(memo)</font>
<font color="black">1159.         # Need to force a new ModelChoiceIterator to be created, bug #11183</font>
<font color="red">1160.         result.queryset = result.queryset</font>
<font color="red">1161.         return result</font>
<font color="black">1162. </font>
<font color="green">1163.     def _get_queryset(self):</font>
<font color="green">1164.         return self._queryset</font>
<font color="black">1165. </font>
<font color="green">1166.     def _set_queryset(self, queryset):</font>
<font color="green">1167.         self._queryset = queryset</font>
<font color="green">1168.         self.widget.choices = self.choices</font>
<font color="black">1169. </font>
<font color="green">1170.     queryset = property(_get_queryset, _set_queryset)</font>
<font color="black">1171. </font>
<font color="black">1172.     # this method will be used to create object labels by the QuerySetIterator.</font>
<font color="black">1173.     # Override it to customize the label.</font>
<font color="green">1174.     def label_from_instance(self, obj):</font>
<font color="black">1175.         &quot;&quot;&quot;</font>
<font color="black">1176.         This method is used to convert objects into strings; it's used to</font>
<font color="black">1177.         generate the labels for the choices presented by this object. Subclasses</font>
<font color="black">1178.         can override this method to customize the display of the choices.</font>
<font color="black">1179.         &quot;&quot;&quot;</font>
<font color="red">1180.         return smart_text(obj)</font>
<font color="black">1181. </font>
<font color="green">1182.     def _get_choices(self):</font>
<font color="black">1183.         # If self._choices is set, then somebody must have manually set</font>
<font color="black">1184.         # the property self.choices. In this case, just return self._choices.</font>
<font color="green">1185.         if hasattr(self, '_choices'):</font>
<font color="red">1186.             return self._choices</font>
<font color="black">1187. </font>
<font color="black">1188.         # Otherwise, execute the QuerySet in self.queryset to determine the</font>
<font color="black">1189.         # choices dynamically. Return a fresh ModelChoiceIterator that has not been</font>
<font color="black">1190.         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*</font>
<font color="black">1191.         # time _get_choices() is called (and, thus, each time self.choices is</font>
<font color="black">1192.         # accessed) so that we can ensure the QuerySet has not been consumed. This</font>
<font color="black">1193.         # construct might look complicated but it allows for lazy evaluation of</font>
<font color="black">1194.         # the queryset.</font>
<font color="green">1195.         return ModelChoiceIterator(self)</font>
<font color="black">1196. </font>
<font color="green">1197.     choices = property(_get_choices, ChoiceField._set_choices)</font>
<font color="black">1198. </font>
<font color="green">1199.     def prepare_value(self, value):</font>
<font color="red">1200.         if hasattr(value, '_meta'):</font>
<font color="red">1201.             if self.to_field_name:</font>
<font color="red">1202.                 return value.serializable_value(self.to_field_name)</font>
<font color="black">1203.             else:</font>
<font color="red">1204.                 return value.pk</font>
<font color="red">1205.         return super(ModelChoiceField, self).prepare_value(value)</font>
<font color="black">1206. </font>
<font color="green">1207.     def to_python(self, value):</font>
<font color="red">1208.         if value in self.empty_values:</font>
<font color="red">1209.             return None</font>
<font color="red">1210.         try:</font>
<font color="red">1211.             key = self.to_field_name or 'pk'</font>
<font color="red">1212.             value = self.queryset.get(**{key: value})</font>
<font color="red">1213.         except (ValueError, TypeError, self.queryset.model.DoesNotExist):</font>
<font color="red">1214.             raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')</font>
<font color="red">1215.         return value</font>
<font color="black">1216. </font>
<font color="green">1217.     def validate(self, value):</font>
<font color="red">1218.         return Field.validate(self, value)</font>
<font color="black">1219. </font>
<font color="green">1220.     def has_changed(self, initial, data):</font>
<font color="red">1221.         initial_value = initial if initial is not None else ''</font>
<font color="red">1222.         data_value = data if data is not None else ''</font>
<font color="red">1223.         return force_text(self.prepare_value(initial_value)) != force_text(data_value)</font>
<font color="black">1224. </font>
<font color="black">1225. </font>
<font color="green">1226. class ModelMultipleChoiceField(ModelChoiceField):</font>
<font color="green">1227.     &quot;&quot;&quot;A MultipleChoiceField whose choices are a model QuerySet.&quot;&quot;&quot;</font>
<font color="green">1228.     widget = SelectMultiple</font>
<font color="green">1229.     hidden_widget = MultipleHiddenInput</font>
<font color="green">1230.     default_error_messages = {</font>
<font color="green">1231.         'list': _('Enter a list of values.'),</font>
<font color="green">1232.         'invalid_choice': _('Select a valid choice. %(value)s is not one of the'</font>
<font color="black">1233.                             ' available choices.'),</font>
<font color="green">1234.         'invalid_pk_value': _('&quot;%(pk)s&quot; is not a valid value for a primary key.')</font>
<font color="black">1235.     }</font>
<font color="black">1236. </font>
<font color="green">1237.     def __init__(self, queryset, required=True, widget=None, label=None,</font>
<font color="green">1238.                  initial=None, help_text='', *args, **kwargs):</font>
<font color="green">1239.         super(ModelMultipleChoiceField, self).__init__(queryset, None,</font>
<font color="green">1240.             required, widget, label, initial, help_text, *args, **kwargs)</font>
<font color="black">1241. </font>
<font color="green">1242.     def to_python(self, value):</font>
<font color="red">1243.         if not value:</font>
<font color="red">1244.             return []</font>
<font color="red">1245.         return list(self._check_values(value))</font>
<font color="black">1246. </font>
<font color="green">1247.     def clean(self, value):</font>
<font color="red">1248.         if self.required and not value:</font>
<font color="red">1249.             raise ValidationError(self.error_messages['required'], code='required')</font>
<font color="red">1250.         elif not self.required and not value:</font>
<font color="red">1251.             return self.queryset.none()</font>
<font color="red">1252.         if not isinstance(value, (list, tuple)):</font>
<font color="red">1253.             raise ValidationError(self.error_messages['list'], code='list')</font>
<font color="red">1254.         qs = self._check_values(value)</font>
<font color="black">1255.         # Since this overrides the inherited ModelChoiceField.clean</font>
<font color="black">1256.         # we run custom validators here</font>
<font color="red">1257.         self.run_validators(value)</font>
<font color="red">1258.         return qs</font>
<font color="black">1259. </font>
<font color="green">1260.     def _check_values(self, value):</font>
<font color="black">1261.         &quot;&quot;&quot;</font>
<font color="black">1262.         Given a list of possible PK values, returns a QuerySet of the</font>
<font color="black">1263.         corresponding objects. Raises a ValidationError if a given value is</font>
<font color="black">1264.         invalid (not a valid PK, not in the queryset, etc.)</font>
<font color="black">1265.         &quot;&quot;&quot;</font>
<font color="red">1266.         key = self.to_field_name or 'pk'</font>
<font color="black">1267.         # deduplicate given values to avoid creating many querysets or</font>
<font color="black">1268.         # requiring the database backend deduplicate efficiently.</font>
<font color="red">1269.         try:</font>
<font color="red">1270.             value = frozenset(value)</font>
<font color="red">1271.         except TypeError:</font>
<font color="black">1272.             # list of lists isn't hashable, for example</font>
<font color="red">1273.             raise ValidationError(</font>
<font color="red">1274.                 self.error_messages['list'],</font>
<font color="red">1275.                 code='list',</font>
<font color="black">1276.             )</font>
<font color="red">1277.         for pk in value:</font>
<font color="red">1278.             try:</font>
<font color="red">1279.                 self.queryset.filter(**{key: pk})</font>
<font color="red">1280.             except (ValueError, TypeError):</font>
<font color="red">1281.                 raise ValidationError(</font>
<font color="red">1282.                     self.error_messages['invalid_pk_value'],</font>
<font color="red">1283.                     code='invalid_pk_value',</font>
<font color="red">1284.                     params={'pk': pk},</font>
<font color="black">1285.                 )</font>
<font color="red">1286.         qs = self.queryset.filter(**{'%s__in' % key: value})</font>
<font color="red">1287.         pks = set(force_text(getattr(o, key)) for o in qs)</font>
<font color="red">1288.         for val in value:</font>
<font color="red">1289.             if force_text(val) not in pks:</font>
<font color="red">1290.                 raise ValidationError(</font>
<font color="red">1291.                     self.error_messages['invalid_choice'],</font>
<font color="red">1292.                     code='invalid_choice',</font>
<font color="red">1293.                     params={'value': val},</font>
<font color="black">1294.                 )</font>
<font color="red">1295.         return qs</font>
<font color="black">1296. </font>
<font color="green">1297.     def prepare_value(self, value):</font>
<font color="red">1298.         if (hasattr(value, '__iter__') and</font>
<font color="red">1299.                 not isinstance(value, six.text_type) and</font>
<font color="red">1300.                 not hasattr(value, '_meta')):</font>
<font color="red">1301.             return [super(ModelMultipleChoiceField, self).prepare_value(v) for v in value]</font>
<font color="red">1302.         return super(ModelMultipleChoiceField, self).prepare_value(value)</font>
<font color="black">1303. </font>
<font color="green">1304.     def has_changed(self, initial, data):</font>
<font color="red">1305.         if initial is None:</font>
<font color="red">1306.             initial = []</font>
<font color="red">1307.         if data is None:</font>
<font color="red">1308.             data = []</font>
<font color="red">1309.         if len(initial) != len(data):</font>
<font color="red">1310.             return True</font>
<font color="red">1311.         initial_set = set(force_text(value) for value in self.prepare_value(initial))</font>
<font color="red">1312.         data_set = set(force_text(value) for value in data)</font>
<font color="red">1313.         return data_set != initial_set</font>
<font color="black">1314. </font>
<font color="black">1315. </font>
<font color="green">1316. def modelform_defines_fields(form_class):</font>
<font color="red">1317.     return (form_class is not None and (</font>
<font color="red">1318.             hasattr(form_class, '_meta') and</font>
<font color="red">1319.             (form_class._meta.fields is not None or</font>
<font color="red">1320.              form_class._meta.exclude is not None)</font>
<font color="black">1321.             ))</font>
</pre>

