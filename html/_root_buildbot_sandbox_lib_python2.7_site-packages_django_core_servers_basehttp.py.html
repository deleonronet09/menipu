source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/servers/basehttp.py</b><br>


file stats: <b>112 lines, 31 executed: 27.7% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. HTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21).</font>
<font color="black">   3. </font>
<font color="black">   4. Based on wsgiref.simple_server which is part of the standard library since 2.5.</font>
<font color="black">   5. </font>
<font color="black">   6. This is a simple server for use in testing or debugging Django apps. It hasn't</font>
<font color="black">   7. been reviewed for security issues. DON'T USE IT FOR PRODUCTION USE!</font>
<font color="green">   8. &quot;&quot;&quot;</font>
<font color="black">   9. </font>
<font color="green">  10. from __future__ import unicode_literals</font>
<font color="black">  11. </font>
<font color="green">  12. import socket</font>
<font color="green">  13. import sys</font>
<font color="green">  14. from wsgiref import simple_server</font>
<font color="black">  15. </font>
<font color="green">  16. from django.core.exceptions import ImproperlyConfigured</font>
<font color="green">  17. from django.core.handlers.wsgi import ISO_8859_1, UTF_8</font>
<font color="green">  18. from django.core.management.color import color_style</font>
<font color="green">  19. from django.core.wsgi import get_wsgi_application</font>
<font color="green">  20. from django.utils import six</font>
<font color="green">  21. from django.utils.encoding import uri_to_iri</font>
<font color="green">  22. from django.utils.module_loading import import_string</font>
<font color="green">  23. from django.utils.six.moves import socketserver</font>
<font color="black">  24. </font>
<font color="green">  25. __all__ = ('WSGIServer', 'WSGIRequestHandler')</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="green">  28. def get_internal_wsgi_application():</font>
<font color="black">  29.     &quot;&quot;&quot;</font>
<font color="black">  30.     Loads and returns the WSGI application as configured by the user in</font>
<font color="black">  31.     ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,</font>
<font color="black">  32.     this will be the ``application`` object in ``projectname/wsgi.py``.</font>
<font color="black">  33. </font>
<font color="black">  34.     This function, and the ``WSGI_APPLICATION`` setting itself, are only useful</font>
<font color="black">  35.     for Django's internal server (runserver); external WSGI servers should just</font>
<font color="black">  36.     be configured to point to the correct application object directly.</font>
<font color="black">  37. </font>
<font color="black">  38.     If settings.WSGI_APPLICATION is not set (is ``None``), we just return</font>
<font color="black">  39.     whatever ``django.core.wsgi.get_wsgi_application`` returns.</font>
<font color="black">  40.     &quot;&quot;&quot;</font>
<font color="red">  41.     from django.conf import settings</font>
<font color="red">  42.     app_path = getattr(settings, 'WSGI_APPLICATION')</font>
<font color="red">  43.     if app_path is None:</font>
<font color="red">  44.         return get_wsgi_application()</font>
<font color="black">  45. </font>
<font color="red">  46.     try:</font>
<font color="red">  47.         return import_string(app_path)</font>
<font color="red">  48.     except ImportError as e:</font>
<font color="black">  49.         msg = (</font>
<font color="red">  50.             &quot;WSGI application '%(app_path)s' could not be loaded; &quot;</font>
<font color="red">  51.             &quot;Error importing module: '%(exception)s'&quot; % ({</font>
<font color="red">  52.                 'app_path': app_path,</font>
<font color="red">  53.                 'exception': e,</font>
<font color="black">  54.             })</font>
<font color="black">  55.         )</font>
<font color="red">  56.         six.reraise(ImproperlyConfigured, ImproperlyConfigured(msg),</font>
<font color="red">  57.                     sys.exc_info()[2])</font>
<font color="black">  58. </font>
<font color="black">  59. </font>
<font color="green">  60. def is_broken_pipe_error():</font>
<font color="red">  61.     exc_type, exc_value = sys.exc_info()[:2]</font>
<font color="red">  62.     return issubclass(exc_type, socket.error) and exc_value.args[0] == 32</font>
<font color="black">  63. </font>
<font color="black">  64. </font>
<font color="green">  65. class WSGIServer(simple_server.WSGIServer, object):</font>
<font color="green">  66.     &quot;&quot;&quot;BaseHTTPServer that implements the Python WSGI protocol&quot;&quot;&quot;</font>
<font color="black">  67. </font>
<font color="green">  68.     request_queue_size = 10</font>
<font color="black">  69. </font>
<font color="green">  70.     def __init__(self, *args, **kwargs):</font>
<font color="red">  71.         if kwargs.pop('ipv6', False):</font>
<font color="red">  72.             self.address_family = socket.AF_INET6</font>
<font color="red">  73.         super(WSGIServer, self).__init__(*args, **kwargs)</font>
<font color="black">  74. </font>
<font color="green">  75.     def server_bind(self):</font>
<font color="black">  76.         &quot;&quot;&quot;Override server_bind to store the server name.&quot;&quot;&quot;</font>
<font color="red">  77.         super(WSGIServer, self).server_bind()</font>
<font color="red">  78.         self.setup_environ()</font>
<font color="black">  79. </font>
<font color="green">  80.     def handle_error(self, request, client_address):</font>
<font color="red">  81.         if is_broken_pipe_error():</font>
<font color="red">  82.             sys.stderr.write(&quot;- Broken pipe from %s\n&quot; % (client_address,))</font>
<font color="black">  83.         else:</font>
<font color="red">  84.             super(WSGIServer, self).handle_error(request, client_address)</font>
<font color="black">  85. </font>
<font color="black">  86. </font>
<font color="black">  87. # Inheriting from object required on Python 2.</font>
<font color="green">  88. class ServerHandler(simple_server.ServerHandler, object):</font>
<font color="green">  89.     def handle_error(self):</font>
<font color="black">  90.         # Ignore broken pipe errors, otherwise pass on</font>
<font color="red">  91.         if not is_broken_pipe_error():</font>
<font color="red">  92.             super(ServerHandler, self).handle_error()</font>
<font color="black">  93. </font>
<font color="black">  94. </font>
<font color="green">  95. class WSGIRequestHandler(simple_server.WSGIRequestHandler, object):</font>
<font color="black">  96. </font>
<font color="green">  97.     def __init__(self, *args, **kwargs):</font>
<font color="red">  98.         self.style = color_style()</font>
<font color="red">  99.         super(WSGIRequestHandler, self).__init__(*args, **kwargs)</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def address_string(self):</font>
<font color="black"> 102.         # Short-circuit parent method to not call socket.getfqdn</font>
<font color="red"> 103.         return self.client_address[0]</font>
<font color="black"> 104. </font>
<font color="green"> 105.     def log_message(self, format, *args):</font>
<font color="black"> 106. </font>
<font color="red"> 107.         msg = &quot;[%s] &quot; % self.log_date_time_string()</font>
<font color="red"> 108.         try:</font>
<font color="red"> 109.             msg += &quot;%s\n&quot; % (format % args)</font>
<font color="red"> 110.         except UnicodeDecodeError:</font>
<font color="black"> 111.             # e.g. accessing the server via SSL on Python 2</font>
<font color="red"> 112.             msg += &quot;\n&quot;</font>
<font color="black"> 113. </font>
<font color="black"> 114.         # Utilize terminal colors, if available</font>
<font color="red"> 115.         if args[1][0] == '2':</font>
<font color="black"> 116.             # Put 2XX first, since it should be the common case</font>
<font color="red"> 117.             msg = self.style.HTTP_SUCCESS(msg)</font>
<font color="red"> 118.         elif args[1][0] == '1':</font>
<font color="red"> 119.             msg = self.style.HTTP_INFO(msg)</font>
<font color="red"> 120.         elif args[1] == '304':</font>
<font color="red"> 121.             msg = self.style.HTTP_NOT_MODIFIED(msg)</font>
<font color="red"> 122.         elif args[1][0] == '3':</font>
<font color="red"> 123.             msg = self.style.HTTP_REDIRECT(msg)</font>
<font color="red"> 124.         elif args[1] == '404':</font>
<font color="red"> 125.             msg = self.style.HTTP_NOT_FOUND(msg)</font>
<font color="red"> 126.         elif args[1][0] == '4':</font>
<font color="black"> 127.             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x</font>
<font color="red"> 128.             if args[0].startswith(str('\x16\x03')):</font>
<font color="red"> 129.                 msg = (&quot;You're accessing the development server over HTTPS, &quot;</font>
<font color="black"> 130.                     &quot;but it only supports HTTP.\n&quot;)</font>
<font color="red"> 131.             msg = self.style.HTTP_BAD_REQUEST(msg)</font>
<font color="black"> 132.         else:</font>
<font color="black"> 133.             # Any 5XX, or any other response</font>
<font color="red"> 134.             msg = self.style.HTTP_SERVER_ERROR(msg)</font>
<font color="black"> 135. </font>
<font color="red"> 136.         sys.stderr.write(msg)</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def get_environ(self):</font>
<font color="black"> 139.         # Strip all headers with underscores in the name before constructing</font>
<font color="black"> 140.         # the WSGI environ. This prevents header-spoofing based on ambiguity</font>
<font color="black"> 141.         # between underscores and dashes both normalized to underscores in WSGI</font>
<font color="black"> 142.         # env vars. Nginx and Apache 2.4+ both do this as well.</font>
<font color="red"> 143.         for k, v in self.headers.items():</font>
<font color="red"> 144.             if '_' in k:</font>
<font color="red"> 145.                 del self.headers[k]</font>
<font color="black"> 146. </font>
<font color="red"> 147.         env = super(WSGIRequestHandler, self).get_environ()</font>
<font color="black"> 148. </font>
<font color="red"> 149.         path = self.path</font>
<font color="red"> 150.         if '?' in path:</font>
<font color="red"> 151.             path = path.partition('?')[0]</font>
<font color="black"> 152. </font>
<font color="red"> 153.         path = uri_to_iri(path).encode(UTF_8)</font>
<font color="black"> 154.         # Under Python 3, non-ASCII values in the WSGI environ are arbitrarily</font>
<font color="black"> 155.         # decoded with ISO-8859-1. We replicate this behavior here.</font>
<font color="black"> 156.         # Refs comment in `get_bytes_from_wsgi()`.</font>
<font color="red"> 157.         env['PATH_INFO'] = path.decode(ISO_8859_1) if six.PY3 else path</font>
<font color="black"> 158. </font>
<font color="red"> 159.         return env</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def handle(self):</font>
<font color="black"> 162.         &quot;&quot;&quot;Copy of WSGIRequestHandler, but with different ServerHandler&quot;&quot;&quot;</font>
<font color="black"> 163. </font>
<font color="red"> 164.         self.raw_requestline = self.rfile.readline(65537)</font>
<font color="red"> 165.         if len(self.raw_requestline) &gt; 65536:</font>
<font color="red"> 166.             self.requestline = ''</font>
<font color="red"> 167.             self.request_version = ''</font>
<font color="red"> 168.             self.command = ''</font>
<font color="red"> 169.             self.send_error(414)</font>
<font color="red"> 170.             return</font>
<font color="black"> 171. </font>
<font color="red"> 172.         if not self.parse_request():  # An error code has been sent, just exit</font>
<font color="red"> 173.             return</font>
<font color="black"> 174. </font>
<font color="red"> 175.         handler = ServerHandler(</font>
<font color="red"> 176.             self.rfile, self.wfile, self.get_stderr(), self.get_environ()</font>
<font color="black"> 177.         )</font>
<font color="red"> 178.         handler.request_handler = self      # backpointer for logging</font>
<font color="red"> 179.         handler.run(self.server.get_app())</font>
<font color="black"> 180. </font>
<font color="black"> 181. </font>
<font color="green"> 182. def run(addr, port, wsgi_handler, ipv6=False, threading=False):</font>
<font color="red"> 183.     server_address = (addr, port)</font>
<font color="red"> 184.     if threading:</font>
<font color="red"> 185.         httpd_cls = type(str('WSGIServer'), (socketserver.ThreadingMixIn, WSGIServer), {})</font>
<font color="black"> 186.     else:</font>
<font color="red"> 187.         httpd_cls = WSGIServer</font>
<font color="red"> 188.     httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)</font>
<font color="red"> 189.     if threading:</font>
<font color="black"> 190.         # ThreadingMixIn.daemon_threads indicates how threads will behave on an</font>
<font color="black"> 191.         # abrupt shutdown; like quitting the server by the user or restarting</font>
<font color="black"> 192.         # by the auto-reloader. True means the server will not wait for thread</font>
<font color="black"> 193.         # termination before it quits. This will make auto-reloader faster</font>
<font color="black"> 194.         # and will prevent the need to kill the server manually if a thread</font>
<font color="black"> 195.         # isn't terminating correctly.</font>
<font color="red"> 196.         httpd.daemon_threads = True</font>
<font color="red"> 197.     httpd.set_app(wsgi_handler)</font>
<font color="red"> 198.     httpd.serve_forever()</font>
</pre>

