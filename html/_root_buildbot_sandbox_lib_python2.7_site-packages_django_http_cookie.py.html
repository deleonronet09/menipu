source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/http/cookie.py</b><br>


file stats: <b>63 lines, 23 executed: 36.5% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import sys</font>
<font color="black">   4. </font>
<font color="green">   5. from django.utils import six</font>
<font color="green">   6. from django.utils.encoding import force_str</font>
<font color="green">   7. from django.utils.six.moves import http_cookies</font>
<font color="black">   8. </font>
<font color="black">   9. # Some versions of Python 2.7 and later won't need this encoding bug fix:</font>
<font color="green">  10. _cookie_encodes_correctly = http_cookies.SimpleCookie().value_encode(';') == (';', '&quot;\\073&quot;')</font>
<font color="black">  11. # See ticket #13007, http://bugs.python.org/issue2193 and http://trac.edgewall.org/ticket/2256</font>
<font color="green">  12. _tc = http_cookies.SimpleCookie()</font>
<font color="green">  13. try:</font>
<font color="green">  14.     _tc.load(str('foo:bar=1'))</font>
<font color="red">  15.     _cookie_allows_colon_in_names = True</font>
<font color="green">  16. except http_cookies.CookieError:</font>
<font color="green">  17.     _cookie_allows_colon_in_names = False</font>
<font color="black">  18. </font>
<font color="black">  19. # Cookie pickling bug is fixed in Python 2.7.9 and Python 3.4.3+</font>
<font color="black">  20. # http://bugs.python.org/issue22775</font>
<font color="black">  21. cookie_pickles_properly = (</font>
<font color="green">  22.     (sys.version_info[:2] == (2, 7) and sys.version_info &gt;= (2, 7, 9)) or</font>
<font color="green">  23.     sys.version_info &gt;= (3, 4, 3)</font>
<font color="black">  24. )</font>
<font color="black">  25. </font>
<font color="green">  26. if _cookie_encodes_correctly and _cookie_allows_colon_in_names and cookie_pickles_properly:</font>
<font color="red">  27.     SimpleCookie = http_cookies.SimpleCookie</font>
<font color="black">  28. else:</font>
<font color="green">  29.     Morsel = http_cookies.Morsel</font>
<font color="black">  30. </font>
<font color="green">  31.     class SimpleCookie(http_cookies.SimpleCookie):</font>
<font color="green">  32.         if not cookie_pickles_properly:</font>
<font color="green">  33.             def __setitem__(self, key, value):</font>
<font color="black">  34.                 # Apply the fix from http://bugs.python.org/issue22775 where</font>
<font color="black">  35.                 # it's not fixed in Python itself</font>
<font color="red">  36.                 if isinstance(value, Morsel):</font>
<font color="black">  37.                     # allow assignment of constructed Morsels (e.g. for pickling)</font>
<font color="red">  38.                     dict.__setitem__(self, key, value)</font>
<font color="black">  39.                 else:</font>
<font color="red">  40.                     super(SimpleCookie, self).__setitem__(key, value)</font>
<font color="black">  41. </font>
<font color="green">  42.         if not _cookie_encodes_correctly:</font>
<font color="red">  43.             def value_encode(self, val):</font>
<font color="black">  44.                 # Some browsers do not support quoted-string from RFC 2109,</font>
<font color="black">  45.                 # including some versions of Safari and Internet Explorer.</font>
<font color="black">  46.                 # These browsers split on ';', and some versions of Safari</font>
<font color="black">  47.                 # are known to split on ', '. Therefore, we encode ';' and ','</font>
<font color="black">  48. </font>
<font color="black">  49.                 # SimpleCookie already does the hard work of encoding and decoding.</font>
<font color="black">  50.                 # It uses octal sequences like '\\012' for newline etc.</font>
<font color="black">  51.                 # and non-ASCII chars. We just make use of this mechanism, to</font>
<font color="black">  52.                 # avoid introducing two encoding schemes which would be confusing</font>
<font color="black">  53.                 # and especially awkward for javascript.</font>
<font color="black">  54. </font>
<font color="black">  55.                 # NB, contrary to Python docs, value_encode returns a tuple containing</font>
<font color="black">  56.                 # (real val, encoded_val)</font>
<font color="red">  57.                 val, encoded = super(SimpleCookie, self).value_encode(val)</font>
<font color="black">  58. </font>
<font color="red">  59.                 encoded = encoded.replace(&quot;;&quot;, &quot;\\073&quot;).replace(&quot;,&quot;, &quot;\\054&quot;)</font>
<font color="black">  60.                 # If encoded now contains any quoted chars, we need double quotes</font>
<font color="black">  61.                 # around the whole string.</font>
<font color="red">  62.                 if &quot;\\&quot; in encoded and not encoded.startswith('&quot;'):</font>
<font color="red">  63.                     encoded = '&quot;' + encoded + '&quot;'</font>
<font color="black">  64. </font>
<font color="red">  65.                 return val, encoded</font>
<font color="black">  66. </font>
<font color="green">  67.         if not _cookie_allows_colon_in_names:</font>
<font color="green">  68.             def load(self, rawdata):</font>
<font color="red">  69.                 self.bad_cookies = set()</font>
<font color="red">  70.                 if six.PY2 and isinstance(rawdata, six.text_type):</font>
<font color="red">  71.                     rawdata = force_str(rawdata)</font>
<font color="red">  72.                 super(SimpleCookie, self).load(rawdata)</font>
<font color="red">  73.                 for key in self.bad_cookies:</font>
<font color="red">  74.                     del self[key]</font>
<font color="black">  75. </font>
<font color="black">  76.             # override private __set() method:</font>
<font color="black">  77.             # (needed for using our Morsel, and for laxness with CookieError</font>
<font color="green">  78.             def _BaseCookie__set(self, key, real_value, coded_value):</font>
<font color="red">  79.                 key = force_str(key)</font>
<font color="red">  80.                 try:</font>
<font color="red">  81.                     M = self.get(key, Morsel())</font>
<font color="red">  82.                     M.set(key, real_value, coded_value)</font>
<font color="red">  83.                     dict.__setitem__(self, key, M)</font>
<font color="red">  84.                 except http_cookies.CookieError:</font>
<font color="red">  85.                     if not hasattr(self, 'bad_cookies'):</font>
<font color="red">  86.                         self.bad_cookies = set()</font>
<font color="red">  87.                     self.bad_cookies.add(key)</font>
<font color="red">  88.                     dict.__setitem__(self, key, http_cookies.Morsel())</font>
<font color="black">  89. </font>
<font color="black">  90. </font>
<font color="green">  91. def parse_cookie(cookie):</font>
<font color="red">  92.     if cookie == '':</font>
<font color="red">  93.         return {}</font>
<font color="red">  94.     if not isinstance(cookie, http_cookies.BaseCookie):</font>
<font color="red">  95.         try:</font>
<font color="red">  96.             c = SimpleCookie()</font>
<font color="red">  97.             c.load(cookie)</font>
<font color="red">  98.         except http_cookies.CookieError:</font>
<font color="black">  99.             # Invalid cookie</font>
<font color="red"> 100.             return {}</font>
<font color="black"> 101.     else:</font>
<font color="red"> 102.         c = cookie</font>
<font color="red"> 103.     cookiedict = {}</font>
<font color="red"> 104.     for key in c.keys():</font>
<font color="red"> 105.         cookiedict[key] = c.get(key).value</font>
<font color="red"> 106.     return cookiedict</font>
</pre>

