source file: <b>/usr/lib/python2.7/collections.py</b><br>


file stats: <b>312 lines, 74 executed: 23.7% covered</b>
<pre>
<font color="red">   1. __all__ = ['Counter', 'deque', 'defaultdict', 'namedtuple', 'OrderedDict']</font>
<font color="black">   2. # For bootstrapping reasons, the collection ABCs are defined in _abcoll.py.</font>
<font color="black">   3. # They should however be considered an integral part of collections.py.</font>
<font color="red">   4. from _abcoll import *</font>
<font color="red">   5. import _abcoll</font>
<font color="red">   6. __all__ += _abcoll.__all__</font>
<font color="black">   7. </font>
<font color="red">   8. from _collections import deque, defaultdict</font>
<font color="red">   9. from operator import itemgetter as _itemgetter, eq as _eq</font>
<font color="red">  10. from keyword import iskeyword as _iskeyword</font>
<font color="red">  11. import sys as _sys</font>
<font color="red">  12. import heapq as _heapq</font>
<font color="red">  13. from itertools import repeat as _repeat, chain as _chain, starmap as _starmap</font>
<font color="red">  14. from itertools import imap as _imap</font>
<font color="black">  15. </font>
<font color="red">  16. try:</font>
<font color="red">  17.     from thread import get_ident as _get_ident</font>
<font color="red">  18. except ImportError:</font>
<font color="red">  19.     from dummy_thread import get_ident as _get_ident</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="black">  22. ################################################################################</font>
<font color="black">  23. ### OrderedDict</font>
<font color="black">  24. ################################################################################</font>
<font color="black">  25. </font>
<font color="red">  26. class OrderedDict(dict):</font>
<font color="red">  27.     'Dictionary that remembers insertion order'</font>
<font color="black">  28.     # An inherited dict maps keys to values.</font>
<font color="black">  29.     # The inherited dict provides __getitem__, __len__, __contains__, and get.</font>
<font color="black">  30.     # The remaining methods are order-aware.</font>
<font color="black">  31.     # Big-O running times for all methods are the same as regular dictionaries.</font>
<font color="black">  32. </font>
<font color="black">  33.     # The internal self.__map dict maps keys to links in a doubly linked list.</font>
<font color="black">  34.     # The circular doubly linked list starts and ends with a sentinel element.</font>
<font color="black">  35.     # The sentinel element never gets deleted (this simplifies the algorithm).</font>
<font color="black">  36.     # Each link is stored as a list of length three:  [PREV, NEXT, KEY].</font>
<font color="black">  37. </font>
<font color="red">  38.     def __init__(self, *args, **kwds):</font>
<font color="black">  39.         '''Initialize an ordered dictionary.  The signature is the same as</font>
<font color="black">  40.         regular dictionaries, but keyword arguments are not recommended because</font>
<font color="black">  41.         their insertion order is arbitrary.</font>
<font color="black">  42. </font>
<font color="black">  43.         '''</font>
<font color="green">  44.         if len(args) &gt; 1:</font>
<font color="red">  45.             raise TypeError('expected at most 1 arguments, got %d' % len(args))</font>
<font color="green">  46.         try:</font>
<font color="green">  47.             self.__root</font>
<font color="green">  48.         except AttributeError:</font>
<font color="green">  49.             self.__root = root = []                     # sentinel node</font>
<font color="green">  50.             root[:] = [root, root, None]</font>
<font color="green">  51.             self.__map = {}</font>
<font color="green">  52.         self.__update(*args, **kwds)</font>
<font color="black">  53. </font>
<font color="red">  54.     def __setitem__(self, key, value, dict_setitem=dict.__setitem__):</font>
<font color="black">  55.         'od.__setitem__(i, y) &lt;==&gt; od[i]=y'</font>
<font color="black">  56.         # Setting a new item creates a new link at the end of the linked list,</font>
<font color="black">  57.         # and the inherited dictionary is updated with the new key/value pair.</font>
<font color="green">  58.         if key not in self:</font>
<font color="green">  59.             root = self.__root</font>
<font color="green">  60.             last = root[0]</font>
<font color="green">  61.             last[1] = root[0] = self.__map[key] = [last, root, key]</font>
<font color="green">  62.         return dict_setitem(self, key, value)</font>
<font color="black">  63. </font>
<font color="red">  64.     def __delitem__(self, key, dict_delitem=dict.__delitem__):</font>
<font color="black">  65.         'od.__delitem__(y) &lt;==&gt; del od[y]'</font>
<font color="black">  66.         # Deleting an existing item uses self.__map to find the link which gets</font>
<font color="black">  67.         # removed by updating the links in the predecessor and successor nodes.</font>
<font color="green">  68.         dict_delitem(self, key)</font>
<font color="green">  69.         link_prev, link_next, _ = self.__map.pop(key)</font>
<font color="green">  70.         link_prev[1] = link_next                        # update link_prev[NEXT]</font>
<font color="green">  71.         link_next[0] = link_prev                        # update link_next[PREV]</font>
<font color="black">  72. </font>
<font color="red">  73.     def __iter__(self):</font>
<font color="black">  74.         'od.__iter__() &lt;==&gt; iter(od)'</font>
<font color="black">  75.         # Traverse the linked list in order.</font>
<font color="green">  76.         root = self.__root</font>
<font color="green">  77.         curr = root[1]                                  # start at the first node</font>
<font color="green">  78.         while curr is not root:</font>
<font color="green">  79.             yield curr[2]                               # yield the curr[KEY]</font>
<font color="green">  80.             curr = curr[1]                              # move to next node</font>
<font color="black">  81. </font>
<font color="red">  82.     def __reversed__(self):</font>
<font color="black">  83.         'od.__reversed__() &lt;==&gt; reversed(od)'</font>
<font color="black">  84.         # Traverse the linked list in reverse order.</font>
<font color="red">  85.         root = self.__root</font>
<font color="red">  86.         curr = root[0]                                  # start at the last node</font>
<font color="red">  87.         while curr is not root:</font>
<font color="red">  88.             yield curr[2]                               # yield the curr[KEY]</font>
<font color="red">  89.             curr = curr[0]                              # move to previous node</font>
<font color="black">  90. </font>
<font color="red">  91.     def clear(self):</font>
<font color="black">  92.         'od.clear() -&gt; None.  Remove all items from od.'</font>
<font color="red">  93.         root = self.__root</font>
<font color="red">  94.         root[:] = [root, root, None]</font>
<font color="red">  95.         self.__map.clear()</font>
<font color="red">  96.         dict.clear(self)</font>
<font color="black">  97. </font>
<font color="black">  98.     # -- the following methods do not depend on the internal structure --</font>
<font color="black">  99. </font>
<font color="red"> 100.     def keys(self):</font>
<font color="black"> 101.         'od.keys() -&gt; list of keys in od'</font>
<font color="green"> 102.         return list(self)</font>
<font color="black"> 103. </font>
<font color="red"> 104.     def values(self):</font>
<font color="black"> 105.         'od.values() -&gt; list of values in od'</font>
<font color="green"> 106.         return [self[key] for key in self]</font>
<font color="black"> 107. </font>
<font color="red"> 108.     def items(self):</font>
<font color="black"> 109.         'od.items() -&gt; list of (key, value) pairs in od'</font>
<font color="green"> 110.         return [(key, self[key]) for key in self]</font>
<font color="black"> 111. </font>
<font color="red"> 112.     def iterkeys(self):</font>
<font color="black"> 113.         'od.iterkeys() -&gt; an iterator over the keys in od'</font>
<font color="red"> 114.         return iter(self)</font>
<font color="black"> 115. </font>
<font color="red"> 116.     def itervalues(self):</font>
<font color="black"> 117.         'od.itervalues -&gt; an iterator over the values in od'</font>
<font color="red"> 118.         for k in self:</font>
<font color="red"> 119.             yield self[k]</font>
<font color="black"> 120. </font>
<font color="red"> 121.     def iteritems(self):</font>
<font color="black"> 122.         'od.iteritems -&gt; an iterator over the (key, value) pairs in od'</font>
<font color="green"> 123.         for k in self:</font>
<font color="green"> 124.             yield (k, self[k])</font>
<font color="black"> 125. </font>
<font color="red"> 126.     update = MutableMapping.update</font>
<font color="black"> 127. </font>
<font color="red"> 128.     __update = update # let subclasses override update without breaking __init__</font>
<font color="black"> 129. </font>
<font color="red"> 130.     __marker = object()</font>
<font color="black"> 131. </font>
<font color="red"> 132.     def pop(self, key, default=__marker):</font>
<font color="black"> 133.         '''od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding</font>
<font color="black"> 134.         value.  If key is not found, d is returned if given, otherwise KeyError</font>
<font color="black"> 135.         is raised.</font>
<font color="black"> 136. </font>
<font color="black"> 137.         '''</font>
<font color="red"> 138.         if key in self:</font>
<font color="red"> 139.             result = self[key]</font>
<font color="red"> 140.             del self[key]</font>
<font color="red"> 141.             return result</font>
<font color="red"> 142.         if default is self.__marker:</font>
<font color="red"> 143.             raise KeyError(key)</font>
<font color="red"> 144.         return default</font>
<font color="black"> 145. </font>
<font color="red"> 146.     def setdefault(self, key, default=None):</font>
<font color="black"> 147.         'od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od'</font>
<font color="red"> 148.         if key in self:</font>
<font color="red"> 149.             return self[key]</font>
<font color="red"> 150.         self[key] = default</font>
<font color="red"> 151.         return default</font>
<font color="black"> 152. </font>
<font color="red"> 153.     def popitem(self, last=True):</font>
<font color="black"> 154.         '''od.popitem() -&gt; (k, v), return and remove a (key, value) pair.</font>
<font color="black"> 155.         Pairs are returned in LIFO order if last is true or FIFO order if false.</font>
<font color="black"> 156. </font>
<font color="black"> 157.         '''</font>
<font color="red"> 158.         if not self:</font>
<font color="red"> 159.             raise KeyError('dictionary is empty')</font>
<font color="red"> 160.         key = next(reversed(self) if last else iter(self))</font>
<font color="red"> 161.         value = self.pop(key)</font>
<font color="red"> 162.         return key, value</font>
<font color="black"> 163. </font>
<font color="red"> 164.     def __repr__(self, _repr_running={}):</font>
<font color="black"> 165.         'od.__repr__() &lt;==&gt; repr(od)'</font>
<font color="red"> 166.         call_key = id(self), _get_ident()</font>
<font color="red"> 167.         if call_key in _repr_running:</font>
<font color="red"> 168.             return '...'</font>
<font color="red"> 169.         _repr_running[call_key] = 1</font>
<font color="red"> 170.         try:</font>
<font color="red"> 171.             if not self:</font>
<font color="red"> 172.                 return '%s()' % (self.__class__.__name__,)</font>
<font color="red"> 173.             return '%s(%r)' % (self.__class__.__name__, self.items())</font>
<font color="black"> 174.         finally:</font>
<font color="red"> 175.             del _repr_running[call_key]</font>
<font color="black"> 176. </font>
<font color="red"> 177.     def __reduce__(self):</font>
<font color="black"> 178.         'Return state information for pickling'</font>
<font color="green"> 179.         items = [[k, self[k]] for k in self]</font>
<font color="green"> 180.         inst_dict = vars(self).copy()</font>
<font color="green"> 181.         for k in vars(OrderedDict()):</font>
<font color="green"> 182.             inst_dict.pop(k, None)</font>
<font color="green"> 183.         if inst_dict:</font>
<font color="red"> 184.             return (self.__class__, (items,), inst_dict)</font>
<font color="green"> 185.         return self.__class__, (items,)</font>
<font color="black"> 186. </font>
<font color="red"> 187.     def copy(self):</font>
<font color="black"> 188.         'od.copy() -&gt; a shallow copy of od'</font>
<font color="red"> 189.         return self.__class__(self)</font>
<font color="black"> 190. </font>
<font color="red"> 191.     @classmethod</font>
<font color="red"> 192.     def fromkeys(cls, iterable, value=None):</font>
<font color="black"> 193.         '''OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.</font>
<font color="black"> 194.         If not specified, the value defaults to None.</font>
<font color="black"> 195. </font>
<font color="black"> 196.         '''</font>
<font color="red"> 197.         self = cls()</font>
<font color="red"> 198.         for key in iterable:</font>
<font color="red"> 199.             self[key] = value</font>
<font color="red"> 200.         return self</font>
<font color="black"> 201. </font>
<font color="red"> 202.     def __eq__(self, other):</font>
<font color="black"> 203.         '''od.__eq__(y) &lt;==&gt; od==y.  Comparison to another OD is order-sensitive</font>
<font color="black"> 204.         while comparison to a regular mapping is order-insensitive.</font>
<font color="black"> 205. </font>
<font color="black"> 206.         '''</font>
<font color="red"> 207.         if isinstance(other, OrderedDict):</font>
<font color="red"> 208.             return dict.__eq__(self, other) and all(_imap(_eq, self, other))</font>
<font color="red"> 209.         return dict.__eq__(self, other)</font>
<font color="black"> 210. </font>
<font color="red"> 211.     def __ne__(self, other):</font>
<font color="black"> 212.         'od.__ne__(y) &lt;==&gt; od!=y'</font>
<font color="red"> 213.         return not self == other</font>
<font color="black"> 214. </font>
<font color="black"> 215.     # -- the following methods support python 3.x style dictionary views --</font>
<font color="black"> 216. </font>
<font color="red"> 217.     def viewkeys(self):</font>
<font color="black"> 218.         &quot;od.viewkeys() -&gt; a set-like object providing a view on od's keys&quot;</font>
<font color="red"> 219.         return KeysView(self)</font>
<font color="black"> 220. </font>
<font color="red"> 221.     def viewvalues(self):</font>
<font color="black"> 222.         &quot;od.viewvalues() -&gt; an object providing a view on od's values&quot;</font>
<font color="red"> 223.         return ValuesView(self)</font>
<font color="black"> 224. </font>
<font color="red"> 225.     def viewitems(self):</font>
<font color="black"> 226.         &quot;od.viewitems() -&gt; a set-like object providing a view on od's items&quot;</font>
<font color="red"> 227.         return ItemsView(self)</font>
<font color="black"> 228. </font>
<font color="black"> 229. </font>
<font color="black"> 230. ################################################################################</font>
<font color="black"> 231. ### namedtuple</font>
<font color="black"> 232. ################################################################################</font>
<font color="black"> 233. </font>
<font color="black"> 234. _class_template = '''\</font>
<font color="black"> 235. class {typename}(tuple):</font>
<font color="black"> 236.     '{typename}({arg_list})'</font>
<font color="black"> 237. </font>
<font color="black"> 238.     __slots__ = ()</font>
<font color="black"> 239. </font>
<font color="black"> 240.     _fields = {field_names!r}</font>
<font color="black"> 241. </font>
<font color="black"> 242.     def __new__(_cls, {arg_list}):</font>
<font color="black"> 243.         'Create new instance of {typename}({arg_list})'</font>
<font color="black"> 244.         return _tuple.__new__(_cls, ({arg_list}))</font>
<font color="black"> 245. </font>
<font color="black"> 246.     @classmethod</font>
<font color="black"> 247.     def _make(cls, iterable, new=tuple.__new__, len=len):</font>
<font color="black"> 248.         'Make a new {typename} object from a sequence or iterable'</font>
<font color="black"> 249.         result = new(cls, iterable)</font>
<font color="black"> 250.         if len(result) != {num_fields:d}:</font>
<font color="black"> 251.             raise TypeError('Expected {num_fields:d} arguments, got %d' % len(result))</font>
<font color="black"> 252.         return result</font>
<font color="black"> 253. </font>
<font color="black"> 254.     def __repr__(self):</font>
<font color="black"> 255.         'Return a nicely formatted representation string'</font>
<font color="black"> 256.         return '{typename}({repr_fmt})' % self</font>
<font color="black"> 257. </font>
<font color="black"> 258.     def _asdict(self):</font>
<font color="black"> 259.         'Return a new OrderedDict which maps field names to their values'</font>
<font color="black"> 260.         return OrderedDict(zip(self._fields, self))</font>
<font color="black"> 261. </font>
<font color="black"> 262.     def _replace(_self, **kwds):</font>
<font color="black"> 263.         'Return a new {typename} object replacing specified fields with new values'</font>
<font color="black"> 264.         result = _self._make(map(kwds.pop, {field_names!r}, _self))</font>
<font color="black"> 265.         if kwds:</font>
<font color="black"> 266.             raise ValueError('Got unexpected field names: %r' % kwds.keys())</font>
<font color="black"> 267.         return result</font>
<font color="black"> 268. </font>
<font color="black"> 269.     def __getnewargs__(self):</font>
<font color="black"> 270.         'Return self as a plain tuple.  Used by copy and pickle.'</font>
<font color="black"> 271.         return tuple(self)</font>
<font color="black"> 272. </font>
<font color="black"> 273.     __dict__ = _property(_asdict)</font>
<font color="black"> 274. </font>
<font color="black"> 275.     def __getstate__(self):</font>
<font color="black"> 276.         'Exclude the OrderedDict from pickling'</font>
<font color="black"> 277.         pass</font>
<font color="black"> 278. </font>
<font color="black"> 279. {field_defs}</font>
<font color="red"> 280. '''</font>
<font color="black"> 281. </font>
<font color="red"> 282. _repr_template = '{name}=%r'</font>
<font color="black"> 283. </font>
<font color="black"> 284. _field_template = '''\</font>
<font color="black"> 285.     {name} = _property(_itemgetter({index:d}), doc='Alias for field number {index:d}')</font>
<font color="red"> 286. '''</font>
<font color="black"> 287. </font>
<font color="red"> 288. def namedtuple(typename, field_names, verbose=False, rename=False):</font>
<font color="black"> 289.     &quot;&quot;&quot;Returns a new subclass of tuple with named fields.</font>
<font color="black"> 290. </font>
<font color="black"> 291.     &gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])</font>
<font color="black"> 292.     &gt;&gt;&gt; Point.__doc__                   # docstring for the new class</font>
<font color="black"> 293.     'Point(x, y)'</font>
<font color="black"> 294.     &gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords</font>
<font color="black"> 295.     &gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple</font>
<font color="black"> 296.     33</font>
<font color="black"> 297.     &gt;&gt;&gt; x, y = p                        # unpack like a regular tuple</font>
<font color="black"> 298.     &gt;&gt;&gt; x, y</font>
<font color="black"> 299.     (11, 22)</font>
<font color="black"> 300.     &gt;&gt;&gt; p.x + p.y                       # fields also accessable by name</font>
<font color="black"> 301.     33</font>
<font color="black"> 302.     &gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary</font>
<font color="black"> 303.     &gt;&gt;&gt; d['x']</font>
<font color="black"> 304.     11</font>
<font color="black"> 305.     &gt;&gt;&gt; Point(**d)                      # convert from a dictionary</font>
<font color="black"> 306.     Point(x=11, y=22)</font>
<font color="black"> 307.     &gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields</font>
<font color="black"> 308.     Point(x=100, y=22)</font>
<font color="black"> 309. </font>
<font color="black"> 310.     &quot;&quot;&quot;</font>
<font color="black"> 311. </font>
<font color="black"> 312.     # Validate the field names.  At the user's option, either generate an error</font>
<font color="black"> 313.     # message or automatically replace the field name with a valid name.</font>
<font color="green"> 314.     if isinstance(field_names, basestring):</font>
<font color="green"> 315.         field_names = field_names.replace(',', ' ').split()</font>
<font color="green"> 316.     field_names = map(str, field_names)</font>
<font color="green"> 317.     if rename:</font>
<font color="red"> 318.         seen = set()</font>
<font color="red"> 319.         for index, name in enumerate(field_names):</font>
<font color="red"> 320.             if (not all(c.isalnum() or c=='_' for c in name)</font>
<font color="red"> 321.                 or _iskeyword(name)</font>
<font color="red"> 322.                 or not name</font>
<font color="red"> 323.                 or name[0].isdigit()</font>
<font color="red"> 324.                 or name.startswith('_')</font>
<font color="red"> 325.                 or name in seen):</font>
<font color="red"> 326.                 field_names[index] = '_%d' % index</font>
<font color="red"> 327.             seen.add(name)</font>
<font color="green"> 328.     for name in [typename] + field_names:</font>
<font color="green"> 329.         if not all(c.isalnum() or c=='_' for c in name):</font>
<font color="red"> 330.             raise ValueError('Type names and field names can only contain '</font>
<font color="red"> 331.                              'alphanumeric characters and underscores: %r' % name)</font>
<font color="green"> 332.         if _iskeyword(name):</font>
<font color="red"> 333.             raise ValueError('Type names and field names cannot be a '</font>
<font color="red"> 334.                              'keyword: %r' % name)</font>
<font color="green"> 335.         if name[0].isdigit():</font>
<font color="red"> 336.             raise ValueError('Type names and field names cannot start with '</font>
<font color="red"> 337.                              'a number: %r' % name)</font>
<font color="green"> 338.     seen = set()</font>
<font color="green"> 339.     for name in field_names:</font>
<font color="green"> 340.         if name.startswith('_') and not rename:</font>
<font color="red"> 341.             raise ValueError('Field names cannot start with an underscore: '</font>
<font color="red"> 342.                              '%r' % name)</font>
<font color="green"> 343.         if name in seen:</font>
<font color="red"> 344.             raise ValueError('Encountered duplicate field name: %r' % name)</font>
<font color="green"> 345.         seen.add(name)</font>
<font color="black"> 346. </font>
<font color="black"> 347.     # Fill-in the class template</font>
<font color="green"> 348.     class_definition = _class_template.format(</font>
<font color="green"> 349.         typename = typename,</font>
<font color="green"> 350.         field_names = tuple(field_names),</font>
<font color="green"> 351.         num_fields = len(field_names),</font>
<font color="green"> 352.         arg_list = repr(tuple(field_names)).replace(&quot;'&quot;, &quot;&quot;)[1:-1],</font>
<font color="green"> 353.         repr_fmt = ', '.join(_repr_template.format(name=name)</font>
<font color="green"> 354.                              for name in field_names),</font>
<font color="green"> 355.         field_defs = '\n'.join(_field_template.format(index=index, name=name)</font>
<font color="green"> 356.                                for index, name in enumerate(field_names))</font>
<font color="black"> 357.     )</font>
<font color="green"> 358.     if verbose:</font>
<font color="red"> 359.         print class_definition</font>
<font color="black"> 360. </font>
<font color="black"> 361.     # Execute the template string in a temporary namespace and support</font>
<font color="black"> 362.     # tracing utilities by setting a value for frame.f_globals['__name__']</font>
<font color="green"> 363.     namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,</font>
<font color="green"> 364.                      OrderedDict=OrderedDict, _property=property, _tuple=tuple)</font>
<font color="green"> 365.     try:</font>
<font color="green"> 366.         exec class_definition in namespace</font>
<font color="red"> 367.     except SyntaxError as e:</font>
<font color="red"> 368.         raise SyntaxError(e.message + ':\n' + class_definition)</font>
<font color="green"> 369.     result = namespace[typename]</font>
<font color="black"> 370. </font>
<font color="black"> 371.     # For pickling to work, the __module__ variable needs to be set to the frame</font>
<font color="black"> 372.     # where the named tuple is created.  Bypass this step in environments where</font>
<font color="black"> 373.     # sys._getframe is not defined (Jython for example) or sys._getframe is not</font>
<font color="black"> 374.     # defined for arguments greater than 0 (IronPython).</font>
<font color="green"> 375.     try:</font>
<font color="green"> 376.         result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')</font>
<font color="red"> 377.     except (AttributeError, ValueError):</font>
<font color="red"> 378.         pass</font>
<font color="black"> 379. </font>
<font color="green"> 380.     return result</font>
<font color="black"> 381. </font>
<font color="black"> 382. </font>
<font color="black"> 383. ########################################################################</font>
<font color="black"> 384. ###  Counter</font>
<font color="black"> 385. ########################################################################</font>
<font color="black"> 386. </font>
<font color="red"> 387. class Counter(dict):</font>
<font color="black"> 388.     '''Dict subclass for counting hashable items.  Sometimes called a bag</font>
<font color="black"> 389.     or multiset.  Elements are stored as dictionary keys and their counts</font>
<font color="black"> 390.     are stored as dictionary values.</font>
<font color="black"> 391. </font>
<font color="black"> 392.     &gt;&gt;&gt; c = Counter('abcdeabcdabcaba')  # count elements from a string</font>
<font color="black"> 393. </font>
<font color="black"> 394.     &gt;&gt;&gt; c.most_common(3)                # three most common elements</font>
<font color="black"> 395.     [('a', 5), ('b', 4), ('c', 3)]</font>
<font color="black"> 396.     &gt;&gt;&gt; sorted(c)                       # list all unique elements</font>
<font color="black"> 397.     ['a', 'b', 'c', 'd', 'e']</font>
<font color="black"> 398.     &gt;&gt;&gt; ''.join(sorted(c.elements()))   # list elements with repetitions</font>
<font color="black"> 399.     'aaaaabbbbcccdde'</font>
<font color="black"> 400.     &gt;&gt;&gt; sum(c.values())                 # total of all counts</font>
<font color="black"> 401.     15</font>
<font color="black"> 402. </font>
<font color="black"> 403.     &gt;&gt;&gt; c['a']                          # count of letter 'a'</font>
<font color="black"> 404.     5</font>
<font color="black"> 405.     &gt;&gt;&gt; for elem in 'shazam':           # update counts from an iterable</font>
<font color="black"> 406.     ...     c[elem] += 1                # by adding 1 to each element's count</font>
<font color="black"> 407.     &gt;&gt;&gt; c['a']                          # now there are seven 'a'</font>
<font color="black"> 408.     7</font>
<font color="black"> 409.     &gt;&gt;&gt; del c['b']                      # remove all 'b'</font>
<font color="black"> 410.     &gt;&gt;&gt; c['b']                          # now there are zero 'b'</font>
<font color="black"> 411.     0</font>
<font color="black"> 412. </font>
<font color="black"> 413.     &gt;&gt;&gt; d = Counter('simsalabim')       # make another counter</font>
<font color="black"> 414.     &gt;&gt;&gt; c.update(d)                     # add in the second counter</font>
<font color="black"> 415.     &gt;&gt;&gt; c['a']                          # now there are nine 'a'</font>
<font color="black"> 416.     9</font>
<font color="black"> 417. </font>
<font color="black"> 418.     &gt;&gt;&gt; c.clear()                       # empty the counter</font>
<font color="black"> 419.     &gt;&gt;&gt; c</font>
<font color="black"> 420.     Counter()</font>
<font color="black"> 421. </font>
<font color="black"> 422.     Note:  If a count is set to zero or reduced to zero, it will remain</font>
<font color="black"> 423.     in the counter until the entry is deleted or the counter is cleared:</font>
<font color="black"> 424. </font>
<font color="black"> 425.     &gt;&gt;&gt; c = Counter('aaabbc')</font>
<font color="black"> 426.     &gt;&gt;&gt; c['b'] -= 2                     # reduce the count of 'b' by two</font>
<font color="black"> 427.     &gt;&gt;&gt; c.most_common()                 # 'b' is still in, but its count is zero</font>
<font color="black"> 428.     [('a', 3), ('c', 1), ('b', 0)]</font>
<font color="black"> 429. </font>
<font color="red"> 430.     '''</font>
<font color="black"> 431.     # References:</font>
<font color="black"> 432.     #   http://en.wikipedia.org/wiki/Multiset</font>
<font color="black"> 433.     #   http://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html</font>
<font color="black"> 434.     #   http://www.demo2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm</font>
<font color="black"> 435.     #   http://code.activestate.com/recipes/259174/</font>
<font color="black"> 436.     #   Knuth, TAOCP Vol. II section 4.6.3</font>
<font color="black"> 437. </font>
<font color="red"> 438.     def __init__(self, iterable=None, **kwds):</font>
<font color="black"> 439.         '''Create a new, empty Counter object.  And if given, count elements</font>
<font color="black"> 440.         from an input iterable.  Or, initialize the count from another mapping</font>
<font color="black"> 441.         of elements to their counts.</font>
<font color="black"> 442. </font>
<font color="black"> 443.         &gt;&gt;&gt; c = Counter()                           # a new, empty counter</font>
<font color="black"> 444.         &gt;&gt;&gt; c = Counter('gallahad')                 # a new counter from an iterable</font>
<font color="black"> 445.         &gt;&gt;&gt; c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping</font>
<font color="black"> 446.         &gt;&gt;&gt; c = Counter(a=4, b=2)                   # a new counter from keyword args</font>
<font color="black"> 447. </font>
<font color="black"> 448.         '''</font>
<font color="green"> 449.         super(Counter, self).__init__()</font>
<font color="green"> 450.         self.update(iterable, **kwds)</font>
<font color="black"> 451. </font>
<font color="red"> 452.     def __missing__(self, key):</font>
<font color="black"> 453.         'The count of elements not in the Counter is zero.'</font>
<font color="black"> 454.         # Needed so that self[missing_item] does not raise KeyError</font>
<font color="red"> 455.         return 0</font>
<font color="black"> 456. </font>
<font color="red"> 457.     def most_common(self, n=None):</font>
<font color="black"> 458.         '''List the n most common elements and their counts from the most</font>
<font color="black"> 459.         common to the least.  If n is None, then list all element counts.</font>
<font color="black"> 460. </font>
<font color="black"> 461.         &gt;&gt;&gt; Counter('abcdeabcdabcaba').most_common(3)</font>
<font color="black"> 462.         [('a', 5), ('b', 4), ('c', 3)]</font>
<font color="black"> 463. </font>
<font color="black"> 464.         '''</font>
<font color="black"> 465.         # Emulate Bag.sortedByCount from Smalltalk</font>
<font color="green"> 466.         if n is None:</font>
<font color="green"> 467.             return sorted(self.iteritems(), key=_itemgetter(1), reverse=True)</font>
<font color="red"> 468.         return _heapq.nlargest(n, self.iteritems(), key=_itemgetter(1))</font>
<font color="black"> 469. </font>
<font color="red"> 470.     def elements(self):</font>
<font color="black"> 471.         '''Iterator over elements repeating each as many times as its count.</font>
<font color="black"> 472. </font>
<font color="black"> 473.         &gt;&gt;&gt; c = Counter('ABCABC')</font>
<font color="black"> 474.         &gt;&gt;&gt; sorted(c.elements())</font>
<font color="black"> 475.         ['A', 'A', 'B', 'B', 'C', 'C']</font>
<font color="black"> 476. </font>
<font color="black"> 477.         # Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1</font>
<font color="black"> 478.         &gt;&gt;&gt; prime_factors = Counter({2: 2, 3: 3, 17: 1})</font>
<font color="black"> 479.         &gt;&gt;&gt; product = 1</font>
<font color="black"> 480.         &gt;&gt;&gt; for factor in prime_factors.elements():     # loop over factors</font>
<font color="black"> 481.         ...     product *= factor                       # and multiply them</font>
<font color="black"> 482.         &gt;&gt;&gt; product</font>
<font color="black"> 483.         1836</font>
<font color="black"> 484. </font>
<font color="black"> 485.         Note, if an element's count has been set to zero or is a negative</font>
<font color="black"> 486.         number, elements() will ignore it.</font>
<font color="black"> 487. </font>
<font color="black"> 488.         '''</font>
<font color="black"> 489.         # Emulate Bag.do from Smalltalk and Multiset.begin from C++.</font>
<font color="red"> 490.         return _chain.from_iterable(_starmap(_repeat, self.iteritems()))</font>
<font color="black"> 491. </font>
<font color="black"> 492.     # Override dict methods where necessary</font>
<font color="black"> 493. </font>
<font color="red"> 494.     @classmethod</font>
<font color="red"> 495.     def fromkeys(cls, iterable, v=None):</font>
<font color="black"> 496.         # There is no equivalent method for counters because setting v=1</font>
<font color="black"> 497.         # means that no element can have a count greater than one.</font>
<font color="red"> 498.         raise NotImplementedError(</font>
<font color="red"> 499.             'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')</font>
<font color="black"> 500. </font>
<font color="red"> 501.     def update(self, iterable=None, **kwds):</font>
<font color="black"> 502.         '''Like dict.update() but add counts instead of replacing them.</font>
<font color="black"> 503. </font>
<font color="black"> 504.         Source can be an iterable, a dictionary, or another Counter instance.</font>
<font color="black"> 505. </font>
<font color="black"> 506.         &gt;&gt;&gt; c = Counter('which')</font>
<font color="black"> 507.         &gt;&gt;&gt; c.update('witch')           # add elements from another iterable</font>
<font color="black"> 508.         &gt;&gt;&gt; d = Counter('watch')</font>
<font color="black"> 509.         &gt;&gt;&gt; c.update(d)                 # add elements from another counter</font>
<font color="black"> 510.         &gt;&gt;&gt; c['h']                      # four 'h' in which, witch, and watch</font>
<font color="black"> 511.         4</font>
<font color="black"> 512. </font>
<font color="black"> 513.         '''</font>
<font color="black"> 514.         # The regular dict.update() operation makes no sense here because the</font>
<font color="black"> 515.         # replace behavior results in the some of original untouched counts</font>
<font color="black"> 516.         # being mixed-in with all of the other counts for a mismash that</font>
<font color="black"> 517.         # doesn't have a straight-forward interpretation in most counting</font>
<font color="black"> 518.         # contexts.  Instead, we implement straight-addition.  Both the inputs</font>
<font color="black"> 519.         # and outputs are allowed to contain zero and negative counts.</font>
<font color="black"> 520. </font>
<font color="green"> 521.         if iterable is not None:</font>
<font color="green"> 522.             if isinstance(iterable, Mapping):</font>
<font color="red"> 523.                 if self:</font>
<font color="red"> 524.                     self_get = self.get</font>
<font color="red"> 525.                     for elem, count in iterable.iteritems():</font>
<font color="red"> 526.                         self[elem] = self_get(elem, 0) + count</font>
<font color="black"> 527.                 else:</font>
<font color="red"> 528.                     super(Counter, self).update(iterable) # fast path when counter is empty</font>
<font color="black"> 529.             else:</font>
<font color="green"> 530.                 self_get = self.get</font>
<font color="green"> 531.                 for elem in iterable:</font>
<font color="green"> 532.                     self[elem] = self_get(elem, 0) + 1</font>
<font color="green"> 533.         if kwds:</font>
<font color="red"> 534.             self.update(kwds)</font>
<font color="black"> 535. </font>
<font color="red"> 536.     def subtract(self, iterable=None, **kwds):</font>
<font color="black"> 537.         '''Like dict.update() but subtracts counts instead of replacing them.</font>
<font color="black"> 538.         Counts can be reduced below zero.  Both the inputs and outputs are</font>
<font color="black"> 539.         allowed to contain zero and negative counts.</font>
<font color="black"> 540. </font>
<font color="black"> 541.         Source can be an iterable, a dictionary, or another Counter instance.</font>
<font color="black"> 542. </font>
<font color="black"> 543.         &gt;&gt;&gt; c = Counter('which')</font>
<font color="black"> 544.         &gt;&gt;&gt; c.subtract('witch')             # subtract elements from another iterable</font>
<font color="black"> 545.         &gt;&gt;&gt; c.subtract(Counter('watch'))    # subtract elements from another counter</font>
<font color="black"> 546.         &gt;&gt;&gt; c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch</font>
<font color="black"> 547.         0</font>
<font color="black"> 548.         &gt;&gt;&gt; c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch</font>
<font color="black"> 549.         -1</font>
<font color="black"> 550. </font>
<font color="black"> 551.         '''</font>
<font color="red"> 552.         if iterable is not None:</font>
<font color="red"> 553.             self_get = self.get</font>
<font color="red"> 554.             if isinstance(iterable, Mapping):</font>
<font color="red"> 555.                 for elem, count in iterable.items():</font>
<font color="red"> 556.                     self[elem] = self_get(elem, 0) - count</font>
<font color="black"> 557.             else:</font>
<font color="red"> 558.                 for elem in iterable:</font>
<font color="red"> 559.                     self[elem] = self_get(elem, 0) - 1</font>
<font color="red"> 560.         if kwds:</font>
<font color="red"> 561.             self.subtract(kwds)</font>
<font color="black"> 562. </font>
<font color="red"> 563.     def copy(self):</font>
<font color="black"> 564.         'Return a shallow copy.'</font>
<font color="red"> 565.         return self.__class__(self)</font>
<font color="black"> 566. </font>
<font color="red"> 567.     def __reduce__(self):</font>
<font color="red"> 568.         return self.__class__, (dict(self),)</font>
<font color="black"> 569. </font>
<font color="red"> 570.     def __delitem__(self, elem):</font>
<font color="black"> 571.         'Like dict.__delitem__() but does not raise KeyError for missing values.'</font>
<font color="red"> 572.         if elem in self:</font>
<font color="red"> 573.             super(Counter, self).__delitem__(elem)</font>
<font color="black"> 574. </font>
<font color="red"> 575.     def __repr__(self):</font>
<font color="red"> 576.         if not self:</font>
<font color="red"> 577.             return '%s()' % self.__class__.__name__</font>
<font color="red"> 578.         items = ', '.join(map('%r: %r'.__mod__, self.most_common()))</font>
<font color="red"> 579.         return '%s({%s})' % (self.__class__.__name__, items)</font>
<font color="black"> 580. </font>
<font color="black"> 581.     # Multiset-style mathematical operations discussed in:</font>
<font color="black"> 582.     #       Knuth TAOCP Volume II section 4.6.3 exercise 19</font>
<font color="black"> 583.     #       and at http://en.wikipedia.org/wiki/Multiset</font>
<font color="black"> 584.     #</font>
<font color="black"> 585.     # Outputs guaranteed to only include positive counts.</font>
<font color="black"> 586.     #</font>
<font color="black"> 587.     # To strip negative and zero counts, add-in an empty counter:</font>
<font color="black"> 588.     #       c += Counter()</font>
<font color="black"> 589. </font>
<font color="red"> 590.     def __add__(self, other):</font>
<font color="black"> 591.         '''Add counts from two counters.</font>
<font color="black"> 592. </font>
<font color="black"> 593.         &gt;&gt;&gt; Counter('abbb') + Counter('bcc')</font>
<font color="black"> 594.         Counter({'b': 4, 'c': 2, 'a': 1})</font>
<font color="black"> 595. </font>
<font color="black"> 596.         '''</font>
<font color="red"> 597.         if not isinstance(other, Counter):</font>
<font color="red"> 598.             return NotImplemented</font>
<font color="red"> 599.         result = Counter()</font>
<font color="red"> 600.         for elem, count in self.items():</font>
<font color="red"> 601.             newcount = count + other[elem]</font>
<font color="red"> 602.             if newcount &gt; 0:</font>
<font color="red"> 603.                 result[elem] = newcount</font>
<font color="red"> 604.         for elem, count in other.items():</font>
<font color="red"> 605.             if elem not in self and count &gt; 0:</font>
<font color="red"> 606.                 result[elem] = count</font>
<font color="red"> 607.         return result</font>
<font color="black"> 608. </font>
<font color="red"> 609.     def __sub__(self, other):</font>
<font color="black"> 610.         ''' Subtract count, but keep only results with positive counts.</font>
<font color="black"> 611. </font>
<font color="black"> 612.         &gt;&gt;&gt; Counter('abbbc') - Counter('bccd')</font>
<font color="black"> 613.         Counter({'b': 2, 'a': 1})</font>
<font color="black"> 614. </font>
<font color="black"> 615.         '''</font>
<font color="red"> 616.         if not isinstance(other, Counter):</font>
<font color="red"> 617.             return NotImplemented</font>
<font color="red"> 618.         result = Counter()</font>
<font color="red"> 619.         for elem, count in self.items():</font>
<font color="red"> 620.             newcount = count - other[elem]</font>
<font color="red"> 621.             if newcount &gt; 0:</font>
<font color="red"> 622.                 result[elem] = newcount</font>
<font color="red"> 623.         for elem, count in other.items():</font>
<font color="red"> 624.             if elem not in self and count &lt; 0:</font>
<font color="red"> 625.                 result[elem] = 0 - count</font>
<font color="red"> 626.         return result</font>
<font color="black"> 627. </font>
<font color="red"> 628.     def __or__(self, other):</font>
<font color="black"> 629.         '''Union is the maximum of value in either of the input counters.</font>
<font color="black"> 630. </font>
<font color="black"> 631.         &gt;&gt;&gt; Counter('abbb') | Counter('bcc')</font>
<font color="black"> 632.         Counter({'b': 3, 'c': 2, 'a': 1})</font>
<font color="black"> 633. </font>
<font color="black"> 634.         '''</font>
<font color="red"> 635.         if not isinstance(other, Counter):</font>
<font color="red"> 636.             return NotImplemented</font>
<font color="red"> 637.         result = Counter()</font>
<font color="red"> 638.         for elem, count in self.items():</font>
<font color="red"> 639.             other_count = other[elem]</font>
<font color="red"> 640.             newcount = other_count if count &lt; other_count else count</font>
<font color="red"> 641.             if newcount &gt; 0:</font>
<font color="red"> 642.                 result[elem] = newcount</font>
<font color="red"> 643.         for elem, count in other.items():</font>
<font color="red"> 644.             if elem not in self and count &gt; 0:</font>
<font color="red"> 645.                 result[elem] = count</font>
<font color="red"> 646.         return result</font>
<font color="black"> 647. </font>
<font color="red"> 648.     def __and__(self, other):</font>
<font color="black"> 649.         ''' Intersection is the minimum of corresponding counts.</font>
<font color="black"> 650. </font>
<font color="black"> 651.         &gt;&gt;&gt; Counter('abbb') &amp; Counter('bcc')</font>
<font color="black"> 652.         Counter({'b': 1})</font>
<font color="black"> 653. </font>
<font color="black"> 654.         '''</font>
<font color="red"> 655.         if not isinstance(other, Counter):</font>
<font color="red"> 656.             return NotImplemented</font>
<font color="red"> 657.         result = Counter()</font>
<font color="red"> 658.         for elem, count in self.items():</font>
<font color="red"> 659.             other_count = other[elem]</font>
<font color="red"> 660.             newcount = count if count &lt; other_count else other_count</font>
<font color="red"> 661.             if newcount &gt; 0:</font>
<font color="red"> 662.                 result[elem] = newcount</font>
<font color="red"> 663.         return result</font>
<font color="black"> 664. </font>
<font color="black"> 665. </font>
<font color="red"> 666. if __name__ == '__main__':</font>
<font color="black"> 667.     # verify that instances can be pickled</font>
<font color="red"> 668.     from cPickle import loads, dumps</font>
<font color="red"> 669.     Point = namedtuple('Point', 'x, y', True)</font>
<font color="red"> 670.     p = Point(x=10, y=20)</font>
<font color="red"> 671.     assert p == loads(dumps(p))</font>
<font color="black"> 672. </font>
<font color="black"> 673.     # test and demonstrate ability to override methods</font>
<font color="red"> 674.     class Point(namedtuple('Point', 'x y')):</font>
<font color="red"> 675.         __slots__ = ()</font>
<font color="red"> 676.         @property</font>
<font color="black"> 677.         def hypot(self):</font>
<font color="red"> 678.             return (self.x ** 2 + self.y ** 2) ** 0.5</font>
<font color="red"> 679.         def __str__(self):</font>
<font color="red"> 680.             return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, self.hypot)</font>
<font color="black"> 681. </font>
<font color="red"> 682.     for p in Point(3, 4), Point(14, 5/7.):</font>
<font color="red"> 683.         print p</font>
<font color="black"> 684. </font>
<font color="red"> 685.     class Point(namedtuple('Point', 'x y')):</font>
<font color="red"> 686.         'Point class with optimized _make() and _replace() without error-checking'</font>
<font color="red"> 687.         __slots__ = ()</font>
<font color="red"> 688.         _make = classmethod(tuple.__new__)</font>
<font color="red"> 689.         def _replace(self, _map=map, **kwds):</font>
<font color="red"> 690.             return self._make(_map(kwds.get, ('x', 'y'), self))</font>
<font color="black"> 691. </font>
<font color="red"> 692.     print Point(11, 22)._replace(x=100)</font>
<font color="black"> 693. </font>
<font color="red"> 694.     Point3D = namedtuple('Point3D', Point._fields + ('z',))</font>
<font color="red"> 695.     print Point3D.__doc__</font>
<font color="black"> 696. </font>
<font color="red"> 697.     import doctest</font>
<font color="red"> 698.     TestResults = namedtuple('TestResults', 'failed attempted')</font>
<font color="red"> 699.     print TestResults(*doctest.testmod())</font>
</pre>

