source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/urlresolvers.py</b><br>


file stats: <b>436 lines, 74 executed: 17.0% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. This module converts requested URLs to callback view functions.</font>
<font color="black">   3. </font>
<font color="black">   4. RegexURLResolver is the main class here. Its resolve() method takes a URL (as</font>
<font color="black">   5. a string) and returns a ResolverMatch object which provides access to all</font>
<font color="black">   6. attributes of the resolved URL match.</font>
<font color="green">   7. &quot;&quot;&quot;</font>
<font color="green">   8. from __future__ import unicode_literals</font>
<font color="black">   9. </font>
<font color="green">  10. import functools</font>
<font color="green">  11. import re</font>
<font color="green">  12. import warnings</font>
<font color="green">  13. from importlib import import_module</font>
<font color="green">  14. from threading import local</font>
<font color="black">  15. </font>
<font color="green">  16. from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist</font>
<font color="green">  17. from django.http import Http404</font>
<font color="green">  18. from django.utils import lru_cache, six</font>
<font color="green">  19. from django.utils.datastructures import MultiValueDict</font>
<font color="green">  20. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="green">  21. from django.utils.encoding import force_str, force_text, iri_to_uri</font>
<font color="green">  22. from django.utils.functional import cached_property, lazy</font>
<font color="green">  23. from django.utils.http import RFC3986_SUBDELIMS, urlquote</font>
<font color="green">  24. from django.utils.module_loading import module_has_submodule</font>
<font color="green">  25. from django.utils.regex_helper import normalize</font>
<font color="green">  26. from django.utils.six.moves.urllib.parse import urlsplit, urlunsplit</font>
<font color="green">  27. from django.utils.translation import get_language, override</font>
<font color="black">  28. </font>
<font color="black">  29. # SCRIPT_NAME prefixes for each thread are stored here. If there's no entry for</font>
<font color="black">  30. # the current thread (which is the only one we ever access), it is assumed to</font>
<font color="black">  31. # be empty.</font>
<font color="green">  32. _prefixes = local()</font>
<font color="black">  33. </font>
<font color="black">  34. # Overridden URLconfs for each thread are stored here.</font>
<font color="green">  35. _urlconfs = local()</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. class ResolverMatch(object):</font>
<font color="green">  39.     def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None):</font>
<font color="red">  40.         self.func = func</font>
<font color="red">  41.         self.args = args</font>
<font color="red">  42.         self.kwargs = kwargs</font>
<font color="red">  43.         self.url_name = url_name</font>
<font color="black">  44. </font>
<font color="black">  45.         # If a URLRegexResolver doesn't have a namespace or app_name, it passes</font>
<font color="black">  46.         # in an empty value.</font>
<font color="red">  47.         self.app_names = [x for x in app_names if x] if app_names else []</font>
<font color="red">  48.         self.app_name = ':'.join(self.app_names)</font>
<font color="black">  49. </font>
<font color="red">  50.         if namespaces:</font>
<font color="red">  51.             self.namespaces = [x for x in namespaces if x]</font>
<font color="black">  52.         else:</font>
<font color="red">  53.             self.namespaces = []</font>
<font color="red">  54.         self.namespace = ':'.join(self.namespaces)</font>
<font color="black">  55. </font>
<font color="red">  56.         if not hasattr(func, '__name__'):</font>
<font color="black">  57.             # A class-based view</font>
<font color="red">  58.             self._func_path = '.'.join([func.__class__.__module__, func.__class__.__name__])</font>
<font color="black">  59.         else:</font>
<font color="black">  60.             # A function-based view</font>
<font color="red">  61.             self._func_path = '.'.join([func.__module__, func.__name__])</font>
<font color="black">  62. </font>
<font color="red">  63.         view_path = url_name or self._func_path</font>
<font color="red">  64.         self.view_name = ':'.join(self.namespaces + [view_path])</font>
<font color="black">  65. </font>
<font color="green">  66.     def __getitem__(self, index):</font>
<font color="red">  67.         return (self.func, self.args, self.kwargs)[index]</font>
<font color="black">  68. </font>
<font color="green">  69.     def __repr__(self):</font>
<font color="red">  70.         return &quot;ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s)&quot; % (</font>
<font color="red">  71.             self._func_path, self.args, self.kwargs, self.url_name, self.app_names, self.namespaces)</font>
<font color="black">  72. </font>
<font color="black">  73. </font>
<font color="green">  74. class Resolver404(Http404):</font>
<font color="green">  75.     pass</font>
<font color="black">  76. </font>
<font color="black">  77. </font>
<font color="green">  78. class NoReverseMatch(Exception):</font>
<font color="green">  79.     pass</font>
<font color="black">  80. </font>
<font color="black">  81. </font>
<font color="green">  82. @lru_cache.lru_cache(maxsize=None)</font>
<font color="green">  83. def get_callable(lookup_view, can_fail=False):</font>
<font color="black">  84.     &quot;&quot;&quot;</font>
<font color="black">  85.     Return a callable corresponding to lookup_view. This function is used</font>
<font color="black">  86.     by both resolve() and reverse(), so can_fail allows the caller to choose</font>
<font color="black">  87.     between returning the input as is and raising an exception when the input</font>
<font color="black">  88.     string can't be interpreted as an import path.</font>
<font color="black">  89. </font>
<font color="black">  90.     If lookup_view is already a callable, return it.</font>
<font color="black">  91.     If lookup_view is a string import path that can be resolved to a callable,</font>
<font color="black">  92.       import that callable and return it.</font>
<font color="black">  93.     If lookup_view is some other kind of string and can_fail is True, the string</font>
<font color="black">  94.       is returned as is. If can_fail is False, an exception is raised (either</font>
<font color="black">  95.       ImportError or ViewDoesNotExist).</font>
<font color="black">  96.     &quot;&quot;&quot;</font>
<font color="red">  97.     if callable(lookup_view):</font>
<font color="red">  98.         return lookup_view</font>
<font color="black">  99. </font>
<font color="red"> 100.     if not isinstance(lookup_view, six.string_types):</font>
<font color="red"> 101.         raise ViewDoesNotExist(</font>
<font color="red"> 102.             &quot;'%s' is not a callable or a dot-notation path&quot; % lookup_view</font>
<font color="black"> 103.         )</font>
<font color="black"> 104. </font>
<font color="red"> 105.     mod_name, func_name = get_mod_func(lookup_view)</font>
<font color="red"> 106.     if not func_name:  # No '.' in lookup_view</font>
<font color="red"> 107.         if can_fail:</font>
<font color="red"> 108.             return lookup_view</font>
<font color="black"> 109.         else:</font>
<font color="red"> 110.             raise ImportError(</font>
<font color="red"> 111.                 &quot;Could not import '%s'. The path must be fully qualified.&quot; %</font>
<font color="red"> 112.                 lookup_view)</font>
<font color="black"> 113. </font>
<font color="red"> 114.     try:</font>
<font color="red"> 115.         mod = import_module(mod_name)</font>
<font color="red"> 116.     except ImportError:</font>
<font color="red"> 117.         if can_fail:</font>
<font color="red"> 118.             return lookup_view</font>
<font color="black"> 119.         else:</font>
<font color="red"> 120.             parentmod, submod = get_mod_func(mod_name)</font>
<font color="red"> 121.             if submod and not module_has_submodule(import_module(parentmod), submod):</font>
<font color="red"> 122.                 raise ViewDoesNotExist(</font>
<font color="red"> 123.                     &quot;Could not import '%s'. Parent module %s does not exist.&quot; %</font>
<font color="red"> 124.                     (lookup_view, mod_name))</font>
<font color="black"> 125.             else:</font>
<font color="red"> 126.                 raise</font>
<font color="black"> 127.     else:</font>
<font color="red"> 128.         try:</font>
<font color="red"> 129.             view_func = getattr(mod, func_name)</font>
<font color="red"> 130.         except AttributeError:</font>
<font color="red"> 131.             if can_fail:</font>
<font color="red"> 132.                 return lookup_view</font>
<font color="black"> 133.             else:</font>
<font color="red"> 134.                 raise ViewDoesNotExist(</font>
<font color="red"> 135.                     &quot;Could not import '%s'. View does not exist in module %s.&quot; %</font>
<font color="red"> 136.                     (lookup_view, mod_name))</font>
<font color="black"> 137.         else:</font>
<font color="red"> 138.             if not callable(view_func):</font>
<font color="black"> 139.                 # For backwards compatibility this is raised regardless of can_fail</font>
<font color="red"> 140.                 raise ViewDoesNotExist(</font>
<font color="red"> 141.                     &quot;Could not import '%s.%s'. View is not callable.&quot; %</font>
<font color="red"> 142.                     (mod_name, func_name))</font>
<font color="black"> 143. </font>
<font color="red"> 144.             return view_func</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. @lru_cache.lru_cache(maxsize=None)</font>
<font color="green"> 148. def get_resolver(urlconf=None):</font>
<font color="red"> 149.     if urlconf is None:</font>
<font color="red"> 150.         from django.conf import settings</font>
<font color="red"> 151.         urlconf = settings.ROOT_URLCONF</font>
<font color="red"> 152.     return RegexURLResolver(r'^/', urlconf)</font>
<font color="black"> 153. </font>
<font color="black"> 154. </font>
<font color="green"> 155. @lru_cache.lru_cache(maxsize=None)</font>
<font color="black"> 156. def get_ns_resolver(ns_pattern, resolver):</font>
<font color="black"> 157.     # Build a namespaced resolver for the given parent URLconf pattern.</font>
<font color="black"> 158.     # This makes it possible to have captured parameters in the parent</font>
<font color="black"> 159.     # URLconf pattern.</font>
<font color="red"> 160.     ns_resolver = RegexURLResolver(ns_pattern, resolver.url_patterns)</font>
<font color="red"> 161.     return RegexURLResolver(r'^/', [ns_resolver])</font>
<font color="black"> 162. </font>
<font color="black"> 163. </font>
<font color="green"> 164. def get_mod_func(callback):</font>
<font color="black"> 165.     # Converts 'django.views.news.stories.story_detail' to</font>
<font color="black"> 166.     # ['django.views.news.stories', 'story_detail']</font>
<font color="red"> 167.     try:</font>
<font color="red"> 168.         dot = callback.rindex('.')</font>
<font color="red"> 169.     except ValueError:</font>
<font color="red"> 170.         return callback, ''</font>
<font color="red"> 171.     return callback[:dot], callback[dot + 1:]</font>
<font color="black"> 172. </font>
<font color="black"> 173. </font>
<font color="green"> 174. class LocaleRegexProvider(object):</font>
<font color="black"> 175.     &quot;&quot;&quot;</font>
<font color="black"> 176.     A mixin to provide a default regex property which can vary by active</font>
<font color="black"> 177.     language.</font>
<font color="green"> 178.     &quot;&quot;&quot;</font>
<font color="green"> 179.     def __init__(self, regex):</font>
<font color="black"> 180.         # regex is either a string representing a regular expression, or a</font>
<font color="black"> 181.         # translatable string (using ugettext_lazy) representing a regular</font>
<font color="black"> 182.         # expression.</font>
<font color="red"> 183.         self._regex = regex</font>
<font color="red"> 184.         self._regex_dict = {}</font>
<font color="black"> 185. </font>
<font color="green"> 186.     @property</font>
<font color="black"> 187.     def regex(self):</font>
<font color="black"> 188.         &quot;&quot;&quot;</font>
<font color="black"> 189.         Returns a compiled regular expression, depending upon the activated</font>
<font color="black"> 190.         language-code.</font>
<font color="black"> 191.         &quot;&quot;&quot;</font>
<font color="red"> 192.         language_code = get_language()</font>
<font color="red"> 193.         if language_code not in self._regex_dict:</font>
<font color="red"> 194.             if isinstance(self._regex, six.string_types):</font>
<font color="red"> 195.                 regex = self._regex</font>
<font color="black"> 196.             else:</font>
<font color="red"> 197.                 regex = force_text(self._regex)</font>
<font color="red"> 198.             try:</font>
<font color="red"> 199.                 compiled_regex = re.compile(regex, re.UNICODE)</font>
<font color="red"> 200.             except re.error as e:</font>
<font color="red"> 201.                 raise ImproperlyConfigured(</font>
<font color="red"> 202.                     '&quot;%s&quot; is not a valid regular expression: %s' %</font>
<font color="red"> 203.                     (regex, six.text_type(e)))</font>
<font color="black"> 204. </font>
<font color="red"> 205.             self._regex_dict[language_code] = compiled_regex</font>
<font color="red"> 206.         return self._regex_dict[language_code]</font>
<font color="black"> 207. </font>
<font color="black"> 208. </font>
<font color="green"> 209. class RegexURLPattern(LocaleRegexProvider):</font>
<font color="green"> 210.     def __init__(self, regex, callback, default_args=None, name=None):</font>
<font color="red"> 211.         LocaleRegexProvider.__init__(self, regex)</font>
<font color="black"> 212.         # callback is either a string like 'foo.views.news.stories.story_detail'</font>
<font color="black"> 213.         # which represents the path to a module and a view function name, or a</font>
<font color="black"> 214.         # callable object (view).</font>
<font color="red"> 215.         if callable(callback):</font>
<font color="red"> 216.             self._callback = callback</font>
<font color="black"> 217.         else:</font>
<font color="red"> 218.             self._callback = None</font>
<font color="red"> 219.             self._callback_str = callback</font>
<font color="red"> 220.         self.default_args = default_args or {}</font>
<font color="red"> 221.         self.name = name</font>
<font color="black"> 222. </font>
<font color="green"> 223.     def __repr__(self):</font>
<font color="red"> 224.         return force_str('&lt;%s %s %s&gt;' % (self.__class__.__name__, self.name, self.regex.pattern))</font>
<font color="black"> 225. </font>
<font color="green"> 226.     def add_prefix(self, prefix):</font>
<font color="black"> 227.         &quot;&quot;&quot;</font>
<font color="black"> 228.         Adds the prefix string to a string-based callback.</font>
<font color="black"> 229.         &quot;&quot;&quot;</font>
<font color="red"> 230.         if not prefix or not hasattr(self, '_callback_str'):</font>
<font color="red"> 231.             return</font>
<font color="red"> 232.         self._callback_str = prefix + '.' + self._callback_str</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def resolve(self, path):</font>
<font color="red"> 235.         match = self.regex.search(path)</font>
<font color="red"> 236.         if match:</font>
<font color="black"> 237.             # If there are any named groups, use those as kwargs, ignoring</font>
<font color="black"> 238.             # non-named groups. Otherwise, pass all non-named arguments as</font>
<font color="black"> 239.             # positional arguments.</font>
<font color="red"> 240.             kwargs = match.groupdict()</font>
<font color="red"> 241.             if kwargs:</font>
<font color="red"> 242.                 args = ()</font>
<font color="black"> 243.             else:</font>
<font color="red"> 244.                 args = match.groups()</font>
<font color="black"> 245.             # In both cases, pass any extra_kwargs as **kwargs.</font>
<font color="red"> 246.             kwargs.update(self.default_args)</font>
<font color="black"> 247. </font>
<font color="red"> 248.             return ResolverMatch(self.callback, args, kwargs, self.name)</font>
<font color="black"> 249. </font>
<font color="green"> 250.     @property</font>
<font color="black"> 251.     def callback(self):</font>
<font color="red"> 252.         if self._callback is not None:</font>
<font color="red"> 253.             return self._callback</font>
<font color="black"> 254. </font>
<font color="red"> 255.         self._callback = get_callable(self._callback_str)</font>
<font color="red"> 256.         return self._callback</font>
<font color="black"> 257. </font>
<font color="black"> 258. </font>
<font color="green"> 259. class RegexURLResolver(LocaleRegexProvider):</font>
<font color="green"> 260.     def __init__(self, regex, urlconf_name, default_kwargs=None, app_name=None, namespace=None):</font>
<font color="red"> 261.         LocaleRegexProvider.__init__(self, regex)</font>
<font color="black"> 262.         # urlconf_name is the dotted Python path to the module defining</font>
<font color="black"> 263.         # urlpatterns. It may also be an object with an urlpatterns attribute</font>
<font color="black"> 264.         # or urlpatterns itself.</font>
<font color="red"> 265.         self.urlconf_name = urlconf_name</font>
<font color="red"> 266.         self.callback = None</font>
<font color="red"> 267.         self.default_kwargs = default_kwargs or {}</font>
<font color="red"> 268.         self.namespace = namespace</font>
<font color="red"> 269.         self.app_name = app_name</font>
<font color="red"> 270.         self._reverse_dict = {}</font>
<font color="red"> 271.         self._namespace_dict = {}</font>
<font color="red"> 272.         self._app_dict = {}</font>
<font color="black"> 273.         # set of dotted paths to all functions and classes that are used in</font>
<font color="black"> 274.         # urlpatterns</font>
<font color="red"> 275.         self._callback_strs = set()</font>
<font color="red"> 276.         self._populated = False</font>
<font color="black"> 277. </font>
<font color="green"> 278.     def __repr__(self):</font>
<font color="red"> 279.         if isinstance(self.urlconf_name, list) and len(self.urlconf_name):</font>
<font color="black"> 280.             # Don't bother to output the whole list, it can be huge</font>
<font color="red"> 281.             urlconf_repr = '&lt;%s list&gt;' % self.urlconf_name[0].__class__.__name__</font>
<font color="black"> 282.         else:</font>
<font color="red"> 283.             urlconf_repr = repr(self.urlconf_name)</font>
<font color="red"> 284.         return str('&lt;%s %s (%s:%s) %s&gt;') % (</font>
<font color="red"> 285.             self.__class__.__name__, urlconf_repr, self.app_name,</font>
<font color="red"> 286.             self.namespace, self.regex.pattern)</font>
<font color="black"> 287. </font>
<font color="green"> 288.     def _populate(self):</font>
<font color="red"> 289.         lookups = MultiValueDict()</font>
<font color="red"> 290.         namespaces = {}</font>
<font color="red"> 291.         apps = {}</font>
<font color="red"> 292.         language_code = get_language()</font>
<font color="red"> 293.         for pattern in reversed(self.url_patterns):</font>
<font color="red"> 294.             if hasattr(pattern, '_callback_str'):</font>
<font color="red"> 295.                 self._callback_strs.add(pattern._callback_str)</font>
<font color="red"> 296.             elif hasattr(pattern, '_callback'):</font>
<font color="red"> 297.                 callback = pattern._callback</font>
<font color="red"> 298.                 if isinstance(callback, functools.partial):</font>
<font color="red"> 299.                     callback = callback.func</font>
<font color="black"> 300. </font>
<font color="red"> 301.                 if not hasattr(callback, '__name__'):</font>
<font color="red"> 302.                     lookup_str = callback.__module__ + &quot;.&quot; + callback.__class__.__name__</font>
<font color="black"> 303.                 else:</font>
<font color="red"> 304.                     lookup_str = callback.__module__ + &quot;.&quot; + callback.__name__</font>
<font color="red"> 305.                 self._callback_strs.add(lookup_str)</font>
<font color="red"> 306.             p_pattern = pattern.regex.pattern</font>
<font color="red"> 307.             if p_pattern.startswith('^'):</font>
<font color="red"> 308.                 p_pattern = p_pattern[1:]</font>
<font color="red"> 309.             if isinstance(pattern, RegexURLResolver):</font>
<font color="red"> 310.                 if pattern.namespace:</font>
<font color="red"> 311.                     namespaces[pattern.namespace] = (p_pattern, pattern)</font>
<font color="red"> 312.                     if pattern.app_name:</font>
<font color="red"> 313.                         apps.setdefault(pattern.app_name, []).append(pattern.namespace)</font>
<font color="black"> 314.                 else:</font>
<font color="red"> 315.                     parent_pat = pattern.regex.pattern</font>
<font color="red"> 316.                     for name in pattern.reverse_dict:</font>
<font color="red"> 317.                         for matches, pat, defaults in pattern.reverse_dict.getlist(name):</font>
<font color="red"> 318.                             new_matches = normalize(parent_pat + pat)</font>
<font color="red"> 319.                             lookups.appendlist(</font>
<font color="red"> 320.                                 name,</font>
<font color="black"> 321.                                 (</font>
<font color="red"> 322.                                     new_matches,</font>
<font color="red"> 323.                                     p_pattern + pat,</font>
<font color="red"> 324.                                     dict(defaults, **pattern.default_kwargs),</font>
<font color="black"> 325.                                 )</font>
<font color="black"> 326.                             )</font>
<font color="red"> 327.                     for namespace, (prefix, sub_pattern) in pattern.namespace_dict.items():</font>
<font color="red"> 328.                         namespaces[namespace] = (p_pattern + prefix, sub_pattern)</font>
<font color="red"> 329.                     for app_name, namespace_list in pattern.app_dict.items():</font>
<font color="red"> 330.                         apps.setdefault(app_name, []).extend(namespace_list)</font>
<font color="red"> 331.                     self._callback_strs.update(pattern._callback_strs)</font>
<font color="black"> 332.             else:</font>
<font color="red"> 333.                 bits = normalize(p_pattern)</font>
<font color="red"> 334.                 lookups.appendlist(pattern.callback, (bits, p_pattern, pattern.default_args))</font>
<font color="red"> 335.                 if pattern.name is not None:</font>
<font color="red"> 336.                     lookups.appendlist(pattern.name, (bits, p_pattern, pattern.default_args))</font>
<font color="red"> 337.         self._reverse_dict[language_code] = lookups</font>
<font color="red"> 338.         self._namespace_dict[language_code] = namespaces</font>
<font color="red"> 339.         self._app_dict[language_code] = apps</font>
<font color="red"> 340.         self._populated = True</font>
<font color="black"> 341. </font>
<font color="green"> 342.     @property</font>
<font color="black"> 343.     def reverse_dict(self):</font>
<font color="red"> 344.         language_code = get_language()</font>
<font color="red"> 345.         if language_code not in self._reverse_dict:</font>
<font color="red"> 346.             self._populate()</font>
<font color="red"> 347.         return self._reverse_dict[language_code]</font>
<font color="black"> 348. </font>
<font color="green"> 349.     @property</font>
<font color="black"> 350.     def namespace_dict(self):</font>
<font color="red"> 351.         language_code = get_language()</font>
<font color="red"> 352.         if language_code not in self._namespace_dict:</font>
<font color="red"> 353.             self._populate()</font>
<font color="red"> 354.         return self._namespace_dict[language_code]</font>
<font color="black"> 355. </font>
<font color="green"> 356.     @property</font>
<font color="black"> 357.     def app_dict(self):</font>
<font color="red"> 358.         language_code = get_language()</font>
<font color="red"> 359.         if language_code not in self._app_dict:</font>
<font color="red"> 360.             self._populate()</font>
<font color="red"> 361.         return self._app_dict[language_code]</font>
<font color="black"> 362. </font>
<font color="green"> 363.     def _is_callback(self, name):</font>
<font color="red"> 364.         if not self._populated:</font>
<font color="red"> 365.             self._populate()</font>
<font color="red"> 366.         return name in self._callback_strs</font>
<font color="black"> 367. </font>
<font color="green"> 368.     def resolve(self, path):</font>
<font color="red"> 369.         path = force_text(path)  # path may be a reverse_lazy object</font>
<font color="red"> 370.         tried = []</font>
<font color="red"> 371.         match = self.regex.search(path)</font>
<font color="red"> 372.         if match:</font>
<font color="red"> 373.             new_path = path[match.end():]</font>
<font color="red"> 374.             for pattern in self.url_patterns:</font>
<font color="red"> 375.                 try:</font>
<font color="red"> 376.                     sub_match = pattern.resolve(new_path)</font>
<font color="red"> 377.                 except Resolver404 as e:</font>
<font color="red"> 378.                     sub_tried = e.args[0].get('tried')</font>
<font color="red"> 379.                     if sub_tried is not None:</font>
<font color="red"> 380.                         tried.extend([pattern] + t for t in sub_tried)</font>
<font color="black"> 381.                     else:</font>
<font color="red"> 382.                         tried.append([pattern])</font>
<font color="black"> 383.                 else:</font>
<font color="red"> 384.                     if sub_match:</font>
<font color="black"> 385.                         # Merge captured arguments in match with submatch</font>
<font color="red"> 386.                         sub_match_dict = dict(match.groupdict(), **self.default_kwargs)</font>
<font color="red"> 387.                         sub_match_dict.update(sub_match.kwargs)</font>
<font color="black"> 388. </font>
<font color="black"> 389.                         # If there are *any* named groups, ignore all non-named groups.</font>
<font color="black"> 390.                         # Otherwise, pass all non-named arguments as positional arguments.</font>
<font color="red"> 391.                         sub_match_args = sub_match.args</font>
<font color="red"> 392.                         if not sub_match_dict:</font>
<font color="red"> 393.                             sub_match_args = match.groups() + sub_match.args</font>
<font color="black"> 394. </font>
<font color="red"> 395.                         return ResolverMatch(</font>
<font color="red"> 396.                             sub_match.func,</font>
<font color="red"> 397.                             sub_match_args,</font>
<font color="red"> 398.                             sub_match_dict,</font>
<font color="red"> 399.                             sub_match.url_name,</font>
<font color="red"> 400.                             [self.app_name] + sub_match.app_names,</font>
<font color="red"> 401.                             [self.namespace] + sub_match.namespaces</font>
<font color="black"> 402.                         )</font>
<font color="red"> 403.                     tried.append([pattern])</font>
<font color="red"> 404.             raise Resolver404({'tried': tried, 'path': new_path})</font>
<font color="red"> 405.         raise Resolver404({'path': path})</font>
<font color="black"> 406. </font>
<font color="green"> 407.     @cached_property</font>
<font color="black"> 408.     def urlconf_module(self):</font>
<font color="red"> 409.         if isinstance(self.urlconf_name, six.string_types):</font>
<font color="red"> 410.             return import_module(self.urlconf_name)</font>
<font color="black"> 411.         else:</font>
<font color="red"> 412.             return self.urlconf_name</font>
<font color="black"> 413. </font>
<font color="green"> 414.     @cached_property</font>
<font color="black"> 415.     def url_patterns(self):</font>
<font color="black"> 416.         # urlconf_module might be a valid set of patterns, so we default to it</font>
<font color="red"> 417.         patterns = getattr(self.urlconf_module, &quot;urlpatterns&quot;, self.urlconf_module)</font>
<font color="red"> 418.         try:</font>
<font color="red"> 419.             iter(patterns)</font>
<font color="red"> 420.         except TypeError:</font>
<font color="black"> 421.             msg = (</font>
<font color="red"> 422.                 &quot;The included URLconf '{name}' does not appear to have any &quot;</font>
<font color="black"> 423.                 &quot;patterns in it. If you see valid patterns in the file then &quot;</font>
<font color="black"> 424.                 &quot;the issue is probably caused by a circular import.&quot;</font>
<font color="black"> 425.             )</font>
<font color="red"> 426.             raise ImproperlyConfigured(msg.format(name=self.urlconf_name))</font>
<font color="red"> 427.         return patterns</font>
<font color="black"> 428. </font>
<font color="green"> 429.     def resolve_error_handler(self, view_type):</font>
<font color="red"> 430.         callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)</font>
<font color="red"> 431.         if not callback:</font>
<font color="black"> 432.             # No handler specified in file; use default</font>
<font color="black"> 433.             # Lazy import, since django.urls imports this file</font>
<font color="red"> 434.             from django.conf import urls</font>
<font color="red"> 435.             callback = getattr(urls, 'handler%s' % view_type)</font>
<font color="red"> 436.         return get_callable(callback), {}</font>
<font color="black"> 437. </font>
<font color="green"> 438.     def reverse(self, lookup_view, *args, **kwargs):</font>
<font color="red"> 439.         return self._reverse_with_prefix(lookup_view, '', *args, **kwargs)</font>
<font color="black"> 440. </font>
<font color="green"> 441.     def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):</font>
<font color="red"> 442.         if args and kwargs:</font>
<font color="red"> 443.             raise ValueError(&quot;Don't mix *args and **kwargs in call to reverse()!&quot;)</font>
<font color="red"> 444.         text_args = [force_text(v) for v in args]</font>
<font color="red"> 445.         text_kwargs = {k: force_text(v) for (k, v) in kwargs.items()}</font>
<font color="black"> 446. </font>
<font color="red"> 447.         if not self._populated:</font>
<font color="red"> 448.             self._populate()</font>
<font color="black"> 449. </font>
<font color="red"> 450.         original_lookup = lookup_view</font>
<font color="red"> 451.         try:</font>
<font color="red"> 452.             if self._is_callback(lookup_view):</font>
<font color="red"> 453.                 lookup_view = get_callable(lookup_view, True)</font>
<font color="red"> 454.         except (ImportError, AttributeError) as e:</font>
<font color="red"> 455.             raise NoReverseMatch(&quot;Error importing '%s': %s.&quot; % (lookup_view, e))</font>
<font color="black"> 456.         else:</font>
<font color="red"> 457.             if not callable(original_lookup) and callable(lookup_view):</font>
<font color="red"> 458.                 warnings.warn(</font>
<font color="red"> 459.                     'Reversing by dotted path is deprecated (%s).' % original_lookup,</font>
<font color="red"> 460.                     RemovedInDjango110Warning, stacklevel=3</font>
<font color="black"> 461.                 )</font>
<font color="red"> 462.         possibilities = self.reverse_dict.getlist(lookup_view)</font>
<font color="black"> 463. </font>
<font color="red"> 464.         for possibility, pattern, defaults in possibilities:</font>
<font color="red"> 465.             for result, params in possibility:</font>
<font color="red"> 466.                 if args:</font>
<font color="red"> 467.                     if len(args) != len(params):</font>
<font color="red"> 468.                         continue</font>
<font color="red"> 469.                     candidate_subs = dict(zip(params, text_args))</font>
<font color="black"> 470.                 else:</font>
<font color="red"> 471.                     if (set(kwargs.keys()) | set(defaults.keys()) != set(params) |</font>
<font color="red"> 472.                             set(defaults.keys())):</font>
<font color="red"> 473.                         continue</font>
<font color="red"> 474.                     matches = True</font>
<font color="red"> 475.                     for k, v in defaults.items():</font>
<font color="red"> 476.                         if kwargs.get(k, v) != v:</font>
<font color="red"> 477.                             matches = False</font>
<font color="red"> 478.                             break</font>
<font color="red"> 479.                     if not matches:</font>
<font color="red"> 480.                         continue</font>
<font color="red"> 481.                     candidate_subs = text_kwargs</font>
<font color="black"> 482.                 # WSGI provides decoded URLs, without %xx escapes, and the URL</font>
<font color="black"> 483.                 # resolver operates on such URLs. First substitute arguments</font>
<font color="black"> 484.                 # without quoting to build a decoded URL and look for a match.</font>
<font color="black"> 485.                 # Then, if we have a match, redo the substitution with quoted</font>
<font color="black"> 486.                 # arguments in order to return a properly encoded URL.</font>
<font color="red"> 487.                 candidate_pat = _prefix.replace('%', '%%') + result</font>
<font color="red"> 488.                 if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % candidate_subs, re.UNICODE):</font>
<font color="black"> 489.                     # safe characters from `pchar` definition of RFC 3986</font>
<font color="red"> 490.                     url = urlquote(candidate_pat % candidate_subs, safe=RFC3986_SUBDELIMS + str('/~:@'))</font>
<font color="black"> 491.                     # Don't allow construction of scheme relative urls.</font>
<font color="red"> 492.                     if url.startswith('//'):</font>
<font color="red"> 493.                         url = '/%%2F%s' % url[2:]</font>
<font color="red"> 494.                     return url</font>
<font color="black"> 495.         # lookup_view can be URL label, or dotted path, or callable, Any of</font>
<font color="black"> 496.         # these can be passed in at the top, but callables are not friendly in</font>
<font color="black"> 497.         # error messages.</font>
<font color="red"> 498.         m = getattr(lookup_view, '__module__', None)</font>
<font color="red"> 499.         n = getattr(lookup_view, '__name__', None)</font>
<font color="red"> 500.         if m is not None and n is not None:</font>
<font color="red"> 501.             lookup_view_s = &quot;%s.%s&quot; % (m, n)</font>
<font color="black"> 502.         else:</font>
<font color="red"> 503.             lookup_view_s = lookup_view</font>
<font color="black"> 504. </font>
<font color="red"> 505.         patterns = [pattern for (possibility, pattern, defaults) in possibilities]</font>
<font color="red"> 506.         raise NoReverseMatch(&quot;Reverse for '%s' with arguments '%s' and keyword &quot;</font>
<font color="black"> 507.                 &quot;arguments '%s' not found. %d pattern(s) tried: %s&quot; %</font>
<font color="red"> 508.                              (lookup_view_s, args, kwargs, len(patterns), patterns))</font>
<font color="black"> 509. </font>
<font color="black"> 510. </font>
<font color="green"> 511. class LocaleRegexURLResolver(RegexURLResolver):</font>
<font color="black"> 512.     &quot;&quot;&quot;</font>
<font color="black"> 513.     A URL resolver that always matches the active language code as URL prefix.</font>
<font color="black"> 514. </font>
<font color="black"> 515.     Rather than taking a regex argument, we just override the ``regex``</font>
<font color="black"> 516.     function to always return the active language-code as regex.</font>
<font color="green"> 517.     &quot;&quot;&quot;</font>
<font color="green"> 518.     def __init__(self, urlconf_name, default_kwargs=None, app_name=None, namespace=None):</font>
<font color="red"> 519.         super(LocaleRegexURLResolver, self).__init__(</font>
<font color="red"> 520.             None, urlconf_name, default_kwargs, app_name, namespace)</font>
<font color="black"> 521. </font>
<font color="green"> 522.     @property</font>
<font color="black"> 523.     def regex(self):</font>
<font color="red"> 524.         language_code = get_language()</font>
<font color="red"> 525.         if language_code not in self._regex_dict:</font>
<font color="red"> 526.             regex_compiled = re.compile('^%s/' % language_code, re.UNICODE)</font>
<font color="red"> 527.             self._regex_dict[language_code] = regex_compiled</font>
<font color="red"> 528.         return self._regex_dict[language_code]</font>
<font color="black"> 529. </font>
<font color="black"> 530. </font>
<font color="green"> 531. def resolve(path, urlconf=None):</font>
<font color="red"> 532.     if urlconf is None:</font>
<font color="red"> 533.         urlconf = get_urlconf()</font>
<font color="red"> 534.     return get_resolver(urlconf).resolve(path)</font>
<font color="black"> 535. </font>
<font color="black"> 536. </font>
<font color="green"> 537. def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):</font>
<font color="red"> 538.     if urlconf is None:</font>
<font color="red"> 539.         urlconf = get_urlconf()</font>
<font color="red"> 540.     resolver = get_resolver(urlconf)</font>
<font color="red"> 541.     args = args or []</font>
<font color="red"> 542.     kwargs = kwargs or {}</font>
<font color="black"> 543. </font>
<font color="red"> 544.     prefix = get_script_prefix()</font>
<font color="black"> 545. </font>
<font color="red"> 546.     if not isinstance(viewname, six.string_types):</font>
<font color="red"> 547.         view = viewname</font>
<font color="black"> 548.     else:</font>
<font color="red"> 549.         parts = viewname.split(':')</font>
<font color="red"> 550.         parts.reverse()</font>
<font color="red"> 551.         view = parts[0]</font>
<font color="red"> 552.         path = parts[1:]</font>
<font color="black"> 553. </font>
<font color="red"> 554.         if current_app:</font>
<font color="red"> 555.             current_path = current_app.split(':')</font>
<font color="red"> 556.             current_path.reverse()</font>
<font color="black"> 557.         else:</font>
<font color="red"> 558.             current_path = None</font>
<font color="black"> 559. </font>
<font color="red"> 560.         resolved_path = []</font>
<font color="red"> 561.         ns_pattern = ''</font>
<font color="red"> 562.         while path:</font>
<font color="red"> 563.             ns = path.pop()</font>
<font color="red"> 564.             current_ns = current_path.pop() if current_path else None</font>
<font color="black"> 565. </font>
<font color="black"> 566.             # Lookup the name to see if it could be an app identifier</font>
<font color="red"> 567.             try:</font>
<font color="red"> 568.                 app_list = resolver.app_dict[ns]</font>
<font color="black"> 569.                 # Yes! Path part matches an app in the current Resolver</font>
<font color="red"> 570.                 if current_ns and current_ns in app_list:</font>
<font color="black"> 571.                     # If we are reversing for a particular app,</font>
<font color="black"> 572.                     # use that namespace</font>
<font color="red"> 573.                     ns = current_ns</font>
<font color="red"> 574.                 elif ns not in app_list:</font>
<font color="black"> 575.                     # The name isn't shared by one of the instances</font>
<font color="black"> 576.                     # (i.e., the default) so just pick the first instance</font>
<font color="black"> 577.                     # as the default.</font>
<font color="red"> 578.                     ns = app_list[0]</font>
<font color="red"> 579.             except KeyError:</font>
<font color="red"> 580.                 pass</font>
<font color="black"> 581. </font>
<font color="red"> 582.             if ns != current_ns:</font>
<font color="red"> 583.                 current_path = None</font>
<font color="black"> 584. </font>
<font color="red"> 585.             try:</font>
<font color="red"> 586.                 extra, resolver = resolver.namespace_dict[ns]</font>
<font color="red"> 587.                 resolved_path.append(ns)</font>
<font color="red"> 588.                 ns_pattern = ns_pattern + extra</font>
<font color="red"> 589.             except KeyError as key:</font>
<font color="red"> 590.                 if resolved_path:</font>
<font color="red"> 591.                     raise NoReverseMatch(</font>
<font color="red"> 592.                         &quot;%s is not a registered namespace inside '%s'&quot; %</font>
<font color="red"> 593.                         (key, ':'.join(resolved_path)))</font>
<font color="black"> 594.                 else:</font>
<font color="red"> 595.                     raise NoReverseMatch(&quot;%s is not a registered namespace&quot; %</font>
<font color="red"> 596.                                          key)</font>
<font color="red"> 597.         if ns_pattern:</font>
<font color="red"> 598.             resolver = get_ns_resolver(ns_pattern, resolver)</font>
<font color="black"> 599. </font>
<font color="red"> 600.     return force_text(iri_to_uri(resolver._reverse_with_prefix(view, prefix, *args, **kwargs)))</font>
<font color="black"> 601. </font>
<font color="green"> 602. reverse_lazy = lazy(reverse, six.text_type)</font>
<font color="black"> 603. </font>
<font color="black"> 604. </font>
<font color="green"> 605. def clear_url_caches():</font>
<font color="red"> 606.     get_callable.cache_clear()</font>
<font color="red"> 607.     get_resolver.cache_clear()</font>
<font color="red"> 608.     get_ns_resolver.cache_clear()</font>
<font color="black"> 609. </font>
<font color="black"> 610. </font>
<font color="green"> 611. def set_script_prefix(prefix):</font>
<font color="black"> 612.     &quot;&quot;&quot;</font>
<font color="black"> 613.     Sets the script prefix for the current thread.</font>
<font color="black"> 614.     &quot;&quot;&quot;</font>
<font color="red"> 615.     if not prefix.endswith('/'):</font>
<font color="red"> 616.         prefix += '/'</font>
<font color="red"> 617.     _prefixes.value = prefix</font>
<font color="black"> 618. </font>
<font color="black"> 619. </font>
<font color="green"> 620. def get_script_prefix():</font>
<font color="black"> 621.     &quot;&quot;&quot;</font>
<font color="black"> 622.     Returns the currently active script prefix. Useful for client code that</font>
<font color="black"> 623.     wishes to construct their own URLs manually (although accessing the request</font>
<font color="black"> 624.     instance is normally going to be a lot cleaner).</font>
<font color="black"> 625.     &quot;&quot;&quot;</font>
<font color="red"> 626.     return getattr(_prefixes, &quot;value&quot;, '/')</font>
<font color="black"> 627. </font>
<font color="black"> 628. </font>
<font color="green"> 629. def clear_script_prefix():</font>
<font color="black"> 630.     &quot;&quot;&quot;</font>
<font color="black"> 631.     Unsets the script prefix for the current thread.</font>
<font color="black"> 632.     &quot;&quot;&quot;</font>
<font color="red"> 633.     try:</font>
<font color="red"> 634.         del _prefixes.value</font>
<font color="red"> 635.     except AttributeError:</font>
<font color="red"> 636.         pass</font>
<font color="black"> 637. </font>
<font color="black"> 638. </font>
<font color="green"> 639. def set_urlconf(urlconf_name):</font>
<font color="black"> 640.     &quot;&quot;&quot;</font>
<font color="black"> 641.     Sets the URLconf for the current thread (overriding the default one in</font>
<font color="black"> 642.     settings). Set to None to revert back to the default.</font>
<font color="black"> 643.     &quot;&quot;&quot;</font>
<font color="red"> 644.     if urlconf_name:</font>
<font color="red"> 645.         _urlconfs.value = urlconf_name</font>
<font color="black"> 646.     else:</font>
<font color="red"> 647.         if hasattr(_urlconfs, &quot;value&quot;):</font>
<font color="red"> 648.             del _urlconfs.value</font>
<font color="black"> 649. </font>
<font color="black"> 650. </font>
<font color="green"> 651. def get_urlconf(default=None):</font>
<font color="black"> 652.     &quot;&quot;&quot;</font>
<font color="black"> 653.     Returns the root URLconf to use for the current thread if it has been</font>
<font color="black"> 654.     changed from the default one.</font>
<font color="black"> 655.     &quot;&quot;&quot;</font>
<font color="red"> 656.     return getattr(_urlconfs, &quot;value&quot;, default)</font>
<font color="black"> 657. </font>
<font color="black"> 658. </font>
<font color="green"> 659. def is_valid_path(path, urlconf=None):</font>
<font color="black"> 660.     &quot;&quot;&quot;</font>
<font color="black"> 661.     Returns True if the given path resolves against the default URL resolver,</font>
<font color="black"> 662.     False otherwise.</font>
<font color="black"> 663. </font>
<font color="black"> 664.     This is a convenience method to make working with &quot;is this a match?&quot; cases</font>
<font color="black"> 665.     easier, avoiding unnecessarily indented try...except blocks.</font>
<font color="black"> 666.     &quot;&quot;&quot;</font>
<font color="red"> 667.     try:</font>
<font color="red"> 668.         resolve(path, urlconf)</font>
<font color="red"> 669.         return True</font>
<font color="red"> 670.     except Resolver404:</font>
<font color="red"> 671.         return False</font>
<font color="black"> 672. </font>
<font color="black"> 673. </font>
<font color="green"> 674. def translate_url(url, lang_code):</font>
<font color="black"> 675.     &quot;&quot;&quot;</font>
<font color="black"> 676.     Given a URL (absolute or relative), try to get its translated version in</font>
<font color="black"> 677.     the `lang_code` language (either by i18n_patterns or by translated regex).</font>
<font color="black"> 678.     Return the original URL if no translated version is found.</font>
<font color="black"> 679.     &quot;&quot;&quot;</font>
<font color="red"> 680.     parsed = urlsplit(url)</font>
<font color="red"> 681.     try:</font>
<font color="red"> 682.         match = resolve(parsed.path)</font>
<font color="red"> 683.     except Resolver404:</font>
<font color="red"> 684.         pass</font>
<font color="black"> 685.     else:</font>
<font color="red"> 686.         to_be_reversed = &quot;%s:%s&quot; % (match.namespace, match.url_name) if match.namespace else match.url_name</font>
<font color="red"> 687.         with override(lang_code):</font>
<font color="red"> 688.             try:</font>
<font color="red"> 689.                 url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs)</font>
<font color="red"> 690.             except NoReverseMatch:</font>
<font color="red"> 691.                 pass</font>
<font color="black"> 692.             else:</font>
<font color="red"> 693.                 url = urlunsplit((parsed.scheme, parsed.netloc, url, parsed.query, parsed.fragment))</font>
<font color="red"> 694.     return url</font>
</pre>

