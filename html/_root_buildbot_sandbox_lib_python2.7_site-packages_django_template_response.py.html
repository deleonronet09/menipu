source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/template/response.py</b><br>


file stats: <b>106 lines, 31 executed: 29.2% covered</b>
<pre>
<font color="green">   1. import warnings</font>
<font color="black">   2. </font>
<font color="green">   3. from django.http import HttpResponse</font>
<font color="green">   4. from django.utils import six</font>
<font color="green">   5. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="black">   6. </font>
<font color="green">   7. from .backends.django import Template as BackendTemplate</font>
<font color="green">   8. from .base import Template</font>
<font color="green">   9. from .context import Context, RequestContext, _current_app_undefined</font>
<font color="green">  10. from .loader import get_template, select_template</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class ContentNotRenderedError(Exception):</font>
<font color="green">  14.     pass</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. class SimpleTemplateResponse(HttpResponse):</font>
<font color="green">  18.     rendering_attrs = ['template_name', 'context_data', '_post_render_callbacks']</font>
<font color="black">  19. </font>
<font color="green">  20.     def __init__(self, template, context=None, content_type=None, status=None,</font>
<font color="green">  21.                  charset=None, using=None):</font>
<font color="red">  22.         if isinstance(template, Template):</font>
<font color="red">  23.             warnings.warn(</font>
<font color="red">  24.                 &quot;{}'s template argument cannot be a django.template.Template &quot;</font>
<font color="black">  25.                 &quot;anymore. It may be a backend-specific template like those &quot;</font>
<font color="red">  26.                 &quot;created by get_template().&quot;.format(self.__class__.__name__),</font>
<font color="red">  27.                 RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red">  28.             template = BackendTemplate(template)</font>
<font color="black">  29. </font>
<font color="black">  30.         # It would seem obvious to call these next two members 'template' and</font>
<font color="black">  31.         # 'context', but those names are reserved as part of the test Client</font>
<font color="black">  32.         # API. To avoid the name collision, we use different names.</font>
<font color="red">  33.         self.template_name = template</font>
<font color="red">  34.         self.context_data = context</font>
<font color="black">  35. </font>
<font color="red">  36.         self.using = using</font>
<font color="black">  37. </font>
<font color="red">  38.         self._post_render_callbacks = []</font>
<font color="black">  39. </font>
<font color="black">  40.         # _request stores the current request object in subclasses that know</font>
<font color="black">  41.         # about requests, like TemplateResponse. It's defined in the base class</font>
<font color="black">  42.         # to minimize code duplication.</font>
<font color="black">  43.         # It's called self._request because self.request gets overwritten by</font>
<font color="black">  44.         # django.test.client.Client. Unlike template_name and context_data,</font>
<font color="black">  45.         # _request should not be considered part of the public API.</font>
<font color="red">  46.         self._request = None</font>
<font color="black">  47. </font>
<font color="black">  48.         # content argument doesn't make sense here because it will be replaced</font>
<font color="black">  49.         # with rendered template so we always pass empty string in order to</font>
<font color="black">  50.         # prevent errors and provide shorter signature.</font>
<font color="red">  51.         super(SimpleTemplateResponse, self).__init__('', content_type, status, charset)</font>
<font color="black">  52. </font>
<font color="black">  53.         # _is_rendered tracks whether the template and context has been baked</font>
<font color="black">  54.         # into a final response.</font>
<font color="black">  55.         # Super __init__ doesn't know any better than to set self.content to</font>
<font color="black">  56.         # the empty string we just gave it, which wrongly sets _is_rendered</font>
<font color="black">  57.         # True, so we initialize it to False after the call to super __init__.</font>
<font color="red">  58.         self._is_rendered = False</font>
<font color="black">  59. </font>
<font color="green">  60.     def __getstate__(self):</font>
<font color="black">  61.         &quot;&quot;&quot;Pickling support function.</font>
<font color="black">  62. </font>
<font color="black">  63.         Ensures that the object can't be pickled before it has been</font>
<font color="black">  64.         rendered, and that the pickled state only includes rendered</font>
<font color="black">  65.         data, not the data used to construct the response.</font>
<font color="black">  66.         &quot;&quot;&quot;</font>
<font color="red">  67.         obj_dict = self.__dict__.copy()</font>
<font color="red">  68.         if not self._is_rendered:</font>
<font color="red">  69.             raise ContentNotRenderedError('The response content must be '</font>
<font color="black">  70.                                           'rendered before it can be pickled.')</font>
<font color="red">  71.         for attr in self.rendering_attrs:</font>
<font color="red">  72.             if attr in obj_dict:</font>
<font color="red">  73.                 del obj_dict[attr]</font>
<font color="black">  74. </font>
<font color="red">  75.         return obj_dict</font>
<font color="black">  76. </font>
<font color="green">  77.     def resolve_template(self, template):</font>
<font color="black">  78.         &quot;Accepts a template object, path-to-template or list of paths&quot;</font>
<font color="red">  79.         if isinstance(template, (list, tuple)):</font>
<font color="red">  80.             return select_template(template, using=self.using)</font>
<font color="red">  81.         elif isinstance(template, six.string_types):</font>
<font color="red">  82.             return get_template(template, using=self.using)</font>
<font color="black">  83.         else:</font>
<font color="red">  84.             return template</font>
<font color="black">  85. </font>
<font color="green">  86.     def _resolve_template(self, template):</font>
<font color="black">  87.         # This wrapper deprecates returning a django.template.Template in</font>
<font color="black">  88.         # subclasses that override resolve_template. It can be removed in</font>
<font color="black">  89.         # Django 1.10.</font>
<font color="red">  90.         new_template = self.resolve_template(template)</font>
<font color="red">  91.         if isinstance(new_template, Template):</font>
<font color="red">  92.             warnings.warn(</font>
<font color="red">  93.                 &quot;{}.resolve_template() must return a backend-specific &quot;</font>
<font color="black">  94.                 &quot;template like those created by get_template(), not a &quot;</font>
<font color="black">  95.                 &quot;{}.&quot;.format(</font>
<font color="red">  96.                     self.__class__.__name__, new_template.__class__.__name__),</font>
<font color="red">  97.                 RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red">  98.             new_template = BackendTemplate(new_template)</font>
<font color="red">  99.         return new_template</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def resolve_context(self, context):</font>
<font color="red"> 102.         return context</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def _resolve_context(self, context):</font>
<font color="black"> 105.         # This wrapper deprecates returning a Context or a RequestContext in</font>
<font color="black"> 106.         # subclasses that override resolve_context. It can be removed in</font>
<font color="black"> 107.         # Django 1.10. If returning a Context or a RequestContext works by</font>
<font color="black"> 108.         # accident, it won't be an issue per se, but it won't be officially</font>
<font color="black"> 109.         # supported either.</font>
<font color="red"> 110.         new_context = self.resolve_context(context)</font>
<font color="red"> 111.         if isinstance(new_context, RequestContext) and self._request is None:</font>
<font color="red"> 112.             self._request = new_context.request</font>
<font color="red"> 113.         if isinstance(new_context, Context):</font>
<font color="red"> 114.             warnings.warn(</font>
<font color="red"> 115.                 &quot;{}.resolve_context() must return a dict, not a {}.&quot;.format(</font>
<font color="red"> 116.                     self.__class__.__name__, new_context.__class__.__name__),</font>
<font color="red"> 117.                 RemovedInDjango110Warning, stacklevel=2)</font>
<font color="black"> 118.             # It would be tempting to do new_context = new_context.flatten()</font>
<font color="black"> 119.             # here but that would cause template context processors to run for</font>
<font color="black"> 120.             # TemplateResponse(request, template, Context({})), which would be</font>
<font color="black"> 121.             # backwards-incompatible. As a consequence another deprecation</font>
<font color="black"> 122.             # warning will be raised when rendering the template. There isn't</font>
<font color="black"> 123.             # much we can do about that.</font>
<font color="red"> 124.         return new_context</font>
<font color="black"> 125. </font>
<font color="green"> 126.     @property</font>
<font color="black"> 127.     def rendered_content(self):</font>
<font color="black"> 128.         &quot;&quot;&quot;Returns the freshly rendered content for the template and context</font>
<font color="black"> 129.         described by the TemplateResponse.</font>
<font color="black"> 130. </font>
<font color="black"> 131.         This *does not* set the final content of the response. To set the</font>
<font color="black"> 132.         response content, you must either call render(), or set the</font>
<font color="black"> 133.         content explicitly using the value of this property.</font>
<font color="black"> 134.         &quot;&quot;&quot;</font>
<font color="red"> 135.         template = self._resolve_template(self.template_name)</font>
<font color="red"> 136.         context = self._resolve_context(self.context_data)</font>
<font color="red"> 137.         content = template.render(context, self._request)</font>
<font color="red"> 138.         return content</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def add_post_render_callback(self, callback):</font>
<font color="black"> 141.         &quot;&quot;&quot;Adds a new post-rendering callback.</font>
<font color="black"> 142. </font>
<font color="black"> 143.         If the response has already been rendered,</font>
<font color="black"> 144.         invoke the callback immediately.</font>
<font color="black"> 145.         &quot;&quot;&quot;</font>
<font color="red"> 146.         if self._is_rendered:</font>
<font color="red"> 147.             callback(self)</font>
<font color="black"> 148.         else:</font>
<font color="red"> 149.             self._post_render_callbacks.append(callback)</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def render(self):</font>
<font color="black"> 152.         &quot;&quot;&quot;Renders (thereby finalizing) the content of the response.</font>
<font color="black"> 153. </font>
<font color="black"> 154.         If the content has already been rendered, this is a no-op.</font>
<font color="black"> 155. </font>
<font color="black"> 156.         Returns the baked response instance.</font>
<font color="black"> 157.         &quot;&quot;&quot;</font>
<font color="red"> 158.         retval = self</font>
<font color="red"> 159.         if not self._is_rendered:</font>
<font color="red"> 160.             self.content = self.rendered_content</font>
<font color="red"> 161.             for post_callback in self._post_render_callbacks:</font>
<font color="red"> 162.                 newretval = post_callback(retval)</font>
<font color="red"> 163.                 if newretval is not None:</font>
<font color="red"> 164.                     retval = newretval</font>
<font color="red"> 165.         return retval</font>
<font color="black"> 166. </font>
<font color="green"> 167.     @property</font>
<font color="black"> 168.     def is_rendered(self):</font>
<font color="red"> 169.         return self._is_rendered</font>
<font color="black"> 170. </font>
<font color="green"> 171.     def __iter__(self):</font>
<font color="red"> 172.         if not self._is_rendered:</font>
<font color="red"> 173.             raise ContentNotRenderedError('The response content must be '</font>
<font color="black"> 174.                                           'rendered before it can be iterated over.')</font>
<font color="red"> 175.         return super(SimpleTemplateResponse, self).__iter__()</font>
<font color="black"> 176. </font>
<font color="green"> 177.     @property</font>
<font color="black"> 178.     def content(self):</font>
<font color="red"> 179.         if not self._is_rendered:</font>
<font color="red"> 180.             raise ContentNotRenderedError('The response content must be '</font>
<font color="black"> 181.                                           'rendered before it can be accessed.')</font>
<font color="red"> 182.         return super(SimpleTemplateResponse, self).content</font>
<font color="black"> 183. </font>
<font color="green"> 184.     @content.setter</font>
<font color="black"> 185.     def content(self, value):</font>
<font color="black"> 186.         &quot;&quot;&quot;Sets the content for the response</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="red"> 188.         HttpResponse.content.fset(self, value)</font>
<font color="red"> 189.         self._is_rendered = True</font>
<font color="black"> 190. </font>
<font color="black"> 191. </font>
<font color="green"> 192. class TemplateResponse(SimpleTemplateResponse):</font>
<font color="green"> 193.     rendering_attrs = SimpleTemplateResponse.rendering_attrs + ['_request', '_current_app']</font>
<font color="black"> 194. </font>
<font color="green"> 195.     def __init__(self, request, template, context=None, content_type=None,</font>
<font color="green"> 196.             status=None, current_app=_current_app_undefined, charset=None,</font>
<font color="green"> 197.             using=None):</font>
<font color="black"> 198.         # As a convenience we'll allow callers to provide current_app without</font>
<font color="black"> 199.         # having to avoid needing to create the RequestContext directly</font>
<font color="red"> 200.         if current_app is not _current_app_undefined:</font>
<font color="red"> 201.             warnings.warn(</font>
<font color="red"> 202.                 &quot;The current_app argument of TemplateResponse is deprecated. &quot;</font>
<font color="black"> 203.                 &quot;Set the current_app attribute of its request instead.&quot;,</font>
<font color="red"> 204.                 RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 205.             request.current_app = current_app</font>
<font color="red"> 206.         super(TemplateResponse, self).__init__(</font>
<font color="red"> 207.             template, context, content_type, status, charset, using)</font>
<font color="red"> 208.         self._request = request</font>
</pre>

