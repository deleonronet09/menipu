source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/base/features.py</b><br>


file stats: <b>100 lines, 82 executed: 82.0% covered</b>
<pre>
<font color="green">   1. from django.db.models.aggregates import StdDev</font>
<font color="green">   2. from django.db.utils import ProgrammingError</font>
<font color="green">   3. from django.utils.functional import cached_property</font>
<font color="black">   4. </font>
<font color="black">   5. </font>
<font color="green">   6. class BaseDatabaseFeatures(object):</font>
<font color="green">   7.     gis_enabled = False</font>
<font color="green">   8.     allows_group_by_pk = False</font>
<font color="green">   9.     allows_group_by_selected_pks = False</font>
<font color="green">  10.     empty_fetchmany_value = []</font>
<font color="green">  11.     update_can_self_select = True</font>
<font color="black">  12. </font>
<font color="black">  13.     # Does the backend distinguish between '' and None?</font>
<font color="green">  14.     interprets_empty_strings_as_nulls = False</font>
<font color="black">  15. </font>
<font color="black">  16.     # Does the backend allow inserting duplicate NULL rows in a nullable</font>
<font color="black">  17.     # unique field? All core backends implement this correctly, but other</font>
<font color="black">  18.     # databases such as SQL Server do not.</font>
<font color="green">  19.     supports_nullable_unique_constraints = True</font>
<font color="black">  20. </font>
<font color="black">  21.     # Does the backend allow inserting duplicate rows when a unique_together</font>
<font color="black">  22.     # constraint exists and some fields are nullable but not all of them?</font>
<font color="green">  23.     supports_partially_nullable_unique_constraints = True</font>
<font color="black">  24. </font>
<font color="green">  25.     can_use_chunked_reads = True</font>
<font color="green">  26.     can_return_id_from_insert = False</font>
<font color="green">  27.     has_bulk_insert = False</font>
<font color="green">  28.     uses_savepoints = False</font>
<font color="green">  29.     can_release_savepoints = False</font>
<font color="green">  30.     can_combine_inserts_with_and_without_auto_increment_pk = False</font>
<font color="black">  31. </font>
<font color="black">  32.     # If True, don't use integer foreign keys referring to, e.g., positive</font>
<font color="black">  33.     # integer primary keys.</font>
<font color="green">  34.     related_fields_match_type = False</font>
<font color="green">  35.     allow_sliced_subqueries = True</font>
<font color="green">  36.     has_select_for_update = False</font>
<font color="green">  37.     has_select_for_update_nowait = False</font>
<font color="black">  38. </font>
<font color="green">  39.     supports_select_related = True</font>
<font color="black">  40. </font>
<font color="black">  41.     # Does the default test database allow multiple connections?</font>
<font color="black">  42.     # Usually an indication that the test database is in-memory</font>
<font color="green">  43.     test_db_allows_multiple_connections = True</font>
<font color="black">  44. </font>
<font color="black">  45.     # Can an object be saved without an explicit primary key?</font>
<font color="green">  46.     supports_unspecified_pk = False</font>
<font color="black">  47. </font>
<font color="black">  48.     # Can a fixture contain forward references? i.e., are</font>
<font color="black">  49.     # FK constraints checked at the end of transaction, or</font>
<font color="black">  50.     # at the end of each save operation?</font>
<font color="green">  51.     supports_forward_references = True</font>
<font color="black">  52. </font>
<font color="black">  53.     # Does the backend truncate names properly when they are too long?</font>
<font color="green">  54.     truncates_names = False</font>
<font color="black">  55. </font>
<font color="black">  56.     # Is there a REAL datatype in addition to floats/doubles?</font>
<font color="green">  57.     has_real_datatype = False</font>
<font color="green">  58.     supports_subqueries_in_group_by = True</font>
<font color="green">  59.     supports_bitwise_or = True</font>
<font color="black">  60. </font>
<font color="black">  61.     # Is there a true datatype for uuid?</font>
<font color="green">  62.     has_native_uuid_field = False</font>
<font color="black">  63. </font>
<font color="black">  64.     # Is there a true datatype for timedeltas?</font>
<font color="green">  65.     has_native_duration_field = False</font>
<font color="black">  66. </font>
<font color="black">  67.     # Does the database driver support timedeltas as arguments?</font>
<font color="black">  68.     # This is only relevant when there is a native duration field.</font>
<font color="black">  69.     # Specifically, there is a bug with cx_Oracle:</font>
<font color="black">  70.     # https://bitbucket.org/anthony_tuininga/cx_oracle/issue/7/</font>
<font color="green">  71.     driver_supports_timedelta_args = False</font>
<font color="black">  72. </font>
<font color="black">  73.     # Do time/datetime fields have microsecond precision?</font>
<font color="green">  74.     supports_microsecond_precision = True</font>
<font color="black">  75. </font>
<font color="black">  76.     # Does the __regex lookup support backreferencing and grouping?</font>
<font color="green">  77.     supports_regex_backreferencing = True</font>
<font color="black">  78. </font>
<font color="black">  79.     # Can date/datetime lookups be performed using a string?</font>
<font color="green">  80.     supports_date_lookup_using_string = True</font>
<font color="black">  81. </font>
<font color="black">  82.     # Can datetimes with timezones be used?</font>
<font color="green">  83.     supports_timezones = True</font>
<font color="black">  84. </font>
<font color="black">  85.     # Does the database have a copy of the zoneinfo database?</font>
<font color="green">  86.     has_zoneinfo_database = True</font>
<font color="black">  87. </font>
<font color="black">  88.     # When performing a GROUP BY, is an ORDER BY NULL required</font>
<font color="black">  89.     # to remove any ordering?</font>
<font color="green">  90.     requires_explicit_null_ordering_when_grouping = False</font>
<font color="black">  91. </font>
<font color="black">  92.     # Does the backend order NULL values as largest or smallest?</font>
<font color="green">  93.     nulls_order_largest = False</font>
<font color="black">  94. </font>
<font color="black">  95.     # Is there a 1000 item limit on query parameters?</font>
<font color="green">  96.     supports_1000_query_parameters = True</font>
<font color="black">  97. </font>
<font color="black">  98.     # Can an object have an autoincrement primary key of 0? MySQL says No.</font>
<font color="green">  99.     allows_auto_pk_0 = True</font>
<font color="black"> 100. </font>
<font color="black"> 101.     # Do we need to NULL a ForeignKey out, or can the constraint check be</font>
<font color="black"> 102.     # deferred</font>
<font color="green"> 103.     can_defer_constraint_checks = False</font>
<font color="black"> 104. </font>
<font color="black"> 105.     # date_interval_sql can properly handle mixed Date/DateTime fields and timedeltas</font>
<font color="green"> 106.     supports_mixed_date_datetime_comparisons = True</font>
<font color="black"> 107. </font>
<font color="black"> 108.     # Does the backend support tablespaces? Default to False because it isn't</font>
<font color="black"> 109.     # in the SQL standard.</font>
<font color="green"> 110.     supports_tablespaces = False</font>
<font color="black"> 111. </font>
<font color="black"> 112.     # Does the backend reset sequences between tests?</font>
<font color="green"> 113.     supports_sequence_reset = True</font>
<font color="black"> 114. </font>
<font color="black"> 115.     # Can the backend determine reliably the length of a CharField?</font>
<font color="green"> 116.     can_introspect_max_length = True</font>
<font color="black"> 117. </font>
<font color="black"> 118.     # Can the backend determine reliably if a field is nullable?</font>
<font color="black"> 119.     # Note that this is separate from interprets_empty_strings_as_nulls,</font>
<font color="black"> 120.     # although the latter feature, when true, interferes with correct</font>
<font color="black"> 121.     # setting (and introspection) of CharFields' nullability.</font>
<font color="black"> 122.     # This is True for all core backends.</font>
<font color="green"> 123.     can_introspect_null = True</font>
<font color="black"> 124. </font>
<font color="black"> 125.     # Can the backend introspect the default value of a column?</font>
<font color="green"> 126.     can_introspect_default = True</font>
<font color="black"> 127. </font>
<font color="black"> 128.     # Confirm support for introspected foreign keys</font>
<font color="black"> 129.     # Every database can do this reliably, except MySQL,</font>
<font color="black"> 130.     # which can't do it for MyISAM tables</font>
<font color="green"> 131.     can_introspect_foreign_keys = True</font>
<font color="black"> 132. </font>
<font color="black"> 133.     # Can the backend introspect an AutoField, instead of an IntegerField?</font>
<font color="green"> 134.     can_introspect_autofield = False</font>
<font color="black"> 135. </font>
<font color="black"> 136.     # Can the backend introspect a BigIntegerField, instead of an IntegerField?</font>
<font color="green"> 137.     can_introspect_big_integer_field = True</font>
<font color="black"> 138. </font>
<font color="black"> 139.     # Can the backend introspect an BinaryField, instead of an TextField?</font>
<font color="green"> 140.     can_introspect_binary_field = True</font>
<font color="black"> 141. </font>
<font color="black"> 142.     # Can the backend introspect an DecimalField, instead of an FloatField?</font>
<font color="green"> 143.     can_introspect_decimal_field = True</font>
<font color="black"> 144. </font>
<font color="black"> 145.     # Can the backend introspect an IPAddressField, instead of an CharField?</font>
<font color="green"> 146.     can_introspect_ip_address_field = False</font>
<font color="black"> 147. </font>
<font color="black"> 148.     # Can the backend introspect a PositiveIntegerField, instead of an IntegerField?</font>
<font color="green"> 149.     can_introspect_positive_integer_field = False</font>
<font color="black"> 150. </font>
<font color="black"> 151.     # Can the backend introspect a SmallIntegerField, instead of an IntegerField?</font>
<font color="green"> 152.     can_introspect_small_integer_field = False</font>
<font color="black"> 153. </font>
<font color="black"> 154.     # Can the backend introspect a TimeField, instead of a DateTimeField?</font>
<font color="green"> 155.     can_introspect_time_field = True</font>
<font color="black"> 156. </font>
<font color="black"> 157.     # Support for the DISTINCT ON clause</font>
<font color="green"> 158.     can_distinct_on_fields = False</font>
<font color="black"> 159. </font>
<font color="black"> 160.     # Does the backend decide to commit before SAVEPOINT statements</font>
<font color="black"> 161.     # when autocommit is disabled? http://bugs.python.org/issue8145#msg109965</font>
<font color="green"> 162.     autocommits_when_autocommit_is_off = False</font>
<font color="black"> 163. </font>
<font color="black"> 164.     # Does the backend prevent running SQL queries in broken transactions?</font>
<font color="green"> 165.     atomic_transactions = True</font>
<font color="black"> 166. </font>
<font color="black"> 167.     # Can we roll back DDL in a transaction?</font>
<font color="green"> 168.     can_rollback_ddl = False</font>
<font color="black"> 169. </font>
<font color="black"> 170.     # Can we issue more than one ALTER COLUMN clause in an ALTER TABLE?</font>
<font color="green"> 171.     supports_combined_alters = False</font>
<font color="black"> 172. </font>
<font color="black"> 173.     # Does it support foreign keys?</font>
<font color="green"> 174.     supports_foreign_keys = True</font>
<font color="black"> 175. </font>
<font color="black"> 176.     # Does it support CHECK constraints?</font>
<font color="green"> 177.     supports_column_check_constraints = True</font>
<font color="black"> 178. </font>
<font color="black"> 179.     # Does the backend support 'pyformat' style (&quot;... %(name)s ...&quot;, {'name': value})</font>
<font color="black"> 180.     # parameter passing? Note this can be provided by the backend even if not</font>
<font color="black"> 181.     # supported by the Python driver</font>
<font color="green"> 182.     supports_paramstyle_pyformat = True</font>
<font color="black"> 183. </font>
<font color="black"> 184.     # Does the backend require literal defaults, rather than parameterized ones?</font>
<font color="green"> 185.     requires_literal_defaults = False</font>
<font color="black"> 186. </font>
<font color="black"> 187.     # Does the backend require a connection reset after each material schema change?</font>
<font color="green"> 188.     connection_persists_old_columns = False</font>
<font color="black"> 189. </font>
<font color="black"> 190.     # What kind of error does the backend throw when accessing closed cursor?</font>
<font color="green"> 191.     closed_cursor_error_class = ProgrammingError</font>
<font color="black"> 192. </font>
<font color="black"> 193.     # Does 'a' LIKE 'A' match?</font>
<font color="green"> 194.     has_case_insensitive_like = True</font>
<font color="black"> 195. </font>
<font color="black"> 196.     # Does the backend require the sqlparse library for splitting multi-line</font>
<font color="black"> 197.     # statements before executing them?</font>
<font color="green"> 198.     requires_sqlparse_for_splitting = True</font>
<font color="black"> 199. </font>
<font color="black"> 200.     # Suffix for backends that don't support &quot;SELECT xxx;&quot; queries.</font>
<font color="green"> 201.     bare_select_suffix = ''</font>
<font color="black"> 202. </font>
<font color="black"> 203.     # If NULL is implied on columns without needing to be explicitly specified</font>
<font color="green"> 204.     implied_column_null = False</font>
<font color="black"> 205. </font>
<font color="green"> 206.     uppercases_column_names = False</font>
<font color="black"> 207. </font>
<font color="black"> 208.     # Does the backend support &quot;select for update&quot; queries with limit (and offset)?</font>
<font color="green"> 209.     supports_select_for_update_with_limit = True</font>
<font color="black"> 210. </font>
<font color="black"> 211.     # Does the backend ignore null expressions in GREATEST and LEAST queries unless</font>
<font color="black"> 212.     # every expression is null?</font>
<font color="green"> 213.     greatest_least_ignores_nulls = False</font>
<font color="black"> 214. </font>
<font color="black"> 215.     # Can the backend clone databases for parallel test execution?</font>
<font color="black"> 216.     # Defaults to False to allow third-party backends to opt-in.</font>
<font color="green"> 217.     can_clone_databases = False</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def __init__(self, connection):</font>
<font color="green"> 220.         self.connection = connection</font>
<font color="black"> 221. </font>
<font color="green"> 222.     @cached_property</font>
<font color="black"> 223.     def supports_transactions(self):</font>
<font color="black"> 224.         &quot;&quot;&quot;Confirm support for transactions.&quot;&quot;&quot;</font>
<font color="red"> 225.         with self.connection.cursor() as cursor:</font>
<font color="red"> 226.             cursor.execute('CREATE TABLE ROLLBACK_TEST (X INT)')</font>
<font color="red"> 227.             self.connection.set_autocommit(False)</font>
<font color="red"> 228.             cursor.execute('INSERT INTO ROLLBACK_TEST (X) VALUES (8)')</font>
<font color="red"> 229.             self.connection.rollback()</font>
<font color="red"> 230.             self.connection.set_autocommit(True)</font>
<font color="red"> 231.             cursor.execute('SELECT COUNT(X) FROM ROLLBACK_TEST')</font>
<font color="red"> 232.             count, = cursor.fetchone()</font>
<font color="red"> 233.             cursor.execute('DROP TABLE ROLLBACK_TEST')</font>
<font color="red"> 234.         return count == 0</font>
<font color="black"> 235. </font>
<font color="green"> 236.     @cached_property</font>
<font color="black"> 237.     def supports_stddev(self):</font>
<font color="black"> 238.         &quot;&quot;&quot;Confirm support for STDDEV and related stats functions.&quot;&quot;&quot;</font>
<font color="red"> 239.         try:</font>
<font color="red"> 240.             self.connection.ops.check_expression_support(StdDev(1))</font>
<font color="red"> 241.             return True</font>
<font color="red"> 242.         except NotImplementedError:</font>
<font color="red"> 243.             return False</font>
<font color="black"> 244. </font>
<font color="green"> 245.     def introspected_boolean_field_type(self, field=None, created_separately=False):</font>
<font color="black"> 246.         &quot;&quot;&quot;</font>
<font color="black"> 247.         What is the type returned when the backend introspects a BooleanField?</font>
<font color="black"> 248.         The optional arguments may be used to give further details of the field to be</font>
<font color="black"> 249.         introspected; in particular, they are provided by Django's test suite:</font>
<font color="black"> 250.         field -- the field definition</font>
<font color="black"> 251.         created_separately -- True if the field was added via a SchemaEditor's AddField,</font>
<font color="black"> 252.                               False if the field was created with the model</font>
<font color="black"> 253. </font>
<font color="black"> 254.         Note that return value from this function is compared by tests against actual</font>
<font color="black"> 255.         introspection results; it should provide expectations, not run an introspection</font>
<font color="black"> 256.         itself.</font>
<font color="black"> 257.         &quot;&quot;&quot;</font>
<font color="red"> 258.         if self.can_introspect_null and field and field.null:</font>
<font color="red"> 259.             return 'NullBooleanField'</font>
<font color="red"> 260.         return 'BooleanField'</font>
</pre>

