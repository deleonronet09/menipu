source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/apps/registry.py</b><br>


file stats: <b>183 lines, 134 executed: 73.2% covered</b>
<pre>
<font color="green">   1. import sys</font>
<font color="green">   2. import threading</font>
<font color="green">   3. import warnings</font>
<font color="green">   4. from collections import Counter, OrderedDict, defaultdict</font>
<font color="green">   5. from functools import partial</font>
<font color="black">   6. </font>
<font color="green">   7. from django.core.exceptions import AppRegistryNotReady, ImproperlyConfigured</font>
<font color="green">   8. from django.utils import lru_cache</font>
<font color="black">   9. </font>
<font color="green">  10. from .config import AppConfig</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class Apps(object):</font>
<font color="black">  14.     &quot;&quot;&quot;</font>
<font color="black">  15.     A registry that stores the configuration of installed applications.</font>
<font color="black">  16. </font>
<font color="black">  17.     It also keeps track of models eg. to provide reverse-relations.</font>
<font color="green">  18.     &quot;&quot;&quot;</font>
<font color="black">  19. </font>
<font color="green">  20.     def __init__(self, installed_apps=()):</font>
<font color="black">  21.         # installed_apps is set to None when creating the master registry</font>
<font color="black">  22.         # because it cannot be populated at that point. Other registries must</font>
<font color="black">  23.         # provide a list of installed apps and are populated immediately.</font>
<font color="green">  24.         if installed_apps is None and hasattr(sys.modules[__name__], 'apps'):</font>
<font color="red">  25.             raise RuntimeError(&quot;You must supply an installed_apps argument.&quot;)</font>
<font color="black">  26. </font>
<font color="black">  27.         # Mapping of app labels =&gt; model names =&gt; model classes. Every time a</font>
<font color="black">  28.         # model is imported, ModelBase.__new__ calls apps.register_model which</font>
<font color="black">  29.         # creates an entry in all_models. All imported models are registered,</font>
<font color="black">  30.         # regardless of whether they're defined in an installed application</font>
<font color="black">  31.         # and whether the registry has been populated. Since it isn't possible</font>
<font color="black">  32.         # to reimport a module safely (it could reexecute initialization code)</font>
<font color="black">  33.         # all_models is never overridden or reset.</font>
<font color="green">  34.         self.all_models = defaultdict(OrderedDict)</font>
<font color="black">  35. </font>
<font color="black">  36.         # Mapping of labels to AppConfig instances for installed apps.</font>
<font color="green">  37.         self.app_configs = OrderedDict()</font>
<font color="black">  38. </font>
<font color="black">  39.         # Stack of app_configs. Used to store the current state in</font>
<font color="black">  40.         # set_available_apps and set_installed_apps.</font>
<font color="green">  41.         self.stored_app_configs = []</font>
<font color="black">  42. </font>
<font color="black">  43.         # Whether the registry is populated.</font>
<font color="green">  44.         self.apps_ready = self.models_ready = self.ready = False</font>
<font color="black">  45. </font>
<font color="black">  46.         # Lock for thread-safe population.</font>
<font color="green">  47.         self._lock = threading.Lock()</font>
<font color="black">  48. </font>
<font color="black">  49.         # Maps (&quot;app_label&quot;, &quot;modelname&quot;) tuples to lists of functions to be</font>
<font color="black">  50.         # called when the corresponding model is ready. Used by this class's</font>
<font color="black">  51.         # `lazy_model_operation()` and `do_pending_operations()` methods.</font>
<font color="green">  52.         self._pending_operations = defaultdict(list)</font>
<font color="black">  53. </font>
<font color="black">  54.         # Populate apps and models, unless it's the master registry.</font>
<font color="green">  55.         if installed_apps is not None:</font>
<font color="green">  56.             self.populate(installed_apps)</font>
<font color="black">  57. </font>
<font color="green">  58.     def populate(self, installed_apps=None):</font>
<font color="black">  59.         &quot;&quot;&quot;</font>
<font color="black">  60.         Loads application configurations and models.</font>
<font color="black">  61. </font>
<font color="black">  62.         This method imports each application module and then each model module.</font>
<font color="black">  63. </font>
<font color="black">  64.         It is thread safe and idempotent, but not reentrant.</font>
<font color="black">  65.         &quot;&quot;&quot;</font>
<font color="green">  66.         if self.ready:</font>
<font color="red">  67.             return</font>
<font color="black">  68. </font>
<font color="black">  69.         # populate() might be called by two threads in parallel on servers</font>
<font color="black">  70.         # that create threads before initializing the WSGI callable.</font>
<font color="green">  71.         with self._lock:</font>
<font color="green">  72.             if self.ready:</font>
<font color="red">  73.                 return</font>
<font color="black">  74. </font>
<font color="black">  75.             # app_config should be pristine, otherwise the code below won't</font>
<font color="black">  76.             # guarantee that the order matches the order in INSTALLED_APPS.</font>
<font color="green">  77.             if self.app_configs:</font>
<font color="red">  78.                 raise RuntimeError(&quot;populate() isn't reentrant&quot;)</font>
<font color="black">  79. </font>
<font color="black">  80.             # Load app configs and app modules.</font>
<font color="green">  81.             for entry in installed_apps:</font>
<font color="green">  82.                 if isinstance(entry, AppConfig):</font>
<font color="green">  83.                     app_config = entry</font>
<font color="black">  84.                 else:</font>
<font color="green">  85.                     app_config = AppConfig.create(entry)</font>
<font color="green">  86.                 if app_config.label in self.app_configs:</font>
<font color="red">  87.                     raise ImproperlyConfigured(</font>
<font color="red">  88.                         &quot;Application labels aren't unique, &quot;</font>
<font color="red">  89.                         &quot;duplicates: %s&quot; % app_config.label)</font>
<font color="black">  90. </font>
<font color="green">  91.                 self.app_configs[app_config.label] = app_config</font>
<font color="black">  92. </font>
<font color="black">  93.             # Check for duplicate app names.</font>
<font color="green">  94.             counts = Counter(</font>
<font color="green">  95.                 app_config.name for app_config in self.app_configs.values())</font>
<font color="black">  96.             duplicates = [</font>
<font color="green">  97.                 name for name, count in counts.most_common() if count &gt; 1]</font>
<font color="green">  98.             if duplicates:</font>
<font color="red">  99.                 raise ImproperlyConfigured(</font>
<font color="red"> 100.                     &quot;Application names aren't unique, &quot;</font>
<font color="red"> 101.                     &quot;duplicates: %s&quot; % &quot;, &quot;.join(duplicates))</font>
<font color="black"> 102. </font>
<font color="green"> 103.             self.apps_ready = True</font>
<font color="black"> 104. </font>
<font color="black"> 105.             # Load models.</font>
<font color="green"> 106.             for app_config in self.app_configs.values():</font>
<font color="green"> 107.                 all_models = self.all_models[app_config.label]</font>
<font color="green"> 108.                 app_config.import_models(all_models)</font>
<font color="black"> 109. </font>
<font color="green"> 110.             self.clear_cache()</font>
<font color="black"> 111. </font>
<font color="green"> 112.             self.models_ready = True</font>
<font color="black"> 113. </font>
<font color="green"> 114.             for app_config in self.get_app_configs():</font>
<font color="green"> 115.                 app_config.ready()</font>
<font color="black"> 116. </font>
<font color="green"> 117.             self.ready = True</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def check_apps_ready(self):</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="black"> 121.         Raises an exception if all apps haven't been imported yet.</font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="green"> 123.         if not self.apps_ready:</font>
<font color="red"> 124.             raise AppRegistryNotReady(&quot;Apps aren't loaded yet.&quot;)</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def check_models_ready(self):</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         Raises an exception if all models haven't been imported yet.</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="green"> 130.         if not self.models_ready:</font>
<font color="red"> 131.             raise AppRegistryNotReady(&quot;Models aren't loaded yet.&quot;)</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def get_app_configs(self):</font>
<font color="black"> 134.         &quot;&quot;&quot;</font>
<font color="black"> 135.         Imports applications and returns an iterable of app configs.</font>
<font color="black"> 136.         &quot;&quot;&quot;</font>
<font color="green"> 137.         self.check_apps_ready()</font>
<font color="green"> 138.         return self.app_configs.values()</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def get_app_config(self, app_label):</font>
<font color="black"> 141.         &quot;&quot;&quot;</font>
<font color="black"> 142.         Imports applications and returns an app config for the given label.</font>
<font color="black"> 143. </font>
<font color="black"> 144.         Raises LookupError if no application exists with this label.</font>
<font color="black"> 145.         &quot;&quot;&quot;</font>
<font color="green"> 146.         self.check_apps_ready()</font>
<font color="green"> 147.         try:</font>
<font color="green"> 148.             return self.app_configs[app_label]</font>
<font color="green"> 149.         except KeyError:</font>
<font color="green"> 150.             message = &quot;No installed app with label '%s'.&quot; % app_label</font>
<font color="green"> 151.             for app_config in self.get_app_configs():</font>
<font color="green"> 152.                 if app_config.name == app_label:</font>
<font color="red"> 153.                     message += &quot; Did you mean '%s'?&quot; % app_config.label</font>
<font color="red"> 154.                     break</font>
<font color="green"> 155.             raise LookupError(message)</font>
<font color="black"> 156. </font>
<font color="black"> 157.     # This method is performance-critical at least for Django's test suite.</font>
<font color="green"> 158.     @lru_cache.lru_cache(maxsize=None)</font>
<font color="green"> 159.     def get_models(self, include_auto_created=False,</font>
<font color="green"> 160.                    include_deferred=False, include_swapped=False):</font>
<font color="black"> 161.         &quot;&quot;&quot;</font>
<font color="black"> 162.         Returns a list of all installed models.</font>
<font color="black"> 163. </font>
<font color="black"> 164.         By default, the following models aren't included:</font>
<font color="black"> 165. </font>
<font color="black"> 166.         - auto-created models for many-to-many relations without</font>
<font color="black"> 167.           an explicit intermediate table,</font>
<font color="black"> 168.         - models created to satisfy deferred attribute queries,</font>
<font color="black"> 169.         - models that have been swapped out.</font>
<font color="black"> 170. </font>
<font color="black"> 171.         Set the corresponding keyword argument to True to include such models.</font>
<font color="black"> 172.         &quot;&quot;&quot;</font>
<font color="green"> 173.         self.check_models_ready()</font>
<font color="black"> 174. </font>
<font color="green"> 175.         result = []</font>
<font color="green"> 176.         for app_config in self.app_configs.values():</font>
<font color="green"> 177.             result.extend(list(app_config.get_models(</font>
<font color="green"> 178.                 include_auto_created, include_deferred, include_swapped)))</font>
<font color="green"> 179.         return result</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def get_model(self, app_label, model_name=None):</font>
<font color="black"> 182.         &quot;&quot;&quot;</font>
<font color="black"> 183.         Returns the model matching the given app_label and model_name.</font>
<font color="black"> 184. </font>
<font color="black"> 185.         As a shortcut, this function also accepts a single argument in the</font>
<font color="black"> 186.         form &lt;app_label&gt;.&lt;model_name&gt;.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         model_name is case-insensitive.</font>
<font color="black"> 189. </font>
<font color="black"> 190.         Raises LookupError if no application exists with this label, or no</font>
<font color="black"> 191.         model exists with this name in the application. Raises ValueError if</font>
<font color="black"> 192.         called with a single argument that doesn't contain exactly one dot.</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="green"> 194.         self.check_models_ready()</font>
<font color="green"> 195.         if model_name is None:</font>
<font color="green"> 196.             app_label, model_name = app_label.split('.')</font>
<font color="green"> 197.         return self.get_app_config(app_label).get_model(model_name.lower())</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def register_model(self, app_label, model):</font>
<font color="black"> 200.         # Since this method is called when models are imported, it cannot</font>
<font color="black"> 201.         # perform imports because of the risk of import loops. It mustn't</font>
<font color="black"> 202.         # call get_app_config().</font>
<font color="green"> 203.         model_name = model._meta.model_name</font>
<font color="green"> 204.         app_models = self.all_models[app_label]</font>
<font color="green"> 205.         if model_name in app_models:</font>
<font color="red"> 206.             if (model.__name__ == app_models[model_name].__name__ and</font>
<font color="red"> 207.                     model.__module__ == app_models[model_name].__module__):</font>
<font color="red"> 208.                 warnings.warn(</font>
<font color="red"> 209.                     &quot;Model '%s.%s' was already registered. &quot;</font>
<font color="black"> 210.                     &quot;Reloading models is not advised as it can lead to inconsistencies, &quot;</font>
<font color="red"> 211.                     &quot;most notably with related models.&quot; % (app_label, model_name),</font>
<font color="red"> 212.                     RuntimeWarning, stacklevel=2)</font>
<font color="black"> 213.             else:</font>
<font color="red"> 214.                 raise RuntimeError(</font>
<font color="red"> 215.                     &quot;Conflicting '%s' models in application '%s': %s and %s.&quot; %</font>
<font color="red"> 216.                     (model_name, app_label, app_models[model_name], model))</font>
<font color="green"> 217.         app_models[model_name] = model</font>
<font color="green"> 218.         self.do_pending_operations(model)</font>
<font color="green"> 219.         self.clear_cache()</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def is_installed(self, app_name):</font>
<font color="black"> 222.         &quot;&quot;&quot;</font>
<font color="black"> 223.         Checks whether an application with this name exists in the registry.</font>
<font color="black"> 224. </font>
<font color="black"> 225.         app_name is the full name of the app eg. 'django.contrib.admin'.</font>
<font color="black"> 226.         &quot;&quot;&quot;</font>
<font color="red"> 227.         self.check_apps_ready()</font>
<font color="red"> 228.         return any(ac.name == app_name for ac in self.app_configs.values())</font>
<font color="black"> 229. </font>
<font color="green"> 230.     def get_containing_app_config(self, object_name):</font>
<font color="black"> 231.         &quot;&quot;&quot;</font>
<font color="black"> 232.         Look for an app config containing a given object.</font>
<font color="black"> 233. </font>
<font color="black"> 234.         object_name is the dotted Python path to the object.</font>
<font color="black"> 235. </font>
<font color="black"> 236.         Returns the app config for the inner application in case of nesting.</font>
<font color="black"> 237.         Returns None if the object isn't in any registered app config.</font>
<font color="black"> 238.         &quot;&quot;&quot;</font>
<font color="green"> 239.         self.check_apps_ready()</font>
<font color="green"> 240.         candidates = []</font>
<font color="green"> 241.         for app_config in self.app_configs.values():</font>
<font color="green"> 242.             if object_name.startswith(app_config.name):</font>
<font color="green"> 243.                 subpath = object_name[len(app_config.name):]</font>
<font color="green"> 244.                 if subpath == '' or subpath[0] == '.':</font>
<font color="green"> 245.                     candidates.append(app_config)</font>
<font color="green"> 246.         if candidates:</font>
<font color="green"> 247.             return sorted(candidates, key=lambda ac: -len(ac.name))[0]</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def get_registered_model(self, app_label, model_name):</font>
<font color="black"> 250.         &quot;&quot;&quot;</font>
<font color="black"> 251.         Similar to get_model(), but doesn't require that an app exists with</font>
<font color="black"> 252.         the given app_label.</font>
<font color="black"> 253. </font>
<font color="black"> 254.         It's safe to call this method at import time, even while the registry</font>
<font color="black"> 255.         is being populated.</font>
<font color="black"> 256.         &quot;&quot;&quot;</font>
<font color="green"> 257.         model = self.all_models[app_label].get(model_name.lower())</font>
<font color="green"> 258.         if model is None:</font>
<font color="green"> 259.             raise LookupError(</font>
<font color="green"> 260.                 &quot;Model '%s.%s' not registered.&quot; % (app_label, model_name))</font>
<font color="green"> 261.         return model</font>
<font color="black"> 262. </font>
<font color="green"> 263.     @lru_cache.lru_cache(maxsize=None)</font>
<font color="black"> 264.     def get_swappable_settings_name(self, to_string):</font>
<font color="black"> 265.         &quot;&quot;&quot;</font>
<font color="black"> 266.         For a given model string (e.g. &quot;auth.User&quot;), return the name of the</font>
<font color="black"> 267.         corresponding settings name if it refers to a swappable model. If the</font>
<font color="black"> 268.         referred model is not swappable, return None.</font>
<font color="black"> 269. </font>
<font color="black"> 270.         This method is decorated with lru_cache because it's performance</font>
<font color="black"> 271.         critical when it comes to migrations. Since the swappable settings don't</font>
<font color="black"> 272.         change after Django has loaded the settings, there is no reason to get</font>
<font color="black"> 273.         the respective settings attribute over and over again.</font>
<font color="black"> 274.         &quot;&quot;&quot;</font>
<font color="green"> 275.         for model in self.get_models(include_swapped=True):</font>
<font color="green"> 276.             swapped = model._meta.swapped</font>
<font color="black"> 277.             # Is this model swapped out for the model given by to_string?</font>
<font color="green"> 278.             if swapped and swapped == to_string:</font>
<font color="red"> 279.                 return model._meta.swappable</font>
<font color="black"> 280.             # Is this model swappable and the one given by to_string?</font>
<font color="green"> 281.             if model._meta.swappable and model._meta.label == to_string:</font>
<font color="green"> 282.                 return model._meta.swappable</font>
<font color="green"> 283.         return None</font>
<font color="black"> 284. </font>
<font color="green"> 285.     def set_available_apps(self, available):</font>
<font color="black"> 286.         &quot;&quot;&quot;</font>
<font color="black"> 287.         Restricts the set of installed apps used by get_app_config[s].</font>
<font color="black"> 288. </font>
<font color="black"> 289.         available must be an iterable of application names.</font>
<font color="black"> 290. </font>
<font color="black"> 291.         set_available_apps() must be balanced with unset_available_apps().</font>
<font color="black"> 292. </font>
<font color="black"> 293.         Primarily used for performance optimization in TransactionTestCase.</font>
<font color="black"> 294. </font>
<font color="black"> 295.         This method is safe is the sense that it doesn't trigger any imports.</font>
<font color="black"> 296.         &quot;&quot;&quot;</font>
<font color="red"> 297.         available = set(available)</font>
<font color="red"> 298.         installed = set(app_config.name for app_config in self.get_app_configs())</font>
<font color="red"> 299.         if not available.issubset(installed):</font>
<font color="red"> 300.             raise ValueError(&quot;Available apps isn't a subset of installed &quot;</font>
<font color="red"> 301.                 &quot;apps, extra apps: %s&quot; % &quot;, &quot;.join(available - installed))</font>
<font color="black"> 302. </font>
<font color="red"> 303.         self.stored_app_configs.append(self.app_configs)</font>
<font color="red"> 304.         self.app_configs = OrderedDict(</font>
<font color="red"> 305.             (label, app_config)</font>
<font color="red"> 306.             for label, app_config in self.app_configs.items()</font>
<font color="red"> 307.             if app_config.name in available)</font>
<font color="red"> 308.         self.clear_cache()</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def unset_available_apps(self):</font>
<font color="black"> 311.         &quot;&quot;&quot;</font>
<font color="black"> 312.         Cancels a previous call to set_available_apps().</font>
<font color="black"> 313.         &quot;&quot;&quot;</font>
<font color="red"> 314.         self.app_configs = self.stored_app_configs.pop()</font>
<font color="red"> 315.         self.clear_cache()</font>
<font color="black"> 316. </font>
<font color="green"> 317.     def set_installed_apps(self, installed):</font>
<font color="black"> 318.         &quot;&quot;&quot;</font>
<font color="black"> 319.         Enables a different set of installed apps for get_app_config[s].</font>
<font color="black"> 320. </font>
<font color="black"> 321.         installed must be an iterable in the same format as INSTALLED_APPS.</font>
<font color="black"> 322. </font>
<font color="black"> 323.         set_installed_apps() must be balanced with unset_installed_apps(),</font>
<font color="black"> 324.         even if it exits with an exception.</font>
<font color="black"> 325. </font>
<font color="black"> 326.         Primarily used as a receiver of the setting_changed signal in tests.</font>
<font color="black"> 327. </font>
<font color="black"> 328.         This method may trigger new imports, which may add new models to the</font>
<font color="black"> 329.         registry of all imported models. They will stay in the registry even</font>
<font color="black"> 330.         after unset_installed_apps(). Since it isn't possible to replay</font>
<font color="black"> 331.         imports safely (eg. that could lead to registering listeners twice),</font>
<font color="black"> 332.         models are registered when they're imported and never removed.</font>
<font color="black"> 333.         &quot;&quot;&quot;</font>
<font color="red"> 334.         if not self.ready:</font>
<font color="red"> 335.             raise AppRegistryNotReady(&quot;App registry isn't ready yet.&quot;)</font>
<font color="red"> 336.         self.stored_app_configs.append(self.app_configs)</font>
<font color="red"> 337.         self.app_configs = OrderedDict()</font>
<font color="red"> 338.         self.apps_ready = self.models_ready = self.ready = False</font>
<font color="red"> 339.         self.clear_cache()</font>
<font color="red"> 340.         self.populate(installed)</font>
<font color="black"> 341. </font>
<font color="green"> 342.     def unset_installed_apps(self):</font>
<font color="black"> 343.         &quot;&quot;&quot;</font>
<font color="black"> 344.         Cancels a previous call to set_installed_apps().</font>
<font color="black"> 345.         &quot;&quot;&quot;</font>
<font color="red"> 346.         self.app_configs = self.stored_app_configs.pop()</font>
<font color="red"> 347.         self.apps_ready = self.models_ready = self.ready = True</font>
<font color="red"> 348.         self.clear_cache()</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def clear_cache(self):</font>
<font color="black"> 351.         &quot;&quot;&quot;</font>
<font color="black"> 352.         Clears all internal caches, for methods that alter the app registry.</font>
<font color="black"> 353. </font>
<font color="black"> 354.         This is mostly used in tests.</font>
<font color="black"> 355.         &quot;&quot;&quot;</font>
<font color="black"> 356.         # Call expire cache on each model. This will purge</font>
<font color="black"> 357.         # the relation tree and the fields cache.</font>
<font color="green"> 358.         self.get_models.cache_clear()</font>
<font color="green"> 359.         if self.ready:</font>
<font color="black"> 360.             # Circumvent self.get_models() to prevent that the cache is refilled.</font>
<font color="black"> 361.             # This particularly prevents that an empty value is cached while cloning.</font>
<font color="green"> 362.             for app_config in self.app_configs.values():</font>
<font color="green"> 363.                 for model in app_config.get_models(include_auto_created=True):</font>
<font color="green"> 364.                     model._meta._expire_cache()</font>
<font color="black"> 365. </font>
<font color="green"> 366.     def lazy_model_operation(self, function, *model_keys):</font>
<font color="black"> 367.         &quot;&quot;&quot;</font>
<font color="black"> 368.         Take a function and a number of (&quot;app_label&quot;, &quot;modelname&quot;) tuples, and</font>
<font color="black"> 369.         when all the corresponding models have been imported and registered,</font>
<font color="black"> 370.         call the function with the model classes as its arguments.</font>
<font color="black"> 371. </font>
<font color="black"> 372.         The function passed to this method must accept exactly n models as</font>
<font color="black"> 373.         arguments, where n=len(model_keys).</font>
<font color="black"> 374.         &quot;&quot;&quot;</font>
<font color="black"> 375.         # If this function depends on more than one model, we recursively turn</font>
<font color="black"> 376.         # it into a chain of functions that accept a single model argument and</font>
<font color="black"> 377.         # pass each in turn to lazy_model_operation.</font>
<font color="green"> 378.         model_key, more_models = model_keys[0], model_keys[1:]</font>
<font color="green"> 379.         if more_models:</font>
<font color="green"> 380.             supplied_fn = function</font>
<font color="black"> 381. </font>
<font color="green"> 382.             def function(model):</font>
<font color="green"> 383.                 next_function = partial(supplied_fn, model)</font>
<font color="black"> 384.                 # Annotate the function with its field for retrieval in</font>
<font color="black"> 385.                 # migrations.state.StateApps.</font>
<font color="green"> 386.                 if getattr(supplied_fn, 'keywords', None):</font>
<font color="green"> 387.                     next_function.field = supplied_fn.keywords.get('field')</font>
<font color="green"> 388.                 self.lazy_model_operation(next_function, *more_models)</font>
<font color="black"> 389. </font>
<font color="black"> 390.         # If the model is already loaded, pass it to the function immediately.</font>
<font color="black"> 391.         # Otherwise, delay execution until the class is prepared.</font>
<font color="green"> 392.         try:</font>
<font color="green"> 393.             model_class = self.get_registered_model(*model_key)</font>
<font color="green"> 394.         except LookupError:</font>
<font color="green"> 395.             self._pending_operations[model_key].append(function)</font>
<font color="black"> 396.         else:</font>
<font color="green"> 397.             function(model_class)</font>
<font color="black"> 398. </font>
<font color="green"> 399.     def do_pending_operations(self, model):</font>
<font color="black"> 400.         &quot;&quot;&quot;</font>
<font color="black"> 401.         Take a newly-prepared model and pass it to each function waiting for</font>
<font color="black"> 402.         it. This is called at the very end of `Apps.register_model()`.</font>
<font color="black"> 403.         &quot;&quot;&quot;</font>
<font color="green"> 404.         key = model._meta.app_label, model._meta.model_name</font>
<font color="green"> 405.         for function in self._pending_operations.pop(key, []):</font>
<font color="green"> 406.             function(model)</font>
<font color="black"> 407. </font>
<font color="green"> 408. apps = Apps(installed_apps=None)</font>
</pre>

