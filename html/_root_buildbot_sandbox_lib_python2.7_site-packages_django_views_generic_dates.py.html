source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/views/generic/dates.py</b><br>


file stats: <b>381 lines, 124 executed: 32.5% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import datetime</font>
<font color="black">   4. </font>
<font color="green">   5. from django.conf import settings</font>
<font color="green">   6. from django.core.exceptions import ImproperlyConfigured</font>
<font color="green">   7. from django.db import models</font>
<font color="green">   8. from django.http import Http404</font>
<font color="green">   9. from django.utils import timezone</font>
<font color="green">  10. from django.utils.encoding import force_str, force_text</font>
<font color="green">  11. from django.utils.functional import cached_property</font>
<font color="green">  12. from django.utils.translation import ugettext as _</font>
<font color="green">  13. from django.views.generic.base import View</font>
<font color="green">  14. from django.views.generic.detail import (</font>
<font color="black">  15.     BaseDetailView, SingleObjectTemplateResponseMixin,</font>
<font color="black">  16. )</font>
<font color="green">  17. from django.views.generic.list import (</font>
<font color="black">  18.     MultipleObjectMixin, MultipleObjectTemplateResponseMixin,</font>
<font color="black">  19. )</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class YearMixin(object):</font>
<font color="black">  23.     &quot;&quot;&quot;</font>
<font color="black">  24.     Mixin for views manipulating year-based data.</font>
<font color="green">  25.     &quot;&quot;&quot;</font>
<font color="green">  26.     year_format = '%Y'</font>
<font color="green">  27.     year = None</font>
<font color="black">  28. </font>
<font color="green">  29.     def get_year_format(self):</font>
<font color="black">  30.         &quot;&quot;&quot;</font>
<font color="black">  31.         Get a year format string in strptime syntax to be used to parse the</font>
<font color="black">  32.         year from url variables.</font>
<font color="black">  33.         &quot;&quot;&quot;</font>
<font color="red">  34.         return self.year_format</font>
<font color="black">  35. </font>
<font color="green">  36.     def get_year(self):</font>
<font color="black">  37.         &quot;&quot;&quot;</font>
<font color="black">  38.         Return the year for which this view should display data.</font>
<font color="black">  39.         &quot;&quot;&quot;</font>
<font color="red">  40.         year = self.year</font>
<font color="red">  41.         if year is None:</font>
<font color="red">  42.             try:</font>
<font color="red">  43.                 year = self.kwargs['year']</font>
<font color="red">  44.             except KeyError:</font>
<font color="red">  45.                 try:</font>
<font color="red">  46.                     year = self.request.GET['year']</font>
<font color="red">  47.                 except KeyError:</font>
<font color="red">  48.                     raise Http404(_(&quot;No year specified&quot;))</font>
<font color="red">  49.         return year</font>
<font color="black">  50. </font>
<font color="green">  51.     def get_next_year(self, date):</font>
<font color="black">  52.         &quot;&quot;&quot;</font>
<font color="black">  53.         Get the next valid year.</font>
<font color="black">  54.         &quot;&quot;&quot;</font>
<font color="red">  55.         return _get_next_prev(self, date, is_previous=False, period='year')</font>
<font color="black">  56. </font>
<font color="green">  57.     def get_previous_year(self, date):</font>
<font color="black">  58.         &quot;&quot;&quot;</font>
<font color="black">  59.         Get the previous valid year.</font>
<font color="black">  60.         &quot;&quot;&quot;</font>
<font color="red">  61.         return _get_next_prev(self, date, is_previous=True, period='year')</font>
<font color="black">  62. </font>
<font color="green">  63.     def _get_next_year(self, date):</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="black">  65.         Return the start date of the next interval.</font>
<font color="black">  66. </font>
<font color="black">  67.         The interval is defined by start date &lt;= item date &lt; next start date.</font>
<font color="black">  68.         &quot;&quot;&quot;</font>
<font color="red">  69.         return date.replace(year=date.year + 1, month=1, day=1)</font>
<font color="black">  70. </font>
<font color="green">  71.     def _get_current_year(self, date):</font>
<font color="black">  72.         &quot;&quot;&quot;</font>
<font color="black">  73.         Return the start date of the current interval.</font>
<font color="black">  74.         &quot;&quot;&quot;</font>
<font color="red">  75.         return date.replace(month=1, day=1)</font>
<font color="black">  76. </font>
<font color="black">  77. </font>
<font color="green">  78. class MonthMixin(object):</font>
<font color="black">  79.     &quot;&quot;&quot;</font>
<font color="black">  80.     Mixin for views manipulating month-based data.</font>
<font color="green">  81.     &quot;&quot;&quot;</font>
<font color="green">  82.     month_format = '%b'</font>
<font color="green">  83.     month = None</font>
<font color="black">  84. </font>
<font color="green">  85.     def get_month_format(self):</font>
<font color="black">  86.         &quot;&quot;&quot;</font>
<font color="black">  87.         Get a month format string in strptime syntax to be used to parse the</font>
<font color="black">  88.         month from url variables.</font>
<font color="black">  89.         &quot;&quot;&quot;</font>
<font color="red">  90.         return self.month_format</font>
<font color="black">  91. </font>
<font color="green">  92.     def get_month(self):</font>
<font color="black">  93.         &quot;&quot;&quot;</font>
<font color="black">  94.         Return the month for which this view should display data.</font>
<font color="black">  95.         &quot;&quot;&quot;</font>
<font color="red">  96.         month = self.month</font>
<font color="red">  97.         if month is None:</font>
<font color="red">  98.             try:</font>
<font color="red">  99.                 month = self.kwargs['month']</font>
<font color="red"> 100.             except KeyError:</font>
<font color="red"> 101.                 try:</font>
<font color="red"> 102.                     month = self.request.GET['month']</font>
<font color="red"> 103.                 except KeyError:</font>
<font color="red"> 104.                     raise Http404(_(&quot;No month specified&quot;))</font>
<font color="red"> 105.         return month</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def get_next_month(self, date):</font>
<font color="black"> 108.         &quot;&quot;&quot;</font>
<font color="black"> 109.         Get the next valid month.</font>
<font color="black"> 110.         &quot;&quot;&quot;</font>
<font color="red"> 111.         return _get_next_prev(self, date, is_previous=False, period='month')</font>
<font color="black"> 112. </font>
<font color="green"> 113.     def get_previous_month(self, date):</font>
<font color="black"> 114.         &quot;&quot;&quot;</font>
<font color="black"> 115.         Get the previous valid month.</font>
<font color="black"> 116.         &quot;&quot;&quot;</font>
<font color="red"> 117.         return _get_next_prev(self, date, is_previous=True, period='month')</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def _get_next_month(self, date):</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="black"> 121.         Return the start date of the next interval.</font>
<font color="black"> 122. </font>
<font color="black"> 123.         The interval is defined by start date &lt;= item date &lt; next start date.</font>
<font color="black"> 124.         &quot;&quot;&quot;</font>
<font color="red"> 125.         if date.month == 12:</font>
<font color="red"> 126.             return date.replace(year=date.year + 1, month=1, day=1)</font>
<font color="black"> 127.         else:</font>
<font color="red"> 128.             return date.replace(month=date.month + 1, day=1)</font>
<font color="black"> 129. </font>
<font color="green"> 130.     def _get_current_month(self, date):</font>
<font color="black"> 131.         &quot;&quot;&quot;</font>
<font color="black"> 132.         Return the start date of the previous interval.</font>
<font color="black"> 133.         &quot;&quot;&quot;</font>
<font color="red"> 134.         return date.replace(day=1)</font>
<font color="black"> 135. </font>
<font color="black"> 136. </font>
<font color="green"> 137. class DayMixin(object):</font>
<font color="black"> 138.     &quot;&quot;&quot;</font>
<font color="black"> 139.     Mixin for views manipulating day-based data.</font>
<font color="green"> 140.     &quot;&quot;&quot;</font>
<font color="green"> 141.     day_format = '%d'</font>
<font color="green"> 142.     day = None</font>
<font color="black"> 143. </font>
<font color="green"> 144.     def get_day_format(self):</font>
<font color="black"> 145.         &quot;&quot;&quot;</font>
<font color="black"> 146.         Get a day format string in strptime syntax to be used to parse the day</font>
<font color="black"> 147.         from url variables.</font>
<font color="black"> 148.         &quot;&quot;&quot;</font>
<font color="red"> 149.         return self.day_format</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def get_day(self):</font>
<font color="black"> 152.         &quot;&quot;&quot;</font>
<font color="black"> 153.         Return the day for which this view should display data.</font>
<font color="black"> 154.         &quot;&quot;&quot;</font>
<font color="red"> 155.         day = self.day</font>
<font color="red"> 156.         if day is None:</font>
<font color="red"> 157.             try:</font>
<font color="red"> 158.                 day = self.kwargs['day']</font>
<font color="red"> 159.             except KeyError:</font>
<font color="red"> 160.                 try:</font>
<font color="red"> 161.                     day = self.request.GET['day']</font>
<font color="red"> 162.                 except KeyError:</font>
<font color="red"> 163.                     raise Http404(_(&quot;No day specified&quot;))</font>
<font color="red"> 164.         return day</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def get_next_day(self, date):</font>
<font color="black"> 167.         &quot;&quot;&quot;</font>
<font color="black"> 168.         Get the next valid day.</font>
<font color="black"> 169.         &quot;&quot;&quot;</font>
<font color="red"> 170.         return _get_next_prev(self, date, is_previous=False, period='day')</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def get_previous_day(self, date):</font>
<font color="black"> 173.         &quot;&quot;&quot;</font>
<font color="black"> 174.         Get the previous valid day.</font>
<font color="black"> 175.         &quot;&quot;&quot;</font>
<font color="red"> 176.         return _get_next_prev(self, date, is_previous=True, period='day')</font>
<font color="black"> 177. </font>
<font color="green"> 178.     def _get_next_day(self, date):</font>
<font color="black"> 179.         &quot;&quot;&quot;</font>
<font color="black"> 180.         Return the start date of the next interval.</font>
<font color="black"> 181. </font>
<font color="black"> 182.         The interval is defined by start date &lt;= item date &lt; next start date.</font>
<font color="black"> 183.         &quot;&quot;&quot;</font>
<font color="red"> 184.         return date + datetime.timedelta(days=1)</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def _get_current_day(self, date):</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="black"> 188.         Return the start date of the current interval.</font>
<font color="black"> 189.         &quot;&quot;&quot;</font>
<font color="red"> 190.         return date</font>
<font color="black"> 191. </font>
<font color="black"> 192. </font>
<font color="green"> 193. class WeekMixin(object):</font>
<font color="black"> 194.     &quot;&quot;&quot;</font>
<font color="black"> 195.     Mixin for views manipulating week-based data.</font>
<font color="green"> 196.     &quot;&quot;&quot;</font>
<font color="green"> 197.     week_format = '%U'</font>
<font color="green"> 198.     week = None</font>
<font color="black"> 199. </font>
<font color="green"> 200.     def get_week_format(self):</font>
<font color="black"> 201.         &quot;&quot;&quot;</font>
<font color="black"> 202.         Get a week format string in strptime syntax to be used to parse the</font>
<font color="black"> 203.         week from url variables.</font>
<font color="black"> 204.         &quot;&quot;&quot;</font>
<font color="red"> 205.         return self.week_format</font>
<font color="black"> 206. </font>
<font color="green"> 207.     def get_week(self):</font>
<font color="black"> 208.         &quot;&quot;&quot;</font>
<font color="black"> 209.         Return the week for which this view should display data</font>
<font color="black"> 210.         &quot;&quot;&quot;</font>
<font color="red"> 211.         week = self.week</font>
<font color="red"> 212.         if week is None:</font>
<font color="red"> 213.             try:</font>
<font color="red"> 214.                 week = self.kwargs['week']</font>
<font color="red"> 215.             except KeyError:</font>
<font color="red"> 216.                 try:</font>
<font color="red"> 217.                     week = self.request.GET['week']</font>
<font color="red"> 218.                 except KeyError:</font>
<font color="red"> 219.                     raise Http404(_(&quot;No week specified&quot;))</font>
<font color="red"> 220.         return week</font>
<font color="black"> 221. </font>
<font color="green"> 222.     def get_next_week(self, date):</font>
<font color="black"> 223.         &quot;&quot;&quot;</font>
<font color="black"> 224.         Get the next valid week.</font>
<font color="black"> 225.         &quot;&quot;&quot;</font>
<font color="red"> 226.         return _get_next_prev(self, date, is_previous=False, period='week')</font>
<font color="black"> 227. </font>
<font color="green"> 228.     def get_previous_week(self, date):</font>
<font color="black"> 229.         &quot;&quot;&quot;</font>
<font color="black"> 230.         Get the previous valid week.</font>
<font color="black"> 231.         &quot;&quot;&quot;</font>
<font color="red"> 232.         return _get_next_prev(self, date, is_previous=True, period='week')</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def _get_next_week(self, date):</font>
<font color="black"> 235.         &quot;&quot;&quot;</font>
<font color="black"> 236.         Return the start date of the next interval.</font>
<font color="black"> 237. </font>
<font color="black"> 238.         The interval is defined by start date &lt;= item date &lt; next start date.</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="red"> 240.         return date + datetime.timedelta(days=7 - self._get_weekday(date))</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def _get_current_week(self, date):</font>
<font color="black"> 243.         &quot;&quot;&quot;</font>
<font color="black"> 244.         Return the start date of the current interval.</font>
<font color="black"> 245.         &quot;&quot;&quot;</font>
<font color="red"> 246.         return date - datetime.timedelta(self._get_weekday(date))</font>
<font color="black"> 247. </font>
<font color="green"> 248.     def _get_weekday(self, date):</font>
<font color="black"> 249.         &quot;&quot;&quot;</font>
<font color="black"> 250.         Return the weekday for a given date.</font>
<font color="black"> 251. </font>
<font color="black"> 252.         The first day according to the week format is 0 and the last day is 6.</font>
<font color="black"> 253.         &quot;&quot;&quot;</font>
<font color="red"> 254.         week_format = self.get_week_format()</font>
<font color="red"> 255.         if week_format == '%W':                 # week starts on Monday</font>
<font color="red"> 256.             return date.weekday()</font>
<font color="red"> 257.         elif week_format == '%U':               # week starts on Sunday</font>
<font color="red"> 258.             return (date.weekday() + 1) % 7</font>
<font color="black"> 259.         else:</font>
<font color="red"> 260.             raise ValueError(&quot;unknown week format: %s&quot; % week_format)</font>
<font color="black"> 261. </font>
<font color="black"> 262. </font>
<font color="green"> 263. class DateMixin(object):</font>
<font color="black"> 264.     &quot;&quot;&quot;</font>
<font color="black"> 265.     Mixin class for views manipulating date-based data.</font>
<font color="green"> 266.     &quot;&quot;&quot;</font>
<font color="green"> 267.     date_field = None</font>
<font color="green"> 268.     allow_future = False</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def get_date_field(self):</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="black"> 272.         Get the name of the date field to be used to filter by.</font>
<font color="black"> 273.         &quot;&quot;&quot;</font>
<font color="red"> 274.         if self.date_field is None:</font>
<font color="red"> 275.             raise ImproperlyConfigured(&quot;%s.date_field is required.&quot; % self.__class__.__name__)</font>
<font color="red"> 276.         return self.date_field</font>
<font color="black"> 277. </font>
<font color="green"> 278.     def get_allow_future(self):</font>
<font color="black"> 279.         &quot;&quot;&quot;</font>
<font color="black"> 280.         Returns `True` if the view should be allowed to display objects from</font>
<font color="black"> 281.         the future.</font>
<font color="black"> 282.         &quot;&quot;&quot;</font>
<font color="red"> 283.         return self.allow_future</font>
<font color="black"> 284. </font>
<font color="black"> 285.     # Note: the following three methods only work in subclasses that also</font>
<font color="black"> 286.     # inherit SingleObjectMixin or MultipleObjectMixin.</font>
<font color="black"> 287. </font>
<font color="green"> 288.     @cached_property</font>
<font color="black"> 289.     def uses_datetime_field(self):</font>
<font color="black"> 290.         &quot;&quot;&quot;</font>
<font color="black"> 291.         Return `True` if the date field is a `DateTimeField` and `False`</font>
<font color="black"> 292.         if it's a `DateField`.</font>
<font color="black"> 293.         &quot;&quot;&quot;</font>
<font color="red"> 294.         model = self.get_queryset().model if self.model is None else self.model</font>
<font color="red"> 295.         field = model._meta.get_field(self.get_date_field())</font>
<font color="red"> 296.         return isinstance(field, models.DateTimeField)</font>
<font color="black"> 297. </font>
<font color="green"> 298.     def _make_date_lookup_arg(self, value):</font>
<font color="black"> 299.         &quot;&quot;&quot;</font>
<font color="black"> 300.         Convert a date into a datetime when the date field is a DateTimeField.</font>
<font color="black"> 301. </font>
<font color="black"> 302.         When time zone support is enabled, `date` is assumed to be in the</font>
<font color="black"> 303.         current time zone, so that displayed items are consistent with the URL.</font>
<font color="black"> 304.         &quot;&quot;&quot;</font>
<font color="red"> 305.         if self.uses_datetime_field:</font>
<font color="red"> 306.             value = datetime.datetime.combine(value, datetime.time.min)</font>
<font color="red"> 307.             if settings.USE_TZ:</font>
<font color="red"> 308.                 value = timezone.make_aware(value, timezone.get_current_timezone())</font>
<font color="red"> 309.         return value</font>
<font color="black"> 310. </font>
<font color="green"> 311.     def _make_single_date_lookup(self, date):</font>
<font color="black"> 312.         &quot;&quot;&quot;</font>
<font color="black"> 313.         Get the lookup kwargs for filtering on a single date.</font>
<font color="black"> 314. </font>
<font color="black"> 315.         If the date field is a DateTimeField, we can't just filter on</font>
<font color="black"> 316.         date_field=date because that doesn't take the time into account.</font>
<font color="black"> 317.         &quot;&quot;&quot;</font>
<font color="red"> 318.         date_field = self.get_date_field()</font>
<font color="red"> 319.         if self.uses_datetime_field:</font>
<font color="red"> 320.             since = self._make_date_lookup_arg(date)</font>
<font color="red"> 321.             until = self._make_date_lookup_arg(date + datetime.timedelta(days=1))</font>
<font color="red"> 322.             return {</font>
<font color="red"> 323.                 '%s__gte' % date_field: since,</font>
<font color="red"> 324.                 '%s__lt' % date_field: until,</font>
<font color="black"> 325.             }</font>
<font color="black"> 326.         else:</font>
<font color="black"> 327.             # Skip self._make_date_lookup_arg, it's a no-op in this branch.</font>
<font color="red"> 328.             return {date_field: date}</font>
<font color="black"> 329. </font>
<font color="black"> 330. </font>
<font color="green"> 331. class BaseDateListView(MultipleObjectMixin, DateMixin, View):</font>
<font color="black"> 332.     &quot;&quot;&quot;</font>
<font color="black"> 333.     Abstract base class for date-based views displaying a list of objects.</font>
<font color="green"> 334.     &quot;&quot;&quot;</font>
<font color="green"> 335.     allow_empty = False</font>
<font color="green"> 336.     date_list_period = 'year'</font>
<font color="black"> 337. </font>
<font color="green"> 338.     def get(self, request, *args, **kwargs):</font>
<font color="red"> 339.         self.date_list, self.object_list, extra_context = self.get_dated_items()</font>
<font color="red"> 340.         context = self.get_context_data(object_list=self.object_list,</font>
<font color="red"> 341.                                         date_list=self.date_list)</font>
<font color="red"> 342.         context.update(extra_context)</font>
<font color="red"> 343.         return self.render_to_response(context)</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def get_dated_items(self):</font>
<font color="black"> 346.         &quot;&quot;&quot;</font>
<font color="black"> 347.         Obtain the list of dates and items.</font>
<font color="black"> 348.         &quot;&quot;&quot;</font>
<font color="red"> 349.         raise NotImplementedError('A DateView must provide an implementation of get_dated_items()')</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def get_ordering(self):</font>
<font color="black"> 352.         &quot;&quot;&quot;</font>
<font color="black"> 353.         Returns the field or fields to use for ordering the queryset; uses the</font>
<font color="black"> 354.         date field by default.</font>
<font color="black"> 355.         &quot;&quot;&quot;</font>
<font color="red"> 356.         return '-%s' % self.get_date_field() if self.ordering is None else self.ordering</font>
<font color="black"> 357. </font>
<font color="green"> 358.     def get_dated_queryset(self, **lookup):</font>
<font color="black"> 359.         &quot;&quot;&quot;</font>
<font color="black"> 360.         Get a queryset properly filtered according to `allow_future` and any</font>
<font color="black"> 361.         extra lookup kwargs.</font>
<font color="black"> 362.         &quot;&quot;&quot;</font>
<font color="red"> 363.         qs = self.get_queryset().filter(**lookup)</font>
<font color="red"> 364.         date_field = self.get_date_field()</font>
<font color="red"> 365.         allow_future = self.get_allow_future()</font>
<font color="red"> 366.         allow_empty = self.get_allow_empty()</font>
<font color="red"> 367.         paginate_by = self.get_paginate_by(qs)</font>
<font color="black"> 368. </font>
<font color="red"> 369.         if not allow_future:</font>
<font color="red"> 370.             now = timezone.now() if self.uses_datetime_field else timezone_today()</font>
<font color="red"> 371.             qs = qs.filter(**{'%s__lte' % date_field: now})</font>
<font color="black"> 372. </font>
<font color="red"> 373.         if not allow_empty:</font>
<font color="black"> 374.             # When pagination is enabled, it's better to do a cheap query</font>
<font color="black"> 375.             # than to load the unpaginated queryset in memory.</font>
<font color="red"> 376.             is_empty = len(qs) == 0 if paginate_by is None else not qs.exists()</font>
<font color="red"> 377.             if is_empty:</font>
<font color="red"> 378.                 raise Http404(_(&quot;No %(verbose_name_plural)s available&quot;) % {</font>
<font color="red"> 379.                     'verbose_name_plural': force_text(qs.model._meta.verbose_name_plural)</font>
<font color="black"> 380.                 })</font>
<font color="black"> 381. </font>
<font color="red"> 382.         return qs</font>
<font color="black"> 383. </font>
<font color="green"> 384.     def get_date_list_period(self):</font>
<font color="black"> 385.         &quot;&quot;&quot;</font>
<font color="black"> 386.         Get the aggregation period for the list of dates: 'year', 'month', or 'day'.</font>
<font color="black"> 387.         &quot;&quot;&quot;</font>
<font color="red"> 388.         return self.date_list_period</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def get_date_list(self, queryset, date_type=None, ordering='ASC'):</font>
<font color="black"> 391.         &quot;&quot;&quot;</font>
<font color="black"> 392.         Get a date list by calling `queryset.dates/datetimes()`, checking</font>
<font color="black"> 393.         along the way for empty lists that aren't allowed.</font>
<font color="black"> 394.         &quot;&quot;&quot;</font>
<font color="red"> 395.         date_field = self.get_date_field()</font>
<font color="red"> 396.         allow_empty = self.get_allow_empty()</font>
<font color="red"> 397.         if date_type is None:</font>
<font color="red"> 398.             date_type = self.get_date_list_period()</font>
<font color="black"> 399. </font>
<font color="red"> 400.         if self.uses_datetime_field:</font>
<font color="red"> 401.             date_list = queryset.datetimes(date_field, date_type, ordering)</font>
<font color="black"> 402.         else:</font>
<font color="red"> 403.             date_list = queryset.dates(date_field, date_type, ordering)</font>
<font color="red"> 404.         if date_list is not None and not date_list and not allow_empty:</font>
<font color="red"> 405.             name = force_text(queryset.model._meta.verbose_name_plural)</font>
<font color="red"> 406.             raise Http404(_(&quot;No %(verbose_name_plural)s available&quot;) %</font>
<font color="red"> 407.                           {'verbose_name_plural': name})</font>
<font color="black"> 408. </font>
<font color="red"> 409.         return date_list</font>
<font color="black"> 410. </font>
<font color="black"> 411. </font>
<font color="green"> 412. class BaseArchiveIndexView(BaseDateListView):</font>
<font color="black"> 413.     &quot;&quot;&quot;</font>
<font color="black"> 414.     Base class for archives of date-based items.</font>
<font color="black"> 415. </font>
<font color="black"> 416.     Requires a response mixin.</font>
<font color="green"> 417.     &quot;&quot;&quot;</font>
<font color="green"> 418.     context_object_name = 'latest'</font>
<font color="black"> 419. </font>
<font color="green"> 420.     def get_dated_items(self):</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="black"> 422.         Return (date_list, items, extra_context) for this request.</font>
<font color="black"> 423.         &quot;&quot;&quot;</font>
<font color="red"> 424.         qs = self.get_dated_queryset()</font>
<font color="red"> 425.         date_list = self.get_date_list(qs, ordering='DESC')</font>
<font color="black"> 426. </font>
<font color="red"> 427.         if not date_list:</font>
<font color="red"> 428.             qs = qs.none()</font>
<font color="black"> 429. </font>
<font color="red"> 430.         return (date_list, qs, {})</font>
<font color="black"> 431. </font>
<font color="black"> 432. </font>
<font color="green"> 433. class ArchiveIndexView(MultipleObjectTemplateResponseMixin, BaseArchiveIndexView):</font>
<font color="black"> 434.     &quot;&quot;&quot;</font>
<font color="black"> 435.     Top-level archive of date-based items.</font>
<font color="green"> 436.     &quot;&quot;&quot;</font>
<font color="green"> 437.     template_name_suffix = '_archive'</font>
<font color="black"> 438. </font>
<font color="black"> 439. </font>
<font color="green"> 440. class BaseYearArchiveView(YearMixin, BaseDateListView):</font>
<font color="black"> 441.     &quot;&quot;&quot;</font>
<font color="black"> 442.     List of objects published in a given year.</font>
<font color="green"> 443.     &quot;&quot;&quot;</font>
<font color="green"> 444.     date_list_period = 'month'</font>
<font color="green"> 445.     make_object_list = False</font>
<font color="black"> 446. </font>
<font color="green"> 447.     def get_dated_items(self):</font>
<font color="black"> 448.         &quot;&quot;&quot;</font>
<font color="black"> 449.         Return (date_list, items, extra_context) for this request.</font>
<font color="black"> 450.         &quot;&quot;&quot;</font>
<font color="red"> 451.         year = self.get_year()</font>
<font color="black"> 452. </font>
<font color="red"> 453.         date_field = self.get_date_field()</font>
<font color="red"> 454.         date = _date_from_string(year, self.get_year_format())</font>
<font color="black"> 455. </font>
<font color="red"> 456.         since = self._make_date_lookup_arg(date)</font>
<font color="red"> 457.         until = self._make_date_lookup_arg(self._get_next_year(date))</font>
<font color="red"> 458.         lookup_kwargs = {</font>
<font color="red"> 459.             '%s__gte' % date_field: since,</font>
<font color="red"> 460.             '%s__lt' % date_field: until,</font>
<font color="black"> 461.         }</font>
<font color="black"> 462. </font>
<font color="red"> 463.         qs = self.get_dated_queryset(**lookup_kwargs)</font>
<font color="red"> 464.         date_list = self.get_date_list(qs)</font>
<font color="black"> 465. </font>
<font color="red"> 466.         if not self.get_make_object_list():</font>
<font color="black"> 467.             # We need this to be a queryset since parent classes introspect it</font>
<font color="black"> 468.             # to find information about the model.</font>
<font color="red"> 469.             qs = qs.none()</font>
<font color="black"> 470. </font>
<font color="red"> 471.         return (date_list, qs, {</font>
<font color="red"> 472.             'year': date,</font>
<font color="red"> 473.             'next_year': self.get_next_year(date),</font>
<font color="red"> 474.             'previous_year': self.get_previous_year(date),</font>
<font color="black"> 475.         })</font>
<font color="black"> 476. </font>
<font color="green"> 477.     def get_make_object_list(self):</font>
<font color="black"> 478.         &quot;&quot;&quot;</font>
<font color="black"> 479.         Return `True` if this view should contain the full list of objects in</font>
<font color="black"> 480.         the given year.</font>
<font color="black"> 481.         &quot;&quot;&quot;</font>
<font color="red"> 482.         return self.make_object_list</font>
<font color="black"> 483. </font>
<font color="black"> 484. </font>
<font color="green"> 485. class YearArchiveView(MultipleObjectTemplateResponseMixin, BaseYearArchiveView):</font>
<font color="black"> 486.     &quot;&quot;&quot;</font>
<font color="black"> 487.     List of objects published in a given year.</font>
<font color="green"> 488.     &quot;&quot;&quot;</font>
<font color="green"> 489.     template_name_suffix = '_archive_year'</font>
<font color="black"> 490. </font>
<font color="black"> 491. </font>
<font color="green"> 492. class BaseMonthArchiveView(YearMixin, MonthMixin, BaseDateListView):</font>
<font color="black"> 493.     &quot;&quot;&quot;</font>
<font color="black"> 494.     List of objects published in a given month.</font>
<font color="green"> 495.     &quot;&quot;&quot;</font>
<font color="green"> 496.     date_list_period = 'day'</font>
<font color="black"> 497. </font>
<font color="green"> 498.     def get_dated_items(self):</font>
<font color="black"> 499.         &quot;&quot;&quot;</font>
<font color="black"> 500.         Return (date_list, items, extra_context) for this request.</font>
<font color="black"> 501.         &quot;&quot;&quot;</font>
<font color="red"> 502.         year = self.get_year()</font>
<font color="red"> 503.         month = self.get_month()</font>
<font color="black"> 504. </font>
<font color="red"> 505.         date_field = self.get_date_field()</font>
<font color="red"> 506.         date = _date_from_string(year, self.get_year_format(),</font>
<font color="red"> 507.                                  month, self.get_month_format())</font>
<font color="black"> 508. </font>
<font color="red"> 509.         since = self._make_date_lookup_arg(date)</font>
<font color="red"> 510.         until = self._make_date_lookup_arg(self._get_next_month(date))</font>
<font color="red"> 511.         lookup_kwargs = {</font>
<font color="red"> 512.             '%s__gte' % date_field: since,</font>
<font color="red"> 513.             '%s__lt' % date_field: until,</font>
<font color="black"> 514.         }</font>
<font color="black"> 515. </font>
<font color="red"> 516.         qs = self.get_dated_queryset(**lookup_kwargs)</font>
<font color="red"> 517.         date_list = self.get_date_list(qs)</font>
<font color="black"> 518. </font>
<font color="red"> 519.         return (date_list, qs, {</font>
<font color="red"> 520.             'month': date,</font>
<font color="red"> 521.             'next_month': self.get_next_month(date),</font>
<font color="red"> 522.             'previous_month': self.get_previous_month(date),</font>
<font color="black"> 523.         })</font>
<font color="black"> 524. </font>
<font color="black"> 525. </font>
<font color="green"> 526. class MonthArchiveView(MultipleObjectTemplateResponseMixin, BaseMonthArchiveView):</font>
<font color="black"> 527.     &quot;&quot;&quot;</font>
<font color="black"> 528.     List of objects published in a given month.</font>
<font color="green"> 529.     &quot;&quot;&quot;</font>
<font color="green"> 530.     template_name_suffix = '_archive_month'</font>
<font color="black"> 531. </font>
<font color="black"> 532. </font>
<font color="green"> 533. class BaseWeekArchiveView(YearMixin, WeekMixin, BaseDateListView):</font>
<font color="black"> 534.     &quot;&quot;&quot;</font>
<font color="black"> 535.     List of objects published in a given week.</font>
<font color="green"> 536.     &quot;&quot;&quot;</font>
<font color="black"> 537. </font>
<font color="green"> 538.     def get_dated_items(self):</font>
<font color="black"> 539.         &quot;&quot;&quot;</font>
<font color="black"> 540.         Return (date_list, items, extra_context) for this request.</font>
<font color="black"> 541.         &quot;&quot;&quot;</font>
<font color="red"> 542.         year = self.get_year()</font>
<font color="red"> 543.         week = self.get_week()</font>
<font color="black"> 544. </font>
<font color="red"> 545.         date_field = self.get_date_field()</font>
<font color="red"> 546.         week_format = self.get_week_format()</font>
<font color="red"> 547.         week_start = {</font>
<font color="red"> 548.             '%W': '1',</font>
<font color="red"> 549.             '%U': '0',</font>
<font color="red"> 550.         }[week_format]</font>
<font color="red"> 551.         date = _date_from_string(year, self.get_year_format(),</font>
<font color="red"> 552.                                  week_start, '%w',</font>
<font color="red"> 553.                                  week, week_format)</font>
<font color="black"> 554. </font>
<font color="red"> 555.         since = self._make_date_lookup_arg(date)</font>
<font color="red"> 556.         until = self._make_date_lookup_arg(self._get_next_week(date))</font>
<font color="red"> 557.         lookup_kwargs = {</font>
<font color="red"> 558.             '%s__gte' % date_field: since,</font>
<font color="red"> 559.             '%s__lt' % date_field: until,</font>
<font color="black"> 560.         }</font>
<font color="black"> 561. </font>
<font color="red"> 562.         qs = self.get_dated_queryset(**lookup_kwargs)</font>
<font color="black"> 563. </font>
<font color="red"> 564.         return (None, qs, {</font>
<font color="red"> 565.             'week': date,</font>
<font color="red"> 566.             'next_week': self.get_next_week(date),</font>
<font color="red"> 567.             'previous_week': self.get_previous_week(date),</font>
<font color="black"> 568.         })</font>
<font color="black"> 569. </font>
<font color="black"> 570. </font>
<font color="green"> 571. class WeekArchiveView(MultipleObjectTemplateResponseMixin, BaseWeekArchiveView):</font>
<font color="black"> 572.     &quot;&quot;&quot;</font>
<font color="black"> 573.     List of objects published in a given week.</font>
<font color="green"> 574.     &quot;&quot;&quot;</font>
<font color="green"> 575.     template_name_suffix = '_archive_week'</font>
<font color="black"> 576. </font>
<font color="black"> 577. </font>
<font color="green"> 578. class BaseDayArchiveView(YearMixin, MonthMixin, DayMixin, BaseDateListView):</font>
<font color="black"> 579.     &quot;&quot;&quot;</font>
<font color="black"> 580.     List of objects published on a given day.</font>
<font color="green"> 581.     &quot;&quot;&quot;</font>
<font color="green"> 582.     def get_dated_items(self):</font>
<font color="black"> 583.         &quot;&quot;&quot;</font>
<font color="black"> 584.         Return (date_list, items, extra_context) for this request.</font>
<font color="black"> 585.         &quot;&quot;&quot;</font>
<font color="red"> 586.         year = self.get_year()</font>
<font color="red"> 587.         month = self.get_month()</font>
<font color="red"> 588.         day = self.get_day()</font>
<font color="black"> 589. </font>
<font color="red"> 590.         date = _date_from_string(year, self.get_year_format(),</font>
<font color="red"> 591.                                  month, self.get_month_format(),</font>
<font color="red"> 592.                                  day, self.get_day_format())</font>
<font color="black"> 593. </font>
<font color="red"> 594.         return self._get_dated_items(date)</font>
<font color="black"> 595. </font>
<font color="green"> 596.     def _get_dated_items(self, date):</font>
<font color="black"> 597.         &quot;&quot;&quot;</font>
<font color="black"> 598.         Do the actual heavy lifting of getting the dated items; this accepts a</font>
<font color="black"> 599.         date object so that TodayArchiveView can be trivial.</font>
<font color="black"> 600.         &quot;&quot;&quot;</font>
<font color="red"> 601.         lookup_kwargs = self._make_single_date_lookup(date)</font>
<font color="red"> 602.         qs = self.get_dated_queryset(**lookup_kwargs)</font>
<font color="black"> 603. </font>
<font color="red"> 604.         return (None, qs, {</font>
<font color="red"> 605.             'day': date,</font>
<font color="red"> 606.             'previous_day': self.get_previous_day(date),</font>
<font color="red"> 607.             'next_day': self.get_next_day(date),</font>
<font color="red"> 608.             'previous_month': self.get_previous_month(date),</font>
<font color="red"> 609.             'next_month': self.get_next_month(date)</font>
<font color="black"> 610.         })</font>
<font color="black"> 611. </font>
<font color="black"> 612. </font>
<font color="green"> 613. class DayArchiveView(MultipleObjectTemplateResponseMixin, BaseDayArchiveView):</font>
<font color="black"> 614.     &quot;&quot;&quot;</font>
<font color="black"> 615.     List of objects published on a given day.</font>
<font color="green"> 616.     &quot;&quot;&quot;</font>
<font color="green"> 617.     template_name_suffix = &quot;_archive_day&quot;</font>
<font color="black"> 618. </font>
<font color="black"> 619. </font>
<font color="green"> 620. class BaseTodayArchiveView(BaseDayArchiveView):</font>
<font color="black"> 621.     &quot;&quot;&quot;</font>
<font color="black"> 622.     List of objects published today.</font>
<font color="green"> 623.     &quot;&quot;&quot;</font>
<font color="black"> 624. </font>
<font color="green"> 625.     def get_dated_items(self):</font>
<font color="black"> 626.         &quot;&quot;&quot;</font>
<font color="black"> 627.         Return (date_list, items, extra_context) for this request.</font>
<font color="black"> 628.         &quot;&quot;&quot;</font>
<font color="red"> 629.         return self._get_dated_items(datetime.date.today())</font>
<font color="black"> 630. </font>
<font color="black"> 631. </font>
<font color="green"> 632. class TodayArchiveView(MultipleObjectTemplateResponseMixin, BaseTodayArchiveView):</font>
<font color="black"> 633.     &quot;&quot;&quot;</font>
<font color="black"> 634.     List of objects published today.</font>
<font color="green"> 635.     &quot;&quot;&quot;</font>
<font color="green"> 636.     template_name_suffix = &quot;_archive_day&quot;</font>
<font color="black"> 637. </font>
<font color="black"> 638. </font>
<font color="green"> 639. class BaseDateDetailView(YearMixin, MonthMixin, DayMixin, DateMixin, BaseDetailView):</font>
<font color="black"> 640.     &quot;&quot;&quot;</font>
<font color="black"> 641.     Detail view of a single object on a single date; this differs from the</font>
<font color="black"> 642.     standard DetailView by accepting a year/month/day in the URL.</font>
<font color="green"> 643.     &quot;&quot;&quot;</font>
<font color="green"> 644.     def get_object(self, queryset=None):</font>
<font color="black"> 645.         &quot;&quot;&quot;</font>
<font color="black"> 646.         Get the object this request displays.</font>
<font color="black"> 647.         &quot;&quot;&quot;</font>
<font color="red"> 648.         year = self.get_year()</font>
<font color="red"> 649.         month = self.get_month()</font>
<font color="red"> 650.         day = self.get_day()</font>
<font color="red"> 651.         date = _date_from_string(year, self.get_year_format(),</font>
<font color="red"> 652.                                  month, self.get_month_format(),</font>
<font color="red"> 653.                                  day, self.get_day_format())</font>
<font color="black"> 654. </font>
<font color="black"> 655.         # Use a custom queryset if provided</font>
<font color="red"> 656.         qs = self.get_queryset() if queryset is None else queryset</font>
<font color="black"> 657. </font>
<font color="red"> 658.         if not self.get_allow_future() and date &gt; datetime.date.today():</font>
<font color="red"> 659.             raise Http404(_(</font>
<font color="red"> 660.                 &quot;Future %(verbose_name_plural)s not available because &quot;</font>
<font color="red"> 661.                 &quot;%(class_name)s.allow_future is False.&quot;) % {</font>
<font color="red"> 662.                 'verbose_name_plural': qs.model._meta.verbose_name_plural,</font>
<font color="red"> 663.                 'class_name': self.__class__.__name__,</font>
<font color="black"> 664.                 },</font>
<font color="black"> 665.             )</font>
<font color="black"> 666. </font>
<font color="black"> 667.         # Filter down a queryset from self.queryset using the date from the</font>
<font color="black"> 668.         # URL. This'll get passed as the queryset to DetailView.get_object,</font>
<font color="black"> 669.         # which'll handle the 404</font>
<font color="red"> 670.         lookup_kwargs = self._make_single_date_lookup(date)</font>
<font color="red"> 671.         qs = qs.filter(**lookup_kwargs)</font>
<font color="black"> 672. </font>
<font color="red"> 673.         return super(BaseDetailView, self).get_object(queryset=qs)</font>
<font color="black"> 674. </font>
<font color="black"> 675. </font>
<font color="green"> 676. class DateDetailView(SingleObjectTemplateResponseMixin, BaseDateDetailView):</font>
<font color="black"> 677.     &quot;&quot;&quot;</font>
<font color="black"> 678.     Detail view of a single object on a single date; this differs from the</font>
<font color="black"> 679.     standard DetailView by accepting a year/month/day in the URL.</font>
<font color="green"> 680.     &quot;&quot;&quot;</font>
<font color="green"> 681.     template_name_suffix = '_detail'</font>
<font color="black"> 682. </font>
<font color="black"> 683. </font>
<font color="green"> 684. def _date_from_string(year, year_format, month='', month_format='', day='', day_format='', delim='__'):</font>
<font color="black"> 685.     &quot;&quot;&quot;</font>
<font color="black"> 686.     Helper: get a datetime.date object given a format string and a year,</font>
<font color="black"> 687.     month, and day (only year is mandatory). Raise a 404 for an invalid date.</font>
<font color="black"> 688.     &quot;&quot;&quot;</font>
<font color="red"> 689.     format = delim.join((year_format, month_format, day_format))</font>
<font color="red"> 690.     datestr = delim.join((year, month, day))</font>
<font color="red"> 691.     try:</font>
<font color="red"> 692.         return datetime.datetime.strptime(force_str(datestr), format).date()</font>
<font color="red"> 693.     except ValueError:</font>
<font color="red"> 694.         raise Http404(_(&quot;Invalid date string '%(datestr)s' given format '%(format)s'&quot;) % {</font>
<font color="red"> 695.             'datestr': datestr,</font>
<font color="red"> 696.             'format': format,</font>
<font color="black"> 697.         })</font>
<font color="black"> 698. </font>
<font color="black"> 699. </font>
<font color="green"> 700. def _get_next_prev(generic_view, date, is_previous, period):</font>
<font color="black"> 701.     &quot;&quot;&quot;</font>
<font color="black"> 702.     Helper: Get the next or the previous valid date. The idea is to allow</font>
<font color="black"> 703.     links on month/day views to never be 404s by never providing a date</font>
<font color="black"> 704.     that'll be invalid for the given view.</font>
<font color="black"> 705. </font>
<font color="black"> 706.     This is a bit complicated since it handles different intervals of time,</font>
<font color="black"> 707.     hence the coupling to generic_view.</font>
<font color="black"> 708. </font>
<font color="black"> 709.     However in essence the logic comes down to:</font>
<font color="black"> 710. </font>
<font color="black"> 711.         * If allow_empty and allow_future are both true, this is easy: just</font>
<font color="black"> 712.           return the naive result (just the next/previous day/week/month,</font>
<font color="black"> 713.           regardless of object existence.)</font>
<font color="black"> 714. </font>
<font color="black"> 715.         * If allow_empty is true, allow_future is false, and the naive result</font>
<font color="black"> 716.           isn't in the future, then return it; otherwise return None.</font>
<font color="black"> 717. </font>
<font color="black"> 718.         * If allow_empty is false and allow_future is true, return the next</font>
<font color="black"> 719.           date *that contains a valid object*, even if it's in the future. If</font>
<font color="black"> 720.           there are no next objects, return None.</font>
<font color="black"> 721. </font>
<font color="black"> 722.         * If allow_empty is false and allow_future is false, return the next</font>
<font color="black"> 723.           date that contains a valid object. If that date is in the future, or</font>
<font color="black"> 724.           if there are no next objects, return None.</font>
<font color="black"> 725.     &quot;&quot;&quot;</font>
<font color="red"> 726.     date_field = generic_view.get_date_field()</font>
<font color="red"> 727.     allow_empty = generic_view.get_allow_empty()</font>
<font color="red"> 728.     allow_future = generic_view.get_allow_future()</font>
<font color="black"> 729. </font>
<font color="red"> 730.     get_current = getattr(generic_view, '_get_current_%s' % period)</font>
<font color="red"> 731.     get_next = getattr(generic_view, '_get_next_%s' % period)</font>
<font color="black"> 732. </font>
<font color="black"> 733.     # Bounds of the current interval</font>
<font color="red"> 734.     start, end = get_current(date), get_next(date)</font>
<font color="black"> 735. </font>
<font color="black"> 736.     # If allow_empty is True, the naive result will be valid</font>
<font color="red"> 737.     if allow_empty:</font>
<font color="red"> 738.         if is_previous:</font>
<font color="red"> 739.             result = get_current(start - datetime.timedelta(days=1))</font>
<font color="black"> 740.         else:</font>
<font color="red"> 741.             result = end</font>
<font color="black"> 742. </font>
<font color="red"> 743.         if allow_future or result &lt;= timezone_today():</font>
<font color="red"> 744.             return result</font>
<font color="black"> 745.         else:</font>
<font color="red"> 746.             return None</font>
<font color="black"> 747. </font>
<font color="black"> 748.     # Otherwise, we'll need to go to the database to look for an object</font>
<font color="black"> 749.     # whose date_field is at least (greater than/less than) the given</font>
<font color="black"> 750.     # naive result</font>
<font color="black"> 751.     else:</font>
<font color="black"> 752.         # Construct a lookup and an ordering depending on whether we're doing</font>
<font color="black"> 753.         # a previous date or a next date lookup.</font>
<font color="red"> 754.         if is_previous:</font>
<font color="red"> 755.             lookup = {'%s__lt' % date_field: generic_view._make_date_lookup_arg(start)}</font>
<font color="red"> 756.             ordering = '-%s' % date_field</font>
<font color="black"> 757.         else:</font>
<font color="red"> 758.             lookup = {'%s__gte' % date_field: generic_view._make_date_lookup_arg(end)}</font>
<font color="red"> 759.             ordering = date_field</font>
<font color="black"> 760. </font>
<font color="black"> 761.         # Filter out objects in the future if appropriate.</font>
<font color="red"> 762.         if not allow_future:</font>
<font color="black"> 763.             # Fortunately, to match the implementation of allow_future,</font>
<font color="black"> 764.             # we need __lte, which doesn't conflict with __lt above.</font>
<font color="red"> 765.             if generic_view.uses_datetime_field:</font>
<font color="red"> 766.                 now = timezone.now()</font>
<font color="black"> 767.             else:</font>
<font color="red"> 768.                 now = timezone_today()</font>
<font color="red"> 769.             lookup['%s__lte' % date_field] = now</font>
<font color="black"> 770. </font>
<font color="red"> 771.         qs = generic_view.get_queryset().filter(**lookup).order_by(ordering)</font>
<font color="black"> 772. </font>
<font color="black"> 773.         # Snag the first object from the queryset; if it doesn't exist that</font>
<font color="black"> 774.         # means there's no next/previous link available.</font>
<font color="red"> 775.         try:</font>
<font color="red"> 776.             result = getattr(qs[0], date_field)</font>
<font color="red"> 777.         except IndexError:</font>
<font color="red"> 778.             return None</font>
<font color="black"> 779. </font>
<font color="black"> 780.         # Convert datetimes to dates in the current time zone.</font>
<font color="red"> 781.         if generic_view.uses_datetime_field:</font>
<font color="red"> 782.             if settings.USE_TZ:</font>
<font color="red"> 783.                 result = timezone.localtime(result)</font>
<font color="red"> 784.             result = result.date()</font>
<font color="black"> 785. </font>
<font color="black"> 786.         # Return the first day of the period.</font>
<font color="red"> 787.         return get_current(result)</font>
<font color="black"> 788. </font>
<font color="black"> 789. </font>
<font color="green"> 790. def timezone_today():</font>
<font color="black"> 791.     &quot;&quot;&quot;</font>
<font color="black"> 792.     Return the current date in the current time zone.</font>
<font color="black"> 793.     &quot;&quot;&quot;</font>
<font color="red"> 794.     if settings.USE_TZ:</font>
<font color="red"> 795.         return timezone.localtime(timezone.now()).date()</font>
<font color="black"> 796.     else:</font>
<font color="red"> 797.         return datetime.date.today()</font>
</pre>

