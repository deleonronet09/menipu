source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/base/operations.py</b><br>


file stats: <b>203 lines, 101 executed: 49.8% covered</b>
<pre>
<font color="green">   1. import datetime</font>
<font color="green">   2. import decimal</font>
<font color="green">   3. import warnings</font>
<font color="green">   4. from importlib import import_module</font>
<font color="black">   5. </font>
<font color="green">   6. from django.conf import settings</font>
<font color="green">   7. from django.core.exceptions import ImproperlyConfigured</font>
<font color="green">   8. from django.db.backends import utils</font>
<font color="green">   9. from django.utils import six, timezone</font>
<font color="green">  10. from django.utils.dateparse import parse_duration</font>
<font color="green">  11. from django.utils.deprecation import RemovedInDjango20Warning</font>
<font color="green">  12. from django.utils.encoding import force_text</font>
<font color="black">  13. </font>
<font color="black">  14. </font>
<font color="green">  15. class BaseDatabaseOperations(object):</font>
<font color="black">  16.     &quot;&quot;&quot;</font>
<font color="black">  17.     This class encapsulates all backend-specific differences, such as the way</font>
<font color="black">  18.     a backend performs ordering or calculates the ID of a recently-inserted</font>
<font color="black">  19.     row.</font>
<font color="green">  20.     &quot;&quot;&quot;</font>
<font color="green">  21.     compiler_module = &quot;django.db.models.sql.compiler&quot;</font>
<font color="black">  22. </font>
<font color="black">  23.     # Integer field safe ranges by `internal_type` as documented</font>
<font color="black">  24.     # in docs/ref/models/fields.txt.</font>
<font color="green">  25.     integer_field_ranges = {</font>
<font color="green">  26.         'SmallIntegerField': (-32768, 32767),</font>
<font color="green">  27.         'IntegerField': (-2147483648, 2147483647),</font>
<font color="green">  28.         'BigIntegerField': (-9223372036854775808, 9223372036854775807),</font>
<font color="green">  29.         'PositiveSmallIntegerField': (0, 32767),</font>
<font color="green">  30.         'PositiveIntegerField': (0, 2147483647),</font>
<font color="black">  31.     }</font>
<font color="black">  32. </font>
<font color="green">  33.     def __init__(self, connection):</font>
<font color="green">  34.         self.connection = connection</font>
<font color="green">  35.         self._cache = None</font>
<font color="black">  36. </font>
<font color="green">  37.     def autoinc_sql(self, table, column):</font>
<font color="black">  38.         &quot;&quot;&quot;</font>
<font color="black">  39.         Returns any SQL needed to support auto-incrementing primary keys, or</font>
<font color="black">  40.         None if no SQL is necessary.</font>
<font color="black">  41. </font>
<font color="black">  42.         This SQL is executed when a table is created.</font>
<font color="black">  43.         &quot;&quot;&quot;</font>
<font color="green">  44.         return None</font>
<font color="black">  45. </font>
<font color="green">  46.     def bulk_batch_size(self, fields, objs):</font>
<font color="black">  47.         &quot;&quot;&quot;</font>
<font color="black">  48.         Returns the maximum allowed batch size for the backend. The fields</font>
<font color="black">  49.         are the fields going to be inserted in the batch, the objs contains</font>
<font color="black">  50.         all the objects to be inserted.</font>
<font color="black">  51.         &quot;&quot;&quot;</font>
<font color="red">  52.         return len(objs)</font>
<font color="black">  53. </font>
<font color="green">  54.     def cache_key_culling_sql(self):</font>
<font color="black">  55.         &quot;&quot;&quot;</font>
<font color="black">  56.         Returns an SQL query that retrieves the first cache key greater than the</font>
<font color="black">  57.         n smallest.</font>
<font color="black">  58. </font>
<font color="black">  59.         This is used by the 'db' cache backend to determine where to start</font>
<font color="black">  60.         culling.</font>
<font color="black">  61.         &quot;&quot;&quot;</font>
<font color="red">  62.         return &quot;SELECT cache_key FROM %s ORDER BY cache_key LIMIT 1 OFFSET %%s&quot;</font>
<font color="black">  63. </font>
<font color="green">  64.     def unification_cast_sql(self, output_field):</font>
<font color="black">  65.         &quot;&quot;&quot;</font>
<font color="black">  66.         Given a field instance, returns the SQL necessary to cast the result of</font>
<font color="black">  67.         a union to that type. Note that the resulting string should contain a</font>
<font color="black">  68.         '%s' placeholder for the expression being cast.</font>
<font color="black">  69.         &quot;&quot;&quot;</font>
<font color="red">  70.         return '%s'</font>
<font color="black">  71. </font>
<font color="green">  72.     def date_extract_sql(self, lookup_type, field_name):</font>
<font color="black">  73.         &quot;&quot;&quot;</font>
<font color="black">  74.         Given a lookup_type of 'year', 'month' or 'day', returns the SQL that</font>
<font color="black">  75.         extracts a value from the given date field field_name.</font>
<font color="black">  76.         &quot;&quot;&quot;</font>
<font color="red">  77.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a date_extract_sql() method')</font>
<font color="black">  78. </font>
<font color="green">  79.     def date_interval_sql(self, timedelta):</font>
<font color="black">  80.         &quot;&quot;&quot;</font>
<font color="black">  81.         Implements the date interval functionality for expressions</font>
<font color="black">  82.         &quot;&quot;&quot;</font>
<font color="red">  83.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a date_interval_sql() method')</font>
<font color="black">  84. </font>
<font color="green">  85.     def date_trunc_sql(self, lookup_type, field_name):</font>
<font color="black">  86.         &quot;&quot;&quot;</font>
<font color="black">  87.         Given a lookup_type of 'year', 'month' or 'day', returns the SQL that</font>
<font color="black">  88.         truncates the given date field field_name to a date object with only</font>
<font color="black">  89.         the given specificity.</font>
<font color="black">  90.         &quot;&quot;&quot;</font>
<font color="red">  91.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a datetrunc_sql() method')</font>
<font color="black">  92. </font>
<font color="green">  93.     def datetime_cast_date_sql(self, field_name, tzname):</font>
<font color="black">  94.         &quot;&quot;&quot;</font>
<font color="black">  95.         Returns the SQL necessary to cast a datetime value to date value.</font>
<font color="black">  96.         &quot;&quot;&quot;</font>
<font color="red">  97.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a datetime_cast_date() method')</font>
<font color="black">  98. </font>
<font color="green">  99.     def datetime_extract_sql(self, lookup_type, field_name, tzname):</font>
<font color="black"> 100.         &quot;&quot;&quot;</font>
<font color="black"> 101.         Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute' or</font>
<font color="black"> 102.         'second', returns the SQL that extracts a value from the given</font>
<font color="black"> 103.         datetime field field_name, and a tuple of parameters.</font>
<font color="black"> 104.         &quot;&quot;&quot;</font>
<font color="red"> 105.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a datetime_extract_sql() method')</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def datetime_trunc_sql(self, lookup_type, field_name, tzname):</font>
<font color="black"> 108.         &quot;&quot;&quot;</font>
<font color="black"> 109.         Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute' or</font>
<font color="black"> 110.         'second', returns the SQL that truncates the given datetime field</font>
<font color="black"> 111.         field_name to a datetime object with only the given specificity, and</font>
<font color="black"> 112.         a tuple of parameters.</font>
<font color="black"> 113.         &quot;&quot;&quot;</font>
<font color="red"> 114.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a datetime_trunk_sql() method')</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def time_extract_sql(self, lookup_type, field_name):</font>
<font color="black"> 117.         &quot;&quot;&quot;</font>
<font color="black"> 118.         Given a lookup_type of 'hour', 'minute' or 'second', returns the SQL</font>
<font color="black"> 119.         that extracts a value from the given time field field_name.</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="red"> 121.         return self.date_extract_sql(lookup_type, field_name)</font>
<font color="black"> 122. </font>
<font color="green"> 123.     def deferrable_sql(self):</font>
<font color="black"> 124.         &quot;&quot;&quot;</font>
<font color="black"> 125.         Returns the SQL necessary to make a constraint &quot;initially deferred&quot;</font>
<font color="black"> 126.         during a CREATE TABLE statement.</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="red"> 128.         return ''</font>
<font color="black"> 129. </font>
<font color="green"> 130.     def distinct_sql(self, fields):</font>
<font color="black"> 131.         &quot;&quot;&quot;</font>
<font color="black"> 132.         Returns an SQL DISTINCT clause which removes duplicate rows from the</font>
<font color="black"> 133.         result set. If any fields are given, only the given fields are being</font>
<font color="black"> 134.         checked for duplicates.</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="red"> 136.         if fields:</font>
<font color="red"> 137.             raise NotImplementedError('DISTINCT ON fields is not supported by this database backend')</font>
<font color="black"> 138.         else:</font>
<font color="red"> 139.             return 'DISTINCT'</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def drop_foreignkey_sql(self):</font>
<font color="black"> 142.         &quot;&quot;&quot;</font>
<font color="black"> 143.         Returns the SQL command that drops a foreign key.</font>
<font color="black"> 144.         &quot;&quot;&quot;</font>
<font color="red"> 145.         return &quot;DROP CONSTRAINT&quot;</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def drop_sequence_sql(self, table):</font>
<font color="black"> 148.         &quot;&quot;&quot;</font>
<font color="black"> 149.         Returns any SQL necessary to drop the sequence for the given table.</font>
<font color="black"> 150.         Returns None if no SQL is necessary.</font>
<font color="black"> 151.         &quot;&quot;&quot;</font>
<font color="red"> 152.         return None</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def fetch_returned_insert_id(self, cursor):</font>
<font color="black"> 155.         &quot;&quot;&quot;</font>
<font color="black"> 156.         Given a cursor object that has just performed an INSERT...RETURNING</font>
<font color="black"> 157.         statement into a table that has an auto-incrementing ID, returns the</font>
<font color="black"> 158.         newly created ID.</font>
<font color="black"> 159.         &quot;&quot;&quot;</font>
<font color="red"> 160.         return cursor.fetchone()[0]</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def field_cast_sql(self, db_type, internal_type):</font>
<font color="black"> 163.         &quot;&quot;&quot;</font>
<font color="black"> 164.         Given a column type (e.g. 'BLOB', 'VARCHAR'), and an internal type</font>
<font color="black"> 165.         (e.g. 'GenericIPAddressField'), returns the SQL necessary to cast it</font>
<font color="black"> 166.         before using it in a WHERE statement. Note that the resulting string</font>
<font color="black"> 167.         should contain a '%s' placeholder for the column being searched against.</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="green"> 169.         return '%s'</font>
<font color="black"> 170. </font>
<font color="green"> 171.     def force_no_ordering(self):</font>
<font color="black"> 172.         &quot;&quot;&quot;</font>
<font color="black"> 173.         Returns a list used in the &quot;ORDER BY&quot; clause to force no ordering at</font>
<font color="black"> 174.         all. Returning an empty list means that nothing will be included in the</font>
<font color="black"> 175.         ordering.</font>
<font color="black"> 176.         &quot;&quot;&quot;</font>
<font color="red"> 177.         return []</font>
<font color="black"> 178. </font>
<font color="green"> 179.     def for_update_sql(self, nowait=False):</font>
<font color="black"> 180.         &quot;&quot;&quot;</font>
<font color="black"> 181.         Returns the FOR UPDATE SQL clause to lock rows for an update operation.</font>
<font color="black"> 182.         &quot;&quot;&quot;</font>
<font color="red"> 183.         if nowait:</font>
<font color="red"> 184.             return 'FOR UPDATE NOWAIT'</font>
<font color="black"> 185.         else:</font>
<font color="red"> 186.             return 'FOR UPDATE'</font>
<font color="black"> 187. </font>
<font color="green"> 188.     def fulltext_search_sql(self, field_name):</font>
<font color="black"> 189.         &quot;&quot;&quot;</font>
<font color="black"> 190.         Returns the SQL WHERE clause to use in order to perform a full-text</font>
<font color="black"> 191.         search of the given field_name. Note that the resulting string should</font>
<font color="black"> 192.         contain a '%s' placeholder for the value being searched against.</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="red"> 194.         raise NotImplementedError('Full-text search is not implemented for this database backend')</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def last_executed_query(self, cursor, sql, params):</font>
<font color="black"> 197.         &quot;&quot;&quot;</font>
<font color="black"> 198.         Returns a string of the query last executed by the given cursor, with</font>
<font color="black"> 199.         placeholders replaced with actual values.</font>
<font color="black"> 200. </font>
<font color="black"> 201.         `sql` is the raw query containing placeholders, and `params` is the</font>
<font color="black"> 202.         sequence of parameters. These are used by default, but this method</font>
<font color="black"> 203.         exists for database backends to provide a better implementation</font>
<font color="black"> 204.         according to their own quoting schemes.</font>
<font color="black"> 205.         &quot;&quot;&quot;</font>
<font color="black"> 206.         # Convert params to contain Unicode values.</font>
<font color="red"> 207.         to_unicode = lambda s: force_text(s, strings_only=True, errors='replace')</font>
<font color="red"> 208.         if isinstance(params, (list, tuple)):</font>
<font color="red"> 209.             u_params = tuple(to_unicode(val) for val in params)</font>
<font color="red"> 210.         elif params is None:</font>
<font color="red"> 211.             u_params = ()</font>
<font color="black"> 212.         else:</font>
<font color="red"> 213.             u_params = {to_unicode(k): to_unicode(v) for k, v in params.items()}</font>
<font color="black"> 214. </font>
<font color="red"> 215.         return six.text_type(&quot;QUERY = %r - PARAMS = %r&quot;) % (sql, u_params)</font>
<font color="black"> 216. </font>
<font color="green"> 217.     def last_insert_id(self, cursor, table_name, pk_name):</font>
<font color="black"> 218.         &quot;&quot;&quot;</font>
<font color="black"> 219.         Given a cursor object that has just performed an INSERT statement into</font>
<font color="black"> 220.         a table that has an auto-incrementing ID, returns the newly created ID.</font>
<font color="black"> 221. </font>
<font color="black"> 222.         This method also receives the table name and the name of the primary-key</font>
<font color="black"> 223.         column.</font>
<font color="black"> 224.         &quot;&quot;&quot;</font>
<font color="green"> 225.         return cursor.lastrowid</font>
<font color="black"> 226. </font>
<font color="green"> 227.     def lookup_cast(self, lookup_type, internal_type=None):</font>
<font color="black"> 228.         &quot;&quot;&quot;</font>
<font color="black"> 229.         Returns the string to use in a query when performing lookups</font>
<font color="black"> 230.         (&quot;contains&quot;, &quot;like&quot;, etc). The resulting string should contain a '%s'</font>
<font color="black"> 231.         placeholder for the column being searched against.</font>
<font color="black"> 232.         &quot;&quot;&quot;</font>
<font color="green"> 233.         return &quot;%s&quot;</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def max_in_list_size(self):</font>
<font color="black"> 236.         &quot;&quot;&quot;</font>
<font color="black"> 237.         Returns the maximum number of items that can be passed in a single 'IN'</font>
<font color="black"> 238.         list condition, or None if the backend does not impose a limit.</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="green"> 240.         return None</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def max_name_length(self):</font>
<font color="black"> 243.         &quot;&quot;&quot;</font>
<font color="black"> 244.         Returns the maximum length of table and column names, or None if there</font>
<font color="black"> 245.         is no limit.</font>
<font color="black"> 246.         &quot;&quot;&quot;</font>
<font color="green"> 247.         return None</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def no_limit_value(self):</font>
<font color="black"> 250.         &quot;&quot;&quot;</font>
<font color="black"> 251.         Returns the value to use for the LIMIT when we are wanting &quot;LIMIT</font>
<font color="black"> 252.         infinity&quot;. Returns None if the limit clause can be omitted in this case.</font>
<font color="black"> 253.         &quot;&quot;&quot;</font>
<font color="red"> 254.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a no_limit_value() method')</font>
<font color="black"> 255. </font>
<font color="green"> 256.     def pk_default_value(self):</font>
<font color="black"> 257.         &quot;&quot;&quot;</font>
<font color="black"> 258.         Returns the value to use during an INSERT statement to specify that</font>
<font color="black"> 259.         the field should use its default value.</font>
<font color="black"> 260.         &quot;&quot;&quot;</font>
<font color="red"> 261.         return 'DEFAULT'</font>
<font color="black"> 262. </font>
<font color="green"> 263.     def prepare_sql_script(self, sql):</font>
<font color="black"> 264.         &quot;&quot;&quot;</font>
<font color="black"> 265.         Takes a SQL script that may contain multiple lines and returns a list</font>
<font color="black"> 266.         of statements to feed to successive cursor.execute() calls.</font>
<font color="black"> 267. </font>
<font color="black"> 268.         Since few databases are able to process raw SQL scripts in a single</font>
<font color="black"> 269.         cursor.execute() call and PEP 249 doesn't talk about this use case,</font>
<font color="black"> 270.         the default implementation is conservative.</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="red"> 272.         try:</font>
<font color="red"> 273.             import sqlparse</font>
<font color="red"> 274.         except ImportError:</font>
<font color="red"> 275.             raise ImproperlyConfigured(</font>
<font color="red"> 276.                 &quot;sqlparse is required if you don't split your SQL &quot;</font>
<font color="black"> 277.                 &quot;statements manually.&quot;</font>
<font color="black"> 278.             )</font>
<font color="black"> 279.         else:</font>
<font color="red"> 280.             return [sqlparse.format(statement, strip_comments=True)</font>
<font color="red"> 281.                     for statement in sqlparse.split(sql) if statement]</font>
<font color="black"> 282. </font>
<font color="green"> 283.     def process_clob(self, value):</font>
<font color="black"> 284.         &quot;&quot;&quot;</font>
<font color="black"> 285.         Returns the value of a CLOB column, for backends that return a locator</font>
<font color="black"> 286.         object that requires additional processing.</font>
<font color="black"> 287.         &quot;&quot;&quot;</font>
<font color="red"> 288.         return value</font>
<font color="black"> 289. </font>
<font color="green"> 290.     def return_insert_id(self):</font>
<font color="black"> 291.         &quot;&quot;&quot;</font>
<font color="black"> 292.         For backends that support returning the last insert ID as part</font>
<font color="black"> 293.         of an insert query, this method returns the SQL and params to</font>
<font color="black"> 294.         append to the INSERT query. The returned fragment should</font>
<font color="black"> 295.         contain a format string to hold the appropriate column.</font>
<font color="black"> 296.         &quot;&quot;&quot;</font>
<font color="red"> 297.         pass</font>
<font color="black"> 298. </font>
<font color="green"> 299.     def compiler(self, compiler_name):</font>
<font color="black"> 300.         &quot;&quot;&quot;</font>
<font color="black"> 301.         Returns the SQLCompiler class corresponding to the given name,</font>
<font color="black"> 302.         in the namespace corresponding to the `compiler_module` attribute</font>
<font color="black"> 303.         on this backend.</font>
<font color="black"> 304.         &quot;&quot;&quot;</font>
<font color="green"> 305.         if self._cache is None:</font>
<font color="green"> 306.             self._cache = import_module(self.compiler_module)</font>
<font color="green"> 307.         return getattr(self._cache, compiler_name)</font>
<font color="black"> 308. </font>
<font color="green"> 309.     def quote_name(self, name):</font>
<font color="black"> 310.         &quot;&quot;&quot;</font>
<font color="black"> 311.         Returns a quoted version of the given table, index or column name. Does</font>
<font color="black"> 312.         not quote the given name if it's already been quoted.</font>
<font color="black"> 313.         &quot;&quot;&quot;</font>
<font color="red"> 314.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a quote_name() method')</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def random_function_sql(self):</font>
<font color="black"> 317.         &quot;&quot;&quot;</font>
<font color="black"> 318.         Returns an SQL expression that returns a random value.</font>
<font color="black"> 319.         &quot;&quot;&quot;</font>
<font color="red"> 320.         return 'RANDOM()'</font>
<font color="black"> 321. </font>
<font color="green"> 322.     def regex_lookup(self, lookup_type):</font>
<font color="black"> 323.         &quot;&quot;&quot;</font>
<font color="black"> 324.         Returns the string to use in a query when performing regular expression</font>
<font color="black"> 325.         lookups (using &quot;regex&quot; or &quot;iregex&quot;). The resulting string should</font>
<font color="black"> 326.         contain a '%s' placeholder for the column being searched against.</font>
<font color="black"> 327. </font>
<font color="black"> 328.         If the feature is not supported (or part of it is not supported), a</font>
<font color="black"> 329.         NotImplementedError exception can be raised.</font>
<font color="black"> 330.         &quot;&quot;&quot;</font>
<font color="red"> 331.         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a regex_lookup() method')</font>
<font color="black"> 332. </font>
<font color="green"> 333.     def savepoint_create_sql(self, sid):</font>
<font color="black"> 334.         &quot;&quot;&quot;</font>
<font color="black"> 335.         Returns the SQL for starting a new savepoint. Only required if the</font>
<font color="black"> 336.         &quot;uses_savepoints&quot; feature is True. The &quot;sid&quot; parameter is a string</font>
<font color="black"> 337.         for the savepoint id.</font>
<font color="black"> 338.         &quot;&quot;&quot;</font>
<font color="green"> 339.         return &quot;SAVEPOINT %s&quot; % self.quote_name(sid)</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def savepoint_commit_sql(self, sid):</font>
<font color="black"> 342.         &quot;&quot;&quot;</font>
<font color="black"> 343.         Returns the SQL for committing the given savepoint.</font>
<font color="black"> 344.         &quot;&quot;&quot;</font>
<font color="green"> 345.         return &quot;RELEASE SAVEPOINT %s&quot; % self.quote_name(sid)</font>
<font color="black"> 346. </font>
<font color="green"> 347.     def savepoint_rollback_sql(self, sid):</font>
<font color="black"> 348.         &quot;&quot;&quot;</font>
<font color="black"> 349.         Returns the SQL for rolling back the given savepoint.</font>
<font color="black"> 350.         &quot;&quot;&quot;</font>
<font color="green"> 351.         return &quot;ROLLBACK TO SAVEPOINT %s&quot; % self.quote_name(sid)</font>
<font color="black"> 352. </font>
<font color="green"> 353.     def set_time_zone_sql(self):</font>
<font color="black"> 354.         &quot;&quot;&quot;</font>
<font color="black"> 355.         Returns the SQL that will set the connection's time zone.</font>
<font color="black"> 356. </font>
<font color="black"> 357.         Returns '' if the backend doesn't support time zones.</font>
<font color="black"> 358.         &quot;&quot;&quot;</font>
<font color="red"> 359.         return ''</font>
<font color="black"> 360. </font>
<font color="green"> 361.     def sql_flush(self, style, tables, sequences, allow_cascade=False):</font>
<font color="black"> 362.         &quot;&quot;&quot;</font>
<font color="black"> 363.         Returns a list of SQL statements required to remove all data from</font>
<font color="black"> 364.         the given database tables (without actually removing the tables</font>
<font color="black"> 365.         themselves).</font>
<font color="black"> 366. </font>
<font color="black"> 367.         The returned value also includes SQL statements required to reset DB</font>
<font color="black"> 368.         sequences passed in :param sequences:.</font>
<font color="black"> 369. </font>
<font color="black"> 370.         The `style` argument is a Style object as returned by either</font>
<font color="black"> 371.         color_style() or no_style() in django.core.management.color.</font>
<font color="black"> 372. </font>
<font color="black"> 373.         The `allow_cascade` argument determines whether truncation may cascade</font>
<font color="black"> 374.         to tables with foreign keys pointing the tables being truncated.</font>
<font color="black"> 375.         PostgreSQL requires a cascade even if these tables are empty.</font>
<font color="black"> 376.         &quot;&quot;&quot;</font>
<font color="red"> 377.         raise NotImplementedError('subclasses of BaseDatabaseOperations must provide a sql_flush() method')</font>
<font color="black"> 378. </font>
<font color="green"> 379.     def sequence_reset_by_name_sql(self, style, sequences):</font>
<font color="black"> 380.         &quot;&quot;&quot;</font>
<font color="black"> 381.         Returns a list of the SQL statements required to reset sequences</font>
<font color="black"> 382.         passed in :param sequences:.</font>
<font color="black"> 383. </font>
<font color="black"> 384.         The `style` argument is a Style object as returned by either</font>
<font color="black"> 385.         color_style() or no_style() in django.core.management.color.</font>
<font color="black"> 386.         &quot;&quot;&quot;</font>
<font color="red"> 387.         return []</font>
<font color="black"> 388. </font>
<font color="green"> 389.     def sequence_reset_sql(self, style, model_list):</font>
<font color="black"> 390.         &quot;&quot;&quot;</font>
<font color="black"> 391.         Returns a list of the SQL statements required to reset sequences for</font>
<font color="black"> 392.         the given models.</font>
<font color="black"> 393. </font>
<font color="black"> 394.         The `style` argument is a Style object as returned by either</font>
<font color="black"> 395.         color_style() or no_style() in django.core.management.color.</font>
<font color="black"> 396.         &quot;&quot;&quot;</font>
<font color="red"> 397.         return []  # No sequence reset required by default.</font>
<font color="black"> 398. </font>
<font color="green"> 399.     def start_transaction_sql(self):</font>
<font color="black"> 400.         &quot;&quot;&quot;</font>
<font color="black"> 401.         Returns the SQL statement required to start a transaction.</font>
<font color="black"> 402.         &quot;&quot;&quot;</font>
<font color="red"> 403.         return &quot;BEGIN;&quot;</font>
<font color="black"> 404. </font>
<font color="green"> 405.     def end_transaction_sql(self, success=True):</font>
<font color="black"> 406.         &quot;&quot;&quot;</font>
<font color="black"> 407.         Returns the SQL statement required to end a transaction.</font>
<font color="black"> 408.         &quot;&quot;&quot;</font>
<font color="red"> 409.         if not success:</font>
<font color="red"> 410.             return &quot;ROLLBACK;&quot;</font>
<font color="red"> 411.         return &quot;COMMIT;&quot;</font>
<font color="black"> 412. </font>
<font color="green"> 413.     def tablespace_sql(self, tablespace, inline=False):</font>
<font color="black"> 414.         &quot;&quot;&quot;</font>
<font color="black"> 415.         Returns the SQL that will be used in a query to define the tablespace.</font>
<font color="black"> 416. </font>
<font color="black"> 417.         Returns '' if the backend doesn't support tablespaces.</font>
<font color="black"> 418. </font>
<font color="black"> 419.         If inline is True, the SQL is appended to a row; otherwise it's appended</font>
<font color="black"> 420.         to the entire CREATE TABLE or CREATE INDEX statement.</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="red"> 422.         return ''</font>
<font color="black"> 423. </font>
<font color="green"> 424.     def prep_for_like_query(self, x):</font>
<font color="black"> 425.         &quot;&quot;&quot;Prepares a value for use in a LIKE query.&quot;&quot;&quot;</font>
<font color="red"> 426.         return force_text(x).replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;%&quot;, &quot;\%&quot;).replace(&quot;_&quot;, &quot;\_&quot;)</font>
<font color="black"> 427. </font>
<font color="black"> 428.     # Same as prep_for_like_query(), but called for &quot;iexact&quot; matches, which</font>
<font color="black"> 429.     # need not necessarily be implemented using &quot;LIKE&quot; in the backend.</font>
<font color="green"> 430.     prep_for_iexact_query = prep_for_like_query</font>
<font color="black"> 431. </font>
<font color="green"> 432.     def validate_autopk_value(self, value):</font>
<font color="black"> 433.         &quot;&quot;&quot;</font>
<font color="black"> 434.         Certain backends do not accept some values for &quot;serial&quot; fields</font>
<font color="black"> 435.         (for example zero in MySQL). This method will raise a ValueError</font>
<font color="black"> 436.         if the value is invalid, otherwise returns validated value.</font>
<font color="black"> 437.         &quot;&quot;&quot;</font>
<font color="green"> 438.         return value</font>
<font color="black"> 439. </font>
<font color="green"> 440.     def adapt_unknown_value(self, value):</font>
<font color="black"> 441.         &quot;&quot;&quot;</font>
<font color="black"> 442.         Transforms a value to something compatible with the backend driver.</font>
<font color="black"> 443. </font>
<font color="black"> 444.         This method only depends on the type of the value. It's designed for</font>
<font color="black"> 445.         cases where the target type isn't known, such as .raw() SQL queries.</font>
<font color="black"> 446.         As a consequence it may not work perfectly in all circumstances.</font>
<font color="black"> 447.         &quot;&quot;&quot;</font>
<font color="red"> 448.         if isinstance(value, datetime.datetime):   # must be before date</font>
<font color="red"> 449.             return self.adapt_datetimefield_value(value)</font>
<font color="red"> 450.         elif isinstance(value, datetime.date):</font>
<font color="red"> 451.             return self.adapt_datefield_value(value)</font>
<font color="red"> 452.         elif isinstance(value, datetime.time):</font>
<font color="red"> 453.             return self.adapt_timefield_value(value)</font>
<font color="red"> 454.         elif isinstance(value, decimal.Decimal):</font>
<font color="red"> 455.             return self.adapt_decimalfield_value(value)</font>
<font color="black"> 456.         else:</font>
<font color="red"> 457.             return value</font>
<font color="black"> 458. </font>
<font color="green"> 459.     def adapt_datefield_value(self, value):</font>
<font color="black"> 460.         &quot;&quot;&quot;</font>
<font color="black"> 461.         Transforms a date value to an object compatible with what is expected</font>
<font color="black"> 462.         by the backend driver for date columns.</font>
<font color="black"> 463.         &quot;&quot;&quot;</font>
<font color="red"> 464.         if value is None:</font>
<font color="red"> 465.             return None</font>
<font color="red"> 466.         return six.text_type(value)</font>
<font color="black"> 467. </font>
<font color="green"> 468.     def adapt_datetimefield_value(self, value):</font>
<font color="black"> 469.         &quot;&quot;&quot;</font>
<font color="black"> 470.         Transforms a datetime value to an object compatible with what is expected</font>
<font color="black"> 471.         by the backend driver for datetime columns.</font>
<font color="black"> 472.         &quot;&quot;&quot;</font>
<font color="red"> 473.         if value is None:</font>
<font color="red"> 474.             return None</font>
<font color="red"> 475.         return six.text_type(value)</font>
<font color="black"> 476. </font>
<font color="green"> 477.     def adapt_timefield_value(self, value):</font>
<font color="black"> 478.         &quot;&quot;&quot;</font>
<font color="black"> 479.         Transforms a time value to an object compatible with what is expected</font>
<font color="black"> 480.         by the backend driver for time columns.</font>
<font color="black"> 481.         &quot;&quot;&quot;</font>
<font color="red"> 482.         if value is None:</font>
<font color="red"> 483.             return None</font>
<font color="red"> 484.         if timezone.is_aware(value):</font>
<font color="red"> 485.             raise ValueError(&quot;Django does not support timezone-aware times.&quot;)</font>
<font color="red"> 486.         return six.text_type(value)</font>
<font color="black"> 487. </font>
<font color="green"> 488.     def adapt_decimalfield_value(self, value, max_digits, decimal_places):</font>
<font color="black"> 489.         &quot;&quot;&quot;</font>
<font color="black"> 490.         Transforms a decimal.Decimal value to an object compatible with what is</font>
<font color="black"> 491.         expected by the backend driver for decimal (numeric) columns.</font>
<font color="black"> 492.         &quot;&quot;&quot;</font>
<font color="red"> 493.         return utils.format_number(value, max_digits, decimal_places)</font>
<font color="black"> 494. </font>
<font color="green"> 495.     def adapt_ipaddressfield_value(self, value):</font>
<font color="black"> 496.         &quot;&quot;&quot;</font>
<font color="black"> 497.         Transforms a string representation of an IP address into the expected</font>
<font color="black"> 498.         type for the backend driver.</font>
<font color="black"> 499.         &quot;&quot;&quot;</font>
<font color="red"> 500.         return value</font>
<font color="black"> 501. </font>
<font color="green"> 502.     def year_lookup_bounds_for_date_field(self, value):</font>
<font color="black"> 503.         &quot;&quot;&quot;</font>
<font color="black"> 504.         Returns a two-elements list with the lower and upper bound to be used</font>
<font color="black"> 505.         with a BETWEEN operator to query a DateField value using a year</font>
<font color="black"> 506.         lookup.</font>
<font color="black"> 507. </font>
<font color="black"> 508.         `value` is an int, containing the looked-up year.</font>
<font color="black"> 509.         &quot;&quot;&quot;</font>
<font color="red"> 510.         first = datetime.date(value, 1, 1)</font>
<font color="red"> 511.         second = datetime.date(value, 12, 31)</font>
<font color="red"> 512.         first = self.adapt_datefield_value(first)</font>
<font color="red"> 513.         second = self.adapt_datefield_value(second)</font>
<font color="red"> 514.         return [first, second]</font>
<font color="black"> 515. </font>
<font color="green"> 516.     def year_lookup_bounds_for_datetime_field(self, value):</font>
<font color="black"> 517.         &quot;&quot;&quot;</font>
<font color="black"> 518.         Returns a two-elements list with the lower and upper bound to be used</font>
<font color="black"> 519.         with a BETWEEN operator to query a DateTimeField value using a year</font>
<font color="black"> 520.         lookup.</font>
<font color="black"> 521. </font>
<font color="black"> 522.         `value` is an int, containing the looked-up year.</font>
<font color="black"> 523.         &quot;&quot;&quot;</font>
<font color="red"> 524.         first = datetime.datetime(value, 1, 1)</font>
<font color="red"> 525.         second = datetime.datetime(value, 12, 31, 23, 59, 59, 999999)</font>
<font color="red"> 526.         if settings.USE_TZ:</font>
<font color="red"> 527.             tz = timezone.get_current_timezone()</font>
<font color="red"> 528.             first = timezone.make_aware(first, tz)</font>
<font color="red"> 529.             second = timezone.make_aware(second, tz)</font>
<font color="red"> 530.         first = self.adapt_datetimefield_value(first)</font>
<font color="red"> 531.         second = self.adapt_datetimefield_value(second)</font>
<font color="red"> 532.         return [first, second]</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def get_db_converters(self, expression):</font>
<font color="black"> 535.         &quot;&quot;&quot;</font>
<font color="black"> 536.         Get a list of functions needed to convert field data.</font>
<font color="black"> 537. </font>
<font color="black"> 538.         Some field types on some backends do not provide data in the correct</font>
<font color="black"> 539.         format, this is the hook for converter functions.</font>
<font color="black"> 540.         &quot;&quot;&quot;</font>
<font color="green"> 541.         return []</font>
<font color="black"> 542. </font>
<font color="green"> 543.     def convert_durationfield_value(self, value, expression, connection, context):</font>
<font color="red"> 544.         if value is not None:</font>
<font color="red"> 545.             value = str(decimal.Decimal(value) / decimal.Decimal(1000000))</font>
<font color="red"> 546.             value = parse_duration(value)</font>
<font color="red"> 547.         return value</font>
<font color="black"> 548. </font>
<font color="green"> 549.     def check_aggregate_support(self, aggregate_func):</font>
<font color="red"> 550.         warnings.warn(</font>
<font color="red"> 551.             &quot;check_aggregate_support has been deprecated. Use &quot;</font>
<font color="black"> 552.             &quot;check_expression_support instead.&quot;,</font>
<font color="red"> 553.             RemovedInDjango20Warning, stacklevel=2)</font>
<font color="red"> 554.         return self.check_expression_support(aggregate_func)</font>
<font color="black"> 555. </font>
<font color="green"> 556.     def check_expression_support(self, expression):</font>
<font color="black"> 557.         &quot;&quot;&quot;</font>
<font color="black"> 558.         Check that the backend supports the provided expression.</font>
<font color="black"> 559. </font>
<font color="black"> 560.         This is used on specific backends to rule out known expressions</font>
<font color="black"> 561.         that have problematic or nonexistent implementations. If the</font>
<font color="black"> 562.         expression has a known problem, the backend should raise</font>
<font color="black"> 563.         NotImplementedError.</font>
<font color="black"> 564.         &quot;&quot;&quot;</font>
<font color="red"> 565.         pass</font>
<font color="black"> 566. </font>
<font color="green"> 567.     def combine_expression(self, connector, sub_expressions):</font>
<font color="black"> 568.         &quot;&quot;&quot;Combine a list of subexpressions into a single expression, using</font>
<font color="black"> 569.         the provided connecting operator. This is required because operators</font>
<font color="black"> 570.         can vary between backends (e.g., Oracle with %% and &amp;) and between</font>
<font color="black"> 571.         subexpression types (e.g., date expressions)</font>
<font color="black"> 572.         &quot;&quot;&quot;</font>
<font color="red"> 573.         conn = ' %s ' % connector</font>
<font color="red"> 574.         return conn.join(sub_expressions)</font>
<font color="black"> 575. </font>
<font color="green"> 576.     def combine_duration_expression(self, connector, sub_expressions):</font>
<font color="red"> 577.         return self.combine_expression(connector, sub_expressions)</font>
<font color="black"> 578. </font>
<font color="green"> 579.     def modify_insert_params(self, placeholder, params):</font>
<font color="black"> 580.         &quot;&quot;&quot;Allow modification of insert parameters. Needed for Oracle Spatial</font>
<font color="black"> 581.         backend due to #10888.</font>
<font color="black"> 582.         &quot;&quot;&quot;</font>
<font color="green"> 583.         return params</font>
<font color="black"> 584. </font>
<font color="green"> 585.     def integer_field_range(self, internal_type):</font>
<font color="black"> 586.         &quot;&quot;&quot;</font>
<font color="black"> 587.         Given an integer field internal type (e.g. 'PositiveIntegerField'),</font>
<font color="black"> 588.         returns a tuple of the (min_value, max_value) form representing the</font>
<font color="black"> 589.         range of the column type bound to the field.</font>
<font color="black"> 590.         &quot;&quot;&quot;</font>
<font color="red"> 591.         return self.integer_field_ranges[internal_type]</font>
</pre>

