source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/middleware/cache.py</b><br>


file stats: <b>77 lines, 16 executed: 20.8% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Cache middleware. If enabled, each Django-powered page will be cached based on</font>
<font color="black">   3. URL. The canonical way to enable cache middleware is to set</font>
<font color="black">   4. ``UpdateCacheMiddleware`` as your first piece of middleware, and</font>
<font color="black">   5. ``FetchFromCacheMiddleware`` as the last::</font>
<font color="black">   6. </font>
<font color="black">   7.     MIDDLEWARE_CLASSES = [</font>
<font color="black">   8.         'django.middleware.cache.UpdateCacheMiddleware',</font>
<font color="black">   9.         ...</font>
<font color="black">  10.         'django.middleware.cache.FetchFromCacheMiddleware'</font>
<font color="black">  11.     ]</font>
<font color="black">  12. </font>
<font color="black">  13. This is counter-intuitive, but correct: ``UpdateCacheMiddleware`` needs to run</font>
<font color="black">  14. last during the response phase, which processes middleware bottom-up;</font>
<font color="black">  15. ``FetchFromCacheMiddleware`` needs to run last during the request phase, which</font>
<font color="black">  16. processes middleware top-down.</font>
<font color="black">  17. </font>
<font color="black">  18. The single-class ``CacheMiddleware`` can be used for some simple sites.</font>
<font color="black">  19. However, if any other piece of middleware needs to affect the cache key, you'll</font>
<font color="black">  20. need to use the two-part ``UpdateCacheMiddleware`` and</font>
<font color="black">  21. ``FetchFromCacheMiddleware``. This'll most often happen when you're using</font>
<font color="black">  22. Django's ``LocaleMiddleware``.</font>
<font color="black">  23. </font>
<font color="black">  24. More details about how the caching works:</font>
<font color="black">  25. </font>
<font color="black">  26. * Only GET or HEAD-requests with status code 200 are cached.</font>
<font color="black">  27. </font>
<font color="black">  28. * The number of seconds each page is stored for is set by the &quot;max-age&quot; section</font>
<font color="black">  29.   of the response's &quot;Cache-Control&quot; header, falling back to the</font>
<font color="black">  30.   CACHE_MIDDLEWARE_SECONDS setting if the section was not found.</font>
<font color="black">  31. </font>
<font color="black">  32. * This middleware expects that a HEAD request is answered with the same response</font>
<font color="black">  33.   headers exactly like the corresponding GET request.</font>
<font color="black">  34. </font>
<font color="black">  35. * When a hit occurs, a shallow copy of the original response object is returned</font>
<font color="black">  36.   from process_request.</font>
<font color="black">  37. </font>
<font color="black">  38. * Pages will be cached based on the contents of the request headers listed in</font>
<font color="black">  39.   the response's &quot;Vary&quot; header.</font>
<font color="black">  40. </font>
<font color="black">  41. * This middleware also sets ETag, Last-Modified, Expires and Cache-Control</font>
<font color="black">  42.   headers on the response object.</font>
<font color="black">  43. </font>
<font color="green">  44. &quot;&quot;&quot;</font>
<font color="black">  45. </font>
<font color="green">  46. from django.conf import settings</font>
<font color="green">  47. from django.core.cache import DEFAULT_CACHE_ALIAS, caches</font>
<font color="green">  48. from django.utils.cache import (</font>
<font color="black">  49.     get_cache_key, get_max_age, has_vary_header, learn_cache_key,</font>
<font color="black">  50.     patch_response_headers,</font>
<font color="black">  51. )</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. class UpdateCacheMiddleware(object):</font>
<font color="black">  55.     &quot;&quot;&quot;</font>
<font color="black">  56.     Response-phase cache middleware that updates the cache if the response is</font>
<font color="black">  57.     cacheable.</font>
<font color="black">  58. </font>
<font color="black">  59.     Must be used as part of the two-part update/fetch cache middleware.</font>
<font color="black">  60.     UpdateCacheMiddleware must be the first piece of middleware in</font>
<font color="black">  61.     MIDDLEWARE_CLASSES so that it'll get called last during the response phase.</font>
<font color="green">  62.     &quot;&quot;&quot;</font>
<font color="green">  63.     def __init__(self):</font>
<font color="red">  64.         self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS</font>
<font color="red">  65.         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX</font>
<font color="red">  66.         self.cache_alias = settings.CACHE_MIDDLEWARE_ALIAS</font>
<font color="red">  67.         self.cache = caches[self.cache_alias]</font>
<font color="black">  68. </font>
<font color="green">  69.     def _should_update_cache(self, request, response):</font>
<font color="red">  70.         return hasattr(request, '_cache_update_cache') and request._cache_update_cache</font>
<font color="black">  71. </font>
<font color="green">  72.     def process_response(self, request, response):</font>
<font color="black">  73.         &quot;&quot;&quot;Sets the cache, if needed.&quot;&quot;&quot;</font>
<font color="red">  74.         if not self._should_update_cache(request, response):</font>
<font color="black">  75.             # We don't need to update the cache, just return.</font>
<font color="red">  76.             return response</font>
<font color="black">  77. </font>
<font color="red">  78.         if response.streaming or response.status_code != 200:</font>
<font color="red">  79.             return response</font>
<font color="black">  80. </font>
<font color="black">  81.         # Don't cache responses that set a user-specific (and maybe security</font>
<font color="black">  82.         # sensitive) cookie in response to a cookie-less request.</font>
<font color="red">  83.         if not request.COOKIES and response.cookies and has_vary_header(response, 'Cookie'):</font>
<font color="red">  84.             return response</font>
<font color="black">  85. </font>
<font color="black">  86.         # Try to get the timeout from the &quot;max-age&quot; section of the &quot;Cache-</font>
<font color="black">  87.         # Control&quot; header before reverting to using the default cache_timeout</font>
<font color="black">  88.         # length.</font>
<font color="red">  89.         timeout = get_max_age(response)</font>
<font color="red">  90.         if timeout is None:</font>
<font color="red">  91.             timeout = self.cache_timeout</font>
<font color="red">  92.         elif timeout == 0:</font>
<font color="black">  93.             # max-age was set to 0, don't bother caching.</font>
<font color="red">  94.             return response</font>
<font color="red">  95.         patch_response_headers(response, timeout)</font>
<font color="red">  96.         if timeout:</font>
<font color="red">  97.             cache_key = learn_cache_key(request, response, timeout, self.key_prefix, cache=self.cache)</font>
<font color="red">  98.             if hasattr(response, 'render') and callable(response.render):</font>
<font color="red">  99.                 response.add_post_render_callback(</font>
<font color="red"> 100.                     lambda r: self.cache.set(cache_key, r, timeout)</font>
<font color="black"> 101.                 )</font>
<font color="black"> 102.             else:</font>
<font color="red"> 103.                 self.cache.set(cache_key, response, timeout)</font>
<font color="red"> 104.         return response</font>
<font color="black"> 105. </font>
<font color="black"> 106. </font>
<font color="green"> 107. class FetchFromCacheMiddleware(object):</font>
<font color="black"> 108.     &quot;&quot;&quot;</font>
<font color="black"> 109.     Request-phase cache middleware that fetches a page from the cache.</font>
<font color="black"> 110. </font>
<font color="black"> 111.     Must be used as part of the two-part update/fetch cache middleware.</font>
<font color="black"> 112.     FetchFromCacheMiddleware must be the last piece of middleware in</font>
<font color="black"> 113.     MIDDLEWARE_CLASSES so that it'll get called last during the request phase.</font>
<font color="green"> 114.     &quot;&quot;&quot;</font>
<font color="green"> 115.     def __init__(self):</font>
<font color="red"> 116.         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX</font>
<font color="red"> 117.         self.cache_alias = settings.CACHE_MIDDLEWARE_ALIAS</font>
<font color="red"> 118.         self.cache = caches[self.cache_alias]</font>
<font color="black"> 119. </font>
<font color="green"> 120.     def process_request(self, request):</font>
<font color="black"> 121.         &quot;&quot;&quot;</font>
<font color="black"> 122.         Checks whether the page is already cached and returns the cached</font>
<font color="black"> 123.         version if available.</font>
<font color="black"> 124.         &quot;&quot;&quot;</font>
<font color="red"> 125.         if request.method not in ('GET', 'HEAD'):</font>
<font color="red"> 126.             request._cache_update_cache = False</font>
<font color="red"> 127.             return None  # Don't bother checking the cache.</font>
<font color="black"> 128. </font>
<font color="black"> 129.         # try and get the cached GET response</font>
<font color="red"> 130.         cache_key = get_cache_key(request, self.key_prefix, 'GET', cache=self.cache)</font>
<font color="red"> 131.         if cache_key is None:</font>
<font color="red"> 132.             request._cache_update_cache = True</font>
<font color="red"> 133.             return None  # No cache information available, need to rebuild.</font>
<font color="red"> 134.         response = self.cache.get(cache_key)</font>
<font color="black"> 135.         # if it wasn't found and we are looking for a HEAD, try looking just for that</font>
<font color="red"> 136.         if response is None and request.method == 'HEAD':</font>
<font color="red"> 137.             cache_key = get_cache_key(request, self.key_prefix, 'HEAD', cache=self.cache)</font>
<font color="red"> 138.             response = self.cache.get(cache_key)</font>
<font color="black"> 139. </font>
<font color="red"> 140.         if response is None:</font>
<font color="red"> 141.             request._cache_update_cache = True</font>
<font color="red"> 142.             return None  # No cache information available, need to rebuild.</font>
<font color="black"> 143. </font>
<font color="black"> 144.         # hit, return cached response</font>
<font color="red"> 145.         request._cache_update_cache = False</font>
<font color="red"> 146.         return response</font>
<font color="black"> 147. </font>
<font color="black"> 148. </font>
<font color="green"> 149. class CacheMiddleware(UpdateCacheMiddleware, FetchFromCacheMiddleware):</font>
<font color="black"> 150.     &quot;&quot;&quot;</font>
<font color="black"> 151.     Cache middleware that provides basic behavior for many simple sites.</font>
<font color="black"> 152. </font>
<font color="black"> 153.     Also used as the hook point for the cache decorator, which is generated</font>
<font color="black"> 154.     using the decorator-from-middleware utility.</font>
<font color="green"> 155.     &quot;&quot;&quot;</font>
<font color="green"> 156.     def __init__(self, cache_timeout=None, **kwargs):</font>
<font color="black"> 157.         # We need to differentiate between &quot;provided, but using default value&quot;,</font>
<font color="black"> 158.         # and &quot;not provided&quot;. If the value is provided using a default, then</font>
<font color="black"> 159.         # we fall back to system defaults. If it is not provided at all,</font>
<font color="black"> 160.         # we need to use middleware defaults.</font>
<font color="black"> 161. </font>
<font color="red"> 162.         try:</font>
<font color="red"> 163.             key_prefix = kwargs['key_prefix']</font>
<font color="red"> 164.             if key_prefix is None:</font>
<font color="red"> 165.                 key_prefix = ''</font>
<font color="red"> 166.         except KeyError:</font>
<font color="red"> 167.             key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX</font>
<font color="red"> 168.         self.key_prefix = key_prefix</font>
<font color="black"> 169. </font>
<font color="red"> 170.         try:</font>
<font color="red"> 171.             cache_alias = kwargs['cache_alias']</font>
<font color="red"> 172.             if cache_alias is None:</font>
<font color="red"> 173.                 cache_alias = DEFAULT_CACHE_ALIAS</font>
<font color="red"> 174.         except KeyError:</font>
<font color="red"> 175.             cache_alias = settings.CACHE_MIDDLEWARE_ALIAS</font>
<font color="red"> 176.         self.cache_alias = cache_alias</font>
<font color="black"> 177. </font>
<font color="red"> 178.         if cache_timeout is None:</font>
<font color="red"> 179.             cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS</font>
<font color="red"> 180.         self.cache_timeout = cache_timeout</font>
<font color="red"> 181.         self.cache = caches[self.cache_alias]</font>
</pre>

