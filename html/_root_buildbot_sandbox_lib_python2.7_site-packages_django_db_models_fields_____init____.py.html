source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/fields/__init__.py</b><br>


file stats: <b>1606 lines, 682 executed: 42.5% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="green">   2. from __future__ import unicode_literals</font>
<font color="black">   3. </font>
<font color="green">   4. import collections</font>
<font color="green">   5. import copy</font>
<font color="green">   6. import datetime</font>
<font color="green">   7. import decimal</font>
<font color="green">   8. import math</font>
<font color="green">   9. import uuid</font>
<font color="green">  10. import warnings</font>
<font color="green">  11. from base64 import b64decode, b64encode</font>
<font color="green">  12. from functools import total_ordering</font>
<font color="black">  13. </font>
<font color="green">  14. from django import forms</font>
<font color="green">  15. from django.apps import apps</font>
<font color="green">  16. from django.conf import settings</font>
<font color="green">  17. from django.core import checks, exceptions, validators</font>
<font color="black">  18. # When the _meta object was formalized, this exception was moved to</font>
<font color="black">  19. # django.core.exceptions. It is retained here for backwards compatibility</font>
<font color="black">  20. # purposes.</font>
<font color="green">  21. from django.core.exceptions import FieldDoesNotExist  # NOQA</font>
<font color="green">  22. from django.db import connection, connections, router</font>
<font color="green">  23. from django.db.models.query_utils import QueryWrapper, RegisterLookupMixin</font>
<font color="green">  24. from django.utils import six, timezone</font>
<font color="green">  25. from django.utils.datastructures import DictWrapper</font>
<font color="green">  26. from django.utils.dateparse import (</font>
<font color="black">  27.     parse_date, parse_datetime, parse_duration, parse_time,</font>
<font color="black">  28. )</font>
<font color="green">  29. from django.utils.deprecation import (</font>
<font color="black">  30.     RemovedInDjango20Warning, warn_about_renamed_method,</font>
<font color="black">  31. )</font>
<font color="green">  32. from django.utils.duration import duration_string</font>
<font color="green">  33. from django.utils.encoding import (</font>
<font color="black">  34.     force_bytes, force_text, python_2_unicode_compatible, smart_text,</font>
<font color="black">  35. )</font>
<font color="green">  36. from django.utils.functional import Promise, cached_property, curry</font>
<font color="green">  37. from django.utils.ipv6 import clean_ipv6_address</font>
<font color="green">  38. from django.utils.itercompat import is_iterable</font>
<font color="green">  39. from django.utils.text import capfirst</font>
<font color="green">  40. from django.utils.translation import ugettext_lazy as _</font>
<font color="black">  41. </font>
<font color="black">  42. # Avoid &quot;TypeError: Item in ``from list'' not a string&quot; -- unicode_literals</font>
<font color="black">  43. # makes these strings unicode</font>
<font color="green">  44. __all__ = [str(x) for x in (</font>
<font color="green">  45.     'AutoField', 'BLANK_CHOICE_DASH', 'BigIntegerField', 'BinaryField',</font>
<font color="green">  46.     'BooleanField', 'CharField', 'CommaSeparatedIntegerField', 'DateField',</font>
<font color="green">  47.     'DateTimeField', 'DecimalField', 'DurationField', 'EmailField', 'Empty',</font>
<font color="green">  48.     'Field', 'FieldDoesNotExist', 'FilePathField', 'FloatField',</font>
<font color="green">  49.     'GenericIPAddressField', 'IPAddressField', 'IntegerField', 'NOT_PROVIDED',</font>
<font color="green">  50.     'NullBooleanField', 'PositiveIntegerField', 'PositiveSmallIntegerField',</font>
<font color="green">  51.     'SlugField', 'SmallIntegerField', 'TextField', 'TimeField', 'URLField',</font>
<font color="green">  52.     'UUIDField',</font>
<font color="black">  53. )]</font>
<font color="black">  54. </font>
<font color="black">  55. </font>
<font color="green">  56. class Empty(object):</font>
<font color="green">  57.     pass</font>
<font color="black">  58. </font>
<font color="black">  59. </font>
<font color="green">  60. class NOT_PROVIDED:</font>
<font color="green">  61.     pass</font>
<font color="black">  62. </font>
<font color="black">  63. # The values to use for &quot;blank&quot; in SelectFields. Will be appended to the start</font>
<font color="black">  64. # of most &quot;choices&quot; lists.</font>
<font color="green">  65. BLANK_CHOICE_DASH = [(&quot;&quot;, &quot;---------&quot;)]</font>
<font color="black">  66. </font>
<font color="black">  67. </font>
<font color="green">  68. def _load_field(app_label, model_name, field_name):</font>
<font color="red">  69.     return apps.get_model(app_label, model_name)._meta.get_field(field_name)</font>
<font color="black">  70. </font>
<font color="black">  71. </font>
<font color="black">  72. # A guide to Field parameters:</font>
<font color="black">  73. #</font>
<font color="black">  74. #   * name:      The name of the field specified in the model.</font>
<font color="black">  75. #   * attname:   The attribute to use on the model object. This is the same as</font>
<font color="black">  76. #                &quot;name&quot;, except in the case of ForeignKeys, where &quot;_id&quot; is</font>
<font color="black">  77. #                appended.</font>
<font color="black">  78. #   * db_column: The db_column specified in the model (or None).</font>
<font color="black">  79. #   * column:    The database column for this field. This is the same as</font>
<font color="black">  80. #                &quot;attname&quot;, except if db_column is specified.</font>
<font color="black">  81. #</font>
<font color="black">  82. # Code that introspects values, or does other dynamic things, should use</font>
<font color="black">  83. # attname. For example, this gets the primary key value of object &quot;obj&quot;:</font>
<font color="black">  84. #</font>
<font color="black">  85. #     getattr(obj, opts.pk.attname)</font>
<font color="black">  86. </font>
<font color="green">  87. def _empty(of_cls):</font>
<font color="red">  88.     new = Empty()</font>
<font color="red">  89.     new.__class__ = of_cls</font>
<font color="red">  90.     return new</font>
<font color="black">  91. </font>
<font color="black">  92. </font>
<font color="green">  93. @total_ordering</font>
<font color="green">  94. @python_2_unicode_compatible</font>
<font color="green">  95. class Field(RegisterLookupMixin):</font>
<font color="green">  96.     &quot;&quot;&quot;Base class for all field types&quot;&quot;&quot;</font>
<font color="black">  97. </font>
<font color="black">  98.     # Designates whether empty strings fundamentally are allowed at the</font>
<font color="black">  99.     # database level.</font>
<font color="green"> 100.     empty_strings_allowed = True</font>
<font color="green"> 101.     empty_values = list(validators.EMPTY_VALUES)</font>
<font color="black"> 102. </font>
<font color="black"> 103.     # These track each time a Field instance is created. Used to retain order.</font>
<font color="black"> 104.     # The auto_creation_counter is used for fields that Django implicitly</font>
<font color="black"> 105.     # creates, creation_counter is used for all user-specified fields.</font>
<font color="green"> 106.     creation_counter = 0</font>
<font color="green"> 107.     auto_creation_counter = -1</font>
<font color="green"> 108.     default_validators = []  # Default set of validators</font>
<font color="green"> 109.     default_error_messages = {</font>
<font color="green"> 110.         'invalid_choice': _('Value %(value)r is not a valid choice.'),</font>
<font color="green"> 111.         'null': _('This field cannot be null.'),</font>
<font color="green"> 112.         'blank': _('This field cannot be blank.'),</font>
<font color="green"> 113.         'unique': _('%(model_name)s with this %(field_label)s '</font>
<font color="black"> 114.                     'already exists.'),</font>
<font color="black"> 115.         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.</font>
<font color="black"> 116.         # Eg: &quot;Title must be unique for pub_date year&quot;</font>
<font color="green"> 117.         'unique_for_date': _(&quot;%(field_label)s must be unique for &quot;</font>
<font color="black"> 118.                              &quot;%(date_field_label)s %(lookup_type)s.&quot;),</font>
<font color="black"> 119.     }</font>
<font color="green"> 120.     system_check_deprecated_details = None</font>
<font color="green"> 121.     system_check_removed_details = None</font>
<font color="black"> 122. </font>
<font color="black"> 123.     # Field flags</font>
<font color="green"> 124.     hidden = False</font>
<font color="black"> 125. </font>
<font color="green"> 126.     many_to_many = None</font>
<font color="green"> 127.     many_to_one = None</font>
<font color="green"> 128.     one_to_many = None</font>
<font color="green"> 129.     one_to_one = None</font>
<font color="green"> 130.     related_model = None</font>
<font color="black"> 131. </font>
<font color="black"> 132.     # Generic field type description, usually overridden by subclasses</font>
<font color="green"> 133.     def _description(self):</font>
<font color="red"> 134.         return _('Field of type: %(field_type)s') % {</font>
<font color="red"> 135.             'field_type': self.__class__.__name__</font>
<font color="black"> 136.         }</font>
<font color="green"> 137.     description = property(_description)</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def __init__(self, verbose_name=None, name=None, primary_key=False,</font>
<font color="green"> 140.             max_length=None, unique=False, blank=False, null=False,</font>
<font color="green"> 141.             db_index=False, rel=None, default=NOT_PROVIDED, editable=True,</font>
<font color="green"> 142.             serialize=True, unique_for_date=None, unique_for_month=None,</font>
<font color="green"> 143.             unique_for_year=None, choices=None, help_text='', db_column=None,</font>
<font color="green"> 144.             db_tablespace=None, auto_created=False, validators=[],</font>
<font color="green"> 145.             error_messages=None):</font>
<font color="green"> 146.         self.name = name</font>
<font color="green"> 147.         self.verbose_name = verbose_name  # May be set by set_attributes_from_name</font>
<font color="green"> 148.         self._verbose_name = verbose_name  # Store original for deconstruction</font>
<font color="green"> 149.         self.primary_key = primary_key</font>
<font color="green"> 150.         self.max_length, self._unique = max_length, unique</font>
<font color="green"> 151.         self.blank, self.null = blank, null</font>
<font color="green"> 152.         self.remote_field = rel</font>
<font color="green"> 153.         self.is_relation = self.remote_field is not None</font>
<font color="green"> 154.         self.default = default</font>
<font color="green"> 155.         self.editable = editable</font>
<font color="green"> 156.         self.serialize = serialize</font>
<font color="green"> 157.         self.unique_for_date = unique_for_date</font>
<font color="green"> 158.         self.unique_for_month = unique_for_month</font>
<font color="green"> 159.         self.unique_for_year = unique_for_year</font>
<font color="green"> 160.         if isinstance(choices, collections.Iterator):</font>
<font color="red"> 161.             choices = list(choices)</font>
<font color="green"> 162.         self.choices = choices or []</font>
<font color="green"> 163.         self.help_text = help_text</font>
<font color="green"> 164.         self.db_index = db_index</font>
<font color="green"> 165.         self.db_column = db_column</font>
<font color="green"> 166.         self.db_tablespace = db_tablespace or settings.DEFAULT_INDEX_TABLESPACE</font>
<font color="green"> 167.         self.auto_created = auto_created</font>
<font color="black"> 168. </font>
<font color="black"> 169.         # Adjust the appropriate creation counter, and save our local copy.</font>
<font color="green"> 170.         if auto_created:</font>
<font color="green"> 171.             self.creation_counter = Field.auto_creation_counter</font>
<font color="green"> 172.             Field.auto_creation_counter -= 1</font>
<font color="black"> 173.         else:</font>
<font color="green"> 174.             self.creation_counter = Field.creation_counter</font>
<font color="green"> 175.             Field.creation_counter += 1</font>
<font color="black"> 176. </font>
<font color="green"> 177.         self._validators = validators  # Store for deconstruction later</font>
<font color="black"> 178. </font>
<font color="green"> 179.         messages = {}</font>
<font color="green"> 180.         for c in reversed(self.__class__.__mro__):</font>
<font color="green"> 181.             messages.update(getattr(c, 'default_error_messages', {}))</font>
<font color="green"> 182.         messages.update(error_messages or {})</font>
<font color="green"> 183.         self._error_messages = error_messages  # Store for deconstruction later</font>
<font color="green"> 184.         self.error_messages = messages</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def __str__(self):</font>
<font color="black"> 187.         &quot;&quot;&quot; Return &quot;app_label.model_label.field_name&quot;. &quot;&quot;&quot;</font>
<font color="red"> 188.         model = self.model</font>
<font color="red"> 189.         app = model._meta.app_label</font>
<font color="red"> 190.         return '%s.%s.%s' % (app, model._meta.object_name, self.name)</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def __repr__(self):</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="black"> 194.         Displays the module, class and name of the field.</font>
<font color="black"> 195.         &quot;&quot;&quot;</font>
<font color="red"> 196.         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)</font>
<font color="red"> 197.         name = getattr(self, 'name', None)</font>
<font color="red"> 198.         if name is not None:</font>
<font color="red"> 199.             return '&lt;%s: %s&gt;' % (path, name)</font>
<font color="red"> 200.         return '&lt;%s&gt;' % path</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def check(self, **kwargs):</font>
<font color="red"> 203.         errors = []</font>
<font color="red"> 204.         errors.extend(self._check_field_name())</font>
<font color="red"> 205.         errors.extend(self._check_choices())</font>
<font color="red"> 206.         errors.extend(self._check_db_index())</font>
<font color="red"> 207.         errors.extend(self._check_null_allowed_for_primary_keys())</font>
<font color="red"> 208.         errors.extend(self._check_backend_specific_checks(**kwargs))</font>
<font color="red"> 209.         errors.extend(self._check_deprecation_details())</font>
<font color="red"> 210.         return errors</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def _check_field_name(self):</font>
<font color="black"> 213.         &quot;&quot;&quot; Check if field name is valid, i.e. 1) does not end with an</font>
<font color="black"> 214.         underscore, 2) does not contain &quot;__&quot; and 3) is not &quot;pk&quot;. &quot;&quot;&quot;</font>
<font color="black"> 215. </font>
<font color="red"> 216.         if self.name.endswith('_'):</font>
<font color="black"> 217.             return [</font>
<font color="red"> 218.                 checks.Error(</font>
<font color="red"> 219.                     'Field names must not end with an underscore.',</font>
<font color="red"> 220.                     hint=None,</font>
<font color="red"> 221.                     obj=self,</font>
<font color="red"> 222.                     id='fields.E001',</font>
<font color="black"> 223.                 )</font>
<font color="black"> 224.             ]</font>
<font color="red"> 225.         elif '__' in self.name:</font>
<font color="black"> 226.             return [</font>
<font color="red"> 227.                 checks.Error(</font>
<font color="red"> 228.                     'Field names must not contain &quot;__&quot;.',</font>
<font color="red"> 229.                     hint=None,</font>
<font color="red"> 230.                     obj=self,</font>
<font color="red"> 231.                     id='fields.E002',</font>
<font color="black"> 232.                 )</font>
<font color="black"> 233.             ]</font>
<font color="red"> 234.         elif self.name == 'pk':</font>
<font color="black"> 235.             return [</font>
<font color="red"> 236.                 checks.Error(</font>
<font color="red"> 237.                     &quot;'pk' is a reserved word that cannot be used as a field name.&quot;,</font>
<font color="red"> 238.                     hint=None,</font>
<font color="red"> 239.                     obj=self,</font>
<font color="red"> 240.                     id='fields.E003',</font>
<font color="black"> 241.                 )</font>
<font color="black"> 242.             ]</font>
<font color="black"> 243.         else:</font>
<font color="red"> 244.             return []</font>
<font color="black"> 245. </font>
<font color="green"> 246.     @property</font>
<font color="black"> 247.     def rel(self):</font>
<font color="red"> 248.         warnings.warn(</font>
<font color="red"> 249.             &quot;Usage of field.rel has been deprecated. Use field.remote_field instead.&quot;,</font>
<font color="red"> 250.             RemovedInDjango20Warning, 2)</font>
<font color="red"> 251.         return self.remote_field</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def _check_choices(self):</font>
<font color="red"> 254.         if self.choices:</font>
<font color="red"> 255.             if (isinstance(self.choices, six.string_types) or</font>
<font color="red"> 256.                     not is_iterable(self.choices)):</font>
<font color="black"> 257.                 return [</font>
<font color="red"> 258.                     checks.Error(</font>
<font color="red"> 259.                         &quot;'choices' must be an iterable (e.g., a list or tuple).&quot;,</font>
<font color="red"> 260.                         hint=None,</font>
<font color="red"> 261.                         obj=self,</font>
<font color="red"> 262.                         id='fields.E004',</font>
<font color="black"> 263.                     )</font>
<font color="black"> 264.                 ]</font>
<font color="red"> 265.             elif any(isinstance(choice, six.string_types) or</font>
<font color="black"> 266.                      not is_iterable(choice) or len(choice) != 2</font>
<font color="red"> 267.                      for choice in self.choices):</font>
<font color="black"> 268.                 return [</font>
<font color="red"> 269.                     checks.Error(</font>
<font color="red"> 270.                         (&quot;'choices' must be an iterable containing &quot;</font>
<font color="black"> 271.                          &quot;(actual value, human readable name) tuples.&quot;),</font>
<font color="red"> 272.                         hint=None,</font>
<font color="red"> 273.                         obj=self,</font>
<font color="red"> 274.                         id='fields.E005',</font>
<font color="black"> 275.                     )</font>
<font color="black"> 276.                 ]</font>
<font color="black"> 277.             else:</font>
<font color="red"> 278.                 return []</font>
<font color="black"> 279.         else:</font>
<font color="red"> 280.             return []</font>
<font color="black"> 281. </font>
<font color="green"> 282.     def _check_db_index(self):</font>
<font color="red"> 283.         if self.db_index not in (None, True, False):</font>
<font color="black"> 284.             return [</font>
<font color="red"> 285.                 checks.Error(</font>
<font color="red"> 286.                     &quot;'db_index' must be None, True or False.&quot;,</font>
<font color="red"> 287.                     hint=None,</font>
<font color="red"> 288.                     obj=self,</font>
<font color="red"> 289.                     id='fields.E006',</font>
<font color="black"> 290.                 )</font>
<font color="black"> 291.             ]</font>
<font color="black"> 292.         else:</font>
<font color="red"> 293.             return []</font>
<font color="black"> 294. </font>
<font color="green"> 295.     def _check_null_allowed_for_primary_keys(self):</font>
<font color="red"> 296.         if (self.primary_key and self.null and</font>
<font color="red"> 297.                 not connection.features.interprets_empty_strings_as_nulls):</font>
<font color="black"> 298.             # We cannot reliably check this for backends like Oracle which</font>
<font color="black"> 299.             # consider NULL and '' to be equal (and thus set up</font>
<font color="black"> 300.             # character-based fields a little differently).</font>
<font color="black"> 301.             return [</font>
<font color="red"> 302.                 checks.Error(</font>
<font color="red"> 303.                     'Primary keys must not have null=True.',</font>
<font color="red"> 304.                     hint=('Set null=False on the field, or '</font>
<font color="black"> 305.                           'remove primary_key=True argument.'),</font>
<font color="red"> 306.                     obj=self,</font>
<font color="red"> 307.                     id='fields.E007',</font>
<font color="black"> 308.                 )</font>
<font color="black"> 309.             ]</font>
<font color="black"> 310.         else:</font>
<font color="red"> 311.             return []</font>
<font color="black"> 312. </font>
<font color="green"> 313.     def _check_backend_specific_checks(self, **kwargs):</font>
<font color="red"> 314.         app_label = self.model._meta.app_label</font>
<font color="red"> 315.         for db in connections:</font>
<font color="red"> 316.             if router.allow_migrate(db, app_label, model=self.model):</font>
<font color="red"> 317.                 return connections[db].validation.check_field(self, **kwargs)</font>
<font color="red"> 318.         return []</font>
<font color="black"> 319. </font>
<font color="green"> 320.     def _check_deprecation_details(self):</font>
<font color="red"> 321.         if self.system_check_removed_details is not None:</font>
<font color="black"> 322.             return [</font>
<font color="red"> 323.                 checks.Error(</font>
<font color="red"> 324.                     self.system_check_removed_details.get(</font>
<font color="red"> 325.                         'msg',</font>
<font color="red"> 326.                         '%s has been removed except for support in historical '</font>
<font color="red"> 327.                         'migrations.' % self.__class__.__name__</font>
<font color="black"> 328.                     ),</font>
<font color="red"> 329.                     hint=self.system_check_removed_details.get('hint'),</font>
<font color="red"> 330.                     obj=self,</font>
<font color="red"> 331.                     id=self.system_check_removed_details.get('id', 'fields.EXXX'),</font>
<font color="black"> 332.                 )</font>
<font color="black"> 333.             ]</font>
<font color="red"> 334.         elif self.system_check_deprecated_details is not None:</font>
<font color="black"> 335.             return [</font>
<font color="red"> 336.                 checks.Warning(</font>
<font color="red"> 337.                     self.system_check_deprecated_details.get(</font>
<font color="red"> 338.                         'msg',</font>
<font color="red"> 339.                         '%s has been deprecated.' % self.__class__.__name__</font>
<font color="black"> 340.                     ),</font>
<font color="red"> 341.                     hint=self.system_check_deprecated_details.get('hint'),</font>
<font color="red"> 342.                     obj=self,</font>
<font color="red"> 343.                     id=self.system_check_deprecated_details.get('id', 'fields.WXXX'),</font>
<font color="black"> 344.                 )</font>
<font color="black"> 345.             ]</font>
<font color="red"> 346.         return []</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def get_col(self, alias, output_field=None):</font>
<font color="green"> 349.         if output_field is None:</font>
<font color="green"> 350.             output_field = self</font>
<font color="green"> 351.         if alias != self.model._meta.db_table or output_field != self:</font>
<font color="green"> 352.             from django.db.models.expressions import Col</font>
<font color="green"> 353.             return Col(alias, self, output_field)</font>
<font color="black"> 354.         else:</font>
<font color="green"> 355.             return self.cached_col</font>
<font color="black"> 356. </font>
<font color="green"> 357.     @cached_property</font>
<font color="black"> 358.     def cached_col(self):</font>
<font color="green"> 359.         from django.db.models.expressions import Col</font>
<font color="green"> 360.         return Col(self.model._meta.db_table, self)</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def select_format(self, compiler, sql, params):</font>
<font color="black"> 363.         &quot;&quot;&quot;</font>
<font color="black"> 364.         Custom format for select clauses. For example, GIS columns need to be</font>
<font color="black"> 365.         selected as AsText(table.col) on MySQL as the table.col data can't be used</font>
<font color="black"> 366.         by Django.</font>
<font color="black"> 367.         &quot;&quot;&quot;</font>
<font color="green"> 368.         return sql, params</font>
<font color="black"> 369. </font>
<font color="green"> 370.     def deconstruct(self):</font>
<font color="black"> 371.         &quot;&quot;&quot;</font>
<font color="black"> 372.         Returns enough information to recreate the field as a 4-tuple:</font>
<font color="black"> 373. </font>
<font color="black"> 374.          * The name of the field on the model, if contribute_to_class has been run</font>
<font color="black"> 375.          * The import path of the field, including the class: django.db.models.IntegerField</font>
<font color="black"> 376.            This should be the most portable version, so less specific may be better.</font>
<font color="black"> 377.          * A list of positional arguments</font>
<font color="black"> 378.          * A dict of keyword arguments</font>
<font color="black"> 379. </font>
<font color="black"> 380.         Note that the positional or keyword arguments must contain values of the</font>
<font color="black"> 381.         following types (including inner values of collection types):</font>
<font color="black"> 382. </font>
<font color="black"> 383.          * None, bool, str, unicode, int, long, float, complex, set, frozenset, list, tuple, dict</font>
<font color="black"> 384.          * UUID</font>
<font color="black"> 385.          * datetime.datetime (naive), datetime.date</font>
<font color="black"> 386.          * top-level classes, top-level functions - will be referenced by their full import path</font>
<font color="black"> 387.          * Storage instances - these have their own deconstruct() method</font>
<font color="black"> 388. </font>
<font color="black"> 389.         This is because the values here must be serialized into a text format</font>
<font color="black"> 390.         (possibly new Python code, possibly JSON) and these are the only types</font>
<font color="black"> 391.         with encoding handlers defined.</font>
<font color="black"> 392. </font>
<font color="black"> 393.         There's no need to return the exact way the field was instantiated this time,</font>
<font color="black"> 394.         just ensure that the resulting field is the same - prefer keyword arguments</font>
<font color="black"> 395.         over positional ones, and omit parameters with their default values.</font>
<font color="black"> 396.         &quot;&quot;&quot;</font>
<font color="black"> 397.         # Short-form way of fetching all the default parameters</font>
<font color="green"> 398.         keywords = {}</font>
<font color="green"> 399.         possibles = {</font>
<font color="green"> 400.             &quot;verbose_name&quot;: None,</font>
<font color="green"> 401.             &quot;primary_key&quot;: False,</font>
<font color="green"> 402.             &quot;max_length&quot;: None,</font>
<font color="green"> 403.             &quot;unique&quot;: False,</font>
<font color="green"> 404.             &quot;blank&quot;: False,</font>
<font color="green"> 405.             &quot;null&quot;: False,</font>
<font color="green"> 406.             &quot;db_index&quot;: False,</font>
<font color="green"> 407.             &quot;default&quot;: NOT_PROVIDED,</font>
<font color="green"> 408.             &quot;editable&quot;: True,</font>
<font color="green"> 409.             &quot;serialize&quot;: True,</font>
<font color="green"> 410.             &quot;unique_for_date&quot;: None,</font>
<font color="green"> 411.             &quot;unique_for_month&quot;: None,</font>
<font color="green"> 412.             &quot;unique_for_year&quot;: None,</font>
<font color="green"> 413.             &quot;choices&quot;: [],</font>
<font color="green"> 414.             &quot;help_text&quot;: '',</font>
<font color="green"> 415.             &quot;db_column&quot;: None,</font>
<font color="green"> 416.             &quot;db_tablespace&quot;: settings.DEFAULT_INDEX_TABLESPACE,</font>
<font color="green"> 417.             &quot;auto_created&quot;: False,</font>
<font color="green"> 418.             &quot;validators&quot;: [],</font>
<font color="green"> 419.             &quot;error_messages&quot;: None,</font>
<font color="black"> 420.         }</font>
<font color="green"> 421.         attr_overrides = {</font>
<font color="green"> 422.             &quot;unique&quot;: &quot;_unique&quot;,</font>
<font color="green"> 423.             &quot;error_messages&quot;: &quot;_error_messages&quot;,</font>
<font color="green"> 424.             &quot;validators&quot;: &quot;_validators&quot;,</font>
<font color="green"> 425.             &quot;verbose_name&quot;: &quot;_verbose_name&quot;,</font>
<font color="black"> 426.         }</font>
<font color="green"> 427.         equals_comparison = {&quot;choices&quot;, &quot;validators&quot;, &quot;db_tablespace&quot;}</font>
<font color="green"> 428.         for name, default in possibles.items():</font>
<font color="green"> 429.             value = getattr(self, attr_overrides.get(name, name))</font>
<font color="black"> 430.             # Unroll anything iterable for choices into a concrete list</font>
<font color="green"> 431.             if name == &quot;choices&quot; and isinstance(value, collections.Iterable):</font>
<font color="green"> 432.                 value = list(value)</font>
<font color="black"> 433.             # Do correct kind of comparison</font>
<font color="green"> 434.             if name in equals_comparison:</font>
<font color="green"> 435.                 if value != default:</font>
<font color="green"> 436.                     keywords[name] = value</font>
<font color="black"> 437.             else:</font>
<font color="green"> 438.                 if value is not default:</font>
<font color="green"> 439.                     keywords[name] = value</font>
<font color="black"> 440.         # Work out path - we shorten it for known Django core fields</font>
<font color="green"> 441.         path = &quot;%s.%s&quot; % (self.__class__.__module__, self.__class__.__name__)</font>
<font color="green"> 442.         if path.startswith(&quot;django.db.models.fields.related&quot;):</font>
<font color="green"> 443.             path = path.replace(&quot;django.db.models.fields.related&quot;, &quot;django.db.models&quot;)</font>
<font color="green"> 444.         if path.startswith(&quot;django.db.models.fields.files&quot;):</font>
<font color="red"> 445.             path = path.replace(&quot;django.db.models.fields.files&quot;, &quot;django.db.models&quot;)</font>
<font color="green"> 446.         if path.startswith(&quot;django.db.models.fields.proxy&quot;):</font>
<font color="red"> 447.             path = path.replace(&quot;django.db.models.fields.proxy&quot;, &quot;django.db.models&quot;)</font>
<font color="green"> 448.         if path.startswith(&quot;django.db.models.fields&quot;):</font>
<font color="green"> 449.             path = path.replace(&quot;django.db.models.fields&quot;, &quot;django.db.models&quot;)</font>
<font color="black"> 450.         # Return basic info - other fields should override this.</font>
<font color="black"> 451.         return (</font>
<font color="green"> 452.             force_text(self.name, strings_only=True),</font>
<font color="green"> 453.             path,</font>
<font color="green"> 454.             [],</font>
<font color="green"> 455.             keywords,</font>
<font color="black"> 456.         )</font>
<font color="black"> 457. </font>
<font color="green"> 458.     def clone(self):</font>
<font color="black"> 459.         &quot;&quot;&quot;</font>
<font color="black"> 460.         Uses deconstruct() to clone a new copy of this Field.</font>
<font color="black"> 461.         Will not preserve any class attachments/attribute names.</font>
<font color="black"> 462.         &quot;&quot;&quot;</font>
<font color="green"> 463.         name, path, args, kwargs = self.deconstruct()</font>
<font color="green"> 464.         return self.__class__(*args, **kwargs)</font>
<font color="black"> 465. </font>
<font color="green"> 466.     def __eq__(self, other):</font>
<font color="black"> 467.         # Needed for @total_ordering</font>
<font color="green"> 468.         if isinstance(other, Field):</font>
<font color="green"> 469.             return self.creation_counter == other.creation_counter</font>
<font color="red"> 470.         return NotImplemented</font>
<font color="black"> 471. </font>
<font color="green"> 472.     def __lt__(self, other):</font>
<font color="black"> 473.         # This is needed because bisect does not take a comparison function.</font>
<font color="green"> 474.         if isinstance(other, Field):</font>
<font color="green"> 475.             return self.creation_counter &lt; other.creation_counter</font>
<font color="red"> 476.         return NotImplemented</font>
<font color="black"> 477. </font>
<font color="green"> 478.     def __hash__(self):</font>
<font color="red"> 479.         return hash(self.creation_counter)</font>
<font color="black"> 480. </font>
<font color="green"> 481.     def __deepcopy__(self, memodict):</font>
<font color="black"> 482.         # We don't have to deepcopy very much here, since most things are not</font>
<font color="black"> 483.         # intended to be altered after initial creation.</font>
<font color="green"> 484.         obj = copy.copy(self)</font>
<font color="green"> 485.         if self.remote_field:</font>
<font color="green"> 486.             obj.remote_field = copy.copy(self.remote_field)</font>
<font color="green"> 487.             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:</font>
<font color="green"> 488.                 obj.remote_field.field = obj</font>
<font color="green"> 489.         memodict[id(self)] = obj</font>
<font color="green"> 490.         return obj</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def __copy__(self):</font>
<font color="black"> 493.         # We need to avoid hitting __reduce__, so define this</font>
<font color="black"> 494.         # slightly weird copy construct.</font>
<font color="green"> 495.         obj = Empty()</font>
<font color="green"> 496.         obj.__class__ = self.__class__</font>
<font color="green"> 497.         obj.__dict__ = self.__dict__.copy()</font>
<font color="green"> 498.         return obj</font>
<font color="black"> 499. </font>
<font color="green"> 500.     def __reduce__(self):</font>
<font color="black"> 501.         &quot;&quot;&quot;</font>
<font color="black"> 502.         Pickling should return the model._meta.fields instance of the field,</font>
<font color="black"> 503.         not a new copy of that field. So, we use the app registry to load the</font>
<font color="black"> 504.         model and then the field back.</font>
<font color="black"> 505.         &quot;&quot;&quot;</font>
<font color="red"> 506.         if not hasattr(self, 'model'):</font>
<font color="black"> 507.             # Fields are sometimes used without attaching them to models (for</font>
<font color="black"> 508.             # example in aggregation). In this case give back a plain field</font>
<font color="black"> 509.             # instance. The code below will create a new empty instance of</font>
<font color="black"> 510.             # class self.__class__, then update its dict with self.__dict__</font>
<font color="black"> 511.             # values - so, this is very close to normal pickle.</font>
<font color="red"> 512.             return _empty, (self.__class__,), self.__dict__</font>
<font color="red"> 513.         if self.model._deferred:</font>
<font color="black"> 514.             # Deferred model will not be found from the app registry. This</font>
<font color="black"> 515.             # could be fixed by reconstructing the deferred model on unpickle.</font>
<font color="red"> 516.             raise RuntimeError(&quot;Fields of deferred models can't be reduced&quot;)</font>
<font color="red"> 517.         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,</font>
<font color="red"> 518.                              self.name)</font>
<font color="black"> 519. </font>
<font color="green"> 520.     def get_pk_value_on_save(self, instance):</font>
<font color="black"> 521.         &quot;&quot;&quot;</font>
<font color="black"> 522.         Hook to generate new PK values on save. This method is called when</font>
<font color="black"> 523.         saving instances with no primary key value set. If this method returns</font>
<font color="black"> 524.         something else than None, then the returned value is used when saving</font>
<font color="black"> 525.         the new instance.</font>
<font color="black"> 526.         &quot;&quot;&quot;</font>
<font color="green"> 527.         if self.default:</font>
<font color="green"> 528.             return self.get_default()</font>
<font color="red"> 529.         return None</font>
<font color="black"> 530. </font>
<font color="green"> 531.     def to_python(self, value):</font>
<font color="black"> 532.         &quot;&quot;&quot;</font>
<font color="black"> 533.         Converts the input value into the expected Python data type, raising</font>
<font color="black"> 534.         django.core.exceptions.ValidationError if the data can't be converted.</font>
<font color="black"> 535.         Returns the converted value. Subclasses should override this.</font>
<font color="black"> 536.         &quot;&quot;&quot;</font>
<font color="red"> 537.         return value</font>
<font color="black"> 538. </font>
<font color="green"> 539.     @cached_property</font>
<font color="black"> 540.     def validators(self):</font>
<font color="black"> 541.         # Some validators can't be created at field initialization time.</font>
<font color="black"> 542.         # This method provides a way to delay their creation until required.</font>
<font color="green"> 543.         return self.default_validators + self._validators</font>
<font color="black"> 544. </font>
<font color="green"> 545.     def run_validators(self, value):</font>
<font color="red"> 546.         if value in self.empty_values:</font>
<font color="red"> 547.             return</font>
<font color="black"> 548. </font>
<font color="red"> 549.         errors = []</font>
<font color="red"> 550.         for v in self.validators:</font>
<font color="red"> 551.             try:</font>
<font color="red"> 552.                 v(value)</font>
<font color="red"> 553.             except exceptions.ValidationError as e:</font>
<font color="red"> 554.                 if hasattr(e, 'code') and e.code in self.error_messages:</font>
<font color="red"> 555.                     e.message = self.error_messages[e.code]</font>
<font color="red"> 556.                 errors.extend(e.error_list)</font>
<font color="black"> 557. </font>
<font color="red"> 558.         if errors:</font>
<font color="red"> 559.             raise exceptions.ValidationError(errors)</font>
<font color="black"> 560. </font>
<font color="green"> 561.     def validate(self, value, model_instance):</font>
<font color="black"> 562.         &quot;&quot;&quot;</font>
<font color="black"> 563.         Validates value and throws ValidationError. Subclasses should override</font>
<font color="black"> 564.         this to provide validation logic.</font>
<font color="black"> 565.         &quot;&quot;&quot;</font>
<font color="red"> 566.         if not self.editable:</font>
<font color="black"> 567.             # Skip validation for non-editable fields.</font>
<font color="red"> 568.             return</font>
<font color="black"> 569. </font>
<font color="red"> 570.         if self.choices and value not in self.empty_values:</font>
<font color="red"> 571.             for option_key, option_value in self.choices:</font>
<font color="red"> 572.                 if isinstance(option_value, (list, tuple)):</font>
<font color="black"> 573.                     # This is an optgroup, so look inside the group for</font>
<font color="black"> 574.                     # options.</font>
<font color="red"> 575.                     for optgroup_key, optgroup_value in option_value:</font>
<font color="red"> 576.                         if value == optgroup_key:</font>
<font color="red"> 577.                             return</font>
<font color="red"> 578.                 elif value == option_key:</font>
<font color="red"> 579.                     return</font>
<font color="red"> 580.             raise exceptions.ValidationError(</font>
<font color="red"> 581.                 self.error_messages['invalid_choice'],</font>
<font color="red"> 582.                 code='invalid_choice',</font>
<font color="red"> 583.                 params={'value': value},</font>
<font color="black"> 584.             )</font>
<font color="black"> 585. </font>
<font color="red"> 586.         if value is None and not self.null:</font>
<font color="red"> 587.             raise exceptions.ValidationError(self.error_messages['null'], code='null')</font>
<font color="black"> 588. </font>
<font color="red"> 589.         if not self.blank and value in self.empty_values:</font>
<font color="red"> 590.             raise exceptions.ValidationError(self.error_messages['blank'], code='blank')</font>
<font color="black"> 591. </font>
<font color="green"> 592.     def clean(self, value, model_instance):</font>
<font color="black"> 593.         &quot;&quot;&quot;</font>
<font color="black"> 594.         Convert the value's type and run validation. Validation errors</font>
<font color="black"> 595.         from to_python and validate are propagated. The correct value is</font>
<font color="black"> 596.         returned if no error is raised.</font>
<font color="black"> 597.         &quot;&quot;&quot;</font>
<font color="red"> 598.         value = self.to_python(value)</font>
<font color="red"> 599.         self.validate(value, model_instance)</font>
<font color="red"> 600.         self.run_validators(value)</font>
<font color="red"> 601.         return value</font>
<font color="black"> 602. </font>
<font color="green"> 603.     def db_type(self, connection):</font>
<font color="black"> 604.         &quot;&quot;&quot;</font>
<font color="black"> 605.         Returns the database column data type for this field, for the provided</font>
<font color="black"> 606.         connection.</font>
<font color="black"> 607.         &quot;&quot;&quot;</font>
<font color="black"> 608.         # The default implementation of this method looks at the</font>
<font color="black"> 609.         # backend-specific data_types dictionary, looking up the field by its</font>
<font color="black"> 610.         # &quot;internal type&quot;.</font>
<font color="black"> 611.         #</font>
<font color="black"> 612.         # A Field class can implement the get_internal_type() method to specify</font>
<font color="black"> 613.         # which *preexisting* Django Field class it's most similar to -- i.e.,</font>
<font color="black"> 614.         # a custom field might be represented by a TEXT column type, which is</font>
<font color="black"> 615.         # the same as the TextField Django field type, which means the custom</font>
<font color="black"> 616.         # field's get_internal_type() returns 'TextField'.</font>
<font color="black"> 617.         #</font>
<font color="black"> 618.         # But the limitation of the get_internal_type() / data_types approach</font>
<font color="black"> 619.         # is that it cannot handle database column types that aren't already</font>
<font color="black"> 620.         # mapped to one of the built-in Django field types. In this case, you</font>
<font color="black"> 621.         # can implement db_type() instead of get_internal_type() to specify</font>
<font color="black"> 622.         # exactly which wacky database column type you want to use.</font>
<font color="green"> 623.         data = DictWrapper(self.__dict__, connection.ops.quote_name, &quot;qn_&quot;)</font>
<font color="green"> 624.         try:</font>
<font color="green"> 625.             return connection.data_types[self.get_internal_type()] % data</font>
<font color="red"> 626.         except KeyError:</font>
<font color="red"> 627.             return None</font>
<font color="black"> 628. </font>
<font color="green"> 629.     def db_parameters(self, connection):</font>
<font color="black"> 630.         &quot;&quot;&quot;</font>
<font color="black"> 631.         Extension of db_type(), providing a range of different return</font>
<font color="black"> 632.         values (type, checks).</font>
<font color="black"> 633.         This will look at db_type(), allowing custom model fields to override it.</font>
<font color="black"> 634.         &quot;&quot;&quot;</font>
<font color="green"> 635.         data = DictWrapper(self.__dict__, connection.ops.quote_name, &quot;qn_&quot;)</font>
<font color="green"> 636.         type_string = self.db_type(connection)</font>
<font color="green"> 637.         try:</font>
<font color="green"> 638.             check_string = connection.data_type_check_constraints[self.get_internal_type()] % data</font>
<font color="green"> 639.         except KeyError:</font>
<font color="green"> 640.             check_string = None</font>
<font color="green"> 641.         return {</font>
<font color="green"> 642.             &quot;type&quot;: type_string,</font>
<font color="green"> 643.             &quot;check&quot;: check_string,</font>
<font color="black"> 644.         }</font>
<font color="black"> 645. </font>
<font color="green"> 646.     def db_type_suffix(self, connection):</font>
<font color="green"> 647.         return connection.data_types_suffix.get(self.get_internal_type())</font>
<font color="black"> 648. </font>
<font color="green"> 649.     def get_db_converters(self, connection):</font>
<font color="green"> 650.         if hasattr(self, 'from_db_value'):</font>
<font color="red"> 651.             return [self.from_db_value]</font>
<font color="green"> 652.         return []</font>
<font color="black"> 653. </font>
<font color="green"> 654.     @property</font>
<font color="black"> 655.     def unique(self):</font>
<font color="green"> 656.         return self._unique or self.primary_key</font>
<font color="black"> 657. </font>
<font color="green"> 658.     def set_attributes_from_name(self, name):</font>
<font color="green"> 659.         if not self.name:</font>
<font color="green"> 660.             self.name = name</font>
<font color="green"> 661.         self.attname, self.column = self.get_attname_column()</font>
<font color="green"> 662.         self.concrete = self.column is not None</font>
<font color="green"> 663.         if self.verbose_name is None and self.name:</font>
<font color="green"> 664.             self.verbose_name = self.name.replace('_', ' ')</font>
<font color="black"> 665. </font>
<font color="green"> 666.     def contribute_to_class(self, cls, name, virtual_only=False):</font>
<font color="green"> 667.         self.set_attributes_from_name(name)</font>
<font color="green"> 668.         self.model = cls</font>
<font color="green"> 669.         if virtual_only:</font>
<font color="red"> 670.             cls._meta.add_field(self, virtual=True)</font>
<font color="black"> 671.         else:</font>
<font color="green"> 672.             cls._meta.add_field(self)</font>
<font color="green"> 673.         if self.choices:</font>
<font color="red"> 674.             setattr(cls, 'get_%s_display' % self.name,</font>
<font color="red"> 675.                     curry(cls._get_FIELD_display, field=self))</font>
<font color="black"> 676. </font>
<font color="green"> 677.     def get_filter_kwargs_for_object(self, obj):</font>
<font color="black"> 678.         &quot;&quot;&quot;</font>
<font color="black"> 679.         Return a dict that when passed as kwargs to self.model.filter(), would</font>
<font color="black"> 680.         yield all instances having the same value for this field as obj has.</font>
<font color="black"> 681.         &quot;&quot;&quot;</font>
<font color="red"> 682.         return {self.name: getattr(obj, self.attname)}</font>
<font color="black"> 683. </font>
<font color="green"> 684.     def get_attname(self):</font>
<font color="green"> 685.         return self.name</font>
<font color="black"> 686. </font>
<font color="green"> 687.     def get_attname_column(self):</font>
<font color="green"> 688.         attname = self.get_attname()</font>
<font color="green"> 689.         column = self.db_column or attname</font>
<font color="green"> 690.         return attname, column</font>
<font color="black"> 691. </font>
<font color="green"> 692.     def get_cache_name(self):</font>
<font color="green"> 693.         return '_%s_cache' % self.name</font>
<font color="black"> 694. </font>
<font color="green"> 695.     def get_internal_type(self):</font>
<font color="green"> 696.         return self.__class__.__name__</font>
<font color="black"> 697. </font>
<font color="green"> 698.     def pre_save(self, model_instance, add):</font>
<font color="black"> 699.         &quot;&quot;&quot;</font>
<font color="black"> 700.         Returns field's value just before saving.</font>
<font color="black"> 701.         &quot;&quot;&quot;</font>
<font color="green"> 702.         return getattr(model_instance, self.attname)</font>
<font color="black"> 703. </font>
<font color="green"> 704.     def get_prep_value(self, value):</font>
<font color="black"> 705.         &quot;&quot;&quot;</font>
<font color="black"> 706.         Perform preliminary non-db specific value checks and conversions.</font>
<font color="black"> 707.         &quot;&quot;&quot;</font>
<font color="green"> 708.         if isinstance(value, Promise):</font>
<font color="red"> 709.             value = value._proxy____cast()</font>
<font color="green"> 710.         return value</font>
<font color="black"> 711. </font>
<font color="green"> 712.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="black"> 713.         &quot;&quot;&quot;Returns field's value prepared for interacting with the database</font>
<font color="black"> 714.         backend.</font>
<font color="black"> 715. </font>
<font color="black"> 716.         Used by the default implementations of ``get_db_prep_save``and</font>
<font color="black"> 717.         `get_db_prep_lookup```</font>
<font color="black"> 718.         &quot;&quot;&quot;</font>
<font color="green"> 719.         if not prepared:</font>
<font color="green"> 720.             value = self.get_prep_value(value)</font>
<font color="green"> 721.         return value</font>
<font color="black"> 722. </font>
<font color="green"> 723.     def get_db_prep_save(self, value, connection):</font>
<font color="black"> 724.         &quot;&quot;&quot;</font>
<font color="black"> 725.         Returns field's value prepared for saving into a database.</font>
<font color="black"> 726.         &quot;&quot;&quot;</font>
<font color="green"> 727.         return self.get_db_prep_value(value, connection=connection,</font>
<font color="green"> 728.                                       prepared=False)</font>
<font color="black"> 729. </font>
<font color="green"> 730.     def get_prep_lookup(self, lookup_type, value):</font>
<font color="black"> 731.         &quot;&quot;&quot;</font>
<font color="black"> 732.         Perform preliminary non-db specific lookup checks and conversions</font>
<font color="black"> 733.         &quot;&quot;&quot;</font>
<font color="green"> 734.         if hasattr(value, '_prepare'):</font>
<font color="red"> 735.             return value._prepare()</font>
<font color="black"> 736. </font>
<font color="green"> 737.         if lookup_type in {</font>
<font color="green"> 738.             'iexact', 'contains', 'icontains',</font>
<font color="green"> 739.             'startswith', 'istartswith', 'endswith', 'iendswith',</font>
<font color="green"> 740.             'isnull', 'search', 'regex', 'iregex',</font>
<font color="black"> 741.         }:</font>
<font color="red"> 742.             return value</font>
<font color="green"> 743.         elif lookup_type in ('exact', 'gt', 'gte', 'lt', 'lte'):</font>
<font color="green"> 744.             return self.get_prep_value(value)</font>
<font color="green"> 745.         elif lookup_type in ('range', 'in'):</font>
<font color="green"> 746.             return [self.get_prep_value(v) for v in value]</font>
<font color="red"> 747.         return self.get_prep_value(value)</font>
<font color="black"> 748. </font>
<font color="black"> 749.     def get_db_prep_lookup(self, lookup_type, value, connection,</font>
<font color="green"> 750.                            prepared=False):</font>
<font color="black"> 751.         &quot;&quot;&quot;</font>
<font color="black"> 752.         Returns field's value prepared for database lookup.</font>
<font color="black"> 753.         &quot;&quot;&quot;</font>
<font color="green"> 754.         if not prepared:</font>
<font color="red"> 755.             value = self.get_prep_lookup(lookup_type, value)</font>
<font color="red"> 756.             prepared = True</font>
<font color="green"> 757.         if hasattr(value, 'get_compiler'):</font>
<font color="red"> 758.             value = value.get_compiler(connection=connection)</font>
<font color="green"> 759.         if hasattr(value, 'as_sql') or hasattr(value, '_as_sql'):</font>
<font color="black"> 760.             # If the value has a relabeled_clone method it means the</font>
<font color="black"> 761.             # value will be handled later on.</font>
<font color="red"> 762.             if hasattr(value, 'relabeled_clone'):</font>
<font color="red"> 763.                 return value</font>
<font color="red"> 764.             if hasattr(value, 'as_sql'):</font>
<font color="red"> 765.                 sql, params = value.as_sql()</font>
<font color="black"> 766.             else:</font>
<font color="red"> 767.                 sql, params = value._as_sql(connection=connection)</font>
<font color="red"> 768.             return QueryWrapper(('(%s)' % sql), params)</font>
<font color="black"> 769. </font>
<font color="green"> 770.         if lookup_type in ('search', 'regex', 'iregex', 'contains',</font>
<font color="black"> 771.                            'icontains', 'iexact', 'startswith', 'endswith',</font>
<font color="green"> 772.                            'istartswith', 'iendswith'):</font>
<font color="red"> 773.             return [value]</font>
<font color="green"> 774.         elif lookup_type in ('exact', 'gt', 'gte', 'lt', 'lte'):</font>
<font color="green"> 775.             return [self.get_db_prep_value(value, connection=connection,</font>
<font color="green"> 776.                                            prepared=prepared)]</font>
<font color="green"> 777.         elif lookup_type in ('range', 'in'):</font>
<font color="green"> 778.             return [self.get_db_prep_value(v, connection=connection,</font>
<font color="green"> 779.                                            prepared=prepared) for v in value]</font>
<font color="red"> 780.         elif lookup_type == 'isnull':</font>
<font color="red"> 781.             return []</font>
<font color="black"> 782.         else:</font>
<font color="red"> 783.             return [value]</font>
<font color="black"> 784. </font>
<font color="green"> 785.     def has_default(self):</font>
<font color="black"> 786.         &quot;&quot;&quot;</font>
<font color="black"> 787.         Returns a boolean of whether this field has a default value.</font>
<font color="black"> 788.         &quot;&quot;&quot;</font>
<font color="green"> 789.         return self.default is not NOT_PROVIDED</font>
<font color="black"> 790. </font>
<font color="green"> 791.     def get_default(self):</font>
<font color="black"> 792.         &quot;&quot;&quot;</font>
<font color="black"> 793.         Returns the default value for this field.</font>
<font color="black"> 794.         &quot;&quot;&quot;</font>
<font color="green"> 795.         if self.has_default():</font>
<font color="green"> 796.             if callable(self.default):</font>
<font color="green"> 797.                 return self.default()</font>
<font color="green"> 798.             return self.default</font>
<font color="green"> 799.         if (not self.empty_strings_allowed or (self.null and</font>
<font color="red"> 800.                    not connection.features.interprets_empty_strings_as_nulls)):</font>
<font color="green"> 801.             return None</font>
<font color="red"> 802.         return &quot;&quot;</font>
<font color="black"> 803. </font>
<font color="green"> 804.     def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH, limit_choices_to=None):</font>
<font color="black"> 805.         &quot;&quot;&quot;Returns choices with a default blank choices included, for use</font>
<font color="black"> 806.         as SelectField choices for this field.&quot;&quot;&quot;</font>
<font color="red"> 807.         blank_defined = False</font>
<font color="red"> 808.         choices = list(self.choices) if self.choices else []</font>
<font color="red"> 809.         named_groups = choices and isinstance(choices[0][1], (list, tuple))</font>
<font color="red"> 810.         if not named_groups:</font>
<font color="red"> 811.             for choice, __ in choices:</font>
<font color="red"> 812.                 if choice in ('', None):</font>
<font color="red"> 813.                     blank_defined = True</font>
<font color="red"> 814.                     break</font>
<font color="black"> 815. </font>
<font color="red"> 816.         first_choice = (blank_choice if include_blank and</font>
<font color="red"> 817.                         not blank_defined else [])</font>
<font color="red"> 818.         if self.choices:</font>
<font color="red"> 819.             return first_choice + choices</font>
<font color="red"> 820.         rel_model = self.remote_field.model</font>
<font color="red"> 821.         limit_choices_to = limit_choices_to or self.get_limit_choices_to()</font>
<font color="red"> 822.         if hasattr(self.remote_field, 'get_related_field'):</font>
<font color="red"> 823.             lst = [(getattr(x, self.remote_field.get_related_field().attname),</font>
<font color="black"> 824.                    smart_text(x))</font>
<font color="red"> 825.                    for x in rel_model._default_manager.complex_filter(</font>
<font color="red"> 826.                        limit_choices_to)]</font>
<font color="black"> 827.         else:</font>
<font color="red"> 828.             lst = [(x._get_pk_val(), smart_text(x))</font>
<font color="red"> 829.                    for x in rel_model._default_manager.complex_filter(</font>
<font color="red"> 830.                        limit_choices_to)]</font>
<font color="red"> 831.         return first_choice + lst</font>
<font color="black"> 832. </font>
<font color="green"> 833.     def get_choices_default(self):</font>
<font color="red"> 834.         return self.get_choices()</font>
<font color="black"> 835. </font>
<font color="green"> 836.     @warn_about_renamed_method(</font>
<font color="green"> 837.         'Field', '_get_val_from_obj', 'value_from_object',</font>
<font color="green"> 838.         RemovedInDjango20Warning</font>
<font color="black"> 839.     )</font>
<font color="black"> 840.     def _get_val_from_obj(self, obj):</font>
<font color="red"> 841.         if obj is not None:</font>
<font color="red"> 842.             return getattr(obj, self.attname)</font>
<font color="black"> 843.         else:</font>
<font color="red"> 844.             return self.get_default()</font>
<font color="black"> 845. </font>
<font color="green"> 846.     def value_to_string(self, obj):</font>
<font color="black"> 847.         &quot;&quot;&quot;</font>
<font color="black"> 848.         Returns a string value of this field from the passed obj.</font>
<font color="black"> 849.         This is used by the serialization framework.</font>
<font color="black"> 850.         &quot;&quot;&quot;</font>
<font color="green"> 851.         return smart_text(self.value_from_object(obj))</font>
<font color="black"> 852. </font>
<font color="green"> 853.     def _get_flatchoices(self):</font>
<font color="black"> 854.         &quot;&quot;&quot;Flattened version of choices tuple.&quot;&quot;&quot;</font>
<font color="red"> 855.         flat = []</font>
<font color="red"> 856.         for choice, value in self.choices:</font>
<font color="red"> 857.             if isinstance(value, (list, tuple)):</font>
<font color="red"> 858.                 flat.extend(value)</font>
<font color="black"> 859.             else:</font>
<font color="red"> 860.                 flat.append((choice, value))</font>
<font color="red"> 861.         return flat</font>
<font color="green"> 862.     flatchoices = property(_get_flatchoices)</font>
<font color="black"> 863. </font>
<font color="green"> 864.     def save_form_data(self, instance, data):</font>
<font color="red"> 865.         setattr(instance, self.name, data)</font>
<font color="black"> 866. </font>
<font color="green"> 867.     def formfield(self, form_class=None, choices_form_class=None, **kwargs):</font>
<font color="black"> 868.         &quot;&quot;&quot;</font>
<font color="black"> 869.         Returns a django.forms.Field instance for this database Field.</font>
<font color="black"> 870.         &quot;&quot;&quot;</font>
<font color="green"> 871.         defaults = {'required': not self.blank,</font>
<font color="green"> 872.                     'label': capfirst(self.verbose_name),</font>
<font color="green"> 873.                     'help_text': self.help_text}</font>
<font color="green"> 874.         if self.has_default():</font>
<font color="green"> 875.             if callable(self.default):</font>
<font color="green"> 876.                 defaults['initial'] = self.default</font>
<font color="green"> 877.                 defaults['show_hidden_initial'] = True</font>
<font color="black"> 878.             else:</font>
<font color="green"> 879.                 defaults['initial'] = self.get_default()</font>
<font color="green"> 880.         if self.choices:</font>
<font color="black"> 881.             # Fields with choices get special treatment.</font>
<font color="red"> 882.             include_blank = (self.blank or</font>
<font color="red"> 883.                              not (self.has_default() or 'initial' in kwargs))</font>
<font color="red"> 884.             defaults['choices'] = self.get_choices(include_blank=include_blank)</font>
<font color="red"> 885.             defaults['coerce'] = self.to_python</font>
<font color="red"> 886.             if self.null:</font>
<font color="red"> 887.                 defaults['empty_value'] = None</font>
<font color="red"> 888.             if choices_form_class is not None:</font>
<font color="red"> 889.                 form_class = choices_form_class</font>
<font color="black"> 890.             else:</font>
<font color="red"> 891.                 form_class = forms.TypedChoiceField</font>
<font color="black"> 892.             # Many of the subclass-specific formfield arguments (min_value,</font>
<font color="black"> 893.             # max_value) don't apply for choice fields, so be sure to only pass</font>
<font color="black"> 894.             # the values that TypedChoiceField will understand.</font>
<font color="red"> 895.             for k in list(kwargs):</font>
<font color="red"> 896.                 if k not in ('coerce', 'empty_value', 'choices', 'required',</font>
<font color="black"> 897.                              'widget', 'label', 'initial', 'help_text',</font>
<font color="red"> 898.                              'error_messages', 'show_hidden_initial'):</font>
<font color="red"> 899.                     del kwargs[k]</font>
<font color="green"> 900.         defaults.update(kwargs)</font>
<font color="green"> 901.         if form_class is None:</font>
<font color="green"> 902.             form_class = forms.CharField</font>
<font color="green"> 903.         return form_class(**defaults)</font>
<font color="black"> 904. </font>
<font color="green"> 905.     def value_from_object(self, obj):</font>
<font color="black"> 906.         &quot;&quot;&quot;</font>
<font color="black"> 907.         Returns the value of this field in the given model instance.</font>
<font color="black"> 908.         &quot;&quot;&quot;</font>
<font color="green"> 909.         return getattr(obj, self.attname)</font>
<font color="black"> 910. </font>
<font color="black"> 911. </font>
<font color="green"> 912. class AutoField(Field):</font>
<font color="green"> 913.     description = _(&quot;Integer&quot;)</font>
<font color="black"> 914. </font>
<font color="green"> 915.     empty_strings_allowed = False</font>
<font color="green"> 916.     default_error_messages = {</font>
<font color="green"> 917.         'invalid': _(&quot;'%(value)s' value must be an integer.&quot;),</font>
<font color="black"> 918.     }</font>
<font color="black"> 919. </font>
<font color="green"> 920.     def __init__(self, *args, **kwargs):</font>
<font color="green"> 921.         kwargs['blank'] = True</font>
<font color="green"> 922.         super(AutoField, self).__init__(*args, **kwargs)</font>
<font color="black"> 923. </font>
<font color="green"> 924.     def check(self, **kwargs):</font>
<font color="red"> 925.         errors = super(AutoField, self).check(**kwargs)</font>
<font color="red"> 926.         errors.extend(self._check_primary_key())</font>
<font color="red"> 927.         return errors</font>
<font color="black"> 928. </font>
<font color="green"> 929.     def _check_primary_key(self):</font>
<font color="red"> 930.         if not self.primary_key:</font>
<font color="black"> 931.             return [</font>
<font color="red"> 932.                 checks.Error(</font>
<font color="red"> 933.                     'AutoFields must set primary_key=True.',</font>
<font color="red"> 934.                     hint=None,</font>
<font color="red"> 935.                     obj=self,</font>
<font color="red"> 936.                     id='fields.E100',</font>
<font color="black"> 937.                 ),</font>
<font color="black"> 938.             ]</font>
<font color="black"> 939.         else:</font>
<font color="red"> 940.             return []</font>
<font color="black"> 941. </font>
<font color="green"> 942.     def deconstruct(self):</font>
<font color="green"> 943.         name, path, args, kwargs = super(AutoField, self).deconstruct()</font>
<font color="green"> 944.         del kwargs['blank']</font>
<font color="green"> 945.         kwargs['primary_key'] = True</font>
<font color="green"> 946.         return name, path, args, kwargs</font>
<font color="black"> 947. </font>
<font color="green"> 948.     def get_internal_type(self):</font>
<font color="green"> 949.         return &quot;AutoField&quot;</font>
<font color="black"> 950. </font>
<font color="green"> 951.     def to_python(self, value):</font>
<font color="red"> 952.         if value is None:</font>
<font color="red"> 953.             return value</font>
<font color="red"> 954.         try:</font>
<font color="red"> 955.             return int(value)</font>
<font color="red"> 956.         except (TypeError, ValueError):</font>
<font color="red"> 957.             raise exceptions.ValidationError(</font>
<font color="red"> 958.                 self.error_messages['invalid'],</font>
<font color="red"> 959.                 code='invalid',</font>
<font color="red"> 960.                 params={'value': value},</font>
<font color="black"> 961.             )</font>
<font color="black"> 962. </font>
<font color="green"> 963.     def validate(self, value, model_instance):</font>
<font color="red"> 964.         pass</font>
<font color="black"> 965. </font>
<font color="green"> 966.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="green"> 967.         if not prepared:</font>
<font color="green"> 968.             value = self.get_prep_value(value)</font>
<font color="green"> 969.             value = connection.ops.validate_autopk_value(value)</font>
<font color="green"> 970.         return value</font>
<font color="black"> 971. </font>
<font color="green"> 972.     def get_prep_value(self, value):</font>
<font color="green"> 973.         value = super(AutoField, self).get_prep_value(value)</font>
<font color="green"> 974.         if value is None:</font>
<font color="red"> 975.             return None</font>
<font color="green"> 976.         return int(value)</font>
<font color="black"> 977. </font>
<font color="green"> 978.     def contribute_to_class(self, cls, name, **kwargs):</font>
<font color="green"> 979.         assert not cls._meta.has_auto_field, \</font>
<font color="red"> 980.             &quot;A model can't have more than one AutoField.&quot;</font>
<font color="green"> 981.         super(AutoField, self).contribute_to_class(cls, name, **kwargs)</font>
<font color="green"> 982.         cls._meta.has_auto_field = True</font>
<font color="green"> 983.         cls._meta.auto_field = self</font>
<font color="black"> 984. </font>
<font color="green"> 985.     def formfield(self, **kwargs):</font>
<font color="green"> 986.         return None</font>
<font color="black"> 987. </font>
<font color="black"> 988. </font>
<font color="green"> 989. class BooleanField(Field):</font>
<font color="green"> 990.     empty_strings_allowed = False</font>
<font color="green"> 991.     default_error_messages = {</font>
<font color="green"> 992.         'invalid': _(&quot;'%(value)s' value must be either True or False.&quot;),</font>
<font color="black"> 993.     }</font>
<font color="green"> 994.     description = _(&quot;Boolean (Either True or False)&quot;)</font>
<font color="black"> 995. </font>
<font color="green"> 996.     def __init__(self, *args, **kwargs):</font>
<font color="green"> 997.         kwargs['blank'] = True</font>
<font color="green"> 998.         super(BooleanField, self).__init__(*args, **kwargs)</font>
<font color="black"> 999. </font>
<font color="green">1000.     def check(self, **kwargs):</font>
<font color="red">1001.         errors = super(BooleanField, self).check(**kwargs)</font>
<font color="red">1002.         errors.extend(self._check_null(**kwargs))</font>
<font color="red">1003.         return errors</font>
<font color="black">1004. </font>
<font color="green">1005.     def _check_null(self, **kwargs):</font>
<font color="red">1006.         if getattr(self, 'null', False):</font>
<font color="black">1007.             return [</font>
<font color="red">1008.                 checks.Error(</font>
<font color="red">1009.                     'BooleanFields do not accept null values.',</font>
<font color="red">1010.                     hint='Use a NullBooleanField instead.',</font>
<font color="red">1011.                     obj=self,</font>
<font color="red">1012.                     id='fields.E110',</font>
<font color="black">1013.                 )</font>
<font color="black">1014.             ]</font>
<font color="black">1015.         else:</font>
<font color="red">1016.             return []</font>
<font color="black">1017. </font>
<font color="green">1018.     def deconstruct(self):</font>
<font color="green">1019.         name, path, args, kwargs = super(BooleanField, self).deconstruct()</font>
<font color="green">1020.         del kwargs['blank']</font>
<font color="green">1021.         return name, path, args, kwargs</font>
<font color="black">1022. </font>
<font color="green">1023.     def get_internal_type(self):</font>
<font color="green">1024.         return &quot;BooleanField&quot;</font>
<font color="black">1025. </font>
<font color="green">1026.     def to_python(self, value):</font>
<font color="red">1027.         if value in (True, False):</font>
<font color="black">1028.             # if value is 1 or 0 than it's equal to True or False, but we want</font>
<font color="black">1029.             # to return a true bool for semantic reasons.</font>
<font color="red">1030.             return bool(value)</font>
<font color="red">1031.         if value in ('t', 'True', '1'):</font>
<font color="red">1032.             return True</font>
<font color="red">1033.         if value in ('f', 'False', '0'):</font>
<font color="red">1034.             return False</font>
<font color="red">1035.         raise exceptions.ValidationError(</font>
<font color="red">1036.             self.error_messages['invalid'],</font>
<font color="red">1037.             code='invalid',</font>
<font color="red">1038.             params={'value': value},</font>
<font color="black">1039.         )</font>
<font color="black">1040. </font>
<font color="green">1041.     def get_prep_lookup(self, lookup_type, value):</font>
<font color="black">1042.         # Special-case handling for filters coming from a Web request (e.g. the</font>
<font color="black">1043.         # admin interface). Only works for scalar values (not lists). If you're</font>
<font color="black">1044.         # passing in a list, you might as well make things the right type when</font>
<font color="black">1045.         # constructing the list.</font>
<font color="red">1046.         if value in ('1', '0'):</font>
<font color="red">1047.             value = bool(int(value))</font>
<font color="red">1048.         return super(BooleanField, self).get_prep_lookup(lookup_type, value)</font>
<font color="black">1049. </font>
<font color="green">1050.     def get_prep_value(self, value):</font>
<font color="red">1051.         value = super(BooleanField, self).get_prep_value(value)</font>
<font color="red">1052.         if value is None:</font>
<font color="red">1053.             return None</font>
<font color="red">1054.         return bool(value)</font>
<font color="black">1055. </font>
<font color="green">1056.     def formfield(self, **kwargs):</font>
<font color="black">1057.         # Unlike most fields, BooleanField figures out include_blank from</font>
<font color="black">1058.         # self.null instead of self.blank.</font>
<font color="green">1059.         if self.choices:</font>
<font color="red">1060.             include_blank = not (self.has_default() or 'initial' in kwargs)</font>
<font color="red">1061.             defaults = {'choices': self.get_choices(include_blank=include_blank)}</font>
<font color="black">1062.         else:</font>
<font color="green">1063.             defaults = {'form_class': forms.BooleanField}</font>
<font color="green">1064.         defaults.update(kwargs)</font>
<font color="green">1065.         return super(BooleanField, self).formfield(**defaults)</font>
<font color="black">1066. </font>
<font color="black">1067. </font>
<font color="green">1068. class CharField(Field):</font>
<font color="green">1069.     description = _(&quot;String (up to %(max_length)s)&quot;)</font>
<font color="black">1070. </font>
<font color="green">1071.     def __init__(self, *args, **kwargs):</font>
<font color="green">1072.         super(CharField, self).__init__(*args, **kwargs)</font>
<font color="green">1073.         self.validators.append(validators.MaxLengthValidator(self.max_length))</font>
<font color="black">1074. </font>
<font color="green">1075.     def check(self, **kwargs):</font>
<font color="red">1076.         errors = super(CharField, self).check(**kwargs)</font>
<font color="red">1077.         errors.extend(self._check_max_length_attribute(**kwargs))</font>
<font color="red">1078.         return errors</font>
<font color="black">1079. </font>
<font color="green">1080.     def _check_max_length_attribute(self, **kwargs):</font>
<font color="red">1081.         if self.max_length is None:</font>
<font color="black">1082.             return [</font>
<font color="red">1083.                 checks.Error(</font>
<font color="red">1084.                     &quot;CharFields must define a 'max_length' attribute.&quot;,</font>
<font color="red">1085.                     hint=None,</font>
<font color="red">1086.                     obj=self,</font>
<font color="red">1087.                     id='fields.E120',</font>
<font color="black">1088.                 )</font>
<font color="black">1089.             ]</font>
<font color="red">1090.         elif not isinstance(self.max_length, six.integer_types) or self.max_length &lt;= 0:</font>
<font color="black">1091.             return [</font>
<font color="red">1092.                 checks.Error(</font>
<font color="red">1093.                     &quot;'max_length' must be a positive integer.&quot;,</font>
<font color="red">1094.                     hint=None,</font>
<font color="red">1095.                     obj=self,</font>
<font color="red">1096.                     id='fields.E121',</font>
<font color="black">1097.                 )</font>
<font color="black">1098.             ]</font>
<font color="black">1099.         else:</font>
<font color="red">1100.             return []</font>
<font color="black">1101. </font>
<font color="green">1102.     def get_internal_type(self):</font>
<font color="green">1103.         return &quot;CharField&quot;</font>
<font color="black">1104. </font>
<font color="green">1105.     def to_python(self, value):</font>
<font color="green">1106.         if isinstance(value, six.string_types) or value is None:</font>
<font color="green">1107.             return value</font>
<font color="red">1108.         return smart_text(value)</font>
<font color="black">1109. </font>
<font color="green">1110.     def get_prep_value(self, value):</font>
<font color="green">1111.         value = super(CharField, self).get_prep_value(value)</font>
<font color="green">1112.         return self.to_python(value)</font>
<font color="black">1113. </font>
<font color="green">1114.     def formfield(self, **kwargs):</font>
<font color="black">1115.         # Passing max_length to forms.CharField means that the value's length</font>
<font color="black">1116.         # will be validated twice. This is considered acceptable since we want</font>
<font color="black">1117.         # the value in the form field (to pass into widget for example).</font>
<font color="green">1118.         defaults = {'max_length': self.max_length}</font>
<font color="green">1119.         defaults.update(kwargs)</font>
<font color="green">1120.         return super(CharField, self).formfield(**defaults)</font>
<font color="black">1121. </font>
<font color="black">1122. </font>
<font color="green">1123. class CommaSeparatedIntegerField(CharField):</font>
<font color="green">1124.     default_validators = [validators.validate_comma_separated_integer_list]</font>
<font color="green">1125.     description = _(&quot;Comma-separated integers&quot;)</font>
<font color="black">1126. </font>
<font color="green">1127.     def formfield(self, **kwargs):</font>
<font color="red">1128.         defaults = {</font>
<font color="red">1129.             'error_messages': {</font>
<font color="red">1130.                 'invalid': _('Enter only digits separated by commas.'),</font>
<font color="black">1131.             }</font>
<font color="black">1132.         }</font>
<font color="red">1133.         defaults.update(kwargs)</font>
<font color="red">1134.         return super(CommaSeparatedIntegerField, self).formfield(**defaults)</font>
<font color="black">1135. </font>
<font color="black">1136. </font>
<font color="green">1137. class DateTimeCheckMixin(object):</font>
<font color="black">1138. </font>
<font color="green">1139.     def check(self, **kwargs):</font>
<font color="red">1140.         errors = super(DateTimeCheckMixin, self).check(**kwargs)</font>
<font color="red">1141.         errors.extend(self._check_mutually_exclusive_options())</font>
<font color="red">1142.         errors.extend(self._check_fix_default_value())</font>
<font color="red">1143.         return errors</font>
<font color="black">1144. </font>
<font color="green">1145.     def _check_mutually_exclusive_options(self):</font>
<font color="black">1146.         # auto_now, auto_now_add, and default are mutually exclusive</font>
<font color="black">1147.         # options. The use of more than one of these options together</font>
<font color="black">1148.         # will trigger an Error</font>
<font color="red">1149.         mutually_exclusive_options = [self.auto_now_add, self.auto_now,</font>
<font color="red">1150.                                       self.has_default()]</font>
<font color="red">1151.         enabled_options = [option not in (None, False)</font>
<font color="red">1152.                           for option in mutually_exclusive_options].count(True)</font>
<font color="red">1153.         if enabled_options &gt; 1:</font>
<font color="black">1154.             return [</font>
<font color="red">1155.                 checks.Error(</font>
<font color="red">1156.                     &quot;The options auto_now, auto_now_add, and default &quot;</font>
<font color="black">1157.                     &quot;are mutually exclusive. Only one of these options &quot;</font>
<font color="black">1158.                     &quot;may be present.&quot;,</font>
<font color="red">1159.                     hint=None,</font>
<font color="red">1160.                     obj=self,</font>
<font color="red">1161.                     id='fields.E160',</font>
<font color="black">1162.                 )</font>
<font color="black">1163.             ]</font>
<font color="black">1164.         else:</font>
<font color="red">1165.             return []</font>
<font color="black">1166. </font>
<font color="green">1167.     def _check_fix_default_value(self):</font>
<font color="red">1168.         return []</font>
<font color="black">1169. </font>
<font color="black">1170. </font>
<font color="green">1171. class DateField(DateTimeCheckMixin, Field):</font>
<font color="green">1172.     empty_strings_allowed = False</font>
<font color="green">1173.     default_error_messages = {</font>
<font color="green">1174.         'invalid': _(&quot;'%(value)s' value has an invalid date format. It must be &quot;</font>
<font color="black">1175.                      &quot;in YYYY-MM-DD format.&quot;),</font>
<font color="green">1176.         'invalid_date': _(&quot;'%(value)s' value has the correct format (YYYY-MM-DD) &quot;</font>
<font color="black">1177.                           &quot;but it is an invalid date.&quot;),</font>
<font color="black">1178.     }</font>
<font color="green">1179.     description = _(&quot;Date (without time)&quot;)</font>
<font color="black">1180. </font>
<font color="green">1181.     def __init__(self, verbose_name=None, name=None, auto_now=False,</font>
<font color="green">1182.                  auto_now_add=False, **kwargs):</font>
<font color="green">1183.         self.auto_now, self.auto_now_add = auto_now, auto_now_add</font>
<font color="green">1184.         if auto_now or auto_now_add:</font>
<font color="green">1185.             kwargs['editable'] = False</font>
<font color="green">1186.             kwargs['blank'] = True</font>
<font color="green">1187.         super(DateField, self).__init__(verbose_name, name, **kwargs)</font>
<font color="black">1188. </font>
<font color="green">1189.     def _check_fix_default_value(self):</font>
<font color="black">1190.         &quot;&quot;&quot;</font>
<font color="black">1191.         Adds a warning to the checks framework stating, that using an actual</font>
<font color="black">1192.         date or datetime value is probably wrong; it's only being evaluated on</font>
<font color="black">1193.         server start-up.</font>
<font color="black">1194. </font>
<font color="black">1195.         For details see ticket #21905</font>
<font color="black">1196.         &quot;&quot;&quot;</font>
<font color="red">1197.         if not self.has_default():</font>
<font color="red">1198.             return []</font>
<font color="black">1199. </font>
<font color="red">1200.         now = timezone.now()</font>
<font color="red">1201.         if not timezone.is_naive(now):</font>
<font color="red">1202.             now = timezone.make_naive(now, timezone.utc)</font>
<font color="red">1203.         value = self.default</font>
<font color="red">1204.         if isinstance(value, datetime.datetime):</font>
<font color="red">1205.             if not timezone.is_naive(value):</font>
<font color="red">1206.                 value = timezone.make_naive(value, timezone.utc)</font>
<font color="red">1207.             value = value.date()</font>
<font color="red">1208.         elif isinstance(value, datetime.date):</font>
<font color="black">1209.             # Nothing to do, as dates don't have tz information</font>
<font color="red">1210.             pass</font>
<font color="black">1211.         else:</font>
<font color="black">1212.             # No explicit date / datetime value -- no checks necessary</font>
<font color="red">1213.             return []</font>
<font color="red">1214.         offset = datetime.timedelta(days=1)</font>
<font color="red">1215.         lower = (now - offset).date()</font>
<font color="red">1216.         upper = (now + offset).date()</font>
<font color="red">1217.         if lower &lt;= value &lt;= upper:</font>
<font color="black">1218.             return [</font>
<font color="red">1219.                 checks.Warning(</font>
<font color="red">1220.                     'Fixed default value provided.',</font>
<font color="red">1221.                     hint='It seems you set a fixed date / time / datetime '</font>
<font color="black">1222.                          'value as default for this field. This may not be '</font>
<font color="black">1223.                          'what you want. If you want to have the current date '</font>
<font color="black">1224.                          'as default, use `django.utils.timezone.now`',</font>
<font color="red">1225.                     obj=self,</font>
<font color="red">1226.                     id='fields.W161',</font>
<font color="black">1227.                 )</font>
<font color="black">1228.             ]</font>
<font color="black">1229. </font>
<font color="red">1230.         return []</font>
<font color="black">1231. </font>
<font color="green">1232.     def deconstruct(self):</font>
<font color="green">1233.         name, path, args, kwargs = super(DateField, self).deconstruct()</font>
<font color="green">1234.         if self.auto_now:</font>
<font color="green">1235.             kwargs['auto_now'] = True</font>
<font color="green">1236.         if self.auto_now_add:</font>
<font color="red">1237.             kwargs['auto_now_add'] = True</font>
<font color="green">1238.         if self.auto_now or self.auto_now_add:</font>
<font color="green">1239.             del kwargs['editable']</font>
<font color="green">1240.             del kwargs['blank']</font>
<font color="green">1241.         return name, path, args, kwargs</font>
<font color="black">1242. </font>
<font color="green">1243.     def get_internal_type(self):</font>
<font color="red">1244.         return &quot;DateField&quot;</font>
<font color="black">1245. </font>
<font color="green">1246.     def to_python(self, value):</font>
<font color="red">1247.         if value is None:</font>
<font color="red">1248.             return value</font>
<font color="red">1249.         if isinstance(value, datetime.datetime):</font>
<font color="red">1250.             if settings.USE_TZ and timezone.is_aware(value):</font>
<font color="black">1251.                 # Convert aware datetimes to the default time zone</font>
<font color="black">1252.                 # before casting them to dates (#17742).</font>
<font color="red">1253.                 default_timezone = timezone.get_default_timezone()</font>
<font color="red">1254.                 value = timezone.make_naive(value, default_timezone)</font>
<font color="red">1255.             return value.date()</font>
<font color="red">1256.         if isinstance(value, datetime.date):</font>
<font color="red">1257.             return value</font>
<font color="black">1258. </font>
<font color="red">1259.         try:</font>
<font color="red">1260.             parsed = parse_date(value)</font>
<font color="red">1261.             if parsed is not None:</font>
<font color="red">1262.                 return parsed</font>
<font color="red">1263.         except ValueError:</font>
<font color="red">1264.             raise exceptions.ValidationError(</font>
<font color="red">1265.                 self.error_messages['invalid_date'],</font>
<font color="red">1266.                 code='invalid_date',</font>
<font color="red">1267.                 params={'value': value},</font>
<font color="black">1268.             )</font>
<font color="black">1269. </font>
<font color="red">1270.         raise exceptions.ValidationError(</font>
<font color="red">1271.             self.error_messages['invalid'],</font>
<font color="red">1272.             code='invalid',</font>
<font color="red">1273.             params={'value': value},</font>
<font color="black">1274.         )</font>
<font color="black">1275. </font>
<font color="green">1276.     def pre_save(self, model_instance, add):</font>
<font color="green">1277.         if self.auto_now or (self.auto_now_add and add):</font>
<font color="red">1278.             value = datetime.date.today()</font>
<font color="red">1279.             setattr(model_instance, self.attname, value)</font>
<font color="red">1280.             return value</font>
<font color="black">1281.         else:</font>
<font color="green">1282.             return super(DateField, self).pre_save(model_instance, add)</font>
<font color="black">1283. </font>
<font color="green">1284.     def contribute_to_class(self, cls, name, **kwargs):</font>
<font color="green">1285.         super(DateField, self).contribute_to_class(cls, name, **kwargs)</font>
<font color="green">1286.         if not self.null:</font>
<font color="green">1287.             setattr(cls, 'get_next_by_%s' % self.name,</font>
<font color="green">1288.                 curry(cls._get_next_or_previous_by_FIELD, field=self,</font>
<font color="green">1289.                       is_next=True))</font>
<font color="green">1290.             setattr(cls, 'get_previous_by_%s' % self.name,</font>
<font color="green">1291.                 curry(cls._get_next_or_previous_by_FIELD, field=self,</font>
<font color="green">1292.                       is_next=False))</font>
<font color="black">1293. </font>
<font color="green">1294.     def get_prep_value(self, value):</font>
<font color="green">1295.         value = super(DateField, self).get_prep_value(value)</font>
<font color="green">1296.         return self.to_python(value)</font>
<font color="black">1297. </font>
<font color="green">1298.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="black">1299.         # Casts dates into the format expected by the backend</font>
<font color="red">1300.         if not prepared:</font>
<font color="red">1301.             value = self.get_prep_value(value)</font>
<font color="red">1302.         return connection.ops.adapt_datefield_value(value)</font>
<font color="black">1303. </font>
<font color="green">1304.     def value_to_string(self, obj):</font>
<font color="red">1305.         val = self.value_from_object(obj)</font>
<font color="red">1306.         return '' if val is None else val.isoformat()</font>
<font color="black">1307. </font>
<font color="green">1308.     def formfield(self, **kwargs):</font>
<font color="green">1309.         defaults = {'form_class': forms.DateField}</font>
<font color="green">1310.         defaults.update(kwargs)</font>
<font color="green">1311.         return super(DateField, self).formfield(**defaults)</font>
<font color="black">1312. </font>
<font color="black">1313. </font>
<font color="green">1314. class DateTimeField(DateField):</font>
<font color="green">1315.     empty_strings_allowed = False</font>
<font color="green">1316.     default_error_messages = {</font>
<font color="green">1317.         'invalid': _(&quot;'%(value)s' value has an invalid format. It must be in &quot;</font>
<font color="black">1318.                      &quot;YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format.&quot;),</font>
<font color="green">1319.         'invalid_date': _(&quot;'%(value)s' value has the correct format &quot;</font>
<font color="black">1320.                           &quot;(YYYY-MM-DD) but it is an invalid date.&quot;),</font>
<font color="green">1321.         'invalid_datetime': _(&quot;'%(value)s' value has the correct format &quot;</font>
<font color="black">1322.                               &quot;(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) &quot;</font>
<font color="black">1323.                               &quot;but it is an invalid date/time.&quot;),</font>
<font color="black">1324.     }</font>
<font color="green">1325.     description = _(&quot;Date (with time)&quot;)</font>
<font color="black">1326. </font>
<font color="black">1327.     # __init__ is inherited from DateField</font>
<font color="black">1328. </font>
<font color="green">1329.     def _check_fix_default_value(self):</font>
<font color="black">1330.         &quot;&quot;&quot;</font>
<font color="black">1331.         Adds a warning to the checks framework stating, that using an actual</font>
<font color="black">1332.         date or datetime value is probably wrong; it's only being evaluated on</font>
<font color="black">1333.         server start-up.</font>
<font color="black">1334. </font>
<font color="black">1335.         For details see ticket #21905</font>
<font color="black">1336.         &quot;&quot;&quot;</font>
<font color="red">1337.         if not self.has_default():</font>
<font color="red">1338.             return []</font>
<font color="black">1339. </font>
<font color="red">1340.         now = timezone.now()</font>
<font color="red">1341.         if not timezone.is_naive(now):</font>
<font color="red">1342.             now = timezone.make_naive(now, timezone.utc)</font>
<font color="red">1343.         value = self.default</font>
<font color="red">1344.         if isinstance(value, datetime.datetime):</font>
<font color="red">1345.             second_offset = datetime.timedelta(seconds=10)</font>
<font color="red">1346.             lower = now - second_offset</font>
<font color="red">1347.             upper = now + second_offset</font>
<font color="red">1348.             if timezone.is_aware(value):</font>
<font color="red">1349.                 value = timezone.make_naive(value, timezone.utc)</font>
<font color="red">1350.         elif isinstance(value, datetime.date):</font>
<font color="red">1351.             second_offset = datetime.timedelta(seconds=10)</font>
<font color="red">1352.             lower = now - second_offset</font>
<font color="red">1353.             lower = datetime.datetime(lower.year, lower.month, lower.day)</font>
<font color="red">1354.             upper = now + second_offset</font>
<font color="red">1355.             upper = datetime.datetime(upper.year, upper.month, upper.day)</font>
<font color="red">1356.             value = datetime.datetime(value.year, value.month, value.day)</font>
<font color="black">1357.         else:</font>
<font color="black">1358.             # No explicit date / datetime value -- no checks necessary</font>
<font color="red">1359.             return []</font>
<font color="red">1360.         if lower &lt;= value &lt;= upper:</font>
<font color="black">1361.             return [</font>
<font color="red">1362.                 checks.Warning(</font>
<font color="red">1363.                     'Fixed default value provided.',</font>
<font color="red">1364.                     hint='It seems you set a fixed date / time / datetime '</font>
<font color="black">1365.                          'value as default for this field. This may not be '</font>
<font color="black">1366.                          'what you want. If you want to have the current date '</font>
<font color="black">1367.                          'as default, use `django.utils.timezone.now`',</font>
<font color="red">1368.                     obj=self,</font>
<font color="red">1369.                     id='fields.W161',</font>
<font color="black">1370.                 )</font>
<font color="black">1371.             ]</font>
<font color="black">1372. </font>
<font color="red">1373.         return []</font>
<font color="black">1374. </font>
<font color="green">1375.     def get_internal_type(self):</font>
<font color="green">1376.         return &quot;DateTimeField&quot;</font>
<font color="black">1377. </font>
<font color="green">1378.     def to_python(self, value):</font>
<font color="green">1379.         if value is None:</font>
<font color="red">1380.             return value</font>
<font color="green">1381.         if isinstance(value, datetime.datetime):</font>
<font color="green">1382.             return value</font>
<font color="red">1383.         if isinstance(value, datetime.date):</font>
<font color="red">1384.             value = datetime.datetime(value.year, value.month, value.day)</font>
<font color="red">1385.             if settings.USE_TZ:</font>
<font color="black">1386.                 # For backwards compatibility, interpret naive datetimes in</font>
<font color="black">1387.                 # local time. This won't work during DST change, but we can't</font>
<font color="black">1388.                 # do much about it, so we let the exceptions percolate up the</font>
<font color="black">1389.                 # call stack.</font>
<font color="red">1390.                 warnings.warn(&quot;DateTimeField %s.%s received a naive datetime &quot;</font>
<font color="black">1391.                               &quot;(%s) while time zone support is active.&quot; %</font>
<font color="red">1392.                               (self.model.__name__, self.name, value),</font>
<font color="red">1393.                               RuntimeWarning)</font>
<font color="red">1394.                 default_timezone = timezone.get_default_timezone()</font>
<font color="red">1395.                 value = timezone.make_aware(value, default_timezone)</font>
<font color="red">1396.             return value</font>
<font color="black">1397. </font>
<font color="red">1398.         try:</font>
<font color="red">1399.             parsed = parse_datetime(value)</font>
<font color="red">1400.             if parsed is not None:</font>
<font color="red">1401.                 return parsed</font>
<font color="red">1402.         except ValueError:</font>
<font color="red">1403.             raise exceptions.ValidationError(</font>
<font color="red">1404.                 self.error_messages['invalid_datetime'],</font>
<font color="red">1405.                 code='invalid_datetime',</font>
<font color="red">1406.                 params={'value': value},</font>
<font color="black">1407.             )</font>
<font color="black">1408. </font>
<font color="red">1409.         try:</font>
<font color="red">1410.             parsed = parse_date(value)</font>
<font color="red">1411.             if parsed is not None:</font>
<font color="red">1412.                 return datetime.datetime(parsed.year, parsed.month, parsed.day)</font>
<font color="red">1413.         except ValueError:</font>
<font color="red">1414.             raise exceptions.ValidationError(</font>
<font color="red">1415.                 self.error_messages['invalid_date'],</font>
<font color="red">1416.                 code='invalid_date',</font>
<font color="red">1417.                 params={'value': value},</font>
<font color="black">1418.             )</font>
<font color="black">1419. </font>
<font color="red">1420.         raise exceptions.ValidationError(</font>
<font color="red">1421.             self.error_messages['invalid'],</font>
<font color="red">1422.             code='invalid',</font>
<font color="red">1423.             params={'value': value},</font>
<font color="black">1424.         )</font>
<font color="black">1425. </font>
<font color="green">1426.     def pre_save(self, model_instance, add):</font>
<font color="green">1427.         if self.auto_now or (self.auto_now_add and add):</font>
<font color="red">1428.             value = timezone.now()</font>
<font color="red">1429.             setattr(model_instance, self.attname, value)</font>
<font color="red">1430.             return value</font>
<font color="black">1431.         else:</font>
<font color="green">1432.             return super(DateTimeField, self).pre_save(model_instance, add)</font>
<font color="black">1433. </font>
<font color="black">1434.     # contribute_to_class is inherited from DateField, it registers</font>
<font color="black">1435.     # get_next_by_FOO and get_prev_by_FOO</font>
<font color="black">1436. </font>
<font color="black">1437.     # get_prep_lookup is inherited from DateField</font>
<font color="black">1438. </font>
<font color="green">1439.     def get_prep_value(self, value):</font>
<font color="green">1440.         value = super(DateTimeField, self).get_prep_value(value)</font>
<font color="green">1441.         value = self.to_python(value)</font>
<font color="green">1442.         if value is not None and settings.USE_TZ and timezone.is_naive(value):</font>
<font color="black">1443.             # For backwards compatibility, interpret naive datetimes in local</font>
<font color="black">1444.             # time. This won't work during DST change, but we can't do much</font>
<font color="black">1445.             # about it, so we let the exceptions percolate up the call stack.</font>
<font color="red">1446.             try:</font>
<font color="red">1447.                 name = '%s.%s' % (self.model.__name__, self.name)</font>
<font color="red">1448.             except AttributeError:</font>
<font color="red">1449.                 name = '(unbound)'</font>
<font color="red">1450.             warnings.warn(&quot;DateTimeField %s received a naive datetime (%s)&quot;</font>
<font color="black">1451.                           &quot; while time zone support is active.&quot; %</font>
<font color="red">1452.                           (name, value),</font>
<font color="red">1453.                           RuntimeWarning)</font>
<font color="red">1454.             default_timezone = timezone.get_default_timezone()</font>
<font color="red">1455.             value = timezone.make_aware(value, default_timezone)</font>
<font color="green">1456.         return value</font>
<font color="black">1457. </font>
<font color="green">1458.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="black">1459.         # Casts datetimes into the format expected by the backend</font>
<font color="green">1460.         if not prepared:</font>
<font color="green">1461.             value = self.get_prep_value(value)</font>
<font color="green">1462.         return connection.ops.adapt_datetimefield_value(value)</font>
<font color="black">1463. </font>
<font color="green">1464.     def value_to_string(self, obj):</font>
<font color="red">1465.         val = self.value_from_object(obj)</font>
<font color="red">1466.         return '' if val is None else val.isoformat()</font>
<font color="black">1467. </font>
<font color="green">1468.     def formfield(self, **kwargs):</font>
<font color="green">1469.         defaults = {'form_class': forms.DateTimeField}</font>
<font color="green">1470.         defaults.update(kwargs)</font>
<font color="green">1471.         return super(DateTimeField, self).formfield(**defaults)</font>
<font color="black">1472. </font>
<font color="black">1473. </font>
<font color="green">1474. class DecimalField(Field):</font>
<font color="green">1475.     empty_strings_allowed = False</font>
<font color="green">1476.     default_error_messages = {</font>
<font color="green">1477.         'invalid': _(&quot;'%(value)s' value must be a decimal number.&quot;),</font>
<font color="black">1478.     }</font>
<font color="green">1479.     description = _(&quot;Decimal number&quot;)</font>
<font color="black">1480. </font>
<font color="green">1481.     def __init__(self, verbose_name=None, name=None, max_digits=None,</font>
<font color="green">1482.                  decimal_places=None, **kwargs):</font>
<font color="red">1483.         self.max_digits, self.decimal_places = max_digits, decimal_places</font>
<font color="red">1484.         super(DecimalField, self).__init__(verbose_name, name, **kwargs)</font>
<font color="black">1485. </font>
<font color="green">1486.     def check(self, **kwargs):</font>
<font color="red">1487.         errors = super(DecimalField, self).check(**kwargs)</font>
<font color="black">1488. </font>
<font color="red">1489.         digits_errors = self._check_decimal_places()</font>
<font color="red">1490.         digits_errors.extend(self._check_max_digits())</font>
<font color="red">1491.         if not digits_errors:</font>
<font color="red">1492.             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))</font>
<font color="black">1493.         else:</font>
<font color="red">1494.             errors.extend(digits_errors)</font>
<font color="red">1495.         return errors</font>
<font color="black">1496. </font>
<font color="green">1497.     def _check_decimal_places(self):</font>
<font color="red">1498.         try:</font>
<font color="red">1499.             decimal_places = int(self.decimal_places)</font>
<font color="red">1500.             if decimal_places &lt; 0:</font>
<font color="red">1501.                 raise ValueError()</font>
<font color="red">1502.         except TypeError:</font>
<font color="black">1503.             return [</font>
<font color="red">1504.                 checks.Error(</font>
<font color="red">1505.                     &quot;DecimalFields must define a 'decimal_places' attribute.&quot;,</font>
<font color="red">1506.                     hint=None,</font>
<font color="red">1507.                     obj=self,</font>
<font color="red">1508.                     id='fields.E130',</font>
<font color="black">1509.                 )</font>
<font color="black">1510.             ]</font>
<font color="red">1511.         except ValueError:</font>
<font color="black">1512.             return [</font>
<font color="red">1513.                 checks.Error(</font>
<font color="red">1514.                     &quot;'decimal_places' must be a non-negative integer.&quot;,</font>
<font color="red">1515.                     hint=None,</font>
<font color="red">1516.                     obj=self,</font>
<font color="red">1517.                     id='fields.E131',</font>
<font color="black">1518.                 )</font>
<font color="black">1519.             ]</font>
<font color="black">1520.         else:</font>
<font color="red">1521.             return []</font>
<font color="black">1522. </font>
<font color="green">1523.     def _check_max_digits(self):</font>
<font color="red">1524.         try:</font>
<font color="red">1525.             max_digits = int(self.max_digits)</font>
<font color="red">1526.             if max_digits &lt;= 0:</font>
<font color="red">1527.                 raise ValueError()</font>
<font color="red">1528.         except TypeError:</font>
<font color="black">1529.             return [</font>
<font color="red">1530.                 checks.Error(</font>
<font color="red">1531.                     &quot;DecimalFields must define a 'max_digits' attribute.&quot;,</font>
<font color="red">1532.                     hint=None,</font>
<font color="red">1533.                     obj=self,</font>
<font color="red">1534.                     id='fields.E132',</font>
<font color="black">1535.                 )</font>
<font color="black">1536.             ]</font>
<font color="red">1537.         except ValueError:</font>
<font color="black">1538.             return [</font>
<font color="red">1539.                 checks.Error(</font>
<font color="red">1540.                     &quot;'max_digits' must be a positive integer.&quot;,</font>
<font color="red">1541.                     hint=None,</font>
<font color="red">1542.                     obj=self,</font>
<font color="red">1543.                     id='fields.E133',</font>
<font color="black">1544.                 )</font>
<font color="black">1545.             ]</font>
<font color="black">1546.         else:</font>
<font color="red">1547.             return []</font>
<font color="black">1548. </font>
<font color="green">1549.     def _check_decimal_places_and_max_digits(self, **kwargs):</font>
<font color="red">1550.         if int(self.decimal_places) &gt; int(self.max_digits):</font>
<font color="black">1551.             return [</font>
<font color="red">1552.                 checks.Error(</font>
<font color="red">1553.                     &quot;'max_digits' must be greater or equal to 'decimal_places'.&quot;,</font>
<font color="red">1554.                     hint=None,</font>
<font color="red">1555.                     obj=self,</font>
<font color="red">1556.                     id='fields.E134',</font>
<font color="black">1557.                 )</font>
<font color="black">1558.             ]</font>
<font color="red">1559.         return []</font>
<font color="black">1560. </font>
<font color="green">1561.     @cached_property</font>
<font color="black">1562.     def validators(self):</font>
<font color="red">1563.         return super(DecimalField, self).validators + [</font>
<font color="red">1564.             validators.DecimalValidator(self.max_digits, self.decimal_places)</font>
<font color="black">1565.         ]</font>
<font color="black">1566. </font>
<font color="green">1567.     def deconstruct(self):</font>
<font color="red">1568.         name, path, args, kwargs = super(DecimalField, self).deconstruct()</font>
<font color="red">1569.         if self.max_digits is not None:</font>
<font color="red">1570.             kwargs['max_digits'] = self.max_digits</font>
<font color="red">1571.         if self.decimal_places is not None:</font>
<font color="red">1572.             kwargs['decimal_places'] = self.decimal_places</font>
<font color="red">1573.         return name, path, args, kwargs</font>
<font color="black">1574. </font>
<font color="green">1575.     def get_internal_type(self):</font>
<font color="red">1576.         return &quot;DecimalField&quot;</font>
<font color="black">1577. </font>
<font color="green">1578.     def to_python(self, value):</font>
<font color="red">1579.         if value is None:</font>
<font color="red">1580.             return value</font>
<font color="red">1581.         try:</font>
<font color="red">1582.             return decimal.Decimal(value)</font>
<font color="red">1583.         except decimal.InvalidOperation:</font>
<font color="red">1584.             raise exceptions.ValidationError(</font>
<font color="red">1585.                 self.error_messages['invalid'],</font>
<font color="red">1586.                 code='invalid',</font>
<font color="red">1587.                 params={'value': value},</font>
<font color="black">1588.             )</font>
<font color="black">1589. </font>
<font color="green">1590.     def _format(self, value):</font>
<font color="red">1591.         if isinstance(value, six.string_types):</font>
<font color="red">1592.             return value</font>
<font color="black">1593.         else:</font>
<font color="red">1594.             return self.format_number(value)</font>
<font color="black">1595. </font>
<font color="green">1596.     def format_number(self, value):</font>
<font color="black">1597.         &quot;&quot;&quot;</font>
<font color="black">1598.         Formats a number into a string with the requisite number of digits and</font>
<font color="black">1599.         decimal places.</font>
<font color="black">1600.         &quot;&quot;&quot;</font>
<font color="black">1601.         # Method moved to django.db.backends.utils.</font>
<font color="black">1602.         #</font>
<font color="black">1603.         # It is preserved because it is used by the oracle backend</font>
<font color="black">1604.         # (django.db.backends.oracle.query), and also for</font>
<font color="black">1605.         # backwards-compatibility with any external code which may have used</font>
<font color="black">1606.         # this method.</font>
<font color="red">1607.         from django.db.backends import utils</font>
<font color="red">1608.         return utils.format_number(value, self.max_digits, self.decimal_places)</font>
<font color="black">1609. </font>
<font color="green">1610.     def get_db_prep_save(self, value, connection):</font>
<font color="red">1611.         return connection.ops.adapt_decimalfield_value(self.to_python(value),</font>
<font color="red">1612.                 self.max_digits, self.decimal_places)</font>
<font color="black">1613. </font>
<font color="green">1614.     def get_prep_value(self, value):</font>
<font color="red">1615.         value = super(DecimalField, self).get_prep_value(value)</font>
<font color="red">1616.         return self.to_python(value)</font>
<font color="black">1617. </font>
<font color="green">1618.     def formfield(self, **kwargs):</font>
<font color="red">1619.         defaults = {</font>
<font color="red">1620.             'max_digits': self.max_digits,</font>
<font color="red">1621.             'decimal_places': self.decimal_places,</font>
<font color="red">1622.             'form_class': forms.DecimalField,</font>
<font color="black">1623.         }</font>
<font color="red">1624.         defaults.update(kwargs)</font>
<font color="red">1625.         return super(DecimalField, self).formfield(**defaults)</font>
<font color="black">1626. </font>
<font color="black">1627. </font>
<font color="green">1628. class DurationField(Field):</font>
<font color="black">1629.     &quot;&quot;&quot;Stores timedelta objects.</font>
<font color="black">1630. </font>
<font color="black">1631.     Uses interval on postgres, INVERAL DAY TO SECOND on Oracle, and bigint of</font>
<font color="black">1632.     microseconds on other databases.</font>
<font color="green">1633.     &quot;&quot;&quot;</font>
<font color="green">1634.     empty_strings_allowed = False</font>
<font color="green">1635.     default_error_messages = {</font>
<font color="green">1636.         'invalid': _(&quot;'%(value)s' value has an invalid format. It must be in &quot;</font>
<font color="black">1637.                      &quot;[DD] [HH:[MM:]]ss[.uuuuuu] format.&quot;)</font>
<font color="black">1638.     }</font>
<font color="green">1639.     description = _(&quot;Duration&quot;)</font>
<font color="black">1640. </font>
<font color="green">1641.     def get_internal_type(self):</font>
<font color="red">1642.         return &quot;DurationField&quot;</font>
<font color="black">1643. </font>
<font color="green">1644.     def to_python(self, value):</font>
<font color="red">1645.         if value is None:</font>
<font color="red">1646.             return value</font>
<font color="red">1647.         if isinstance(value, datetime.timedelta):</font>
<font color="red">1648.             return value</font>
<font color="red">1649.         try:</font>
<font color="red">1650.             parsed = parse_duration(value)</font>
<font color="red">1651.         except ValueError:</font>
<font color="red">1652.             pass</font>
<font color="black">1653.         else:</font>
<font color="red">1654.             if parsed is not None:</font>
<font color="red">1655.                 return parsed</font>
<font color="black">1656. </font>
<font color="red">1657.         raise exceptions.ValidationError(</font>
<font color="red">1658.             self.error_messages['invalid'],</font>
<font color="red">1659.             code='invalid',</font>
<font color="red">1660.             params={'value': value},</font>
<font color="black">1661.         )</font>
<font color="black">1662. </font>
<font color="green">1663.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="red">1664.         if connection.features.has_native_duration_field:</font>
<font color="red">1665.             return value</font>
<font color="red">1666.         if value is None:</font>
<font color="red">1667.             return None</font>
<font color="red">1668.         return value.total_seconds() * 1000000</font>
<font color="black">1669. </font>
<font color="green">1670.     def get_db_converters(self, connection):</font>
<font color="red">1671.         converters = []</font>
<font color="red">1672.         if not connection.features.has_native_duration_field:</font>
<font color="red">1673.             converters.append(connection.ops.convert_durationfield_value)</font>
<font color="red">1674.         return converters + super(DurationField, self).get_db_converters(connection)</font>
<font color="black">1675. </font>
<font color="green">1676.     def value_to_string(self, obj):</font>
<font color="red">1677.         val = self.value_from_object(obj)</font>
<font color="red">1678.         return '' if val is None else duration_string(val)</font>
<font color="black">1679. </font>
<font color="green">1680.     def formfield(self, **kwargs):</font>
<font color="red">1681.         defaults = {</font>
<font color="red">1682.             'form_class': forms.DurationField,</font>
<font color="black">1683.         }</font>
<font color="red">1684.         defaults.update(kwargs)</font>
<font color="red">1685.         return super(DurationField, self).formfield(**defaults)</font>
<font color="black">1686. </font>
<font color="black">1687. </font>
<font color="green">1688. class EmailField(CharField):</font>
<font color="green">1689.     default_validators = [validators.validate_email]</font>
<font color="green">1690.     description = _(&quot;Email address&quot;)</font>
<font color="black">1691. </font>
<font color="green">1692.     def __init__(self, *args, **kwargs):</font>
<font color="black">1693.         # max_length=254 to be compliant with RFCs 3696 and 5321</font>
<font color="green">1694.         kwargs['max_length'] = kwargs.get('max_length', 254)</font>
<font color="green">1695.         super(EmailField, self).__init__(*args, **kwargs)</font>
<font color="black">1696. </font>
<font color="green">1697.     def deconstruct(self):</font>
<font color="green">1698.         name, path, args, kwargs = super(EmailField, self).deconstruct()</font>
<font color="black">1699.         # We do not exclude max_length if it matches default as we want to change</font>
<font color="black">1700.         # the default in future.</font>
<font color="green">1701.         return name, path, args, kwargs</font>
<font color="black">1702. </font>
<font color="green">1703.     def formfield(self, **kwargs):</font>
<font color="black">1704.         # As with CharField, this will cause email validation to be performed</font>
<font color="black">1705.         # twice.</font>
<font color="green">1706.         defaults = {</font>
<font color="green">1707.             'form_class': forms.EmailField,</font>
<font color="black">1708.         }</font>
<font color="green">1709.         defaults.update(kwargs)</font>
<font color="green">1710.         return super(EmailField, self).formfield(**defaults)</font>
<font color="black">1711. </font>
<font color="black">1712. </font>
<font color="green">1713. class FilePathField(Field):</font>
<font color="green">1714.     description = _(&quot;File path&quot;)</font>
<font color="black">1715. </font>
<font color="green">1716.     def __init__(self, verbose_name=None, name=None, path='', match=None,</font>
<font color="green">1717.                  recursive=False, allow_files=True, allow_folders=False, **kwargs):</font>
<font color="red">1718.         self.path, self.match, self.recursive = path, match, recursive</font>
<font color="red">1719.         self.allow_files, self.allow_folders = allow_files, allow_folders</font>
<font color="red">1720.         kwargs['max_length'] = kwargs.get('max_length', 100)</font>
<font color="red">1721.         super(FilePathField, self).__init__(verbose_name, name, **kwargs)</font>
<font color="black">1722. </font>
<font color="green">1723.     def check(self, **kwargs):</font>
<font color="red">1724.         errors = super(FilePathField, self).check(**kwargs)</font>
<font color="red">1725.         errors.extend(self._check_allowing_files_or_folders(**kwargs))</font>
<font color="red">1726.         return errors</font>
<font color="black">1727. </font>
<font color="green">1728.     def _check_allowing_files_or_folders(self, **kwargs):</font>
<font color="red">1729.         if not self.allow_files and not self.allow_folders:</font>
<font color="black">1730.             return [</font>
<font color="red">1731.                 checks.Error(</font>
<font color="red">1732.                     &quot;FilePathFields must have either 'allow_files' or 'allow_folders' set to True.&quot;,</font>
<font color="red">1733.                     hint=None,</font>
<font color="red">1734.                     obj=self,</font>
<font color="red">1735.                     id='fields.E140',</font>
<font color="black">1736.                 )</font>
<font color="black">1737.             ]</font>
<font color="red">1738.         return []</font>
<font color="black">1739. </font>
<font color="green">1740.     def deconstruct(self):</font>
<font color="red">1741.         name, path, args, kwargs = super(FilePathField, self).deconstruct()</font>
<font color="red">1742.         if self.path != '':</font>
<font color="red">1743.             kwargs['path'] = self.path</font>
<font color="red">1744.         if self.match is not None:</font>
<font color="red">1745.             kwargs['match'] = self.match</font>
<font color="red">1746.         if self.recursive is not False:</font>
<font color="red">1747.             kwargs['recursive'] = self.recursive</font>
<font color="red">1748.         if self.allow_files is not True:</font>
<font color="red">1749.             kwargs['allow_files'] = self.allow_files</font>
<font color="red">1750.         if self.allow_folders is not False:</font>
<font color="red">1751.             kwargs['allow_folders'] = self.allow_folders</font>
<font color="red">1752.         if kwargs.get(&quot;max_length&quot;) == 100:</font>
<font color="red">1753.             del kwargs[&quot;max_length&quot;]</font>
<font color="red">1754.         return name, path, args, kwargs</font>
<font color="black">1755. </font>
<font color="green">1756.     def get_prep_value(self, value):</font>
<font color="red">1757.         value = super(FilePathField, self).get_prep_value(value)</font>
<font color="red">1758.         if value is None:</font>
<font color="red">1759.             return None</font>
<font color="red">1760.         return six.text_type(value)</font>
<font color="black">1761. </font>
<font color="green">1762.     def formfield(self, **kwargs):</font>
<font color="red">1763.         defaults = {</font>
<font color="red">1764.             'path': self.path,</font>
<font color="red">1765.             'match': self.match,</font>
<font color="red">1766.             'recursive': self.recursive,</font>
<font color="red">1767.             'form_class': forms.FilePathField,</font>
<font color="red">1768.             'allow_files': self.allow_files,</font>
<font color="red">1769.             'allow_folders': self.allow_folders,</font>
<font color="black">1770.         }</font>
<font color="red">1771.         defaults.update(kwargs)</font>
<font color="red">1772.         return super(FilePathField, self).formfield(**defaults)</font>
<font color="black">1773. </font>
<font color="green">1774.     def get_internal_type(self):</font>
<font color="red">1775.         return &quot;FilePathField&quot;</font>
<font color="black">1776. </font>
<font color="black">1777. </font>
<font color="green">1778. class FloatField(Field):</font>
<font color="green">1779.     empty_strings_allowed = False</font>
<font color="green">1780.     default_error_messages = {</font>
<font color="green">1781.         'invalid': _(&quot;'%(value)s' value must be a float.&quot;),</font>
<font color="black">1782.     }</font>
<font color="green">1783.     description = _(&quot;Floating point number&quot;)</font>
<font color="black">1784. </font>
<font color="green">1785.     def get_prep_value(self, value):</font>
<font color="red">1786.         value = super(FloatField, self).get_prep_value(value)</font>
<font color="red">1787.         if value is None:</font>
<font color="red">1788.             return None</font>
<font color="red">1789.         return float(value)</font>
<font color="black">1790. </font>
<font color="green">1791.     def get_internal_type(self):</font>
<font color="red">1792.         return &quot;FloatField&quot;</font>
<font color="black">1793. </font>
<font color="green">1794.     def to_python(self, value):</font>
<font color="red">1795.         if value is None:</font>
<font color="red">1796.             return value</font>
<font color="red">1797.         try:</font>
<font color="red">1798.             return float(value)</font>
<font color="red">1799.         except (TypeError, ValueError):</font>
<font color="red">1800.             raise exceptions.ValidationError(</font>
<font color="red">1801.                 self.error_messages['invalid'],</font>
<font color="red">1802.                 code='invalid',</font>
<font color="red">1803.                 params={'value': value},</font>
<font color="black">1804.             )</font>
<font color="black">1805. </font>
<font color="green">1806.     def formfield(self, **kwargs):</font>
<font color="red">1807.         defaults = {'form_class': forms.FloatField}</font>
<font color="red">1808.         defaults.update(kwargs)</font>
<font color="red">1809.         return super(FloatField, self).formfield(**defaults)</font>
<font color="black">1810. </font>
<font color="black">1811. </font>
<font color="green">1812. class IntegerField(Field):</font>
<font color="green">1813.     empty_strings_allowed = False</font>
<font color="green">1814.     default_error_messages = {</font>
<font color="green">1815.         'invalid': _(&quot;'%(value)s' value must be an integer.&quot;),</font>
<font color="black">1816.     }</font>
<font color="green">1817.     description = _(&quot;Integer&quot;)</font>
<font color="black">1818. </font>
<font color="green">1819.     def check(self, **kwargs):</font>
<font color="red">1820.         errors = super(IntegerField, self).check(**kwargs)</font>
<font color="red">1821.         errors.extend(self._check_max_length_warning())</font>
<font color="red">1822.         return errors</font>
<font color="black">1823. </font>
<font color="green">1824.     def _check_max_length_warning(self):</font>
<font color="red">1825.         if self.max_length is not None:</font>
<font color="black">1826.             return [</font>
<font color="red">1827.                 checks.Warning(</font>
<font color="red">1828.                     &quot;'max_length' is ignored when used with IntegerField&quot;,</font>
<font color="red">1829.                     hint=&quot;Remove 'max_length' from field&quot;,</font>
<font color="red">1830.                     obj=self,</font>
<font color="red">1831.                     id='fields.W122',</font>
<font color="black">1832.                 )</font>
<font color="black">1833.             ]</font>
<font color="red">1834.         return []</font>
<font color="black">1835. </font>
<font color="green">1836.     @cached_property</font>
<font color="black">1837.     def validators(self):</font>
<font color="black">1838.         # These validators can't be added at field initialization time since</font>
<font color="black">1839.         # they're based on values retrieved from `connection`.</font>
<font color="red">1840.         range_validators = []</font>
<font color="red">1841.         internal_type = self.get_internal_type()</font>
<font color="red">1842.         min_value, max_value = connection.ops.integer_field_range(internal_type)</font>
<font color="red">1843.         if min_value is not None:</font>
<font color="red">1844.             range_validators.append(validators.MinValueValidator(min_value))</font>
<font color="red">1845.         if max_value is not None:</font>
<font color="red">1846.             range_validators.append(validators.MaxValueValidator(max_value))</font>
<font color="red">1847.         return super(IntegerField, self).validators + range_validators</font>
<font color="black">1848. </font>
<font color="green">1849.     def get_prep_value(self, value):</font>
<font color="red">1850.         value = super(IntegerField, self).get_prep_value(value)</font>
<font color="red">1851.         if value is None:</font>
<font color="red">1852.             return None</font>
<font color="red">1853.         return int(value)</font>
<font color="black">1854. </font>
<font color="green">1855.     def get_prep_lookup(self, lookup_type, value):</font>
<font color="red">1856.         if ((lookup_type == 'gte' or lookup_type == 'lt')</font>
<font color="red">1857.                 and isinstance(value, float)):</font>
<font color="red">1858.             value = math.ceil(value)</font>
<font color="red">1859.         return super(IntegerField, self).get_prep_lookup(lookup_type, value)</font>
<font color="black">1860. </font>
<font color="green">1861.     def get_internal_type(self):</font>
<font color="green">1862.         return &quot;IntegerField&quot;</font>
<font color="black">1863. </font>
<font color="green">1864.     def to_python(self, value):</font>
<font color="red">1865.         if value is None:</font>
<font color="red">1866.             return value</font>
<font color="red">1867.         try:</font>
<font color="red">1868.             return int(value)</font>
<font color="red">1869.         except (TypeError, ValueError):</font>
<font color="red">1870.             raise exceptions.ValidationError(</font>
<font color="red">1871.                 self.error_messages['invalid'],</font>
<font color="red">1872.                 code='invalid',</font>
<font color="red">1873.                 params={'value': value},</font>
<font color="black">1874.             )</font>
<font color="black">1875. </font>
<font color="green">1876.     def formfield(self, **kwargs):</font>
<font color="red">1877.         defaults = {'form_class': forms.IntegerField}</font>
<font color="red">1878.         defaults.update(kwargs)</font>
<font color="red">1879.         return super(IntegerField, self).formfield(**defaults)</font>
<font color="black">1880. </font>
<font color="black">1881. </font>
<font color="green">1882. class BigIntegerField(IntegerField):</font>
<font color="green">1883.     empty_strings_allowed = False</font>
<font color="green">1884.     description = _(&quot;Big (8 byte) integer&quot;)</font>
<font color="green">1885.     MAX_BIGINT = 9223372036854775807</font>
<font color="black">1886. </font>
<font color="green">1887.     def get_internal_type(self):</font>
<font color="red">1888.         return &quot;BigIntegerField&quot;</font>
<font color="black">1889. </font>
<font color="green">1890.     def formfield(self, **kwargs):</font>
<font color="red">1891.         defaults = {'min_value': -BigIntegerField.MAX_BIGINT - 1,</font>
<font color="red">1892.                     'max_value': BigIntegerField.MAX_BIGINT}</font>
<font color="red">1893.         defaults.update(kwargs)</font>
<font color="red">1894.         return super(BigIntegerField, self).formfield(**defaults)</font>
<font color="black">1895. </font>
<font color="black">1896. </font>
<font color="green">1897. class IPAddressField(Field):</font>
<font color="green">1898.     empty_strings_allowed = False</font>
<font color="green">1899.     description = _(&quot;IPv4 address&quot;)</font>
<font color="green">1900.     system_check_removed_details = {</font>
<font color="black">1901.         'msg': (</font>
<font color="green">1902.             'IPAddressField has been removed except for support in '</font>
<font color="black">1903.             'historical migrations.'</font>
<font color="black">1904.         ),</font>
<font color="green">1905.         'hint': 'Use GenericIPAddressField instead.',</font>
<font color="green">1906.         'id': 'fields.E900',</font>
<font color="black">1907.     }</font>
<font color="black">1908. </font>
<font color="green">1909.     def __init__(self, *args, **kwargs):</font>
<font color="red">1910.         kwargs['max_length'] = 15</font>
<font color="red">1911.         super(IPAddressField, self).__init__(*args, **kwargs)</font>
<font color="black">1912. </font>
<font color="green">1913.     def deconstruct(self):</font>
<font color="red">1914.         name, path, args, kwargs = super(IPAddressField, self).deconstruct()</font>
<font color="red">1915.         del kwargs['max_length']</font>
<font color="red">1916.         return name, path, args, kwargs</font>
<font color="black">1917. </font>
<font color="green">1918.     def get_prep_value(self, value):</font>
<font color="red">1919.         value = super(IPAddressField, self).get_prep_value(value)</font>
<font color="red">1920.         if value is None:</font>
<font color="red">1921.             return None</font>
<font color="red">1922.         return six.text_type(value)</font>
<font color="black">1923. </font>
<font color="green">1924.     def get_internal_type(self):</font>
<font color="red">1925.         return &quot;IPAddressField&quot;</font>
<font color="black">1926. </font>
<font color="black">1927. </font>
<font color="green">1928. class GenericIPAddressField(Field):</font>
<font color="green">1929.     empty_strings_allowed = False</font>
<font color="green">1930.     description = _(&quot;IP address&quot;)</font>
<font color="green">1931.     default_error_messages = {}</font>
<font color="black">1932. </font>
<font color="green">1933.     def __init__(self, verbose_name=None, name=None, protocol='both',</font>
<font color="green">1934.                  unpack_ipv4=False, *args, **kwargs):</font>
<font color="red">1935.         self.unpack_ipv4 = unpack_ipv4</font>
<font color="red">1936.         self.protocol = protocol</font>
<font color="black">1937.         self.default_validators, invalid_error_message = \</font>
<font color="red">1938.             validators.ip_address_validators(protocol, unpack_ipv4)</font>
<font color="red">1939.         self.default_error_messages['invalid'] = invalid_error_message</font>
<font color="red">1940.         kwargs['max_length'] = 39</font>
<font color="red">1941.         super(GenericIPAddressField, self).__init__(verbose_name, name, *args,</font>
<font color="red">1942.                                                     **kwargs)</font>
<font color="black">1943. </font>
<font color="green">1944.     def check(self, **kwargs):</font>
<font color="red">1945.         errors = super(GenericIPAddressField, self).check(**kwargs)</font>
<font color="red">1946.         errors.extend(self._check_blank_and_null_values(**kwargs))</font>
<font color="red">1947.         return errors</font>
<font color="black">1948. </font>
<font color="green">1949.     def _check_blank_and_null_values(self, **kwargs):</font>
<font color="red">1950.         if not getattr(self, 'null', False) and getattr(self, 'blank', False):</font>
<font color="black">1951.             return [</font>
<font color="red">1952.                 checks.Error(</font>
<font color="red">1953.                     ('GenericIPAddressFields cannot have blank=True if null=False, '</font>
<font color="black">1954.                      'as blank values are stored as nulls.'),</font>
<font color="red">1955.                     hint=None,</font>
<font color="red">1956.                     obj=self,</font>
<font color="red">1957.                     id='fields.E150',</font>
<font color="black">1958.                 )</font>
<font color="black">1959.             ]</font>
<font color="red">1960.         return []</font>
<font color="black">1961. </font>
<font color="green">1962.     def deconstruct(self):</font>
<font color="red">1963.         name, path, args, kwargs = super(GenericIPAddressField, self).deconstruct()</font>
<font color="red">1964.         if self.unpack_ipv4 is not False:</font>
<font color="red">1965.             kwargs['unpack_ipv4'] = self.unpack_ipv4</font>
<font color="red">1966.         if self.protocol != &quot;both&quot;:</font>
<font color="red">1967.             kwargs['protocol'] = self.protocol</font>
<font color="red">1968.         if kwargs.get(&quot;max_length&quot;) == 39:</font>
<font color="red">1969.             del kwargs['max_length']</font>
<font color="red">1970.         return name, path, args, kwargs</font>
<font color="black">1971. </font>
<font color="green">1972.     def get_internal_type(self):</font>
<font color="red">1973.         return &quot;GenericIPAddressField&quot;</font>
<font color="black">1974. </font>
<font color="green">1975.     def to_python(self, value):</font>
<font color="red">1976.         if value is None:</font>
<font color="red">1977.             return None</font>
<font color="red">1978.         if not isinstance(value, six.string_types):</font>
<font color="red">1979.             value = force_text(value)</font>
<font color="red">1980.         value = value.strip()</font>
<font color="red">1981.         if ':' in value:</font>
<font color="red">1982.             return clean_ipv6_address(value,</font>
<font color="red">1983.                 self.unpack_ipv4, self.error_messages['invalid'])</font>
<font color="red">1984.         return value</font>
<font color="black">1985. </font>
<font color="green">1986.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="red">1987.         if not prepared:</font>
<font color="red">1988.             value = self.get_prep_value(value)</font>
<font color="red">1989.         return connection.ops.adapt_ipaddressfield_value(value)</font>
<font color="black">1990. </font>
<font color="green">1991.     def get_prep_value(self, value):</font>
<font color="red">1992.         value = super(GenericIPAddressField, self).get_prep_value(value)</font>
<font color="red">1993.         if value is None:</font>
<font color="red">1994.             return None</font>
<font color="red">1995.         if value and ':' in value:</font>
<font color="red">1996.             try:</font>
<font color="red">1997.                 return clean_ipv6_address(value, self.unpack_ipv4)</font>
<font color="red">1998.             except exceptions.ValidationError:</font>
<font color="red">1999.                 pass</font>
<font color="red">2000.         return six.text_type(value)</font>
<font color="black">2001. </font>
<font color="green">2002.     def formfield(self, **kwargs):</font>
<font color="red">2003.         defaults = {</font>
<font color="red">2004.             'protocol': self.protocol,</font>
<font color="red">2005.             'form_class': forms.GenericIPAddressField,</font>
<font color="black">2006.         }</font>
<font color="red">2007.         defaults.update(kwargs)</font>
<font color="red">2008.         return super(GenericIPAddressField, self).formfield(**defaults)</font>
<font color="black">2009. </font>
<font color="black">2010. </font>
<font color="green">2011. class NullBooleanField(Field):</font>
<font color="green">2012.     empty_strings_allowed = False</font>
<font color="green">2013.     default_error_messages = {</font>
<font color="green">2014.         'invalid': _(&quot;'%(value)s' value must be either None, True or False.&quot;),</font>
<font color="black">2015.     }</font>
<font color="green">2016.     description = _(&quot;Boolean (Either True, False or None)&quot;)</font>
<font color="black">2017. </font>
<font color="green">2018.     def __init__(self, *args, **kwargs):</font>
<font color="red">2019.         kwargs['null'] = True</font>
<font color="red">2020.         kwargs['blank'] = True</font>
<font color="red">2021.         super(NullBooleanField, self).__init__(*args, **kwargs)</font>
<font color="black">2022. </font>
<font color="green">2023.     def deconstruct(self):</font>
<font color="red">2024.         name, path, args, kwargs = super(NullBooleanField, self).deconstruct()</font>
<font color="red">2025.         del kwargs['null']</font>
<font color="red">2026.         del kwargs['blank']</font>
<font color="red">2027.         return name, path, args, kwargs</font>
<font color="black">2028. </font>
<font color="green">2029.     def get_internal_type(self):</font>
<font color="red">2030.         return &quot;NullBooleanField&quot;</font>
<font color="black">2031. </font>
<font color="green">2032.     def to_python(self, value):</font>
<font color="red">2033.         if value is None:</font>
<font color="red">2034.             return None</font>
<font color="red">2035.         if value in (True, False):</font>
<font color="red">2036.             return bool(value)</font>
<font color="red">2037.         if value in ('None',):</font>
<font color="red">2038.             return None</font>
<font color="red">2039.         if value in ('t', 'True', '1'):</font>
<font color="red">2040.             return True</font>
<font color="red">2041.         if value in ('f', 'False', '0'):</font>
<font color="red">2042.             return False</font>
<font color="red">2043.         raise exceptions.ValidationError(</font>
<font color="red">2044.             self.error_messages['invalid'],</font>
<font color="red">2045.             code='invalid',</font>
<font color="red">2046.             params={'value': value},</font>
<font color="black">2047.         )</font>
<font color="black">2048. </font>
<font color="green">2049.     def get_prep_lookup(self, lookup_type, value):</font>
<font color="black">2050.         # Special-case handling for filters coming from a Web request (e.g. the</font>
<font color="black">2051.         # admin interface). Only works for scalar values (not lists). If you're</font>
<font color="black">2052.         # passing in a list, you might as well make things the right type when</font>
<font color="black">2053.         # constructing the list.</font>
<font color="red">2054.         if value in ('1', '0'):</font>
<font color="red">2055.             value = bool(int(value))</font>
<font color="red">2056.         return super(NullBooleanField, self).get_prep_lookup(lookup_type,</font>
<font color="red">2057.                                                              value)</font>
<font color="black">2058. </font>
<font color="green">2059.     def get_prep_value(self, value):</font>
<font color="red">2060.         value = super(NullBooleanField, self).get_prep_value(value)</font>
<font color="red">2061.         if value is None:</font>
<font color="red">2062.             return None</font>
<font color="red">2063.         return bool(value)</font>
<font color="black">2064. </font>
<font color="green">2065.     def formfield(self, **kwargs):</font>
<font color="red">2066.         defaults = {</font>
<font color="red">2067.             'form_class': forms.NullBooleanField,</font>
<font color="red">2068.             'required': not self.blank,</font>
<font color="red">2069.             'label': capfirst(self.verbose_name),</font>
<font color="red">2070.             'help_text': self.help_text}</font>
<font color="red">2071.         defaults.update(kwargs)</font>
<font color="red">2072.         return super(NullBooleanField, self).formfield(**defaults)</font>
<font color="black">2073. </font>
<font color="black">2074. </font>
<font color="green">2075. class PositiveIntegerField(IntegerField):</font>
<font color="green">2076.     description = _(&quot;Positive integer&quot;)</font>
<font color="black">2077. </font>
<font color="green">2078.     def get_internal_type(self):</font>
<font color="red">2079.         return &quot;PositiveIntegerField&quot;</font>
<font color="black">2080. </font>
<font color="green">2081.     def formfield(self, **kwargs):</font>
<font color="red">2082.         defaults = {'min_value': 0}</font>
<font color="red">2083.         defaults.update(kwargs)</font>
<font color="red">2084.         return super(PositiveIntegerField, self).formfield(**defaults)</font>
<font color="black">2085. </font>
<font color="black">2086. </font>
<font color="green">2087. class PositiveSmallIntegerField(IntegerField):</font>
<font color="green">2088.     description = _(&quot;Positive small integer&quot;)</font>
<font color="black">2089. </font>
<font color="green">2090.     def get_internal_type(self):</font>
<font color="green">2091.         return &quot;PositiveSmallIntegerField&quot;</font>
<font color="black">2092. </font>
<font color="green">2093.     def formfield(self, **kwargs):</font>
<font color="red">2094.         defaults = {'min_value': 0}</font>
<font color="red">2095.         defaults.update(kwargs)</font>
<font color="red">2096.         return super(PositiveSmallIntegerField, self).formfield(**defaults)</font>
<font color="black">2097. </font>
<font color="black">2098. </font>
<font color="green">2099. class SlugField(CharField):</font>
<font color="green">2100.     default_validators = [validators.validate_slug]</font>
<font color="green">2101.     description = _(&quot;Slug (up to %(max_length)s)&quot;)</font>
<font color="black">2102. </font>
<font color="green">2103.     def __init__(self, *args, **kwargs):</font>
<font color="red">2104.         kwargs['max_length'] = kwargs.get('max_length', 50)</font>
<font color="black">2105.         # Set db_index=True unless it's been set manually.</font>
<font color="red">2106.         if 'db_index' not in kwargs:</font>
<font color="red">2107.             kwargs['db_index'] = True</font>
<font color="red">2108.         self.allow_unicode = kwargs.pop('allow_unicode', False)</font>
<font color="red">2109.         if self.allow_unicode:</font>
<font color="red">2110.             self.default_validators = [validators.validate_unicode_slug]</font>
<font color="red">2111.         super(SlugField, self).__init__(*args, **kwargs)</font>
<font color="black">2112. </font>
<font color="green">2113.     def deconstruct(self):</font>
<font color="red">2114.         name, path, args, kwargs = super(SlugField, self).deconstruct()</font>
<font color="red">2115.         if kwargs.get(&quot;max_length&quot;) == 50:</font>
<font color="red">2116.             del kwargs['max_length']</font>
<font color="red">2117.         if self.db_index is False:</font>
<font color="red">2118.             kwargs['db_index'] = False</font>
<font color="black">2119.         else:</font>
<font color="red">2120.             del kwargs['db_index']</font>
<font color="red">2121.         if self.allow_unicode is not False:</font>
<font color="red">2122.             kwargs['allow_unicode'] = self.allow_unicode</font>
<font color="red">2123.         return name, path, args, kwargs</font>
<font color="black">2124. </font>
<font color="green">2125.     def get_internal_type(self):</font>
<font color="red">2126.         return &quot;SlugField&quot;</font>
<font color="black">2127. </font>
<font color="green">2128.     def formfield(self, **kwargs):</font>
<font color="red">2129.         defaults = {'form_class': forms.SlugField, 'allow_unicode': self.allow_unicode}</font>
<font color="red">2130.         defaults.update(kwargs)</font>
<font color="red">2131.         return super(SlugField, self).formfield(**defaults)</font>
<font color="black">2132. </font>
<font color="black">2133. </font>
<font color="green">2134. class SmallIntegerField(IntegerField):</font>
<font color="green">2135.     description = _(&quot;Small integer&quot;)</font>
<font color="black">2136. </font>
<font color="green">2137.     def get_internal_type(self):</font>
<font color="red">2138.         return &quot;SmallIntegerField&quot;</font>
<font color="black">2139. </font>
<font color="black">2140. </font>
<font color="green">2141. class TextField(Field):</font>
<font color="green">2142.     description = _(&quot;Text&quot;)</font>
<font color="black">2143. </font>
<font color="green">2144.     def get_internal_type(self):</font>
<font color="green">2145.         return &quot;TextField&quot;</font>
<font color="black">2146. </font>
<font color="green">2147.     def to_python(self, value):</font>
<font color="red">2148.         if isinstance(value, six.string_types) or value is None:</font>
<font color="red">2149.             return value</font>
<font color="red">2150.         return smart_text(value)</font>
<font color="black">2151. </font>
<font color="green">2152.     def get_prep_value(self, value):</font>
<font color="red">2153.         value = super(TextField, self).get_prep_value(value)</font>
<font color="red">2154.         return self.to_python(value)</font>
<font color="black">2155. </font>
<font color="green">2156.     def formfield(self, **kwargs):</font>
<font color="black">2157.         # Passing max_length to forms.CharField means that the value's length</font>
<font color="black">2158.         # will be validated twice. This is considered acceptable since we want</font>
<font color="black">2159.         # the value in the form field (to pass into widget for example).</font>
<font color="red">2160.         defaults = {'max_length': self.max_length, 'widget': forms.Textarea}</font>
<font color="red">2161.         defaults.update(kwargs)</font>
<font color="red">2162.         return super(TextField, self).formfield(**defaults)</font>
<font color="black">2163. </font>
<font color="black">2164. </font>
<font color="green">2165. class TimeField(DateTimeCheckMixin, Field):</font>
<font color="green">2166.     empty_strings_allowed = False</font>
<font color="green">2167.     default_error_messages = {</font>
<font color="green">2168.         'invalid': _(&quot;'%(value)s' value has an invalid format. It must be in &quot;</font>
<font color="black">2169.                      &quot;HH:MM[:ss[.uuuuuu]] format.&quot;),</font>
<font color="green">2170.         'invalid_time': _(&quot;'%(value)s' value has the correct format &quot;</font>
<font color="black">2171.                           &quot;(HH:MM[:ss[.uuuuuu]]) but it is an invalid time.&quot;),</font>
<font color="black">2172.     }</font>
<font color="green">2173.     description = _(&quot;Time&quot;)</font>
<font color="black">2174. </font>
<font color="green">2175.     def __init__(self, verbose_name=None, name=None, auto_now=False,</font>
<font color="green">2176.                  auto_now_add=False, **kwargs):</font>
<font color="red">2177.         self.auto_now, self.auto_now_add = auto_now, auto_now_add</font>
<font color="red">2178.         if auto_now or auto_now_add:</font>
<font color="red">2179.             kwargs['editable'] = False</font>
<font color="red">2180.             kwargs['blank'] = True</font>
<font color="red">2181.         super(TimeField, self).__init__(verbose_name, name, **kwargs)</font>
<font color="black">2182. </font>
<font color="green">2183.     def _check_fix_default_value(self):</font>
<font color="black">2184.         &quot;&quot;&quot;</font>
<font color="black">2185.         Adds a warning to the checks framework stating, that using an actual</font>
<font color="black">2186.         time or datetime value is probably wrong; it's only being evaluated on</font>
<font color="black">2187.         server start-up.</font>
<font color="black">2188. </font>
<font color="black">2189.         For details see ticket #21905</font>
<font color="black">2190.         &quot;&quot;&quot;</font>
<font color="red">2191.         if not self.has_default():</font>
<font color="red">2192.             return []</font>
<font color="black">2193. </font>
<font color="red">2194.         now = timezone.now()</font>
<font color="red">2195.         if not timezone.is_naive(now):</font>
<font color="red">2196.             now = timezone.make_naive(now, timezone.utc)</font>
<font color="red">2197.         value = self.default</font>
<font color="red">2198.         if isinstance(value, datetime.datetime):</font>
<font color="red">2199.             second_offset = datetime.timedelta(seconds=10)</font>
<font color="red">2200.             lower = now - second_offset</font>
<font color="red">2201.             upper = now + second_offset</font>
<font color="red">2202.             if timezone.is_aware(value):</font>
<font color="red">2203.                 value = timezone.make_naive(value, timezone.utc)</font>
<font color="red">2204.         elif isinstance(value, datetime.time):</font>
<font color="red">2205.             second_offset = datetime.timedelta(seconds=10)</font>
<font color="red">2206.             lower = now - second_offset</font>
<font color="red">2207.             upper = now + second_offset</font>
<font color="red">2208.             value = datetime.datetime.combine(now.date(), value)</font>
<font color="red">2209.             if timezone.is_aware(value):</font>
<font color="red">2210.                 value = timezone.make_naive(value, timezone.utc).time()</font>
<font color="black">2211.         else:</font>
<font color="black">2212.             # No explicit time / datetime value -- no checks necessary</font>
<font color="red">2213.             return []</font>
<font color="red">2214.         if lower &lt;= value &lt;= upper:</font>
<font color="black">2215.             return [</font>
<font color="red">2216.                 checks.Warning(</font>
<font color="red">2217.                     'Fixed default value provided.',</font>
<font color="red">2218.                     hint='It seems you set a fixed date / time / datetime '</font>
<font color="black">2219.                          'value as default for this field. This may not be '</font>
<font color="black">2220.                          'what you want. If you want to have the current date '</font>
<font color="black">2221.                          'as default, use `django.utils.timezone.now`',</font>
<font color="red">2222.                     obj=self,</font>
<font color="red">2223.                     id='fields.W161',</font>
<font color="black">2224.                 )</font>
<font color="black">2225.             ]</font>
<font color="black">2226. </font>
<font color="red">2227.         return []</font>
<font color="black">2228. </font>
<font color="green">2229.     def deconstruct(self):</font>
<font color="red">2230.         name, path, args, kwargs = super(TimeField, self).deconstruct()</font>
<font color="red">2231.         if self.auto_now is not False:</font>
<font color="red">2232.             kwargs[&quot;auto_now&quot;] = self.auto_now</font>
<font color="red">2233.         if self.auto_now_add is not False:</font>
<font color="red">2234.             kwargs[&quot;auto_now_add&quot;] = self.auto_now_add</font>
<font color="red">2235.         if self.auto_now or self.auto_now_add:</font>
<font color="red">2236.             del kwargs['blank']</font>
<font color="red">2237.             del kwargs['editable']</font>
<font color="red">2238.         return name, path, args, kwargs</font>
<font color="black">2239. </font>
<font color="green">2240.     def get_internal_type(self):</font>
<font color="red">2241.         return &quot;TimeField&quot;</font>
<font color="black">2242. </font>
<font color="green">2243.     def to_python(self, value):</font>
<font color="red">2244.         if value is None:</font>
<font color="red">2245.             return None</font>
<font color="red">2246.         if isinstance(value, datetime.time):</font>
<font color="red">2247.             return value</font>
<font color="red">2248.         if isinstance(value, datetime.datetime):</font>
<font color="black">2249.             # Not usually a good idea to pass in a datetime here (it loses</font>
<font color="black">2250.             # information), but this can be a side-effect of interacting with a</font>
<font color="black">2251.             # database backend (e.g. Oracle), so we'll be accommodating.</font>
<font color="red">2252.             return value.time()</font>
<font color="black">2253. </font>
<font color="red">2254.         try:</font>
<font color="red">2255.             parsed = parse_time(value)</font>
<font color="red">2256.             if parsed is not None:</font>
<font color="red">2257.                 return parsed</font>
<font color="red">2258.         except ValueError:</font>
<font color="red">2259.             raise exceptions.ValidationError(</font>
<font color="red">2260.                 self.error_messages['invalid_time'],</font>
<font color="red">2261.                 code='invalid_time',</font>
<font color="red">2262.                 params={'value': value},</font>
<font color="black">2263.             )</font>
<font color="black">2264. </font>
<font color="red">2265.         raise exceptions.ValidationError(</font>
<font color="red">2266.             self.error_messages['invalid'],</font>
<font color="red">2267.             code='invalid',</font>
<font color="red">2268.             params={'value': value},</font>
<font color="black">2269.         )</font>
<font color="black">2270. </font>
<font color="green">2271.     def pre_save(self, model_instance, add):</font>
<font color="red">2272.         if self.auto_now or (self.auto_now_add and add):</font>
<font color="red">2273.             value = datetime.datetime.now().time()</font>
<font color="red">2274.             setattr(model_instance, self.attname, value)</font>
<font color="red">2275.             return value</font>
<font color="black">2276.         else:</font>
<font color="red">2277.             return super(TimeField, self).pre_save(model_instance, add)</font>
<font color="black">2278. </font>
<font color="green">2279.     def get_prep_value(self, value):</font>
<font color="red">2280.         value = super(TimeField, self).get_prep_value(value)</font>
<font color="red">2281.         return self.to_python(value)</font>
<font color="black">2282. </font>
<font color="green">2283.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="black">2284.         # Casts times into the format expected by the backend</font>
<font color="red">2285.         if not prepared:</font>
<font color="red">2286.             value = self.get_prep_value(value)</font>
<font color="red">2287.         return connection.ops.adapt_timefield_value(value)</font>
<font color="black">2288. </font>
<font color="green">2289.     def value_to_string(self, obj):</font>
<font color="red">2290.         val = self.value_from_object(obj)</font>
<font color="red">2291.         return '' if val is None else val.isoformat()</font>
<font color="black">2292. </font>
<font color="green">2293.     def formfield(self, **kwargs):</font>
<font color="red">2294.         defaults = {'form_class': forms.TimeField}</font>
<font color="red">2295.         defaults.update(kwargs)</font>
<font color="red">2296.         return super(TimeField, self).formfield(**defaults)</font>
<font color="black">2297. </font>
<font color="black">2298. </font>
<font color="green">2299. class URLField(CharField):</font>
<font color="green">2300.     default_validators = [validators.URLValidator()]</font>
<font color="green">2301.     description = _(&quot;URL&quot;)</font>
<font color="black">2302. </font>
<font color="green">2303.     def __init__(self, verbose_name=None, name=None, **kwargs):</font>
<font color="red">2304.         kwargs['max_length'] = kwargs.get('max_length', 200)</font>
<font color="red">2305.         super(URLField, self).__init__(verbose_name, name, **kwargs)</font>
<font color="black">2306. </font>
<font color="green">2307.     def deconstruct(self):</font>
<font color="red">2308.         name, path, args, kwargs = super(URLField, self).deconstruct()</font>
<font color="red">2309.         if kwargs.get(&quot;max_length&quot;) == 200:</font>
<font color="red">2310.             del kwargs['max_length']</font>
<font color="red">2311.         return name, path, args, kwargs</font>
<font color="black">2312. </font>
<font color="green">2313.     def formfield(self, **kwargs):</font>
<font color="black">2314.         # As with CharField, this will cause URL validation to be performed</font>
<font color="black">2315.         # twice.</font>
<font color="red">2316.         defaults = {</font>
<font color="red">2317.             'form_class': forms.URLField,</font>
<font color="black">2318.         }</font>
<font color="red">2319.         defaults.update(kwargs)</font>
<font color="red">2320.         return super(URLField, self).formfield(**defaults)</font>
<font color="black">2321. </font>
<font color="black">2322. </font>
<font color="green">2323. class BinaryField(Field):</font>
<font color="green">2324.     description = _(&quot;Raw binary data&quot;)</font>
<font color="green">2325.     empty_values = [None, b'']</font>
<font color="black">2326. </font>
<font color="green">2327.     def __init__(self, *args, **kwargs):</font>
<font color="red">2328.         kwargs['editable'] = False</font>
<font color="red">2329.         super(BinaryField, self).__init__(*args, **kwargs)</font>
<font color="red">2330.         if self.max_length is not None:</font>
<font color="red">2331.             self.validators.append(validators.MaxLengthValidator(self.max_length))</font>
<font color="black">2332. </font>
<font color="green">2333.     def deconstruct(self):</font>
<font color="red">2334.         name, path, args, kwargs = super(BinaryField, self).deconstruct()</font>
<font color="red">2335.         del kwargs['editable']</font>
<font color="red">2336.         return name, path, args, kwargs</font>
<font color="black">2337. </font>
<font color="green">2338.     def get_internal_type(self):</font>
<font color="red">2339.         return &quot;BinaryField&quot;</font>
<font color="black">2340. </font>
<font color="green">2341.     def get_default(self):</font>
<font color="red">2342.         if self.has_default() and not callable(self.default):</font>
<font color="red">2343.             return self.default</font>
<font color="red">2344.         default = super(BinaryField, self).get_default()</font>
<font color="red">2345.         if default == '':</font>
<font color="red">2346.             return b''</font>
<font color="red">2347.         return default</font>
<font color="black">2348. </font>
<font color="green">2349.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="red">2350.         value = super(BinaryField, self).get_db_prep_value(value, connection, prepared)</font>
<font color="red">2351.         if value is not None:</font>
<font color="red">2352.             return connection.Database.Binary(value)</font>
<font color="red">2353.         return value</font>
<font color="black">2354. </font>
<font color="green">2355.     def value_to_string(self, obj):</font>
<font color="black">2356.         &quot;&quot;&quot;Binary data is serialized as base64&quot;&quot;&quot;</font>
<font color="red">2357.         return b64encode(force_bytes(self.value_from_object(obj))).decode('ascii')</font>
<font color="black">2358. </font>
<font color="green">2359.     def to_python(self, value):</font>
<font color="black">2360.         # If it's a string, it should be base64-encoded data</font>
<font color="red">2361.         if isinstance(value, six.text_type):</font>
<font color="red">2362.             return six.memoryview(b64decode(force_bytes(value)))</font>
<font color="red">2363.         return value</font>
<font color="black">2364. </font>
<font color="black">2365. </font>
<font color="green">2366. class UUIDField(Field):</font>
<font color="green">2367.     default_error_messages = {</font>
<font color="green">2368.         'invalid': _(&quot;'%(value)s' is not a valid UUID.&quot;),</font>
<font color="black">2369.     }</font>
<font color="green">2370.     description = 'Universally unique identifier'</font>
<font color="green">2371.     empty_strings_allowed = False</font>
<font color="black">2372. </font>
<font color="green">2373.     def __init__(self, verbose_name=None, **kwargs):</font>
<font color="red">2374.         kwargs['max_length'] = 32</font>
<font color="red">2375.         super(UUIDField, self).__init__(verbose_name, **kwargs)</font>
<font color="black">2376. </font>
<font color="green">2377.     def deconstruct(self):</font>
<font color="red">2378.         name, path, args, kwargs = super(UUIDField, self).deconstruct()</font>
<font color="red">2379.         del kwargs['max_length']</font>
<font color="red">2380.         return name, path, args, kwargs</font>
<font color="black">2381. </font>
<font color="green">2382.     def get_internal_type(self):</font>
<font color="red">2383.         return &quot;UUIDField&quot;</font>
<font color="black">2384. </font>
<font color="green">2385.     def get_db_prep_value(self, value, connection, prepared=False):</font>
<font color="red">2386.         if value is None:</font>
<font color="red">2387.             return None</font>
<font color="red">2388.         if not isinstance(value, uuid.UUID):</font>
<font color="red">2389.             try:</font>
<font color="red">2390.                 value = uuid.UUID(value)</font>
<font color="red">2391.             except AttributeError:</font>
<font color="red">2392.                 raise TypeError(self.error_messages['invalid'] % {'value': value})</font>
<font color="black">2393. </font>
<font color="red">2394.         if connection.features.has_native_uuid_field:</font>
<font color="red">2395.             return value</font>
<font color="red">2396.         return value.hex</font>
<font color="black">2397. </font>
<font color="green">2398.     def to_python(self, value):</font>
<font color="red">2399.         if value and not isinstance(value, uuid.UUID):</font>
<font color="red">2400.             try:</font>
<font color="red">2401.                 return uuid.UUID(value)</font>
<font color="red">2402.             except ValueError:</font>
<font color="red">2403.                 raise exceptions.ValidationError(</font>
<font color="red">2404.                     self.error_messages['invalid'],</font>
<font color="red">2405.                     code='invalid',</font>
<font color="red">2406.                     params={'value': value},</font>
<font color="black">2407.                 )</font>
<font color="red">2408.         return value</font>
<font color="black">2409. </font>
<font color="green">2410.     def formfield(self, **kwargs):</font>
<font color="red">2411.         defaults = {</font>
<font color="red">2412.             'form_class': forms.UUIDField,</font>
<font color="black">2413.         }</font>
<font color="red">2414.         defaults.update(kwargs)</font>
<font color="red">2415.         return super(UUIDField, self).formfield(**defaults)</font>
</pre>

