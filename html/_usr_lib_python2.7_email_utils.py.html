source file: <b>/usr/lib/python2.7/email/utils.py</b><br>


file stats: <b>175 lines, 55 executed: 31.4% covered</b>
<pre>
<font color="black">   1. # Copyright (C) 2001-2010 Python Software Foundation</font>
<font color="black">   2. # Author: Barry Warsaw</font>
<font color="black">   3. # Contact: email-sig@python.org</font>
<font color="black">   4. </font>
<font color="green">   5. &quot;&quot;&quot;Miscellaneous utilities.&quot;&quot;&quot;</font>
<font color="black">   6. </font>
<font color="black">   7. __all__ = [</font>
<font color="green">   8.     'collapse_rfc2231_value',</font>
<font color="green">   9.     'decode_params',</font>
<font color="green">  10.     'decode_rfc2231',</font>
<font color="green">  11.     'encode_rfc2231',</font>
<font color="green">  12.     'formataddr',</font>
<font color="green">  13.     'formatdate',</font>
<font color="green">  14.     'getaddresses',</font>
<font color="green">  15.     'make_msgid',</font>
<font color="green">  16.     'mktime_tz',</font>
<font color="green">  17.     'parseaddr',</font>
<font color="green">  18.     'parsedate',</font>
<font color="green">  19.     'parsedate_tz',</font>
<font color="green">  20.     'unquote',</font>
<font color="black">  21.     ]</font>
<font color="black">  22. </font>
<font color="green">  23. import os</font>
<font color="green">  24. import re</font>
<font color="green">  25. import time</font>
<font color="green">  26. import base64</font>
<font color="green">  27. import random</font>
<font color="green">  28. import socket</font>
<font color="green">  29. import urllib</font>
<font color="green">  30. import warnings</font>
<font color="black">  31. </font>
<font color="green">  32. from email._parseaddr import quote</font>
<font color="green">  33. from email._parseaddr import AddressList as _AddressList</font>
<font color="green">  34. from email._parseaddr import mktime_tz</font>
<font color="black">  35. </font>
<font color="black">  36. # We need wormarounds for bugs in these methods in older Pythons (see below)</font>
<font color="green">  37. from email._parseaddr import parsedate as _parsedate</font>
<font color="green">  38. from email._parseaddr import parsedate_tz as _parsedate_tz</font>
<font color="black">  39. </font>
<font color="green">  40. from quopri import decodestring as _qdecode</font>
<font color="black">  41. </font>
<font color="black">  42. # Intrapackage imports</font>
<font color="green">  43. from email.encoders import _bencode, _qencode</font>
<font color="black">  44. </font>
<font color="green">  45. COMMASPACE = ', '</font>
<font color="green">  46. EMPTYSTRING = ''</font>
<font color="green">  47. UEMPTYSTRING = u''</font>
<font color="green">  48. CRLF = '\r\n'</font>
<font color="green">  49. TICK = &quot;'&quot;</font>
<font color="black">  50. </font>
<font color="green">  51. specialsre = re.compile(r'[][\\()&lt;&gt;@,:;&quot;.]')</font>
<font color="green">  52. escapesre = re.compile(r'[][\\()&quot;]')</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="black">  55. </font>
<font color="black">  56. # Helpers</font>
<font color="black">  57. </font>
<font color="green">  58. def _identity(s):</font>
<font color="red">  59.     return s</font>
<font color="black">  60. </font>
<font color="black">  61. </font>
<font color="green">  62. def _bdecode(s):</font>
<font color="black">  63.     &quot;&quot;&quot;Decodes a base64 string.</font>
<font color="black">  64. </font>
<font color="black">  65.     This function is equivalent to base64.decodestring and it's retained only</font>
<font color="black">  66.     for backward compatibility. It used to remove the last \\n of the decoded</font>
<font color="black">  67.     string, if it had any (see issue 7143).</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="red">  69.     if not s:</font>
<font color="red">  70.         return s</font>
<font color="red">  71.     return base64.decodestring(s)</font>
<font color="black">  72. </font>
<font color="black">  73. </font>
<font color="black">  74. </font>
<font color="green">  75. def fix_eols(s):</font>
<font color="black">  76.     &quot;&quot;&quot;Replace all line-ending characters with \\r\\n.&quot;&quot;&quot;</font>
<font color="black">  77.     # Fix newlines with no preceding carriage return</font>
<font color="red">  78.     s = re.sub(r'(?&lt;!\r)\n', CRLF, s)</font>
<font color="black">  79.     # Fix carriage returns with no following newline</font>
<font color="red">  80.     s = re.sub(r'\r(?!\n)', CRLF, s)</font>
<font color="red">  81.     return s</font>
<font color="black">  82. </font>
<font color="black">  83. </font>
<font color="black">  84. </font>
<font color="green">  85. def formataddr(pair):</font>
<font color="black">  86.     &quot;&quot;&quot;The inverse of parseaddr(), this takes a 2-tuple of the form</font>
<font color="black">  87.     (realname, email_address) and returns the string value suitable</font>
<font color="black">  88.     for an RFC 2822 From, To or Cc header.</font>
<font color="black">  89. </font>
<font color="black">  90.     If the first element of pair is false, then the second element is</font>
<font color="black">  91.     returned unmodified.</font>
<font color="black">  92.     &quot;&quot;&quot;</font>
<font color="red">  93.     name, address = pair</font>
<font color="red">  94.     if name:</font>
<font color="red">  95.         quotes = ''</font>
<font color="red">  96.         if specialsre.search(name):</font>
<font color="red">  97.             quotes = '&quot;'</font>
<font color="red">  98.         name = escapesre.sub(r'\\\g&lt;0&gt;', name)</font>
<font color="red">  99.         return '%s%s%s &lt;%s&gt;' % (quotes, name, quotes, address)</font>
<font color="red"> 100.     return address</font>
<font color="black"> 101. </font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. def getaddresses(fieldvalues):</font>
<font color="black"> 105.     &quot;&quot;&quot;Return a list of (REALNAME, EMAIL) for each fieldvalue.&quot;&quot;&quot;</font>
<font color="red"> 106.     all = COMMASPACE.join(fieldvalues)</font>
<font color="red"> 107.     a = _AddressList(all)</font>
<font color="red"> 108.     return a.addresslist</font>
<font color="black"> 109. </font>
<font color="black"> 110. </font>
<font color="black"> 111. </font>
<font color="green"> 112. ecre = re.compile(r'''</font>
<font color="black"> 113.   =\?                   # literal =?</font>
<font color="black"> 114.   (?P&lt;charset&gt;[^?]*?)   # non-greedy up to the next ? is the charset</font>
<font color="black"> 115.   \?                    # literal ?</font>
<font color="black"> 116.   (?P&lt;encoding&gt;[qb])    # either a &quot;q&quot; or a &quot;b&quot;, case insensitive</font>
<font color="black"> 117.   \?                    # literal ?</font>
<font color="black"> 118.   (?P&lt;atom&gt;.*?)         # non-greedy up to the next ?= is the atom</font>
<font color="black"> 119.   \?=                   # literal ?=</font>
<font color="green"> 120.   ''', re.VERBOSE | re.IGNORECASE)</font>
<font color="black"> 121. </font>
<font color="black"> 122. </font>
<font color="black"> 123. </font>
<font color="green"> 124. def formatdate(timeval=None, localtime=False, usegmt=False):</font>
<font color="black"> 125.     &quot;&quot;&quot;Returns a date string as specified by RFC 2822, e.g.:</font>
<font color="black"> 126. </font>
<font color="black"> 127.     Fri, 09 Nov 2001 01:08:47 -0000</font>
<font color="black"> 128. </font>
<font color="black"> 129.     Optional timeval if given is a floating point time value as accepted by</font>
<font color="black"> 130.     gmtime() and localtime(), otherwise the current time is used.</font>
<font color="black"> 131. </font>
<font color="black"> 132.     Optional localtime is a flag that when True, interprets timeval, and</font>
<font color="black"> 133.     returns a date relative to the local timezone instead of UTC, properly</font>
<font color="black"> 134.     taking daylight savings time into account.</font>
<font color="black"> 135. </font>
<font color="black"> 136.     Optional argument usegmt means that the timezone is written out as</font>
<font color="black"> 137.     an ascii string, not numeric one (so &quot;GMT&quot; instead of &quot;+0000&quot;). This</font>
<font color="black"> 138.     is needed for HTTP, and is only used when localtime==False.</font>
<font color="black"> 139.     &quot;&quot;&quot;</font>
<font color="black"> 140.     # Note: we cannot use strftime() because that honors the locale and RFC</font>
<font color="black"> 141.     # 2822 requires that day and month names be the English abbreviations.</font>
<font color="red"> 142.     if timeval is None:</font>
<font color="red"> 143.         timeval = time.time()</font>
<font color="red"> 144.     if localtime:</font>
<font color="red"> 145.         now = time.localtime(timeval)</font>
<font color="black"> 146.         # Calculate timezone offset, based on whether the local zone has</font>
<font color="black"> 147.         # daylight savings time, and whether DST is in effect.</font>
<font color="red"> 148.         if time.daylight and now[-1]:</font>
<font color="red"> 149.             offset = time.altzone</font>
<font color="black"> 150.         else:</font>
<font color="red"> 151.             offset = time.timezone</font>
<font color="red"> 152.         hours, minutes = divmod(abs(offset), 3600)</font>
<font color="black"> 153.         # Remember offset is in seconds west of UTC, but the timezone is in</font>
<font color="black"> 154.         # minutes east of UTC, so the signs differ.</font>
<font color="red"> 155.         if offset &gt; 0:</font>
<font color="red"> 156.             sign = '-'</font>
<font color="black"> 157.         else:</font>
<font color="red"> 158.             sign = '+'</font>
<font color="red"> 159.         zone = '%s%02d%02d' % (sign, hours, minutes // 60)</font>
<font color="black"> 160.     else:</font>
<font color="red"> 161.         now = time.gmtime(timeval)</font>
<font color="black"> 162.         # Timezone offset is always -0000</font>
<font color="red"> 163.         if usegmt:</font>
<font color="red"> 164.             zone = 'GMT'</font>
<font color="black"> 165.         else:</font>
<font color="red"> 166.             zone = '-0000'</font>
<font color="red"> 167.     return '%s, %02d %s %04d %02d:%02d:%02d %s' % (</font>
<font color="red"> 168.         ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][now[6]],</font>
<font color="red"> 169.         now[2],</font>
<font color="red"> 170.         ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',</font>
<font color="red"> 171.          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][now[1] - 1],</font>
<font color="red"> 172.         now[0], now[3], now[4], now[5],</font>
<font color="red"> 173.         zone)</font>
<font color="black"> 174. </font>
<font color="black"> 175. </font>
<font color="black"> 176. </font>
<font color="green"> 177. def make_msgid(idstring=None):</font>
<font color="black"> 178.     &quot;&quot;&quot;Returns a string suitable for RFC 2822 compliant Message-ID, e.g:</font>
<font color="black"> 179. </font>
<font color="black"> 180.     &lt;20020201195627.33539.96671@nightshade.la.mastaler.com&gt;</font>
<font color="black"> 181. </font>
<font color="black"> 182.     Optional idstring if given is a string used to strengthen the</font>
<font color="black"> 183.     uniqueness of the message id.</font>
<font color="black"> 184.     &quot;&quot;&quot;</font>
<font color="red"> 185.     timeval = time.time()</font>
<font color="red"> 186.     utcdate = time.strftime('%Y%m%d%H%M%S', time.gmtime(timeval))</font>
<font color="red"> 187.     pid = os.getpid()</font>
<font color="red"> 188.     randint = random.randrange(100000)</font>
<font color="red"> 189.     if idstring is None:</font>
<font color="red"> 190.         idstring = ''</font>
<font color="black"> 191.     else:</font>
<font color="red"> 192.         idstring = '.' + idstring</font>
<font color="red"> 193.     idhost = socket.getfqdn()</font>
<font color="red"> 194.     msgid = '&lt;%s.%s.%s%s@%s&gt;' % (utcdate, pid, randint, idstring, idhost)</font>
<font color="red"> 195.     return msgid</font>
<font color="black"> 196. </font>
<font color="black"> 197. </font>
<font color="black"> 198. </font>
<font color="black"> 199. # These functions are in the standalone mimelib version only because they've</font>
<font color="black"> 200. # subsequently been fixed in the latest Python versions.  We use this to worm</font>
<font color="black"> 201. # around broken older Pythons.</font>
<font color="green"> 202. def parsedate(data):</font>
<font color="red"> 203.     if not data:</font>
<font color="red"> 204.         return None</font>
<font color="red"> 205.     return _parsedate(data)</font>
<font color="black"> 206. </font>
<font color="black"> 207. </font>
<font color="green"> 208. def parsedate_tz(data):</font>
<font color="red"> 209.     if not data:</font>
<font color="red"> 210.         return None</font>
<font color="red"> 211.     return _parsedate_tz(data)</font>
<font color="black"> 212. </font>
<font color="black"> 213. </font>
<font color="green"> 214. def parseaddr(addr):</font>
<font color="red"> 215.     addrs = _AddressList(addr).addresslist</font>
<font color="red"> 216.     if not addrs:</font>
<font color="red"> 217.         return '', ''</font>
<font color="red"> 218.     return addrs[0]</font>
<font color="black"> 219. </font>
<font color="black"> 220. </font>
<font color="black"> 221. # rfc822.unquote() doesn't properly de-backslash-ify in Python pre-2.3.</font>
<font color="green"> 222. def unquote(str):</font>
<font color="black"> 223.     &quot;&quot;&quot;Remove quotes from a string.&quot;&quot;&quot;</font>
<font color="red"> 224.     if len(str) &gt; 1:</font>
<font color="red"> 225.         if str.startswith('&quot;') and str.endswith('&quot;'):</font>
<font color="red"> 226.             return str[1:-1].replace('\\\\', '\\').replace('\\&quot;', '&quot;')</font>
<font color="red"> 227.         if str.startswith('&lt;') and str.endswith('&gt;'):</font>
<font color="red"> 228.             return str[1:-1]</font>
<font color="red"> 229.     return str</font>
<font color="black"> 230. </font>
<font color="black"> 231. </font>
<font color="black"> 232. </font>
<font color="black"> 233. # RFC2231-related functions - parameter encoding and decoding</font>
<font color="green"> 234. def decode_rfc2231(s):</font>
<font color="black"> 235.     &quot;&quot;&quot;Decode string according to RFC 2231&quot;&quot;&quot;</font>
<font color="red"> 236.     parts = s.split(TICK, 2)</font>
<font color="red"> 237.     if len(parts) &lt;= 2:</font>
<font color="red"> 238.         return None, None, s</font>
<font color="red"> 239.     return parts</font>
<font color="black"> 240. </font>
<font color="black"> 241. </font>
<font color="green"> 242. def encode_rfc2231(s, charset=None, language=None):</font>
<font color="black"> 243.     &quot;&quot;&quot;Encode string according to RFC 2231.</font>
<font color="black"> 244. </font>
<font color="black"> 245.     If neither charset nor language is given, then s is returned as-is.  If</font>
<font color="black"> 246.     charset is given but not language, the string is encoded using the empty</font>
<font color="black"> 247.     string for language.</font>
<font color="black"> 248.     &quot;&quot;&quot;</font>
<font color="red"> 249.     import urllib</font>
<font color="red"> 250.     s = urllib.quote(s, safe='')</font>
<font color="red"> 251.     if charset is None and language is None:</font>
<font color="red"> 252.         return s</font>
<font color="red"> 253.     if language is None:</font>
<font color="red"> 254.         language = ''</font>
<font color="red"> 255.     return &quot;%s'%s'%s&quot; % (charset, language, s)</font>
<font color="black"> 256. </font>
<font color="black"> 257. </font>
<font color="green"> 258. rfc2231_continuation = re.compile(r'^(?P&lt;name&gt;\w+)\*((?P&lt;num&gt;[0-9]+)\*?)?$')</font>
<font color="black"> 259. </font>
<font color="green"> 260. def decode_params(params):</font>
<font color="black"> 261.     &quot;&quot;&quot;Decode parameters list according to RFC 2231.</font>
<font color="black"> 262. </font>
<font color="black"> 263.     params is a sequence of 2-tuples containing (param name, string value).</font>
<font color="black"> 264.     &quot;&quot;&quot;</font>
<font color="black"> 265.     # Copy params so we don't mess with the original</font>
<font color="red"> 266.     params = params[:]</font>
<font color="red"> 267.     new_params = []</font>
<font color="black"> 268.     # Map parameter's name to a list of continuations.  The values are a</font>
<font color="black"> 269.     # 3-tuple of the continuation number, the string value, and a flag</font>
<font color="black"> 270.     # specifying whether a particular segment is %-encoded.</font>
<font color="red"> 271.     rfc2231_params = {}</font>
<font color="red"> 272.     name, value = params.pop(0)</font>
<font color="red"> 273.     new_params.append((name, value))</font>
<font color="red"> 274.     while params:</font>
<font color="red"> 275.         name, value = params.pop(0)</font>
<font color="red"> 276.         if name.endswith('*'):</font>
<font color="red"> 277.             encoded = True</font>
<font color="black"> 278.         else:</font>
<font color="red"> 279.             encoded = False</font>
<font color="red"> 280.         value = unquote(value)</font>
<font color="red"> 281.         mo = rfc2231_continuation.match(name)</font>
<font color="red"> 282.         if mo:</font>
<font color="red"> 283.             name, num = mo.group('name', 'num')</font>
<font color="red"> 284.             if num is not None:</font>
<font color="red"> 285.                 num = int(num)</font>
<font color="red"> 286.             rfc2231_params.setdefault(name, []).append((num, value, encoded))</font>
<font color="black"> 287.         else:</font>
<font color="red"> 288.             new_params.append((name, '&quot;%s&quot;' % quote(value)))</font>
<font color="red"> 289.     if rfc2231_params:</font>
<font color="red"> 290.         for name, continuations in rfc2231_params.items():</font>
<font color="red"> 291.             value = []</font>
<font color="red"> 292.             extended = False</font>
<font color="black"> 293.             # Sort by number</font>
<font color="red"> 294.             continuations.sort()</font>
<font color="black"> 295.             # And now append all values in numerical order, converting</font>
<font color="black"> 296.             # %-encodings for the encoded segments.  If any of the</font>
<font color="black"> 297.             # continuation names ends in a *, then the entire string, after</font>
<font color="black"> 298.             # decoding segments and concatenating, must have the charset and</font>
<font color="black"> 299.             # language specifiers at the beginning of the string.</font>
<font color="red"> 300.             for num, s, encoded in continuations:</font>
<font color="red"> 301.                 if encoded:</font>
<font color="red"> 302.                     s = urllib.unquote(s)</font>
<font color="red"> 303.                     extended = True</font>
<font color="red"> 304.                 value.append(s)</font>
<font color="red"> 305.             value = quote(EMPTYSTRING.join(value))</font>
<font color="red"> 306.             if extended:</font>
<font color="red"> 307.                 charset, language, value = decode_rfc2231(value)</font>
<font color="red"> 308.                 new_params.append((name, (charset, language, '&quot;%s&quot;' % value)))</font>
<font color="black"> 309.             else:</font>
<font color="red"> 310.                 new_params.append((name, '&quot;%s&quot;' % value))</font>
<font color="red"> 311.     return new_params</font>
<font color="black"> 312. </font>
<font color="green"> 313. def collapse_rfc2231_value(value, errors='replace',</font>
<font color="green"> 314.                            fallback_charset='us-ascii'):</font>
<font color="red"> 315.     if isinstance(value, tuple):</font>
<font color="red"> 316.         rawval = unquote(value[2])</font>
<font color="red"> 317.         charset = value[0] or 'us-ascii'</font>
<font color="red"> 318.         try:</font>
<font color="red"> 319.             return unicode(rawval, charset, errors)</font>
<font color="red"> 320.         except LookupError:</font>
<font color="black"> 321.             # XXX charset is unknown to Python.</font>
<font color="red"> 322.             return unicode(rawval, fallback_charset, errors)</font>
<font color="black"> 323.     else:</font>
<font color="red"> 324.         return unquote(value)</font>
</pre>

