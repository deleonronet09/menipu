source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/template/context.py</b><br>


file stats: <b>179 lines, 55 executed: 30.7% covered</b>
<pre>
<font color="green">   1. import warnings</font>
<font color="green">   2. from contextlib import contextmanager</font>
<font color="green">   3. from copy import copy</font>
<font color="black">   4. </font>
<font color="green">   5. from django.utils.deprecation import RemovedInDjango110Warning</font>
<font color="black">   6. </font>
<font color="black">   7. # Hard-coded processor for easier use of CSRF protection.</font>
<font color="green">   8. _builtin_context_processors = ('django.template.context_processors.csrf',)</font>
<font color="black">   9. </font>
<font color="green">  10. _current_app_undefined = object()</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. class ContextPopException(Exception):</font>
<font color="green">  14.     &quot;pop() has been called more times than push()&quot;</font>
<font color="green">  15.     pass</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. class ContextDict(dict):</font>
<font color="green">  19.     def __init__(self, context, *args, **kwargs):</font>
<font color="red">  20.         super(ContextDict, self).__init__(*args, **kwargs)</font>
<font color="black">  21. </font>
<font color="red">  22.         context.dicts.append(self)</font>
<font color="red">  23.         self.context = context</font>
<font color="black">  24. </font>
<font color="green">  25.     def __enter__(self):</font>
<font color="red">  26.         return self</font>
<font color="black">  27. </font>
<font color="green">  28.     def __exit__(self, *args, **kwargs):</font>
<font color="red">  29.         self.context.pop()</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. class BaseContext(object):</font>
<font color="green">  33.     def __init__(self, dict_=None):</font>
<font color="red">  34.         self._reset_dicts(dict_)</font>
<font color="black">  35. </font>
<font color="green">  36.     def _reset_dicts(self, value=None):</font>
<font color="red">  37.         builtins = {'True': True, 'False': False, 'None': None}</font>
<font color="red">  38.         self.dicts = [builtins]</font>
<font color="red">  39.         if value is not None:</font>
<font color="red">  40.             self.dicts.append(value)</font>
<font color="black">  41. </font>
<font color="green">  42.     def __copy__(self):</font>
<font color="red">  43.         duplicate = copy(super(BaseContext, self))</font>
<font color="red">  44.         duplicate.dicts = self.dicts[:]</font>
<font color="red">  45.         return duplicate</font>
<font color="black">  46. </font>
<font color="green">  47.     def __repr__(self):</font>
<font color="red">  48.         return repr(self.dicts)</font>
<font color="black">  49. </font>
<font color="green">  50.     def __iter__(self):</font>
<font color="red">  51.         for d in reversed(self.dicts):</font>
<font color="red">  52.             yield d</font>
<font color="black">  53. </font>
<font color="green">  54.     def push(self, *args, **kwargs):</font>
<font color="red">  55.         dicts = []</font>
<font color="red">  56.         for d in args:</font>
<font color="red">  57.             if isinstance(d, BaseContext):</font>
<font color="red">  58.                 dicts += d.dicts[1:]</font>
<font color="black">  59.             else:</font>
<font color="red">  60.                 dicts.append(d)</font>
<font color="red">  61.         return ContextDict(self, *dicts, **kwargs)</font>
<font color="black">  62. </font>
<font color="green">  63.     def pop(self):</font>
<font color="red">  64.         if len(self.dicts) == 1:</font>
<font color="red">  65.             raise ContextPopException</font>
<font color="red">  66.         return self.dicts.pop()</font>
<font color="black">  67. </font>
<font color="green">  68.     def __setitem__(self, key, value):</font>
<font color="black">  69.         &quot;Set a variable in the current context&quot;</font>
<font color="red">  70.         self.dicts[-1][key] = value</font>
<font color="black">  71. </font>
<font color="green">  72.     def __getitem__(self, key):</font>
<font color="black">  73.         &quot;Get a variable's value, starting at the current context and going upward&quot;</font>
<font color="red">  74.         for d in reversed(self.dicts):</font>
<font color="red">  75.             if key in d:</font>
<font color="red">  76.                 return d[key]</font>
<font color="red">  77.         raise KeyError(key)</font>
<font color="black">  78. </font>
<font color="green">  79.     def __delitem__(self, key):</font>
<font color="black">  80.         &quot;Delete a variable from the current context&quot;</font>
<font color="red">  81.         del self.dicts[-1][key]</font>
<font color="black">  82. </font>
<font color="green">  83.     def has_key(self, key):</font>
<font color="red">  84.         for d in self.dicts:</font>
<font color="red">  85.             if key in d:</font>
<font color="red">  86.                 return True</font>
<font color="red">  87.         return False</font>
<font color="black">  88. </font>
<font color="green">  89.     def __contains__(self, key):</font>
<font color="red">  90.         return self.has_key(key)</font>
<font color="black">  91. </font>
<font color="green">  92.     def get(self, key, otherwise=None):</font>
<font color="red">  93.         for d in reversed(self.dicts):</font>
<font color="red">  94.             if key in d:</font>
<font color="red">  95.                 return d[key]</font>
<font color="red">  96.         return otherwise</font>
<font color="black">  97. </font>
<font color="green">  98.     def setdefault(self, key, default=None):</font>
<font color="red">  99.         try:</font>
<font color="red"> 100.             return self[key]</font>
<font color="red"> 101.         except KeyError:</font>
<font color="red"> 102.             self[key] = default</font>
<font color="red"> 103.         return default</font>
<font color="black"> 104. </font>
<font color="green"> 105.     def new(self, values=None):</font>
<font color="black"> 106.         &quot;&quot;&quot;</font>
<font color="black"> 107.         Returns a new context with the same properties, but with only the</font>
<font color="black"> 108.         values given in 'values' stored.</font>
<font color="black"> 109.         &quot;&quot;&quot;</font>
<font color="red"> 110.         new_context = copy(self)</font>
<font color="red"> 111.         new_context._reset_dicts(values)</font>
<font color="red"> 112.         return new_context</font>
<font color="black"> 113. </font>
<font color="green"> 114.     def flatten(self):</font>
<font color="black"> 115.         &quot;&quot;&quot;</font>
<font color="black"> 116.         Returns self.dicts as one dictionary</font>
<font color="black"> 117.         &quot;&quot;&quot;</font>
<font color="red"> 118.         flat = {}</font>
<font color="red"> 119.         for d in self.dicts:</font>
<font color="red"> 120.             flat.update(d)</font>
<font color="red"> 121.         return flat</font>
<font color="black"> 122. </font>
<font color="green"> 123.     def __eq__(self, other):</font>
<font color="black"> 124.         &quot;&quot;&quot;</font>
<font color="black"> 125.         Compares two contexts by comparing theirs 'dicts' attributes.</font>
<font color="black"> 126.         &quot;&quot;&quot;</font>
<font color="red"> 127.         if isinstance(other, BaseContext):</font>
<font color="black"> 128.             # because dictionaries can be put in different order</font>
<font color="black"> 129.             # we have to flatten them like in templates</font>
<font color="red"> 130.             return self.flatten() == other.flatten()</font>
<font color="black"> 131. </font>
<font color="black"> 132.         # if it's not comparable return false</font>
<font color="red"> 133.         return False</font>
<font color="black"> 134. </font>
<font color="black"> 135. </font>
<font color="green"> 136. class Context(BaseContext):</font>
<font color="green"> 137.     &quot;A stack container for variable context&quot;</font>
<font color="green"> 138.     def __init__(self, dict_=None, autoescape=True,</font>
<font color="green"> 139.             current_app=_current_app_undefined,</font>
<font color="green"> 140.             use_l10n=None, use_tz=None):</font>
<font color="red"> 141.         if current_app is not _current_app_undefined:</font>
<font color="red"> 142.             warnings.warn(</font>
<font color="red"> 143.                 &quot;The current_app argument of Context is deprecated. Use &quot;</font>
<font color="black"> 144.                 &quot;RequestContext and set the current_app attribute of its &quot;</font>
<font color="red"> 145.                 &quot;request instead.&quot;, RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 146.         self.autoescape = autoescape</font>
<font color="red"> 147.         self._current_app = current_app</font>
<font color="red"> 148.         self.use_l10n = use_l10n</font>
<font color="red"> 149.         self.use_tz = use_tz</font>
<font color="red"> 150.         self.template_name = &quot;unknown&quot;</font>
<font color="red"> 151.         self.render_context = RenderContext()</font>
<font color="black"> 152.         # Set to the original template -- as opposed to extended or included</font>
<font color="black"> 153.         # templates -- during rendering, see bind_template.</font>
<font color="red"> 154.         self.template = None</font>
<font color="red"> 155.         super(Context, self).__init__(dict_)</font>
<font color="black"> 156. </font>
<font color="green"> 157.     @property</font>
<font color="black"> 158.     def current_app(self):</font>
<font color="red"> 159.         return None if self._current_app is _current_app_undefined else self._current_app</font>
<font color="black"> 160. </font>
<font color="green"> 161.     @property</font>
<font color="black"> 162.     def is_current_app_set(self):</font>
<font color="red"> 163.         return self._current_app is not _current_app_undefined</font>
<font color="black"> 164. </font>
<font color="green"> 165.     @contextmanager</font>
<font color="black"> 166.     def bind_template(self, template):</font>
<font color="red"> 167.         if self.template is not None:</font>
<font color="red"> 168.             raise RuntimeError(&quot;Context is already bound to a template&quot;)</font>
<font color="red"> 169.         self.template = template</font>
<font color="red"> 170.         try:</font>
<font color="red"> 171.             yield</font>
<font color="black"> 172.         finally:</font>
<font color="red"> 173.             self.template = None</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def __copy__(self):</font>
<font color="red"> 176.         duplicate = super(Context, self).__copy__()</font>
<font color="red"> 177.         duplicate.render_context = copy(self.render_context)</font>
<font color="red"> 178.         return duplicate</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def update(self, other_dict):</font>
<font color="black"> 181.         &quot;Pushes other_dict to the stack of dictionaries in the Context&quot;</font>
<font color="red"> 182.         if not hasattr(other_dict, '__getitem__'):</font>
<font color="red"> 183.             raise TypeError('other_dict must be a mapping (dictionary-like) object.')</font>
<font color="red"> 184.         if isinstance(other_dict, BaseContext):</font>
<font color="red"> 185.             other_dict = other_dict.dicts[1:].pop()</font>
<font color="red"> 186.         return ContextDict(self, other_dict)</font>
<font color="black"> 187. </font>
<font color="black"> 188. </font>
<font color="green"> 189. class RenderContext(BaseContext):</font>
<font color="black"> 190.     &quot;&quot;&quot;</font>
<font color="black"> 191.     A stack container for storing Template state.</font>
<font color="black"> 192. </font>
<font color="black"> 193.     RenderContext simplifies the implementation of template Nodes by providing a</font>
<font color="black"> 194.     safe place to store state between invocations of a node's `render` method.</font>
<font color="black"> 195. </font>
<font color="black"> 196.     The RenderContext also provides scoping rules that are more sensible for</font>
<font color="black"> 197.     'template local' variables. The render context stack is pushed before each</font>
<font color="black"> 198.     template is rendered, creating a fresh scope with nothing in it. Name</font>
<font color="black"> 199.     resolution fails if a variable is not found at the top of the RequestContext</font>
<font color="black"> 200.     stack. Thus, variables are local to a specific template and don't affect the</font>
<font color="black"> 201.     rendering of other templates as they would if they were stored in the normal</font>
<font color="black"> 202.     template context.</font>
<font color="green"> 203.     &quot;&quot;&quot;</font>
<font color="green"> 204.     def __iter__(self):</font>
<font color="red"> 205.         for d in self.dicts[-1]:</font>
<font color="red"> 206.             yield d</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def has_key(self, key):</font>
<font color="red"> 209.         return key in self.dicts[-1]</font>
<font color="black"> 210. </font>
<font color="green"> 211.     def get(self, key, otherwise=None):</font>
<font color="red"> 212.         return self.dicts[-1].get(key, otherwise)</font>
<font color="black"> 213. </font>
<font color="green"> 214.     def __getitem__(self, key):</font>
<font color="red"> 215.         return self.dicts[-1][key]</font>
<font color="black"> 216. </font>
<font color="black"> 217. </font>
<font color="green"> 218. class RequestContext(Context):</font>
<font color="black"> 219.     &quot;&quot;&quot;</font>
<font color="black"> 220.     This subclass of template.Context automatically populates itself using</font>
<font color="black"> 221.     the processors defined in the engine's configuration.</font>
<font color="black"> 222.     Additional processors can be specified as a list of callables</font>
<font color="black"> 223.     using the &quot;processors&quot; keyword argument.</font>
<font color="green"> 224.     &quot;&quot;&quot;</font>
<font color="green"> 225.     def __init__(self, request, dict_=None, processors=None,</font>
<font color="green"> 226.             current_app=_current_app_undefined,</font>
<font color="green"> 227.             use_l10n=None, use_tz=None):</font>
<font color="black"> 228.         # current_app isn't passed here to avoid triggering the deprecation</font>
<font color="black"> 229.         # warning in Context.__init__.</font>
<font color="red"> 230.         super(RequestContext, self).__init__(</font>
<font color="red"> 231.             dict_, use_l10n=use_l10n, use_tz=use_tz)</font>
<font color="red"> 232.         if current_app is not _current_app_undefined:</font>
<font color="red"> 233.             warnings.warn(</font>
<font color="red"> 234.                 &quot;The current_app argument of RequestContext is deprecated. &quot;</font>
<font color="black"> 235.                 &quot;Set the current_app attribute of its request instead.&quot;,</font>
<font color="red"> 236.                 RemovedInDjango110Warning, stacklevel=2)</font>
<font color="red"> 237.         self._current_app = current_app</font>
<font color="red"> 238.         self.request = request</font>
<font color="red"> 239.         self._processors = () if processors is None else tuple(processors)</font>
<font color="red"> 240.         self._processors_index = len(self.dicts)</font>
<font color="black"> 241. </font>
<font color="black"> 242.         # placeholder for context processors output</font>
<font color="red"> 243.         self.update({})</font>
<font color="black"> 244. </font>
<font color="black"> 245.         # empty dict for any new modifications</font>
<font color="black"> 246.         # (so that context processors don't overwrite them)</font>
<font color="red"> 247.         self.update({})</font>
<font color="black"> 248. </font>
<font color="green"> 249.     @contextmanager</font>
<font color="black"> 250.     def bind_template(self, template):</font>
<font color="red"> 251.         if self.template is not None:</font>
<font color="red"> 252.             raise RuntimeError(&quot;Context is already bound to a template&quot;)</font>
<font color="black"> 253. </font>
<font color="red"> 254.         self.template = template</font>
<font color="black"> 255.         # Set context processors according to the template engine's settings.</font>
<font color="red"> 256.         processors = (template.engine.template_context_processors +</font>
<font color="red"> 257.                       self._processors)</font>
<font color="red"> 258.         updates = {}</font>
<font color="red"> 259.         for processor in processors:</font>
<font color="red"> 260.             updates.update(processor(self.request))</font>
<font color="red"> 261.         self.dicts[self._processors_index] = updates</font>
<font color="black"> 262. </font>
<font color="red"> 263.         try:</font>
<font color="red"> 264.             yield</font>
<font color="black"> 265.         finally:</font>
<font color="red"> 266.             self.template = None</font>
<font color="black"> 267.             # Unset context processors.</font>
<font color="red"> 268.             self.dicts[self._processors_index] = {}</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def new(self, values=None):</font>
<font color="red"> 271.         new_context = super(RequestContext, self).new(values)</font>
<font color="black"> 272.         # This is for backwards-compatibility: RequestContexts created via</font>
<font color="black"> 273.         # Context.new don't include values from context processors.</font>
<font color="red"> 274.         if hasattr(new_context, '_processors_index'):</font>
<font color="red"> 275.             del new_context._processors_index</font>
<font color="red"> 276.         return new_context</font>
<font color="black"> 277. </font>
<font color="black"> 278. </font>
<font color="green"> 279. def make_context(context, request=None):</font>
<font color="black"> 280.     &quot;&quot;&quot;</font>
<font color="black"> 281.     Create a suitable Context from a plain dict and optionally an HttpRequest.</font>
<font color="black"> 282.     &quot;&quot;&quot;</font>
<font color="red"> 283.     if request is None:</font>
<font color="red"> 284.         context = Context(context)</font>
<font color="black"> 285.     else:</font>
<font color="black"> 286.         # The following pattern is required to ensure values from</font>
<font color="black"> 287.         # context override those from template context processors.</font>
<font color="red"> 288.         original_context = context</font>
<font color="red"> 289.         context = RequestContext(request)</font>
<font color="red"> 290.         if original_context:</font>
<font color="red"> 291.             context.push(original_context)</font>
<font color="red"> 292.     return context</font>
</pre>

