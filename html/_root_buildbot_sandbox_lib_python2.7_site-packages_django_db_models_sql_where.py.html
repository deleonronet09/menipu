source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/sql/where.py</b><br>


file stats: <b>131 lines, 62 executed: 47.3% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Code to manage the creation and SQL rendering of 'where' constraints.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. from django.db.models.sql.datastructures import EmptyResultSet</font>
<font color="green">   6. from django.utils import tree</font>
<font color="green">   7. from django.utils.functional import cached_property</font>
<font color="black">   8. </font>
<font color="black">   9. # Connection types</font>
<font color="green">  10. AND = 'AND'</font>
<font color="green">  11. OR = 'OR'</font>
<font color="black">  12. </font>
<font color="black">  13. </font>
<font color="green">  14. class WhereNode(tree.Node):</font>
<font color="black">  15.     &quot;&quot;&quot;</font>
<font color="black">  16.     Used to represent the SQL where-clause.</font>
<font color="black">  17. </font>
<font color="black">  18.     The class is tied to the Query class that created it (in order to create</font>
<font color="black">  19.     the correct SQL).</font>
<font color="black">  20. </font>
<font color="black">  21.     A child is usually an expression producing boolean values. Most likely the</font>
<font color="black">  22.     expression is a Lookup instance.</font>
<font color="black">  23. </font>
<font color="black">  24.     However, a child could also be any class with as_sql() and either</font>
<font color="black">  25.     relabeled_clone() method or relabel_aliases() and clone() methods and</font>
<font color="black">  26.     contains_aggregate attribute.</font>
<font color="green">  27.     &quot;&quot;&quot;</font>
<font color="green">  28.     default = AND</font>
<font color="black">  29. </font>
<font color="green">  30.     def split_having(self, negated=False):</font>
<font color="black">  31.         &quot;&quot;&quot;</font>
<font color="black">  32.         Returns two possibly None nodes: one for those parts of self that</font>
<font color="black">  33.         should be included in the WHERE clause and one for those parts of</font>
<font color="black">  34.         self that must be included in the HAVING clause.</font>
<font color="black">  35.         &quot;&quot;&quot;</font>
<font color="green">  36.         if not self.contains_aggregate:</font>
<font color="green">  37.             return self, None</font>
<font color="red">  38.         in_negated = negated ^ self.negated</font>
<font color="black">  39.         # If the effective connector is OR and this node contains an aggregate,</font>
<font color="black">  40.         # then we need to push the whole branch to HAVING clause.</font>
<font color="black">  41.         may_need_split = (</font>
<font color="red">  42.             (in_negated and self.connector == AND) or</font>
<font color="red">  43.             (not in_negated and self.connector == OR))</font>
<font color="red">  44.         if may_need_split and self.contains_aggregate:</font>
<font color="red">  45.             return None, self</font>
<font color="red">  46.         where_parts = []</font>
<font color="red">  47.         having_parts = []</font>
<font color="red">  48.         for c in self.children:</font>
<font color="red">  49.             if hasattr(c, 'split_having'):</font>
<font color="red">  50.                 where_part, having_part = c.split_having(in_negated)</font>
<font color="red">  51.                 if where_part is not None:</font>
<font color="red">  52.                     where_parts.append(where_part)</font>
<font color="red">  53.                 if having_part is not None:</font>
<font color="red">  54.                     having_parts.append(having_part)</font>
<font color="red">  55.             elif c.contains_aggregate:</font>
<font color="red">  56.                 having_parts.append(c)</font>
<font color="black">  57.             else:</font>
<font color="red">  58.                 where_parts.append(c)</font>
<font color="red">  59.         having_node = self.__class__(having_parts, self.connector, self.negated) if having_parts else None</font>
<font color="red">  60.         where_node = self.__class__(where_parts, self.connector, self.negated) if where_parts else None</font>
<font color="red">  61.         return where_node, having_node</font>
<font color="black">  62. </font>
<font color="green">  63.     def as_sql(self, compiler, connection):</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="black">  65.         Returns the SQL version of the where clause and the value to be</font>
<font color="black">  66.         substituted in. Returns '', [] if this node matches everything,</font>
<font color="black">  67.         None, [] if this node is empty, and raises EmptyResultSet if this</font>
<font color="black">  68.         node can't match anything.</font>
<font color="black">  69.         &quot;&quot;&quot;</font>
<font color="green">  70.         result = []</font>
<font color="green">  71.         result_params = []</font>
<font color="green">  72.         if self.connector == AND:</font>
<font color="green">  73.             full_needed, empty_needed = len(self.children), 1</font>
<font color="black">  74.         else:</font>
<font color="red">  75.             full_needed, empty_needed = 1, len(self.children)</font>
<font color="black">  76. </font>
<font color="green">  77.         for child in self.children:</font>
<font color="green">  78.             try:</font>
<font color="green">  79.                 sql, params = compiler.compile(child)</font>
<font color="red">  80.             except EmptyResultSet:</font>
<font color="red">  81.                 empty_needed -= 1</font>
<font color="black">  82.             else:</font>
<font color="green">  83.                 if sql:</font>
<font color="green">  84.                     result.append(sql)</font>
<font color="green">  85.                     result_params.extend(params)</font>
<font color="black">  86.                 else:</font>
<font color="red">  87.                     full_needed -= 1</font>
<font color="black">  88.             # Check if this node matches nothing or everything.</font>
<font color="black">  89.             # First check the amount of full nodes and empty nodes</font>
<font color="black">  90.             # to make this node empty/full.</font>
<font color="black">  91.             # Now, check if this node is full/empty using the</font>
<font color="black">  92.             # counts.</font>
<font color="green">  93.             if empty_needed == 0:</font>
<font color="red">  94.                 if self.negated:</font>
<font color="red">  95.                     return '', []</font>
<font color="black">  96.                 else:</font>
<font color="red">  97.                     raise EmptyResultSet</font>
<font color="green">  98.             if full_needed == 0:</font>
<font color="red">  99.                 if self.negated:</font>
<font color="red"> 100.                     raise EmptyResultSet</font>
<font color="black"> 101.                 else:</font>
<font color="red"> 102.                     return '', []</font>
<font color="green"> 103.         conn = ' %s ' % self.connector</font>
<font color="green"> 104.         sql_string = conn.join(result)</font>
<font color="green"> 105.         if sql_string:</font>
<font color="green"> 106.             if self.negated:</font>
<font color="black"> 107.                 # Some backends (Oracle at least) need parentheses</font>
<font color="black"> 108.                 # around the inner SQL in the negated case, even if the</font>
<font color="black"> 109.                 # inner SQL contains just a single expression.</font>
<font color="red"> 110.                 sql_string = 'NOT (%s)' % sql_string</font>
<font color="green"> 111.             elif len(result) &gt; 1:</font>
<font color="green"> 112.                 sql_string = '(%s)' % sql_string</font>
<font color="green"> 113.         return sql_string, result_params</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def get_group_by_cols(self):</font>
<font color="red"> 116.         cols = []</font>
<font color="red"> 117.         for child in self.children:</font>
<font color="red"> 118.             cols.extend(child.get_group_by_cols())</font>
<font color="red"> 119.         return cols</font>
<font color="black"> 120. </font>
<font color="green"> 121.     def relabel_aliases(self, change_map):</font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="black"> 123.         Relabels the alias values of any children. 'change_map' is a dictionary</font>
<font color="black"> 124.         mapping old (current) alias values to the new values.</font>
<font color="black"> 125.         &quot;&quot;&quot;</font>
<font color="red"> 126.         for pos, child in enumerate(self.children):</font>
<font color="red"> 127.             if hasattr(child, 'relabel_aliases'):</font>
<font color="black"> 128.                 # For example another WhereNode</font>
<font color="red"> 129.                 child.relabel_aliases(change_map)</font>
<font color="red"> 130.             elif hasattr(child, 'relabeled_clone'):</font>
<font color="red"> 131.                 self.children[pos] = child.relabeled_clone(change_map)</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def clone(self):</font>
<font color="black"> 134.         &quot;&quot;&quot;</font>
<font color="black"> 135.         Creates a clone of the tree. Must only be called on root nodes (nodes</font>
<font color="black"> 136.         with empty subtree_parents). Childs must be either (Contraint, lookup,</font>
<font color="black"> 137.         value) tuples, or objects supporting .clone().</font>
<font color="black"> 138.         &quot;&quot;&quot;</font>
<font color="green"> 139.         clone = self.__class__._new_instance(</font>
<font color="green"> 140.             children=[], connector=self.connector, negated=self.negated)</font>
<font color="green"> 141.         for child in self.children:</font>
<font color="green"> 142.             if hasattr(child, 'clone'):</font>
<font color="red"> 143.                 clone.children.append(child.clone())</font>
<font color="black"> 144.             else:</font>
<font color="green"> 145.                 clone.children.append(child)</font>
<font color="green"> 146.         return clone</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def relabeled_clone(self, change_map):</font>
<font color="red"> 149.         clone = self.clone()</font>
<font color="red"> 150.         clone.relabel_aliases(change_map)</font>
<font color="red"> 151.         return clone</font>
<font color="black"> 152. </font>
<font color="green"> 153.     @classmethod</font>
<font color="black"> 154.     def _contains_aggregate(cls, obj):</font>
<font color="green"> 155.         if isinstance(obj, tree.Node):</font>
<font color="green"> 156.             return any(cls._contains_aggregate(c) for c in obj.children)</font>
<font color="green"> 157.         return obj.contains_aggregate</font>
<font color="black"> 158. </font>
<font color="green"> 159.     @cached_property</font>
<font color="black"> 160.     def contains_aggregate(self):</font>
<font color="green"> 161.         return self._contains_aggregate(self)</font>
<font color="black"> 162. </font>
<font color="black"> 163. </font>
<font color="green"> 164. class NothingNode(object):</font>
<font color="black"> 165.     &quot;&quot;&quot;</font>
<font color="black"> 166.     A node that matches nothing.</font>
<font color="green"> 167.     &quot;&quot;&quot;</font>
<font color="green"> 168.     contains_aggregate = False</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def as_sql(self, compiler=None, connection=None):</font>
<font color="red"> 171.         raise EmptyResultSet</font>
<font color="black"> 172. </font>
<font color="black"> 173. </font>
<font color="green"> 174. class ExtraWhere(object):</font>
<font color="black"> 175.     # The contents are a black box - assume no aggregates are used.</font>
<font color="green"> 176.     contains_aggregate = False</font>
<font color="black"> 177. </font>
<font color="green"> 178.     def __init__(self, sqls, params):</font>
<font color="red"> 179.         self.sqls = sqls</font>
<font color="red"> 180.         self.params = params</font>
<font color="black"> 181. </font>
<font color="green"> 182.     def as_sql(self, compiler=None, connection=None):</font>
<font color="red"> 183.         sqls = [&quot;(%s)&quot; % sql for sql in self.sqls]</font>
<font color="red"> 184.         return &quot; AND &quot;.join(sqls), list(self.params or ())</font>
<font color="black"> 185. </font>
<font color="black"> 186. </font>
<font color="green"> 187. class SubqueryConstraint(object):</font>
<font color="black"> 188.     # Even if aggregates would be used in a subquery, the outer query isn't</font>
<font color="black"> 189.     # interested about those.</font>
<font color="green"> 190.     contains_aggregate = False</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def __init__(self, alias, columns, targets, query_object):</font>
<font color="red"> 193.         self.alias = alias</font>
<font color="red"> 194.         self.columns = columns</font>
<font color="red"> 195.         self.targets = targets</font>
<font color="red"> 196.         self.query_object = query_object</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def as_sql(self, compiler, connection):</font>
<font color="red"> 199.         query = self.query_object</font>
<font color="black"> 200. </font>
<font color="black"> 201.         # QuerySet was sent</font>
<font color="red"> 202.         if hasattr(query, 'values'):</font>
<font color="red"> 203.             if query._db and connection.alias != query._db:</font>
<font color="red"> 204.                 raise ValueError(&quot;Can't do subqueries with queries on different DBs.&quot;)</font>
<font color="black"> 205.             # Do not override already existing values.</font>
<font color="red"> 206.             if query._fields is None:</font>
<font color="red"> 207.                 query = query.values(*self.targets)</font>
<font color="black"> 208.             else:</font>
<font color="red"> 209.                 query = query._clone()</font>
<font color="red"> 210.             query = query.query</font>
<font color="red"> 211.             if query.can_filter():</font>
<font color="black"> 212.                 # If there is no slicing in use, then we can safely drop all ordering</font>
<font color="red"> 213.                 query.clear_ordering(True)</font>
<font color="black"> 214. </font>
<font color="red"> 215.         query_compiler = query.get_compiler(connection=connection)</font>
<font color="red"> 216.         return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)</font>
<font color="black"> 217. </font>
<font color="green"> 218.     def relabel_aliases(self, change_map):</font>
<font color="red"> 219.         self.alias = change_map.get(self.alias, self.alias)</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def clone(self):</font>
<font color="red"> 222.         return self.__class__(</font>
<font color="red"> 223.             self.alias, self.columns, self.targets,</font>
<font color="red"> 224.             self.query_object)</font>
</pre>

