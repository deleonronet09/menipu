source file: <b>/usr/lib/python2.7/unittest/util.py</b><br>


file stats: <b>121 lines, 13 executed: 10.7% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Various utility functions.&quot;&quot;&quot;</font>
<font color="green">   2. from collections import namedtuple, OrderedDict</font>
<font color="black">   3. </font>
<font color="black">   4. </font>
<font color="green">   5. __unittest = True</font>
<font color="black">   6. </font>
<font color="green">   7. _MAX_LENGTH = 80</font>
<font color="green">   8. def safe_repr(obj, short=False):</font>
<font color="red">   9.     try:</font>
<font color="red">  10.         result = repr(obj)</font>
<font color="red">  11.     except Exception:</font>
<font color="red">  12.         result = object.__repr__(obj)</font>
<font color="red">  13.     if not short or len(result) &lt; _MAX_LENGTH:</font>
<font color="red">  14.         return result</font>
<font color="red">  15.     return result[:_MAX_LENGTH] + ' [truncated]...'</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. def strclass(cls):</font>
<font color="green">  19.     return &quot;%s.%s&quot; % (cls.__module__, cls.__name__)</font>
<font color="black">  20. </font>
<font color="green">  21. def sorted_list_difference(expected, actual):</font>
<font color="black">  22.     &quot;&quot;&quot;Finds elements in only one or the other of two, sorted input lists.</font>
<font color="black">  23. </font>
<font color="black">  24.     Returns a two-element tuple of lists.    The first list contains those</font>
<font color="black">  25.     elements in the &quot;expected&quot; list but not in the &quot;actual&quot; list, and the</font>
<font color="black">  26.     second contains those elements in the &quot;actual&quot; list but not in the</font>
<font color="black">  27.     &quot;expected&quot; list.    Duplicate elements in either input list are ignored.</font>
<font color="black">  28.     &quot;&quot;&quot;</font>
<font color="red">  29.     i = j = 0</font>
<font color="red">  30.     missing = []</font>
<font color="red">  31.     unexpected = []</font>
<font color="red">  32.     while True:</font>
<font color="red">  33.         try:</font>
<font color="red">  34.             e = expected[i]</font>
<font color="red">  35.             a = actual[j]</font>
<font color="red">  36.             if e &lt; a:</font>
<font color="red">  37.                 missing.append(e)</font>
<font color="red">  38.                 i += 1</font>
<font color="red">  39.                 while expected[i] == e:</font>
<font color="red">  40.                     i += 1</font>
<font color="red">  41.             elif e &gt; a:</font>
<font color="red">  42.                 unexpected.append(a)</font>
<font color="red">  43.                 j += 1</font>
<font color="red">  44.                 while actual[j] == a:</font>
<font color="red">  45.                     j += 1</font>
<font color="black">  46.             else:</font>
<font color="red">  47.                 i += 1</font>
<font color="red">  48.                 try:</font>
<font color="red">  49.                     while expected[i] == e:</font>
<font color="red">  50.                         i += 1</font>
<font color="black">  51.                 finally:</font>
<font color="red">  52.                     j += 1</font>
<font color="red">  53.                     while actual[j] == a:</font>
<font color="red">  54.                         j += 1</font>
<font color="red">  55.         except IndexError:</font>
<font color="red">  56.             missing.extend(expected[i:])</font>
<font color="red">  57.             unexpected.extend(actual[j:])</font>
<font color="red">  58.             break</font>
<font color="red">  59.     return missing, unexpected</font>
<font color="black">  60. </font>
<font color="black">  61. </font>
<font color="green">  62. def unorderable_list_difference(expected, actual, ignore_duplicate=False):</font>
<font color="black">  63.     &quot;&quot;&quot;Same behavior as sorted_list_difference but</font>
<font color="black">  64.     for lists of unorderable items (like dicts).</font>
<font color="black">  65. </font>
<font color="black">  66.     As it does a linear search per item (remove) it</font>
<font color="black">  67.     has O(n*n) performance.</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="red">  69.     missing = []</font>
<font color="red">  70.     unexpected = []</font>
<font color="red">  71.     while expected:</font>
<font color="red">  72.         item = expected.pop()</font>
<font color="red">  73.         try:</font>
<font color="red">  74.             actual.remove(item)</font>
<font color="red">  75.         except ValueError:</font>
<font color="red">  76.             missing.append(item)</font>
<font color="red">  77.         if ignore_duplicate:</font>
<font color="red">  78.             for lst in expected, actual:</font>
<font color="red">  79.                 try:</font>
<font color="red">  80.                     while True:</font>
<font color="red">  81.                         lst.remove(item)</font>
<font color="red">  82.                 except ValueError:</font>
<font color="red">  83.                     pass</font>
<font color="red">  84.     if ignore_duplicate:</font>
<font color="red">  85.         while actual:</font>
<font color="red">  86.             item = actual.pop()</font>
<font color="red">  87.             unexpected.append(item)</font>
<font color="red">  88.             try:</font>
<font color="red">  89.                 while True:</font>
<font color="red">  90.                     actual.remove(item)</font>
<font color="red">  91.             except ValueError:</font>
<font color="red">  92.                 pass</font>
<font color="red">  93.         return missing, unexpected</font>
<font color="black">  94. </font>
<font color="black">  95.     # anything left in actual is unexpected</font>
<font color="red">  96.     return missing, actual</font>
<font color="black">  97. </font>
<font color="green">  98. _Mismatch = namedtuple('Mismatch', 'actual expected value')</font>
<font color="black">  99. </font>
<font color="green"> 100. def _count_diff_all_purpose(actual, expected):</font>
<font color="black"> 101.     'Returns list of (cnt_act, cnt_exp, elem) triples where the counts differ'</font>
<font color="black"> 102.     # elements need not be hashable</font>
<font color="red"> 103.     s, t = list(actual), list(expected)</font>
<font color="red"> 104.     m, n = len(s), len(t)</font>
<font color="red"> 105.     NULL = object()</font>
<font color="red"> 106.     result = []</font>
<font color="red"> 107.     for i, elem in enumerate(s):</font>
<font color="red"> 108.         if elem is NULL:</font>
<font color="red"> 109.             continue</font>
<font color="red"> 110.         cnt_s = cnt_t = 0</font>
<font color="red"> 111.         for j in range(i, m):</font>
<font color="red"> 112.             if s[j] == elem:</font>
<font color="red"> 113.                 cnt_s += 1</font>
<font color="red"> 114.                 s[j] = NULL</font>
<font color="red"> 115.         for j, other_elem in enumerate(t):</font>
<font color="red"> 116.             if other_elem == elem:</font>
<font color="red"> 117.                 cnt_t += 1</font>
<font color="red"> 118.                 t[j] = NULL</font>
<font color="red"> 119.         if cnt_s != cnt_t:</font>
<font color="red"> 120.             diff = _Mismatch(cnt_s, cnt_t, elem)</font>
<font color="red"> 121.             result.append(diff)</font>
<font color="black"> 122. </font>
<font color="red"> 123.     for i, elem in enumerate(t):</font>
<font color="red"> 124.         if elem is NULL:</font>
<font color="red"> 125.             continue</font>
<font color="red"> 126.         cnt_t = 0</font>
<font color="red"> 127.         for j in range(i, n):</font>
<font color="red"> 128.             if t[j] == elem:</font>
<font color="red"> 129.                 cnt_t += 1</font>
<font color="red"> 130.                 t[j] = NULL</font>
<font color="red"> 131.         diff = _Mismatch(0, cnt_t, elem)</font>
<font color="red"> 132.         result.append(diff)</font>
<font color="red"> 133.     return result</font>
<font color="black"> 134. </font>
<font color="green"> 135. def _ordered_count(iterable):</font>
<font color="black"> 136.     'Return dict of element counts, in the order they were first seen'</font>
<font color="red"> 137.     c = OrderedDict()</font>
<font color="red"> 138.     for elem in iterable:</font>
<font color="red"> 139.         c[elem] = c.get(elem, 0) + 1</font>
<font color="red"> 140.     return c</font>
<font color="black"> 141. </font>
<font color="green"> 142. def _count_diff_hashable(actual, expected):</font>
<font color="black"> 143.     'Returns list of (cnt_act, cnt_exp, elem) triples where the counts differ'</font>
<font color="black"> 144.     # elements must be hashable</font>
<font color="red"> 145.     s, t = _ordered_count(actual), _ordered_count(expected)</font>
<font color="red"> 146.     result = []</font>
<font color="red"> 147.     for elem, cnt_s in s.items():</font>
<font color="red"> 148.         cnt_t = t.get(elem, 0)</font>
<font color="red"> 149.         if cnt_s != cnt_t:</font>
<font color="red"> 150.             diff = _Mismatch(cnt_s, cnt_t, elem)</font>
<font color="red"> 151.             result.append(diff)</font>
<font color="red"> 152.     for elem, cnt_t in t.items():</font>
<font color="red"> 153.         if elem not in s:</font>
<font color="red"> 154.             diff = _Mismatch(0, cnt_t, elem)</font>
<font color="red"> 155.             result.append(diff)</font>
<font color="red"> 156.     return result</font>
</pre>

