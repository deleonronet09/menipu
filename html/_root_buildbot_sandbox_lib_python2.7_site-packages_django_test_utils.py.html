source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/test/utils.py</b><br>


file stats: <b>376 lines, 113 executed: 30.1% covered</b>
<pre>
<font color="green">   1. import logging</font>
<font color="green">   2. import re</font>
<font color="green">   3. import sys</font>
<font color="green">   4. import time</font>
<font color="green">   5. import warnings</font>
<font color="green">   6. from contextlib import contextmanager</font>
<font color="green">   7. from functools import wraps</font>
<font color="green">   8. from unittest import skipIf, skipUnless</font>
<font color="green">   9. from xml.dom.minidom import Node, parseString</font>
<font color="black">  10. </font>
<font color="green">  11. from django.apps import apps</font>
<font color="green">  12. from django.conf import UserSettingsHolder, settings</font>
<font color="green">  13. from django.core import mail</font>
<font color="green">  14. from django.core.signals import request_started</font>
<font color="green">  15. from django.core.urlresolvers import get_script_prefix, set_script_prefix</font>
<font color="green">  16. from django.db import reset_queries</font>
<font color="green">  17. from django.http import request</font>
<font color="green">  18. from django.template import Template</font>
<font color="green">  19. from django.test.signals import setting_changed, template_rendered</font>
<font color="green">  20. from django.utils import six</font>
<font color="green">  21. from django.utils.decorators import ContextDecorator</font>
<font color="green">  22. from django.utils.encoding import force_str</font>
<font color="green">  23. from django.utils.translation import deactivate</font>
<font color="black">  24. </font>
<font color="green">  25. try:</font>
<font color="green">  26.     import jinja2</font>
<font color="red">  27. except ImportError:</font>
<font color="red">  28.     jinja2 = None</font>
<font color="black">  29. </font>
<font color="black">  30. </font>
<font color="black">  31. __all__ = (</font>
<font color="black">  32.     'Approximate', 'ContextList', 'isolate_lru_cache', 'get_runner',</font>
<font color="black">  33.     'modify_settings', 'override_settings',</font>
<font color="black">  34.     'requires_tz_support',</font>
<font color="green">  35.     'setup_test_environment', 'teardown_test_environment',</font>
<font color="black">  36. )</font>
<font color="black">  37. </font>
<font color="green">  38. TZ_SUPPORT = hasattr(time, 'tzset')</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. class Approximate(object):</font>
<font color="green">  42.     def __init__(self, val, places=7):</font>
<font color="red">  43.         self.val = val</font>
<font color="red">  44.         self.places = places</font>
<font color="black">  45. </font>
<font color="green">  46.     def __repr__(self):</font>
<font color="red">  47.         return repr(self.val)</font>
<font color="black">  48. </font>
<font color="green">  49.     def __eq__(self, other):</font>
<font color="red">  50.         if self.val == other:</font>
<font color="red">  51.             return True</font>
<font color="red">  52.         return round(abs(self.val - other), self.places) == 0</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. class ContextList(list):</font>
<font color="black">  56.     &quot;&quot;&quot;A wrapper that provides direct key access to context items contained</font>
<font color="black">  57.     in a list of context objects.</font>
<font color="green">  58.     &quot;&quot;&quot;</font>
<font color="green">  59.     def __getitem__(self, key):</font>
<font color="red">  60.         if isinstance(key, six.string_types):</font>
<font color="red">  61.             for subcontext in self:</font>
<font color="red">  62.                 if key in subcontext:</font>
<font color="red">  63.                     return subcontext[key]</font>
<font color="red">  64.             raise KeyError(key)</font>
<font color="black">  65.         else:</font>
<font color="red">  66.             return super(ContextList, self).__getitem__(key)</font>
<font color="black">  67. </font>
<font color="green">  68.     def __contains__(self, key):</font>
<font color="red">  69.         try:</font>
<font color="red">  70.             self[key]</font>
<font color="red">  71.         except KeyError:</font>
<font color="red">  72.             return False</font>
<font color="red">  73.         return True</font>
<font color="black">  74. </font>
<font color="green">  75.     def keys(self):</font>
<font color="black">  76.         &quot;&quot;&quot;</font>
<font color="black">  77.         Flattened keys of subcontexts.</font>
<font color="black">  78.         &quot;&quot;&quot;</font>
<font color="red">  79.         keys = set()</font>
<font color="red">  80.         for subcontext in self:</font>
<font color="red">  81.             for dict in subcontext:</font>
<font color="red">  82.                 keys |= set(dict.keys())</font>
<font color="red">  83.         return keys</font>
<font color="black">  84. </font>
<font color="black">  85. </font>
<font color="green">  86. def instrumented_test_render(self, context):</font>
<font color="black">  87.     &quot;&quot;&quot;</font>
<font color="black">  88.     An instrumented Template render method, providing a signal</font>
<font color="black">  89.     that can be intercepted by the test system Client</font>
<font color="black">  90.     &quot;&quot;&quot;</font>
<font color="red">  91.     template_rendered.send(sender=self, template=self, context=context)</font>
<font color="red">  92.     return self.nodelist.render(context)</font>
<font color="black">  93. </font>
<font color="black">  94. </font>
<font color="green">  95. def setup_test_environment():</font>
<font color="black">  96.     &quot;&quot;&quot;Perform any global pre-test setup. This involves:</font>
<font color="black">  97. </font>
<font color="black">  98.         - Installing the instrumented test renderer</font>
<font color="black">  99.         - Set the email backend to the locmem email backend.</font>
<font color="black"> 100.         - Setting the active locale to match the LANGUAGE_CODE setting.</font>
<font color="black"> 101.     &quot;&quot;&quot;</font>
<font color="green"> 102.     Template._original_render = Template._render</font>
<font color="green"> 103.     Template._render = instrumented_test_render</font>
<font color="black"> 104. </font>
<font color="black"> 105.     # Storing previous values in the settings module itself is problematic.</font>
<font color="black"> 106.     # Store them in arbitrary (but related) modules instead. See #20636.</font>
<font color="black"> 107. </font>
<font color="green"> 108.     mail._original_email_backend = settings.EMAIL_BACKEND</font>
<font color="green"> 109.     settings.EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'</font>
<font color="black"> 110. </font>
<font color="green"> 111.     request._original_allowed_hosts = settings.ALLOWED_HOSTS</font>
<font color="green"> 112.     settings.ALLOWED_HOSTS = ['*']</font>
<font color="black"> 113. </font>
<font color="green"> 114.     mail.outbox = []</font>
<font color="black"> 115. </font>
<font color="green"> 116.     deactivate()</font>
<font color="black"> 117. </font>
<font color="black"> 118. </font>
<font color="green"> 119. def teardown_test_environment():</font>
<font color="black"> 120.     &quot;&quot;&quot;Perform any global post-test teardown. This involves:</font>
<font color="black"> 121. </font>
<font color="black"> 122.         - Restoring the original test renderer</font>
<font color="black"> 123.         - Restoring the email sending functions</font>
<font color="black"> 124.     &quot;&quot;&quot;</font>
<font color="green"> 125.     Template._render = Template._original_render</font>
<font color="green"> 126.     del Template._original_render</font>
<font color="black"> 127. </font>
<font color="green"> 128.     settings.EMAIL_BACKEND = mail._original_email_backend</font>
<font color="green"> 129.     del mail._original_email_backend</font>
<font color="black"> 130. </font>
<font color="green"> 131.     settings.ALLOWED_HOSTS = request._original_allowed_hosts</font>
<font color="green"> 132.     del request._original_allowed_hosts</font>
<font color="black"> 133. </font>
<font color="green"> 134.     del mail.outbox</font>
<font color="black"> 135. </font>
<font color="black"> 136. </font>
<font color="green"> 137. def get_runner(settings, test_runner_class=None):</font>
<font color="green"> 138.     if not test_runner_class:</font>
<font color="green"> 139.         test_runner_class = settings.TEST_RUNNER</font>
<font color="black"> 140. </font>
<font color="green"> 141.     test_path = test_runner_class.split('.')</font>
<font color="black"> 142.     # Allow for Python 2.5 relative paths</font>
<font color="green"> 143.     if len(test_path) &gt; 1:</font>
<font color="green"> 144.         test_module_name = '.'.join(test_path[:-1])</font>
<font color="black"> 145.     else:</font>
<font color="red"> 146.         test_module_name = '.'</font>
<font color="green"> 147.     test_module = __import__(test_module_name, {}, {}, force_str(test_path[-1]))</font>
<font color="green"> 148.     test_runner = getattr(test_module, test_path[-1])</font>
<font color="green"> 149.     return test_runner</font>
<font color="black"> 150. </font>
<font color="black"> 151. </font>
<font color="green"> 152. class override_settings(object):</font>
<font color="black"> 153.     &quot;&quot;&quot;</font>
<font color="black"> 154.     Acts as either a decorator, or a context manager. If it's a decorator it</font>
<font color="black"> 155.     takes a function and returns a wrapped function. If it's a contextmanager</font>
<font color="black"> 156.     it's used with the ``with`` statement. In either event entering/exiting</font>
<font color="black"> 157.     are called before and after, respectively, the function/block is executed.</font>
<font color="green"> 158.     &quot;&quot;&quot;</font>
<font color="green"> 159.     def __init__(self, **kwargs):</font>
<font color="red"> 160.         self.options = kwargs</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def __enter__(self):</font>
<font color="red"> 163.         self.enable()</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def __exit__(self, exc_type, exc_value, traceback):</font>
<font color="red"> 166.         self.disable()</font>
<font color="black"> 167. </font>
<font color="green"> 168.     def __call__(self, test_func):</font>
<font color="red"> 169.         from django.test import SimpleTestCase</font>
<font color="red"> 170.         if isinstance(test_func, type):</font>
<font color="red"> 171.             if not issubclass(test_func, SimpleTestCase):</font>
<font color="red"> 172.                 raise Exception(</font>
<font color="red"> 173.                     &quot;Only subclasses of Django SimpleTestCase can be decorated &quot;</font>
<font color="black"> 174.                     &quot;with override_settings&quot;)</font>
<font color="red"> 175.             self.save_options(test_func)</font>
<font color="red"> 176.             return test_func</font>
<font color="black"> 177.         else:</font>
<font color="red"> 178.             @wraps(test_func)</font>
<font color="black"> 179.             def inner(*args, **kwargs):</font>
<font color="red"> 180.                 with self:</font>
<font color="red"> 181.                     return test_func(*args, **kwargs)</font>
<font color="red"> 182.         return inner</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def save_options(self, test_func):</font>
<font color="red"> 185.         if test_func._overridden_settings is None:</font>
<font color="red"> 186.             test_func._overridden_settings = self.options</font>
<font color="black"> 187.         else:</font>
<font color="black"> 188.             # Duplicate dict to prevent subclasses from altering their parent.</font>
<font color="red"> 189.             test_func._overridden_settings = dict(</font>
<font color="red"> 190.                 test_func._overridden_settings, **self.options)</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def enable(self):</font>
<font color="black"> 193.         # Keep this code at the beginning to leave the settings unchanged</font>
<font color="black"> 194.         # in case it raises an exception because INSTALLED_APPS is invalid.</font>
<font color="red"> 195.         if 'INSTALLED_APPS' in self.options:</font>
<font color="red"> 196.             try:</font>
<font color="red"> 197.                 apps.set_installed_apps(self.options['INSTALLED_APPS'])</font>
<font color="red"> 198.             except Exception:</font>
<font color="red"> 199.                 apps.unset_installed_apps()</font>
<font color="red"> 200.                 raise</font>
<font color="red"> 201.         override = UserSettingsHolder(settings._wrapped)</font>
<font color="red"> 202.         for key, new_value in self.options.items():</font>
<font color="red"> 203.             setattr(override, key, new_value)</font>
<font color="red"> 204.         self.wrapped = settings._wrapped</font>
<font color="red"> 205.         settings._wrapped = override</font>
<font color="red"> 206.         for key, new_value in self.options.items():</font>
<font color="red"> 207.             setting_changed.send(sender=settings._wrapped.__class__,</font>
<font color="red"> 208.                                  setting=key, value=new_value, enter=True)</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def disable(self):</font>
<font color="red"> 211.         if 'INSTALLED_APPS' in self.options:</font>
<font color="red"> 212.             apps.unset_installed_apps()</font>
<font color="red"> 213.         settings._wrapped = self.wrapped</font>
<font color="red"> 214.         del self.wrapped</font>
<font color="red"> 215.         for key in self.options:</font>
<font color="red"> 216.             new_value = getattr(settings, key, None)</font>
<font color="red"> 217.             setting_changed.send(sender=settings._wrapped.__class__,</font>
<font color="red"> 218.                                  setting=key, value=new_value, enter=False)</font>
<font color="black"> 219. </font>
<font color="black"> 220. </font>
<font color="green"> 221. class modify_settings(override_settings):</font>
<font color="black"> 222.     &quot;&quot;&quot;</font>
<font color="black"> 223.     Like override_settings, but makes it possible to append, prepend or remove</font>
<font color="black"> 224.     items instead of redefining the entire list.</font>
<font color="green"> 225.     &quot;&quot;&quot;</font>
<font color="green"> 226.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 227.         if args:</font>
<font color="black"> 228.             # Hack used when instantiating from SimpleTestCase.setUpClass.</font>
<font color="red"> 229.             assert not kwargs</font>
<font color="red"> 230.             self.operations = args[0]</font>
<font color="black"> 231.         else:</font>
<font color="red"> 232.             assert not args</font>
<font color="red"> 233.             self.operations = list(kwargs.items())</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def save_options(self, test_func):</font>
<font color="red"> 236.         if test_func._modified_settings is None:</font>
<font color="red"> 237.             test_func._modified_settings = self.operations</font>
<font color="black"> 238.         else:</font>
<font color="black"> 239.             # Duplicate list to prevent subclasses from altering their parent.</font>
<font color="red"> 240.             test_func._modified_settings = list(</font>
<font color="red"> 241.                 test_func._modified_settings) + self.operations</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def enable(self):</font>
<font color="red"> 244.         self.options = {}</font>
<font color="red"> 245.         for name, operations in self.operations:</font>
<font color="red"> 246.             try:</font>
<font color="black"> 247.                 # When called from SimpleTestCase.setUpClass, values may be</font>
<font color="black"> 248.                 # overridden several times; cumulate changes.</font>
<font color="red"> 249.                 value = self.options[name]</font>
<font color="red"> 250.             except KeyError:</font>
<font color="red"> 251.                 value = list(getattr(settings, name, []))</font>
<font color="red"> 252.             for action, items in operations.items():</font>
<font color="black"> 253.                 # items my be a single value or an iterable.</font>
<font color="red"> 254.                 if isinstance(items, six.string_types):</font>
<font color="red"> 255.                     items = [items]</font>
<font color="red"> 256.                 if action == 'append':</font>
<font color="red"> 257.                     value = value + [item for item in items if item not in value]</font>
<font color="red"> 258.                 elif action == 'prepend':</font>
<font color="red"> 259.                     value = [item for item in items if item not in value] + value</font>
<font color="red"> 260.                 elif action == 'remove':</font>
<font color="red"> 261.                     value = [item for item in value if item not in items]</font>
<font color="black"> 262.                 else:</font>
<font color="red"> 263.                     raise ValueError(&quot;Unsupported action: %s&quot; % action)</font>
<font color="red"> 264.             self.options[name] = value</font>
<font color="red"> 265.         super(modify_settings, self).enable()</font>
<font color="black"> 266. </font>
<font color="black"> 267. </font>
<font color="green"> 268. def override_system_checks(new_checks, deployment_checks=None):</font>
<font color="black"> 269.     &quot;&quot;&quot; Acts as a decorator. Overrides list of registered system checks.</font>
<font color="black"> 270.     Useful when you override `INSTALLED_APPS`, e.g. if you exclude `auth` app,</font>
<font color="black"> 271.     you also need to exclude its system checks. &quot;&quot;&quot;</font>
<font color="black"> 272. </font>
<font color="red"> 273.     from django.core.checks.registry import registry</font>
<font color="black"> 274. </font>
<font color="red"> 275.     def outer(test_func):</font>
<font color="red"> 276.         @wraps(test_func)</font>
<font color="black"> 277.         def inner(*args, **kwargs):</font>
<font color="red"> 278.             old_checks = registry.registered_checks</font>
<font color="red"> 279.             registry.registered_checks = new_checks</font>
<font color="red"> 280.             old_deployment_checks = registry.deployment_checks</font>
<font color="red"> 281.             if deployment_checks is not None:</font>
<font color="red"> 282.                 registry.deployment_checks = deployment_checks</font>
<font color="red"> 283.             try:</font>
<font color="red"> 284.                 return test_func(*args, **kwargs)</font>
<font color="black"> 285.             finally:</font>
<font color="red"> 286.                 registry.registered_checks = old_checks</font>
<font color="red"> 287.                 registry.deployment_checks = old_deployment_checks</font>
<font color="red"> 288.         return inner</font>
<font color="red"> 289.     return outer</font>
<font color="black"> 290. </font>
<font color="black"> 291. </font>
<font color="green"> 292. def compare_xml(want, got):</font>
<font color="black"> 293.     &quot;&quot;&quot;Tries to do a 'xml-comparison' of want and got.  Plain string</font>
<font color="black"> 294.     comparison doesn't always work because, for example, attribute</font>
<font color="black"> 295.     ordering should not be important. Comment nodes are not considered in the</font>
<font color="black"> 296.     comparison.</font>
<font color="black"> 297. </font>
<font color="black"> 298.     Based on http://codespeak.net/svn/lxml/trunk/src/lxml/doctestcompare.py</font>
<font color="black"> 299.     &quot;&quot;&quot;</font>
<font color="red"> 300.     _norm_whitespace_re = re.compile(r'[ \t\n][ \t\n]+')</font>
<font color="black"> 301. </font>
<font color="red"> 302.     def norm_whitespace(v):</font>
<font color="red"> 303.         return _norm_whitespace_re.sub(' ', v)</font>
<font color="black"> 304. </font>
<font color="red"> 305.     def child_text(element):</font>
<font color="red"> 306.         return ''.join(c.data for c in element.childNodes</font>
<font color="red"> 307.                        if c.nodeType == Node.TEXT_NODE)</font>
<font color="black"> 308. </font>
<font color="red"> 309.     def children(element):</font>
<font color="red"> 310.         return [c for c in element.childNodes</font>
<font color="red"> 311.                 if c.nodeType == Node.ELEMENT_NODE]</font>
<font color="black"> 312. </font>
<font color="red"> 313.     def norm_child_text(element):</font>
<font color="red"> 314.         return norm_whitespace(child_text(element))</font>
<font color="black"> 315. </font>
<font color="red"> 316.     def attrs_dict(element):</font>
<font color="red"> 317.         return dict(element.attributes.items())</font>
<font color="black"> 318. </font>
<font color="red"> 319.     def check_element(want_element, got_element):</font>
<font color="red"> 320.         if want_element.tagName != got_element.tagName:</font>
<font color="red"> 321.             return False</font>
<font color="red"> 322.         if norm_child_text(want_element) != norm_child_text(got_element):</font>
<font color="red"> 323.             return False</font>
<font color="red"> 324.         if attrs_dict(want_element) != attrs_dict(got_element):</font>
<font color="red"> 325.             return False</font>
<font color="red"> 326.         want_children = children(want_element)</font>
<font color="red"> 327.         got_children = children(got_element)</font>
<font color="red"> 328.         if len(want_children) != len(got_children):</font>
<font color="red"> 329.             return False</font>
<font color="red"> 330.         for want, got in zip(want_children, got_children):</font>
<font color="red"> 331.             if not check_element(want, got):</font>
<font color="red"> 332.                 return False</font>
<font color="red"> 333.         return True</font>
<font color="black"> 334. </font>
<font color="red"> 335.     def first_node(document):</font>
<font color="red"> 336.         for node in document.childNodes:</font>
<font color="red"> 337.             if node.nodeType != Node.COMMENT_NODE:</font>
<font color="red"> 338.                 return node</font>
<font color="black"> 339. </font>
<font color="red"> 340.     want, got = strip_quotes(want, got)</font>
<font color="red"> 341.     want = want.replace('\\n', '\n')</font>
<font color="red"> 342.     got = got.replace('\\n', '\n')</font>
<font color="black"> 343. </font>
<font color="black"> 344.     # If the string is not a complete xml document, we may need to add a</font>
<font color="black"> 345.     # root element. This allow us to compare fragments, like &quot;&lt;foo/&gt;&lt;bar/&gt;&quot;</font>
<font color="red"> 346.     if not want.startswith('&lt;?xml'):</font>
<font color="red"> 347.         wrapper = '&lt;root&gt;%s&lt;/root&gt;'</font>
<font color="red"> 348.         want = wrapper % want</font>
<font color="red"> 349.         got = wrapper % got</font>
<font color="black"> 350. </font>
<font color="black"> 351.     # Parse the want and got strings, and compare the parsings.</font>
<font color="red"> 352.     want_root = first_node(parseString(want))</font>
<font color="red"> 353.     got_root = first_node(parseString(got))</font>
<font color="black"> 354. </font>
<font color="red"> 355.     return check_element(want_root, got_root)</font>
<font color="black"> 356. </font>
<font color="black"> 357. </font>
<font color="green"> 358. def strip_quotes(want, got):</font>
<font color="black"> 359.     &quot;&quot;&quot;</font>
<font color="black"> 360.     Strip quotes of doctests output values:</font>
<font color="black"> 361. </font>
<font color="black"> 362.     &gt;&gt;&gt; strip_quotes(&quot;'foo'&quot;)</font>
<font color="black"> 363.     &quot;foo&quot;</font>
<font color="black"> 364.     &gt;&gt;&gt; strip_quotes('&quot;foo&quot;')</font>
<font color="black"> 365.     &quot;foo&quot;</font>
<font color="black"> 366.     &quot;&quot;&quot;</font>
<font color="red"> 367.     def is_quoted_string(s):</font>
<font color="red"> 368.         s = s.strip()</font>
<font color="red"> 369.         return (len(s) &gt;= 2</font>
<font color="red"> 370.                 and s[0] == s[-1]</font>
<font color="red"> 371.                 and s[0] in ('&quot;', &quot;'&quot;))</font>
<font color="black"> 372. </font>
<font color="red"> 373.     def is_quoted_unicode(s):</font>
<font color="red"> 374.         s = s.strip()</font>
<font color="red"> 375.         return (len(s) &gt;= 3</font>
<font color="red"> 376.                 and s[0] == 'u'</font>
<font color="red"> 377.                 and s[1] == s[-1]</font>
<font color="red"> 378.                 and s[1] in ('&quot;', &quot;'&quot;))</font>
<font color="black"> 379. </font>
<font color="red"> 380.     if is_quoted_string(want) and is_quoted_string(got):</font>
<font color="red"> 381.         want = want.strip()[1:-1]</font>
<font color="red"> 382.         got = got.strip()[1:-1]</font>
<font color="red"> 383.     elif is_quoted_unicode(want) and is_quoted_unicode(got):</font>
<font color="red"> 384.         want = want.strip()[2:-1]</font>
<font color="red"> 385.         got = got.strip()[2:-1]</font>
<font color="red"> 386.     return want, got</font>
<font color="black"> 387. </font>
<font color="black"> 388. </font>
<font color="green"> 389. def str_prefix(s):</font>
<font color="red"> 390.     return s % {'_': '' if six.PY3 else 'u'}</font>
<font color="black"> 391. </font>
<font color="black"> 392. </font>
<font color="green"> 393. class CaptureQueriesContext(object):</font>
<font color="black"> 394.     &quot;&quot;&quot;</font>
<font color="black"> 395.     Context manager that captures queries executed by the specified connection.</font>
<font color="green"> 396.     &quot;&quot;&quot;</font>
<font color="green"> 397.     def __init__(self, connection):</font>
<font color="red"> 398.         self.connection = connection</font>
<font color="black"> 399. </font>
<font color="green"> 400.     def __iter__(self):</font>
<font color="red"> 401.         return iter(self.captured_queries)</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def __getitem__(self, index):</font>
<font color="red"> 404.         return self.captured_queries[index]</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def __len__(self):</font>
<font color="red"> 407.         return len(self.captured_queries)</font>
<font color="black"> 408. </font>
<font color="green"> 409.     @property</font>
<font color="black"> 410.     def captured_queries(self):</font>
<font color="red"> 411.         return self.connection.queries[self.initial_queries:self.final_queries]</font>
<font color="black"> 412. </font>
<font color="green"> 413.     def __enter__(self):</font>
<font color="red"> 414.         self.force_debug_cursor = self.connection.force_debug_cursor</font>
<font color="red"> 415.         self.connection.force_debug_cursor = True</font>
<font color="red"> 416.         self.initial_queries = len(self.connection.queries_log)</font>
<font color="red"> 417.         self.final_queries = None</font>
<font color="red"> 418.         request_started.disconnect(reset_queries)</font>
<font color="red"> 419.         return self</font>
<font color="black"> 420. </font>
<font color="green"> 421.     def __exit__(self, exc_type, exc_value, traceback):</font>
<font color="red"> 422.         self.connection.force_debug_cursor = self.force_debug_cursor</font>
<font color="red"> 423.         request_started.connect(reset_queries)</font>
<font color="red"> 424.         if exc_type is not None:</font>
<font color="red"> 425.             return</font>
<font color="red"> 426.         self.final_queries = len(self.connection.queries_log)</font>
<font color="black"> 427. </font>
<font color="black"> 428. </font>
<font color="green"> 429. class ignore_warnings(object):</font>
<font color="green"> 430.     def __init__(self, **kwargs):</font>
<font color="red"> 431.         self.ignore_kwargs = kwargs</font>
<font color="red"> 432.         if 'message' in self.ignore_kwargs or 'module' in self.ignore_kwargs:</font>
<font color="red"> 433.             self.filter_func = warnings.filterwarnings</font>
<font color="black"> 434.         else:</font>
<font color="red"> 435.             self.filter_func = warnings.simplefilter</font>
<font color="black"> 436. </font>
<font color="green"> 437.     def __call__(self, decorated):</font>
<font color="red"> 438.         if isinstance(decorated, type):</font>
<font color="black"> 439.             # A class is decorated</font>
<font color="red"> 440.             saved_setUp = decorated.setUp</font>
<font color="red"> 441.             saved_tearDown = decorated.tearDown</font>
<font color="black"> 442. </font>
<font color="red"> 443.             def setUp(inner_self):</font>
<font color="red"> 444.                 self.catch_warnings = warnings.catch_warnings()</font>
<font color="red"> 445.                 self.catch_warnings.__enter__()</font>
<font color="red"> 446.                 self.filter_func('ignore', **self.ignore_kwargs)</font>
<font color="red"> 447.                 saved_setUp(inner_self)</font>
<font color="black"> 448. </font>
<font color="red"> 449.             def tearDown(inner_self):</font>
<font color="red"> 450.                 saved_tearDown(inner_self)</font>
<font color="red"> 451.                 self.catch_warnings.__exit__(*sys.exc_info())</font>
<font color="black"> 452. </font>
<font color="red"> 453.             decorated.setUp = setUp</font>
<font color="red"> 454.             decorated.tearDown = tearDown</font>
<font color="red"> 455.             return decorated</font>
<font color="black"> 456.         else:</font>
<font color="red"> 457.             @wraps(decorated)</font>
<font color="black"> 458.             def inner(*args, **kwargs):</font>
<font color="red"> 459.                 with warnings.catch_warnings():</font>
<font color="red"> 460.                     self.filter_func('ignore', **self.ignore_kwargs)</font>
<font color="red"> 461.                     return decorated(*args, **kwargs)</font>
<font color="red"> 462.             return inner</font>
<font color="black"> 463. </font>
<font color="black"> 464. </font>
<font color="green"> 465. @contextmanager</font>
<font color="black"> 466. def patch_logger(logger_name, log_level):</font>
<font color="black"> 467.     &quot;&quot;&quot;</font>
<font color="black"> 468.     Context manager that takes a named logger and the logging level</font>
<font color="black"> 469.     and provides a simple mock-like list of messages received</font>
<font color="black"> 470.     &quot;&quot;&quot;</font>
<font color="red"> 471.     calls = []</font>
<font color="black"> 472. </font>
<font color="red"> 473.     def replacement(msg, *args, **kwargs):</font>
<font color="red"> 474.         calls.append(msg % args)</font>
<font color="red"> 475.     logger = logging.getLogger(logger_name)</font>
<font color="red"> 476.     orig = getattr(logger, log_level)</font>
<font color="red"> 477.     setattr(logger, log_level, replacement)</font>
<font color="red"> 478.     try:</font>
<font color="red"> 479.         yield calls</font>
<font color="black"> 480.     finally:</font>
<font color="red"> 481.         setattr(logger, log_level, orig)</font>
<font color="black"> 482. </font>
<font color="black"> 483. </font>
<font color="black"> 484. # On OSes that don't provide tzset (Windows), we can't set the timezone</font>
<font color="black"> 485. # in which the program runs. As a consequence, we must skip tests that</font>
<font color="black"> 486. # don't enforce a specific timezone (with timezone.override or equivalent),</font>
<font color="black"> 487. # or attempt to interpret naive datetimes in the default timezone.</font>
<font color="black"> 488. </font>
<font color="green"> 489. requires_tz_support = skipUnless(TZ_SUPPORT,</font>
<font color="green"> 490.         &quot;This test relies on the ability to run a program in an arbitrary &quot;</font>
<font color="black"> 491.         &quot;time zone, but your operating system isn't able to do that.&quot;)</font>
<font color="black"> 492. </font>
<font color="black"> 493. </font>
<font color="green"> 494. @contextmanager</font>
<font color="black"> 495. def extend_sys_path(*paths):</font>
<font color="black"> 496.     &quot;&quot;&quot;Context manager to temporarily add paths to sys.path.&quot;&quot;&quot;</font>
<font color="red"> 497.     _orig_sys_path = sys.path[:]</font>
<font color="red"> 498.     sys.path.extend(paths)</font>
<font color="red"> 499.     try:</font>
<font color="red"> 500.         yield</font>
<font color="black"> 501.     finally:</font>
<font color="red"> 502.         sys.path = _orig_sys_path</font>
<font color="black"> 503. </font>
<font color="black"> 504. </font>
<font color="green"> 505. @contextmanager</font>
<font color="black"> 506. def isolate_lru_cache(lru_cache_object):</font>
<font color="black"> 507.     &quot;&quot;&quot;Clear the cache of an LRU cache object on entering and exiting.&quot;&quot;&quot;</font>
<font color="red"> 508.     lru_cache_object.cache_clear()</font>
<font color="red"> 509.     try:</font>
<font color="red"> 510.         yield</font>
<font color="black"> 511.     finally:</font>
<font color="red"> 512.         lru_cache_object.cache_clear()</font>
<font color="black"> 513. </font>
<font color="black"> 514. </font>
<font color="green"> 515. @contextmanager</font>
<font color="black"> 516. def captured_output(stream_name):</font>
<font color="black"> 517.     &quot;&quot;&quot;Return a context manager used by captured_stdout/stdin/stderr</font>
<font color="black"> 518.     that temporarily replaces the sys stream *stream_name* with a StringIO.</font>
<font color="black"> 519. </font>
<font color="black"> 520.     Note: This function and the following ``captured_std*`` are copied</font>
<font color="black"> 521.           from CPython's ``test.support`` module.&quot;&quot;&quot;</font>
<font color="red"> 522.     orig_stdout = getattr(sys, stream_name)</font>
<font color="red"> 523.     setattr(sys, stream_name, six.StringIO())</font>
<font color="red"> 524.     try:</font>
<font color="red"> 525.         yield getattr(sys, stream_name)</font>
<font color="black"> 526.     finally:</font>
<font color="red"> 527.         setattr(sys, stream_name, orig_stdout)</font>
<font color="black"> 528. </font>
<font color="black"> 529. </font>
<font color="green"> 530. def captured_stdout():</font>
<font color="black"> 531.     &quot;&quot;&quot;Capture the output of sys.stdout:</font>
<font color="black"> 532. </font>
<font color="black"> 533.        with captured_stdout() as stdout:</font>
<font color="black"> 534.            print(&quot;hello&quot;)</font>
<font color="black"> 535.        self.assertEqual(stdout.getvalue(), &quot;hello\n&quot;)</font>
<font color="black"> 536.     &quot;&quot;&quot;</font>
<font color="red"> 537.     return captured_output(&quot;stdout&quot;)</font>
<font color="black"> 538. </font>
<font color="black"> 539. </font>
<font color="green"> 540. def captured_stderr():</font>
<font color="black"> 541.     &quot;&quot;&quot;Capture the output of sys.stderr:</font>
<font color="black"> 542. </font>
<font color="black"> 543.        with captured_stderr() as stderr:</font>
<font color="black"> 544.            print(&quot;hello&quot;, file=sys.stderr)</font>
<font color="black"> 545.        self.assertEqual(stderr.getvalue(), &quot;hello\n&quot;)</font>
<font color="black"> 546.     &quot;&quot;&quot;</font>
<font color="red"> 547.     return captured_output(&quot;stderr&quot;)</font>
<font color="black"> 548. </font>
<font color="black"> 549. </font>
<font color="green"> 550. def captured_stdin():</font>
<font color="black"> 551.     &quot;&quot;&quot;Capture the input to sys.stdin:</font>
<font color="black"> 552. </font>
<font color="black"> 553.        with captured_stdin() as stdin:</font>
<font color="black"> 554.            stdin.write('hello\n')</font>
<font color="black"> 555.            stdin.seek(0)</font>
<font color="black"> 556.            # call test code that consumes from sys.stdin</font>
<font color="black"> 557.            captured = input()</font>
<font color="black"> 558.        self.assertEqual(captured, &quot;hello&quot;)</font>
<font color="black"> 559.     &quot;&quot;&quot;</font>
<font color="red"> 560.     return captured_output(&quot;stdin&quot;)</font>
<font color="black"> 561. </font>
<font color="black"> 562. </font>
<font color="green"> 563. def reset_warning_registry():</font>
<font color="black"> 564.     &quot;&quot;&quot;</font>
<font color="black"> 565.     Clear warning registry for all modules. This is required in some tests</font>
<font color="black"> 566.     because of a bug in Python that prevents warnings.simplefilter(&quot;always&quot;)</font>
<font color="black"> 567.     from always making warnings appear: http://bugs.python.org/issue4180</font>
<font color="black"> 568. </font>
<font color="black"> 569.     The bug was fixed in Python 3.4.2.</font>
<font color="black"> 570.     &quot;&quot;&quot;</font>
<font color="red"> 571.     key = &quot;__warningregistry__&quot;</font>
<font color="red"> 572.     for mod in sys.modules.values():</font>
<font color="red"> 573.         if hasattr(mod, key):</font>
<font color="red"> 574.             getattr(mod, key).clear()</font>
<font color="black"> 575. </font>
<font color="black"> 576. </font>
<font color="green"> 577. @contextmanager</font>
<font color="black"> 578. def freeze_time(t):</font>
<font color="black"> 579.     &quot;&quot;&quot;</font>
<font color="black"> 580.     Context manager to temporarily freeze time.time(). This temporarily</font>
<font color="black"> 581.     modifies the time function of the time module. Modules which import the</font>
<font color="black"> 582.     time function directly (e.g. `from time import time`) won't be affected</font>
<font color="black"> 583.     This isn't meant as a public API, but helps reduce some repetitive code in</font>
<font color="black"> 584.     Django's test suite.</font>
<font color="black"> 585.     &quot;&quot;&quot;</font>
<font color="red"> 586.     _real_time = time.time</font>
<font color="red"> 587.     time.time = lambda: t</font>
<font color="red"> 588.     try:</font>
<font color="red"> 589.         yield</font>
<font color="black"> 590.     finally:</font>
<font color="red"> 591.         time.time = _real_time</font>
<font color="black"> 592. </font>
<font color="black"> 593. </font>
<font color="green"> 594. def require_jinja2(test_func):</font>
<font color="black"> 595.     &quot;&quot;&quot;</font>
<font color="black"> 596.     Decorator to enable a Jinja2 template engine in addition to the regular</font>
<font color="black"> 597.     Django template engine for a test or skip it if Jinja2 isn't available.</font>
<font color="black"> 598.     &quot;&quot;&quot;</font>
<font color="red"> 599.     test_func = skipIf(jinja2 is None, &quot;this test requires jinja2&quot;)(test_func)</font>
<font color="red"> 600.     test_func = override_settings(TEMPLATES=[{</font>
<font color="red"> 601.         'BACKEND': 'django.template.backends.django.DjangoTemplates',</font>
<font color="red"> 602.         'APP_DIRS': True,</font>
<font color="red"> 603.     }, {</font>
<font color="red"> 604.         'BACKEND': 'django.template.backends.jinja2.Jinja2',</font>
<font color="red"> 605.         'APP_DIRS': True,</font>
<font color="red"> 606.         'OPTIONS': {'keep_trailing_newline': True},</font>
<font color="red"> 607.     }])(test_func)</font>
<font color="red"> 608.     return test_func</font>
<font color="black"> 609. </font>
<font color="black"> 610. </font>
<font color="green"> 611. class ScriptPrefix(ContextDecorator):</font>
<font color="green"> 612.     def __enter__(self):</font>
<font color="red"> 613.         set_script_prefix(self.prefix)</font>
<font color="black"> 614. </font>
<font color="green"> 615.     def __exit__(self, exc_type, exc_val, traceback):</font>
<font color="red"> 616.         set_script_prefix(self.old_prefix)</font>
<font color="black"> 617. </font>
<font color="green"> 618.     def __init__(self, prefix):</font>
<font color="red"> 619.         self.prefix = prefix</font>
<font color="red"> 620.         self.old_prefix = get_script_prefix()</font>
<font color="black"> 621. </font>
<font color="black"> 622. </font>
<font color="green"> 623. def override_script_prefix(prefix):</font>
<font color="black"> 624.     &quot;&quot;&quot;</font>
<font color="black"> 625.     Decorator or context manager to temporary override the script prefix.</font>
<font color="black"> 626.     &quot;&quot;&quot;</font>
<font color="red"> 627.     return ScriptPrefix(prefix)</font>
<font color="black"> 628. </font>
<font color="black"> 629. </font>
<font color="green"> 630. class LoggingCaptureMixin(object):</font>
<font color="black"> 631.     &quot;&quot;&quot;</font>
<font color="black"> 632.     Capture the output from the 'django' logger and store it on the class's</font>
<font color="black"> 633.     logger_output attribute.</font>
<font color="green"> 634.     &quot;&quot;&quot;</font>
<font color="green"> 635.     def setUp(self):</font>
<font color="red"> 636.         self.logger = logging.getLogger('django')</font>
<font color="red"> 637.         self.old_stream = self.logger.handlers[0].stream</font>
<font color="red"> 638.         self.logger_output = six.StringIO()</font>
<font color="red"> 639.         self.logger.handlers[0].stream = self.logger_output</font>
<font color="black"> 640. </font>
<font color="green"> 641.     def tearDown(self):</font>
<font color="red"> 642.         self.logger.handlers[0].stream = self.old_stream</font>
</pre>

