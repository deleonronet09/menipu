source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/middleware/csrf.py</b><br>


file stats: <b>115 lines, 30 executed: 26.1% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Cross Site Request Forgery Middleware.</font>
<font color="black">   3. </font>
<font color="black">   4. This module provides a middleware that implements protection</font>
<font color="black">   5. against request forgeries from other sites.</font>
<font color="green">   6. &quot;&quot;&quot;</font>
<font color="green">   7. from __future__ import unicode_literals</font>
<font color="black">   8. </font>
<font color="green">   9. import logging</font>
<font color="green">  10. import re</font>
<font color="black">  11. </font>
<font color="green">  12. from django.conf import settings</font>
<font color="green">  13. from django.core.urlresolvers import get_callable</font>
<font color="green">  14. from django.utils.cache import patch_vary_headers</font>
<font color="green">  15. from django.utils.crypto import constant_time_compare, get_random_string</font>
<font color="green">  16. from django.utils.encoding import force_text</font>
<font color="green">  17. from django.utils.http import is_same_domain</font>
<font color="green">  18. from django.utils.six.moves.urllib.parse import urlparse</font>
<font color="black">  19. </font>
<font color="green">  20. logger = logging.getLogger('django.request')</font>
<font color="black">  21. </font>
<font color="green">  22. REASON_NO_REFERER = &quot;Referer checking failed - no Referer.&quot;</font>
<font color="green">  23. REASON_BAD_REFERER = &quot;Referer checking failed - %s does not match any trusted origins.&quot;</font>
<font color="green">  24. REASON_NO_CSRF_COOKIE = &quot;CSRF cookie not set.&quot;</font>
<font color="green">  25. REASON_BAD_TOKEN = &quot;CSRF token missing or incorrect.&quot;</font>
<font color="green">  26. REASON_MALFORMED_REFERER = &quot;Referer checking failed - Referer is malformed.&quot;</font>
<font color="green">  27. REASON_INSECURE_REFERER = &quot;Referer checking failed - Referer is insecure while host is secure.&quot;</font>
<font color="black">  28. </font>
<font color="green">  29. CSRF_KEY_LENGTH = 32</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. def _get_failure_view():</font>
<font color="black">  33.     &quot;&quot;&quot;</font>
<font color="black">  34.     Returns the view to be used for CSRF rejections</font>
<font color="black">  35.     &quot;&quot;&quot;</font>
<font color="red">  36.     return get_callable(settings.CSRF_FAILURE_VIEW)</font>
<font color="black">  37. </font>
<font color="black">  38. </font>
<font color="green">  39. def _get_new_csrf_key():</font>
<font color="red">  40.     return get_random_string(CSRF_KEY_LENGTH)</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. def get_token(request):</font>
<font color="black">  44.     &quot;&quot;&quot;</font>
<font color="black">  45.     Returns the CSRF token required for a POST form. The token is an</font>
<font color="black">  46.     alphanumeric value. A new token is created if one is not already set.</font>
<font color="black">  47. </font>
<font color="black">  48.     A side effect of calling this function is to make the csrf_protect</font>
<font color="black">  49.     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'</font>
<font color="black">  50.     header to the outgoing response.  For this reason, you may need to use this</font>
<font color="black">  51.     function lazily, as is done by the csrf context processor.</font>
<font color="black">  52.     &quot;&quot;&quot;</font>
<font color="red">  53.     if &quot;CSRF_COOKIE&quot; not in request.META:</font>
<font color="red">  54.         request.META[&quot;CSRF_COOKIE&quot;] = _get_new_csrf_key()</font>
<font color="red">  55.     request.META[&quot;CSRF_COOKIE_USED&quot;] = True</font>
<font color="red">  56.     return request.META[&quot;CSRF_COOKIE&quot;]</font>
<font color="black">  57. </font>
<font color="black">  58. </font>
<font color="green">  59. def rotate_token(request):</font>
<font color="black">  60.     &quot;&quot;&quot;</font>
<font color="black">  61.     Changes the CSRF token in use for a request - should be done on login</font>
<font color="black">  62.     for security purposes.</font>
<font color="black">  63.     &quot;&quot;&quot;</font>
<font color="red">  64.     request.META.update({</font>
<font color="red">  65.         &quot;CSRF_COOKIE_USED&quot;: True,</font>
<font color="red">  66.         &quot;CSRF_COOKIE&quot;: _get_new_csrf_key(),</font>
<font color="black">  67.     })</font>
<font color="black">  68. </font>
<font color="black">  69. </font>
<font color="green">  70. def _sanitize_token(token):</font>
<font color="black">  71.     # Allow only alphanum</font>
<font color="red">  72.     if len(token) &gt; CSRF_KEY_LENGTH:</font>
<font color="red">  73.         return _get_new_csrf_key()</font>
<font color="red">  74.     token = re.sub('[^a-zA-Z0-9]+', '', force_text(token))</font>
<font color="red">  75.     if token == &quot;&quot;:</font>
<font color="black">  76.         # In case the cookie has been truncated to nothing at some point.</font>
<font color="red">  77.         return _get_new_csrf_key()</font>
<font color="red">  78.     return token</font>
<font color="black">  79. </font>
<font color="black">  80. </font>
<font color="green">  81. class CsrfViewMiddleware(object):</font>
<font color="black">  82.     &quot;&quot;&quot;</font>
<font color="black">  83.     Middleware that requires a present and correct csrfmiddlewaretoken</font>
<font color="black">  84.     for POST requests that have a CSRF cookie, and sets an outgoing</font>
<font color="black">  85.     CSRF cookie.</font>
<font color="black">  86. </font>
<font color="black">  87.     This middleware should be used in conjunction with the csrf_token template</font>
<font color="black">  88.     tag.</font>
<font color="green">  89.     &quot;&quot;&quot;</font>
<font color="black">  90.     # The _accept and _reject methods currently only exist for the sake of the</font>
<font color="black">  91.     # requires_csrf_token decorator.</font>
<font color="green">  92.     def _accept(self, request):</font>
<font color="black">  93.         # Avoid checking the request twice by adding a custom attribute to</font>
<font color="black">  94.         # request.  This will be relevant when both decorator and middleware</font>
<font color="black">  95.         # are used.</font>
<font color="red">  96.         request.csrf_processing_done = True</font>
<font color="red">  97.         return None</font>
<font color="black">  98. </font>
<font color="green">  99.     def _reject(self, request, reason):</font>
<font color="red"> 100.         logger.warning('Forbidden (%s): %s', reason, request.path,</font>
<font color="red"> 101.             extra={</font>
<font color="red"> 102.                 'status_code': 403,</font>
<font color="red"> 103.                 'request': request,</font>
<font color="black"> 104.             }</font>
<font color="black"> 105.         )</font>
<font color="red"> 106.         return _get_failure_view()(request, reason=reason)</font>
<font color="black"> 107. </font>
<font color="green"> 108.     def process_view(self, request, callback, callback_args, callback_kwargs):</font>
<font color="black"> 109. </font>
<font color="red"> 110.         if getattr(request, 'csrf_processing_done', False):</font>
<font color="red"> 111.             return None</font>
<font color="black"> 112. </font>
<font color="red"> 113.         try:</font>
<font color="red"> 114.             csrf_token = _sanitize_token(</font>
<font color="red"> 115.                 request.COOKIES[settings.CSRF_COOKIE_NAME])</font>
<font color="black"> 116.             # Use same token next time</font>
<font color="red"> 117.             request.META['CSRF_COOKIE'] = csrf_token</font>
<font color="red"> 118.         except KeyError:</font>
<font color="red"> 119.             csrf_token = None</font>
<font color="black"> 120. </font>
<font color="black"> 121.         # Wait until request.META[&quot;CSRF_COOKIE&quot;] has been manipulated before</font>
<font color="black"> 122.         # bailing out, so that get_token still works</font>
<font color="red"> 123.         if getattr(callback, 'csrf_exempt', False):</font>
<font color="red"> 124.             return None</font>
<font color="black"> 125. </font>
<font color="black"> 126.         # Assume that anything not defined as 'safe' by RFC2616 needs protection</font>
<font color="red"> 127.         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):</font>
<font color="red"> 128.             if getattr(request, '_dont_enforce_csrf_checks', False):</font>
<font color="black"> 129.                 # Mechanism to turn off CSRF checks for test suite.</font>
<font color="black"> 130.                 # It comes after the creation of CSRF cookies, so that</font>
<font color="black"> 131.                 # everything else continues to work exactly the same</font>
<font color="black"> 132.                 # (e.g. cookies are sent, etc.), but before any</font>
<font color="black"> 133.                 # branches that call reject().</font>
<font color="red"> 134.                 return self._accept(request)</font>
<font color="black"> 135. </font>
<font color="red"> 136.             if request.is_secure():</font>
<font color="black"> 137.                 # Suppose user visits http://example.com/</font>
<font color="black"> 138.                 # An active network attacker (man-in-the-middle, MITM) sends a</font>
<font color="black"> 139.                 # POST form that targets https://example.com/detonate-bomb/ and</font>
<font color="black"> 140.                 # submits it via JavaScript.</font>
<font color="black"> 141.                 #</font>
<font color="black"> 142.                 # The attacker will need to provide a CSRF cookie and token, but</font>
<font color="black"> 143.                 # that's no problem for a MITM and the session-independent</font>
<font color="black"> 144.                 # nonce we're using. So the MITM can circumvent the CSRF</font>
<font color="black"> 145.                 # protection. This is true for any HTTP connection, but anyone</font>
<font color="black"> 146.                 # using HTTPS expects better! For this reason, for</font>
<font color="black"> 147.                 # https://example.com/ we need additional protection that treats</font>
<font color="black"> 148.                 # http://example.com/ as completely untrusted. Under HTTPS,</font>
<font color="black"> 149.                 # Barth et al. found that the Referer header is missing for</font>
<font color="black"> 150.                 # same-domain requests in only about 0.2% of cases or less, so</font>
<font color="black"> 151.                 # we can use strict Referer checking.</font>
<font color="red"> 152.                 referer = force_text(</font>
<font color="red"> 153.                     request.META.get('HTTP_REFERER'),</font>
<font color="red"> 154.                     strings_only=True,</font>
<font color="red"> 155.                     errors='replace'</font>
<font color="black"> 156.                 )</font>
<font color="red"> 157.                 if referer is None:</font>
<font color="red"> 158.                     return self._reject(request, REASON_NO_REFERER)</font>
<font color="black"> 159. </font>
<font color="red"> 160.                 referer = urlparse(referer)</font>
<font color="black"> 161. </font>
<font color="black"> 162.                 # Make sure we have a valid URL for Referer.</font>
<font color="red"> 163.                 if '' in (referer.scheme, referer.netloc):</font>
<font color="red"> 164.                     return self._reject(request, REASON_MALFORMED_REFERER)</font>
<font color="black"> 165. </font>
<font color="black"> 166.                 # Ensure that our Referer is also secure.</font>
<font color="red"> 167.                 if referer.scheme != 'https':</font>
<font color="red"> 168.                     return self._reject(request, REASON_INSECURE_REFERER)</font>
<font color="black"> 169. </font>
<font color="black"> 170.                 # If there isn't a CSRF_COOKIE_DOMAIN, assume we need an exact</font>
<font color="black"> 171.                 # match on host:port. If not, obey the cookie rules.</font>
<font color="red"> 172.                 if settings.CSRF_COOKIE_DOMAIN is None:</font>
<font color="black"> 173.                     # request.get_host() includes the port.</font>
<font color="red"> 174.                     good_referer = request.get_host()</font>
<font color="black"> 175.                 else:</font>
<font color="red"> 176.                     good_referer = settings.CSRF_COOKIE_DOMAIN</font>
<font color="red"> 177.                     server_port = request.META['SERVER_PORT']</font>
<font color="red"> 178.                     if server_port not in ('443', '80'):</font>
<font color="red"> 179.                         good_referer = '%s:%s' % (good_referer, server_port)</font>
<font color="black"> 180. </font>
<font color="black"> 181.                 # Here we generate a list of all acceptable HTTP referers,</font>
<font color="black"> 182.                 # including the current host since that has been validated</font>
<font color="black"> 183.                 # upstream.</font>
<font color="red"> 184.                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)</font>
<font color="red"> 185.                 good_hosts.append(good_referer)</font>
<font color="black"> 186. </font>
<font color="red"> 187.                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):</font>
<font color="red"> 188.                     reason = REASON_BAD_REFERER % referer.geturl()</font>
<font color="red"> 189.                     return self._reject(request, reason)</font>
<font color="black"> 190. </font>
<font color="red"> 191.             if csrf_token is None:</font>
<font color="black"> 192.                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,</font>
<font color="black"> 193.                 # and in this way we can avoid all CSRF attacks, including login</font>
<font color="black"> 194.                 # CSRF.</font>
<font color="red"> 195.                 return self._reject(request, REASON_NO_CSRF_COOKIE)</font>
<font color="black"> 196. </font>
<font color="black"> 197.             # Check non-cookie token for match.</font>
<font color="red"> 198.             request_csrf_token = &quot;&quot;</font>
<font color="red"> 199.             if request.method == &quot;POST&quot;:</font>
<font color="red"> 200.                 try:</font>
<font color="red"> 201.                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')</font>
<font color="red"> 202.                 except IOError:</font>
<font color="black"> 203.                     # Handle a broken connection before we've completed reading</font>
<font color="black"> 204.                     # the POST data. process_view shouldn't raise any</font>
<font color="black"> 205.                     # exceptions, so we'll ignore and serve the user a 403</font>
<font color="black"> 206.                     # (assuming they're still listening, which they probably</font>
<font color="black"> 207.                     # aren't because of the error).</font>
<font color="red"> 208.                     pass</font>
<font color="black"> 209. </font>
<font color="red"> 210.             if request_csrf_token == &quot;&quot;:</font>
<font color="black"> 211.                 # Fall back to X-CSRFToken, to make things easier for AJAX,</font>
<font color="black"> 212.                 # and possible for PUT/DELETE.</font>
<font color="red"> 213.                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')</font>
<font color="black"> 214. </font>
<font color="red"> 215.             if not constant_time_compare(request_csrf_token, csrf_token):</font>
<font color="red"> 216.                 return self._reject(request, REASON_BAD_TOKEN)</font>
<font color="black"> 217. </font>
<font color="red"> 218.         return self._accept(request)</font>
<font color="black"> 219. </font>
<font color="green"> 220.     def process_response(self, request, response):</font>
<font color="red"> 221.         if getattr(response, 'csrf_processing_done', False):</font>
<font color="red"> 222.             return response</font>
<font color="black"> 223. </font>
<font color="red"> 224.         if not request.META.get(&quot;CSRF_COOKIE_USED&quot;, False):</font>
<font color="red"> 225.             return response</font>
<font color="black"> 226. </font>
<font color="black"> 227.         # Set the CSRF cookie even if it's already set, so we renew</font>
<font color="black"> 228.         # the expiry timer.</font>
<font color="red"> 229.         response.set_cookie(settings.CSRF_COOKIE_NAME,</font>
<font color="red"> 230.                             request.META[&quot;CSRF_COOKIE&quot;],</font>
<font color="red"> 231.                             max_age=settings.CSRF_COOKIE_AGE,</font>
<font color="red"> 232.                             domain=settings.CSRF_COOKIE_DOMAIN,</font>
<font color="red"> 233.                             path=settings.CSRF_COOKIE_PATH,</font>
<font color="red"> 234.                             secure=settings.CSRF_COOKIE_SECURE,</font>
<font color="red"> 235.                             httponly=settings.CSRF_COOKIE_HTTPONLY</font>
<font color="black"> 236.                             )</font>
<font color="black"> 237.         # Content varies with the CSRF cookie, so set the Vary header.</font>
<font color="red"> 238.         patch_vary_headers(response, ('Cookie',))</font>
<font color="red"> 239.         response.csrf_processing_done = True</font>
<font color="red"> 240.         return response</font>
</pre>

