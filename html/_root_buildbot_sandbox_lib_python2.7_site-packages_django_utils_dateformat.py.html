source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/dateformat.py</b><br>


file stats: <b>197 lines, 61 executed: 31.0% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. PHP date() style date formatting</font>
<font color="black">   3. See http://www.php.net/date for format strings</font>
<font color="black">   4. </font>
<font color="black">   5. Usage:</font>
<font color="black">   6. &gt;&gt;&gt; import datetime</font>
<font color="black">   7. &gt;&gt;&gt; d = datetime.datetime.now()</font>
<font color="black">   8. &gt;&gt;&gt; df = DateFormat(d)</font>
<font color="black">   9. &gt;&gt;&gt; print(df.format('jS F Y H:i'))</font>
<font color="black">  10. 7th October 2003 11:39</font>
<font color="black">  11. &gt;&gt;&gt;</font>
<font color="green">  12. &quot;&quot;&quot;</font>
<font color="green">  13. from __future__ import unicode_literals</font>
<font color="black">  14. </font>
<font color="green">  15. import calendar</font>
<font color="green">  16. import datetime</font>
<font color="green">  17. import re</font>
<font color="green">  18. import time</font>
<font color="black">  19. </font>
<font color="green">  20. from django.utils import six</font>
<font color="green">  21. from django.utils.dates import (</font>
<font color="black">  22.     MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS, WEEKDAYS_ABBR,</font>
<font color="black">  23. )</font>
<font color="green">  24. from django.utils.encoding import force_text</font>
<font color="green">  25. from django.utils.timezone import get_default_timezone, is_aware, is_naive</font>
<font color="green">  26. from django.utils.translation import ugettext as _</font>
<font color="black">  27. </font>
<font color="green">  28. re_formatchars = re.compile(r'(?&lt;!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])')</font>
<font color="green">  29. re_escaped = re.compile(r'\\(.)')</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. class Formatter(object):</font>
<font color="green">  33.     def format(self, formatstr):</font>
<font color="red">  34.         pieces = []</font>
<font color="red">  35.         for i, piece in enumerate(re_formatchars.split(force_text(formatstr))):</font>
<font color="red">  36.             if i % 2:</font>
<font color="red">  37.                 pieces.append(force_text(getattr(self, piece)()))</font>
<font color="red">  38.             elif piece:</font>
<font color="red">  39.                 pieces.append(re_escaped.sub(r'\1', piece))</font>
<font color="red">  40.         return ''.join(pieces)</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. class TimeFormat(Formatter):</font>
<font color="black">  44. </font>
<font color="green">  45.     def __init__(self, obj):</font>
<font color="red">  46.         self.data = obj</font>
<font color="red">  47.         self.timezone = None</font>
<font color="black">  48. </font>
<font color="black">  49.         # We only support timezone when formatting datetime objects,</font>
<font color="black">  50.         # not date objects (timezone information not appropriate),</font>
<font color="black">  51.         # or time objects (against established django policy).</font>
<font color="red">  52.         if isinstance(obj, datetime.datetime):</font>
<font color="red">  53.             if is_naive(obj):</font>
<font color="red">  54.                 self.timezone = get_default_timezone()</font>
<font color="black">  55.             else:</font>
<font color="red">  56.                 self.timezone = obj.tzinfo</font>
<font color="black">  57. </font>
<font color="green">  58.     def a(self):</font>
<font color="black">  59.         &quot;'a.m.' or 'p.m.'&quot;</font>
<font color="red">  60.         if self.data.hour &gt; 11:</font>
<font color="red">  61.             return _('p.m.')</font>
<font color="red">  62.         return _('a.m.')</font>
<font color="black">  63. </font>
<font color="green">  64.     def A(self):</font>
<font color="black">  65.         &quot;'AM' or 'PM'&quot;</font>
<font color="red">  66.         if self.data.hour &gt; 11:</font>
<font color="red">  67.             return _('PM')</font>
<font color="red">  68.         return _('AM')</font>
<font color="black">  69. </font>
<font color="green">  70.     def B(self):</font>
<font color="black">  71.         &quot;Swatch Internet time&quot;</font>
<font color="red">  72.         raise NotImplementedError('may be implemented in a future release')</font>
<font color="black">  73. </font>
<font color="green">  74.     def e(self):</font>
<font color="black">  75.         &quot;&quot;&quot;</font>
<font color="black">  76.         Timezone name.</font>
<font color="black">  77. </font>
<font color="black">  78.         If timezone information is not available, this method returns</font>
<font color="black">  79.         an empty string.</font>
<font color="black">  80.         &quot;&quot;&quot;</font>
<font color="red">  81.         if not self.timezone:</font>
<font color="red">  82.             return &quot;&quot;</font>
<font color="black">  83. </font>
<font color="red">  84.         try:</font>
<font color="red">  85.             if hasattr(self.data, 'tzinfo') and self.data.tzinfo:</font>
<font color="black">  86.                 # Have to use tzinfo.tzname and not datetime.tzname</font>
<font color="black">  87.                 # because datatime.tzname does not expect Unicode</font>
<font color="red">  88.                 return self.data.tzinfo.tzname(self.data) or &quot;&quot;</font>
<font color="red">  89.         except NotImplementedError:</font>
<font color="red">  90.             pass</font>
<font color="red">  91.         return &quot;&quot;</font>
<font color="black">  92. </font>
<font color="green">  93.     def f(self):</font>
<font color="black">  94.         &quot;&quot;&quot;</font>
<font color="black">  95.         Time, in 12-hour hours and minutes, with minutes left off if they're</font>
<font color="black">  96.         zero.</font>
<font color="black">  97.         Examples: '1', '1:30', '2:05', '2'</font>
<font color="black">  98.         Proprietary extension.</font>
<font color="black">  99.         &quot;&quot;&quot;</font>
<font color="red"> 100.         if self.data.minute == 0:</font>
<font color="red"> 101.             return self.g()</font>
<font color="red"> 102.         return '%s:%s' % (self.g(), self.i())</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def g(self):</font>
<font color="black"> 105.         &quot;Hour, 12-hour format without leading zeros; i.e. '1' to '12'&quot;</font>
<font color="red"> 106.         if self.data.hour == 0:</font>
<font color="red"> 107.             return 12</font>
<font color="red"> 108.         if self.data.hour &gt; 12:</font>
<font color="red"> 109.             return self.data.hour - 12</font>
<font color="red"> 110.         return self.data.hour</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def G(self):</font>
<font color="black"> 113.         &quot;Hour, 24-hour format without leading zeros; i.e. '0' to '23'&quot;</font>
<font color="red"> 114.         return self.data.hour</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def h(self):</font>
<font color="black"> 117.         &quot;Hour, 12-hour format; i.e. '01' to '12'&quot;</font>
<font color="red"> 118.         return '%02d' % self.g()</font>
<font color="black"> 119. </font>
<font color="green"> 120.     def H(self):</font>
<font color="black"> 121.         &quot;Hour, 24-hour format; i.e. '00' to '23'&quot;</font>
<font color="red"> 122.         return '%02d' % self.G()</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def i(self):</font>
<font color="black"> 125.         &quot;Minutes; i.e. '00' to '59'&quot;</font>
<font color="red"> 126.         return '%02d' % self.data.minute</font>
<font color="black"> 127. </font>
<font color="green"> 128.     def O(self):</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="black"> 130.         Difference to Greenwich time in hours; e.g. '+0200', '-0430'.</font>
<font color="black"> 131. </font>
<font color="black"> 132.         If timezone information is not available, this method returns</font>
<font color="black"> 133.         an empty string.</font>
<font color="black"> 134.         &quot;&quot;&quot;</font>
<font color="red"> 135.         if not self.timezone:</font>
<font color="red"> 136.             return &quot;&quot;</font>
<font color="black"> 137. </font>
<font color="red"> 138.         seconds = self.Z()</font>
<font color="red"> 139.         if seconds == &quot;&quot;:</font>
<font color="red"> 140.             return &quot;&quot;</font>
<font color="red"> 141.         sign = '-' if seconds &lt; 0 else '+'</font>
<font color="red"> 142.         seconds = abs(seconds)</font>
<font color="red"> 143.         return &quot;%s%02d%02d&quot; % (sign, seconds // 3600, (seconds // 60) % 60)</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def P(self):</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="black"> 147.         Time, in 12-hour hours, minutes and 'a.m.'/'p.m.', with minutes left off</font>
<font color="black"> 148.         if they're zero and the strings 'midnight' and 'noon' if appropriate.</font>
<font color="black"> 149.         Examples: '1 a.m.', '1:30 p.m.', 'midnight', 'noon', '12:30 p.m.'</font>
<font color="black"> 150.         Proprietary extension.</font>
<font color="black"> 151.         &quot;&quot;&quot;</font>
<font color="red"> 152.         if self.data.minute == 0 and self.data.hour == 0:</font>
<font color="red"> 153.             return _('midnight')</font>
<font color="red"> 154.         if self.data.minute == 0 and self.data.hour == 12:</font>
<font color="red"> 155.             return _('noon')</font>
<font color="red"> 156.         return '%s %s' % (self.f(), self.a())</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def s(self):</font>
<font color="black"> 159.         &quot;Seconds; i.e. '00' to '59'&quot;</font>
<font color="red"> 160.         return '%02d' % self.data.second</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def T(self):</font>
<font color="black"> 163.         &quot;&quot;&quot;</font>
<font color="black"> 164.         Time zone of this machine; e.g. 'EST' or 'MDT'.</font>
<font color="black"> 165. </font>
<font color="black"> 166.         If timezone information is not available, this method returns</font>
<font color="black"> 167.         an empty string.</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="red"> 169.         if not self.timezone:</font>
<font color="red"> 170.             return &quot;&quot;</font>
<font color="black"> 171. </font>
<font color="red"> 172.         name = None</font>
<font color="red"> 173.         try:</font>
<font color="red"> 174.             name = self.timezone.tzname(self.data)</font>
<font color="red"> 175.         except Exception:</font>
<font color="black"> 176.             # pytz raises AmbiguousTimeError during the autumn DST change.</font>
<font color="black"> 177.             # This happens mainly when __init__ receives a naive datetime</font>
<font color="black"> 178.             # and sets self.timezone = get_default_timezone().</font>
<font color="red"> 179.             pass</font>
<font color="red"> 180.         if name is None:</font>
<font color="red"> 181.             name = self.format('O')</font>
<font color="red"> 182.         return six.text_type(name)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def u(self):</font>
<font color="black"> 185.         &quot;Microseconds; i.e. '000000' to '999999'&quot;</font>
<font color="red"> 186.         return '%06d' % self.data.microsecond</font>
<font color="black"> 187. </font>
<font color="green"> 188.     def Z(self):</font>
<font color="black"> 189.         &quot;&quot;&quot;</font>
<font color="black"> 190.         Time zone offset in seconds (i.e. '-43200' to '43200'). The offset for</font>
<font color="black"> 191.         timezones west of UTC is always negative, and for those east of UTC is</font>
<font color="black"> 192.         always positive.</font>
<font color="black"> 193. </font>
<font color="black"> 194.         If timezone information is not available, this method returns</font>
<font color="black"> 195.         an empty string.</font>
<font color="black"> 196.         &quot;&quot;&quot;</font>
<font color="red"> 197.         if not self.timezone:</font>
<font color="red"> 198.             return &quot;&quot;</font>
<font color="black"> 199. </font>
<font color="red"> 200.         try:</font>
<font color="red"> 201.             offset = self.timezone.utcoffset(self.data)</font>
<font color="red"> 202.         except Exception:</font>
<font color="black"> 203.             # pytz raises AmbiguousTimeError during the autumn DST change.</font>
<font color="black"> 204.             # This happens mainly when __init__ receives a naive datetime</font>
<font color="black"> 205.             # and sets self.timezone = get_default_timezone().</font>
<font color="red"> 206.             return &quot;&quot;</font>
<font color="black"> 207. </font>
<font color="black"> 208.         # `offset` is a datetime.timedelta. For negative values (to the west of</font>
<font color="black"> 209.         # UTC) only days can be negative (days=-1) and seconds are always</font>
<font color="black"> 210.         # positive. e.g. UTC-1 -&gt; timedelta(days=-1, seconds=82800, microseconds=0)</font>
<font color="black"> 211.         # Positive offsets have days=0</font>
<font color="red"> 212.         return offset.days * 86400 + offset.seconds</font>
<font color="black"> 213. </font>
<font color="black"> 214. </font>
<font color="green"> 215. class DateFormat(TimeFormat):</font>
<font color="green"> 216.     year_days = [None, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]</font>
<font color="black"> 217. </font>
<font color="green"> 218.     def b(self):</font>
<font color="black"> 219.         &quot;Month, textual, 3 letters, lowercase; e.g. 'jan'&quot;</font>
<font color="red"> 220.         return MONTHS_3[self.data.month]</font>
<font color="black"> 221. </font>
<font color="green"> 222.     def c(self):</font>
<font color="black"> 223.         &quot;&quot;&quot;</font>
<font color="black"> 224.         ISO 8601 Format</font>
<font color="black"> 225.         Example : '2008-01-02T10:30:00.000123'</font>
<font color="black"> 226.         &quot;&quot;&quot;</font>
<font color="red"> 227.         return self.data.isoformat()</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def d(self):</font>
<font color="black"> 230.         &quot;Day of the month, 2 digits with leading zeros; i.e. '01' to '31'&quot;</font>
<font color="red"> 231.         return '%02d' % self.data.day</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def D(self):</font>
<font color="black"> 234.         &quot;Day of the week, textual, 3 letters; e.g. 'Fri'&quot;</font>
<font color="red"> 235.         return WEEKDAYS_ABBR[self.data.weekday()]</font>
<font color="black"> 236. </font>
<font color="green"> 237.     def E(self):</font>
<font color="black"> 238.         &quot;Alternative month names as required by some locales. Proprietary extension.&quot;</font>
<font color="red"> 239.         return MONTHS_ALT[self.data.month]</font>
<font color="black"> 240. </font>
<font color="green"> 241.     def F(self):</font>
<font color="black"> 242.         &quot;Month, textual, long; e.g. 'January'&quot;</font>
<font color="red"> 243.         return MONTHS[self.data.month]</font>
<font color="black"> 244. </font>
<font color="green"> 245.     def I(self):</font>
<font color="black"> 246.         &quot;'1' if Daylight Savings Time, '0' otherwise.&quot;</font>
<font color="red"> 247.         try:</font>
<font color="red"> 248.             if self.timezone and self.timezone.dst(self.data):</font>
<font color="red"> 249.                 return '1'</font>
<font color="black"> 250.             else:</font>
<font color="red"> 251.                 return '0'</font>
<font color="red"> 252.         except Exception:</font>
<font color="black"> 253.             # pytz raises AmbiguousTimeError during the autumn DST change.</font>
<font color="black"> 254.             # This happens mainly when __init__ receives a naive datetime</font>
<font color="black"> 255.             # and sets self.timezone = get_default_timezone().</font>
<font color="red"> 256.             return ''</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def j(self):</font>
<font color="black"> 259.         &quot;Day of the month without leading zeros; i.e. '1' to '31'&quot;</font>
<font color="red"> 260.         return self.data.day</font>
<font color="black"> 261. </font>
<font color="green"> 262.     def l(self):</font>
<font color="black"> 263.         &quot;Day of the week, textual, long; e.g. 'Friday'&quot;</font>
<font color="red"> 264.         return WEEKDAYS[self.data.weekday()]</font>
<font color="black"> 265. </font>
<font color="green"> 266.     def L(self):</font>
<font color="black"> 267.         &quot;Boolean for whether it is a leap year; i.e. True or False&quot;</font>
<font color="red"> 268.         return calendar.isleap(self.data.year)</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def m(self):</font>
<font color="black"> 271.         &quot;Month; i.e. '01' to '12'&quot;</font>
<font color="red"> 272.         return '%02d' % self.data.month</font>
<font color="black"> 273. </font>
<font color="green"> 274.     def M(self):</font>
<font color="black"> 275.         &quot;Month, textual, 3 letters; e.g. 'Jan'&quot;</font>
<font color="red"> 276.         return MONTHS_3[self.data.month].title()</font>
<font color="black"> 277. </font>
<font color="green"> 278.     def n(self):</font>
<font color="black"> 279.         &quot;Month without leading zeros; i.e. '1' to '12'&quot;</font>
<font color="red"> 280.         return self.data.month</font>
<font color="black"> 281. </font>
<font color="green"> 282.     def N(self):</font>
<font color="black"> 283.         &quot;Month abbreviation in Associated Press style. Proprietary extension.&quot;</font>
<font color="red"> 284.         return MONTHS_AP[self.data.month]</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def o(self):</font>
<font color="black"> 287.         &quot;ISO 8601 year number matching the ISO week number (W)&quot;</font>
<font color="red"> 288.         return self.data.isocalendar()[0]</font>
<font color="black"> 289. </font>
<font color="green"> 290.     def r(self):</font>
<font color="black"> 291.         &quot;RFC 2822 formatted date; e.g. 'Thu, 21 Dec 2000 16:01:07 +0200'&quot;</font>
<font color="red"> 292.         return self.format('D, j M Y H:i:s O')</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def S(self):</font>
<font color="black"> 295.         &quot;English ordinal suffix for the day of the month, 2 characters; i.e. 'st', 'nd', 'rd' or 'th'&quot;</font>
<font color="red"> 296.         if self.data.day in (11, 12, 13):  # Special case</font>
<font color="red"> 297.             return 'th'</font>
<font color="red"> 298.         last = self.data.day % 10</font>
<font color="red"> 299.         if last == 1:</font>
<font color="red"> 300.             return 'st'</font>
<font color="red"> 301.         if last == 2:</font>
<font color="red"> 302.             return 'nd'</font>
<font color="red"> 303.         if last == 3:</font>
<font color="red"> 304.             return 'rd'</font>
<font color="red"> 305.         return 'th'</font>
<font color="black"> 306. </font>
<font color="green"> 307.     def t(self):</font>
<font color="black"> 308.         &quot;Number of days in the given month; i.e. '28' to '31'&quot;</font>
<font color="red"> 309.         return '%02d' % calendar.monthrange(self.data.year, self.data.month)[1]</font>
<font color="black"> 310. </font>
<font color="green"> 311.     def U(self):</font>
<font color="black"> 312.         &quot;Seconds since the Unix epoch (January 1 1970 00:00:00 GMT)&quot;</font>
<font color="red"> 313.         if isinstance(self.data, datetime.datetime) and is_aware(self.data):</font>
<font color="red"> 314.             return int(calendar.timegm(self.data.utctimetuple()))</font>
<font color="black"> 315.         else:</font>
<font color="red"> 316.             return int(time.mktime(self.data.timetuple()))</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def w(self):</font>
<font color="black"> 319.         &quot;Day of the week, numeric, i.e. '0' (Sunday) to '6' (Saturday)&quot;</font>
<font color="red"> 320.         return (self.data.weekday() + 1) % 7</font>
<font color="black"> 321. </font>
<font color="green"> 322.     def W(self):</font>
<font color="black"> 323.         &quot;ISO-8601 week number of year, weeks starting on Monday&quot;</font>
<font color="black"> 324.         # Algorithm from http://www.personal.ecu.edu/mccartyr/ISOwdALG.txt</font>
<font color="red"> 325.         week_number = None</font>
<font color="red"> 326.         jan1_weekday = self.data.replace(month=1, day=1).weekday() + 1</font>
<font color="red"> 327.         weekday = self.data.weekday() + 1</font>
<font color="red"> 328.         day_of_year = self.z()</font>
<font color="red"> 329.         if day_of_year &lt;= (8 - jan1_weekday) and jan1_weekday &gt; 4:</font>
<font color="red"> 330.             if jan1_weekday == 5 or (jan1_weekday == 6 and calendar.isleap(self.data.year - 1)):</font>
<font color="red"> 331.                 week_number = 53</font>
<font color="black"> 332.             else:</font>
<font color="red"> 333.                 week_number = 52</font>
<font color="black"> 334.         else:</font>
<font color="red"> 335.             if calendar.isleap(self.data.year):</font>
<font color="red"> 336.                 i = 366</font>
<font color="black"> 337.             else:</font>
<font color="red"> 338.                 i = 365</font>
<font color="red"> 339.             if (i - day_of_year) &lt; (4 - weekday):</font>
<font color="red"> 340.                 week_number = 1</font>
<font color="black"> 341.             else:</font>
<font color="red"> 342.                 j = day_of_year + (7 - weekday) + (jan1_weekday - 1)</font>
<font color="red"> 343.                 week_number = j // 7</font>
<font color="red"> 344.                 if jan1_weekday &gt; 4:</font>
<font color="red"> 345.                     week_number -= 1</font>
<font color="red"> 346.         return week_number</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def y(self):</font>
<font color="black"> 349.         &quot;Year, 2 digits; e.g. '99'&quot;</font>
<font color="red"> 350.         return six.text_type(self.data.year)[2:]</font>
<font color="black"> 351. </font>
<font color="green"> 352.     def Y(self):</font>
<font color="black"> 353.         &quot;Year, 4 digits; e.g. '1999'&quot;</font>
<font color="red"> 354.         return self.data.year</font>
<font color="black"> 355. </font>
<font color="green"> 356.     def z(self):</font>
<font color="black"> 357.         &quot;Day of the year; i.e. '0' to '365'&quot;</font>
<font color="red"> 358.         doy = self.year_days[self.data.month] + self.data.day</font>
<font color="red"> 359.         if self.L() and self.data.month &gt; 2:</font>
<font color="red"> 360.             doy += 1</font>
<font color="red"> 361.         return doy</font>
<font color="black"> 362. </font>
<font color="black"> 363. </font>
<font color="green"> 364. def format(value, format_string):</font>
<font color="black"> 365.     &quot;Convenience function&quot;</font>
<font color="red"> 366.     df = DateFormat(value)</font>
<font color="red"> 367.     return df.format(format_string)</font>
<font color="black"> 368. </font>
<font color="black"> 369. </font>
<font color="green"> 370. def time_format(value, format_string):</font>
<font color="black"> 371.     &quot;Convenience function&quot;</font>
<font color="red"> 372.     tf = TimeFormat(value)</font>
<font color="red"> 373.     return tf.format(format_string)</font>
</pre>

