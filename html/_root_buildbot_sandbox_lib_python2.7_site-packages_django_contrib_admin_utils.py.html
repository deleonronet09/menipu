source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/contrib/admin/utils.py</b><br>


file stats: <b>313 lines, 58 executed: 18.5% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import datetime</font>
<font color="green">   4. import decimal</font>
<font color="green">   5. from collections import defaultdict</font>
<font color="black">   6. </font>
<font color="green">   7. from django.contrib.auth import get_permission_codename</font>
<font color="green">   8. from django.core.exceptions import FieldDoesNotExist</font>
<font color="green">   9. from django.core.urlresolvers import NoReverseMatch, reverse</font>
<font color="green">  10. from django.db import models</font>
<font color="green">  11. from django.db.models.constants import LOOKUP_SEP</font>
<font color="green">  12. from django.db.models.deletion import Collector</font>
<font color="green">  13. from django.db.models.sql.constants import QUERY_TERMS</font>
<font color="green">  14. from django.forms.utils import pretty_name</font>
<font color="green">  15. from django.utils import formats, six, timezone</font>
<font color="green">  16. from django.utils.encoding import force_str, force_text, smart_text</font>
<font color="green">  17. from django.utils.html import format_html</font>
<font color="green">  18. from django.utils.text import capfirst</font>
<font color="green">  19. from django.utils.translation import ungettext</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. def lookup_needs_distinct(opts, lookup_path):</font>
<font color="black">  23.     &quot;&quot;&quot;</font>
<font color="black">  24.     Returns True if 'distinct()' should be used to query the given lookup path.</font>
<font color="black">  25.     &quot;&quot;&quot;</font>
<font color="red">  26.     lookup_fields = lookup_path.split('__')</font>
<font color="black">  27.     # Remove the last item of the lookup path if it is a query term</font>
<font color="red">  28.     if lookup_fields[-1] in QUERY_TERMS:</font>
<font color="red">  29.         lookup_fields = lookup_fields[:-1]</font>
<font color="black">  30.     # Now go through the fields (following all relations) and look for an m2m</font>
<font color="red">  31.     for field_name in lookup_fields:</font>
<font color="red">  32.         field = opts.get_field(field_name)</font>
<font color="red">  33.         if hasattr(field, 'get_path_info'):</font>
<font color="black">  34.             # This field is a relation, update opts to follow the relation</font>
<font color="red">  35.             path_info = field.get_path_info()</font>
<font color="red">  36.             opts = path_info[-1].to_opts</font>
<font color="red">  37.             if any(path.m2m for path in path_info):</font>
<font color="black">  38.                 # This field is a m2m relation so we know we need to call distinct</font>
<font color="red">  39.                 return True</font>
<font color="red">  40.     return False</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. def prepare_lookup_value(key, value):</font>
<font color="black">  44.     &quot;&quot;&quot;</font>
<font color="black">  45.     Returns a lookup value prepared to be used in queryset filtering.</font>
<font color="black">  46.     &quot;&quot;&quot;</font>
<font color="black">  47.     # if key ends with __in, split parameter into separate values</font>
<font color="red">  48.     if key.endswith('__in'):</font>
<font color="red">  49.         value = value.split(',')</font>
<font color="black">  50.     # if key ends with __isnull, special case '' and the string literals 'false' and '0'</font>
<font color="red">  51.     if key.endswith('__isnull'):</font>
<font color="red">  52.         if value.lower() in ('', 'false', '0'):</font>
<font color="red">  53.             value = False</font>
<font color="black">  54.         else:</font>
<font color="red">  55.             value = True</font>
<font color="red">  56.     return value</font>
<font color="black">  57. </font>
<font color="black">  58. </font>
<font color="green">  59. def quote(s):</font>
<font color="black">  60.     &quot;&quot;&quot;</font>
<font color="black">  61.     Ensure that primary key values do not confuse the admin URLs by escaping</font>
<font color="black">  62.     any '/', '_' and ':' and similarly problematic characters.</font>
<font color="black">  63.     Similar to urllib.quote, except that the quoting is slightly different so</font>
<font color="black">  64.     that it doesn't get automatically unquoted by the Web browser.</font>
<font color="black">  65.     &quot;&quot;&quot;</font>
<font color="red">  66.     if not isinstance(s, six.string_types):</font>
<font color="red">  67.         return s</font>
<font color="red">  68.     res = list(s)</font>
<font color="red">  69.     for i in range(len(res)):</font>
<font color="red">  70.         c = res[i]</font>
<font color="red">  71.         if c in &quot;&quot;&quot;:/_#?;@&amp;=+$,&quot;[]&lt;&gt;%\n\\&quot;&quot;&quot;:</font>
<font color="red">  72.             res[i] = '_%02X' % ord(c)</font>
<font color="red">  73.     return ''.join(res)</font>
<font color="black">  74. </font>
<font color="black">  75. </font>
<font color="green">  76. def unquote(s):</font>
<font color="black">  77.     &quot;&quot;&quot;</font>
<font color="black">  78.     Undo the effects of quote(). Based heavily on urllib.unquote().</font>
<font color="black">  79.     &quot;&quot;&quot;</font>
<font color="red">  80.     mychr = chr</font>
<font color="red">  81.     myatoi = int</font>
<font color="red">  82.     list = s.split('_')</font>
<font color="red">  83.     res = [list[0]]</font>
<font color="red">  84.     myappend = res.append</font>
<font color="red">  85.     del list[0]</font>
<font color="red">  86.     for item in list:</font>
<font color="red">  87.         if item[1:2]:</font>
<font color="red">  88.             try:</font>
<font color="red">  89.                 myappend(mychr(myatoi(item[:2], 16)) + item[2:])</font>
<font color="red">  90.             except ValueError:</font>
<font color="red">  91.                 myappend('_' + item)</font>
<font color="black">  92.         else:</font>
<font color="red">  93.             myappend('_' + item)</font>
<font color="red">  94.     return &quot;&quot;.join(res)</font>
<font color="black">  95. </font>
<font color="black">  96. </font>
<font color="green">  97. def flatten(fields):</font>
<font color="black">  98.     &quot;&quot;&quot;Returns a list which is a single level of flattening of the</font>
<font color="black">  99.     original list.&quot;&quot;&quot;</font>
<font color="green"> 100.     flat = []</font>
<font color="green"> 101.     for field in fields:</font>
<font color="green"> 102.         if isinstance(field, (list, tuple)):</font>
<font color="red"> 103.             flat.extend(field)</font>
<font color="black"> 104.         else:</font>
<font color="green"> 105.             flat.append(field)</font>
<font color="green"> 106.     return flat</font>
<font color="black"> 107. </font>
<font color="black"> 108. </font>
<font color="green"> 109. def flatten_fieldsets(fieldsets):</font>
<font color="black"> 110.     &quot;&quot;&quot;Returns a list of field names from an admin fieldsets structure.&quot;&quot;&quot;</font>
<font color="red"> 111.     field_names = []</font>
<font color="red"> 112.     for name, opts in fieldsets:</font>
<font color="red"> 113.         field_names.extend(</font>
<font color="red"> 114.             flatten(opts['fields'])</font>
<font color="black"> 115.         )</font>
<font color="red"> 116.     return field_names</font>
<font color="black"> 117. </font>
<font color="black"> 118. </font>
<font color="green"> 119. def get_deleted_objects(objs, opts, user, admin_site, using):</font>
<font color="black"> 120.     &quot;&quot;&quot;</font>
<font color="black"> 121.     Find all objects related to ``objs`` that should also be deleted. ``objs``</font>
<font color="black"> 122.     must be a homogeneous iterable of objects (e.g. a QuerySet).</font>
<font color="black"> 123. </font>
<font color="black"> 124.     Returns a nested list of strings suitable for display in the</font>
<font color="black"> 125.     template with the ``unordered_list`` filter.</font>
<font color="black"> 126.     &quot;&quot;&quot;</font>
<font color="red"> 127.     collector = NestedObjects(using=using)</font>
<font color="red"> 128.     collector.collect(objs)</font>
<font color="red"> 129.     perms_needed = set()</font>
<font color="black"> 130. </font>
<font color="red"> 131.     def format_callback(obj):</font>
<font color="red"> 132.         has_admin = obj.__class__ in admin_site._registry</font>
<font color="red"> 133.         opts = obj._meta</font>
<font color="black"> 134. </font>
<font color="red"> 135.         no_edit_link = '%s: %s' % (capfirst(opts.verbose_name),</font>
<font color="red"> 136.                                    force_text(obj))</font>
<font color="black"> 137. </font>
<font color="red"> 138.         if has_admin:</font>
<font color="red"> 139.             try:</font>
<font color="red"> 140.                 admin_url = reverse('%s:%s_%s_change'</font>
<font color="red"> 141.                                     % (admin_site.name,</font>
<font color="red"> 142.                                        opts.app_label,</font>
<font color="red"> 143.                                        opts.model_name),</font>
<font color="red"> 144.                                     None, (quote(obj._get_pk_val()),))</font>
<font color="red"> 145.             except NoReverseMatch:</font>
<font color="black"> 146.                 # Change url doesn't exist -- don't display link to edit</font>
<font color="red"> 147.                 return no_edit_link</font>
<font color="black"> 148. </font>
<font color="red"> 149.             p = '%s.%s' % (opts.app_label,</font>
<font color="red"> 150.                            get_permission_codename('delete', opts))</font>
<font color="red"> 151.             if not user.has_perm(p):</font>
<font color="red"> 152.                 perms_needed.add(opts.verbose_name)</font>
<font color="black"> 153.             # Display a link to the admin page.</font>
<font color="red"> 154.             return format_html('{}: &lt;a href=&quot;{}&quot;&gt;{}&lt;/a&gt;',</font>
<font color="red"> 155.                                capfirst(opts.verbose_name),</font>
<font color="red"> 156.                                admin_url,</font>
<font color="red"> 157.                                obj)</font>
<font color="black"> 158.         else:</font>
<font color="black"> 159.             # Don't display link to edit, because it either has no</font>
<font color="black"> 160.             # admin or is edited inline.</font>
<font color="red"> 161.             return no_edit_link</font>
<font color="black"> 162. </font>
<font color="red"> 163.     to_delete = collector.nested(format_callback)</font>
<font color="black"> 164. </font>
<font color="red"> 165.     protected = [format_callback(obj) for obj in collector.protected]</font>
<font color="black"> 166. </font>
<font color="red"> 167.     return to_delete, collector.model_count, perms_needed, protected</font>
<font color="black"> 168. </font>
<font color="black"> 169. </font>
<font color="green"> 170. class NestedObjects(Collector):</font>
<font color="green"> 171.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 172.         super(NestedObjects, self).__init__(*args, **kwargs)</font>
<font color="red"> 173.         self.edges = {}  # {from_instance: [to_instances]}</font>
<font color="red"> 174.         self.protected = set()</font>
<font color="red"> 175.         self.model_count = defaultdict(int)</font>
<font color="black"> 176. </font>
<font color="green"> 177.     def add_edge(self, source, target):</font>
<font color="red"> 178.         self.edges.setdefault(source, []).append(target)</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def collect(self, objs, source=None, source_attr=None, **kwargs):</font>
<font color="red"> 181.         for obj in objs:</font>
<font color="red"> 182.             if source_attr and not source_attr.endswith('+'):</font>
<font color="red"> 183.                 related_name = source_attr % {</font>
<font color="red"> 184.                     'class': source._meta.model_name,</font>
<font color="red"> 185.                     'app_label': source._meta.app_label,</font>
<font color="black"> 186.                 }</font>
<font color="red"> 187.                 self.add_edge(getattr(obj, related_name), obj)</font>
<font color="black"> 188.             else:</font>
<font color="red"> 189.                 self.add_edge(None, obj)</font>
<font color="red"> 190.             self.model_count[obj._meta.verbose_name_plural] += 1</font>
<font color="red"> 191.         try:</font>
<font color="red"> 192.             return super(NestedObjects, self).collect(objs, source_attr=source_attr, **kwargs)</font>
<font color="red"> 193.         except models.ProtectedError as e:</font>
<font color="red"> 194.             self.protected.update(e.protected_objects)</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def related_objects(self, related, objs):</font>
<font color="red"> 197.         qs = super(NestedObjects, self).related_objects(related, objs)</font>
<font color="red"> 198.         return qs.select_related(related.field.name)</font>
<font color="black"> 199. </font>
<font color="green"> 200.     def _nested(self, obj, seen, format_callback):</font>
<font color="red"> 201.         if obj in seen:</font>
<font color="red"> 202.             return []</font>
<font color="red"> 203.         seen.add(obj)</font>
<font color="red"> 204.         children = []</font>
<font color="red"> 205.         for child in self.edges.get(obj, ()):</font>
<font color="red"> 206.             children.extend(self._nested(child, seen, format_callback))</font>
<font color="red"> 207.         if format_callback:</font>
<font color="red"> 208.             ret = [format_callback(obj)]</font>
<font color="black"> 209.         else:</font>
<font color="red"> 210.             ret = [obj]</font>
<font color="red"> 211.         if children:</font>
<font color="red"> 212.             ret.append(children)</font>
<font color="red"> 213.         return ret</font>
<font color="black"> 214. </font>
<font color="green"> 215.     def nested(self, format_callback=None):</font>
<font color="black"> 216.         &quot;&quot;&quot;</font>
<font color="black"> 217.         Return the graph as a nested list.</font>
<font color="black"> 218.         &quot;&quot;&quot;</font>
<font color="red"> 219.         seen = set()</font>
<font color="red"> 220.         roots = []</font>
<font color="red"> 221.         for root in self.edges.get(None, ()):</font>
<font color="red"> 222.             roots.extend(self._nested(root, seen, format_callback))</font>
<font color="red"> 223.         return roots</font>
<font color="black"> 224. </font>
<font color="green"> 225.     def can_fast_delete(self, *args, **kwargs):</font>
<font color="black"> 226.         &quot;&quot;&quot;</font>
<font color="black"> 227.         We always want to load the objects into memory so that we can display</font>
<font color="black"> 228.         them to the user in confirm page.</font>
<font color="black"> 229.         &quot;&quot;&quot;</font>
<font color="red"> 230.         return False</font>
<font color="black"> 231. </font>
<font color="black"> 232. </font>
<font color="green"> 233. def model_format_dict(obj):</font>
<font color="black"> 234.     &quot;&quot;&quot;</font>
<font color="black"> 235.     Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',</font>
<font color="black"> 236.     typically for use with string formatting.</font>
<font color="black"> 237. </font>
<font color="black"> 238.     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.</font>
<font color="black"> 239.     &quot;&quot;&quot;</font>
<font color="red"> 240.     if isinstance(obj, (models.Model, models.base.ModelBase)):</font>
<font color="red"> 241.         opts = obj._meta</font>
<font color="red"> 242.     elif isinstance(obj, models.query.QuerySet):</font>
<font color="red"> 243.         opts = obj.model._meta</font>
<font color="black"> 244.     else:</font>
<font color="red"> 245.         opts = obj</font>
<font color="red"> 246.     return {</font>
<font color="red"> 247.         'verbose_name': force_text(opts.verbose_name),</font>
<font color="red"> 248.         'verbose_name_plural': force_text(opts.verbose_name_plural)</font>
<font color="black"> 249.     }</font>
<font color="black"> 250. </font>
<font color="black"> 251. </font>
<font color="green"> 252. def model_ngettext(obj, n=None):</font>
<font color="black"> 253.     &quot;&quot;&quot;</font>
<font color="black"> 254.     Return the appropriate `verbose_name` or `verbose_name_plural` value for</font>
<font color="black"> 255.     `obj` depending on the count `n`.</font>
<font color="black"> 256. </font>
<font color="black"> 257.     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.</font>
<font color="black"> 258.     If `obj` is a `QuerySet` instance, `n` is optional and the length of the</font>
<font color="black"> 259.     `QuerySet` is used.</font>
<font color="black"> 260.     &quot;&quot;&quot;</font>
<font color="red"> 261.     if isinstance(obj, models.query.QuerySet):</font>
<font color="red"> 262.         if n is None:</font>
<font color="red"> 263.             n = obj.count()</font>
<font color="red"> 264.         obj = obj.model</font>
<font color="red"> 265.     d = model_format_dict(obj)</font>
<font color="red"> 266.     singular, plural = d[&quot;verbose_name&quot;], d[&quot;verbose_name_plural&quot;]</font>
<font color="red"> 267.     return ungettext(singular, plural, n or 0)</font>
<font color="black"> 268. </font>
<font color="black"> 269. </font>
<font color="green"> 270. def lookup_field(name, obj, model_admin=None):</font>
<font color="red"> 271.     opts = obj._meta</font>
<font color="red"> 272.     try:</font>
<font color="red"> 273.         f = _get_non_gfk_field(opts, name)</font>
<font color="red"> 274.     except FieldDoesNotExist:</font>
<font color="black"> 275.         # For non-field values, the value is either a method, property or</font>
<font color="black"> 276.         # returned via a callable.</font>
<font color="red"> 277.         if callable(name):</font>
<font color="red"> 278.             attr = name</font>
<font color="red"> 279.             value = attr(obj)</font>
<font color="red"> 280.         elif (model_admin is not None and</font>
<font color="red"> 281.                 hasattr(model_admin, name) and</font>
<font color="red"> 282.                 not name == '__str__' and</font>
<font color="red"> 283.                 not name == '__unicode__'):</font>
<font color="red"> 284.             attr = getattr(model_admin, name)</font>
<font color="red"> 285.             value = attr(obj)</font>
<font color="black"> 286.         else:</font>
<font color="red"> 287.             attr = getattr(obj, name)</font>
<font color="red"> 288.             if callable(attr):</font>
<font color="red"> 289.                 value = attr()</font>
<font color="black"> 290.             else:</font>
<font color="red"> 291.                 value = attr</font>
<font color="red"> 292.         f = None</font>
<font color="black"> 293.     else:</font>
<font color="red"> 294.         attr = None</font>
<font color="red"> 295.         value = getattr(obj, name)</font>
<font color="red"> 296.     return f, attr, value</font>
<font color="black"> 297. </font>
<font color="black"> 298. </font>
<font color="green"> 299. def _get_non_gfk_field(opts, name):</font>
<font color="black"> 300.     &quot;&quot;&quot;</font>
<font color="black"> 301.     For historical reasons, the admin app relies on GenericForeignKeys as being</font>
<font color="black"> 302.     &quot;not found&quot; by get_field(). This could likely be cleaned up.</font>
<font color="black"> 303. </font>
<font color="black"> 304.     Reverse relations should also be excluded as these aren't attributes of the</font>
<font color="black"> 305.     model (rather something like `foo_set`).</font>
<font color="black"> 306.     &quot;&quot;&quot;</font>
<font color="red"> 307.     field = opts.get_field(name)</font>
<font color="red"> 308.     if (field.is_relation and</font>
<font color="black"> 309.             # Generic foreign keys OR reverse relations</font>
<font color="red"> 310.             ((field.many_to_one and not field.related_model) or field.one_to_many)):</font>
<font color="red"> 311.         raise FieldDoesNotExist()</font>
<font color="red"> 312.     return field</font>
<font color="black"> 313. </font>
<font color="black"> 314. </font>
<font color="green"> 315. def label_for_field(name, model, model_admin=None, return_attr=False):</font>
<font color="black"> 316.     &quot;&quot;&quot;</font>
<font color="black"> 317.     Returns a sensible label for a field name. The name can be a callable,</font>
<font color="black"> 318.     property (but not created with @property decorator) or the name of an</font>
<font color="black"> 319.     object's attribute, as well as a genuine fields. If return_attr is</font>
<font color="black"> 320.     True, the resolved attribute (which could be a callable) is also returned.</font>
<font color="black"> 321.     This will be None if (and only if) the name refers to a field.</font>
<font color="black"> 322.     &quot;&quot;&quot;</font>
<font color="red"> 323.     attr = None</font>
<font color="red"> 324.     try:</font>
<font color="red"> 325.         field = _get_non_gfk_field(model._meta, name)</font>
<font color="red"> 326.         try:</font>
<font color="red"> 327.             label = field.verbose_name</font>
<font color="red"> 328.         except AttributeError:</font>
<font color="black"> 329.             # field is likely a ForeignObjectRel</font>
<font color="red"> 330.             label = field.related_model._meta.verbose_name</font>
<font color="red"> 331.     except FieldDoesNotExist:</font>
<font color="red"> 332.         if name == &quot;__unicode__&quot;:</font>
<font color="red"> 333.             label = force_text(model._meta.verbose_name)</font>
<font color="red"> 334.             attr = six.text_type</font>
<font color="red"> 335.         elif name == &quot;__str__&quot;:</font>
<font color="red"> 336.             label = force_str(model._meta.verbose_name)</font>
<font color="red"> 337.             attr = bytes</font>
<font color="black"> 338.         else:</font>
<font color="red"> 339.             if callable(name):</font>
<font color="red"> 340.                 attr = name</font>
<font color="red"> 341.             elif model_admin is not None and hasattr(model_admin, name):</font>
<font color="red"> 342.                 attr = getattr(model_admin, name)</font>
<font color="red"> 343.             elif hasattr(model, name):</font>
<font color="red"> 344.                 attr = getattr(model, name)</font>
<font color="black"> 345.             else:</font>
<font color="red"> 346.                 message = &quot;Unable to lookup '%s' on %s&quot; % (name, model._meta.object_name)</font>
<font color="red"> 347.                 if model_admin:</font>
<font color="red"> 348.                     message += &quot; or %s&quot; % (model_admin.__class__.__name__,)</font>
<font color="red"> 349.                 raise AttributeError(message)</font>
<font color="black"> 350. </font>
<font color="red"> 351.             if hasattr(attr, &quot;short_description&quot;):</font>
<font color="red"> 352.                 label = attr.short_description</font>
<font color="red"> 353.             elif (isinstance(attr, property) and</font>
<font color="red"> 354.                   hasattr(attr, &quot;fget&quot;) and</font>
<font color="red"> 355.                   hasattr(attr.fget, &quot;short_description&quot;)):</font>
<font color="red"> 356.                 label = attr.fget.short_description</font>
<font color="red"> 357.             elif callable(attr):</font>
<font color="red"> 358.                 if attr.__name__ == &quot;&lt;lambda&gt;&quot;:</font>
<font color="red"> 359.                     label = &quot;--&quot;</font>
<font color="black"> 360.                 else:</font>
<font color="red"> 361.                     label = pretty_name(attr.__name__)</font>
<font color="black"> 362.             else:</font>
<font color="red"> 363.                 label = pretty_name(name)</font>
<font color="red"> 364.     if return_attr:</font>
<font color="red"> 365.         return (label, attr)</font>
<font color="black"> 366.     else:</font>
<font color="red"> 367.         return label</font>
<font color="black"> 368. </font>
<font color="black"> 369. </font>
<font color="green"> 370. def help_text_for_field(name, model):</font>
<font color="red"> 371.     help_text = &quot;&quot;</font>
<font color="red"> 372.     try:</font>
<font color="red"> 373.         field = _get_non_gfk_field(model._meta, name)</font>
<font color="red"> 374.     except FieldDoesNotExist:</font>
<font color="red"> 375.         pass</font>
<font color="black"> 376.     else:</font>
<font color="red"> 377.         if hasattr(field, 'help_text'):</font>
<font color="red"> 378.             help_text = field.help_text</font>
<font color="red"> 379.     return smart_text(help_text)</font>
<font color="black"> 380. </font>
<font color="black"> 381. </font>
<font color="green"> 382. def display_for_field(value, field, empty_value_display):</font>
<font color="red"> 383.     from django.contrib.admin.templatetags.admin_list import _boolean_icon</font>
<font color="black"> 384. </font>
<font color="red"> 385.     if field.flatchoices:</font>
<font color="red"> 386.         return dict(field.flatchoices).get(value, empty_value_display)</font>
<font color="black"> 387.     # NullBooleanField needs special-case null-handling, so it comes</font>
<font color="black"> 388.     # before the general null test.</font>
<font color="red"> 389.     elif isinstance(field, models.BooleanField) or isinstance(field, models.NullBooleanField):</font>
<font color="red"> 390.         return _boolean_icon(value)</font>
<font color="red"> 391.     elif value is None:</font>
<font color="red"> 392.         return empty_value_display</font>
<font color="red"> 393.     elif isinstance(field, models.DateTimeField):</font>
<font color="red"> 394.         return formats.localize(timezone.template_localtime(value))</font>
<font color="red"> 395.     elif isinstance(field, (models.DateField, models.TimeField)):</font>
<font color="red"> 396.         return formats.localize(value)</font>
<font color="red"> 397.     elif isinstance(field, models.DecimalField):</font>
<font color="red"> 398.         return formats.number_format(value, field.decimal_places)</font>
<font color="red"> 399.     elif isinstance(field, (models.IntegerField, models.FloatField)):</font>
<font color="red"> 400.         return formats.number_format(value)</font>
<font color="red"> 401.     elif isinstance(field, models.FileField) and value:</font>
<font color="red"> 402.         return format_html('&lt;a href=&quot;{}&quot;&gt;{}&lt;/a&gt;', value.url, value)</font>
<font color="black"> 403.     else:</font>
<font color="red"> 404.         return smart_text(value)</font>
<font color="black"> 405. </font>
<font color="black"> 406. </font>
<font color="green"> 407. def display_for_value(value, empty_value_display, boolean=False):</font>
<font color="red"> 408.     from django.contrib.admin.templatetags.admin_list import _boolean_icon</font>
<font color="black"> 409. </font>
<font color="red"> 410.     if boolean:</font>
<font color="red"> 411.         return _boolean_icon(value)</font>
<font color="red"> 412.     elif value is None:</font>
<font color="red"> 413.         return empty_value_display</font>
<font color="red"> 414.     elif isinstance(value, datetime.datetime):</font>
<font color="red"> 415.         return formats.localize(timezone.template_localtime(value))</font>
<font color="red"> 416.     elif isinstance(value, (datetime.date, datetime.time)):</font>
<font color="red"> 417.         return formats.localize(value)</font>
<font color="red"> 418.     elif isinstance(value, six.integer_types + (decimal.Decimal, float)):</font>
<font color="red"> 419.         return formats.number_format(value)</font>
<font color="black"> 420.     else:</font>
<font color="red"> 421.         return smart_text(value)</font>
<font color="black"> 422. </font>
<font color="black"> 423. </font>
<font color="green"> 424. class NotRelationField(Exception):</font>
<font color="green"> 425.     pass</font>
<font color="black"> 426. </font>
<font color="black"> 427. </font>
<font color="green"> 428. def get_model_from_relation(field):</font>
<font color="red"> 429.     if hasattr(field, 'get_path_info'):</font>
<font color="red"> 430.         return field.get_path_info()[-1].to_opts.model</font>
<font color="black"> 431.     else:</font>
<font color="red"> 432.         raise NotRelationField</font>
<font color="black"> 433. </font>
<font color="black"> 434. </font>
<font color="green"> 435. def reverse_field_path(model, path):</font>
<font color="black"> 436.     &quot;&quot;&quot; Create a reversed field path.</font>
<font color="black"> 437. </font>
<font color="black"> 438.     E.g. Given (Order, &quot;user__groups&quot;),</font>
<font color="black"> 439.     return (Group, &quot;user__order&quot;).</font>
<font color="black"> 440. </font>
<font color="black"> 441.     Final field must be a related model, not a data field.</font>
<font color="black"> 442.     &quot;&quot;&quot;</font>
<font color="red"> 443.     reversed_path = []</font>
<font color="red"> 444.     parent = model</font>
<font color="red"> 445.     pieces = path.split(LOOKUP_SEP)</font>
<font color="red"> 446.     for piece in pieces:</font>
<font color="red"> 447.         field = parent._meta.get_field(piece)</font>
<font color="black"> 448.         # skip trailing data field if extant:</font>
<font color="red"> 449.         if len(reversed_path) == len(pieces) - 1:  # final iteration</font>
<font color="red"> 450.             try:</font>
<font color="red"> 451.                 get_model_from_relation(field)</font>
<font color="red"> 452.             except NotRelationField:</font>
<font color="red"> 453.                 break</font>
<font color="black"> 454. </font>
<font color="black"> 455.         # Field should point to another model</font>
<font color="red"> 456.         if field.is_relation and not (field.auto_created and not field.concrete):</font>
<font color="red"> 457.             related_name = field.related_query_name()</font>
<font color="red"> 458.             parent = field.remote_field.model</font>
<font color="black"> 459.         else:</font>
<font color="red"> 460.             related_name = field.field.name</font>
<font color="red"> 461.             parent = field.related_model</font>
<font color="red"> 462.         reversed_path.insert(0, related_name)</font>
<font color="red"> 463.     return (parent, LOOKUP_SEP.join(reversed_path))</font>
<font color="black"> 464. </font>
<font color="black"> 465. </font>
<font color="green"> 466. def get_fields_from_path(model, path):</font>
<font color="black"> 467.     &quot;&quot;&quot; Return list of Fields given path relative to model.</font>
<font color="black"> 468. </font>
<font color="black"> 469.     e.g. (ModelX, &quot;user__groups__name&quot;) -&gt; [</font>
<font color="black"> 470.         &lt;django.db.models.fields.related.ForeignKey object at 0x...&gt;,</font>
<font color="black"> 471.         &lt;django.db.models.fields.related.ManyToManyField object at 0x...&gt;,</font>
<font color="black"> 472.         &lt;django.db.models.fields.CharField object at 0x...&gt;,</font>
<font color="black"> 473.     ]</font>
<font color="black"> 474.     &quot;&quot;&quot;</font>
<font color="green"> 475.     pieces = path.split(LOOKUP_SEP)</font>
<font color="green"> 476.     fields = []</font>
<font color="green"> 477.     for piece in pieces:</font>
<font color="green"> 478.         if fields:</font>
<font color="red"> 479.             parent = get_model_from_relation(fields[-1])</font>
<font color="black"> 480.         else:</font>
<font color="green"> 481.             parent = model</font>
<font color="green"> 482.         fields.append(parent._meta.get_field(piece))</font>
<font color="green"> 483.     return fields</font>
<font color="black"> 484. </font>
<font color="black"> 485. </font>
<font color="green"> 486. def remove_trailing_data_field(fields):</font>
<font color="black"> 487.     &quot;&quot;&quot; Discard trailing non-relation field if extant. &quot;&quot;&quot;</font>
<font color="red"> 488.     try:</font>
<font color="red"> 489.         get_model_from_relation(fields[-1])</font>
<font color="red"> 490.     except NotRelationField:</font>
<font color="red"> 491.         fields = fields[:-1]</font>
<font color="red"> 492.     return fields</font>
</pre>

