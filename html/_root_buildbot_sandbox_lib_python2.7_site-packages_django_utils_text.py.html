source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/text.py</b><br>


file stats: <b>234 lines, 62 executed: 26.5% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import re</font>
<font color="green">   4. import unicodedata</font>
<font color="green">   5. from gzip import GzipFile</font>
<font color="green">   6. from io import BytesIO</font>
<font color="black">   7. </font>
<font color="green">   8. from django.utils import six</font>
<font color="green">   9. from django.utils.encoding import force_text</font>
<font color="green">  10. from django.utils.functional import SimpleLazyObject, allow_lazy</font>
<font color="green">  11. from django.utils.safestring import SafeText, mark_safe</font>
<font color="green">  12. from django.utils.six.moves import html_entities</font>
<font color="green">  13. from django.utils.translation import pgettext, ugettext as _, ugettext_lazy</font>
<font color="black">  14. </font>
<font color="green">  15. if six.PY2:</font>
<font color="black">  16.     # Import force_unicode even though this module doesn't use it, because some</font>
<font color="black">  17.     # people rely on it being here.</font>
<font color="green">  18.     from django.utils.encoding import force_unicode  # NOQA</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="black">  21. # Capitalizes the first letter of a string.</font>
<font color="green">  22. capfirst = lambda x: x and force_text(x)[0].upper() + force_text(x)[1:]</font>
<font color="green">  23. capfirst = allow_lazy(capfirst, six.text_type)</font>
<font color="black">  24. </font>
<font color="black">  25. # Set up regular expressions</font>
<font color="green">  26. re_words = re.compile(r'&lt;.*?&gt;|((?:\w[-\w]*|&amp;.*?;)+)', re.U | re.S)</font>
<font color="green">  27. re_chars = re.compile(r'&lt;.*?&gt;|(.)', re.U | re.S)</font>
<font color="green">  28. re_tag = re.compile(r'&lt;(/)?([^ ]+?)(?:(\s*/)| .*?)?&gt;', re.S)</font>
<font color="green">  29. re_newlines = re.compile(r'\r\n|\r')  # Used in normalize_newlines</font>
<font color="green">  30. re_camel_case = re.compile(r'(((?&lt;=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))')</font>
<font color="black">  31. </font>
<font color="black">  32. </font>
<font color="green">  33. def wrap(text, width):</font>
<font color="black">  34.     &quot;&quot;&quot;</font>
<font color="black">  35.     A word-wrap function that preserves existing line breaks. Expects that</font>
<font color="black">  36.     existing line breaks are posix newlines.</font>
<font color="black">  37. </font>
<font color="black">  38.     All white space is preserved except added line breaks consume the space on</font>
<font color="black">  39.     which they break the line.</font>
<font color="black">  40. </font>
<font color="black">  41.     Long words are not wrapped, so the output text may have lines longer than</font>
<font color="black">  42.     ``width``.</font>
<font color="black">  43.     &quot;&quot;&quot;</font>
<font color="red">  44.     text = force_text(text)</font>
<font color="black">  45. </font>
<font color="red">  46.     def _generator():</font>
<font color="red">  47.         for line in text.splitlines(True):  # True keeps trailing linebreaks</font>
<font color="red">  48.             max_width = min((line.endswith('\n') and width + 1 or width), width)</font>
<font color="red">  49.             while len(line) &gt; max_width:</font>
<font color="red">  50.                 space = line[:max_width + 1].rfind(' ') + 1</font>
<font color="red">  51.                 if space == 0:</font>
<font color="red">  52.                     space = line.find(' ') + 1</font>
<font color="red">  53.                     if space == 0:</font>
<font color="red">  54.                         yield line</font>
<font color="red">  55.                         line = ''</font>
<font color="red">  56.                         break</font>
<font color="red">  57.                 yield '%s\n' % line[:space - 1]</font>
<font color="red">  58.                 line = line[space:]</font>
<font color="red">  59.                 max_width = min((line.endswith('\n') and width + 1 or width), width)</font>
<font color="red">  60.             if line:</font>
<font color="red">  61.                 yield line</font>
<font color="red">  62.     return ''.join(_generator())</font>
<font color="green">  63. wrap = allow_lazy(wrap, six.text_type)</font>
<font color="black">  64. </font>
<font color="black">  65. </font>
<font color="green">  66. class Truncator(SimpleLazyObject):</font>
<font color="black">  67.     &quot;&quot;&quot;</font>
<font color="black">  68.     An object used to truncate text, either by characters or words.</font>
<font color="green">  69.     &quot;&quot;&quot;</font>
<font color="green">  70.     def __init__(self, text):</font>
<font color="red">  71.         super(Truncator, self).__init__(lambda: force_text(text))</font>
<font color="black">  72. </font>
<font color="green">  73.     def add_truncation_text(self, text, truncate=None):</font>
<font color="red">  74.         if truncate is None:</font>
<font color="red">  75.             truncate = pgettext(</font>
<font color="red">  76.                 'String to return when truncating text',</font>
<font color="red">  77.                 '%(truncated_text)s...')</font>
<font color="red">  78.         truncate = force_text(truncate)</font>
<font color="red">  79.         if '%(truncated_text)s' in truncate:</font>
<font color="red">  80.             return truncate % {'truncated_text': text}</font>
<font color="black">  81.         # The truncation text didn't contain the %(truncated_text)s string</font>
<font color="black">  82.         # replacement argument so just append it to the text.</font>
<font color="red">  83.         if text.endswith(truncate):</font>
<font color="black">  84.             # But don't append the truncation text if the current text already</font>
<font color="black">  85.             # ends in this.</font>
<font color="red">  86.             return text</font>
<font color="red">  87.         return '%s%s' % (text, truncate)</font>
<font color="black">  88. </font>
<font color="green">  89.     def chars(self, num, truncate=None, html=False):</font>
<font color="black">  90.         &quot;&quot;&quot;</font>
<font color="black">  91.         Returns the text truncated to be no longer than the specified number</font>
<font color="black">  92.         of characters.</font>
<font color="black">  93. </font>
<font color="black">  94.         Takes an optional argument of what should be used to notify that the</font>
<font color="black">  95.         string has been truncated, defaulting to a translatable string of an</font>
<font color="black">  96.         ellipsis (...).</font>
<font color="black">  97.         &quot;&quot;&quot;</font>
<font color="red">  98.         length = int(num)</font>
<font color="red">  99.         text = unicodedata.normalize('NFC', self._wrapped)</font>
<font color="black"> 100. </font>
<font color="black"> 101.         # Calculate the length to truncate to (max length - end_text length)</font>
<font color="red"> 102.         truncate_len = length</font>
<font color="red"> 103.         for char in self.add_truncation_text('', truncate):</font>
<font color="red"> 104.             if not unicodedata.combining(char):</font>
<font color="red"> 105.                 truncate_len -= 1</font>
<font color="red"> 106.                 if truncate_len == 0:</font>
<font color="red"> 107.                     break</font>
<font color="red"> 108.         if html:</font>
<font color="red"> 109.             return self._truncate_html(length, truncate, text, truncate_len, False)</font>
<font color="red"> 110.         return self._text_chars(length, truncate, text, truncate_len)</font>
<font color="green"> 111.     chars = allow_lazy(chars)</font>
<font color="black"> 112. </font>
<font color="green"> 113.     def _text_chars(self, length, truncate, text, truncate_len):</font>
<font color="black"> 114.         &quot;&quot;&quot;</font>
<font color="black"> 115.         Truncates a string after a certain number of chars.</font>
<font color="black"> 116.         &quot;&quot;&quot;</font>
<font color="red"> 117.         s_len = 0</font>
<font color="red"> 118.         end_index = None</font>
<font color="red"> 119.         for i, char in enumerate(text):</font>
<font color="red"> 120.             if unicodedata.combining(char):</font>
<font color="black"> 121.                 # Don't consider combining characters</font>
<font color="black"> 122.                 # as adding to the string length</font>
<font color="red"> 123.                 continue</font>
<font color="red"> 124.             s_len += 1</font>
<font color="red"> 125.             if end_index is None and s_len &gt; truncate_len:</font>
<font color="red"> 126.                 end_index = i</font>
<font color="red"> 127.             if s_len &gt; length:</font>
<font color="black"> 128.                 # Return the truncated string</font>
<font color="red"> 129.                 return self.add_truncation_text(text[:end_index or 0],</font>
<font color="red"> 130.                                                 truncate)</font>
<font color="black"> 131. </font>
<font color="black"> 132.         # Return the original string since no truncation was necessary</font>
<font color="red"> 133.         return text</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def words(self, num, truncate=None, html=False):</font>
<font color="black"> 136.         &quot;&quot;&quot;</font>
<font color="black"> 137.         Truncates a string after a certain number of words. Takes an optional</font>
<font color="black"> 138.         argument of what should be used to notify that the string has been</font>
<font color="black"> 139.         truncated, defaulting to ellipsis (...).</font>
<font color="black"> 140.         &quot;&quot;&quot;</font>
<font color="red"> 141.         length = int(num)</font>
<font color="red"> 142.         if html:</font>
<font color="red"> 143.             return self._truncate_html(length, truncate, self._wrapped, length, True)</font>
<font color="red"> 144.         return self._text_words(length, truncate)</font>
<font color="green"> 145.     words = allow_lazy(words)</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def _text_words(self, length, truncate):</font>
<font color="black"> 148.         &quot;&quot;&quot;</font>
<font color="black"> 149.         Truncates a string after a certain number of words.</font>
<font color="black"> 150. </font>
<font color="black"> 151.         Newlines in the string will be stripped.</font>
<font color="black"> 152.         &quot;&quot;&quot;</font>
<font color="red"> 153.         words = self._wrapped.split()</font>
<font color="red"> 154.         if len(words) &gt; length:</font>
<font color="red"> 155.             words = words[:length]</font>
<font color="red"> 156.             return self.add_truncation_text(' '.join(words), truncate)</font>
<font color="red"> 157.         return ' '.join(words)</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def _truncate_html(self, length, truncate, text, truncate_len, words):</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="black"> 161.         Truncates HTML to a certain number of chars (not counting tags and</font>
<font color="black"> 162.         comments), or, if words is True, then to a certain number of words.</font>
<font color="black"> 163.         Closes opened tags if they were correctly closed in the given HTML.</font>
<font color="black"> 164. </font>
<font color="black"> 165.         Newlines in the HTML are preserved.</font>
<font color="black"> 166.         &quot;&quot;&quot;</font>
<font color="red"> 167.         if words and length &lt;= 0:</font>
<font color="red"> 168.             return ''</font>
<font color="black"> 169. </font>
<font color="black"> 170.         html4_singlets = (</font>
<font color="black"> 171.             'br', 'col', 'link', 'base', 'img',</font>
<font color="red"> 172.             'param', 'area', 'hr', 'input'</font>
<font color="black"> 173.         )</font>
<font color="black"> 174. </font>
<font color="black"> 175.         # Count non-HTML chars/words and keep note of open tags</font>
<font color="red"> 176.         pos = 0</font>
<font color="red"> 177.         end_text_pos = 0</font>
<font color="red"> 178.         current_len = 0</font>
<font color="red"> 179.         open_tags = []</font>
<font color="black"> 180. </font>
<font color="red"> 181.         regex = re_words if words else re_chars</font>
<font color="black"> 182. </font>
<font color="red"> 183.         while current_len &lt;= length:</font>
<font color="red"> 184.             m = regex.search(text, pos)</font>
<font color="red"> 185.             if not m:</font>
<font color="black"> 186.                 # Checked through whole string</font>
<font color="red"> 187.                 break</font>
<font color="red"> 188.             pos = m.end(0)</font>
<font color="red"> 189.             if m.group(1):</font>
<font color="black"> 190.                 # It's an actual non-HTML word or char</font>
<font color="red"> 191.                 current_len += 1</font>
<font color="red"> 192.                 if current_len == truncate_len:</font>
<font color="red"> 193.                     end_text_pos = pos</font>
<font color="red"> 194.                 continue</font>
<font color="black"> 195.             # Check for tag</font>
<font color="red"> 196.             tag = re_tag.match(m.group(0))</font>
<font color="red"> 197.             if not tag or current_len &gt;= truncate_len:</font>
<font color="black"> 198.                 # Don't worry about non tags or tags after our truncate point</font>
<font color="red"> 199.                 continue</font>
<font color="red"> 200.             closing_tag, tagname, self_closing = tag.groups()</font>
<font color="black"> 201.             # Element names are always case-insensitive</font>
<font color="red"> 202.             tagname = tagname.lower()</font>
<font color="red"> 203.             if self_closing or tagname in html4_singlets:</font>
<font color="red"> 204.                 pass</font>
<font color="red"> 205.             elif closing_tag:</font>
<font color="black"> 206.                 # Check for match in open tags list</font>
<font color="red"> 207.                 try:</font>
<font color="red"> 208.                     i = open_tags.index(tagname)</font>
<font color="red"> 209.                 except ValueError:</font>
<font color="red"> 210.                     pass</font>
<font color="black"> 211.                 else:</font>
<font color="black"> 212.                     # SGML: An end tag closes, back to the matching start tag,</font>
<font color="black"> 213.                     # all unclosed intervening start tags with omitted end tags</font>
<font color="red"> 214.                     open_tags = open_tags[i + 1:]</font>
<font color="black"> 215.             else:</font>
<font color="black"> 216.                 # Add it to the start of the open tags list</font>
<font color="red"> 217.                 open_tags.insert(0, tagname)</font>
<font color="black"> 218. </font>
<font color="red"> 219.         if current_len &lt;= length:</font>
<font color="red"> 220.             return text</font>
<font color="red"> 221.         out = text[:end_text_pos]</font>
<font color="red"> 222.         truncate_text = self.add_truncation_text('', truncate)</font>
<font color="red"> 223.         if truncate_text:</font>
<font color="red"> 224.             out += truncate_text</font>
<font color="black"> 225.         # Close any tags still open</font>
<font color="red"> 226.         for tag in open_tags:</font>
<font color="red"> 227.             out += '&lt;/%s&gt;' % tag</font>
<font color="black"> 228.         # Return string</font>
<font color="red"> 229.         return out</font>
<font color="black"> 230. </font>
<font color="black"> 231. </font>
<font color="green"> 232. def get_valid_filename(s):</font>
<font color="black"> 233.     &quot;&quot;&quot;</font>
<font color="black"> 234.     Returns the given string converted to a string that can be used for a clean</font>
<font color="black"> 235.     filename. Specifically, leading and trailing spaces are removed; other</font>
<font color="black"> 236.     spaces are converted to underscores; and anything that is not a unicode</font>
<font color="black"> 237.     alphanumeric, dash, underscore, or dot, is removed.</font>
<font color="black"> 238.     &gt;&gt;&gt; get_valid_filename(&quot;john's portrait in 2004.jpg&quot;)</font>
<font color="black"> 239.     'johns_portrait_in_2004.jpg'</font>
<font color="black"> 240.     &quot;&quot;&quot;</font>
<font color="red"> 241.     s = force_text(s).strip().replace(' ', '_')</font>
<font color="red"> 242.     return re.sub(r'(?u)[^-\w.]', '', s)</font>
<font color="green"> 243. get_valid_filename = allow_lazy(get_valid_filename, six.text_type)</font>
<font color="black"> 244. </font>
<font color="black"> 245. </font>
<font color="green"> 246. def get_text_list(list_, last_word=ugettext_lazy('or')):</font>
<font color="black"> 247.     &quot;&quot;&quot;</font>
<font color="black"> 248.     &gt;&gt;&gt; get_text_list(['a', 'b', 'c', 'd'])</font>
<font color="black"> 249.     'a, b, c or d'</font>
<font color="black"> 250.     &gt;&gt;&gt; get_text_list(['a', 'b', 'c'], 'and')</font>
<font color="black"> 251.     'a, b and c'</font>
<font color="black"> 252.     &gt;&gt;&gt; get_text_list(['a', 'b'], 'and')</font>
<font color="black"> 253.     'a and b'</font>
<font color="black"> 254.     &gt;&gt;&gt; get_text_list(['a'])</font>
<font color="black"> 255.     'a'</font>
<font color="black"> 256.     &gt;&gt;&gt; get_text_list([])</font>
<font color="black"> 257.     ''</font>
<font color="black"> 258.     &quot;&quot;&quot;</font>
<font color="red"> 259.     if len(list_) == 0:</font>
<font color="red"> 260.         return ''</font>
<font color="red"> 261.     if len(list_) == 1:</font>
<font color="red"> 262.         return force_text(list_[0])</font>
<font color="red"> 263.     return '%s %s %s' % (</font>
<font color="black"> 264.         # Translators: This string is used as a separator between list elements</font>
<font color="red"> 265.         _(', ').join(force_text(i) for i in list_[:-1]),</font>
<font color="red"> 266.         force_text(last_word), force_text(list_[-1]))</font>
<font color="green"> 267. get_text_list = allow_lazy(get_text_list, six.text_type)</font>
<font color="black"> 268. </font>
<font color="black"> 269. </font>
<font color="green"> 270. def normalize_newlines(text):</font>
<font color="black"> 271.     &quot;&quot;&quot;Normalizes CRLF and CR newlines to just LF.&quot;&quot;&quot;</font>
<font color="red"> 272.     text = force_text(text)</font>
<font color="red"> 273.     return re_newlines.sub('\n', text)</font>
<font color="green"> 274. normalize_newlines = allow_lazy(normalize_newlines, six.text_type)</font>
<font color="black"> 275. </font>
<font color="black"> 276. </font>
<font color="green"> 277. def phone2numeric(phone):</font>
<font color="black"> 278.     &quot;&quot;&quot;Converts a phone number with letters into its numeric equivalent.&quot;&quot;&quot;</font>
<font color="red"> 279.     char2number = {'a': '2', 'b': '2', 'c': '2', 'd': '3', 'e': '3', 'f': '3',</font>
<font color="red"> 280.          'g': '4', 'h': '4', 'i': '4', 'j': '5', 'k': '5', 'l': '5', 'm': '6',</font>
<font color="red"> 281.          'n': '6', 'o': '6', 'p': '7', 'q': '7', 'r': '7', 's': '7', 't': '8',</font>
<font color="red"> 282.          'u': '8', 'v': '8', 'w': '9', 'x': '9', 'y': '9', 'z': '9'}</font>
<font color="red"> 283.     return ''.join(char2number.get(c, c) for c in phone.lower())</font>
<font color="green"> 284. phone2numeric = allow_lazy(phone2numeric)</font>
<font color="black"> 285. </font>
<font color="black"> 286. </font>
<font color="black"> 287. # From http://www.xhaus.com/alan/python/httpcomp.html#gzip</font>
<font color="black"> 288. # Used with permission.</font>
<font color="green"> 289. def compress_string(s):</font>
<font color="red"> 290.     zbuf = BytesIO()</font>
<font color="red"> 291.     zfile = GzipFile(mode='wb', compresslevel=6, fileobj=zbuf)</font>
<font color="red"> 292.     zfile.write(s)</font>
<font color="red"> 293.     zfile.close()</font>
<font color="red"> 294.     return zbuf.getvalue()</font>
<font color="black"> 295. </font>
<font color="black"> 296. </font>
<font color="green"> 297. class StreamingBuffer(object):</font>
<font color="green"> 298.     def __init__(self):</font>
<font color="red"> 299.         self.vals = []</font>
<font color="black"> 300. </font>
<font color="green"> 301.     def write(self, val):</font>
<font color="red"> 302.         self.vals.append(val)</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def read(self):</font>
<font color="red"> 305.         if not self.vals:</font>
<font color="red"> 306.             return b''</font>
<font color="red"> 307.         ret = b''.join(self.vals)</font>
<font color="red"> 308.         self.vals = []</font>
<font color="red"> 309.         return ret</font>
<font color="black"> 310. </font>
<font color="green"> 311.     def flush(self):</font>
<font color="red"> 312.         return</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def close(self):</font>
<font color="red"> 315.         return</font>
<font color="black"> 316. </font>
<font color="black"> 317. </font>
<font color="black"> 318. # Like compress_string, but for iterators of strings.</font>
<font color="green"> 319. def compress_sequence(sequence):</font>
<font color="red"> 320.     buf = StreamingBuffer()</font>
<font color="red"> 321.     zfile = GzipFile(mode='wb', compresslevel=6, fileobj=buf)</font>
<font color="black"> 322.     # Output headers...</font>
<font color="red"> 323.     yield buf.read()</font>
<font color="red"> 324.     for item in sequence:</font>
<font color="red"> 325.         zfile.write(item)</font>
<font color="red"> 326.         data = buf.read()</font>
<font color="red"> 327.         if data:</font>
<font color="red"> 328.             yield data</font>
<font color="red"> 329.     zfile.close()</font>
<font color="red"> 330.     yield buf.read()</font>
<font color="black"> 331. </font>
<font color="black"> 332. </font>
<font color="black"> 333. # Expression to match some_token and some_token=&quot;with spaces&quot; (and similarly</font>
<font color="black"> 334. # for single-quoted strings).</font>
<font color="green"> 335. smart_split_re = re.compile(r&quot;&quot;&quot;</font>
<font color="black"> 336.     ((?:</font>
<font color="black"> 337.         [^\s'&quot;]*</font>
<font color="black"> 338.         (?:</font>
<font color="black"> 339.             (?:&quot;(?:[^&quot;\\]|\\.)*&quot; | '(?:[^'\\]|\\.)*')</font>
<font color="black"> 340.             [^\s'&quot;]*</font>
<font color="black"> 341.         )+</font>
<font color="black"> 342.     ) | \S+)</font>
<font color="green"> 343. &quot;&quot;&quot;, re.VERBOSE)</font>
<font color="black"> 344. </font>
<font color="black"> 345. </font>
<font color="green"> 346. def smart_split(text):</font>
<font color="black"> 347.     r&quot;&quot;&quot;</font>
<font color="black"> 348.     Generator that splits a string by spaces, leaving quoted phrases together.</font>
<font color="black"> 349.     Supports both single and double quotes, and supports escaping quotes with</font>
<font color="black"> 350.     backslashes. In the output, strings will keep their initial and trailing</font>
<font color="black"> 351.     quote marks and escaped quotes will remain escaped (the results can then</font>
<font color="black"> 352.     be further processed with unescape_string_literal()).</font>
<font color="black"> 353. </font>
<font color="black"> 354.     &gt;&gt;&gt; list(smart_split(r'This is &quot;a person\'s&quot; test.'))</font>
<font color="black"> 355.     ['This', 'is', '&quot;a person\\\'s&quot;', 'test.']</font>
<font color="black"> 356.     &gt;&gt;&gt; list(smart_split(r&quot;Another 'person\'s' test.&quot;))</font>
<font color="black"> 357.     ['Another', &quot;'person\\'s'&quot;, 'test.']</font>
<font color="black"> 358.     &gt;&gt;&gt; list(smart_split(r'A &quot;\&quot;funky\&quot; style&quot; test.'))</font>
<font color="black"> 359.     ['A', '&quot;\\&quot;funky\\&quot; style&quot;', 'test.']</font>
<font color="black"> 360.     &quot;&quot;&quot;</font>
<font color="red"> 361.     text = force_text(text)</font>
<font color="red"> 362.     for bit in smart_split_re.finditer(text):</font>
<font color="red"> 363.         yield bit.group(0)</font>
<font color="black"> 364. </font>
<font color="black"> 365. </font>
<font color="green"> 366. def _replace_entity(match):</font>
<font color="red"> 367.     text = match.group(1)</font>
<font color="red"> 368.     if text[0] == '#':</font>
<font color="red"> 369.         text = text[1:]</font>
<font color="red"> 370.         try:</font>
<font color="red"> 371.             if text[0] in 'xX':</font>
<font color="red"> 372.                 c = int(text[1:], 16)</font>
<font color="black"> 373.             else:</font>
<font color="red"> 374.                 c = int(text)</font>
<font color="red"> 375.             return six.unichr(c)</font>
<font color="red"> 376.         except ValueError:</font>
<font color="red"> 377.             return match.group(0)</font>
<font color="black"> 378.     else:</font>
<font color="red"> 379.         try:</font>
<font color="red"> 380.             return six.unichr(html_entities.name2codepoint[text])</font>
<font color="red"> 381.         except (ValueError, KeyError):</font>
<font color="red"> 382.             return match.group(0)</font>
<font color="black"> 383. </font>
<font color="green"> 384. _entity_re = re.compile(r&quot;&amp;(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));&quot;)</font>
<font color="black"> 385. </font>
<font color="black"> 386. </font>
<font color="green"> 387. def unescape_entities(text):</font>
<font color="red"> 388.     return _entity_re.sub(_replace_entity, text)</font>
<font color="green"> 389. unescape_entities = allow_lazy(unescape_entities, six.text_type)</font>
<font color="black"> 390. </font>
<font color="black"> 391. </font>
<font color="green"> 392. def unescape_string_literal(s):</font>
<font color="black"> 393.     r&quot;&quot;&quot;</font>
<font color="black"> 394.     Convert quoted string literals to unquoted strings with escaped quotes and</font>
<font color="black"> 395.     backslashes unquoted::</font>
<font color="black"> 396. </font>
<font color="black"> 397.         &gt;&gt;&gt; unescape_string_literal('&quot;abc&quot;')</font>
<font color="black"> 398.         'abc'</font>
<font color="black"> 399.         &gt;&gt;&gt; unescape_string_literal(&quot;'abc'&quot;)</font>
<font color="black"> 400.         'abc'</font>
<font color="black"> 401.         &gt;&gt;&gt; unescape_string_literal('&quot;a \&quot;bc\&quot;&quot;')</font>
<font color="black"> 402.         'a &quot;bc&quot;'</font>
<font color="black"> 403.         &gt;&gt;&gt; unescape_string_literal(&quot;'\'ab\' c'&quot;)</font>
<font color="black"> 404.         &quot;'ab' c&quot;</font>
<font color="black"> 405.     &quot;&quot;&quot;</font>
<font color="red"> 406.     if s[0] not in &quot;\&quot;'&quot; or s[-1] != s[0]:</font>
<font color="red"> 407.         raise ValueError(&quot;Not a string literal: %r&quot; % s)</font>
<font color="red"> 408.     quote = s[0]</font>
<font color="red"> 409.     return s[1:-1].replace(r'\%s' % quote, quote).replace(r'\\', '\\')</font>
<font color="green"> 410. unescape_string_literal = allow_lazy(unescape_string_literal)</font>
<font color="black"> 411. </font>
<font color="black"> 412. </font>
<font color="green"> 413. def slugify(value, allow_unicode=False):</font>
<font color="black"> 414.     &quot;&quot;&quot;</font>
<font color="black"> 415.     Convert to ASCII if 'allow_unicode' is False. Convert spaces to hyphens.</font>
<font color="black"> 416.     Remove characters that aren't alphanumerics, underscores, or hyphens.</font>
<font color="black"> 417.     Convert to lowercase. Also strip leading and trailing whitespace.</font>
<font color="black"> 418.     &quot;&quot;&quot;</font>
<font color="red"> 419.     value = force_text(value)</font>
<font color="red"> 420.     if allow_unicode:</font>
<font color="red"> 421.         value = unicodedata.normalize('NFKC', value)</font>
<font color="red"> 422.         value = re.sub('[^\w\s-]', '', value, flags=re.U).strip().lower()</font>
<font color="red"> 423.         return mark_safe(re.sub('[-\s]+', '-', value, flags=re.U))</font>
<font color="red"> 424.     value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')</font>
<font color="red"> 425.     value = re.sub('[^\w\s-]', '', value).strip().lower()</font>
<font color="red"> 426.     return mark_safe(re.sub('[-\s]+', '-', value))</font>
<font color="green"> 427. slugify = allow_lazy(slugify, six.text_type, SafeText)</font>
<font color="black"> 428. </font>
<font color="black"> 429. </font>
<font color="green"> 430. def camel_case_to_spaces(value):</font>
<font color="black"> 431.     &quot;&quot;&quot;</font>
<font color="black"> 432.     Splits CamelCase and converts to lower case. Also strips leading and</font>
<font color="black"> 433.     trailing whitespace.</font>
<font color="black"> 434.     &quot;&quot;&quot;</font>
<font color="green"> 435.     return re_camel_case.sub(r' \1', value).strip().lower()</font>
</pre>

