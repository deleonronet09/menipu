source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/html_parser.py</b><br>


file stats: <b>96 lines, 11 executed: 11.5% covered</b>
<pre>
<font color="green">   1. import re</font>
<font color="green">   2. import sys</font>
<font color="black">   3. </font>
<font color="green">   4. from django.utils import six</font>
<font color="green">   5. from django.utils.six.moves import html_parser as _html_parser</font>
<font color="black">   6. </font>
<font color="green">   7. current_version = sys.version_info</font>
<font color="black">   8. </font>
<font color="green">   9. use_workaround = current_version &lt; (2, 7, 3)</font>
<font color="black">  10. </font>
<font color="green">  11. try:</font>
<font color="green">  12.     HTMLParseError = _html_parser.HTMLParseError</font>
<font color="red">  13. except AttributeError:</font>
<font color="black">  14.     # create a dummy class for Python 3.5+ where it's been removed</font>
<font color="red">  15.     class HTMLParseError(Exception):</font>
<font color="red">  16.         pass</font>
<font color="black">  17. </font>
<font color="green">  18. if not use_workaround:</font>
<font color="green">  19.     if six.PY3:</font>
<font color="red">  20.         class HTMLParser(_html_parser.HTMLParser):</font>
<font color="black">  21.             &quot;&quot;&quot;Explicitly set convert_charrefs to be False.</font>
<font color="black">  22. </font>
<font color="black">  23.             This silences a deprecation warning on Python 3.4, but we can't do</font>
<font color="black">  24.             it at call time because Python 2.7 does not have the keyword</font>
<font color="black">  25.             argument.</font>
<font color="red">  26.             &quot;&quot;&quot;</font>
<font color="red">  27.             def __init__(self, convert_charrefs=False, **kwargs):</font>
<font color="red">  28.                 _html_parser.HTMLParser.__init__(self, convert_charrefs=convert_charrefs, **kwargs)</font>
<font color="black">  29.     else:</font>
<font color="green">  30.         HTMLParser = _html_parser.HTMLParser</font>
<font color="black">  31. else:</font>
<font color="red">  32.     tagfind = re.compile('([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!&gt;))*')</font>
<font color="black">  33. </font>
<font color="red">  34.     class HTMLParser(_html_parser.HTMLParser):</font>
<font color="black">  35.         &quot;&quot;&quot;</font>
<font color="black">  36.         Patched version of stdlib's HTMLParser with patch from:</font>
<font color="black">  37.         http://bugs.python.org/issue670664</font>
<font color="red">  38.         &quot;&quot;&quot;</font>
<font color="red">  39.         def __init__(self):</font>
<font color="red">  40.             _html_parser.HTMLParser.__init__(self)</font>
<font color="red">  41.             self.cdata_tag = None</font>
<font color="black">  42. </font>
<font color="red">  43.         def set_cdata_mode(self, tag):</font>
<font color="red">  44.             try:</font>
<font color="red">  45.                 self.interesting = _html_parser.interesting_cdata</font>
<font color="red">  46.             except AttributeError:</font>
<font color="red">  47.                 self.interesting = re.compile(r'&lt;/\s*%s\s*&gt;' % tag.lower(), re.I)</font>
<font color="red">  48.             self.cdata_tag = tag.lower()</font>
<font color="black">  49. </font>
<font color="red">  50.         def clear_cdata_mode(self):</font>
<font color="red">  51.             self.interesting = _html_parser.interesting_normal</font>
<font color="red">  52.             self.cdata_tag = None</font>
<font color="black">  53. </font>
<font color="black">  54.         # Internal -- handle starttag, return end or -1 if not terminated</font>
<font color="red">  55.         def parse_starttag(self, i):</font>
<font color="red">  56.             self.__starttag_text = None</font>
<font color="red">  57.             endpos = self.check_for_whole_start_tag(i)</font>
<font color="red">  58.             if endpos &lt; 0:</font>
<font color="red">  59.                 return endpos</font>
<font color="red">  60.             rawdata = self.rawdata</font>
<font color="red">  61.             self.__starttag_text = rawdata[i:endpos]</font>
<font color="black">  62. </font>
<font color="black">  63.             # Now parse the data between i+1 and j into a tag and attrs</font>
<font color="red">  64.             attrs = []</font>
<font color="red">  65.             match = tagfind.match(rawdata, i + 1)</font>
<font color="red">  66.             assert match, 'unexpected call to parse_starttag()'</font>
<font color="red">  67.             k = match.end()</font>
<font color="red">  68.             self.lasttag = tag = match.group(1).lower()</font>
<font color="black">  69. </font>
<font color="red">  70.             while k &lt; endpos:</font>
<font color="red">  71.                 m = _html_parser.attrfind.match(rawdata, k)</font>
<font color="red">  72.                 if not m:</font>
<font color="red">  73.                     break</font>
<font color="red">  74.                 attrname, rest, attrvalue = m.group(1, 2, 3)</font>
<font color="red">  75.                 if not rest:</font>
<font color="red">  76.                     attrvalue = None</font>
<font color="red">  77.                 elif (attrvalue[:1] == '\'' == attrvalue[-1:] or</font>
<font color="red">  78.                         attrvalue[:1] == '&quot;' == attrvalue[-1:]):</font>
<font color="red">  79.                     attrvalue = attrvalue[1:-1]</font>
<font color="red">  80.                 if attrvalue:</font>
<font color="red">  81.                     attrvalue = self.unescape(attrvalue)</font>
<font color="red">  82.                 attrs.append((attrname.lower(), attrvalue))</font>
<font color="red">  83.                 k = m.end()</font>
<font color="black">  84. </font>
<font color="red">  85.             end = rawdata[k:endpos].strip()</font>
<font color="red">  86.             if end not in (&quot;&gt;&quot;, &quot;/&gt;&quot;):</font>
<font color="red">  87.                 lineno, offset = self.getpos()</font>
<font color="red">  88.                 if &quot;\n&quot; in self.__starttag_text:</font>
<font color="red">  89.                     lineno = lineno + self.__starttag_text.count(&quot;\n&quot;)</font>
<font color="red">  90.                     offset = (len(self.__starttag_text)</font>
<font color="red">  91.                              - self.__starttag_text.rfind(&quot;\n&quot;))</font>
<font color="black">  92.                 else:</font>
<font color="red">  93.                     offset = offset + len(self.__starttag_text)</font>
<font color="red">  94.                 self.error(&quot;junk characters in start tag: %r&quot;</font>
<font color="red">  95.                            % (rawdata[k:endpos][:20],))</font>
<font color="red">  96.             if end.endswith('/&gt;'):</font>
<font color="black">  97.                 # XHTML-style empty tag: &lt;span attr=&quot;value&quot; /&gt;</font>
<font color="red">  98.                 self.handle_startendtag(tag, attrs)</font>
<font color="black">  99.             else:</font>
<font color="red"> 100.                 self.handle_starttag(tag, attrs)</font>
<font color="red"> 101.                 if tag in self.CDATA_CONTENT_ELEMENTS:</font>
<font color="red"> 102.                     self.set_cdata_mode(tag)  # &lt;--------------------------- Changed</font>
<font color="red"> 103.             return endpos</font>
<font color="black"> 104. </font>
<font color="black"> 105.         # Internal -- parse endtag, return end or -1 if incomplete</font>
<font color="red"> 106.         def parse_endtag(self, i):</font>
<font color="red"> 107.             rawdata = self.rawdata</font>
<font color="red"> 108.             assert rawdata[i:i + 2] == &quot;&lt;/&quot;, &quot;unexpected call to parse_endtag&quot;</font>
<font color="red"> 109.             match = _html_parser.endendtag.search(rawdata, i + 1)  # &gt;</font>
<font color="red"> 110.             if not match:</font>
<font color="red"> 111.                 return -1</font>
<font color="red"> 112.             j = match.end()</font>
<font color="red"> 113.             match = _html_parser.endtagfind.match(rawdata, i)  # &lt;/ + tag + &gt;</font>
<font color="red"> 114.             if not match:</font>
<font color="red"> 115.                 if self.cdata_tag is not None:  # *** add ***</font>
<font color="red"> 116.                     self.handle_data(rawdata[i:j])  # *** add ***</font>
<font color="red"> 117.                     return j  # *** add ***</font>
<font color="red"> 118.                 self.error(&quot;bad end tag: %r&quot; % (rawdata[i:j],))</font>
<font color="black"> 119.             # --- changed start ---------------------------------------------------</font>
<font color="red"> 120.             tag = match.group(1).strip()</font>
<font color="red"> 121.             if self.cdata_tag is not None:</font>
<font color="red"> 122.                 if tag.lower() != self.cdata_tag:</font>
<font color="red"> 123.                     self.handle_data(rawdata[i:j])</font>
<font color="red"> 124.                     return j</font>
<font color="black"> 125.             # --- changed end -----------------------------------------------------</font>
<font color="red"> 126.             self.handle_endtag(tag.lower())</font>
<font color="red"> 127.             self.clear_cdata_mode()</font>
<font color="red"> 128.             return j</font>
</pre>

