source file: <b>/usr/lib/python2.7/urllib.py</b><br>


file stats: <b>1121 lines, 154 executed: 13.7% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Open an arbitrary URL.</font>
<font color="black">   2. </font>
<font color="black">   3. See the following document for more info on URLs:</font>
<font color="black">   4. &quot;Names and Addresses, URIs, URLs, URNs, URCs&quot;, at</font>
<font color="black">   5. http://www.w3.org/pub/WWW/Addressing/Overview.html</font>
<font color="black">   6. </font>
<font color="black">   7. See also the HTTP spec (from which the error codes are derived):</font>
<font color="black">   8. &quot;HTTP - Hypertext Transfer Protocol&quot;, at</font>
<font color="black">   9. http://www.w3.org/pub/WWW/Protocols/</font>
<font color="black">  10. </font>
<font color="black">  11. Related standards and specs:</font>
<font color="black">  12. - RFC1808: the &quot;relative URL&quot; spec. (authoritative status)</font>
<font color="black">  13. - RFC1738 - the &quot;URL standard&quot;. (authoritative status)</font>
<font color="black">  14. - RFC1630 - the &quot;URI spec&quot;. (informational status)</font>
<font color="black">  15. </font>
<font color="black">  16. The object returned by URLopener().open(file) will differ per</font>
<font color="black">  17. protocol.  All you know is that is has methods read(), readline(),</font>
<font color="black">  18. readlines(), fileno(), close() and info().  The read*(), fileno()</font>
<font color="black">  19. and close() methods work like those of open files.</font>
<font color="black">  20. The info() method returns a mimetools.Message object which can be</font>
<font color="black">  21. used to query various info about the object, if available.</font>
<font color="black">  22. (mimetools.Message objects are queried with the getheader() method.)</font>
<font color="green">  23. &quot;&quot;&quot;</font>
<font color="black">  24. </font>
<font color="green">  25. import string</font>
<font color="green">  26. import socket</font>
<font color="green">  27. import os</font>
<font color="green">  28. import time</font>
<font color="green">  29. import sys</font>
<font color="green">  30. import base64</font>
<font color="green">  31. import re</font>
<font color="black">  32. </font>
<font color="green">  33. from urlparse import urljoin as basejoin</font>
<font color="black">  34. </font>
<font color="green">  35. __all__ = [&quot;urlopen&quot;, &quot;URLopener&quot;, &quot;FancyURLopener&quot;, &quot;urlretrieve&quot;,</font>
<font color="green">  36.            &quot;urlcleanup&quot;, &quot;quote&quot;, &quot;quote_plus&quot;, &quot;unquote&quot;, &quot;unquote_plus&quot;,</font>
<font color="green">  37.            &quot;urlencode&quot;, &quot;url2pathname&quot;, &quot;pathname2url&quot;, &quot;splittag&quot;,</font>
<font color="green">  38.            &quot;localhost&quot;, &quot;thishost&quot;, &quot;ftperrors&quot;, &quot;basejoin&quot;, &quot;unwrap&quot;,</font>
<font color="green">  39.            &quot;splittype&quot;, &quot;splithost&quot;, &quot;splituser&quot;, &quot;splitpasswd&quot;, &quot;splitport&quot;,</font>
<font color="green">  40.            &quot;splitnport&quot;, &quot;splitquery&quot;, &quot;splitattr&quot;, &quot;splitvalue&quot;,</font>
<font color="green">  41.            &quot;getproxies&quot;]</font>
<font color="black">  42. </font>
<font color="green">  43. __version__ = '1.17'    # XXX This version is not always updated :-(</font>
<font color="black">  44. </font>
<font color="green">  45. MAXFTPCACHE = 10        # Trim the ftp cache beyond this size</font>
<font color="black">  46. </font>
<font color="black">  47. # Helper for non-unix systems</font>
<font color="green">  48. if os.name == 'nt':</font>
<font color="red">  49.     from nturl2path import url2pathname, pathname2url</font>
<font color="green">  50. elif os.name == 'riscos':</font>
<font color="red">  51.     from rourl2path import url2pathname, pathname2url</font>
<font color="black">  52. else:</font>
<font color="green">  53.     def url2pathname(pathname):</font>
<font color="black">  54.         &quot;&quot;&quot;OS-specific conversion from a relative URL of the 'file' scheme</font>
<font color="black">  55.         to a file system path; not recommended for general use.&quot;&quot;&quot;</font>
<font color="red">  56.         return unquote(pathname)</font>
<font color="black">  57. </font>
<font color="green">  58.     def pathname2url(pathname):</font>
<font color="black">  59.         &quot;&quot;&quot;OS-specific conversion from a file system path to a relative URL</font>
<font color="black">  60.         of the 'file' scheme; not recommended for general use.&quot;&quot;&quot;</font>
<font color="red">  61.         return quote(pathname)</font>
<font color="black">  62. </font>
<font color="black">  63. # This really consists of two pieces:</font>
<font color="black">  64. # (1) a class which handles opening of all sorts of URLs</font>
<font color="black">  65. #     (plus assorted utilities etc.)</font>
<font color="black">  66. # (2) a set of functions for parsing URLs</font>
<font color="black">  67. # XXX Should these be separated out into different modules?</font>
<font color="black">  68. </font>
<font color="black">  69. </font>
<font color="black">  70. # Shortcut for basic usage</font>
<font color="green">  71. _urlopener = None</font>
<font color="green">  72. def urlopen(url, data=None, proxies=None):</font>
<font color="black">  73.     &quot;&quot;&quot;Create a file-like object for the specified URL to read from.&quot;&quot;&quot;</font>
<font color="red">  74.     from warnings import warnpy3k</font>
<font color="red">  75.     warnpy3k(&quot;urllib.urlopen() has been removed in Python 3.0 in &quot;</font>
<font color="red">  76.              &quot;favor of urllib2.urlopen()&quot;, stacklevel=2)</font>
<font color="black">  77. </font>
<font color="black">  78.     global _urlopener</font>
<font color="red">  79.     if proxies is not None:</font>
<font color="red">  80.         opener = FancyURLopener(proxies=proxies)</font>
<font color="red">  81.     elif not _urlopener:</font>
<font color="red">  82.         opener = FancyURLopener()</font>
<font color="red">  83.         _urlopener = opener</font>
<font color="black">  84.     else:</font>
<font color="red">  85.         opener = _urlopener</font>
<font color="red">  86.     if data is None:</font>
<font color="red">  87.         return opener.open(url)</font>
<font color="black">  88.     else:</font>
<font color="red">  89.         return opener.open(url, data)</font>
<font color="green">  90. def urlretrieve(url, filename=None, reporthook=None, data=None):</font>
<font color="black">  91.     global _urlopener</font>
<font color="red">  92.     if not _urlopener:</font>
<font color="red">  93.         _urlopener = FancyURLopener()</font>
<font color="red">  94.     return _urlopener.retrieve(url, filename, reporthook, data)</font>
<font color="green">  95. def urlcleanup():</font>
<font color="red">  96.     if _urlopener:</font>
<font color="red">  97.         _urlopener.cleanup()</font>
<font color="red">  98.     _safe_quoters.clear()</font>
<font color="red">  99.     ftpcache.clear()</font>
<font color="black"> 100. </font>
<font color="black"> 101. # check for SSL</font>
<font color="green"> 102. try:</font>
<font color="green"> 103.     import ssl</font>
<font color="red"> 104. except:</font>
<font color="red"> 105.     _have_ssl = False</font>
<font color="black"> 106. else:</font>
<font color="green"> 107.     _have_ssl = True</font>
<font color="black"> 108. </font>
<font color="black"> 109. # exception raised when downloaded size does not match content-length</font>
<font color="green"> 110. class ContentTooShortError(IOError):</font>
<font color="green"> 111.     def __init__(self, message, content):</font>
<font color="red"> 112.         IOError.__init__(self, message)</font>
<font color="red"> 113.         self.content = content</font>
<font color="black"> 114. </font>
<font color="green"> 115. ftpcache = {}</font>
<font color="green"> 116. class URLopener:</font>
<font color="black"> 117.     &quot;&quot;&quot;Class to open URLs.</font>
<font color="black"> 118.     This is a class rather than just a subroutine because we may need</font>
<font color="black"> 119.     more than one set of global protocol-specific options.</font>
<font color="black"> 120.     Note -- this is a base class for those who don't want the</font>
<font color="black"> 121.     automatic handling of errors type 302 (relocated) and 401</font>
<font color="green"> 122.     (authorization needed).&quot;&quot;&quot;</font>
<font color="black"> 123. </font>
<font color="green"> 124.     __tempfiles = None</font>
<font color="black"> 125. </font>
<font color="green"> 126.     version = &quot;Python-urllib/%s&quot; % __version__</font>
<font color="black"> 127. </font>
<font color="black"> 128.     # Constructor</font>
<font color="green"> 129.     def __init__(self, proxies=None, **x509):</font>
<font color="red"> 130.         if proxies is None:</font>
<font color="red"> 131.             proxies = getproxies()</font>
<font color="red"> 132.         assert hasattr(proxies, 'has_key'), &quot;proxies must be a mapping&quot;</font>
<font color="red"> 133.         self.proxies = proxies</font>
<font color="red"> 134.         self.key_file = x509.get('key_file')</font>
<font color="red"> 135.         self.cert_file = x509.get('cert_file')</font>
<font color="red"> 136.         self.addheaders = [('User-Agent', self.version)]</font>
<font color="red"> 137.         self.__tempfiles = []</font>
<font color="red"> 138.         self.__unlink = os.unlink # See cleanup()</font>
<font color="red"> 139.         self.tempcache = None</font>
<font color="black"> 140.         # Undocumented feature: if you assign {} to tempcache,</font>
<font color="black"> 141.         # it is used to cache files retrieved with</font>
<font color="black"> 142.         # self.retrieve().  This is not enabled by default</font>
<font color="black"> 143.         # since it does not work for changing documents (and I</font>
<font color="black"> 144.         # haven't got the logic to check expiration headers</font>
<font color="black"> 145.         # yet).</font>
<font color="red"> 146.         self.ftpcache = ftpcache</font>
<font color="black"> 147.         # Undocumented feature: you can use a different</font>
<font color="black"> 148.         # ftp cache by assigning to the .ftpcache member;</font>
<font color="black"> 149.         # in case you want logically independent URL openers</font>
<font color="black"> 150.         # XXX This is not threadsafe.  Bah.</font>
<font color="black"> 151. </font>
<font color="green"> 152.     def __del__(self):</font>
<font color="red"> 153.         self.close()</font>
<font color="black"> 154. </font>
<font color="green"> 155.     def close(self):</font>
<font color="red"> 156.         self.cleanup()</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def cleanup(self):</font>
<font color="black"> 159.         # This code sometimes runs when the rest of this module</font>
<font color="black"> 160.         # has already been deleted, so it can't use any globals</font>
<font color="black"> 161.         # or import anything.</font>
<font color="red"> 162.         if self.__tempfiles:</font>
<font color="red"> 163.             for file in self.__tempfiles:</font>
<font color="red"> 164.                 try:</font>
<font color="red"> 165.                     self.__unlink(file)</font>
<font color="red"> 166.                 except OSError:</font>
<font color="red"> 167.                     pass</font>
<font color="red"> 168.             del self.__tempfiles[:]</font>
<font color="red"> 169.         if self.tempcache:</font>
<font color="red"> 170.             self.tempcache.clear()</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def addheader(self, *args):</font>
<font color="black"> 173.         &quot;&quot;&quot;Add a header to be used by the HTTP interface only</font>
<font color="black"> 174.         e.g. u.addheader('Accept', 'sound/basic')&quot;&quot;&quot;</font>
<font color="red"> 175.         self.addheaders.append(args)</font>
<font color="black"> 176. </font>
<font color="black"> 177.     # External interface</font>
<font color="green"> 178.     def open(self, fullurl, data=None):</font>
<font color="black"> 179.         &quot;&quot;&quot;Use URLopener().open(file) instead of open(file, 'r').&quot;&quot;&quot;</font>
<font color="red"> 180.         fullurl = unwrap(toBytes(fullurl))</font>
<font color="black"> 181.         # percent encode url, fixing lame server errors for e.g, like space</font>
<font color="black"> 182.         # within url paths.</font>
<font color="red"> 183.         fullurl = quote(fullurl, safe=&quot;%/:=&amp;?~#+!$,;'@()*[]|&quot;)</font>
<font color="red"> 184.         if self.tempcache and fullurl in self.tempcache:</font>
<font color="red"> 185.             filename, headers = self.tempcache[fullurl]</font>
<font color="red"> 186.             fp = open(filename, 'rb')</font>
<font color="red"> 187.             return addinfourl(fp, headers, fullurl)</font>
<font color="red"> 188.         urltype, url = splittype(fullurl)</font>
<font color="red"> 189.         if not urltype:</font>
<font color="red"> 190.             urltype = 'file'</font>
<font color="red"> 191.         if urltype in self.proxies:</font>
<font color="red"> 192.             proxy = self.proxies[urltype]</font>
<font color="red"> 193.             urltype, proxyhost = splittype(proxy)</font>
<font color="red"> 194.             host, selector = splithost(proxyhost)</font>
<font color="red"> 195.             url = (host, fullurl) # Signal special case to open_*()</font>
<font color="black"> 196.         else:</font>
<font color="red"> 197.             proxy = None</font>
<font color="red"> 198.         name = 'open_' + urltype</font>
<font color="red"> 199.         self.type = urltype</font>
<font color="red"> 200.         name = name.replace('-', '_')</font>
<font color="red"> 201.         if not hasattr(self, name):</font>
<font color="red"> 202.             if proxy:</font>
<font color="red"> 203.                 return self.open_unknown_proxy(proxy, fullurl, data)</font>
<font color="black"> 204.             else:</font>
<font color="red"> 205.                 return self.open_unknown(fullurl, data)</font>
<font color="red"> 206.         try:</font>
<font color="red"> 207.             if data is None:</font>
<font color="red"> 208.                 return getattr(self, name)(url)</font>
<font color="black"> 209.             else:</font>
<font color="red"> 210.                 return getattr(self, name)(url, data)</font>
<font color="red"> 211.         except socket.error, msg:</font>
<font color="red"> 212.             raise IOError, ('socket error', msg), sys.exc_info()[2]</font>
<font color="black"> 213. </font>
<font color="green"> 214.     def open_unknown(self, fullurl, data=None):</font>
<font color="black"> 215.         &quot;&quot;&quot;Overridable interface to open unknown URL type.&quot;&quot;&quot;</font>
<font color="red"> 216.         type, url = splittype(fullurl)</font>
<font color="red"> 217.         raise IOError, ('url error', 'unknown url type', type)</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def open_unknown_proxy(self, proxy, fullurl, data=None):</font>
<font color="black"> 220.         &quot;&quot;&quot;Overridable interface to open unknown URL type.&quot;&quot;&quot;</font>
<font color="red"> 221.         type, url = splittype(fullurl)</font>
<font color="red"> 222.         raise IOError, ('url error', 'invalid proxy for %s' % type, proxy)</font>
<font color="black"> 223. </font>
<font color="black"> 224.     # External interface</font>
<font color="green"> 225.     def retrieve(self, url, filename=None, reporthook=None, data=None):</font>
<font color="black"> 226.         &quot;&quot;&quot;retrieve(url) returns (filename, headers) for a local object</font>
<font color="black"> 227.         or (tempfilename, headers) for a remote object.&quot;&quot;&quot;</font>
<font color="red"> 228.         url = unwrap(toBytes(url))</font>
<font color="red"> 229.         if self.tempcache and url in self.tempcache:</font>
<font color="red"> 230.             return self.tempcache[url]</font>
<font color="red"> 231.         type, url1 = splittype(url)</font>
<font color="red"> 232.         if filename is None and (not type or type == 'file'):</font>
<font color="red"> 233.             try:</font>
<font color="red"> 234.                 fp = self.open_local_file(url1)</font>
<font color="red"> 235.                 hdrs = fp.info()</font>
<font color="red"> 236.                 fp.close()</font>
<font color="red"> 237.                 return url2pathname(splithost(url1)[1]), hdrs</font>
<font color="red"> 238.             except IOError:</font>
<font color="red"> 239.                 pass</font>
<font color="red"> 240.         fp = self.open(url, data)</font>
<font color="red"> 241.         try:</font>
<font color="red"> 242.             headers = fp.info()</font>
<font color="red"> 243.             if filename:</font>
<font color="red"> 244.                 tfp = open(filename, 'wb')</font>
<font color="black"> 245.             else:</font>
<font color="red"> 246.                 import tempfile</font>
<font color="red"> 247.                 garbage, path = splittype(url)</font>
<font color="red"> 248.                 garbage, path = splithost(path or &quot;&quot;)</font>
<font color="red"> 249.                 path, garbage = splitquery(path or &quot;&quot;)</font>
<font color="red"> 250.                 path, garbage = splitattr(path or &quot;&quot;)</font>
<font color="red"> 251.                 suffix = os.path.splitext(path)[1]</font>
<font color="red"> 252.                 (fd, filename) = tempfile.mkstemp(suffix)</font>
<font color="red"> 253.                 self.__tempfiles.append(filename)</font>
<font color="red"> 254.                 tfp = os.fdopen(fd, 'wb')</font>
<font color="red"> 255.             try:</font>
<font color="red"> 256.                 result = filename, headers</font>
<font color="red"> 257.                 if self.tempcache is not None:</font>
<font color="red"> 258.                     self.tempcache[url] = result</font>
<font color="red"> 259.                 bs = 1024*8</font>
<font color="red"> 260.                 size = -1</font>
<font color="red"> 261.                 read = 0</font>
<font color="red"> 262.                 blocknum = 0</font>
<font color="red"> 263.                 if &quot;content-length&quot; in headers:</font>
<font color="red"> 264.                     size = int(headers[&quot;Content-Length&quot;])</font>
<font color="red"> 265.                 if reporthook:</font>
<font color="red"> 266.                     reporthook(blocknum, bs, size)</font>
<font color="red"> 267.                 while 1:</font>
<font color="red"> 268.                     block = fp.read(bs)</font>
<font color="red"> 269.                     if block == &quot;&quot;:</font>
<font color="red"> 270.                         break</font>
<font color="red"> 271.                     read += len(block)</font>
<font color="red"> 272.                     tfp.write(block)</font>
<font color="red"> 273.                     blocknum += 1</font>
<font color="red"> 274.                     if reporthook:</font>
<font color="red"> 275.                         reporthook(blocknum, bs, size)</font>
<font color="black"> 276.             finally:</font>
<font color="red"> 277.                 tfp.close()</font>
<font color="black"> 278.         finally:</font>
<font color="red"> 279.             fp.close()</font>
<font color="black"> 280. </font>
<font color="black"> 281.         # raise exception if actual size does not match content-length header</font>
<font color="red"> 282.         if size &gt;= 0 and read &lt; size:</font>
<font color="red"> 283.             raise ContentTooShortError(&quot;retrieval incomplete: got only %i out &quot;</font>
<font color="red"> 284.                                        &quot;of %i bytes&quot; % (read, size), result)</font>
<font color="black"> 285. </font>
<font color="red"> 286.         return result</font>
<font color="black"> 287. </font>
<font color="black"> 288.     # Each method named open_&lt;type&gt; knows how to open that type of URL</font>
<font color="black"> 289. </font>
<font color="green"> 290.     def open_http(self, url, data=None):</font>
<font color="black"> 291.         &quot;&quot;&quot;Use HTTP protocol.&quot;&quot;&quot;</font>
<font color="red"> 292.         import httplib</font>
<font color="red"> 293.         user_passwd = None</font>
<font color="red"> 294.         proxy_passwd= None</font>
<font color="red"> 295.         if isinstance(url, str):</font>
<font color="red"> 296.             host, selector = splithost(url)</font>
<font color="red"> 297.             if host:</font>
<font color="red"> 298.                 user_passwd, host = splituser(host)</font>
<font color="red"> 299.                 host = unquote(host)</font>
<font color="red"> 300.             realhost = host</font>
<font color="black"> 301.         else:</font>
<font color="red"> 302.             host, selector = url</font>
<font color="black"> 303.             # check whether the proxy contains authorization information</font>
<font color="red"> 304.             proxy_passwd, host = splituser(host)</font>
<font color="black"> 305.             # now we proceed with the url we want to obtain</font>
<font color="red"> 306.             urltype, rest = splittype(selector)</font>
<font color="red"> 307.             url = rest</font>
<font color="red"> 308.             user_passwd = None</font>
<font color="red"> 309.             if urltype.lower() != 'http':</font>
<font color="red"> 310.                 realhost = None</font>
<font color="black"> 311.             else:</font>
<font color="red"> 312.                 realhost, rest = splithost(rest)</font>
<font color="red"> 313.                 if realhost:</font>
<font color="red"> 314.                     user_passwd, realhost = splituser(realhost)</font>
<font color="red"> 315.                 if user_passwd:</font>
<font color="red"> 316.                     selector = &quot;%s://%s%s&quot; % (urltype, realhost, rest)</font>
<font color="red"> 317.                 if proxy_bypass(realhost):</font>
<font color="red"> 318.                     host = realhost</font>
<font color="black"> 319. </font>
<font color="black"> 320.             #print &quot;proxy via http:&quot;, host, selector</font>
<font color="red"> 321.         if not host: raise IOError, ('http error', 'no host given')</font>
<font color="black"> 322. </font>
<font color="red"> 323.         if proxy_passwd:</font>
<font color="red"> 324.             proxy_passwd = unquote(proxy_passwd)</font>
<font color="red"> 325.             proxy_auth = base64.b64encode(proxy_passwd).strip()</font>
<font color="black"> 326.         else:</font>
<font color="red"> 327.             proxy_auth = None</font>
<font color="black"> 328. </font>
<font color="red"> 329.         if user_passwd:</font>
<font color="red"> 330.             user_passwd = unquote(user_passwd)</font>
<font color="red"> 331.             auth = base64.b64encode(user_passwd).strip()</font>
<font color="black"> 332.         else:</font>
<font color="red"> 333.             auth = None</font>
<font color="red"> 334.         h = httplib.HTTP(host)</font>
<font color="red"> 335.         if data is not None:</font>
<font color="red"> 336.             h.putrequest('POST', selector)</font>
<font color="red"> 337.             h.putheader('Content-Type', 'application/x-www-form-urlencoded')</font>
<font color="red"> 338.             h.putheader('Content-Length', '%d' % len(data))</font>
<font color="black"> 339.         else:</font>
<font color="red"> 340.             h.putrequest('GET', selector)</font>
<font color="red"> 341.         if proxy_auth: h.putheader('Proxy-Authorization', 'Basic %s' % proxy_auth)</font>
<font color="red"> 342.         if auth: h.putheader('Authorization', 'Basic %s' % auth)</font>
<font color="red"> 343.         if realhost: h.putheader('Host', realhost)</font>
<font color="red"> 344.         for args in self.addheaders: h.putheader(*args)</font>
<font color="red"> 345.         h.endheaders(data)</font>
<font color="red"> 346.         errcode, errmsg, headers = h.getreply()</font>
<font color="red"> 347.         fp = h.getfile()</font>
<font color="red"> 348.         if errcode == -1:</font>
<font color="red"> 349.             if fp: fp.close()</font>
<font color="black"> 350.             # something went wrong with the HTTP status line</font>
<font color="red"> 351.             raise IOError, ('http protocol error', 0,</font>
<font color="red"> 352.                             'got a bad status line', None)</font>
<font color="black"> 353.         # According to RFC 2616, &quot;2xx&quot; code indicates that the client's</font>
<font color="black"> 354.         # request was successfully received, understood, and accepted.</font>
<font color="red"> 355.         if (200 &lt;= errcode &lt; 300):</font>
<font color="red"> 356.             return addinfourl(fp, headers, &quot;http:&quot; + url, errcode)</font>
<font color="black"> 357.         else:</font>
<font color="red"> 358.             if data is None:</font>
<font color="red"> 359.                 return self.http_error(url, fp, errcode, errmsg, headers)</font>
<font color="black"> 360.             else:</font>
<font color="red"> 361.                 return self.http_error(url, fp, errcode, errmsg, headers, data)</font>
<font color="black"> 362. </font>
<font color="green"> 363.     def http_error(self, url, fp, errcode, errmsg, headers, data=None):</font>
<font color="black"> 364.         &quot;&quot;&quot;Handle http errors.</font>
<font color="black"> 365.         Derived class can override this, or provide specific handlers</font>
<font color="black"> 366.         named http_error_DDD where DDD is the 3-digit error code.&quot;&quot;&quot;</font>
<font color="black"> 367.         # First check if there's a specific handler for this error</font>
<font color="red"> 368.         name = 'http_error_%d' % errcode</font>
<font color="red"> 369.         if hasattr(self, name):</font>
<font color="red"> 370.             method = getattr(self, name)</font>
<font color="red"> 371.             if data is None:</font>
<font color="red"> 372.                 result = method(url, fp, errcode, errmsg, headers)</font>
<font color="black"> 373.             else:</font>
<font color="red"> 374.                 result = method(url, fp, errcode, errmsg, headers, data)</font>
<font color="red"> 375.             if result: return result</font>
<font color="red"> 376.         return self.http_error_default(url, fp, errcode, errmsg, headers)</font>
<font color="black"> 377. </font>
<font color="green"> 378.     def http_error_default(self, url, fp, errcode, errmsg, headers):</font>
<font color="black"> 379.         &quot;&quot;&quot;Default error handler: close the connection and raise IOError.&quot;&quot;&quot;</font>
<font color="red"> 380.         fp.close()</font>
<font color="red"> 381.         raise IOError, ('http error', errcode, errmsg, headers)</font>
<font color="black"> 382. </font>
<font color="green"> 383.     if _have_ssl:</font>
<font color="green"> 384.         def open_https(self, url, data=None):</font>
<font color="black"> 385.             &quot;&quot;&quot;Use HTTPS protocol.&quot;&quot;&quot;</font>
<font color="black"> 386. </font>
<font color="red"> 387.             import httplib</font>
<font color="red"> 388.             user_passwd = None</font>
<font color="red"> 389.             proxy_passwd = None</font>
<font color="red"> 390.             if isinstance(url, str):</font>
<font color="red"> 391.                 host, selector = splithost(url)</font>
<font color="red"> 392.                 if host:</font>
<font color="red"> 393.                     user_passwd, host = splituser(host)</font>
<font color="red"> 394.                     host = unquote(host)</font>
<font color="red"> 395.                 realhost = host</font>
<font color="black"> 396.             else:</font>
<font color="red"> 397.                 host, selector = url</font>
<font color="black"> 398.                 # here, we determine, whether the proxy contains authorization information</font>
<font color="red"> 399.                 proxy_passwd, host = splituser(host)</font>
<font color="red"> 400.                 urltype, rest = splittype(selector)</font>
<font color="red"> 401.                 url = rest</font>
<font color="red"> 402.                 user_passwd = None</font>
<font color="red"> 403.                 if urltype.lower() != 'https':</font>
<font color="red"> 404.                     realhost = None</font>
<font color="black"> 405.                 else:</font>
<font color="red"> 406.                     realhost, rest = splithost(rest)</font>
<font color="red"> 407.                     if realhost:</font>
<font color="red"> 408.                         user_passwd, realhost = splituser(realhost)</font>
<font color="red"> 409.                     if user_passwd:</font>
<font color="red"> 410.                         selector = &quot;%s://%s%s&quot; % (urltype, realhost, rest)</font>
<font color="black"> 411.                 #print &quot;proxy via https:&quot;, host, selector</font>
<font color="red"> 412.             if not host: raise IOError, ('https error', 'no host given')</font>
<font color="red"> 413.             if proxy_passwd:</font>
<font color="red"> 414.                 proxy_passwd = unquote(proxy_passwd)</font>
<font color="red"> 415.                 proxy_auth = base64.b64encode(proxy_passwd).strip()</font>
<font color="black"> 416.             else:</font>
<font color="red"> 417.                 proxy_auth = None</font>
<font color="red"> 418.             if user_passwd:</font>
<font color="red"> 419.                 user_passwd = unquote(user_passwd)</font>
<font color="red"> 420.                 auth = base64.b64encode(user_passwd).strip()</font>
<font color="black"> 421.             else:</font>
<font color="red"> 422.                 auth = None</font>
<font color="red"> 423.             h = httplib.HTTPS(host, 0,</font>
<font color="red"> 424.                               key_file=self.key_file,</font>
<font color="red"> 425.                               cert_file=self.cert_file)</font>
<font color="red"> 426.             if data is not None:</font>
<font color="red"> 427.                 h.putrequest('POST', selector)</font>
<font color="red"> 428.                 h.putheader('Content-Type',</font>
<font color="red"> 429.                             'application/x-www-form-urlencoded')</font>
<font color="red"> 430.                 h.putheader('Content-Length', '%d' % len(data))</font>
<font color="black"> 431.             else:</font>
<font color="red"> 432.                 h.putrequest('GET', selector)</font>
<font color="red"> 433.             if proxy_auth: h.putheader('Proxy-Authorization', 'Basic %s' % proxy_auth)</font>
<font color="red"> 434.             if auth: h.putheader('Authorization', 'Basic %s' % auth)</font>
<font color="red"> 435.             if realhost: h.putheader('Host', realhost)</font>
<font color="red"> 436.             for args in self.addheaders: h.putheader(*args)</font>
<font color="red"> 437.             h.endheaders(data)</font>
<font color="red"> 438.             errcode, errmsg, headers = h.getreply()</font>
<font color="red"> 439.             fp = h.getfile()</font>
<font color="red"> 440.             if errcode == -1:</font>
<font color="red"> 441.                 if fp: fp.close()</font>
<font color="black"> 442.                 # something went wrong with the HTTP status line</font>
<font color="red"> 443.                 raise IOError, ('http protocol error', 0,</font>
<font color="red"> 444.                                 'got a bad status line', None)</font>
<font color="black"> 445.             # According to RFC 2616, &quot;2xx&quot; code indicates that the client's</font>
<font color="black"> 446.             # request was successfully received, understood, and accepted.</font>
<font color="red"> 447.             if (200 &lt;= errcode &lt; 300):</font>
<font color="red"> 448.                 return addinfourl(fp, headers, &quot;https:&quot; + url, errcode)</font>
<font color="black"> 449.             else:</font>
<font color="red"> 450.                 if data is None:</font>
<font color="red"> 451.                     return self.http_error(url, fp, errcode, errmsg, headers)</font>
<font color="black"> 452.                 else:</font>
<font color="red"> 453.                     return self.http_error(url, fp, errcode, errmsg, headers,</font>
<font color="red"> 454.                                            data)</font>
<font color="black"> 455. </font>
<font color="green"> 456.     def open_file(self, url):</font>
<font color="black"> 457.         &quot;&quot;&quot;Use local file or FTP depending on form of URL.&quot;&quot;&quot;</font>
<font color="red"> 458.         if not isinstance(url, str):</font>
<font color="red"> 459.             raise IOError, ('file error', 'proxy support for file protocol currently not implemented')</font>
<font color="red"> 460.         if url[:2] == '//' and url[2:3] != '/' and url[2:12].lower() != 'localhost/':</font>
<font color="red"> 461.             return self.open_ftp(url)</font>
<font color="black"> 462.         else:</font>
<font color="red"> 463.             return self.open_local_file(url)</font>
<font color="black"> 464. </font>
<font color="green"> 465.     def open_local_file(self, url):</font>
<font color="black"> 466.         &quot;&quot;&quot;Use local file.&quot;&quot;&quot;</font>
<font color="red"> 467.         import mimetypes, mimetools, email.utils</font>
<font color="red"> 468.         try:</font>
<font color="red"> 469.             from cStringIO import StringIO</font>
<font color="red"> 470.         except ImportError:</font>
<font color="red"> 471.             from StringIO import StringIO</font>
<font color="red"> 472.         host, file = splithost(url)</font>
<font color="red"> 473.         localname = url2pathname(file)</font>
<font color="red"> 474.         try:</font>
<font color="red"> 475.             stats = os.stat(localname)</font>
<font color="red"> 476.         except OSError, e:</font>
<font color="red"> 477.             raise IOError(e.errno, e.strerror, e.filename)</font>
<font color="red"> 478.         size = stats.st_size</font>
<font color="red"> 479.         modified = email.utils.formatdate(stats.st_mtime, usegmt=True)</font>
<font color="red"> 480.         mtype = mimetypes.guess_type(url)[0]</font>
<font color="red"> 481.         headers = mimetools.Message(StringIO(</font>
<font color="red"> 482.             'Content-Type: %s\nContent-Length: %d\nLast-modified: %s\n' %</font>
<font color="red"> 483.             (mtype or 'text/plain', size, modified)))</font>
<font color="red"> 484.         if not host:</font>
<font color="red"> 485.             urlfile = file</font>
<font color="red"> 486.             if file[:1] == '/':</font>
<font color="red"> 487.                 urlfile = 'file://' + file</font>
<font color="red"> 488.             elif file[:2] == './':</font>
<font color="red"> 489.                 raise ValueError(&quot;local file url may start with / or file:. Unknown url of type: %s&quot; % url)</font>
<font color="red"> 490.             return addinfourl(open(localname, 'rb'),</font>
<font color="red"> 491.                               headers, urlfile)</font>
<font color="red"> 492.         host, port = splitport(host)</font>
<font color="red"> 493.         if not port \</font>
<font color="red"> 494.            and socket.gethostbyname(host) in (localhost(), thishost()):</font>
<font color="red"> 495.             urlfile = file</font>
<font color="red"> 496.             if file[:1] == '/':</font>
<font color="red"> 497.                 urlfile = 'file://' + file</font>
<font color="red"> 498.             return addinfourl(open(localname, 'rb'),</font>
<font color="red"> 499.                               headers, urlfile)</font>
<font color="red"> 500.         raise IOError, ('local file error', 'not on local host')</font>
<font color="black"> 501. </font>
<font color="green"> 502.     def open_ftp(self, url):</font>
<font color="black"> 503.         &quot;&quot;&quot;Use FTP protocol.&quot;&quot;&quot;</font>
<font color="red"> 504.         if not isinstance(url, str):</font>
<font color="red"> 505.             raise IOError, ('ftp error', 'proxy support for ftp protocol currently not implemented')</font>
<font color="red"> 506.         import mimetypes, mimetools</font>
<font color="red"> 507.         try:</font>
<font color="red"> 508.             from cStringIO import StringIO</font>
<font color="red"> 509.         except ImportError:</font>
<font color="red"> 510.             from StringIO import StringIO</font>
<font color="red"> 511.         host, path = splithost(url)</font>
<font color="red"> 512.         if not host: raise IOError, ('ftp error', 'no host given')</font>
<font color="red"> 513.         host, port = splitport(host)</font>
<font color="red"> 514.         user, host = splituser(host)</font>
<font color="red"> 515.         if user: user, passwd = splitpasswd(user)</font>
<font color="red"> 516.         else: passwd = None</font>
<font color="red"> 517.         host = unquote(host)</font>
<font color="red"> 518.         user = user or ''</font>
<font color="red"> 519.         passwd = passwd or ''</font>
<font color="red"> 520.         host = socket.gethostbyname(host)</font>
<font color="red"> 521.         if not port:</font>
<font color="red"> 522.             import ftplib</font>
<font color="red"> 523.             port = ftplib.FTP_PORT</font>
<font color="black"> 524.         else:</font>
<font color="red"> 525.             port = int(port)</font>
<font color="red"> 526.         path, attrs = splitattr(path)</font>
<font color="red"> 527.         path = unquote(path)</font>
<font color="red"> 528.         dirs = path.split('/')</font>
<font color="red"> 529.         dirs, file = dirs[:-1], dirs[-1]</font>
<font color="red"> 530.         if dirs and not dirs[0]: dirs = dirs[1:]</font>
<font color="red"> 531.         if dirs and not dirs[0]: dirs[0] = '/'</font>
<font color="red"> 532.         key = user, host, port, '/'.join(dirs)</font>
<font color="black"> 533.         # XXX thread unsafe!</font>
<font color="red"> 534.         if len(self.ftpcache) &gt; MAXFTPCACHE:</font>
<font color="black"> 535.             # Prune the cache, rather arbitrarily</font>
<font color="red"> 536.             for k in self.ftpcache.keys():</font>
<font color="red"> 537.                 if k != key:</font>
<font color="red"> 538.                     v = self.ftpcache[k]</font>
<font color="red"> 539.                     del self.ftpcache[k]</font>
<font color="red"> 540.                     v.close()</font>
<font color="red"> 541.         try:</font>
<font color="red"> 542.             if not key in self.ftpcache:</font>
<font color="black"> 543.                 self.ftpcache[key] = \</font>
<font color="red"> 544.                     ftpwrapper(user, passwd, host, port, dirs)</font>
<font color="red"> 545.             if not file: type = 'D'</font>
<font color="red"> 546.             else: type = 'I'</font>
<font color="red"> 547.             for attr in attrs:</font>
<font color="red"> 548.                 attr, value = splitvalue(attr)</font>
<font color="red"> 549.                 if attr.lower() == 'type' and \</font>
<font color="red"> 550.                    value in ('a', 'A', 'i', 'I', 'd', 'D'):</font>
<font color="red"> 551.                     type = value.upper()</font>
<font color="red"> 552.             (fp, retrlen) = self.ftpcache[key].retrfile(file, type)</font>
<font color="red"> 553.             mtype = mimetypes.guess_type(&quot;ftp:&quot; + url)[0]</font>
<font color="red"> 554.             headers = &quot;&quot;</font>
<font color="red"> 555.             if mtype:</font>
<font color="red"> 556.                 headers += &quot;Content-Type: %s\n&quot; % mtype</font>
<font color="red"> 557.             if retrlen is not None and retrlen &gt;= 0:</font>
<font color="red"> 558.                 headers += &quot;Content-Length: %d\n&quot; % retrlen</font>
<font color="red"> 559.             headers = mimetools.Message(StringIO(headers))</font>
<font color="red"> 560.             return addinfourl(fp, headers, &quot;ftp:&quot; + url)</font>
<font color="red"> 561.         except ftperrors(), msg:</font>
<font color="red"> 562.             raise IOError, ('ftp error', msg), sys.exc_info()[2]</font>
<font color="black"> 563. </font>
<font color="green"> 564.     def open_data(self, url, data=None):</font>
<font color="black"> 565.         &quot;&quot;&quot;Use &quot;data&quot; URL.&quot;&quot;&quot;</font>
<font color="red"> 566.         if not isinstance(url, str):</font>
<font color="red"> 567.             raise IOError, ('data error', 'proxy support for data protocol currently not implemented')</font>
<font color="black"> 568.         # ignore POSTed data</font>
<font color="black"> 569.         #</font>
<font color="black"> 570.         # syntax of data URLs:</font>
<font color="black"> 571.         # dataurl   := &quot;data:&quot; [ mediatype ] [ &quot;;base64&quot; ] &quot;,&quot; data</font>
<font color="black"> 572.         # mediatype := [ type &quot;/&quot; subtype ] *( &quot;;&quot; parameter )</font>
<font color="black"> 573.         # data      := *urlchar</font>
<font color="black"> 574.         # parameter := attribute &quot;=&quot; value</font>
<font color="red"> 575.         import mimetools</font>
<font color="red"> 576.         try:</font>
<font color="red"> 577.             from cStringIO import StringIO</font>
<font color="red"> 578.         except ImportError:</font>
<font color="red"> 579.             from StringIO import StringIO</font>
<font color="red"> 580.         try:</font>
<font color="red"> 581.             [type, data] = url.split(',', 1)</font>
<font color="red"> 582.         except ValueError:</font>
<font color="red"> 583.             raise IOError, ('data error', 'bad data URL')</font>
<font color="red"> 584.         if not type:</font>
<font color="red"> 585.             type = 'text/plain;charset=US-ASCII'</font>
<font color="red"> 586.         semi = type.rfind(';')</font>
<font color="red"> 587.         if semi &gt;= 0 and '=' not in type[semi:]:</font>
<font color="red"> 588.             encoding = type[semi+1:]</font>
<font color="red"> 589.             type = type[:semi]</font>
<font color="black"> 590.         else:</font>
<font color="red"> 591.             encoding = ''</font>
<font color="red"> 592.         msg = []</font>
<font color="red"> 593.         msg.append('Date: %s'%time.strftime('%a, %d %b %Y %H:%M:%S GMT',</font>
<font color="red"> 594.                                             time.gmtime(time.time())))</font>
<font color="red"> 595.         msg.append('Content-type: %s' % type)</font>
<font color="red"> 596.         if encoding == 'base64':</font>
<font color="red"> 597.             data = base64.decodestring(data)</font>
<font color="black"> 598.         else:</font>
<font color="red"> 599.             data = unquote(data)</font>
<font color="red"> 600.         msg.append('Content-Length: %d' % len(data))</font>
<font color="red"> 601.         msg.append('')</font>
<font color="red"> 602.         msg.append(data)</font>
<font color="red"> 603.         msg = '\n'.join(msg)</font>
<font color="red"> 604.         f = StringIO(msg)</font>
<font color="red"> 605.         headers = mimetools.Message(f, 0)</font>
<font color="black"> 606.         #f.fileno = None     # needed for addinfourl</font>
<font color="red"> 607.         return addinfourl(f, headers, url)</font>
<font color="black"> 608. </font>
<font color="black"> 609. </font>
<font color="green"> 610. class FancyURLopener(URLopener):</font>
<font color="green"> 611.     &quot;&quot;&quot;Derived class with handlers for errors we can handle (perhaps).&quot;&quot;&quot;</font>
<font color="black"> 612. </font>
<font color="green"> 613.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 614.         URLopener.__init__(self, *args, **kwargs)</font>
<font color="red"> 615.         self.auth_cache = {}</font>
<font color="red"> 616.         self.tries = 0</font>
<font color="red"> 617.         self.maxtries = 10</font>
<font color="black"> 618. </font>
<font color="green"> 619.     def http_error_default(self, url, fp, errcode, errmsg, headers):</font>
<font color="black"> 620.         &quot;&quot;&quot;Default error handling -- don't raise an exception.&quot;&quot;&quot;</font>
<font color="red"> 621.         return addinfourl(fp, headers, &quot;http:&quot; + url, errcode)</font>
<font color="black"> 622. </font>
<font color="green"> 623.     def http_error_302(self, url, fp, errcode, errmsg, headers, data=None):</font>
<font color="black"> 624.         &quot;&quot;&quot;Error 302 -- relocated (temporarily).&quot;&quot;&quot;</font>
<font color="red"> 625.         self.tries += 1</font>
<font color="red"> 626.         if self.maxtries and self.tries &gt;= self.maxtries:</font>
<font color="red"> 627.             if hasattr(self, &quot;http_error_500&quot;):</font>
<font color="red"> 628.                 meth = self.http_error_500</font>
<font color="black"> 629.             else:</font>
<font color="red"> 630.                 meth = self.http_error_default</font>
<font color="red"> 631.             self.tries = 0</font>
<font color="red"> 632.             return meth(url, fp, 500,</font>
<font color="red"> 633.                         &quot;Internal Server Error: Redirect Recursion&quot;, headers)</font>
<font color="red"> 634.         result = self.redirect_internal(url, fp, errcode, errmsg, headers,</font>
<font color="red"> 635.                                         data)</font>
<font color="red"> 636.         self.tries = 0</font>
<font color="red"> 637.         return result</font>
<font color="black"> 638. </font>
<font color="green"> 639.     def redirect_internal(self, url, fp, errcode, errmsg, headers, data):</font>
<font color="red"> 640.         if 'location' in headers:</font>
<font color="red"> 641.             newurl = headers['location']</font>
<font color="red"> 642.         elif 'uri' in headers:</font>
<font color="red"> 643.             newurl = headers['uri']</font>
<font color="black"> 644.         else:</font>
<font color="red"> 645.             return</font>
<font color="red"> 646.         fp.close()</font>
<font color="black"> 647.         # In case the server sent a relative URL, join with original:</font>
<font color="red"> 648.         newurl = basejoin(self.type + &quot;:&quot; + url, newurl)</font>
<font color="black"> 649. </font>
<font color="black"> 650.         # For security reasons we do not allow redirects to protocols</font>
<font color="black"> 651.         # other than HTTP, HTTPS or FTP.</font>
<font color="red"> 652.         newurl_lower = newurl.lower()</font>
<font color="red"> 653.         if not (newurl_lower.startswith('http://') or</font>
<font color="red"> 654.                 newurl_lower.startswith('https://') or</font>
<font color="red"> 655.                 newurl_lower.startswith('ftp://')):</font>
<font color="red"> 656.             raise IOError('redirect error', errcode,</font>
<font color="red"> 657.                           errmsg + &quot; - Redirection to url '%s' is not allowed&quot; %</font>
<font color="red"> 658.                           newurl,</font>
<font color="red"> 659.                           headers)</font>
<font color="black"> 660. </font>
<font color="red"> 661.         return self.open(newurl)</font>
<font color="black"> 662. </font>
<font color="green"> 663.     def http_error_301(self, url, fp, errcode, errmsg, headers, data=None):</font>
<font color="black"> 664.         &quot;&quot;&quot;Error 301 -- also relocated (permanently).&quot;&quot;&quot;</font>
<font color="red"> 665.         return self.http_error_302(url, fp, errcode, errmsg, headers, data)</font>
<font color="black"> 666. </font>
<font color="green"> 667.     def http_error_303(self, url, fp, errcode, errmsg, headers, data=None):</font>
<font color="black"> 668.         &quot;&quot;&quot;Error 303 -- also relocated (essentially identical to 302).&quot;&quot;&quot;</font>
<font color="red"> 669.         return self.http_error_302(url, fp, errcode, errmsg, headers, data)</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def http_error_307(self, url, fp, errcode, errmsg, headers, data=None):</font>
<font color="black"> 672.         &quot;&quot;&quot;Error 307 -- relocated, but turn POST into error.&quot;&quot;&quot;</font>
<font color="red"> 673.         if data is None:</font>
<font color="red"> 674.             return self.http_error_302(url, fp, errcode, errmsg, headers, data)</font>
<font color="black"> 675.         else:</font>
<font color="red"> 676.             return self.http_error_default(url, fp, errcode, errmsg, headers)</font>
<font color="black"> 677. </font>
<font color="green"> 678.     def http_error_401(self, url, fp, errcode, errmsg, headers, data=None):</font>
<font color="black"> 679.         &quot;&quot;&quot;Error 401 -- authentication required.</font>
<font color="black"> 680.         This function supports Basic authentication only.&quot;&quot;&quot;</font>
<font color="red"> 681.         if not 'www-authenticate' in headers:</font>
<font color="red"> 682.             URLopener.http_error_default(self, url, fp,</font>
<font color="red"> 683.                                          errcode, errmsg, headers)</font>
<font color="red"> 684.         stuff = headers['www-authenticate']</font>
<font color="red"> 685.         import re</font>
<font color="red"> 686.         match = re.match('[ \t]*([^ \t]+)[ \t]+realm=&quot;([^&quot;]*)&quot;', stuff)</font>
<font color="red"> 687.         if not match:</font>
<font color="red"> 688.             URLopener.http_error_default(self, url, fp,</font>
<font color="red"> 689.                                          errcode, errmsg, headers)</font>
<font color="red"> 690.         scheme, realm = match.groups()</font>
<font color="red"> 691.         if scheme.lower() != 'basic':</font>
<font color="red"> 692.             URLopener.http_error_default(self, url, fp,</font>
<font color="red"> 693.                                          errcode, errmsg, headers)</font>
<font color="red"> 694.         name = 'retry_' + self.type + '_basic_auth'</font>
<font color="red"> 695.         if data is None:</font>
<font color="red"> 696.             return getattr(self,name)(url, realm)</font>
<font color="black"> 697.         else:</font>
<font color="red"> 698.             return getattr(self,name)(url, realm, data)</font>
<font color="black"> 699. </font>
<font color="green"> 700.     def http_error_407(self, url, fp, errcode, errmsg, headers, data=None):</font>
<font color="black"> 701.         &quot;&quot;&quot;Error 407 -- proxy authentication required.</font>
<font color="black"> 702.         This function supports Basic authentication only.&quot;&quot;&quot;</font>
<font color="red"> 703.         if not 'proxy-authenticate' in headers:</font>
<font color="red"> 704.             URLopener.http_error_default(self, url, fp,</font>
<font color="red"> 705.                                          errcode, errmsg, headers)</font>
<font color="red"> 706.         stuff = headers['proxy-authenticate']</font>
<font color="red"> 707.         import re</font>
<font color="red"> 708.         match = re.match('[ \t]*([^ \t]+)[ \t]+realm=&quot;([^&quot;]*)&quot;', stuff)</font>
<font color="red"> 709.         if not match:</font>
<font color="red"> 710.             URLopener.http_error_default(self, url, fp,</font>
<font color="red"> 711.                                          errcode, errmsg, headers)</font>
<font color="red"> 712.         scheme, realm = match.groups()</font>
<font color="red"> 713.         if scheme.lower() != 'basic':</font>
<font color="red"> 714.             URLopener.http_error_default(self, url, fp,</font>
<font color="red"> 715.                                          errcode, errmsg, headers)</font>
<font color="red"> 716.         name = 'retry_proxy_' + self.type + '_basic_auth'</font>
<font color="red"> 717.         if data is None:</font>
<font color="red"> 718.             return getattr(self,name)(url, realm)</font>
<font color="black"> 719.         else:</font>
<font color="red"> 720.             return getattr(self,name)(url, realm, data)</font>
<font color="black"> 721. </font>
<font color="green"> 722.     def retry_proxy_http_basic_auth(self, url, realm, data=None):</font>
<font color="red"> 723.         host, selector = splithost(url)</font>
<font color="red"> 724.         newurl = 'http://' + host + selector</font>
<font color="red"> 725.         proxy = self.proxies['http']</font>
<font color="red"> 726.         urltype, proxyhost = splittype(proxy)</font>
<font color="red"> 727.         proxyhost, proxyselector = splithost(proxyhost)</font>
<font color="red"> 728.         i = proxyhost.find('@') + 1</font>
<font color="red"> 729.         proxyhost = proxyhost[i:]</font>
<font color="red"> 730.         user, passwd = self.get_user_passwd(proxyhost, realm, i)</font>
<font color="red"> 731.         if not (user or passwd): return None</font>
<font color="red"> 732.         proxyhost = quote(user, safe='') + ':' + quote(passwd, safe='') + '@' + proxyhost</font>
<font color="red"> 733.         self.proxies['http'] = 'http://' + proxyhost + proxyselector</font>
<font color="red"> 734.         if data is None:</font>
<font color="red"> 735.             return self.open(newurl)</font>
<font color="black"> 736.         else:</font>
<font color="red"> 737.             return self.open(newurl, data)</font>
<font color="black"> 738. </font>
<font color="green"> 739.     def retry_proxy_https_basic_auth(self, url, realm, data=None):</font>
<font color="red"> 740.         host, selector = splithost(url)</font>
<font color="red"> 741.         newurl = 'https://' + host + selector</font>
<font color="red"> 742.         proxy = self.proxies['https']</font>
<font color="red"> 743.         urltype, proxyhost = splittype(proxy)</font>
<font color="red"> 744.         proxyhost, proxyselector = splithost(proxyhost)</font>
<font color="red"> 745.         i = proxyhost.find('@') + 1</font>
<font color="red"> 746.         proxyhost = proxyhost[i:]</font>
<font color="red"> 747.         user, passwd = self.get_user_passwd(proxyhost, realm, i)</font>
<font color="red"> 748.         if not (user or passwd): return None</font>
<font color="red"> 749.         proxyhost = quote(user, safe='') + ':' + quote(passwd, safe='') + '@' + proxyhost</font>
<font color="red"> 750.         self.proxies['https'] = 'https://' + proxyhost + proxyselector</font>
<font color="red"> 751.         if data is None:</font>
<font color="red"> 752.             return self.open(newurl)</font>
<font color="black"> 753.         else:</font>
<font color="red"> 754.             return self.open(newurl, data)</font>
<font color="black"> 755. </font>
<font color="green"> 756.     def retry_http_basic_auth(self, url, realm, data=None):</font>
<font color="red"> 757.         host, selector = splithost(url)</font>
<font color="red"> 758.         i = host.find('@') + 1</font>
<font color="red"> 759.         host = host[i:]</font>
<font color="red"> 760.         user, passwd = self.get_user_passwd(host, realm, i)</font>
<font color="red"> 761.         if not (user or passwd): return None</font>
<font color="red"> 762.         host = quote(user, safe='') + ':' + quote(passwd, safe='') + '@' + host</font>
<font color="red"> 763.         newurl = 'http://' + host + selector</font>
<font color="red"> 764.         if data is None:</font>
<font color="red"> 765.             return self.open(newurl)</font>
<font color="black"> 766.         else:</font>
<font color="red"> 767.             return self.open(newurl, data)</font>
<font color="black"> 768. </font>
<font color="green"> 769.     def retry_https_basic_auth(self, url, realm, data=None):</font>
<font color="red"> 770.         host, selector = splithost(url)</font>
<font color="red"> 771.         i = host.find('@') + 1</font>
<font color="red"> 772.         host = host[i:]</font>
<font color="red"> 773.         user, passwd = self.get_user_passwd(host, realm, i)</font>
<font color="red"> 774.         if not (user or passwd): return None</font>
<font color="red"> 775.         host = quote(user, safe='') + ':' + quote(passwd, safe='') + '@' + host</font>
<font color="red"> 776.         newurl = 'https://' + host + selector</font>
<font color="red"> 777.         if data is None:</font>
<font color="red"> 778.             return self.open(newurl)</font>
<font color="black"> 779.         else:</font>
<font color="red"> 780.             return self.open(newurl, data)</font>
<font color="black"> 781. </font>
<font color="green"> 782.     def get_user_passwd(self, host, realm, clear_cache=0):</font>
<font color="red"> 783.         key = realm + '@' + host.lower()</font>
<font color="red"> 784.         if key in self.auth_cache:</font>
<font color="red"> 785.             if clear_cache:</font>
<font color="red"> 786.                 del self.auth_cache[key]</font>
<font color="black"> 787.             else:</font>
<font color="red"> 788.                 return self.auth_cache[key]</font>
<font color="red"> 789.         user, passwd = self.prompt_user_passwd(host, realm)</font>
<font color="red"> 790.         if user or passwd: self.auth_cache[key] = (user, passwd)</font>
<font color="red"> 791.         return user, passwd</font>
<font color="black"> 792. </font>
<font color="green"> 793.     def prompt_user_passwd(self, host, realm):</font>
<font color="black"> 794.         &quot;&quot;&quot;Override this in a GUI environment!&quot;&quot;&quot;</font>
<font color="red"> 795.         import getpass</font>
<font color="red"> 796.         try:</font>
<font color="red"> 797.             user = raw_input(&quot;Enter username for %s at %s: &quot; % (realm,</font>
<font color="red"> 798.                                                                 host))</font>
<font color="red"> 799.             passwd = getpass.getpass(&quot;Enter password for %s in %s at %s: &quot; %</font>
<font color="red"> 800.                 (user, realm, host))</font>
<font color="red"> 801.             return user, passwd</font>
<font color="red"> 802.         except KeyboardInterrupt:</font>
<font color="red"> 803.             print</font>
<font color="red"> 804.             return None, None</font>
<font color="black"> 805. </font>
<font color="black"> 806. </font>
<font color="black"> 807. # Utility functions</font>
<font color="black"> 808. </font>
<font color="green"> 809. _localhost = None</font>
<font color="green"> 810. def localhost():</font>
<font color="black"> 811.     &quot;&quot;&quot;Return the IP address of the magic hostname 'localhost'.&quot;&quot;&quot;</font>
<font color="black"> 812.     global _localhost</font>
<font color="red"> 813.     if _localhost is None:</font>
<font color="red"> 814.         _localhost = socket.gethostbyname('localhost')</font>
<font color="red"> 815.     return _localhost</font>
<font color="black"> 816. </font>
<font color="green"> 817. _thishost = None</font>
<font color="green"> 818. def thishost():</font>
<font color="black"> 819.     &quot;&quot;&quot;Return the IP address of the current host.&quot;&quot;&quot;</font>
<font color="black"> 820.     global _thishost</font>
<font color="red"> 821.     if _thishost is None:</font>
<font color="red"> 822.         try:</font>
<font color="red"> 823.             _thishost = socket.gethostbyname(socket.gethostname())</font>
<font color="red"> 824.         except socket.gaierror:</font>
<font color="red"> 825.             _thishost = socket.gethostbyname('localhost')</font>
<font color="red"> 826.     return _thishost</font>
<font color="black"> 827. </font>
<font color="green"> 828. _ftperrors = None</font>
<font color="green"> 829. def ftperrors():</font>
<font color="black"> 830.     &quot;&quot;&quot;Return the set of errors raised by the FTP class.&quot;&quot;&quot;</font>
<font color="black"> 831.     global _ftperrors</font>
<font color="red"> 832.     if _ftperrors is None:</font>
<font color="red"> 833.         import ftplib</font>
<font color="red"> 834.         _ftperrors = ftplib.all_errors</font>
<font color="red"> 835.     return _ftperrors</font>
<font color="black"> 836. </font>
<font color="green"> 837. _noheaders = None</font>
<font color="green"> 838. def noheaders():</font>
<font color="black"> 839.     &quot;&quot;&quot;Return an empty mimetools.Message object.&quot;&quot;&quot;</font>
<font color="black"> 840.     global _noheaders</font>
<font color="red"> 841.     if _noheaders is None:</font>
<font color="red"> 842.         import mimetools</font>
<font color="red"> 843.         try:</font>
<font color="red"> 844.             from cStringIO import StringIO</font>
<font color="red"> 845.         except ImportError:</font>
<font color="red"> 846.             from StringIO import StringIO</font>
<font color="red"> 847.         _noheaders = mimetools.Message(StringIO(), 0)</font>
<font color="red"> 848.         _noheaders.fp.close()   # Recycle file descriptor</font>
<font color="red"> 849.     return _noheaders</font>
<font color="black"> 850. </font>
<font color="black"> 851. </font>
<font color="black"> 852. # Utility classes</font>
<font color="black"> 853. </font>
<font color="green"> 854. class ftpwrapper:</font>
<font color="green"> 855.     &quot;&quot;&quot;Class used by open_ftp() for cache of open FTP connections.&quot;&quot;&quot;</font>
<font color="black"> 856. </font>
<font color="black"> 857.     def __init__(self, user, passwd, host, port, dirs,</font>
<font color="green"> 858.                  timeout=socket._GLOBAL_DEFAULT_TIMEOUT,</font>
<font color="green"> 859.                  persistent=True):</font>
<font color="red"> 860.         self.user = user</font>
<font color="red"> 861.         self.passwd = passwd</font>
<font color="red"> 862.         self.host = host</font>
<font color="red"> 863.         self.port = port</font>
<font color="red"> 864.         self.dirs = dirs</font>
<font color="red"> 865.         self.timeout = timeout</font>
<font color="red"> 866.         self.refcount = 0</font>
<font color="red"> 867.         self.keepalive = persistent</font>
<font color="red"> 868.         self.init()</font>
<font color="black"> 869. </font>
<font color="green"> 870.     def init(self):</font>
<font color="red"> 871.         import ftplib</font>
<font color="red"> 872.         self.busy = 0</font>
<font color="red"> 873.         self.ftp = ftplib.FTP()</font>
<font color="red"> 874.         self.ftp.connect(self.host, self.port, self.timeout)</font>
<font color="red"> 875.         self.ftp.login(self.user, self.passwd)</font>
<font color="red"> 876.         _target = '/'.join(self.dirs)</font>
<font color="red"> 877.         self.ftp.cwd(_target)</font>
<font color="black"> 878. </font>
<font color="green"> 879.     def retrfile(self, file, type):</font>
<font color="red"> 880.         import ftplib</font>
<font color="red"> 881.         self.endtransfer()</font>
<font color="red"> 882.         if type in ('d', 'D'): cmd = 'TYPE A'; isdir = 1</font>
<font color="red"> 883.         else: cmd = 'TYPE ' + type; isdir = 0</font>
<font color="red"> 884.         try:</font>
<font color="red"> 885.             self.ftp.voidcmd(cmd)</font>
<font color="red"> 886.         except ftplib.all_errors:</font>
<font color="red"> 887.             self.init()</font>
<font color="red"> 888.             self.ftp.voidcmd(cmd)</font>
<font color="red"> 889.         conn = None</font>
<font color="red"> 890.         if file and not isdir:</font>
<font color="black"> 891.             # Try to retrieve as a file</font>
<font color="red"> 892.             try:</font>
<font color="red"> 893.                 cmd = 'RETR ' + file</font>
<font color="red"> 894.                 conn, retrlen = self.ftp.ntransfercmd(cmd)</font>
<font color="red"> 895.             except ftplib.error_perm, reason:</font>
<font color="red"> 896.                 if str(reason)[:3] != '550':</font>
<font color="red"> 897.                     raise IOError, ('ftp error', reason), sys.exc_info()[2]</font>
<font color="red"> 898.         if not conn:</font>
<font color="black"> 899.             # Set transfer mode to ASCII!</font>
<font color="red"> 900.             self.ftp.voidcmd('TYPE A')</font>
<font color="black"> 901.             # Try a directory listing. Verify that directory exists.</font>
<font color="red"> 902.             if file:</font>
<font color="red"> 903.                 pwd = self.ftp.pwd()</font>
<font color="red"> 904.                 try:</font>
<font color="red"> 905.                     try:</font>
<font color="red"> 906.                         self.ftp.cwd(file)</font>
<font color="red"> 907.                     except ftplib.error_perm, reason:</font>
<font color="red"> 908.                         raise IOError, ('ftp error', reason), sys.exc_info()[2]</font>
<font color="black"> 909.                 finally:</font>
<font color="red"> 910.                     self.ftp.cwd(pwd)</font>
<font color="red"> 911.                 cmd = 'LIST ' + file</font>
<font color="black"> 912.             else:</font>
<font color="red"> 913.                 cmd = 'LIST'</font>
<font color="red"> 914.             conn, retrlen = self.ftp.ntransfercmd(cmd)</font>
<font color="red"> 915.         self.busy = 1</font>
<font color="red"> 916.         ftpobj = addclosehook(conn.makefile('rb'), self.file_close)</font>
<font color="red"> 917.         self.refcount += 1</font>
<font color="red"> 918.         conn.close()</font>
<font color="black"> 919.         # Pass back both a suitably decorated object and a retrieval length</font>
<font color="red"> 920.         return (ftpobj, retrlen)</font>
<font color="black"> 921. </font>
<font color="green"> 922.     def endtransfer(self):</font>
<font color="red"> 923.         if not self.busy:</font>
<font color="red"> 924.             return</font>
<font color="red"> 925.         self.busy = 0</font>
<font color="red"> 926.         try:</font>
<font color="red"> 927.             self.ftp.voidresp()</font>
<font color="red"> 928.         except ftperrors():</font>
<font color="red"> 929.             pass</font>
<font color="black"> 930. </font>
<font color="green"> 931.     def close(self):</font>
<font color="red"> 932.         self.keepalive = False</font>
<font color="red"> 933.         if self.refcount &lt;= 0:</font>
<font color="red"> 934.             self.real_close()</font>
<font color="black"> 935. </font>
<font color="green"> 936.     def file_close(self):</font>
<font color="red"> 937.         self.endtransfer()</font>
<font color="red"> 938.         self.refcount -= 1</font>
<font color="red"> 939.         if self.refcount &lt;= 0 and not self.keepalive:</font>
<font color="red"> 940.             self.real_close()</font>
<font color="black"> 941. </font>
<font color="green"> 942.     def real_close(self):</font>
<font color="red"> 943.         self.endtransfer()</font>
<font color="red"> 944.         try:</font>
<font color="red"> 945.             self.ftp.close()</font>
<font color="red"> 946.         except ftperrors():</font>
<font color="red"> 947.             pass</font>
<font color="black"> 948. </font>
<font color="green"> 949. class addbase:</font>
<font color="green"> 950.     &quot;&quot;&quot;Base class for addinfo and addclosehook.&quot;&quot;&quot;</font>
<font color="black"> 951. </font>
<font color="green"> 952.     def __init__(self, fp):</font>
<font color="red"> 953.         self.fp = fp</font>
<font color="red"> 954.         self.read = self.fp.read</font>
<font color="red"> 955.         self.readline = self.fp.readline</font>
<font color="red"> 956.         if hasattr(self.fp, &quot;readlines&quot;): self.readlines = self.fp.readlines</font>
<font color="red"> 957.         if hasattr(self.fp, &quot;fileno&quot;):</font>
<font color="red"> 958.             self.fileno = self.fp.fileno</font>
<font color="black"> 959.         else:</font>
<font color="red"> 960.             self.fileno = lambda: None</font>
<font color="red"> 961.         if hasattr(self.fp, &quot;__iter__&quot;):</font>
<font color="red"> 962.             self.__iter__ = self.fp.__iter__</font>
<font color="red"> 963.             if hasattr(self.fp, &quot;next&quot;):</font>
<font color="red"> 964.                 self.next = self.fp.next</font>
<font color="black"> 965. </font>
<font color="green"> 966.     def __repr__(self):</font>
<font color="red"> 967.         return '&lt;%s at %r whose fp = %r&gt;' % (self.__class__.__name__,</font>
<font color="red"> 968.                                              id(self), self.fp)</font>
<font color="black"> 969. </font>
<font color="green"> 970.     def close(self):</font>
<font color="red"> 971.         self.read = None</font>
<font color="red"> 972.         self.readline = None</font>
<font color="red"> 973.         self.readlines = None</font>
<font color="red"> 974.         self.fileno = None</font>
<font color="red"> 975.         if self.fp: self.fp.close()</font>
<font color="red"> 976.         self.fp = None</font>
<font color="black"> 977. </font>
<font color="green"> 978. class addclosehook(addbase):</font>
<font color="green"> 979.     &quot;&quot;&quot;Class to add a close hook to an open file.&quot;&quot;&quot;</font>
<font color="black"> 980. </font>
<font color="green"> 981.     def __init__(self, fp, closehook, *hookargs):</font>
<font color="red"> 982.         addbase.__init__(self, fp)</font>
<font color="red"> 983.         self.closehook = closehook</font>
<font color="red"> 984.         self.hookargs = hookargs</font>
<font color="black"> 985. </font>
<font color="green"> 986.     def close(self):</font>
<font color="red"> 987.         if self.closehook:</font>
<font color="red"> 988.             self.closehook(*self.hookargs)</font>
<font color="red"> 989.             self.closehook = None</font>
<font color="red"> 990.             self.hookargs = None</font>
<font color="red"> 991.         addbase.close(self)</font>
<font color="black"> 992. </font>
<font color="green"> 993. class addinfo(addbase):</font>
<font color="green"> 994.     &quot;&quot;&quot;class to add an info() method to an open file.&quot;&quot;&quot;</font>
<font color="black"> 995. </font>
<font color="green"> 996.     def __init__(self, fp, headers):</font>
<font color="red"> 997.         addbase.__init__(self, fp)</font>
<font color="red"> 998.         self.headers = headers</font>
<font color="black"> 999. </font>
<font color="green">1000.     def info(self):</font>
<font color="red">1001.         return self.headers</font>
<font color="black">1002. </font>
<font color="green">1003. class addinfourl(addbase):</font>
<font color="green">1004.     &quot;&quot;&quot;class to add info() and geturl() methods to an open file.&quot;&quot;&quot;</font>
<font color="black">1005. </font>
<font color="green">1006.     def __init__(self, fp, headers, url, code=None):</font>
<font color="red">1007.         addbase.__init__(self, fp)</font>
<font color="red">1008.         self.headers = headers</font>
<font color="red">1009.         self.url = url</font>
<font color="red">1010.         self.code = code</font>
<font color="black">1011. </font>
<font color="green">1012.     def info(self):</font>
<font color="red">1013.         return self.headers</font>
<font color="black">1014. </font>
<font color="green">1015.     def getcode(self):</font>
<font color="red">1016.         return self.code</font>
<font color="black">1017. </font>
<font color="green">1018.     def geturl(self):</font>
<font color="red">1019.         return self.url</font>
<font color="black">1020. </font>
<font color="black">1021. </font>
<font color="black">1022. # Utilities to parse URLs (most of these return None for missing parts):</font>
<font color="black">1023. # unwrap('&lt;URL:type://host/path&gt;') --&gt; 'type://host/path'</font>
<font color="black">1024. # splittype('type:opaquestring') --&gt; 'type', 'opaquestring'</font>
<font color="black">1025. # splithost('//host[:port]/path') --&gt; 'host[:port]', '/path'</font>
<font color="black">1026. # splituser('user[:passwd]@host[:port]') --&gt; 'user[:passwd]', 'host[:port]'</font>
<font color="black">1027. # splitpasswd('user:passwd') -&gt; 'user', 'passwd'</font>
<font color="black">1028. # splitport('host:port') --&gt; 'host', 'port'</font>
<font color="black">1029. # splitquery('/path?query') --&gt; '/path', 'query'</font>
<font color="black">1030. # splittag('/path#tag') --&gt; '/path', 'tag'</font>
<font color="black">1031. # splitattr('/path;attr1=value1;attr2=value2;...') -&gt;</font>
<font color="black">1032. #   '/path', ['attr1=value1', 'attr2=value2', ...]</font>
<font color="black">1033. # splitvalue('attr=value') --&gt; 'attr', 'value'</font>
<font color="black">1034. # unquote('abc%20def') -&gt; 'abc def'</font>
<font color="black">1035. # quote('abc def') -&gt; 'abc%20def')</font>
<font color="black">1036. </font>
<font color="green">1037. try:</font>
<font color="green">1038.     unicode</font>
<font color="red">1039. except NameError:</font>
<font color="red">1040.     def _is_unicode(x):</font>
<font color="red">1041.         return 0</font>
<font color="black">1042. else:</font>
<font color="green">1043.     def _is_unicode(x):</font>
<font color="red">1044.         return isinstance(x, unicode)</font>
<font color="black">1045. </font>
<font color="green">1046. def toBytes(url):</font>
<font color="black">1047.     &quot;&quot;&quot;toBytes(u&quot;URL&quot;) --&gt; 'URL'.&quot;&quot;&quot;</font>
<font color="black">1048.     # Most URL schemes require ASCII. If that changes, the conversion</font>
<font color="black">1049.     # can be relaxed</font>
<font color="red">1050.     if _is_unicode(url):</font>
<font color="red">1051.         try:</font>
<font color="red">1052.             url = url.encode(&quot;ASCII&quot;)</font>
<font color="red">1053.         except UnicodeError:</font>
<font color="red">1054.             raise UnicodeError(&quot;URL &quot; + repr(url) +</font>
<font color="red">1055.                                &quot; contains non-ASCII characters&quot;)</font>
<font color="red">1056.     return url</font>
<font color="black">1057. </font>
<font color="green">1058. def unwrap(url):</font>
<font color="black">1059.     &quot;&quot;&quot;unwrap('&lt;URL:type://host/path&gt;') --&gt; 'type://host/path'.&quot;&quot;&quot;</font>
<font color="red">1060.     url = url.strip()</font>
<font color="red">1061.     if url[:1] == '&lt;' and url[-1:] == '&gt;':</font>
<font color="red">1062.         url = url[1:-1].strip()</font>
<font color="red">1063.     if url[:4] == 'URL:': url = url[4:].strip()</font>
<font color="red">1064.     return url</font>
<font color="black">1065. </font>
<font color="green">1066. _typeprog = None</font>
<font color="green">1067. def splittype(url):</font>
<font color="black">1068.     &quot;&quot;&quot;splittype('type:opaquestring') --&gt; 'type', 'opaquestring'.&quot;&quot;&quot;</font>
<font color="black">1069.     global _typeprog</font>
<font color="red">1070.     if _typeprog is None:</font>
<font color="red">1071.         import re</font>
<font color="red">1072.         _typeprog = re.compile('^([^/:]+):')</font>
<font color="black">1073. </font>
<font color="red">1074.     match = _typeprog.match(url)</font>
<font color="red">1075.     if match:</font>
<font color="red">1076.         scheme = match.group(1)</font>
<font color="red">1077.         return scheme.lower(), url[len(scheme) + 1:]</font>
<font color="red">1078.     return None, url</font>
<font color="black">1079. </font>
<font color="green">1080. _hostprog = None</font>
<font color="green">1081. def splithost(url):</font>
<font color="black">1082.     &quot;&quot;&quot;splithost('//host[:port]/path') --&gt; 'host[:port]', '/path'.&quot;&quot;&quot;</font>
<font color="black">1083.     global _hostprog</font>
<font color="red">1084.     if _hostprog is None:</font>
<font color="red">1085.         import re</font>
<font color="red">1086.         _hostprog = re.compile('^//([^/?]*)(.*)$')</font>
<font color="black">1087. </font>
<font color="red">1088.     match = _hostprog.match(url)</font>
<font color="red">1089.     if match:</font>
<font color="red">1090.         host_port = match.group(1)</font>
<font color="red">1091.         path = match.group(2)</font>
<font color="red">1092.         if path and not path.startswith('/'):</font>
<font color="red">1093.             path = '/' + path</font>
<font color="red">1094.         return host_port, path</font>
<font color="red">1095.     return None, url</font>
<font color="black">1096. </font>
<font color="green">1097. _userprog = None</font>
<font color="green">1098. def splituser(host):</font>
<font color="black">1099.     &quot;&quot;&quot;splituser('user[:passwd]@host[:port]') --&gt; 'user[:passwd]', 'host[:port]'.&quot;&quot;&quot;</font>
<font color="black">1100.     global _userprog</font>
<font color="red">1101.     if _userprog is None:</font>
<font color="red">1102.         import re</font>
<font color="red">1103.         _userprog = re.compile('^(.*)@(.*)$')</font>
<font color="black">1104. </font>
<font color="red">1105.     match = _userprog.match(host)</font>
<font color="red">1106.     if match: return match.group(1, 2)</font>
<font color="red">1107.     return None, host</font>
<font color="black">1108. </font>
<font color="green">1109. _passwdprog = None</font>
<font color="green">1110. def splitpasswd(user):</font>
<font color="black">1111.     &quot;&quot;&quot;splitpasswd('user:passwd') -&gt; 'user', 'passwd'.&quot;&quot;&quot;</font>
<font color="black">1112.     global _passwdprog</font>
<font color="red">1113.     if _passwdprog is None:</font>
<font color="red">1114.         import re</font>
<font color="red">1115.         _passwdprog = re.compile('^([^:]*):(.*)$',re.S)</font>
<font color="black">1116. </font>
<font color="red">1117.     match = _passwdprog.match(user)</font>
<font color="red">1118.     if match: return match.group(1, 2)</font>
<font color="red">1119.     return user, None</font>
<font color="black">1120. </font>
<font color="black">1121. # splittag('/path#tag') --&gt; '/path', 'tag'</font>
<font color="green">1122. _portprog = None</font>
<font color="green">1123. def splitport(host):</font>
<font color="black">1124.     &quot;&quot;&quot;splitport('host:port') --&gt; 'host', 'port'.&quot;&quot;&quot;</font>
<font color="black">1125.     global _portprog</font>
<font color="red">1126.     if _portprog is None:</font>
<font color="red">1127.         import re</font>
<font color="red">1128.         _portprog = re.compile('^(.*):([0-9]*)$')</font>
<font color="black">1129. </font>
<font color="red">1130.     match = _portprog.match(host)</font>
<font color="red">1131.     if match:</font>
<font color="red">1132.         host, port = match.groups()</font>
<font color="red">1133.         if port:</font>
<font color="red">1134.             return host, port</font>
<font color="red">1135.     return host, None</font>
<font color="black">1136. </font>
<font color="green">1137. _nportprog = None</font>
<font color="green">1138. def splitnport(host, defport=-1):</font>
<font color="black">1139.     &quot;&quot;&quot;Split host and port, returning numeric port.</font>
<font color="black">1140.     Return given default port if no ':' found; defaults to -1.</font>
<font color="black">1141.     Return numerical port if a valid number are found after ':'.</font>
<font color="black">1142.     Return None if ':' but not a valid number.&quot;&quot;&quot;</font>
<font color="black">1143.     global _nportprog</font>
<font color="red">1144.     if _nportprog is None:</font>
<font color="red">1145.         import re</font>
<font color="red">1146.         _nportprog = re.compile('^(.*):(.*)$')</font>
<font color="black">1147. </font>
<font color="red">1148.     match = _nportprog.match(host)</font>
<font color="red">1149.     if match:</font>
<font color="red">1150.         host, port = match.group(1, 2)</font>
<font color="red">1151.         if port:</font>
<font color="red">1152.             try:</font>
<font color="red">1153.                 nport = int(port)</font>
<font color="red">1154.             except ValueError:</font>
<font color="red">1155.                 nport = None</font>
<font color="red">1156.             return host, nport</font>
<font color="red">1157.     return host, defport</font>
<font color="black">1158. </font>
<font color="green">1159. _queryprog = None</font>
<font color="green">1160. def splitquery(url):</font>
<font color="black">1161.     &quot;&quot;&quot;splitquery('/path?query') --&gt; '/path', 'query'.&quot;&quot;&quot;</font>
<font color="black">1162.     global _queryprog</font>
<font color="red">1163.     if _queryprog is None:</font>
<font color="red">1164.         import re</font>
<font color="red">1165.         _queryprog = re.compile('^(.*)\?([^?]*)$')</font>
<font color="black">1166. </font>
<font color="red">1167.     match = _queryprog.match(url)</font>
<font color="red">1168.     if match: return match.group(1, 2)</font>
<font color="red">1169.     return url, None</font>
<font color="black">1170. </font>
<font color="green">1171. _tagprog = None</font>
<font color="green">1172. def splittag(url):</font>
<font color="black">1173.     &quot;&quot;&quot;splittag('/path#tag') --&gt; '/path', 'tag'.&quot;&quot;&quot;</font>
<font color="black">1174.     global _tagprog</font>
<font color="red">1175.     if _tagprog is None:</font>
<font color="red">1176.         import re</font>
<font color="red">1177.         _tagprog = re.compile('^(.*)#([^#]*)$')</font>
<font color="black">1178. </font>
<font color="red">1179.     match = _tagprog.match(url)</font>
<font color="red">1180.     if match: return match.group(1, 2)</font>
<font color="red">1181.     return url, None</font>
<font color="black">1182. </font>
<font color="green">1183. def splitattr(url):</font>
<font color="black">1184.     &quot;&quot;&quot;splitattr('/path;attr1=value1;attr2=value2;...') -&gt;</font>
<font color="black">1185.         '/path', ['attr1=value1', 'attr2=value2', ...].&quot;&quot;&quot;</font>
<font color="red">1186.     words = url.split(';')</font>
<font color="red">1187.     return words[0], words[1:]</font>
<font color="black">1188. </font>
<font color="green">1189. _valueprog = None</font>
<font color="green">1190. def splitvalue(attr):</font>
<font color="black">1191.     &quot;&quot;&quot;splitvalue('attr=value') --&gt; 'attr', 'value'.&quot;&quot;&quot;</font>
<font color="black">1192.     global _valueprog</font>
<font color="red">1193.     if _valueprog is None:</font>
<font color="red">1194.         import re</font>
<font color="red">1195.         _valueprog = re.compile('^([^=]*)=(.*)$')</font>
<font color="black">1196. </font>
<font color="red">1197.     match = _valueprog.match(attr)</font>
<font color="red">1198.     if match: return match.group(1, 2)</font>
<font color="red">1199.     return attr, None</font>
<font color="black">1200. </font>
<font color="black">1201. # urlparse contains a duplicate of this method to avoid a circular import.  If</font>
<font color="black">1202. # you update this method, also update the copy in urlparse.  This code</font>
<font color="black">1203. # duplication does not exist in Python3.</font>
<font color="black">1204. </font>
<font color="green">1205. _hexdig = '0123456789ABCDEFabcdef'</font>
<font color="green">1206. _hextochr = dict((a + b, chr(int(a + b, 16)))</font>
<font color="green">1207.                  for a in _hexdig for b in _hexdig)</font>
<font color="green">1208. _asciire = re.compile('([\x00-\x7f]+)')</font>
<font color="black">1209. </font>
<font color="green">1210. def unquote(s):</font>
<font color="black">1211.     &quot;&quot;&quot;unquote('abc%20def') -&gt; 'abc def'.&quot;&quot;&quot;</font>
<font color="red">1212.     if _is_unicode(s):</font>
<font color="red">1213.         if '%' not in s:</font>
<font color="red">1214.             return s</font>
<font color="red">1215.         bits = _asciire.split(s)</font>
<font color="red">1216.         res = [bits[0]]</font>
<font color="red">1217.         append = res.append</font>
<font color="red">1218.         for i in range(1, len(bits), 2):</font>
<font color="red">1219.             append(unquote(str(bits[i])).decode('latin1'))</font>
<font color="red">1220.             append(bits[i + 1])</font>
<font color="red">1221.         return ''.join(res)</font>
<font color="black">1222. </font>
<font color="red">1223.     bits = s.split('%')</font>
<font color="black">1224.     # fastpath</font>
<font color="red">1225.     if len(bits) == 1:</font>
<font color="red">1226.         return s</font>
<font color="red">1227.     res = [bits[0]]</font>
<font color="red">1228.     append = res.append</font>
<font color="red">1229.     for item in bits[1:]:</font>
<font color="red">1230.         try:</font>
<font color="red">1231.             append(_hextochr[item[:2]])</font>
<font color="red">1232.             append(item[2:])</font>
<font color="red">1233.         except KeyError:</font>
<font color="red">1234.             append('%')</font>
<font color="red">1235.             append(item)</font>
<font color="red">1236.     return ''.join(res)</font>
<font color="black">1237. </font>
<font color="green">1238. def unquote_plus(s):</font>
<font color="black">1239.     &quot;&quot;&quot;unquote('%7e/abc+def') -&gt; '~/abc def'&quot;&quot;&quot;</font>
<font color="red">1240.     s = s.replace('+', ' ')</font>
<font color="red">1241.     return unquote(s)</font>
<font color="black">1242. </font>
<font color="green">1243. always_safe = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ'</font>
<font color="black">1244.                'abcdefghijklmnopqrstuvwxyz'</font>
<font color="black">1245.                '0123456789' '_.-')</font>
<font color="green">1246. _safe_map = {}</font>
<font color="green">1247. for i, c in zip(xrange(256), str(bytearray(xrange(256)))):</font>
<font color="green">1248.     _safe_map[c] = c if (i &lt; 128 and c in always_safe) else '%{:02X}'.format(i)</font>
<font color="green">1249. _safe_quoters = {}</font>
<font color="black">1250. </font>
<font color="green">1251. def quote(s, safe='/'):</font>
<font color="black">1252.     &quot;&quot;&quot;quote('abc def') -&gt; 'abc%20def'</font>
<font color="black">1253. </font>
<font color="black">1254.     Each part of a URL, e.g. the path info, the query, etc., has a</font>
<font color="black">1255.     different set of reserved characters that must be quoted.</font>
<font color="black">1256. </font>
<font color="black">1257.     RFC 2396 Uniform Resource Identifiers (URI): Generic Syntax lists</font>
<font color="black">1258.     the following reserved characters.</font>
<font color="black">1259. </font>
<font color="black">1260.     reserved    = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |</font>
<font color="black">1261.                   &quot;$&quot; | &quot;,&quot;</font>
<font color="black">1262. </font>
<font color="black">1263.     Each of these characters is reserved in some component of a URL,</font>
<font color="black">1264.     but not necessarily in all of them.</font>
<font color="black">1265. </font>
<font color="black">1266.     By default, the quote function is intended for quoting the path</font>
<font color="black">1267.     section of a URL.  Thus, it will not encode '/'.  This character</font>
<font color="black">1268.     is reserved, but in typical usage the quote function is being</font>
<font color="black">1269.     called on a path where the existing slash characters are used as</font>
<font color="black">1270.     reserved characters.</font>
<font color="black">1271.     &quot;&quot;&quot;</font>
<font color="black">1272.     # fastpath</font>
<font color="red">1273.     if not s:</font>
<font color="red">1274.         if s is None:</font>
<font color="red">1275.             raise TypeError('None object cannot be quoted')</font>
<font color="red">1276.         return s</font>
<font color="red">1277.     cachekey = (safe, always_safe)</font>
<font color="red">1278.     try:</font>
<font color="red">1279.         (quoter, safe) = _safe_quoters[cachekey]</font>
<font color="red">1280.     except KeyError:</font>
<font color="red">1281.         safe_map = _safe_map.copy()</font>
<font color="red">1282.         safe_map.update([(c, c) for c in safe])</font>
<font color="red">1283.         quoter = safe_map.__getitem__</font>
<font color="red">1284.         safe = always_safe + safe</font>
<font color="red">1285.         _safe_quoters[cachekey] = (quoter, safe)</font>
<font color="red">1286.     if not s.rstrip(safe):</font>
<font color="red">1287.         return s</font>
<font color="red">1288.     return ''.join(map(quoter, s))</font>
<font color="black">1289. </font>
<font color="green">1290. def quote_plus(s, safe=''):</font>
<font color="black">1291.     &quot;&quot;&quot;Quote the query fragment of a URL; replacing ' ' with '+'&quot;&quot;&quot;</font>
<font color="red">1292.     if ' ' in s:</font>
<font color="red">1293.         s = quote(s, safe + ' ')</font>
<font color="red">1294.         return s.replace(' ', '+')</font>
<font color="red">1295.     return quote(s, safe)</font>
<font color="black">1296. </font>
<font color="green">1297. def urlencode(query, doseq=0):</font>
<font color="black">1298.     &quot;&quot;&quot;Encode a sequence of two-element tuples or dictionary into a URL query string.</font>
<font color="black">1299. </font>
<font color="black">1300.     If any values in the query arg are sequences and doseq is true, each</font>
<font color="black">1301.     sequence element is converted to a separate parameter.</font>
<font color="black">1302. </font>
<font color="black">1303.     If the query arg is a sequence of two-element tuples, the order of the</font>
<font color="black">1304.     parameters in the output will match the order of parameters in the</font>
<font color="black">1305.     input.</font>
<font color="black">1306.     &quot;&quot;&quot;</font>
<font color="black">1307. </font>
<font color="red">1308.     if hasattr(query,&quot;items&quot;):</font>
<font color="black">1309.         # mapping objects</font>
<font color="red">1310.         query = query.items()</font>
<font color="black">1311.     else:</font>
<font color="black">1312.         # it's a bother at times that strings and string-like objects are</font>
<font color="black">1313.         # sequences...</font>
<font color="red">1314.         try:</font>
<font color="black">1315.             # non-sequence items should not work with len()</font>
<font color="black">1316.             # non-empty strings will fail this</font>
<font color="red">1317.             if len(query) and not isinstance(query[0], tuple):</font>
<font color="red">1318.                 raise TypeError</font>
<font color="black">1319.             # zero-length sequences of all types will get here and succeed,</font>
<font color="black">1320.             # but that's a minor nit - since the original implementation</font>
<font color="black">1321.             # allowed empty dicts that type of behavior probably should be</font>
<font color="black">1322.             # preserved for consistency</font>
<font color="red">1323.         except TypeError:</font>
<font color="red">1324.             ty,va,tb = sys.exc_info()</font>
<font color="red">1325.             raise TypeError, &quot;not a valid non-string sequence or mapping object&quot;, tb</font>
<font color="black">1326. </font>
<font color="red">1327.     l = []</font>
<font color="red">1328.     if not doseq:</font>
<font color="black">1329.         # preserve old behavior</font>
<font color="red">1330.         for k, v in query:</font>
<font color="red">1331.             k = quote_plus(str(k))</font>
<font color="red">1332.             v = quote_plus(str(v))</font>
<font color="red">1333.             l.append(k + '=' + v)</font>
<font color="black">1334.     else:</font>
<font color="red">1335.         for k, v in query:</font>
<font color="red">1336.             k = quote_plus(str(k))</font>
<font color="red">1337.             if isinstance(v, str):</font>
<font color="red">1338.                 v = quote_plus(v)</font>
<font color="red">1339.                 l.append(k + '=' + v)</font>
<font color="red">1340.             elif _is_unicode(v):</font>
<font color="black">1341.                 # is there a reasonable way to convert to ASCII?</font>
<font color="black">1342.                 # encode generates a string, but &quot;replace&quot; or &quot;ignore&quot;</font>
<font color="black">1343.                 # lose information and &quot;strict&quot; can raise UnicodeError</font>
<font color="red">1344.                 v = quote_plus(v.encode(&quot;ASCII&quot;,&quot;replace&quot;))</font>
<font color="red">1345.                 l.append(k + '=' + v)</font>
<font color="black">1346.             else:</font>
<font color="red">1347.                 try:</font>
<font color="black">1348.                     # is this a sufficient test for sequence-ness?</font>
<font color="red">1349.                     len(v)</font>
<font color="red">1350.                 except TypeError:</font>
<font color="black">1351.                     # not a sequence</font>
<font color="red">1352.                     v = quote_plus(str(v))</font>
<font color="red">1353.                     l.append(k + '=' + v)</font>
<font color="black">1354.                 else:</font>
<font color="black">1355.                     # loop over the sequence</font>
<font color="red">1356.                     for elt in v:</font>
<font color="red">1357.                         l.append(k + '=' + quote_plus(str(elt)))</font>
<font color="red">1358.     return '&amp;'.join(l)</font>
<font color="black">1359. </font>
<font color="black">1360. # Proxy handling</font>
<font color="green">1361. def getproxies_environment():</font>
<font color="black">1362.     &quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings.</font>
<font color="black">1363. </font>
<font color="black">1364.     Scan the environment for variables named &lt;scheme&gt;_proxy;</font>
<font color="black">1365.     this seems to be the standard convention.  If you need a</font>
<font color="black">1366.     different way, you can pass a proxies dictionary to the</font>
<font color="black">1367.     [Fancy]URLopener constructor.</font>
<font color="black">1368. </font>
<font color="black">1369.     &quot;&quot;&quot;</font>
<font color="red">1370.     proxies = {}</font>
<font color="red">1371.     for name, value in os.environ.items():</font>
<font color="red">1372.         name = name.lower()</font>
<font color="red">1373.         if value and name[-6:] == '_proxy':</font>
<font color="red">1374.             proxies[name[:-6]] = value</font>
<font color="red">1375.     return proxies</font>
<font color="black">1376. </font>
<font color="green">1377. def proxy_bypass_environment(host):</font>
<font color="black">1378.     &quot;&quot;&quot;Test if proxies should not be used for a particular host.</font>
<font color="black">1379. </font>
<font color="black">1380.     Checks the environment for a variable named no_proxy, which should</font>
<font color="black">1381.     be a list of DNS suffixes separated by commas, or '*' for all hosts.</font>
<font color="black">1382.     &quot;&quot;&quot;</font>
<font color="red">1383.     no_proxy = os.environ.get('no_proxy', '') or os.environ.get('NO_PROXY', '')</font>
<font color="black">1384.     # '*' is special case for always bypass</font>
<font color="red">1385.     if no_proxy == '*':</font>
<font color="red">1386.         return 1</font>
<font color="black">1387.     # strip port off host</font>
<font color="red">1388.     hostonly, port = splitport(host)</font>
<font color="black">1389.     # check if the host ends with any of the DNS suffixes</font>
<font color="red">1390.     no_proxy_list = [proxy.strip() for proxy in no_proxy.split(',')]</font>
<font color="red">1391.     for name in no_proxy_list:</font>
<font color="red">1392.         if name and (hostonly.endswith(name) or host.endswith(name)):</font>
<font color="red">1393.             return 1</font>
<font color="black">1394.     # otherwise, don't bypass</font>
<font color="red">1395.     return 0</font>
<font color="black">1396. </font>
<font color="black">1397. </font>
<font color="green">1398. if sys.platform == 'darwin':</font>
<font color="red">1399.     from _scproxy import _get_proxy_settings, _get_proxies</font>
<font color="black">1400. </font>
<font color="red">1401.     def proxy_bypass_macosx_sysconf(host):</font>
<font color="black">1402.         &quot;&quot;&quot;</font>
<font color="black">1403.         Return True iff this host shouldn't be accessed using a proxy</font>
<font color="black">1404. </font>
<font color="black">1405.         This function uses the MacOSX framework SystemConfiguration</font>
<font color="black">1406.         to fetch the proxy information.</font>
<font color="black">1407.         &quot;&quot;&quot;</font>
<font color="red">1408.         import re</font>
<font color="red">1409.         import socket</font>
<font color="red">1410.         from fnmatch import fnmatch</font>
<font color="black">1411. </font>
<font color="red">1412.         hostonly, port = splitport(host)</font>
<font color="black">1413. </font>
<font color="red">1414.         def ip2num(ipAddr):</font>
<font color="red">1415.             parts = ipAddr.split('.')</font>
<font color="red">1416.             parts = map(int, parts)</font>
<font color="red">1417.             if len(parts) != 4:</font>
<font color="red">1418.                 parts = (parts + [0, 0, 0, 0])[:4]</font>
<font color="red">1419.             return (parts[0] &lt;&lt; 24) | (parts[1] &lt;&lt; 16) | (parts[2] &lt;&lt; 8) | parts[3]</font>
<font color="black">1420. </font>
<font color="red">1421.         proxy_settings = _get_proxy_settings()</font>
<font color="black">1422. </font>
<font color="black">1423.         # Check for simple host names:</font>
<font color="red">1424.         if '.' not in host:</font>
<font color="red">1425.             if proxy_settings['exclude_simple']:</font>
<font color="red">1426.                 return True</font>
<font color="black">1427. </font>
<font color="red">1428.         hostIP = None</font>
<font color="black">1429. </font>
<font color="red">1430.         for value in proxy_settings.get('exceptions', ()):</font>
<font color="black">1431.             # Items in the list are strings like these: *.local, 169.254/16</font>
<font color="red">1432.             if not value: continue</font>
<font color="black">1433. </font>
<font color="red">1434.             m = re.match(r&quot;(\d+(?:\.\d+)*)(/\d+)?&quot;, value)</font>
<font color="red">1435.             if m is not None:</font>
<font color="red">1436.                 if hostIP is None:</font>
<font color="red">1437.                     try:</font>
<font color="red">1438.                         hostIP = socket.gethostbyname(hostonly)</font>
<font color="red">1439.                         hostIP = ip2num(hostIP)</font>
<font color="red">1440.                     except socket.error:</font>
<font color="red">1441.                         continue</font>
<font color="black">1442. </font>
<font color="red">1443.                 base = ip2num(m.group(1))</font>
<font color="red">1444.                 mask = m.group(2)</font>
<font color="red">1445.                 if mask is None:</font>
<font color="red">1446.                     mask = 8 * (m.group(1).count('.') + 1)</font>
<font color="black">1447. </font>
<font color="black">1448.                 else:</font>
<font color="red">1449.                     mask = int(mask[1:])</font>
<font color="red">1450.                 mask = 32 - mask</font>
<font color="black">1451. </font>
<font color="red">1452.                 if (hostIP &gt;&gt; mask) == (base &gt;&gt; mask):</font>
<font color="red">1453.                     return True</font>
<font color="black">1454. </font>
<font color="red">1455.             elif fnmatch(host, value):</font>
<font color="red">1456.                 return True</font>
<font color="black">1457. </font>
<font color="red">1458.         return False</font>
<font color="black">1459. </font>
<font color="red">1460.     def getproxies_macosx_sysconf():</font>
<font color="black">1461.         &quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings.</font>
<font color="black">1462. </font>
<font color="black">1463.         This function uses the MacOSX framework SystemConfiguration</font>
<font color="black">1464.         to fetch the proxy information.</font>
<font color="black">1465.         &quot;&quot;&quot;</font>
<font color="red">1466.         return _get_proxies()</font>
<font color="black">1467. </font>
<font color="red">1468.     def proxy_bypass(host):</font>
<font color="red">1469.         if getproxies_environment():</font>
<font color="red">1470.             return proxy_bypass_environment(host)</font>
<font color="black">1471.         else:</font>
<font color="red">1472.             return proxy_bypass_macosx_sysconf(host)</font>
<font color="black">1473. </font>
<font color="red">1474.     def getproxies():</font>
<font color="red">1475.         return getproxies_environment() or getproxies_macosx_sysconf()</font>
<font color="black">1476. </font>
<font color="green">1477. elif os.name == 'nt':</font>
<font color="red">1478.     def getproxies_registry():</font>
<font color="black">1479.         &quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings.</font>
<font color="black">1480. </font>
<font color="black">1481.         Win32 uses the registry to store proxies.</font>
<font color="black">1482. </font>
<font color="black">1483.         &quot;&quot;&quot;</font>
<font color="red">1484.         proxies = {}</font>
<font color="red">1485.         try:</font>
<font color="red">1486.             import _winreg</font>
<font color="red">1487.         except ImportError:</font>
<font color="black">1488.             # Std module, so should be around - but you never know!</font>
<font color="red">1489.             return proxies</font>
<font color="red">1490.         try:</font>
<font color="red">1491.             internetSettings = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER,</font>
<font color="red">1492.                 r'Software\Microsoft\Windows\CurrentVersion\Internet Settings')</font>
<font color="red">1493.             proxyEnable = _winreg.QueryValueEx(internetSettings,</font>
<font color="red">1494.                                                'ProxyEnable')[0]</font>
<font color="red">1495.             if proxyEnable:</font>
<font color="black">1496.                 # Returned as Unicode but problems if not converted to ASCII</font>
<font color="red">1497.                 proxyServer = str(_winreg.QueryValueEx(internetSettings,</font>
<font color="red">1498.                                                        'ProxyServer')[0])</font>
<font color="red">1499.                 if '=' in proxyServer:</font>
<font color="black">1500.                     # Per-protocol settings</font>
<font color="red">1501.                     for p in proxyServer.split(';'):</font>
<font color="red">1502.                         protocol, address = p.split('=', 1)</font>
<font color="black">1503.                         # See if address has a type:// prefix</font>
<font color="red">1504.                         import re</font>
<font color="red">1505.                         if not re.match('^([^/:]+)://', address):</font>
<font color="red">1506.                             address = '%s://%s' % (protocol, address)</font>
<font color="red">1507.                         proxies[protocol] = address</font>
<font color="black">1508.                 else:</font>
<font color="black">1509.                     # Use one setting for all protocols</font>
<font color="red">1510.                     if proxyServer[:5] == 'http:':</font>
<font color="red">1511.                         proxies['http'] = proxyServer</font>
<font color="black">1512.                     else:</font>
<font color="red">1513.                         proxies['http'] = 'http://%s' % proxyServer</font>
<font color="red">1514.                         proxies['https'] = 'https://%s' % proxyServer</font>
<font color="red">1515.                         proxies['ftp'] = 'ftp://%s' % proxyServer</font>
<font color="red">1516.             internetSettings.Close()</font>
<font color="red">1517.         except (WindowsError, ValueError, TypeError):</font>
<font color="black">1518.             # Either registry key not found etc, or the value in an</font>
<font color="black">1519.             # unexpected format.</font>
<font color="black">1520.             # proxies already set up to be empty so nothing to do</font>
<font color="red">1521.             pass</font>
<font color="red">1522.         return proxies</font>
<font color="black">1523. </font>
<font color="red">1524.     def getproxies():</font>
<font color="black">1525.         &quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings.</font>
<font color="black">1526. </font>
<font color="black">1527.         Returns settings gathered from the environment, if specified,</font>
<font color="black">1528.         or the registry.</font>
<font color="black">1529. </font>
<font color="black">1530.         &quot;&quot;&quot;</font>
<font color="red">1531.         return getproxies_environment() or getproxies_registry()</font>
<font color="black">1532. </font>
<font color="red">1533.     def proxy_bypass_registry(host):</font>
<font color="red">1534.         try:</font>
<font color="red">1535.             import _winreg</font>
<font color="red">1536.             import re</font>
<font color="red">1537.         except ImportError:</font>
<font color="black">1538.             # Std modules, so should be around - but you never know!</font>
<font color="red">1539.             return 0</font>
<font color="red">1540.         try:</font>
<font color="red">1541.             internetSettings = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER,</font>
<font color="red">1542.                 r'Software\Microsoft\Windows\CurrentVersion\Internet Settings')</font>
<font color="red">1543.             proxyEnable = _winreg.QueryValueEx(internetSettings,</font>
<font color="red">1544.                                                'ProxyEnable')[0]</font>
<font color="red">1545.             proxyOverride = str(_winreg.QueryValueEx(internetSettings,</font>
<font color="red">1546.                                                      'ProxyOverride')[0])</font>
<font color="black">1547.             # ^^^^ Returned as Unicode but problems if not converted to ASCII</font>
<font color="red">1548.         except WindowsError:</font>
<font color="red">1549.             return 0</font>
<font color="red">1550.         if not proxyEnable or not proxyOverride:</font>
<font color="red">1551.             return 0</font>
<font color="black">1552.         # try to make a host list from name and IP address.</font>
<font color="red">1553.         rawHost, port = splitport(host)</font>
<font color="red">1554.         host = [rawHost]</font>
<font color="red">1555.         try:</font>
<font color="red">1556.             addr = socket.gethostbyname(rawHost)</font>
<font color="red">1557.             if addr != rawHost:</font>
<font color="red">1558.                 host.append(addr)</font>
<font color="red">1559.         except socket.error:</font>
<font color="red">1560.             pass</font>
<font color="red">1561.         try:</font>
<font color="red">1562.             fqdn = socket.getfqdn(rawHost)</font>
<font color="red">1563.             if fqdn != rawHost:</font>
<font color="red">1564.                 host.append(fqdn)</font>
<font color="red">1565.         except socket.error:</font>
<font color="red">1566.             pass</font>
<font color="black">1567.         # make a check value list from the registry entry: replace the</font>
<font color="black">1568.         # '&lt;local&gt;' string by the localhost entry and the corresponding</font>
<font color="black">1569.         # canonical entry.</font>
<font color="red">1570.         proxyOverride = proxyOverride.split(';')</font>
<font color="black">1571.         # now check if we match one of the registry values.</font>
<font color="red">1572.         for test in proxyOverride:</font>
<font color="red">1573.             if test == '&lt;local&gt;':</font>
<font color="red">1574.                 if '.' not in rawHost:</font>
<font color="red">1575.                     return 1</font>
<font color="red">1576.             test = test.replace(&quot;.&quot;, r&quot;\.&quot;)     # mask dots</font>
<font color="red">1577.             test = test.replace(&quot;*&quot;, r&quot;.*&quot;)     # change glob sequence</font>
<font color="red">1578.             test = test.replace(&quot;?&quot;, r&quot;.&quot;)      # change glob char</font>
<font color="red">1579.             for val in host:</font>
<font color="black">1580.                 # print &quot;%s &lt;--&gt; %s&quot; %( test, val )</font>
<font color="red">1581.                 if re.match(test, val, re.I):</font>
<font color="red">1582.                     return 1</font>
<font color="red">1583.         return 0</font>
<font color="black">1584. </font>
<font color="red">1585.     def proxy_bypass(host):</font>
<font color="black">1586.         &quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings.</font>
<font color="black">1587. </font>
<font color="black">1588.         Returns settings gathered from the environment, if specified,</font>
<font color="black">1589.         or the registry.</font>
<font color="black">1590. </font>
<font color="black">1591.         &quot;&quot;&quot;</font>
<font color="red">1592.         if getproxies_environment():</font>
<font color="red">1593.             return proxy_bypass_environment(host)</font>
<font color="black">1594.         else:</font>
<font color="red">1595.             return proxy_bypass_registry(host)</font>
<font color="black">1596. </font>
<font color="black">1597. else:</font>
<font color="black">1598.     # By default use environment variables</font>
<font color="green">1599.     getproxies = getproxies_environment</font>
<font color="green">1600.     proxy_bypass = proxy_bypass_environment</font>
<font color="black">1601. </font>
<font color="black">1602. # Test and time quote() and unquote()</font>
<font color="green">1603. def test1():</font>
<font color="red">1604.     s = ''</font>
<font color="red">1605.     for i in range(256): s = s + chr(i)</font>
<font color="red">1606.     s = s*4</font>
<font color="red">1607.     t0 = time.time()</font>
<font color="red">1608.     qs = quote(s)</font>
<font color="red">1609.     uqs = unquote(qs)</font>
<font color="red">1610.     t1 = time.time()</font>
<font color="red">1611.     if uqs != s:</font>
<font color="red">1612.         print 'Wrong!'</font>
<font color="red">1613.     print repr(s)</font>
<font color="red">1614.     print repr(qs)</font>
<font color="red">1615.     print repr(uqs)</font>
<font color="red">1616.     print round(t1 - t0, 3), 'sec'</font>
<font color="black">1617. </font>
<font color="black">1618. </font>
<font color="green">1619. def reporthook(blocknum, blocksize, totalsize):</font>
<font color="black">1620.     # Report during remote transfers</font>
<font color="red">1621.     print &quot;Block number: %d, Block size: %d, Total size: %d&quot; % (</font>
<font color="red">1622.         blocknum, blocksize, totalsize)</font>
</pre>

