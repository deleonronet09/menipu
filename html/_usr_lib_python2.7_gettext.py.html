source file: <b>/usr/lib/python2.7/gettext.py</b><br>


file stats: <b>391 lines, 147 executed: 37.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Internationalization and localization support.</font>
<font color="black">   2. </font>
<font color="black">   3. This module provides internationalization (I18N) and localization (L10N)</font>
<font color="black">   4. support for your Python programs by providing an interface to the GNU gettext</font>
<font color="black">   5. message catalog library.</font>
<font color="black">   6. </font>
<font color="black">   7. I18N refers to the operation by which a program is made aware of multiple</font>
<font color="black">   8. languages.  L10N refers to the adaptation of your program, once</font>
<font color="black">   9. internationalized, to the local language and cultural habits.</font>
<font color="black">  10. </font>
<font color="red">  11. &quot;&quot;&quot;</font>
<font color="black">  12. </font>
<font color="black">  13. # This module represents the integration of work, contributions, feedback, and</font>
<font color="black">  14. # suggestions from the following people:</font>
<font color="black">  15. #</font>
<font color="black">  16. # Martin von Loewis, who wrote the initial implementation of the underlying</font>
<font color="black">  17. # C-based libintlmodule (later renamed _gettext), along with a skeletal</font>
<font color="black">  18. # gettext.py implementation.</font>
<font color="black">  19. #</font>
<font color="black">  20. # Peter Funk, who wrote fintl.py, a fairly complete wrapper around intlmodule,</font>
<font color="black">  21. # which also included a pure-Python implementation to read .mo files if</font>
<font color="black">  22. # intlmodule wasn't available.</font>
<font color="black">  23. #</font>
<font color="black">  24. # James Henstridge, who also wrote a gettext.py module, which has some</font>
<font color="black">  25. # interesting, but currently unsupported experimental features: the notion of</font>
<font color="black">  26. # a Catalog class and instances, and the ability to add to a catalog file via</font>
<font color="black">  27. # a Python API.</font>
<font color="black">  28. #</font>
<font color="black">  29. # Barry Warsaw integrated these modules, wrote the .install() API and code,</font>
<font color="black">  30. # and conformed all C and Python code to Python's coding standards.</font>
<font color="black">  31. #</font>
<font color="black">  32. # Francois Pinard and Marc-Andre Lemburg also contributed valuably to this</font>
<font color="black">  33. # module.</font>
<font color="black">  34. #</font>
<font color="black">  35. # J. David Ibanez implemented plural forms. Bruno Haible fixed some bugs.</font>
<font color="black">  36. #</font>
<font color="black">  37. # TODO:</font>
<font color="black">  38. # - Lazy loading of .mo files.  Currently the entire catalog is loaded into</font>
<font color="black">  39. #   memory, but that's probably bad for large translated programs.  Instead,</font>
<font color="black">  40. #   the lexical sort of original strings in GNU .mo files should be exploited</font>
<font color="black">  41. #   to do binary searches and lazy initializations.  Or you might want to use</font>
<font color="black">  42. #   the undocumented double-hash algorithm for .mo files with hash tables, but</font>
<font color="black">  43. #   you'll need to study the GNU gettext code to do this.</font>
<font color="black">  44. #</font>
<font color="black">  45. # - Support Solaris .mo file formats.  Unfortunately, we've been unable to</font>
<font color="black">  46. #   find this format documented anywhere.</font>
<font color="black">  47. </font>
<font color="black">  48. </font>
<font color="red">  49. import locale, copy, os, re, struct, sys</font>
<font color="red">  50. from errno import ENOENT</font>
<font color="black">  51. </font>
<font color="black">  52. </font>
<font color="red">  53. __all__ = ['NullTranslations', 'GNUTranslations', 'Catalog',</font>
<font color="red">  54.            'find', 'translation', 'install', 'textdomain', 'bindtextdomain',</font>
<font color="red">  55.            'dgettext', 'dngettext', 'gettext', 'ngettext',</font>
<font color="black">  56.            ]</font>
<font color="black">  57. </font>
<font color="red">  58. _default_localedir = os.path.join(sys.prefix, 'share', 'locale')</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="red">  61. def test(condition, true, false):</font>
<font color="black">  62.     &quot;&quot;&quot;</font>
<font color="black">  63.     Implements the C expression:</font>
<font color="black">  64. </font>
<font color="black">  65.       condition ? true : false</font>
<font color="black">  66. </font>
<font color="black">  67.     Required to correctly interpret plural forms.</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="red">  69.     if condition:</font>
<font color="red">  70.         return true</font>
<font color="black">  71.     else:</font>
<font color="red">  72.         return false</font>
<font color="black">  73. </font>
<font color="black">  74. </font>
<font color="red">  75. def c2py(plural):</font>
<font color="black">  76.     &quot;&quot;&quot;Gets a C expression as used in PO files for plural forms and returns a</font>
<font color="black">  77.     Python lambda function that implements an equivalent expression.</font>
<font color="black">  78.     &quot;&quot;&quot;</font>
<font color="black">  79.     # Security check, allow only the &quot;n&quot; identifier</font>
<font color="red">  80.     try:</font>
<font color="red">  81.         from cStringIO import StringIO</font>
<font color="red">  82.     except ImportError:</font>
<font color="red">  83.         from StringIO import StringIO</font>
<font color="red">  84.     import token, tokenize</font>
<font color="red">  85.     tokens = tokenize.generate_tokens(StringIO(plural).readline)</font>
<font color="red">  86.     try:</font>
<font color="red">  87.         danger = [x for x in tokens if x[0] == token.NAME and x[1] != 'n']</font>
<font color="red">  88.     except tokenize.TokenError:</font>
<font color="red">  89.         raise ValueError, \</font>
<font color="red">  90.               'plural forms expression error, maybe unbalanced parenthesis'</font>
<font color="black">  91.     else:</font>
<font color="red">  92.         if danger:</font>
<font color="red">  93.             raise ValueError, 'plural forms expression could be dangerous'</font>
<font color="black">  94. </font>
<font color="black">  95.     # Replace some C operators by their Python equivalents</font>
<font color="red">  96.     plural = plural.replace('&amp;&amp;', ' and ')</font>
<font color="red">  97.     plural = plural.replace('||', ' or ')</font>
<font color="black">  98. </font>
<font color="red">  99.     expr = re.compile(r'\!([^=])')</font>
<font color="red"> 100.     plural = expr.sub(' not \\1', plural)</font>
<font color="black"> 101. </font>
<font color="black"> 102.     # Regular expression and replacement function used to transform</font>
<font color="black"> 103.     # &quot;a?b:c&quot; to &quot;test(a,b,c)&quot;.</font>
<font color="red"> 104.     expr = re.compile(r'(.*?)\?(.*?):(.*)')</font>
<font color="red"> 105.     def repl(x):</font>
<font color="red"> 106.         return &quot;test(%s, %s, %s)&quot; % (x.group(1), x.group(2),</font>
<font color="red"> 107.                                      expr.sub(repl, x.group(3)))</font>
<font color="black"> 108. </font>
<font color="black"> 109.     # Code to transform the plural expression, taking care of parentheses</font>
<font color="red"> 110.     stack = ['']</font>
<font color="red"> 111.     for c in plural:</font>
<font color="red"> 112.         if c == '(':</font>
<font color="red"> 113.             stack.append('')</font>
<font color="red"> 114.         elif c == ')':</font>
<font color="red"> 115.             if len(stack) == 1:</font>
<font color="black"> 116.                 # Actually, we never reach this code, because unbalanced</font>
<font color="black"> 117.                 # parentheses get caught in the security check at the</font>
<font color="black"> 118.                 # beginning.</font>
<font color="red"> 119.                 raise ValueError, 'unbalanced parenthesis in plural form'</font>
<font color="red"> 120.             s = expr.sub(repl, stack.pop())</font>
<font color="red"> 121.             stack[-1] += '(%s)' % s</font>
<font color="black"> 122.         else:</font>
<font color="red"> 123.             stack[-1] += c</font>
<font color="red"> 124.     plural = expr.sub(repl, stack.pop())</font>
<font color="black"> 125. </font>
<font color="red"> 126.     return eval('lambda n: int(%s)' % plural)</font>
<font color="black"> 127. </font>
<font color="black"> 128. </font>
<font color="black"> 129. </font>
<font color="red"> 130. def _expand_lang(locale):</font>
<font color="green"> 131.     from locale import normalize</font>
<font color="green"> 132.     locale = normalize(locale)</font>
<font color="green"> 133.     COMPONENT_CODESET   = 1 &lt;&lt; 0</font>
<font color="green"> 134.     COMPONENT_TERRITORY = 1 &lt;&lt; 1</font>
<font color="green"> 135.     COMPONENT_MODIFIER  = 1 &lt;&lt; 2</font>
<font color="black"> 136.     # split up the locale into its base components</font>
<font color="green"> 137.     mask = 0</font>
<font color="green"> 138.     pos = locale.find('@')</font>
<font color="green"> 139.     if pos &gt;= 0:</font>
<font color="red"> 140.         modifier = locale[pos:]</font>
<font color="red"> 141.         locale = locale[:pos]</font>
<font color="red"> 142.         mask |= COMPONENT_MODIFIER</font>
<font color="black"> 143.     else:</font>
<font color="green"> 144.         modifier = ''</font>
<font color="green"> 145.     pos = locale.find('.')</font>
<font color="green"> 146.     if pos &gt;= 0:</font>
<font color="green"> 147.         codeset = locale[pos:]</font>
<font color="green"> 148.         locale = locale[:pos]</font>
<font color="green"> 149.         mask |= COMPONENT_CODESET</font>
<font color="black"> 150.     else:</font>
<font color="green"> 151.         codeset = ''</font>
<font color="green"> 152.     pos = locale.find('_')</font>
<font color="green"> 153.     if pos &gt;= 0:</font>
<font color="green"> 154.         territory = locale[pos:]</font>
<font color="green"> 155.         locale = locale[:pos]</font>
<font color="green"> 156.         mask |= COMPONENT_TERRITORY</font>
<font color="black"> 157.     else:</font>
<font color="green"> 158.         territory = ''</font>
<font color="green"> 159.     language = locale</font>
<font color="green"> 160.     ret = []</font>
<font color="green"> 161.     for i in range(mask+1):</font>
<font color="green"> 162.         if not (i &amp; ~mask):  # if all components for this combo exist ...</font>
<font color="green"> 163.             val = language</font>
<font color="green"> 164.             if i &amp; COMPONENT_TERRITORY: val += territory</font>
<font color="green"> 165.             if i &amp; COMPONENT_CODESET:   val += codeset</font>
<font color="green"> 166.             if i &amp; COMPONENT_MODIFIER:  val += modifier</font>
<font color="green"> 167.             ret.append(val)</font>
<font color="green"> 168.     ret.reverse()</font>
<font color="green"> 169.     return ret</font>
<font color="black"> 170. </font>
<font color="black"> 171. </font>
<font color="black"> 172. </font>
<font color="red"> 173. class NullTranslations:</font>
<font color="red"> 174.     def __init__(self, fp=None):</font>
<font color="green"> 175.         self._info = {}</font>
<font color="green"> 176.         self._charset = None</font>
<font color="green"> 177.         self._output_charset = None</font>
<font color="green"> 178.         self._fallback = None</font>
<font color="green"> 179.         if fp is not None:</font>
<font color="green"> 180.             self._parse(fp)</font>
<font color="black"> 181. </font>
<font color="red"> 182.     def _parse(self, fp):</font>
<font color="red"> 183.         pass</font>
<font color="black"> 184. </font>
<font color="red"> 185.     def add_fallback(self, fallback):</font>
<font color="red"> 186.         if self._fallback:</font>
<font color="red"> 187.             self._fallback.add_fallback(fallback)</font>
<font color="black"> 188.         else:</font>
<font color="red"> 189.             self._fallback = fallback</font>
<font color="black"> 190. </font>
<font color="red"> 191.     def gettext(self, message):</font>
<font color="red"> 192.         if self._fallback:</font>
<font color="red"> 193.             return self._fallback.gettext(message)</font>
<font color="red"> 194.         return message</font>
<font color="black"> 195. </font>
<font color="red"> 196.     def lgettext(self, message):</font>
<font color="red"> 197.         if self._fallback:</font>
<font color="red"> 198.             return self._fallback.lgettext(message)</font>
<font color="red"> 199.         return message</font>
<font color="black"> 200. </font>
<font color="red"> 201.     def ngettext(self, msgid1, msgid2, n):</font>
<font color="red"> 202.         if self._fallback:</font>
<font color="red"> 203.             return self._fallback.ngettext(msgid1, msgid2, n)</font>
<font color="red"> 204.         if n == 1:</font>
<font color="red"> 205.             return msgid1</font>
<font color="black"> 206.         else:</font>
<font color="red"> 207.             return msgid2</font>
<font color="black"> 208. </font>
<font color="red"> 209.     def lngettext(self, msgid1, msgid2, n):</font>
<font color="red"> 210.         if self._fallback:</font>
<font color="red"> 211.             return self._fallback.lngettext(msgid1, msgid2, n)</font>
<font color="red"> 212.         if n == 1:</font>
<font color="red"> 213.             return msgid1</font>
<font color="black"> 214.         else:</font>
<font color="red"> 215.             return msgid2</font>
<font color="black"> 216. </font>
<font color="red"> 217.     def ugettext(self, message):</font>
<font color="green"> 218.         if self._fallback:</font>
<font color="red"> 219.             return self._fallback.ugettext(message)</font>
<font color="green"> 220.         return unicode(message)</font>
<font color="black"> 221. </font>
<font color="red"> 222.     def ungettext(self, msgid1, msgid2, n):</font>
<font color="red"> 223.         if self._fallback:</font>
<font color="red"> 224.             return self._fallback.ungettext(msgid1, msgid2, n)</font>
<font color="red"> 225.         if n == 1:</font>
<font color="red"> 226.             return unicode(msgid1)</font>
<font color="black"> 227.         else:</font>
<font color="red"> 228.             return unicode(msgid2)</font>
<font color="black"> 229. </font>
<font color="red"> 230.     def info(self):</font>
<font color="red"> 231.         return self._info</font>
<font color="black"> 232. </font>
<font color="red"> 233.     def charset(self):</font>
<font color="red"> 234.         return self._charset</font>
<font color="black"> 235. </font>
<font color="red"> 236.     def output_charset(self):</font>
<font color="red"> 237.         return self._output_charset</font>
<font color="black"> 238. </font>
<font color="red"> 239.     def set_output_charset(self, charset):</font>
<font color="green"> 240.         self._output_charset = charset</font>
<font color="black"> 241. </font>
<font color="red"> 242.     def install(self, unicode=False, names=None):</font>
<font color="red"> 243.         import __builtin__</font>
<font color="red"> 244.         __builtin__.__dict__['_'] = unicode and self.ugettext or self.gettext</font>
<font color="red"> 245.         if hasattr(names, &quot;__contains__&quot;):</font>
<font color="red"> 246.             if &quot;gettext&quot; in names:</font>
<font color="red"> 247.                 __builtin__.__dict__['gettext'] = __builtin__.__dict__['_']</font>
<font color="red"> 248.             if &quot;ngettext&quot; in names:</font>
<font color="red"> 249.                 __builtin__.__dict__['ngettext'] = (unicode and self.ungettext</font>
<font color="red"> 250.                                                              or self.ngettext)</font>
<font color="red"> 251.             if &quot;lgettext&quot; in names:</font>
<font color="red"> 252.                 __builtin__.__dict__['lgettext'] = self.lgettext</font>
<font color="red"> 253.             if &quot;lngettext&quot; in names:</font>
<font color="red"> 254.                 __builtin__.__dict__['lngettext'] = self.lngettext</font>
<font color="black"> 255. </font>
<font color="black"> 256. </font>
<font color="red"> 257. class GNUTranslations(NullTranslations):</font>
<font color="black"> 258.     # Magic number of .mo files</font>
<font color="red"> 259.     LE_MAGIC = 0x950412deL</font>
<font color="red"> 260.     BE_MAGIC = 0xde120495L</font>
<font color="black"> 261. </font>
<font color="red"> 262.     def _parse(self, fp):</font>
<font color="black"> 263.         &quot;&quot;&quot;Override this method to support alternative .mo formats.&quot;&quot;&quot;</font>
<font color="green"> 264.         unpack = struct.unpack</font>
<font color="green"> 265.         filename = getattr(fp, 'name', '')</font>
<font color="black"> 266.         # Parse the .mo file header, which consists of 5 little endian 32</font>
<font color="black"> 267.         # bit words.</font>
<font color="green"> 268.         self._catalog = catalog = {}</font>
<font color="green"> 269.         self.plural = lambda n: int(n != 1) # germanic plural by default</font>
<font color="green"> 270.         buf = fp.read()</font>
<font color="green"> 271.         buflen = len(buf)</font>
<font color="black"> 272.         # Are we big endian or little endian?</font>
<font color="green"> 273.         magic = unpack('&lt;I', buf[:4])[0]</font>
<font color="green"> 274.         if magic == self.LE_MAGIC:</font>
<font color="green"> 275.             version, msgcount, masteridx, transidx = unpack('&lt;4I', buf[4:20])</font>
<font color="green"> 276.             ii = '&lt;II'</font>
<font color="red"> 277.         elif magic == self.BE_MAGIC:</font>
<font color="red"> 278.             version, msgcount, masteridx, transidx = unpack('&gt;4I', buf[4:20])</font>
<font color="red"> 279.             ii = '&gt;II'</font>
<font color="black"> 280.         else:</font>
<font color="red"> 281.             raise IOError(0, 'Bad magic number', filename)</font>
<font color="black"> 282.         # Now put all messages from the .mo file buffer into the catalog</font>
<font color="black"> 283.         # dictionary.</font>
<font color="green"> 284.         for i in xrange(0, msgcount):</font>
<font color="green"> 285.             mlen, moff = unpack(ii, buf[masteridx:masteridx+8])</font>
<font color="green"> 286.             mend = moff + mlen</font>
<font color="green"> 287.             tlen, toff = unpack(ii, buf[transidx:transidx+8])</font>
<font color="green"> 288.             tend = toff + tlen</font>
<font color="green"> 289.             if mend &lt; buflen and tend &lt; buflen:</font>
<font color="green"> 290.                 msg = buf[moff:mend]</font>
<font color="green"> 291.                 tmsg = buf[toff:tend]</font>
<font color="black"> 292.             else:</font>
<font color="red"> 293.                 raise IOError(0, 'File is corrupt', filename)</font>
<font color="black"> 294.             # See if we're looking at GNU .mo conventions for metadata</font>
<font color="green"> 295.             if mlen == 0:</font>
<font color="black"> 296.                 # Catalog description</font>
<font color="green"> 297.                 lastk = k = None</font>
<font color="green"> 298.                 for item in tmsg.splitlines():</font>
<font color="green"> 299.                     item = item.strip()</font>
<font color="green"> 300.                     if not item:</font>
<font color="red"> 301.                         continue</font>
<font color="green"> 302.                     if ':' in item:</font>
<font color="green"> 303.                         k, v = item.split(':', 1)</font>
<font color="green"> 304.                         k = k.strip().lower()</font>
<font color="green"> 305.                         v = v.strip()</font>
<font color="green"> 306.                         self._info[k] = v</font>
<font color="green"> 307.                         lastk = k</font>
<font color="red"> 308.                     elif lastk:</font>
<font color="red"> 309.                         self._info[lastk] += '\n' + item</font>
<font color="green"> 310.                     if k == 'content-type':</font>
<font color="green"> 311.                         self._charset = v.split('charset=')[1]</font>
<font color="green"> 312.                     elif k == 'plural-forms':</font>
<font color="red"> 313.                         v = v.split(';')</font>
<font color="red"> 314.                         plural = v[1].split('plural=')[1]</font>
<font color="red"> 315.                         self.plural = c2py(plural)</font>
<font color="black"> 316.             # Note: we unconditionally convert both msgids and msgstrs to</font>
<font color="black"> 317.             # Unicode using the character encoding specified in the charset</font>
<font color="black"> 318.             # parameter of the Content-Type header.  The gettext documentation</font>
<font color="black"> 319.             # strongly encourages msgids to be us-ascii, but some applications</font>
<font color="black"> 320.             # require alternative encodings (e.g. Zope's ZCML and ZPT).  For</font>
<font color="black"> 321.             # traditional gettext applications, the msgid conversion will</font>
<font color="black"> 322.             # cause no problems since us-ascii should always be a subset of</font>
<font color="black"> 323.             # the charset encoding.  We may want to fall back to 8-bit msgids</font>
<font color="black"> 324.             # if the Unicode conversion fails.</font>
<font color="green"> 325.             if '\x00' in msg:</font>
<font color="black"> 326.                 # Plural forms</font>
<font color="red"> 327.                 msgid1, msgid2 = msg.split('\x00')</font>
<font color="red"> 328.                 tmsg = tmsg.split('\x00')</font>
<font color="red"> 329.                 if self._charset:</font>
<font color="red"> 330.                     msgid1 = unicode(msgid1, self._charset)</font>
<font color="red"> 331.                     tmsg = [unicode(x, self._charset) for x in tmsg]</font>
<font color="red"> 332.                 for i in range(len(tmsg)):</font>
<font color="red"> 333.                     catalog[(msgid1, i)] = tmsg[i]</font>
<font color="black"> 334.             else:</font>
<font color="green"> 335.                 if self._charset:</font>
<font color="green"> 336.                     msg = unicode(msg, self._charset)</font>
<font color="green"> 337.                     tmsg = unicode(tmsg, self._charset)</font>
<font color="green"> 338.                 catalog[msg] = tmsg</font>
<font color="black"> 339.             # advance to next entry in the seek tables</font>
<font color="green"> 340.             masteridx += 8</font>
<font color="green"> 341.             transidx += 8</font>
<font color="black"> 342. </font>
<font color="red"> 343.     def gettext(self, message):</font>
<font color="red"> 344.         missing = object()</font>
<font color="red"> 345.         tmsg = self._catalog.get(message, missing)</font>
<font color="red"> 346.         if tmsg is missing:</font>
<font color="red"> 347.             if self._fallback:</font>
<font color="red"> 348.                 return self._fallback.gettext(message)</font>
<font color="red"> 349.             return message</font>
<font color="black"> 350.         # Encode the Unicode tmsg back to an 8-bit string, if possible</font>
<font color="red"> 351.         if self._output_charset:</font>
<font color="red"> 352.             return tmsg.encode(self._output_charset)</font>
<font color="red"> 353.         elif self._charset:</font>
<font color="red"> 354.             return tmsg.encode(self._charset)</font>
<font color="red"> 355.         return tmsg</font>
<font color="black"> 356. </font>
<font color="red"> 357.     def lgettext(self, message):</font>
<font color="red"> 358.         missing = object()</font>
<font color="red"> 359.         tmsg = self._catalog.get(message, missing)</font>
<font color="red"> 360.         if tmsg is missing:</font>
<font color="red"> 361.             if self._fallback:</font>
<font color="red"> 362.                 return self._fallback.lgettext(message)</font>
<font color="red"> 363.             return message</font>
<font color="red"> 364.         if self._output_charset:</font>
<font color="red"> 365.             return tmsg.encode(self._output_charset)</font>
<font color="red"> 366.         return tmsg.encode(locale.getpreferredencoding())</font>
<font color="black"> 367. </font>
<font color="red"> 368.     def ngettext(self, msgid1, msgid2, n):</font>
<font color="red"> 369.         try:</font>
<font color="red"> 370.             tmsg = self._catalog[(msgid1, self.plural(n))]</font>
<font color="red"> 371.             if self._output_charset:</font>
<font color="red"> 372.                 return tmsg.encode(self._output_charset)</font>
<font color="red"> 373.             elif self._charset:</font>
<font color="red"> 374.                 return tmsg.encode(self._charset)</font>
<font color="red"> 375.             return tmsg</font>
<font color="red"> 376.         except KeyError:</font>
<font color="red"> 377.             if self._fallback:</font>
<font color="red"> 378.                 return self._fallback.ngettext(msgid1, msgid2, n)</font>
<font color="red"> 379.             if n == 1:</font>
<font color="red"> 380.                 return msgid1</font>
<font color="black"> 381.             else:</font>
<font color="red"> 382.                 return msgid2</font>
<font color="black"> 383. </font>
<font color="red"> 384.     def lngettext(self, msgid1, msgid2, n):</font>
<font color="red"> 385.         try:</font>
<font color="red"> 386.             tmsg = self._catalog[(msgid1, self.plural(n))]</font>
<font color="red"> 387.             if self._output_charset:</font>
<font color="red"> 388.                 return tmsg.encode(self._output_charset)</font>
<font color="red"> 389.             return tmsg.encode(locale.getpreferredencoding())</font>
<font color="red"> 390.         except KeyError:</font>
<font color="red"> 391.             if self._fallback:</font>
<font color="red"> 392.                 return self._fallback.lngettext(msgid1, msgid2, n)</font>
<font color="red"> 393.             if n == 1:</font>
<font color="red"> 394.                 return msgid1</font>
<font color="black"> 395.             else:</font>
<font color="red"> 396.                 return msgid2</font>
<font color="black"> 397. </font>
<font color="red"> 398.     def ugettext(self, message):</font>
<font color="green"> 399.         missing = object()</font>
<font color="green"> 400.         tmsg = self._catalog.get(message, missing)</font>
<font color="green"> 401.         if tmsg is missing:</font>
<font color="green"> 402.             if self._fallback:</font>
<font color="red"> 403.                 return self._fallback.ugettext(message)</font>
<font color="green"> 404.             return unicode(message)</font>
<font color="red"> 405.         return tmsg</font>
<font color="black"> 406. </font>
<font color="red"> 407.     def ungettext(self, msgid1, msgid2, n):</font>
<font color="green"> 408.         try:</font>
<font color="green"> 409.             tmsg = self._catalog[(msgid1, self.plural(n))]</font>
<font color="green"> 410.         except KeyError:</font>
<font color="green"> 411.             if self._fallback:</font>
<font color="red"> 412.                 return self._fallback.ungettext(msgid1, msgid2, n)</font>
<font color="green"> 413.             if n == 1:</font>
<font color="red"> 414.                 tmsg = unicode(msgid1)</font>
<font color="black"> 415.             else:</font>
<font color="green"> 416.                 tmsg = unicode(msgid2)</font>
<font color="green"> 417.         return tmsg</font>
<font color="black"> 418. </font>
<font color="black"> 419. </font>
<font color="black"> 420. # Locate a .mo file using the gettext strategy</font>
<font color="red"> 421. def find(domain, localedir=None, languages=None, all=0):</font>
<font color="black"> 422.     # Get some reasonable defaults for arguments that were not supplied</font>
<font color="green"> 423.     if localedir is None:</font>
<font color="green"> 424.         localedir = _default_localedir</font>
<font color="green"> 425.     if languages is None:</font>
<font color="green"> 426.         languages = []</font>
<font color="green"> 427.         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):</font>
<font color="green"> 428.             val = os.environ.get(envar)</font>
<font color="green"> 429.             if val:</font>
<font color="green"> 430.                 languages = val.split(':')</font>
<font color="green"> 431.                 break</font>
<font color="green"> 432.         if 'C' not in languages:</font>
<font color="green"> 433.             languages.append('C')</font>
<font color="black"> 434.     # now normalize and expand the languages</font>
<font color="green"> 435.     nelangs = []</font>
<font color="green"> 436.     for lang in languages:</font>
<font color="green"> 437.         for nelang in _expand_lang(lang):</font>
<font color="green"> 438.             if nelang not in nelangs:</font>
<font color="green"> 439.                 nelangs.append(nelang)</font>
<font color="black"> 440.     # select a language</font>
<font color="green"> 441.     if all:</font>
<font color="green"> 442.         result = []</font>
<font color="black"> 443.     else:</font>
<font color="red"> 444.         result = None</font>
<font color="green"> 445.     for lang in nelangs:</font>
<font color="green"> 446.         if lang == 'C':</font>
<font color="green"> 447.             break</font>
<font color="green"> 448.         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)</font>
<font color="green"> 449.         mofile_lp = os.path.join(&quot;/usr/share/locale-langpack&quot;, lang,</font>
<font color="green"> 450.                                'LC_MESSAGES', '%s.mo' % domain)</font>
<font color="black"> 451. </font>
<font color="black"> 452. 	# first look into the standard locale dir, then into the</font>
<font color="black"> 453. 	# langpack locale dir</font>
<font color="black"> 454. </font>
<font color="black"> 455. 	# standard mo file</font>
<font color="green"> 456.         if os.path.exists(mofile):</font>
<font color="green"> 457.             if all:</font>
<font color="green"> 458.                 result.append(mofile)</font>
<font color="black"> 459.             else:</font>
<font color="red"> 460.                 return mofile</font>
<font color="black"> 461. </font>
<font color="black"> 462. 	# langpack mofile -&gt; use it</font>
<font color="green"> 463.         if os.path.exists(mofile_lp):</font>
<font color="red"> 464.             if all:</font>
<font color="red"> 465.                 result.append(mofile_lp)</font>
<font color="black"> 466.             else:</font>
<font color="red"> 467.                 return mofile_lp</font>
<font color="black"> 468. </font>
<font color="green"> 469.     return result</font>
<font color="black"> 470. </font>
<font color="black"> 471. </font>
<font color="black"> 472. </font>
<font color="black"> 473. # a mapping between absolute .mo file path and Translation object</font>
<font color="red"> 474. _translations = {}</font>
<font color="black"> 475. </font>
<font color="red"> 476. def translation(domain, localedir=None, languages=None,</font>
<font color="red"> 477.                 class_=None, fallback=False, codeset=None):</font>
<font color="green"> 478.     if class_ is None:</font>
<font color="green"> 479.         class_ = GNUTranslations</font>
<font color="green"> 480.     mofiles = find(domain, localedir, languages, all=1)</font>
<font color="green"> 481.     if not mofiles:</font>
<font color="green"> 482.         if fallback:</font>
<font color="green"> 483.             return NullTranslations()</font>
<font color="green"> 484.         raise IOError(ENOENT, 'No translation file found for domain', domain)</font>
<font color="black"> 485.     # Avoid opening, reading, and parsing the .mo file after it's been done</font>
<font color="black"> 486.     # once.</font>
<font color="green"> 487.     result = None</font>
<font color="green"> 488.     for mofile in mofiles:</font>
<font color="green"> 489.         key = (class_, os.path.abspath(mofile))</font>
<font color="green"> 490.         t = _translations.get(key)</font>
<font color="green"> 491.         if t is None:</font>
<font color="green"> 492.             with open(mofile, 'rb') as fp:</font>
<font color="green"> 493.                 t = _translations.setdefault(key, class_(fp))</font>
<font color="black"> 494.         # Copy the translation object to allow setting fallbacks and</font>
<font color="black"> 495.         # output charset. All other instance data is shared with the</font>
<font color="black"> 496.         # cached object.</font>
<font color="green"> 497.         t = copy.copy(t)</font>
<font color="green"> 498.         if codeset:</font>
<font color="green"> 499.             t.set_output_charset(codeset)</font>
<font color="green"> 500.         if result is None:</font>
<font color="green"> 501.             result = t</font>
<font color="black"> 502.         else:</font>
<font color="red"> 503.             result.add_fallback(t)</font>
<font color="green"> 504.     return result</font>
<font color="black"> 505. </font>
<font color="black"> 506. </font>
<font color="red"> 507. def install(domain, localedir=None, unicode=False, codeset=None, names=None):</font>
<font color="red"> 508.     t = translation(domain, localedir, fallback=True, codeset=codeset)</font>
<font color="red"> 509.     t.install(unicode, names)</font>
<font color="black"> 510. </font>
<font color="black"> 511. </font>
<font color="black"> 512. </font>
<font color="black"> 513. # a mapping b/w domains and locale directories</font>
<font color="red"> 514. _localedirs = {}</font>
<font color="black"> 515. # a mapping b/w domains and codesets</font>
<font color="red"> 516. _localecodesets = {}</font>
<font color="black"> 517. # current global domain, `messages' used for compatibility w/ GNU gettext</font>
<font color="red"> 518. _current_domain = 'messages'</font>
<font color="black"> 519. </font>
<font color="black"> 520. </font>
<font color="red"> 521. def textdomain(domain=None):</font>
<font color="black"> 522.     global _current_domain</font>
<font color="red"> 523.     if domain is not None:</font>
<font color="red"> 524.         _current_domain = domain</font>
<font color="red"> 525.     return _current_domain</font>
<font color="black"> 526. </font>
<font color="black"> 527. </font>
<font color="red"> 528. def bindtextdomain(domain, localedir=None):</font>
<font color="black"> 529.     global _localedirs</font>
<font color="red"> 530.     if localedir is not None:</font>
<font color="red"> 531.         _localedirs[domain] = localedir</font>
<font color="red"> 532.     return _localedirs.get(domain, _default_localedir)</font>
<font color="black"> 533. </font>
<font color="black"> 534. </font>
<font color="red"> 535. def bind_textdomain_codeset(domain, codeset=None):</font>
<font color="black"> 536.     global _localecodesets</font>
<font color="red"> 537.     if codeset is not None:</font>
<font color="red"> 538.         _localecodesets[domain] = codeset</font>
<font color="red"> 539.     return _localecodesets.get(domain)</font>
<font color="black"> 540. </font>
<font color="black"> 541. </font>
<font color="red"> 542. def dgettext(domain, message):</font>
<font color="green"> 543.     try:</font>
<font color="green"> 544.         t = translation(domain, _localedirs.get(domain, None),</font>
<font color="green"> 545.                         codeset=_localecodesets.get(domain))</font>
<font color="green"> 546.     except IOError:</font>
<font color="green"> 547.         return message</font>
<font color="red"> 548.     return t.gettext(message)</font>
<font color="black"> 549. </font>
<font color="red"> 550. def ldgettext(domain, message):</font>
<font color="red"> 551.     try:</font>
<font color="red"> 552.         t = translation(domain, _localedirs.get(domain, None),</font>
<font color="red"> 553.                         codeset=_localecodesets.get(domain))</font>
<font color="red"> 554.     except IOError:</font>
<font color="red"> 555.         return message</font>
<font color="red"> 556.     return t.lgettext(message)</font>
<font color="black"> 557. </font>
<font color="red"> 558. def dngettext(domain, msgid1, msgid2, n):</font>
<font color="red"> 559.     try:</font>
<font color="red"> 560.         t = translation(domain, _localedirs.get(domain, None),</font>
<font color="red"> 561.                         codeset=_localecodesets.get(domain))</font>
<font color="red"> 562.     except IOError:</font>
<font color="red"> 563.         if n == 1:</font>
<font color="red"> 564.             return msgid1</font>
<font color="black"> 565.         else:</font>
<font color="red"> 566.             return msgid2</font>
<font color="red"> 567.     return t.ngettext(msgid1, msgid2, n)</font>
<font color="black"> 568. </font>
<font color="red"> 569. def ldngettext(domain, msgid1, msgid2, n):</font>
<font color="red"> 570.     try:</font>
<font color="red"> 571.         t = translation(domain, _localedirs.get(domain, None),</font>
<font color="red"> 572.                         codeset=_localecodesets.get(domain))</font>
<font color="red"> 573.     except IOError:</font>
<font color="red"> 574.         if n == 1:</font>
<font color="red"> 575.             return msgid1</font>
<font color="black"> 576.         else:</font>
<font color="red"> 577.             return msgid2</font>
<font color="red"> 578.     return t.lngettext(msgid1, msgid2, n)</font>
<font color="black"> 579. </font>
<font color="red"> 580. def gettext(message):</font>
<font color="green"> 581.     return dgettext(_current_domain, message)</font>
<font color="black"> 582. </font>
<font color="red"> 583. def lgettext(message):</font>
<font color="red"> 584.     return ldgettext(_current_domain, message)</font>
<font color="black"> 585. </font>
<font color="red"> 586. def ngettext(msgid1, msgid2, n):</font>
<font color="red"> 587.     return dngettext(_current_domain, msgid1, msgid2, n)</font>
<font color="black"> 588. </font>
<font color="red"> 589. def lngettext(msgid1, msgid2, n):</font>
<font color="red"> 590.     return ldngettext(_current_domain, msgid1, msgid2, n)</font>
<font color="black"> 591. </font>
<font color="black"> 592. # dcgettext() has been deemed unnecessary and is not implemented.</font>
<font color="black"> 593. </font>
<font color="black"> 594. # James Henstridge's Catalog constructor from GNOME gettext.  Documented usage</font>
<font color="black"> 595. # was:</font>
<font color="black"> 596. #</font>
<font color="black"> 597. #    import gettext</font>
<font color="black"> 598. #    cat = gettext.Catalog(PACKAGE, localedir=LOCALEDIR)</font>
<font color="black"> 599. #    _ = cat.gettext</font>
<font color="black"> 600. #    print _('Hello World')</font>
<font color="black"> 601. </font>
<font color="black"> 602. # The resulting catalog object currently don't support access through a</font>
<font color="black"> 603. # dictionary API, which was supported (but apparently unused) in GNOME</font>
<font color="black"> 604. # gettext.</font>
<font color="black"> 605. </font>
<font color="red"> 606. Catalog = translation</font>
</pre>

