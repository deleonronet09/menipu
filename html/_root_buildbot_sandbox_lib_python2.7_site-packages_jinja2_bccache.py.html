source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/bccache.py</b><br>


file stats: <b>171 lines, 49 executed: 28.7% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.bccache</font>
<font color="black">   4.     ~~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     This module implements the bytecode cache system Jinja is optionally</font>
<font color="black">   7.     using.  This is useful if you have very complex template situations and</font>
<font color="black">   8.     the compiliation of all those templates slow down your application too</font>
<font color="black">   9.     much.</font>
<font color="black">  10. </font>
<font color="black">  11.     Situations where this is useful are often forking web applications that</font>
<font color="black">  12.     are initialized on the first request.</font>
<font color="black">  13. </font>
<font color="black">  14.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">  15.     :license: BSD.</font>
<font color="green">  16. &quot;&quot;&quot;</font>
<font color="green">  17. from os import path, listdir</font>
<font color="green">  18. import os</font>
<font color="green">  19. import sys</font>
<font color="green">  20. import stat</font>
<font color="green">  21. import errno</font>
<font color="green">  22. import marshal</font>
<font color="green">  23. import tempfile</font>
<font color="green">  24. import fnmatch</font>
<font color="green">  25. from hashlib import sha1</font>
<font color="green">  26. from jinja2.utils import open_if_exists</font>
<font color="green">  27. from jinja2._compat import BytesIO, pickle, PY2, text_type</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="black">  30. # marshal works better on 3.x, one hack less required</font>
<font color="green">  31. if not PY2:</font>
<font color="red">  32.     marshal_dump = marshal.dump</font>
<font color="red">  33.     marshal_load = marshal.load</font>
<font color="black">  34. else:</font>
<font color="black">  35. </font>
<font color="green">  36.     def marshal_dump(code, f):</font>
<font color="red">  37.         if isinstance(f, file):</font>
<font color="red">  38.             marshal.dump(code, f)</font>
<font color="black">  39.         else:</font>
<font color="red">  40.             f.write(marshal.dumps(code))</font>
<font color="black">  41. </font>
<font color="green">  42.     def marshal_load(f):</font>
<font color="red">  43.         if isinstance(f, file):</font>
<font color="red">  44.             return marshal.load(f)</font>
<font color="red">  45.         return marshal.loads(f.read())</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. bc_version = 2</font>
<font color="black">  49. </font>
<font color="black">  50. # magic version used to only change with new jinja versions.  With 2.6</font>
<font color="black">  51. # we change this to also take Python version changes into account.  The</font>
<font color="black">  52. # reason for this is that Python tends to segfault if fed earlier bytecode</font>
<font color="black">  53. # versions because someone thought it would be a good idea to reuse opcodes</font>
<font color="black">  54. # or make Python incompatible with earlier versions.</font>
<font color="black">  55. bc_magic = 'j2'.encode('ascii') + \</font>
<font color="green">  56.     pickle.dumps(bc_version, 2) + \</font>
<font color="green">  57.     pickle.dumps((sys.version_info[0] &lt;&lt; 24) | sys.version_info[1])</font>
<font color="black">  58. </font>
<font color="black">  59. </font>
<font color="green">  60. class Bucket(object):</font>
<font color="black">  61.     &quot;&quot;&quot;Buckets are used to store the bytecode for one template.  It's created</font>
<font color="black">  62.     and initialized by the bytecode cache and passed to the loading functions.</font>
<font color="black">  63. </font>
<font color="black">  64.     The buckets get an internal checksum from the cache assigned and use this</font>
<font color="black">  65.     to automatically reject outdated cache material.  Individual bytecode</font>
<font color="black">  66.     cache subclasses don't have to care about cache invalidation.</font>
<font color="green">  67.     &quot;&quot;&quot;</font>
<font color="black">  68. </font>
<font color="green">  69.     def __init__(self, environment, key, checksum):</font>
<font color="red">  70.         self.environment = environment</font>
<font color="red">  71.         self.key = key</font>
<font color="red">  72.         self.checksum = checksum</font>
<font color="red">  73.         self.reset()</font>
<font color="black">  74. </font>
<font color="green">  75.     def reset(self):</font>
<font color="black">  76.         &quot;&quot;&quot;Resets the bucket (unloads the bytecode).&quot;&quot;&quot;</font>
<font color="red">  77.         self.code = None</font>
<font color="black">  78. </font>
<font color="green">  79.     def load_bytecode(self, f):</font>
<font color="black">  80.         &quot;&quot;&quot;Loads bytecode from a file or file like object.&quot;&quot;&quot;</font>
<font color="black">  81.         # make sure the magic header is correct</font>
<font color="red">  82.         magic = f.read(len(bc_magic))</font>
<font color="red">  83.         if magic != bc_magic:</font>
<font color="red">  84.             self.reset()</font>
<font color="red">  85.             return</font>
<font color="black">  86.         # the source code of the file changed, we need to reload</font>
<font color="red">  87.         checksum = pickle.load(f)</font>
<font color="red">  88.         if self.checksum != checksum:</font>
<font color="red">  89.             self.reset()</font>
<font color="red">  90.             return</font>
<font color="black">  91.         # if marshal_load fails then we need to reload</font>
<font color="red">  92.         try:</font>
<font color="red">  93.             self.code = marshal_load(f)</font>
<font color="red">  94.         except (EOFError, ValueError, TypeError):</font>
<font color="red">  95.             self.reset()</font>
<font color="red">  96.             return</font>
<font color="black">  97. </font>
<font color="green">  98.     def write_bytecode(self, f):</font>
<font color="black">  99.         &quot;&quot;&quot;Dump the bytecode into the file or file like object passed.&quot;&quot;&quot;</font>
<font color="red"> 100.         if self.code is None:</font>
<font color="red"> 101.             raise TypeError('can\'t write empty bucket')</font>
<font color="red"> 102.         f.write(bc_magic)</font>
<font color="red"> 103.         pickle.dump(self.checksum, f, 2)</font>
<font color="red"> 104.         marshal_dump(self.code, f)</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def bytecode_from_string(self, string):</font>
<font color="black"> 107.         &quot;&quot;&quot;Load bytecode from a string.&quot;&quot;&quot;</font>
<font color="red"> 108.         self.load_bytecode(BytesIO(string))</font>
<font color="black"> 109. </font>
<font color="green"> 110.     def bytecode_to_string(self):</font>
<font color="black"> 111.         &quot;&quot;&quot;Return the bytecode as string.&quot;&quot;&quot;</font>
<font color="red"> 112.         out = BytesIO()</font>
<font color="red"> 113.         self.write_bytecode(out)</font>
<font color="red"> 114.         return out.getvalue()</font>
<font color="black"> 115. </font>
<font color="black"> 116. </font>
<font color="green"> 117. class BytecodeCache(object):</font>
<font color="black"> 118.     &quot;&quot;&quot;To implement your own bytecode cache you have to subclass this class</font>
<font color="black"> 119.     and override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of</font>
<font color="black"> 120.     these methods are passed a :class:`~jinja2.bccache.Bucket`.</font>
<font color="black"> 121. </font>
<font color="black"> 122.     A very basic bytecode cache that saves the bytecode on the file system::</font>
<font color="black"> 123. </font>
<font color="black"> 124.         from os import path</font>
<font color="black"> 125. </font>
<font color="black"> 126.         class MyCache(BytecodeCache):</font>
<font color="black"> 127. </font>
<font color="black"> 128.             def __init__(self, directory):</font>
<font color="black"> 129.                 self.directory = directory</font>
<font color="black"> 130. </font>
<font color="black"> 131.             def load_bytecode(self, bucket):</font>
<font color="black"> 132.                 filename = path.join(self.directory, bucket.key)</font>
<font color="black"> 133.                 if path.exists(filename):</font>
<font color="black"> 134.                     with open(filename, 'rb') as f:</font>
<font color="black"> 135.                         bucket.load_bytecode(f)</font>
<font color="black"> 136. </font>
<font color="black"> 137.             def dump_bytecode(self, bucket):</font>
<font color="black"> 138.                 filename = path.join(self.directory, bucket.key)</font>
<font color="black"> 139.                 with open(filename, 'wb') as f:</font>
<font color="black"> 140.                     bucket.write_bytecode(f)</font>
<font color="black"> 141. </font>
<font color="black"> 142.     A more advanced version of a filesystem based bytecode cache is part of</font>
<font color="black"> 143.     Jinja2.</font>
<font color="green"> 144.     &quot;&quot;&quot;</font>
<font color="black"> 145. </font>
<font color="green"> 146.     def load_bytecode(self, bucket):</font>
<font color="black"> 147.         &quot;&quot;&quot;Subclasses have to override this method to load bytecode into a</font>
<font color="black"> 148.         bucket.  If they are not able to find code in the cache for the</font>
<font color="black"> 149.         bucket, it must not do anything.</font>
<font color="black"> 150.         &quot;&quot;&quot;</font>
<font color="red"> 151.         raise NotImplementedError()</font>
<font color="black"> 152. </font>
<font color="green"> 153.     def dump_bytecode(self, bucket):</font>
<font color="black"> 154.         &quot;&quot;&quot;Subclasses have to override this method to write the bytecode</font>
<font color="black"> 155.         from a bucket back to the cache.  If it unable to do so it must not</font>
<font color="black"> 156.         fail silently but raise an exception.</font>
<font color="black"> 157.         &quot;&quot;&quot;</font>
<font color="red"> 158.         raise NotImplementedError()</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def clear(self):</font>
<font color="black"> 161.         &quot;&quot;&quot;Clears the cache.  This method is not used by Jinja2 but should be</font>
<font color="black"> 162.         implemented to allow applications to clear the bytecode cache used</font>
<font color="black"> 163.         by a particular environment.</font>
<font color="black"> 164.         &quot;&quot;&quot;</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def get_cache_key(self, name, filename=None):</font>
<font color="black"> 167.         &quot;&quot;&quot;Returns the unique hash key for this template name.&quot;&quot;&quot;</font>
<font color="red"> 168.         hash = sha1(name.encode('utf-8'))</font>
<font color="red"> 169.         if filename is not None:</font>
<font color="red"> 170.             filename = '|' + filename</font>
<font color="red"> 171.             if isinstance(filename, text_type):</font>
<font color="red"> 172.                 filename = filename.encode('utf-8')</font>
<font color="red"> 173.             hash.update(filename)</font>
<font color="red"> 174.         return hash.hexdigest()</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def get_source_checksum(self, source):</font>
<font color="black"> 177.         &quot;&quot;&quot;Returns a checksum for the source.&quot;&quot;&quot;</font>
<font color="red"> 178.         return sha1(source.encode('utf-8')).hexdigest()</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def get_bucket(self, environment, name, filename, source):</font>
<font color="black"> 181.         &quot;&quot;&quot;Return a cache bucket for the given template.  All arguments are</font>
<font color="black"> 182.         mandatory but filename may be `None`.</font>
<font color="black"> 183.         &quot;&quot;&quot;</font>
<font color="red"> 184.         key = self.get_cache_key(name, filename)</font>
<font color="red"> 185.         checksum = self.get_source_checksum(source)</font>
<font color="red"> 186.         bucket = Bucket(environment, key, checksum)</font>
<font color="red"> 187.         self.load_bytecode(bucket)</font>
<font color="red"> 188.         return bucket</font>
<font color="black"> 189. </font>
<font color="green"> 190.     def set_bucket(self, bucket):</font>
<font color="black"> 191.         &quot;&quot;&quot;Put the bucket into the cache.&quot;&quot;&quot;</font>
<font color="red"> 192.         self.dump_bytecode(bucket)</font>
<font color="black"> 193. </font>
<font color="black"> 194. </font>
<font color="green"> 195. class FileSystemBytecodeCache(BytecodeCache):</font>
<font color="black"> 196.     &quot;&quot;&quot;A bytecode cache that stores bytecode on the filesystem.  It accepts</font>
<font color="black"> 197.     two arguments: The directory where the cache items are stored and a</font>
<font color="black"> 198.     pattern string that is used to build the filename.</font>
<font color="black"> 199. </font>
<font color="black"> 200.     If no directory is specified a default cache directory is selected.  On</font>
<font color="black"> 201.     Windows the user's temp directory is used, on UNIX systems a directory</font>
<font color="black"> 202.     is created for the user in the system temp directory.</font>
<font color="black"> 203. </font>
<font color="black"> 204.     The pattern can be used to have multiple separate caches operate on the</font>
<font color="black"> 205.     same directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``</font>
<font color="black"> 206.     is replaced with the cache key.</font>
<font color="black"> 207. </font>
<font color="black"> 208.     &gt;&gt;&gt; bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')</font>
<font color="black"> 209. </font>
<font color="black"> 210.     This bytecode cache supports clearing of the cache using the clear method.</font>
<font color="green"> 211.     &quot;&quot;&quot;</font>
<font color="black"> 212. </font>
<font color="green"> 213.     def __init__(self, directory=None, pattern='__jinja2_%s.cache'):</font>
<font color="red"> 214.         if directory is None:</font>
<font color="red"> 215.             directory = self._get_default_cache_dir()</font>
<font color="red"> 216.         self.directory = directory</font>
<font color="red"> 217.         self.pattern = pattern</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def _get_default_cache_dir(self):</font>
<font color="red"> 220.         def _unsafe_dir():</font>
<font color="red"> 221.             raise RuntimeError('Cannot determine safe temp directory.  You '</font>
<font color="black"> 222.                                'need to explicitly provide one.')</font>
<font color="black"> 223. </font>
<font color="red"> 224.         tmpdir = tempfile.gettempdir()</font>
<font color="black"> 225. </font>
<font color="black"> 226.         # On windows the temporary directory is used specific unless</font>
<font color="black"> 227.         # explicitly forced otherwise.  We can just use that.</font>
<font color="red"> 228.         if os.name == 'nt':</font>
<font color="red"> 229.             return tmpdir</font>
<font color="red"> 230.         if not hasattr(os, 'getuid'):</font>
<font color="red"> 231.             _unsafe_dir()</font>
<font color="black"> 232. </font>
<font color="red"> 233.         dirname = '_jinja2-cache-%d' % os.getuid()</font>
<font color="red"> 234.         actual_dir = os.path.join(tmpdir, dirname)</font>
<font color="black"> 235. </font>
<font color="red"> 236.         try:</font>
<font color="red"> 237.             os.mkdir(actual_dir, stat.S_IRWXU)</font>
<font color="red"> 238.         except OSError as e:</font>
<font color="red"> 239.             if e.errno != errno.EEXIST:</font>
<font color="red"> 240.                 raise</font>
<font color="red"> 241.         try:</font>
<font color="red"> 242.             os.chmod(actual_dir, stat.S_IRWXU)</font>
<font color="red"> 243.             actual_dir_stat = os.lstat(actual_dir)</font>
<font color="red"> 244.             if actual_dir_stat.st_uid != os.getuid() \</font>
<font color="red"> 245.                or not stat.S_ISDIR(actual_dir_stat.st_mode) \</font>
<font color="red"> 246.                or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU:</font>
<font color="red"> 247.                 _unsafe_dir()</font>
<font color="red"> 248.         except OSError as e:</font>
<font color="red"> 249.             if e.errno != errno.EEXIST:</font>
<font color="red"> 250.                 raise</font>
<font color="black"> 251. </font>
<font color="red"> 252.         actual_dir_stat = os.lstat(actual_dir)</font>
<font color="red"> 253.         if actual_dir_stat.st_uid != os.getuid() \</font>
<font color="red"> 254.            or not stat.S_ISDIR(actual_dir_stat.st_mode) \</font>
<font color="red"> 255.            or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU:</font>
<font color="red"> 256.             _unsafe_dir()</font>
<font color="black"> 257. </font>
<font color="red"> 258.         return actual_dir</font>
<font color="black"> 259. </font>
<font color="green"> 260.     def _get_cache_filename(self, bucket):</font>
<font color="red"> 261.         return path.join(self.directory, self.pattern % bucket.key)</font>
<font color="black"> 262. </font>
<font color="green"> 263.     def load_bytecode(self, bucket):</font>
<font color="red"> 264.         f = open_if_exists(self._get_cache_filename(bucket), 'rb')</font>
<font color="red"> 265.         if f is not None:</font>
<font color="red"> 266.             try:</font>
<font color="red"> 267.                 bucket.load_bytecode(f)</font>
<font color="black"> 268.             finally:</font>
<font color="red"> 269.                 f.close()</font>
<font color="black"> 270. </font>
<font color="green"> 271.     def dump_bytecode(self, bucket):</font>
<font color="red"> 272.         f = open(self._get_cache_filename(bucket), 'wb')</font>
<font color="red"> 273.         try:</font>
<font color="red"> 274.             bucket.write_bytecode(f)</font>
<font color="black"> 275.         finally:</font>
<font color="red"> 276.             f.close()</font>
<font color="black"> 277. </font>
<font color="green"> 278.     def clear(self):</font>
<font color="black"> 279.         # imported lazily here because google app-engine doesn't support</font>
<font color="black"> 280.         # write access on the file system and the function does not exist</font>
<font color="black"> 281.         # normally.</font>
<font color="red"> 282.         from os import remove</font>
<font color="red"> 283.         files = fnmatch.filter(listdir(self.directory), self.pattern % '*')</font>
<font color="red"> 284.         for filename in files:</font>
<font color="red"> 285.             try:</font>
<font color="red"> 286.                 remove(path.join(self.directory, filename))</font>
<font color="red"> 287.             except OSError:</font>
<font color="red"> 288.                 pass</font>
<font color="black"> 289. </font>
<font color="black"> 290. </font>
<font color="green"> 291. class MemcachedBytecodeCache(BytecodeCache):</font>
<font color="black"> 292.     &quot;&quot;&quot;This class implements a bytecode cache that uses a memcache cache for</font>
<font color="black"> 293.     storing the information.  It does not enforce a specific memcache library</font>
<font color="black"> 294.     (tummy's memcache or cmemcache) but will accept any class that provides</font>
<font color="black"> 295.     the minimal interface required.</font>
<font color="black"> 296. </font>
<font color="black"> 297.     Libraries compatible with this class:</font>
<font color="black"> 298. </font>
<font color="black"> 299.     -   `werkzeug &lt;http://werkzeug.pocoo.org/&gt;`_.contrib.cache</font>
<font color="black"> 300.     -   `python-memcached &lt;http://www.tummy.com/Community/software/python-memcached/&gt;`_</font>
<font color="black"> 301.     -   `cmemcache &lt;http://gijsbert.org/cmemcache/&gt;`_</font>
<font color="black"> 302. </font>
<font color="black"> 303.     (Unfortunately the django cache interface is not compatible because it</font>
<font color="black"> 304.     does not support storing binary data, only unicode.  You can however pass</font>
<font color="black"> 305.     the underlying cache client to the bytecode cache which is available</font>
<font color="black"> 306.     as `django.core.cache.cache._client`.)</font>
<font color="black"> 307. </font>
<font color="black"> 308.     The minimal interface for the client passed to the constructor is this:</font>
<font color="black"> 309. </font>
<font color="black"> 310.     .. class:: MinimalClientInterface</font>
<font color="black"> 311. </font>
<font color="black"> 312.         .. method:: set(key, value[, timeout])</font>
<font color="black"> 313. </font>
<font color="black"> 314.             Stores the bytecode in the cache.  `value` is a string and</font>
<font color="black"> 315.             `timeout` the timeout of the key.  If timeout is not provided</font>
<font color="black"> 316.             a default timeout or no timeout should be assumed, if it's</font>
<font color="black"> 317.             provided it's an integer with the number of seconds the cache</font>
<font color="black"> 318.             item should exist.</font>
<font color="black"> 319. </font>
<font color="black"> 320.         .. method:: get(key)</font>
<font color="black"> 321. </font>
<font color="black"> 322.             Returns the value for the cache key.  If the item does not</font>
<font color="black"> 323.             exist in the cache the return value must be `None`.</font>
<font color="black"> 324. </font>
<font color="black"> 325.     The other arguments to the constructor are the prefix for all keys that</font>
<font color="black"> 326.     is added before the actual cache key and the timeout for the bytecode in</font>
<font color="black"> 327.     the cache system.  We recommend a high (or no) timeout.</font>
<font color="black"> 328. </font>
<font color="black"> 329.     This bytecode cache does not support clearing of used items in the cache.</font>
<font color="black"> 330.     The clear method is a no-operation function.</font>
<font color="black"> 331. </font>
<font color="black"> 332.     .. versionadded:: 2.7</font>
<font color="black"> 333.        Added support for ignoring memcache errors through the</font>
<font color="black"> 334.        `ignore_memcache_errors` parameter.</font>
<font color="green"> 335.     &quot;&quot;&quot;</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def __init__(self, client, prefix='jinja2/bytecode/', timeout=None,</font>
<font color="green"> 338.                  ignore_memcache_errors=True):</font>
<font color="red"> 339.         self.client = client</font>
<font color="red"> 340.         self.prefix = prefix</font>
<font color="red"> 341.         self.timeout = timeout</font>
<font color="red"> 342.         self.ignore_memcache_errors = ignore_memcache_errors</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def load_bytecode(self, bucket):</font>
<font color="red"> 345.         try:</font>
<font color="red"> 346.             code = self.client.get(self.prefix + bucket.key)</font>
<font color="red"> 347.         except Exception:</font>
<font color="red"> 348.             if not self.ignore_memcache_errors:</font>
<font color="red"> 349.                 raise</font>
<font color="red"> 350.             code = None</font>
<font color="red"> 351.         if code is not None:</font>
<font color="red"> 352.             bucket.bytecode_from_string(code)</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def dump_bytecode(self, bucket):</font>
<font color="red"> 355.         args = (self.prefix + bucket.key, bucket.bytecode_to_string())</font>
<font color="red"> 356.         if self.timeout is not None:</font>
<font color="red"> 357.             args += (self.timeout,)</font>
<font color="red"> 358.         try:</font>
<font color="red"> 359.             self.client.set(*args)</font>
<font color="red"> 360.         except Exception:</font>
<font color="red"> 361.             if not self.ignore_memcache_errors:</font>
<font color="red"> 362.                 raise</font>
</pre>

