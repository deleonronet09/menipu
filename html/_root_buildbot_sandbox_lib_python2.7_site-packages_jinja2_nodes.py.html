source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/nodes.py</b><br>


file stats: <b>529 lines, 290 executed: 54.8% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.nodes</font>
<font color="black">   4.     ~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     This module implements additional nodes derived from the ast base node.</font>
<font color="black">   7. </font>
<font color="black">   8.     It also provides some node tree helper functions like `in_lineno` and</font>
<font color="black">   9.     `get_nodes` used by the parser and translator in order to normalize</font>
<font color="black">  10.     python and jinja nodes.</font>
<font color="black">  11. </font>
<font color="black">  12.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">  13.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  14. &quot;&quot;&quot;</font>
<font color="green">  15. import types</font>
<font color="green">  16. import operator</font>
<font color="black">  17. </font>
<font color="green">  18. from collections import deque</font>
<font color="green">  19. from jinja2.utils import Markup</font>
<font color="green">  20. from jinja2._compat import izip, with_metaclass, text_type</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="black">  23. #: the types we support for context functions</font>
<font color="green">  24. _context_function_types = (types.FunctionType, types.MethodType)</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. _binop_to_func = {</font>
<font color="green">  28.     '*':        operator.mul,</font>
<font color="green">  29.     '/':        operator.truediv,</font>
<font color="green">  30.     '//':       operator.floordiv,</font>
<font color="green">  31.     '**':       operator.pow,</font>
<font color="green">  32.     '%':        operator.mod,</font>
<font color="green">  33.     '+':        operator.add,</font>
<font color="green">  34.     '-':        operator.sub</font>
<font color="black">  35. }</font>
<font color="black">  36. </font>
<font color="green">  37. _uaop_to_func = {</font>
<font color="green">  38.     'not':      operator.not_,</font>
<font color="green">  39.     '+':        operator.pos,</font>
<font color="green">  40.     '-':        operator.neg</font>
<font color="black">  41. }</font>
<font color="black">  42. </font>
<font color="green">  43. _cmpop_to_func = {</font>
<font color="green">  44.     'eq':       operator.eq,</font>
<font color="green">  45.     'ne':       operator.ne,</font>
<font color="green">  46.     'gt':       operator.gt,</font>
<font color="green">  47.     'gteq':     operator.ge,</font>
<font color="green">  48.     'lt':       operator.lt,</font>
<font color="green">  49.     'lteq':     operator.le,</font>
<font color="green">  50.     'in':       lambda a, b: a in b,</font>
<font color="green">  51.     'notin':    lambda a, b: a not in b</font>
<font color="black">  52. }</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. class Impossible(Exception):</font>
<font color="green">  56.     &quot;&quot;&quot;Raised if the node could not perform a requested action.&quot;&quot;&quot;</font>
<font color="black">  57. </font>
<font color="black">  58. </font>
<font color="green">  59. class NodeType(type):</font>
<font color="black">  60.     &quot;&quot;&quot;A metaclass for nodes that handles the field and attribute</font>
<font color="black">  61.     inheritance.  fields and attributes from the parent class are</font>
<font color="green">  62.     automatically forwarded to the child.&quot;&quot;&quot;</font>
<font color="black">  63. </font>
<font color="green">  64.     def __new__(cls, name, bases, d):</font>
<font color="green">  65.         for attr in 'fields', 'attributes':</font>
<font color="green">  66.             storage = []</font>
<font color="green">  67.             storage.extend(getattr(bases[0], attr, ()))</font>
<font color="green">  68.             storage.extend(d.get(attr, ()))</font>
<font color="green">  69.             assert len(bases) == 1, 'multiple inheritance not allowed'</font>
<font color="green">  70.             assert len(storage) == len(set(storage)), 'layout conflict'</font>
<font color="green">  71.             d[attr] = tuple(storage)</font>
<font color="green">  72.         d.setdefault('abstract', False)</font>
<font color="green">  73.         return type.__new__(cls, name, bases, d)</font>
<font color="black">  74. </font>
<font color="black">  75. </font>
<font color="green">  76. class EvalContext(object):</font>
<font color="black">  77.     &quot;&quot;&quot;Holds evaluation time information.  Custom attributes can be attached</font>
<font color="black">  78.     to it in extensions.</font>
<font color="green">  79.     &quot;&quot;&quot;</font>
<font color="black">  80. </font>
<font color="green">  81.     def __init__(self, environment, template_name=None):</font>
<font color="red">  82.         self.environment = environment</font>
<font color="red">  83.         if callable(environment.autoescape):</font>
<font color="red">  84.             self.autoescape = environment.autoescape(template_name)</font>
<font color="black">  85.         else:</font>
<font color="red">  86.             self.autoescape = environment.autoescape</font>
<font color="red">  87.         self.volatile = False</font>
<font color="black">  88. </font>
<font color="green">  89.     def save(self):</font>
<font color="red">  90.         return self.__dict__.copy()</font>
<font color="black">  91. </font>
<font color="green">  92.     def revert(self, old):</font>
<font color="red">  93.         self.__dict__.clear()</font>
<font color="red">  94.         self.__dict__.update(old)</font>
<font color="black">  95. </font>
<font color="black">  96. </font>
<font color="green">  97. def get_eval_context(node, ctx):</font>
<font color="red">  98.     if ctx is None:</font>
<font color="red">  99.         if node.environment is None:</font>
<font color="red"> 100.             raise RuntimeError('if no eval context is passed, the '</font>
<font color="black"> 101.                                'node must have an attached '</font>
<font color="black"> 102.                                'environment.')</font>
<font color="red"> 103.         return EvalContext(node.environment)</font>
<font color="red"> 104.     return ctx</font>
<font color="black"> 105. </font>
<font color="black"> 106. </font>
<font color="green"> 107. class Node(with_metaclass(NodeType, object)):</font>
<font color="black"> 108.     &quot;&quot;&quot;Baseclass for all Jinja2 nodes.  There are a number of nodes available</font>
<font color="black"> 109.     of different types.  There are four major types:</font>
<font color="black"> 110. </font>
<font color="black"> 111.     -   :class:`Stmt`: statements</font>
<font color="black"> 112.     -   :class:`Expr`: expressions</font>
<font color="black"> 113.     -   :class:`Helper`: helper nodes</font>
<font color="black"> 114.     -   :class:`Template`: the outermost wrapper node</font>
<font color="black"> 115. </font>
<font color="black"> 116.     All nodes have fields and attributes.  Fields may be other nodes, lists,</font>
<font color="black"> 117.     or arbitrary values.  Fields are passed to the constructor as regular</font>
<font color="black"> 118.     positional arguments, attributes as keyword arguments.  Each node has</font>
<font color="black"> 119.     two attributes: `lineno` (the line number of the node) and `environment`.</font>
<font color="black"> 120.     The `environment` attribute is set at the end of the parsing process for</font>
<font color="black"> 121.     all nodes automatically.</font>
<font color="green"> 122.     &quot;&quot;&quot;</font>
<font color="green"> 123.     fields = ()</font>
<font color="green"> 124.     attributes = ('lineno', 'environment')</font>
<font color="green"> 125.     abstract = True</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def __init__(self, *fields, **attributes):</font>
<font color="red"> 128.         if self.abstract:</font>
<font color="red"> 129.             raise TypeError('abstract nodes are not instanciable')</font>
<font color="red"> 130.         if fields:</font>
<font color="red"> 131.             if len(fields) != len(self.fields):</font>
<font color="red"> 132.                 if not self.fields:</font>
<font color="red"> 133.                     raise TypeError('%r takes 0 arguments' %</font>
<font color="red"> 134.                                     self.__class__.__name__)</font>
<font color="red"> 135.                 raise TypeError('%r takes 0 or %d argument%s' % (</font>
<font color="red"> 136.                     self.__class__.__name__,</font>
<font color="red"> 137.                     len(self.fields),</font>
<font color="red"> 138.                     len(self.fields) != 1 and 's' or ''</font>
<font color="black"> 139.                 ))</font>
<font color="red"> 140.             for name, arg in izip(self.fields, fields):</font>
<font color="red"> 141.                 setattr(self, name, arg)</font>
<font color="red"> 142.         for attr in self.attributes:</font>
<font color="red"> 143.             setattr(self, attr, attributes.pop(attr, None))</font>
<font color="red"> 144.         if attributes:</font>
<font color="red"> 145.             raise TypeError('unknown attribute %r' %</font>
<font color="red"> 146.                             next(iter(attributes)))</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def iter_fields(self, exclude=None, only=None):</font>
<font color="black"> 149.         &quot;&quot;&quot;This method iterates over all fields that are defined and yields</font>
<font color="black"> 150.         ``(key, value)`` tuples.  Per default all fields are returned, but</font>
<font color="black"> 151.         it's possible to limit that to some fields by providing the `only`</font>
<font color="black"> 152.         parameter or to exclude some using the `exclude` parameter.  Both</font>
<font color="black"> 153.         should be sets or tuples of field names.</font>
<font color="black"> 154.         &quot;&quot;&quot;</font>
<font color="red"> 155.         for name in self.fields:</font>
<font color="red"> 156.             if (exclude is only is None) or \</font>
<font color="red"> 157.                (exclude is not None and name not in exclude) or \</font>
<font color="red"> 158.                (only is not None and name in only):</font>
<font color="red"> 159.                 try:</font>
<font color="red"> 160.                     yield name, getattr(self, name)</font>
<font color="red"> 161.                 except AttributeError:</font>
<font color="red"> 162.                     pass</font>
<font color="black"> 163. </font>
<font color="green"> 164.     def iter_child_nodes(self, exclude=None, only=None):</font>
<font color="black"> 165.         &quot;&quot;&quot;Iterates over all direct child nodes of the node.  This iterates</font>
<font color="black"> 166.         over all fields and yields the values of they are nodes.  If the value</font>
<font color="black"> 167.         of a field is a list all the nodes in that list are returned.</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="red"> 169.         for field, item in self.iter_fields(exclude, only):</font>
<font color="red"> 170.             if isinstance(item, list):</font>
<font color="red"> 171.                 for n in item:</font>
<font color="red"> 172.                     if isinstance(n, Node):</font>
<font color="red"> 173.                         yield n</font>
<font color="red"> 174.             elif isinstance(item, Node):</font>
<font color="red"> 175.                 yield item</font>
<font color="black"> 176. </font>
<font color="green"> 177.     def find(self, node_type):</font>
<font color="black"> 178.         &quot;&quot;&quot;Find the first node of a given type.  If no such node exists the</font>
<font color="black"> 179.         return value is `None`.</font>
<font color="black"> 180.         &quot;&quot;&quot;</font>
<font color="red"> 181.         for result in self.find_all(node_type):</font>
<font color="red"> 182.             return result</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def find_all(self, node_type):</font>
<font color="black"> 185.         &quot;&quot;&quot;Find all the nodes of a given type.  If the type is a tuple,</font>
<font color="black"> 186.         the check is performed for any of the tuple items.</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="red"> 188.         for child in self.iter_child_nodes():</font>
<font color="red"> 189.             if isinstance(child, node_type):</font>
<font color="red"> 190.                 yield child</font>
<font color="red"> 191.             for result in child.find_all(node_type):</font>
<font color="red"> 192.                 yield result</font>
<font color="black"> 193. </font>
<font color="green"> 194.     def set_ctx(self, ctx):</font>
<font color="black"> 195.         &quot;&quot;&quot;Reset the context of a node and all child nodes.  Per default the</font>
<font color="black"> 196.         parser will all generate nodes that have a 'load' context as it's the</font>
<font color="black"> 197.         most common one.  This method is used in the parser to set assignment</font>
<font color="black"> 198.         targets and other nodes to a store context.</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="red"> 200.         todo = deque([self])</font>
<font color="red"> 201.         while todo:</font>
<font color="red"> 202.             node = todo.popleft()</font>
<font color="red"> 203.             if 'ctx' in node.fields:</font>
<font color="red"> 204.                 node.ctx = ctx</font>
<font color="red"> 205.             todo.extend(node.iter_child_nodes())</font>
<font color="red"> 206.         return self</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def set_lineno(self, lineno, override=False):</font>
<font color="black"> 209.         &quot;&quot;&quot;Set the line numbers of the node and children.&quot;&quot;&quot;</font>
<font color="red"> 210.         todo = deque([self])</font>
<font color="red"> 211.         while todo:</font>
<font color="red"> 212.             node = todo.popleft()</font>
<font color="red"> 213.             if 'lineno' in node.attributes:</font>
<font color="red"> 214.                 if node.lineno is None or override:</font>
<font color="red"> 215.                     node.lineno = lineno</font>
<font color="red"> 216.             todo.extend(node.iter_child_nodes())</font>
<font color="red"> 217.         return self</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def set_environment(self, environment):</font>
<font color="black"> 220.         &quot;&quot;&quot;Set the environment for all nodes.&quot;&quot;&quot;</font>
<font color="red"> 221.         todo = deque([self])</font>
<font color="red"> 222.         while todo:</font>
<font color="red"> 223.             node = todo.popleft()</font>
<font color="red"> 224.             node.environment = environment</font>
<font color="red"> 225.             todo.extend(node.iter_child_nodes())</font>
<font color="red"> 226.         return self</font>
<font color="black"> 227. </font>
<font color="green"> 228.     def __eq__(self, other):</font>
<font color="red"> 229.         return type(self) is type(other) and \</font>
<font color="red"> 230.                tuple(self.iter_fields()) == tuple(other.iter_fields())</font>
<font color="black"> 231. </font>
<font color="green"> 232.     def __ne__(self, other):</font>
<font color="red"> 233.         return not self.__eq__(other)</font>
<font color="black"> 234. </font>
<font color="black"> 235.     # Restore Python 2 hashing behavior on Python 3</font>
<font color="green"> 236.     __hash__ = object.__hash__</font>
<font color="black"> 237. </font>
<font color="green"> 238.     def __repr__(self):</font>
<font color="red"> 239.         return '%s(%s)' % (</font>
<font color="red"> 240.             self.__class__.__name__,</font>
<font color="red"> 241.             ', '.join('%s=%r' % (arg, getattr(self, arg, None)) for</font>
<font color="red"> 242.                       arg in self.fields)</font>
<font color="black"> 243.         )</font>
<font color="black"> 244. </font>
<font color="black"> 245. </font>
<font color="green"> 246. class Stmt(Node):</font>
<font color="green"> 247.     &quot;&quot;&quot;Base node for all statements.&quot;&quot;&quot;</font>
<font color="green"> 248.     abstract = True</font>
<font color="black"> 249. </font>
<font color="black"> 250. </font>
<font color="green"> 251. class Helper(Node):</font>
<font color="green"> 252.     &quot;&quot;&quot;Nodes that exist in a specific context only.&quot;&quot;&quot;</font>
<font color="green"> 253.     abstract = True</font>
<font color="black"> 254. </font>
<font color="black"> 255. </font>
<font color="green"> 256. class Template(Node):</font>
<font color="black"> 257.     &quot;&quot;&quot;Node that represents a template.  This must be the outermost node that</font>
<font color="black"> 258.     is passed to the compiler.</font>
<font color="green"> 259.     &quot;&quot;&quot;</font>
<font color="green"> 260.     fields = ('body',)</font>
<font color="black"> 261. </font>
<font color="black"> 262. </font>
<font color="green"> 263. class Output(Stmt):</font>
<font color="black"> 264.     &quot;&quot;&quot;A node that holds multiple expressions which are then printed out.</font>
<font color="black"> 265.     This is used both for the `print` statement and the regular template data.</font>
<font color="green"> 266.     &quot;&quot;&quot;</font>
<font color="green"> 267.     fields = ('nodes',)</font>
<font color="black"> 268. </font>
<font color="black"> 269. </font>
<font color="green"> 270. class Extends(Stmt):</font>
<font color="green"> 271.     &quot;&quot;&quot;Represents an extends statement.&quot;&quot;&quot;</font>
<font color="green"> 272.     fields = ('template',)</font>
<font color="black"> 273. </font>
<font color="black"> 274. </font>
<font color="green"> 275. class For(Stmt):</font>
<font color="black"> 276.     &quot;&quot;&quot;The for loop.  `target` is the target for the iteration (usually a</font>
<font color="black"> 277.     :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list</font>
<font color="black"> 278.     of nodes that are used as loop-body, and `else_` a list of nodes for the</font>
<font color="black"> 279.     `else` block.  If no else node exists it has to be an empty list.</font>
<font color="black"> 280. </font>
<font color="black"> 281.     For filtered nodes an expression can be stored as `test`, otherwise `None`.</font>
<font color="green"> 282.     &quot;&quot;&quot;</font>
<font color="green"> 283.     fields = ('target', 'iter', 'body', 'else_', 'test', 'recursive')</font>
<font color="black"> 284. </font>
<font color="black"> 285. </font>
<font color="green"> 286. class If(Stmt):</font>
<font color="green"> 287.     &quot;&quot;&quot;If `test` is true, `body` is rendered, else `else_`.&quot;&quot;&quot;</font>
<font color="green"> 288.     fields = ('test', 'body', 'else_')</font>
<font color="black"> 289. </font>
<font color="black"> 290. </font>
<font color="green"> 291. class Macro(Stmt):</font>
<font color="black"> 292.     &quot;&quot;&quot;A macro definition.  `name` is the name of the macro, `args` a list of</font>
<font color="black"> 293.     arguments and `defaults` a list of defaults if there are any.  `body` is</font>
<font color="black"> 294.     a list of nodes for the macro body.</font>
<font color="green"> 295.     &quot;&quot;&quot;</font>
<font color="green"> 296.     fields = ('name', 'args', 'defaults', 'body')</font>
<font color="black"> 297. </font>
<font color="black"> 298. </font>
<font color="green"> 299. class CallBlock(Stmt):</font>
<font color="black"> 300.     &quot;&quot;&quot;Like a macro without a name but a call instead.  `call` is called with</font>
<font color="black"> 301.     the unnamed macro as `caller` argument this node holds.</font>
<font color="green"> 302.     &quot;&quot;&quot;</font>
<font color="green"> 303.     fields = ('call', 'args', 'defaults', 'body')</font>
<font color="black"> 304. </font>
<font color="black"> 305. </font>
<font color="green"> 306. class FilterBlock(Stmt):</font>
<font color="green"> 307.     &quot;&quot;&quot;Node for filter sections.&quot;&quot;&quot;</font>
<font color="green"> 308.     fields = ('body', 'filter')</font>
<font color="black"> 309. </font>
<font color="black"> 310. </font>
<font color="green"> 311. class Block(Stmt):</font>
<font color="green"> 312.     &quot;&quot;&quot;A node that represents a block.&quot;&quot;&quot;</font>
<font color="green"> 313.     fields = ('name', 'body', 'scoped')</font>
<font color="black"> 314. </font>
<font color="black"> 315. </font>
<font color="green"> 316. class Include(Stmt):</font>
<font color="green"> 317.     &quot;&quot;&quot;A node that represents the include tag.&quot;&quot;&quot;</font>
<font color="green"> 318.     fields = ('template', 'with_context', 'ignore_missing')</font>
<font color="black"> 319. </font>
<font color="black"> 320. </font>
<font color="green"> 321. class Import(Stmt):</font>
<font color="green"> 322.     &quot;&quot;&quot;A node that represents the import tag.&quot;&quot;&quot;</font>
<font color="green"> 323.     fields = ('template', 'target', 'with_context')</font>
<font color="black"> 324. </font>
<font color="black"> 325. </font>
<font color="green"> 326. class FromImport(Stmt):</font>
<font color="black"> 327.     &quot;&quot;&quot;A node that represents the from import tag.  It's important to not</font>
<font color="black"> 328.     pass unsafe names to the name attribute.  The compiler translates the</font>
<font color="black"> 329.     attribute lookups directly into getattr calls and does *not* use the</font>
<font color="black"> 330.     subscript callback of the interface.  As exported variables may not</font>
<font color="black"> 331.     start with double underscores (which the parser asserts) this is not a</font>
<font color="black"> 332.     problem for regular Jinja code, but if this node is used in an extension</font>
<font color="black"> 333.     extra care must be taken.</font>
<font color="black"> 334. </font>
<font color="black"> 335.     The list of names may contain tuples if aliases are wanted.</font>
<font color="green"> 336.     &quot;&quot;&quot;</font>
<font color="green"> 337.     fields = ('template', 'names', 'with_context')</font>
<font color="black"> 338. </font>
<font color="black"> 339. </font>
<font color="green"> 340. class ExprStmt(Stmt):</font>
<font color="green"> 341.     &quot;&quot;&quot;A statement that evaluates an expression and discards the result.&quot;&quot;&quot;</font>
<font color="green"> 342.     fields = ('node',)</font>
<font color="black"> 343. </font>
<font color="black"> 344. </font>
<font color="green"> 345. class Assign(Stmt):</font>
<font color="green"> 346.     &quot;&quot;&quot;Assigns an expression to a target.&quot;&quot;&quot;</font>
<font color="green"> 347.     fields = ('target', 'node')</font>
<font color="black"> 348. </font>
<font color="black"> 349. </font>
<font color="green"> 350. class AssignBlock(Stmt):</font>
<font color="green"> 351.     &quot;&quot;&quot;Assigns a block to a target.&quot;&quot;&quot;</font>
<font color="green"> 352.     fields = ('target', 'body')</font>
<font color="black"> 353. </font>
<font color="black"> 354. </font>
<font color="green"> 355. class Expr(Node):</font>
<font color="green"> 356.     &quot;&quot;&quot;Baseclass for all expressions.&quot;&quot;&quot;</font>
<font color="green"> 357.     abstract = True</font>
<font color="black"> 358. </font>
<font color="green"> 359.     def as_const(self, eval_ctx=None):</font>
<font color="black"> 360.         &quot;&quot;&quot;Return the value of the expression as constant or raise</font>
<font color="black"> 361.         :exc:`Impossible` if this was not possible.</font>
<font color="black"> 362. </font>
<font color="black"> 363.         An :class:`EvalContext` can be provided, if none is given</font>
<font color="black"> 364.         a default context is created which requires the nodes to have</font>
<font color="black"> 365.         an attached environment.</font>
<font color="black"> 366. </font>
<font color="black"> 367.         .. versionchanged:: 2.4</font>
<font color="black"> 368.            the `eval_ctx` parameter was added.</font>
<font color="black"> 369.         &quot;&quot;&quot;</font>
<font color="red"> 370.         raise Impossible()</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def can_assign(self):</font>
<font color="black"> 373.         &quot;&quot;&quot;Check if it's possible to assign something to this node.&quot;&quot;&quot;</font>
<font color="red"> 374.         return False</font>
<font color="black"> 375. </font>
<font color="black"> 376. </font>
<font color="green"> 377. class BinExpr(Expr):</font>
<font color="green"> 378.     &quot;&quot;&quot;Baseclass for all binary expressions.&quot;&quot;&quot;</font>
<font color="green"> 379.     fields = ('left', 'right')</font>
<font color="green"> 380.     operator = None</font>
<font color="green"> 381.     abstract = True</font>
<font color="black"> 382. </font>
<font color="green"> 383.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 384.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="black"> 385.         # intercepted operators cannot be folded at compile time</font>
<font color="red"> 386.         if self.environment.sandboxed and \</font>
<font color="red"> 387.            self.operator in self.environment.intercepted_binops:</font>
<font color="red"> 388.             raise Impossible()</font>
<font color="red"> 389.         f = _binop_to_func[self.operator]</font>
<font color="red"> 390.         try:</font>
<font color="red"> 391.             return f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))</font>
<font color="red"> 392.         except Exception:</font>
<font color="red"> 393.             raise Impossible()</font>
<font color="black"> 394. </font>
<font color="black"> 395. </font>
<font color="green"> 396. class UnaryExpr(Expr):</font>
<font color="green"> 397.     &quot;&quot;&quot;Baseclass for all unary expressions.&quot;&quot;&quot;</font>
<font color="green"> 398.     fields = ('node',)</font>
<font color="green"> 399.     operator = None</font>
<font color="green"> 400.     abstract = True</font>
<font color="black"> 401. </font>
<font color="green"> 402.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 403.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="black"> 404.         # intercepted operators cannot be folded at compile time</font>
<font color="red"> 405.         if self.environment.sandboxed and \</font>
<font color="red"> 406.            self.operator in self.environment.intercepted_unops:</font>
<font color="red"> 407.             raise Impossible()</font>
<font color="red"> 408.         f = _uaop_to_func[self.operator]</font>
<font color="red"> 409.         try:</font>
<font color="red"> 410.             return f(self.node.as_const(eval_ctx))</font>
<font color="red"> 411.         except Exception:</font>
<font color="red"> 412.             raise Impossible()</font>
<font color="black"> 413. </font>
<font color="black"> 414. </font>
<font color="green"> 415. class Name(Expr):</font>
<font color="black"> 416.     &quot;&quot;&quot;Looks up a name or stores a value in a name.</font>
<font color="black"> 417.     The `ctx` of the node can be one of the following values:</font>
<font color="black"> 418. </font>
<font color="black"> 419.     -   `store`: store a value in the name</font>
<font color="black"> 420.     -   `load`: load that name</font>
<font color="black"> 421.     -   `param`: like `store` but if the name was defined as function parameter.</font>
<font color="green"> 422.     &quot;&quot;&quot;</font>
<font color="green"> 423.     fields = ('name', 'ctx')</font>
<font color="black"> 424. </font>
<font color="green"> 425.     def can_assign(self):</font>
<font color="red"> 426.         return self.name not in ('true', 'false', 'none',</font>
<font color="red"> 427.                                  'True', 'False', 'None')</font>
<font color="black"> 428. </font>
<font color="black"> 429. </font>
<font color="green"> 430. class Literal(Expr):</font>
<font color="green"> 431.     &quot;&quot;&quot;Baseclass for literals.&quot;&quot;&quot;</font>
<font color="green"> 432.     abstract = True</font>
<font color="black"> 433. </font>
<font color="black"> 434. </font>
<font color="green"> 435. class Const(Literal):</font>
<font color="black"> 436.     &quot;&quot;&quot;All constant values.  The parser will return this node for simple</font>
<font color="black"> 437.     constants such as ``42`` or ``&quot;foo&quot;`` but it can be used to store more</font>
<font color="black"> 438.     complex values such as lists too.  Only constants with a safe</font>
<font color="black"> 439.     representation (objects where ``eval(repr(x)) == x`` is true).</font>
<font color="green"> 440.     &quot;&quot;&quot;</font>
<font color="green"> 441.     fields = ('value',)</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 444.         return self.value</font>
<font color="black"> 445. </font>
<font color="green"> 446.     @classmethod</font>
<font color="green"> 447.     def from_untrusted(cls, value, lineno=None, environment=None):</font>
<font color="black"> 448.         &quot;&quot;&quot;Return a const object if the value is representable as</font>
<font color="black"> 449.         constant value in the generated code, otherwise it will raise</font>
<font color="black"> 450.         an `Impossible` exception.</font>
<font color="black"> 451.         &quot;&quot;&quot;</font>
<font color="red"> 452.         from .compiler import has_safe_repr</font>
<font color="red"> 453.         if not has_safe_repr(value):</font>
<font color="red"> 454.             raise Impossible()</font>
<font color="red"> 455.         return cls(value, lineno=lineno, environment=environment)</font>
<font color="black"> 456. </font>
<font color="black"> 457. </font>
<font color="green"> 458. class TemplateData(Literal):</font>
<font color="green"> 459.     &quot;&quot;&quot;A constant template string.&quot;&quot;&quot;</font>
<font color="green"> 460.     fields = ('data',)</font>
<font color="black"> 461. </font>
<font color="green"> 462.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 463.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 464.         if eval_ctx.volatile:</font>
<font color="red"> 465.             raise Impossible()</font>
<font color="red"> 466.         if eval_ctx.autoescape:</font>
<font color="red"> 467.             return Markup(self.data)</font>
<font color="red"> 468.         return self.data</font>
<font color="black"> 469. </font>
<font color="black"> 470. </font>
<font color="green"> 471. class Tuple(Literal):</font>
<font color="black"> 472.     &quot;&quot;&quot;For loop unpacking and some other things like multiple arguments</font>
<font color="black"> 473.     for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple</font>
<font color="black"> 474.     is used for loading the names or storing.</font>
<font color="green"> 475.     &quot;&quot;&quot;</font>
<font color="green"> 476.     fields = ('items', 'ctx')</font>
<font color="black"> 477. </font>
<font color="green"> 478.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 479.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 480.         return tuple(x.as_const(eval_ctx) for x in self.items)</font>
<font color="black"> 481. </font>
<font color="green"> 482.     def can_assign(self):</font>
<font color="red"> 483.         for item in self.items:</font>
<font color="red"> 484.             if not item.can_assign():</font>
<font color="red"> 485.                 return False</font>
<font color="red"> 486.         return True</font>
<font color="black"> 487. </font>
<font color="black"> 488. </font>
<font color="green"> 489. class List(Literal):</font>
<font color="green"> 490.     &quot;&quot;&quot;Any list literal such as ``[1, 2, 3]``&quot;&quot;&quot;</font>
<font color="green"> 491.     fields = ('items',)</font>
<font color="black"> 492. </font>
<font color="green"> 493.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 494.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 495.         return [x.as_const(eval_ctx) for x in self.items]</font>
<font color="black"> 496. </font>
<font color="black"> 497. </font>
<font color="green"> 498. class Dict(Literal):</font>
<font color="black"> 499.     &quot;&quot;&quot;Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of</font>
<font color="black"> 500.     :class:`Pair` nodes.</font>
<font color="green"> 501.     &quot;&quot;&quot;</font>
<font color="green"> 502.     fields = ('items',)</font>
<font color="black"> 503. </font>
<font color="green"> 504.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 505.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 506.         return dict(x.as_const(eval_ctx) for x in self.items)</font>
<font color="black"> 507. </font>
<font color="black"> 508. </font>
<font color="green"> 509. class Pair(Helper):</font>
<font color="green"> 510.     &quot;&quot;&quot;A key, value pair for dicts.&quot;&quot;&quot;</font>
<font color="green"> 511.     fields = ('key', 'value')</font>
<font color="black"> 512. </font>
<font color="green"> 513.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 514.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 515.         return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)</font>
<font color="black"> 516. </font>
<font color="black"> 517. </font>
<font color="green"> 518. class Keyword(Helper):</font>
<font color="green"> 519.     &quot;&quot;&quot;A key, value pair for keyword arguments where key is a string.&quot;&quot;&quot;</font>
<font color="green"> 520.     fields = ('key', 'value')</font>
<font color="black"> 521. </font>
<font color="green"> 522.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 523.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 524.         return self.key, self.value.as_const(eval_ctx)</font>
<font color="black"> 525. </font>
<font color="black"> 526. </font>
<font color="green"> 527. class CondExpr(Expr):</font>
<font color="black"> 528.     &quot;&quot;&quot;A conditional expression (inline if expression).  (``{{</font>
<font color="black"> 529.     foo if bar else baz }}``)</font>
<font color="green"> 530.     &quot;&quot;&quot;</font>
<font color="green"> 531.     fields = ('test', 'expr1', 'expr2')</font>
<font color="black"> 532. </font>
<font color="green"> 533.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 534.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 535.         if self.test.as_const(eval_ctx):</font>
<font color="red"> 536.             return self.expr1.as_const(eval_ctx)</font>
<font color="black"> 537. </font>
<font color="black"> 538.         # if we evaluate to an undefined object, we better do that at runtime</font>
<font color="red"> 539.         if self.expr2 is None:</font>
<font color="red"> 540.             raise Impossible()</font>
<font color="black"> 541. </font>
<font color="red"> 542.         return self.expr2.as_const(eval_ctx)</font>
<font color="black"> 543. </font>
<font color="black"> 544. </font>
<font color="green"> 545. class Filter(Expr):</font>
<font color="black"> 546.     &quot;&quot;&quot;This node applies a filter on an expression.  `name` is the name of</font>
<font color="black"> 547.     the filter, the rest of the fields are the same as for :class:`Call`.</font>
<font color="black"> 548. </font>
<font color="black"> 549.     If the `node` of a filter is `None` the contents of the last buffer are</font>
<font color="black"> 550.     filtered.  Buffers are created by macros and filter blocks.</font>
<font color="green"> 551.     &quot;&quot;&quot;</font>
<font color="green"> 552.     fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')</font>
<font color="black"> 553. </font>
<font color="green"> 554.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 555.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 556.         if eval_ctx.volatile or self.node is None:</font>
<font color="red"> 557.             raise Impossible()</font>
<font color="black"> 558.         # we have to be careful here because we call filter_ below.</font>
<font color="black"> 559.         # if this variable would be called filter, 2to3 would wrap the</font>
<font color="black"> 560.         # call in a list beause it is assuming we are talking about the</font>
<font color="black"> 561.         # builtin filter function here which no longer returns a list in</font>
<font color="black"> 562.         # python 3.  because of that, do not rename filter_ to filter!</font>
<font color="red"> 563.         filter_ = self.environment.filters.get(self.name)</font>
<font color="red"> 564.         if filter_ is None or getattr(filter_, 'contextfilter', False):</font>
<font color="red"> 565.             raise Impossible()</font>
<font color="red"> 566.         obj = self.node.as_const(eval_ctx)</font>
<font color="red"> 567.         args = [x.as_const(eval_ctx) for x in self.args]</font>
<font color="red"> 568.         if getattr(filter_, 'evalcontextfilter', False):</font>
<font color="red"> 569.             args.insert(0, eval_ctx)</font>
<font color="red"> 570.         elif getattr(filter_, 'environmentfilter', False):</font>
<font color="red"> 571.             args.insert(0, self.environment)</font>
<font color="red"> 572.         kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)</font>
<font color="red"> 573.         if self.dyn_args is not None:</font>
<font color="red"> 574.             try:</font>
<font color="red"> 575.                 args.extend(self.dyn_args.as_const(eval_ctx))</font>
<font color="red"> 576.             except Exception:</font>
<font color="red"> 577.                 raise Impossible()</font>
<font color="red"> 578.         if self.dyn_kwargs is not None:</font>
<font color="red"> 579.             try:</font>
<font color="red"> 580.                 kwargs.update(self.dyn_kwargs.as_const(eval_ctx))</font>
<font color="red"> 581.             except Exception:</font>
<font color="red"> 582.                 raise Impossible()</font>
<font color="red"> 583.         try:</font>
<font color="red"> 584.             return filter_(obj, *args, **kwargs)</font>
<font color="red"> 585.         except Exception:</font>
<font color="red"> 586.             raise Impossible()</font>
<font color="black"> 587. </font>
<font color="black"> 588. </font>
<font color="green"> 589. class Test(Expr):</font>
<font color="black"> 590.     &quot;&quot;&quot;Applies a test on an expression.  `name` is the name of the test, the</font>
<font color="black"> 591.     rest of the fields are the same as for :class:`Call`.</font>
<font color="green"> 592.     &quot;&quot;&quot;</font>
<font color="green"> 593.     fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')</font>
<font color="black"> 594. </font>
<font color="black"> 595. </font>
<font color="green"> 596. class Call(Expr):</font>
<font color="black"> 597.     &quot;&quot;&quot;Calls an expression.  `args` is a list of arguments, `kwargs` a list</font>
<font color="black"> 598.     of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`</font>
<font color="black"> 599.     and `dyn_kwargs` has to be either `None` or a node that is used as</font>
<font color="black"> 600.     node for dynamic positional (``*args``) or keyword (``**kwargs``)</font>
<font color="black"> 601.     arguments.</font>
<font color="green"> 602.     &quot;&quot;&quot;</font>
<font color="green"> 603.     fields = ('node', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')</font>
<font color="black"> 604. </font>
<font color="green"> 605.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 606.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 607.         if eval_ctx.volatile:</font>
<font color="red"> 608.             raise Impossible()</font>
<font color="red"> 609.         obj = self.node.as_const(eval_ctx)</font>
<font color="black"> 610. </font>
<font color="black"> 611.         # don't evaluate context functions</font>
<font color="red"> 612.         args = [x.as_const(eval_ctx) for x in self.args]</font>
<font color="red"> 613.         if isinstance(obj, _context_function_types):</font>
<font color="red"> 614.             if getattr(obj, 'contextfunction', False):</font>
<font color="red"> 615.                 raise Impossible()</font>
<font color="red"> 616.             elif getattr(obj, 'evalcontextfunction', False):</font>
<font color="red"> 617.                 args.insert(0, eval_ctx)</font>
<font color="red"> 618.             elif getattr(obj, 'environmentfunction', False):</font>
<font color="red"> 619.                 args.insert(0, self.environment)</font>
<font color="black"> 620. </font>
<font color="red"> 621.         kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)</font>
<font color="red"> 622.         if self.dyn_args is not None:</font>
<font color="red"> 623.             try:</font>
<font color="red"> 624.                 args.extend(self.dyn_args.as_const(eval_ctx))</font>
<font color="red"> 625.             except Exception:</font>
<font color="red"> 626.                 raise Impossible()</font>
<font color="red"> 627.         if self.dyn_kwargs is not None:</font>
<font color="red"> 628.             try:</font>
<font color="red"> 629.                 kwargs.update(self.dyn_kwargs.as_const(eval_ctx))</font>
<font color="red"> 630.             except Exception:</font>
<font color="red"> 631.                 raise Impossible()</font>
<font color="red"> 632.         try:</font>
<font color="red"> 633.             return obj(*args, **kwargs)</font>
<font color="red"> 634.         except Exception:</font>
<font color="red"> 635.             raise Impossible()</font>
<font color="black"> 636. </font>
<font color="black"> 637. </font>
<font color="green"> 638. class Getitem(Expr):</font>
<font color="green"> 639.     &quot;&quot;&quot;Get an attribute or item from an expression and prefer the item.&quot;&quot;&quot;</font>
<font color="green"> 640.     fields = ('node', 'arg', 'ctx')</font>
<font color="black"> 641. </font>
<font color="green"> 642.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 643.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 644.         if self.ctx != 'load':</font>
<font color="red"> 645.             raise Impossible()</font>
<font color="red"> 646.         try:</font>
<font color="red"> 647.             return self.environment.getitem(self.node.as_const(eval_ctx),</font>
<font color="red"> 648.                                             self.arg.as_const(eval_ctx))</font>
<font color="red"> 649.         except Exception:</font>
<font color="red"> 650.             raise Impossible()</font>
<font color="black"> 651. </font>
<font color="green"> 652.     def can_assign(self):</font>
<font color="red"> 653.         return False</font>
<font color="black"> 654. </font>
<font color="black"> 655. </font>
<font color="green"> 656. class Getattr(Expr):</font>
<font color="black"> 657.     &quot;&quot;&quot;Get an attribute or item from an expression that is a ascii-only</font>
<font color="black"> 658.     bytestring and prefer the attribute.</font>
<font color="green"> 659.     &quot;&quot;&quot;</font>
<font color="green"> 660.     fields = ('node', 'attr', 'ctx')</font>
<font color="black"> 661. </font>
<font color="green"> 662.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 663.         if self.ctx != 'load':</font>
<font color="red"> 664.             raise Impossible()</font>
<font color="red"> 665.         try:</font>
<font color="red"> 666.             eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 667.             return self.environment.getattr(self.node.as_const(eval_ctx),</font>
<font color="red"> 668.                                             self.attr)</font>
<font color="red"> 669.         except Exception:</font>
<font color="red"> 670.             raise Impossible()</font>
<font color="black"> 671. </font>
<font color="green"> 672.     def can_assign(self):</font>
<font color="red"> 673.         return False</font>
<font color="black"> 674. </font>
<font color="black"> 675. </font>
<font color="green"> 676. class Slice(Expr):</font>
<font color="black"> 677.     &quot;&quot;&quot;Represents a slice object.  This must only be used as argument for</font>
<font color="black"> 678.     :class:`Subscript`.</font>
<font color="green"> 679.     &quot;&quot;&quot;</font>
<font color="green"> 680.     fields = ('start', 'stop', 'step')</font>
<font color="black"> 681. </font>
<font color="green"> 682.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 683.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 684.         def const(obj):</font>
<font color="red"> 685.             if obj is None:</font>
<font color="red"> 686.                 return None</font>
<font color="red"> 687.             return obj.as_const(eval_ctx)</font>
<font color="red"> 688.         return slice(const(self.start), const(self.stop), const(self.step))</font>
<font color="black"> 689. </font>
<font color="black"> 690. </font>
<font color="green"> 691. class Concat(Expr):</font>
<font color="black"> 692.     &quot;&quot;&quot;Concatenates the list of expressions provided after converting them to</font>
<font color="black"> 693.     unicode.</font>
<font color="green"> 694.     &quot;&quot;&quot;</font>
<font color="green"> 695.     fields = ('nodes',)</font>
<font color="black"> 696. </font>
<font color="green"> 697.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 698.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 699.         return ''.join(text_type(x.as_const(eval_ctx)) for x in self.nodes)</font>
<font color="black"> 700. </font>
<font color="black"> 701. </font>
<font color="green"> 702. class Compare(Expr):</font>
<font color="black"> 703.     &quot;&quot;&quot;Compares an expression with some other expressions.  `ops` must be a</font>
<font color="black"> 704.     list of :class:`Operand`\s.</font>
<font color="green"> 705.     &quot;&quot;&quot;</font>
<font color="green"> 706.     fields = ('expr', 'ops')</font>
<font color="black"> 707. </font>
<font color="green"> 708.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 709.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 710.         result = value = self.expr.as_const(eval_ctx)</font>
<font color="red"> 711.         try:</font>
<font color="red"> 712.             for op in self.ops:</font>
<font color="red"> 713.                 new_value = op.expr.as_const(eval_ctx)</font>
<font color="red"> 714.                 result = _cmpop_to_func[op.op](value, new_value)</font>
<font color="red"> 715.                 value = new_value</font>
<font color="red"> 716.         except Exception:</font>
<font color="red"> 717.             raise Impossible()</font>
<font color="red"> 718.         return result</font>
<font color="black"> 719. </font>
<font color="black"> 720. </font>
<font color="green"> 721. class Operand(Helper):</font>
<font color="green"> 722.     &quot;&quot;&quot;Holds an operator and an expression.&quot;&quot;&quot;</font>
<font color="green"> 723.     fields = ('op', 'expr')</font>
<font color="black"> 724. </font>
<font color="black"> 725. if __debug__:</font>
<font color="green"> 726.     Operand.__doc__ += '\nThe following operators are available: ' + \</font>
<font color="green"> 727.         ', '.join(sorted('``%s``' % x for x in set(_binop_to_func) |</font>
<font color="green"> 728.                   set(_uaop_to_func) | set(_cmpop_to_func)))</font>
<font color="black"> 729. </font>
<font color="black"> 730. </font>
<font color="green"> 731. class Mul(BinExpr):</font>
<font color="green"> 732.     &quot;&quot;&quot;Multiplies the left with the right node.&quot;&quot;&quot;</font>
<font color="green"> 733.     operator = '*'</font>
<font color="black"> 734. </font>
<font color="black"> 735. </font>
<font color="green"> 736. class Div(BinExpr):</font>
<font color="green"> 737.     &quot;&quot;&quot;Divides the left by the right node.&quot;&quot;&quot;</font>
<font color="green"> 738.     operator = '/'</font>
<font color="black"> 739. </font>
<font color="black"> 740. </font>
<font color="green"> 741. class FloorDiv(BinExpr):</font>
<font color="black"> 742.     &quot;&quot;&quot;Divides the left by the right node and truncates conver the</font>
<font color="black"> 743.     result into an integer by truncating.</font>
<font color="green"> 744.     &quot;&quot;&quot;</font>
<font color="green"> 745.     operator = '//'</font>
<font color="black"> 746. </font>
<font color="black"> 747. </font>
<font color="green"> 748. class Add(BinExpr):</font>
<font color="green"> 749.     &quot;&quot;&quot;Add the left to the right node.&quot;&quot;&quot;</font>
<font color="green"> 750.     operator = '+'</font>
<font color="black"> 751. </font>
<font color="black"> 752. </font>
<font color="green"> 753. class Sub(BinExpr):</font>
<font color="green"> 754.     &quot;&quot;&quot;Subtract the right from the left node.&quot;&quot;&quot;</font>
<font color="green"> 755.     operator = '-'</font>
<font color="black"> 756. </font>
<font color="black"> 757. </font>
<font color="green"> 758. class Mod(BinExpr):</font>
<font color="green"> 759.     &quot;&quot;&quot;Left modulo right.&quot;&quot;&quot;</font>
<font color="green"> 760.     operator = '%'</font>
<font color="black"> 761. </font>
<font color="black"> 762. </font>
<font color="green"> 763. class Pow(BinExpr):</font>
<font color="green"> 764.     &quot;&quot;&quot;Left to the power of right.&quot;&quot;&quot;</font>
<font color="green"> 765.     operator = '**'</font>
<font color="black"> 766. </font>
<font color="black"> 767. </font>
<font color="green"> 768. class And(BinExpr):</font>
<font color="green"> 769.     &quot;&quot;&quot;Short circuited AND.&quot;&quot;&quot;</font>
<font color="green"> 770.     operator = 'and'</font>
<font color="black"> 771. </font>
<font color="green"> 772.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 773.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 774.         return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)</font>
<font color="black"> 775. </font>
<font color="black"> 776. </font>
<font color="green"> 777. class Or(BinExpr):</font>
<font color="green"> 778.     &quot;&quot;&quot;Short circuited OR.&quot;&quot;&quot;</font>
<font color="green"> 779.     operator = 'or'</font>
<font color="black"> 780. </font>
<font color="green"> 781.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 782.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 783.         return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)</font>
<font color="black"> 784. </font>
<font color="black"> 785. </font>
<font color="green"> 786. class Not(UnaryExpr):</font>
<font color="green"> 787.     &quot;&quot;&quot;Negate the expression.&quot;&quot;&quot;</font>
<font color="green"> 788.     operator = 'not'</font>
<font color="black"> 789. </font>
<font color="black"> 790. </font>
<font color="green"> 791. class Neg(UnaryExpr):</font>
<font color="green"> 792.     &quot;&quot;&quot;Make the expression negative.&quot;&quot;&quot;</font>
<font color="green"> 793.     operator = '-'</font>
<font color="black"> 794. </font>
<font color="black"> 795. </font>
<font color="green"> 796. class Pos(UnaryExpr):</font>
<font color="green"> 797.     &quot;&quot;&quot;Make the expression positive (noop for most expressions)&quot;&quot;&quot;</font>
<font color="green"> 798.     operator = '+'</font>
<font color="black"> 799. </font>
<font color="black"> 800. </font>
<font color="black"> 801. # Helpers for extensions</font>
<font color="black"> 802. </font>
<font color="black"> 803. </font>
<font color="green"> 804. class EnvironmentAttribute(Expr):</font>
<font color="black"> 805.     &quot;&quot;&quot;Loads an attribute from the environment object.  This is useful for</font>
<font color="black"> 806.     extensions that want to call a callback stored on the environment.</font>
<font color="green"> 807.     &quot;&quot;&quot;</font>
<font color="green"> 808.     fields = ('name',)</font>
<font color="black"> 809. </font>
<font color="black"> 810. </font>
<font color="green"> 811. class ExtensionAttribute(Expr):</font>
<font color="black"> 812.     &quot;&quot;&quot;Returns the attribute of an extension bound to the environment.</font>
<font color="black"> 813.     The identifier is the identifier of the :class:`Extension`.</font>
<font color="black"> 814. </font>
<font color="black"> 815.     This node is usually constructed by calling the</font>
<font color="black"> 816.     :meth:`~jinja2.ext.Extension.attr` method on an extension.</font>
<font color="green"> 817.     &quot;&quot;&quot;</font>
<font color="green"> 818.     fields = ('identifier', 'name')</font>
<font color="black"> 819. </font>
<font color="black"> 820. </font>
<font color="green"> 821. class ImportedName(Expr):</font>
<font color="black"> 822.     &quot;&quot;&quot;If created with an import name the import name is returned on node</font>
<font color="black"> 823.     access.  For example ``ImportedName('cgi.escape')`` returns the `escape`</font>
<font color="black"> 824.     function from the cgi module on evaluation.  Imports are optimized by the</font>
<font color="black"> 825.     compiler so there is no need to assign them to local variables.</font>
<font color="green"> 826.     &quot;&quot;&quot;</font>
<font color="green"> 827.     fields = ('importname',)</font>
<font color="black"> 828. </font>
<font color="black"> 829. </font>
<font color="green"> 830. class InternalName(Expr):</font>
<font color="black"> 831.     &quot;&quot;&quot;An internal name in the compiler.  You cannot create these nodes</font>
<font color="black"> 832.     yourself but the parser provides a</font>
<font color="black"> 833.     :meth:`~jinja2.parser.Parser.free_identifier` method that creates</font>
<font color="black"> 834.     a new identifier for you.  This identifier is not available from the</font>
<font color="black"> 835.     template and is not threated specially by the compiler.</font>
<font color="green"> 836.     &quot;&quot;&quot;</font>
<font color="green"> 837.     fields = ('name',)</font>
<font color="black"> 838. </font>
<font color="green"> 839.     def __init__(self):</font>
<font color="red"> 840.         raise TypeError('Can\'t create internal names.  Use the '</font>
<font color="black"> 841.                         '`free_identifier` method on a parser.')</font>
<font color="black"> 842. </font>
<font color="black"> 843. </font>
<font color="green"> 844. class MarkSafe(Expr):</font>
<font color="green"> 845.     &quot;&quot;&quot;Mark the wrapped expression as safe (wrap it as `Markup`).&quot;&quot;&quot;</font>
<font color="green"> 846.     fields = ('expr',)</font>
<font color="black"> 847. </font>
<font color="green"> 848.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 849.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 850.         return Markup(self.expr.as_const(eval_ctx))</font>
<font color="black"> 851. </font>
<font color="black"> 852. </font>
<font color="green"> 853. class MarkSafeIfAutoescape(Expr):</font>
<font color="black"> 854.     &quot;&quot;&quot;Mark the wrapped expression as safe (wrap it as `Markup`) but</font>
<font color="black"> 855.     only if autoescaping is active.</font>
<font color="black"> 856. </font>
<font color="black"> 857.     .. versionadded:: 2.5</font>
<font color="green"> 858.     &quot;&quot;&quot;</font>
<font color="green"> 859.     fields = ('expr',)</font>
<font color="black"> 860. </font>
<font color="green"> 861.     def as_const(self, eval_ctx=None):</font>
<font color="red"> 862.         eval_ctx = get_eval_context(self, eval_ctx)</font>
<font color="red"> 863.         if eval_ctx.volatile:</font>
<font color="red"> 864.             raise Impossible()</font>
<font color="red"> 865.         expr = self.expr.as_const(eval_ctx)</font>
<font color="red"> 866.         if eval_ctx.autoescape:</font>
<font color="red"> 867.             return Markup(expr)</font>
<font color="red"> 868.         return expr</font>
<font color="black"> 869. </font>
<font color="black"> 870. </font>
<font color="green"> 871. class ContextReference(Expr):</font>
<font color="black"> 872.     &quot;&quot;&quot;Returns the current template context.  It can be used like a</font>
<font color="black"> 873.     :class:`Name` node, with a ``'load'`` ctx and will return the</font>
<font color="black"> 874.     current :class:`~jinja2.runtime.Context` object.</font>
<font color="black"> 875. </font>
<font color="black"> 876.     Here an example that assigns the current template name to a</font>
<font color="black"> 877.     variable named `foo`::</font>
<font color="black"> 878. </font>
<font color="black"> 879.         Assign(Name('foo', ctx='store'),</font>
<font color="black"> 880.                Getattr(ContextReference(), 'name'))</font>
<font color="green"> 881.     &quot;&quot;&quot;</font>
<font color="black"> 882. </font>
<font color="black"> 883. </font>
<font color="green"> 884. class Continue(Stmt):</font>
<font color="green"> 885.     &quot;&quot;&quot;Continue a loop.&quot;&quot;&quot;</font>
<font color="black"> 886. </font>
<font color="black"> 887. </font>
<font color="green"> 888. class Break(Stmt):</font>
<font color="green"> 889.     &quot;&quot;&quot;Break a loop.&quot;&quot;&quot;</font>
<font color="black"> 890. </font>
<font color="black"> 891. </font>
<font color="green"> 892. class Scope(Stmt):</font>
<font color="green"> 893.     &quot;&quot;&quot;An artificial scope.&quot;&quot;&quot;</font>
<font color="green"> 894.     fields = ('body',)</font>
<font color="black"> 895. </font>
<font color="black"> 896. </font>
<font color="green"> 897. class EvalContextModifier(Stmt):</font>
<font color="black"> 898.     &quot;&quot;&quot;Modifies the eval context.  For each option that should be modified,</font>
<font color="black"> 899.     a :class:`Keyword` has to be added to the :attr:`options` list.</font>
<font color="black"> 900. </font>
<font color="black"> 901.     Example to change the `autoescape` setting::</font>
<font color="black"> 902. </font>
<font color="black"> 903.         EvalContextModifier(options=[Keyword('autoescape', Const(True))])</font>
<font color="green"> 904.     &quot;&quot;&quot;</font>
<font color="green"> 905.     fields = ('options',)</font>
<font color="black"> 906. </font>
<font color="black"> 907. </font>
<font color="green"> 908. class ScopedEvalContextModifier(EvalContextModifier):</font>
<font color="black"> 909.     &quot;&quot;&quot;Modifies the eval context and reverts it later.  Works exactly like</font>
<font color="black"> 910.     :class:`EvalContextModifier` but will only modify the</font>
<font color="black"> 911.     :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.</font>
<font color="green"> 912.     &quot;&quot;&quot;</font>
<font color="green"> 913.     fields = ('body',)</font>
<font color="black"> 914. </font>
<font color="black"> 915. </font>
<font color="black"> 916. # make sure nobody creates custom nodes</font>
<font color="green"> 917. def _failing_new(*args, **kwargs):</font>
<font color="red"> 918.     raise TypeError('can\'t create custom node types')</font>
<font color="green"> 919. NodeType.__new__ = staticmethod(_failing_new); del _failing_new</font>
</pre>

