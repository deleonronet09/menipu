source file: <b>/usr/lib/python2.7/codecs.py</b><br>


file stats: <b>413 lines, 9 executed: 2.2% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot; codecs -- Python Codec Registry, API and helpers.</font>
<font color="black">   2. </font>
<font color="black">   3. </font>
<font color="black">   4. Written by Marc-Andre Lemburg (mal@lemburg.com).</font>
<font color="black">   5. </font>
<font color="black">   6. (c) Copyright CNRI, All Rights Reserved. NO WARRANTY.</font>
<font color="black">   7. </font>
<font color="red">   8. &quot;&quot;&quot;#&quot;</font>
<font color="black">   9. </font>
<font color="red">  10. import __builtin__, sys</font>
<font color="black">  11. </font>
<font color="black">  12. ### Registry and builtin stateless codec functions</font>
<font color="black">  13. </font>
<font color="red">  14. try:</font>
<font color="red">  15.     from _codecs import *</font>
<font color="red">  16. except ImportError, why:</font>
<font color="red">  17.     raise SystemError('Failed to load the builtin codecs: %s' % why)</font>
<font color="black">  18. </font>
<font color="red">  19. __all__ = [&quot;register&quot;, &quot;lookup&quot;, &quot;open&quot;, &quot;EncodedFile&quot;, &quot;BOM&quot;, &quot;BOM_BE&quot;,</font>
<font color="red">  20.            &quot;BOM_LE&quot;, &quot;BOM32_BE&quot;, &quot;BOM32_LE&quot;, &quot;BOM64_BE&quot;, &quot;BOM64_LE&quot;,</font>
<font color="red">  21.            &quot;BOM_UTF8&quot;, &quot;BOM_UTF16&quot;, &quot;BOM_UTF16_LE&quot;, &quot;BOM_UTF16_BE&quot;,</font>
<font color="red">  22.            &quot;BOM_UTF32&quot;, &quot;BOM_UTF32_LE&quot;, &quot;BOM_UTF32_BE&quot;,</font>
<font color="red">  23.            &quot;strict_errors&quot;, &quot;ignore_errors&quot;, &quot;replace_errors&quot;,</font>
<font color="red">  24.            &quot;xmlcharrefreplace_errors&quot;,</font>
<font color="red">  25.            &quot;register_error&quot;, &quot;lookup_error&quot;]</font>
<font color="black">  26. </font>
<font color="black">  27. ### Constants</font>
<font color="black">  28. </font>
<font color="black">  29. #</font>
<font color="black">  30. # Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)</font>
<font color="black">  31. # and its possible byte string values</font>
<font color="black">  32. # for UTF8/UTF16/UTF32 output and little/big endian machines</font>
<font color="black">  33. #</font>
<font color="black">  34. </font>
<font color="black">  35. # UTF-8</font>
<font color="red">  36. BOM_UTF8 = '\xef\xbb\xbf'</font>
<font color="black">  37. </font>
<font color="black">  38. # UTF-16, little endian</font>
<font color="red">  39. BOM_LE = BOM_UTF16_LE = '\xff\xfe'</font>
<font color="black">  40. </font>
<font color="black">  41. # UTF-16, big endian</font>
<font color="red">  42. BOM_BE = BOM_UTF16_BE = '\xfe\xff'</font>
<font color="black">  43. </font>
<font color="black">  44. # UTF-32, little endian</font>
<font color="red">  45. BOM_UTF32_LE = '\xff\xfe\x00\x00'</font>
<font color="black">  46. </font>
<font color="black">  47. # UTF-32, big endian</font>
<font color="red">  48. BOM_UTF32_BE = '\x00\x00\xfe\xff'</font>
<font color="black">  49. </font>
<font color="red">  50. if sys.byteorder == 'little':</font>
<font color="black">  51. </font>
<font color="black">  52.     # UTF-16, native endianness</font>
<font color="red">  53.     BOM = BOM_UTF16 = BOM_UTF16_LE</font>
<font color="black">  54. </font>
<font color="black">  55.     # UTF-32, native endianness</font>
<font color="red">  56.     BOM_UTF32 = BOM_UTF32_LE</font>
<font color="black">  57. </font>
<font color="black">  58. else:</font>
<font color="black">  59. </font>
<font color="black">  60.     # UTF-16, native endianness</font>
<font color="red">  61.     BOM = BOM_UTF16 = BOM_UTF16_BE</font>
<font color="black">  62. </font>
<font color="black">  63.     # UTF-32, native endianness</font>
<font color="red">  64.     BOM_UTF32 = BOM_UTF32_BE</font>
<font color="black">  65. </font>
<font color="black">  66. # Old broken names (don't use in new code)</font>
<font color="red">  67. BOM32_LE = BOM_UTF16_LE</font>
<font color="red">  68. BOM32_BE = BOM_UTF16_BE</font>
<font color="red">  69. BOM64_LE = BOM_UTF32_LE</font>
<font color="red">  70. BOM64_BE = BOM_UTF32_BE</font>
<font color="black">  71. </font>
<font color="black">  72. </font>
<font color="black">  73. ### Codec base classes (defining the API)</font>
<font color="black">  74. </font>
<font color="red">  75. class CodecInfo(tuple):</font>
<font color="black">  76. </font>
<font color="red">  77.     def __new__(cls, encode, decode, streamreader=None, streamwriter=None,</font>
<font color="red">  78.         incrementalencoder=None, incrementaldecoder=None, name=None):</font>
<font color="green">  79.         self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))</font>
<font color="green">  80.         self.name = name</font>
<font color="green">  81.         self.encode = encode</font>
<font color="green">  82.         self.decode = decode</font>
<font color="green">  83.         self.incrementalencoder = incrementalencoder</font>
<font color="green">  84.         self.incrementaldecoder = incrementaldecoder</font>
<font color="green">  85.         self.streamwriter = streamwriter</font>
<font color="green">  86.         self.streamreader = streamreader</font>
<font color="green">  87.         return self</font>
<font color="black">  88. </font>
<font color="red">  89.     def __repr__(self):</font>
<font color="red">  90.         return &quot;&lt;%s.%s object for encoding %s at 0x%x&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.name, id(self))</font>
<font color="black">  91. </font>
<font color="red">  92. class Codec:</font>
<font color="black">  93. </font>
<font color="black">  94.     &quot;&quot;&quot; Defines the interface for stateless encoders/decoders.</font>
<font color="black">  95. </font>
<font color="black">  96.         The .encode()/.decode() methods may use different error</font>
<font color="black">  97.         handling schemes by providing the errors argument. These</font>
<font color="black">  98.         string values are predefined:</font>
<font color="black">  99. </font>
<font color="black"> 100.          'strict' - raise a ValueError error (or a subclass)</font>
<font color="black"> 101.          'ignore' - ignore the character and continue with the next</font>
<font color="black"> 102.          'replace' - replace with a suitable replacement character;</font>
<font color="black"> 103.                     Python will use the official U+FFFD REPLACEMENT</font>
<font color="black"> 104.                     CHARACTER for the builtin Unicode codecs on</font>
<font color="black"> 105.                     decoding and '?' on encoding.</font>
<font color="black"> 106.          'xmlcharrefreplace' - Replace with the appropriate XML</font>
<font color="black"> 107.                                character reference (only for encoding).</font>
<font color="black"> 108.          'backslashreplace'  - Replace with backslashed escape sequences</font>
<font color="black"> 109.                                (only for encoding).</font>
<font color="black"> 110. </font>
<font color="black"> 111.         The set of allowed values can be extended via register_error.</font>
<font color="black"> 112. </font>
<font color="red"> 113.     &quot;&quot;&quot;</font>
<font color="red"> 114.     def encode(self, input, errors='strict'):</font>
<font color="black"> 115. </font>
<font color="black"> 116.         &quot;&quot;&quot; Encodes the object input and returns a tuple (output</font>
<font color="black"> 117.             object, length consumed).</font>
<font color="black"> 118. </font>
<font color="black"> 119.             errors defines the error handling to apply. It defaults to</font>
<font color="black"> 120.             'strict' handling.</font>
<font color="black"> 121. </font>
<font color="black"> 122.             The method may not store state in the Codec instance. Use</font>
<font color="black"> 123.             StreamCodec for codecs which have to keep state in order to</font>
<font color="black"> 124.             make encoding/decoding efficient.</font>
<font color="black"> 125. </font>
<font color="black"> 126.             The encoder must be able to handle zero length input and</font>
<font color="black"> 127.             return an empty object of the output object type in this</font>
<font color="black"> 128.             situation.</font>
<font color="black"> 129. </font>
<font color="black"> 130.         &quot;&quot;&quot;</font>
<font color="red"> 131.         raise NotImplementedError</font>
<font color="black"> 132. </font>
<font color="red"> 133.     def decode(self, input, errors='strict'):</font>
<font color="black"> 134. </font>
<font color="black"> 135.         &quot;&quot;&quot; Decodes the object input and returns a tuple (output</font>
<font color="black"> 136.             object, length consumed).</font>
<font color="black"> 137. </font>
<font color="black"> 138.             input must be an object which provides the bf_getreadbuf</font>
<font color="black"> 139.             buffer slot. Python strings, buffer objects and memory</font>
<font color="black"> 140.             mapped files are examples of objects providing this slot.</font>
<font color="black"> 141. </font>
<font color="black"> 142.             errors defines the error handling to apply. It defaults to</font>
<font color="black"> 143.             'strict' handling.</font>
<font color="black"> 144. </font>
<font color="black"> 145.             The method may not store state in the Codec instance. Use</font>
<font color="black"> 146.             StreamCodec for codecs which have to keep state in order to</font>
<font color="black"> 147.             make encoding/decoding efficient.</font>
<font color="black"> 148. </font>
<font color="black"> 149.             The decoder must be able to handle zero length input and</font>
<font color="black"> 150.             return an empty object of the output object type in this</font>
<font color="black"> 151.             situation.</font>
<font color="black"> 152. </font>
<font color="black"> 153.         &quot;&quot;&quot;</font>
<font color="red"> 154.         raise NotImplementedError</font>
<font color="black"> 155. </font>
<font color="red"> 156. class IncrementalEncoder(object):</font>
<font color="black"> 157.     &quot;&quot;&quot;</font>
<font color="black"> 158.     An IncrementalEncoder encodes an input in multiple steps. The input can be</font>
<font color="black"> 159.     passed piece by piece to the encode() method. The IncrementalEncoder remembers</font>
<font color="black"> 160.     the state of the Encoding process between calls to encode().</font>
<font color="red"> 161.     &quot;&quot;&quot;</font>
<font color="red"> 162.     def __init__(self, errors='strict'):</font>
<font color="black"> 163.         &quot;&quot;&quot;</font>
<font color="black"> 164.         Creates an IncrementalEncoder instance.</font>
<font color="black"> 165. </font>
<font color="black"> 166.         The IncrementalEncoder may use different error handling schemes by</font>
<font color="black"> 167.         providing the errors keyword argument. See the module docstring</font>
<font color="black"> 168.         for a list of possible values.</font>
<font color="black"> 169.         &quot;&quot;&quot;</font>
<font color="red"> 170.         self.errors = errors</font>
<font color="red"> 171.         self.buffer = &quot;&quot;</font>
<font color="black"> 172. </font>
<font color="red"> 173.     def encode(self, input, final=False):</font>
<font color="black"> 174.         &quot;&quot;&quot;</font>
<font color="black"> 175.         Encodes input and returns the resulting object.</font>
<font color="black"> 176.         &quot;&quot;&quot;</font>
<font color="red"> 177.         raise NotImplementedError</font>
<font color="black"> 178. </font>
<font color="red"> 179.     def reset(self):</font>
<font color="black"> 180.         &quot;&quot;&quot;</font>
<font color="black"> 181.         Resets the encoder to the initial state.</font>
<font color="black"> 182.         &quot;&quot;&quot;</font>
<font color="black"> 183. </font>
<font color="red"> 184.     def getstate(self):</font>
<font color="black"> 185.         &quot;&quot;&quot;</font>
<font color="black"> 186.         Return the current state of the encoder.</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="red"> 188.         return 0</font>
<font color="black"> 189. </font>
<font color="red"> 190.     def setstate(self, state):</font>
<font color="black"> 191.         &quot;&quot;&quot;</font>
<font color="black"> 192.         Set the current state of the encoder. state must have been</font>
<font color="black"> 193.         returned by getstate().</font>
<font color="black"> 194.         &quot;&quot;&quot;</font>
<font color="black"> 195. </font>
<font color="red"> 196. class BufferedIncrementalEncoder(IncrementalEncoder):</font>
<font color="black"> 197.     &quot;&quot;&quot;</font>
<font color="black"> 198.     This subclass of IncrementalEncoder can be used as the baseclass for an</font>
<font color="black"> 199.     incremental encoder if the encoder must keep some of the output in a</font>
<font color="black"> 200.     buffer between calls to encode().</font>
<font color="red"> 201.     &quot;&quot;&quot;</font>
<font color="red"> 202.     def __init__(self, errors='strict'):</font>
<font color="red"> 203.         IncrementalEncoder.__init__(self, errors)</font>
<font color="red"> 204.         self.buffer = &quot;&quot; # unencoded input that is kept between calls to encode()</font>
<font color="black"> 205. </font>
<font color="red"> 206.     def _buffer_encode(self, input, errors, final):</font>
<font color="black"> 207.         # Overwrite this method in subclasses: It must encode input</font>
<font color="black"> 208.         # and return an (output, length consumed) tuple</font>
<font color="red"> 209.         raise NotImplementedError</font>
<font color="black"> 210. </font>
<font color="red"> 211.     def encode(self, input, final=False):</font>
<font color="black"> 212.         # encode input (taking the buffer into account)</font>
<font color="red"> 213.         data = self.buffer + input</font>
<font color="red"> 214.         (result, consumed) = self._buffer_encode(data, self.errors, final)</font>
<font color="black"> 215.         # keep unencoded input until the next call</font>
<font color="red"> 216.         self.buffer = data[consumed:]</font>
<font color="red"> 217.         return result</font>
<font color="black"> 218. </font>
<font color="red"> 219.     def reset(self):</font>
<font color="red"> 220.         IncrementalEncoder.reset(self)</font>
<font color="red"> 221.         self.buffer = &quot;&quot;</font>
<font color="black"> 222. </font>
<font color="red"> 223.     def getstate(self):</font>
<font color="red"> 224.         return self.buffer or 0</font>
<font color="black"> 225. </font>
<font color="red"> 226.     def setstate(self, state):</font>
<font color="red"> 227.         self.buffer = state or &quot;&quot;</font>
<font color="black"> 228. </font>
<font color="red"> 229. class IncrementalDecoder(object):</font>
<font color="black"> 230.     &quot;&quot;&quot;</font>
<font color="black"> 231.     An IncrementalDecoder decodes an input in multiple steps. The input can be</font>
<font color="black"> 232.     passed piece by piece to the decode() method. The IncrementalDecoder</font>
<font color="black"> 233.     remembers the state of the decoding process between calls to decode().</font>
<font color="red"> 234.     &quot;&quot;&quot;</font>
<font color="red"> 235.     def __init__(self, errors='strict'):</font>
<font color="black"> 236.         &quot;&quot;&quot;</font>
<font color="black"> 237.         Creates a IncrementalDecoder instance.</font>
<font color="black"> 238. </font>
<font color="black"> 239.         The IncrementalDecoder may use different error handling schemes by</font>
<font color="black"> 240.         providing the errors keyword argument. See the module docstring</font>
<font color="black"> 241.         for a list of possible values.</font>
<font color="black"> 242.         &quot;&quot;&quot;</font>
<font color="red"> 243.         self.errors = errors</font>
<font color="black"> 244. </font>
<font color="red"> 245.     def decode(self, input, final=False):</font>
<font color="black"> 246.         &quot;&quot;&quot;</font>
<font color="black"> 247.         Decodes input and returns the resulting object.</font>
<font color="black"> 248.         &quot;&quot;&quot;</font>
<font color="red"> 249.         raise NotImplementedError</font>
<font color="black"> 250. </font>
<font color="red"> 251.     def reset(self):</font>
<font color="black"> 252.         &quot;&quot;&quot;</font>
<font color="black"> 253.         Resets the decoder to the initial state.</font>
<font color="black"> 254.         &quot;&quot;&quot;</font>
<font color="black"> 255. </font>
<font color="red"> 256.     def getstate(self):</font>
<font color="black"> 257.         &quot;&quot;&quot;</font>
<font color="black"> 258.         Return the current state of the decoder.</font>
<font color="black"> 259. </font>
<font color="black"> 260.         This must be a (buffered_input, additional_state_info) tuple.</font>
<font color="black"> 261.         buffered_input must be a bytes object containing bytes that</font>
<font color="black"> 262.         were passed to decode() that have not yet been converted.</font>
<font color="black"> 263.         additional_state_info must be a non-negative integer</font>
<font color="black"> 264.         representing the state of the decoder WITHOUT yet having</font>
<font color="black"> 265.         processed the contents of buffered_input.  In the initial state</font>
<font color="black"> 266.         and after reset(), getstate() must return (b&quot;&quot;, 0).</font>
<font color="black"> 267.         &quot;&quot;&quot;</font>
<font color="red"> 268.         return (b&quot;&quot;, 0)</font>
<font color="black"> 269. </font>
<font color="red"> 270.     def setstate(self, state):</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="black"> 272.         Set the current state of the decoder.</font>
<font color="black"> 273. </font>
<font color="black"> 274.         state must have been returned by getstate().  The effect of</font>
<font color="black"> 275.         setstate((b&quot;&quot;, 0)) must be equivalent to reset().</font>
<font color="black"> 276.         &quot;&quot;&quot;</font>
<font color="black"> 277. </font>
<font color="red"> 278. class BufferedIncrementalDecoder(IncrementalDecoder):</font>
<font color="black"> 279.     &quot;&quot;&quot;</font>
<font color="black"> 280.     This subclass of IncrementalDecoder can be used as the baseclass for an</font>
<font color="black"> 281.     incremental decoder if the decoder must be able to handle incomplete byte</font>
<font color="black"> 282.     sequences.</font>
<font color="red"> 283.     &quot;&quot;&quot;</font>
<font color="red"> 284.     def __init__(self, errors='strict'):</font>
<font color="red"> 285.         IncrementalDecoder.__init__(self, errors)</font>
<font color="red"> 286.         self.buffer = &quot;&quot; # undecoded input that is kept between calls to decode()</font>
<font color="black"> 287. </font>
<font color="red"> 288.     def _buffer_decode(self, input, errors, final):</font>
<font color="black"> 289.         # Overwrite this method in subclasses: It must decode input</font>
<font color="black"> 290.         # and return an (output, length consumed) tuple</font>
<font color="red"> 291.         raise NotImplementedError</font>
<font color="black"> 292. </font>
<font color="red"> 293.     def decode(self, input, final=False):</font>
<font color="black"> 294.         # decode input (taking the buffer into account)</font>
<font color="red"> 295.         data = self.buffer + input</font>
<font color="red"> 296.         (result, consumed) = self._buffer_decode(data, self.errors, final)</font>
<font color="black"> 297.         # keep undecoded input until the next call</font>
<font color="red"> 298.         self.buffer = data[consumed:]</font>
<font color="red"> 299.         return result</font>
<font color="black"> 300. </font>
<font color="red"> 301.     def reset(self):</font>
<font color="red"> 302.         IncrementalDecoder.reset(self)</font>
<font color="red"> 303.         self.buffer = &quot;&quot;</font>
<font color="black"> 304. </font>
<font color="red"> 305.     def getstate(self):</font>
<font color="black"> 306.         # additional state info is always 0</font>
<font color="red"> 307.         return (self.buffer, 0)</font>
<font color="black"> 308. </font>
<font color="red"> 309.     def setstate(self, state):</font>
<font color="black"> 310.         # ignore additional state info</font>
<font color="red"> 311.         self.buffer = state[0]</font>
<font color="black"> 312. </font>
<font color="black"> 313. #</font>
<font color="black"> 314. # The StreamWriter and StreamReader class provide generic working</font>
<font color="black"> 315. # interfaces which can be used to implement new encoding submodules</font>
<font color="black"> 316. # very easily. See encodings/utf_8.py for an example on how this is</font>
<font color="black"> 317. # done.</font>
<font color="black"> 318. #</font>
<font color="black"> 319. </font>
<font color="red"> 320. class StreamWriter(Codec):</font>
<font color="black"> 321. </font>
<font color="red"> 322.     def __init__(self, stream, errors='strict'):</font>
<font color="black"> 323. </font>
<font color="black"> 324.         &quot;&quot;&quot; Creates a StreamWriter instance.</font>
<font color="black"> 325. </font>
<font color="black"> 326.             stream must be a file-like object open for writing</font>
<font color="black"> 327.             (binary) data.</font>
<font color="black"> 328. </font>
<font color="black"> 329.             The StreamWriter may use different error handling</font>
<font color="black"> 330.             schemes by providing the errors keyword argument. These</font>
<font color="black"> 331.             parameters are predefined:</font>
<font color="black"> 332. </font>
<font color="black"> 333.              'strict' - raise a ValueError (or a subclass)</font>
<font color="black"> 334.              'ignore' - ignore the character and continue with the next</font>
<font color="black"> 335.              'replace'- replace with a suitable replacement character</font>
<font color="black"> 336.              'xmlcharrefreplace' - Replace with the appropriate XML</font>
<font color="black"> 337.                                    character reference.</font>
<font color="black"> 338.              'backslashreplace'  - Replace with backslashed escape</font>
<font color="black"> 339.                                    sequences (only for encoding).</font>
<font color="black"> 340. </font>
<font color="black"> 341.             The set of allowed parameter values can be extended via</font>
<font color="black"> 342.             register_error.</font>
<font color="black"> 343.         &quot;&quot;&quot;</font>
<font color="red"> 344.         self.stream = stream</font>
<font color="red"> 345.         self.errors = errors</font>
<font color="black"> 346. </font>
<font color="red"> 347.     def write(self, object):</font>
<font color="black"> 348. </font>
<font color="black"> 349.         &quot;&quot;&quot; Writes the object's contents encoded to self.stream.</font>
<font color="black"> 350.         &quot;&quot;&quot;</font>
<font color="red"> 351.         data, consumed = self.encode(object, self.errors)</font>
<font color="red"> 352.         self.stream.write(data)</font>
<font color="black"> 353. </font>
<font color="red"> 354.     def writelines(self, list):</font>
<font color="black"> 355. </font>
<font color="black"> 356.         &quot;&quot;&quot; Writes the concatenated list of strings to the stream</font>
<font color="black"> 357.             using .write().</font>
<font color="black"> 358.         &quot;&quot;&quot;</font>
<font color="red"> 359.         self.write(''.join(list))</font>
<font color="black"> 360. </font>
<font color="red"> 361.     def reset(self):</font>
<font color="black"> 362. </font>
<font color="black"> 363.         &quot;&quot;&quot; Flushes and resets the codec buffers used for keeping state.</font>
<font color="black"> 364. </font>
<font color="black"> 365.             Calling this method should ensure that the data on the</font>
<font color="black"> 366.             output is put into a clean state, that allows appending</font>
<font color="black"> 367.             of new fresh data without having to rescan the whole</font>
<font color="black"> 368.             stream to recover state.</font>
<font color="black"> 369. </font>
<font color="black"> 370.         &quot;&quot;&quot;</font>
<font color="red"> 371.         pass</font>
<font color="black"> 372. </font>
<font color="red"> 373.     def seek(self, offset, whence=0):</font>
<font color="red"> 374.         self.stream.seek(offset, whence)</font>
<font color="red"> 375.         if whence == 0 and offset == 0:</font>
<font color="red"> 376.             self.reset()</font>
<font color="black"> 377. </font>
<font color="black"> 378.     def __getattr__(self, name,</font>
<font color="red"> 379.                     getattr=getattr):</font>
<font color="black"> 380. </font>
<font color="black"> 381.         &quot;&quot;&quot; Inherit all other methods from the underlying stream.</font>
<font color="black"> 382.         &quot;&quot;&quot;</font>
<font color="red"> 383.         return getattr(self.stream, name)</font>
<font color="black"> 384. </font>
<font color="red"> 385.     def __enter__(self):</font>
<font color="red"> 386.         return self</font>
<font color="black"> 387. </font>
<font color="red"> 388.     def __exit__(self, type, value, tb):</font>
<font color="red"> 389.         self.stream.close()</font>
<font color="black"> 390. </font>
<font color="black"> 391. ###</font>
<font color="black"> 392. </font>
<font color="red"> 393. class StreamReader(Codec):</font>
<font color="black"> 394. </font>
<font color="red"> 395.     def __init__(self, stream, errors='strict'):</font>
<font color="black"> 396. </font>
<font color="black"> 397.         &quot;&quot;&quot; Creates a StreamReader instance.</font>
<font color="black"> 398. </font>
<font color="black"> 399.             stream must be a file-like object open for reading</font>
<font color="black"> 400.             (binary) data.</font>
<font color="black"> 401. </font>
<font color="black"> 402.             The StreamReader may use different error handling</font>
<font color="black"> 403.             schemes by providing the errors keyword argument. These</font>
<font color="black"> 404.             parameters are predefined:</font>
<font color="black"> 405. </font>
<font color="black"> 406.              'strict' - raise a ValueError (or a subclass)</font>
<font color="black"> 407.              'ignore' - ignore the character and continue with the next</font>
<font color="black"> 408.              'replace'- replace with a suitable replacement character;</font>
<font color="black"> 409. </font>
<font color="black"> 410.             The set of allowed parameter values can be extended via</font>
<font color="black"> 411.             register_error.</font>
<font color="black"> 412.         &quot;&quot;&quot;</font>
<font color="red"> 413.         self.stream = stream</font>
<font color="red"> 414.         self.errors = errors</font>
<font color="red"> 415.         self.bytebuffer = &quot;&quot;</font>
<font color="black"> 416.         # For str-&gt;str decoding this will stay a str</font>
<font color="black"> 417.         # For str-&gt;unicode decoding the first read will promote it to unicode</font>
<font color="red"> 418.         self.charbuffer = &quot;&quot;</font>
<font color="red"> 419.         self.linebuffer = None</font>
<font color="black"> 420. </font>
<font color="red"> 421.     def decode(self, input, errors='strict'):</font>
<font color="red"> 422.         raise NotImplementedError</font>
<font color="black"> 423. </font>
<font color="red"> 424.     def read(self, size=-1, chars=-1, firstline=False):</font>
<font color="black"> 425. </font>
<font color="black"> 426.         &quot;&quot;&quot; Decodes data from the stream self.stream and returns the</font>
<font color="black"> 427.             resulting object.</font>
<font color="black"> 428. </font>
<font color="black"> 429.             chars indicates the number of characters to read from the</font>
<font color="black"> 430.             stream. read() will never return more than chars</font>
<font color="black"> 431.             characters, but it might return less, if there are not enough</font>
<font color="black"> 432.             characters available.</font>
<font color="black"> 433. </font>
<font color="black"> 434.             size indicates the approximate maximum number of bytes to</font>
<font color="black"> 435.             read from the stream for decoding purposes. The decoder</font>
<font color="black"> 436.             can modify this setting as appropriate. The default value</font>
<font color="black"> 437.             -1 indicates to read and decode as much as possible.  size</font>
<font color="black"> 438.             is intended to prevent having to decode huge files in one</font>
<font color="black"> 439.             step.</font>
<font color="black"> 440. </font>
<font color="black"> 441.             If firstline is true, and a UnicodeDecodeError happens</font>
<font color="black"> 442.             after the first line terminator in the input only the first line</font>
<font color="black"> 443.             will be returned, the rest of the input will be kept until the</font>
<font color="black"> 444.             next call to read().</font>
<font color="black"> 445. </font>
<font color="black"> 446.             The method should use a greedy read strategy meaning that</font>
<font color="black"> 447.             it should read as much data as is allowed within the</font>
<font color="black"> 448.             definition of the encoding and the given size, e.g.  if</font>
<font color="black"> 449.             optional encoding endings or state markers are available</font>
<font color="black"> 450.             on the stream, these should be read too.</font>
<font color="black"> 451.         &quot;&quot;&quot;</font>
<font color="black"> 452.         # If we have lines cached, first merge them back into characters</font>
<font color="red"> 453.         if self.linebuffer:</font>
<font color="red"> 454.             self.charbuffer = &quot;&quot;.join(self.linebuffer)</font>
<font color="red"> 455.             self.linebuffer = None</font>
<font color="black"> 456. </font>
<font color="black"> 457.         # read until we get the required number of characters (if available)</font>
<font color="red"> 458.         while True:</font>
<font color="black"> 459.             # can the request be satisfied from the character buffer?</font>
<font color="red"> 460.             if chars &gt;= 0:</font>
<font color="red"> 461.                 if len(self.charbuffer) &gt;= chars:</font>
<font color="red"> 462.                     break</font>
<font color="red"> 463.             elif size &gt;= 0:</font>
<font color="red"> 464.                 if len(self.charbuffer) &gt;= size:</font>
<font color="red"> 465.                     break</font>
<font color="black"> 466.             # we need more data</font>
<font color="red"> 467.             if size &lt; 0:</font>
<font color="red"> 468.                 newdata = self.stream.read()</font>
<font color="black"> 469.             else:</font>
<font color="red"> 470.                 newdata = self.stream.read(size)</font>
<font color="black"> 471.             # decode bytes (those remaining from the last call included)</font>
<font color="red"> 472.             data = self.bytebuffer + newdata</font>
<font color="red"> 473.             try:</font>
<font color="red"> 474.                 newchars, decodedbytes = self.decode(data, self.errors)</font>
<font color="red"> 475.             except UnicodeDecodeError, exc:</font>
<font color="red"> 476.                 if firstline:</font>
<font color="red"> 477.                     newchars, decodedbytes = self.decode(data[:exc.start], self.errors)</font>
<font color="red"> 478.                     lines = newchars.splitlines(True)</font>
<font color="red"> 479.                     if len(lines)&lt;=1:</font>
<font color="red"> 480.                         raise</font>
<font color="black"> 481.                 else:</font>
<font color="red"> 482.                     raise</font>
<font color="black"> 483.             # keep undecoded bytes until the next call</font>
<font color="red"> 484.             self.bytebuffer = data[decodedbytes:]</font>
<font color="black"> 485.             # put new characters in the character buffer</font>
<font color="red"> 486.             self.charbuffer += newchars</font>
<font color="black"> 487.             # there was no data available</font>
<font color="red"> 488.             if not newdata:</font>
<font color="red"> 489.                 break</font>
<font color="red"> 490.         if chars &lt; 0:</font>
<font color="black"> 491.             # Return everything we've got</font>
<font color="red"> 492.             result = self.charbuffer</font>
<font color="red"> 493.             self.charbuffer = &quot;&quot;</font>
<font color="black"> 494.         else:</font>
<font color="black"> 495.             # Return the first chars characters</font>
<font color="red"> 496.             result = self.charbuffer[:chars]</font>
<font color="red"> 497.             self.charbuffer = self.charbuffer[chars:]</font>
<font color="red"> 498.         return result</font>
<font color="black"> 499. </font>
<font color="red"> 500.     def readline(self, size=None, keepends=True):</font>
<font color="black"> 501. </font>
<font color="black"> 502.         &quot;&quot;&quot; Read one line from the input stream and return the</font>
<font color="black"> 503.             decoded data.</font>
<font color="black"> 504. </font>
<font color="black"> 505.             size, if given, is passed as size argument to the</font>
<font color="black"> 506.             read() method.</font>
<font color="black"> 507. </font>
<font color="black"> 508.         &quot;&quot;&quot;</font>
<font color="black"> 509.         # If we have lines cached from an earlier read, return</font>
<font color="black"> 510.         # them unconditionally</font>
<font color="red"> 511.         if self.linebuffer:</font>
<font color="red"> 512.             line = self.linebuffer[0]</font>
<font color="red"> 513.             del self.linebuffer[0]</font>
<font color="red"> 514.             if len(self.linebuffer) == 1:</font>
<font color="black"> 515.                 # revert to charbuffer mode; we might need more data</font>
<font color="black"> 516.                 # next time</font>
<font color="red"> 517.                 self.charbuffer = self.linebuffer[0]</font>
<font color="red"> 518.                 self.linebuffer = None</font>
<font color="red"> 519.             if not keepends:</font>
<font color="red"> 520.                 line = line.splitlines(False)[0]</font>
<font color="red"> 521.             return line</font>
<font color="black"> 522. </font>
<font color="red"> 523.         readsize = size or 72</font>
<font color="red"> 524.         line = &quot;&quot;</font>
<font color="black"> 525.         # If size is given, we call read() only once</font>
<font color="red"> 526.         while True:</font>
<font color="red"> 527.             data = self.read(readsize, firstline=True)</font>
<font color="red"> 528.             if data:</font>
<font color="black"> 529.                 # If we're at a &quot;\r&quot; read one extra character (which might</font>
<font color="black"> 530.                 # be a &quot;\n&quot;) to get a proper line ending. If the stream is</font>
<font color="black"> 531.                 # temporarily exhausted we return the wrong line ending.</font>
<font color="red"> 532.                 if data.endswith(&quot;\r&quot;):</font>
<font color="red"> 533.                     data += self.read(size=1, chars=1)</font>
<font color="black"> 534. </font>
<font color="red"> 535.             line += data</font>
<font color="red"> 536.             lines = line.splitlines(True)</font>
<font color="red"> 537.             if lines:</font>
<font color="red"> 538.                 if len(lines) &gt; 1:</font>
<font color="black"> 539.                     # More than one line result; the first line is a full line</font>
<font color="black"> 540.                     # to return</font>
<font color="red"> 541.                     line = lines[0]</font>
<font color="red"> 542.                     del lines[0]</font>
<font color="red"> 543.                     if len(lines) &gt; 1:</font>
<font color="black"> 544.                         # cache the remaining lines</font>
<font color="red"> 545.                         lines[-1] += self.charbuffer</font>
<font color="red"> 546.                         self.linebuffer = lines</font>
<font color="red"> 547.                         self.charbuffer = None</font>
<font color="black"> 548.                     else:</font>
<font color="black"> 549.                         # only one remaining line, put it back into charbuffer</font>
<font color="red"> 550.                         self.charbuffer = lines[0] + self.charbuffer</font>
<font color="red"> 551.                     if not keepends:</font>
<font color="red"> 552.                         line = line.splitlines(False)[0]</font>
<font color="red"> 553.                     break</font>
<font color="red"> 554.                 line0withend = lines[0]</font>
<font color="red"> 555.                 line0withoutend = lines[0].splitlines(False)[0]</font>
<font color="red"> 556.                 if line0withend != line0withoutend: # We really have a line end</font>
<font color="black"> 557.                     # Put the rest back together and keep it until the next call</font>
<font color="red"> 558.                     self.charbuffer = &quot;&quot;.join(lines[1:]) + self.charbuffer</font>
<font color="red"> 559.                     if keepends:</font>
<font color="red"> 560.                         line = line0withend</font>
<font color="black"> 561.                     else:</font>
<font color="red"> 562.                         line = line0withoutend</font>
<font color="red"> 563.                     break</font>
<font color="black"> 564.             # we didn't get anything or this was our only try</font>
<font color="red"> 565.             if not data or size is not None:</font>
<font color="red"> 566.                 if line and not keepends:</font>
<font color="red"> 567.                     line = line.splitlines(False)[0]</font>
<font color="red"> 568.                 break</font>
<font color="red"> 569.             if readsize&lt;8000:</font>
<font color="red"> 570.                 readsize *= 2</font>
<font color="red"> 571.         return line</font>
<font color="black"> 572. </font>
<font color="red"> 573.     def readlines(self, sizehint=None, keepends=True):</font>
<font color="black"> 574. </font>
<font color="black"> 575.         &quot;&quot;&quot; Read all lines available on the input stream</font>
<font color="black"> 576.             and return them as list of lines.</font>
<font color="black"> 577. </font>
<font color="black"> 578.             Line breaks are implemented using the codec's decoder</font>
<font color="black"> 579.             method and are included in the list entries.</font>
<font color="black"> 580. </font>
<font color="black"> 581.             sizehint, if given, is ignored since there is no efficient</font>
<font color="black"> 582.             way to finding the true end-of-line.</font>
<font color="black"> 583. </font>
<font color="black"> 584.         &quot;&quot;&quot;</font>
<font color="red"> 585.         data = self.read()</font>
<font color="red"> 586.         return data.splitlines(keepends)</font>
<font color="black"> 587. </font>
<font color="red"> 588.     def reset(self):</font>
<font color="black"> 589. </font>
<font color="black"> 590.         &quot;&quot;&quot; Resets the codec buffers used for keeping state.</font>
<font color="black"> 591. </font>
<font color="black"> 592.             Note that no stream repositioning should take place.</font>
<font color="black"> 593.             This method is primarily intended to be able to recover</font>
<font color="black"> 594.             from decoding errors.</font>
<font color="black"> 595. </font>
<font color="black"> 596.         &quot;&quot;&quot;</font>
<font color="red"> 597.         self.bytebuffer = &quot;&quot;</font>
<font color="red"> 598.         self.charbuffer = u&quot;&quot;</font>
<font color="red"> 599.         self.linebuffer = None</font>
<font color="black"> 600. </font>
<font color="red"> 601.     def seek(self, offset, whence=0):</font>
<font color="black"> 602.         &quot;&quot;&quot; Set the input stream's current position.</font>
<font color="black"> 603. </font>
<font color="black"> 604.             Resets the codec buffers used for keeping state.</font>
<font color="black"> 605.         &quot;&quot;&quot;</font>
<font color="red"> 606.         self.stream.seek(offset, whence)</font>
<font color="red"> 607.         self.reset()</font>
<font color="black"> 608. </font>
<font color="red"> 609.     def next(self):</font>
<font color="black"> 610. </font>
<font color="black"> 611.         &quot;&quot;&quot; Return the next decoded line from the input stream.&quot;&quot;&quot;</font>
<font color="red"> 612.         line = self.readline()</font>
<font color="red"> 613.         if line:</font>
<font color="red"> 614.             return line</font>
<font color="red"> 615.         raise StopIteration</font>
<font color="black"> 616. </font>
<font color="red"> 617.     def __iter__(self):</font>
<font color="red"> 618.         return self</font>
<font color="black"> 619. </font>
<font color="black"> 620.     def __getattr__(self, name,</font>
<font color="red"> 621.                     getattr=getattr):</font>
<font color="black"> 622. </font>
<font color="black"> 623.         &quot;&quot;&quot; Inherit all other methods from the underlying stream.</font>
<font color="black"> 624.         &quot;&quot;&quot;</font>
<font color="red"> 625.         return getattr(self.stream, name)</font>
<font color="black"> 626. </font>
<font color="red"> 627.     def __enter__(self):</font>
<font color="red"> 628.         return self</font>
<font color="black"> 629. </font>
<font color="red"> 630.     def __exit__(self, type, value, tb):</font>
<font color="red"> 631.         self.stream.close()</font>
<font color="black"> 632. </font>
<font color="black"> 633. ###</font>
<font color="black"> 634. </font>
<font color="red"> 635. class StreamReaderWriter:</font>
<font color="black"> 636. </font>
<font color="black"> 637.     &quot;&quot;&quot; StreamReaderWriter instances allow wrapping streams which</font>
<font color="black"> 638.         work in both read and write modes.</font>
<font color="black"> 639. </font>
<font color="black"> 640.         The design is such that one can use the factory functions</font>
<font color="black"> 641.         returned by the codec.lookup() function to construct the</font>
<font color="black"> 642.         instance.</font>
<font color="black"> 643. </font>
<font color="red"> 644.     &quot;&quot;&quot;</font>
<font color="black"> 645.     # Optional attributes set by the file wrappers below</font>
<font color="red"> 646.     encoding = 'unknown'</font>
<font color="black"> 647. </font>
<font color="red"> 648.     def __init__(self, stream, Reader, Writer, errors='strict'):</font>
<font color="black"> 649. </font>
<font color="black"> 650.         &quot;&quot;&quot; Creates a StreamReaderWriter instance.</font>
<font color="black"> 651. </font>
<font color="black"> 652.             stream must be a Stream-like object.</font>
<font color="black"> 653. </font>
<font color="black"> 654.             Reader, Writer must be factory functions or classes</font>
<font color="black"> 655.             providing the StreamReader, StreamWriter interface resp.</font>
<font color="black"> 656. </font>
<font color="black"> 657.             Error handling is done in the same way as defined for the</font>
<font color="black"> 658.             StreamWriter/Readers.</font>
<font color="black"> 659. </font>
<font color="black"> 660.         &quot;&quot;&quot;</font>
<font color="red"> 661.         self.stream = stream</font>
<font color="red"> 662.         self.reader = Reader(stream, errors)</font>
<font color="red"> 663.         self.writer = Writer(stream, errors)</font>
<font color="red"> 664.         self.errors = errors</font>
<font color="black"> 665. </font>
<font color="red"> 666.     def read(self, size=-1):</font>
<font color="black"> 667. </font>
<font color="red"> 668.         return self.reader.read(size)</font>
<font color="black"> 669. </font>
<font color="red"> 670.     def readline(self, size=None):</font>
<font color="black"> 671. </font>
<font color="red"> 672.         return self.reader.readline(size)</font>
<font color="black"> 673. </font>
<font color="red"> 674.     def readlines(self, sizehint=None):</font>
<font color="black"> 675. </font>
<font color="red"> 676.         return self.reader.readlines(sizehint)</font>
<font color="black"> 677. </font>
<font color="red"> 678.     def next(self):</font>
<font color="black"> 679. </font>
<font color="black"> 680.         &quot;&quot;&quot; Return the next decoded line from the input stream.&quot;&quot;&quot;</font>
<font color="red"> 681.         return self.reader.next()</font>
<font color="black"> 682. </font>
<font color="red"> 683.     def __iter__(self):</font>
<font color="red"> 684.         return self</font>
<font color="black"> 685. </font>
<font color="red"> 686.     def write(self, data):</font>
<font color="black"> 687. </font>
<font color="red"> 688.         return self.writer.write(data)</font>
<font color="black"> 689. </font>
<font color="red"> 690.     def writelines(self, list):</font>
<font color="black"> 691. </font>
<font color="red"> 692.         return self.writer.writelines(list)</font>
<font color="black"> 693. </font>
<font color="red"> 694.     def reset(self):</font>
<font color="black"> 695. </font>
<font color="red"> 696.         self.reader.reset()</font>
<font color="red"> 697.         self.writer.reset()</font>
<font color="black"> 698. </font>
<font color="red"> 699.     def seek(self, offset, whence=0):</font>
<font color="red"> 700.         self.stream.seek(offset, whence)</font>
<font color="red"> 701.         self.reader.reset()</font>
<font color="red"> 702.         if whence == 0 and offset == 0:</font>
<font color="red"> 703.             self.writer.reset()</font>
<font color="black"> 704. </font>
<font color="black"> 705.     def __getattr__(self, name,</font>
<font color="red"> 706.                     getattr=getattr):</font>
<font color="black"> 707. </font>
<font color="black"> 708.         &quot;&quot;&quot; Inherit all other methods from the underlying stream.</font>
<font color="black"> 709.         &quot;&quot;&quot;</font>
<font color="red"> 710.         return getattr(self.stream, name)</font>
<font color="black"> 711. </font>
<font color="black"> 712.     # these are needed to make &quot;with codecs.open(...)&quot; work properly</font>
<font color="black"> 713. </font>
<font color="red"> 714.     def __enter__(self):</font>
<font color="red"> 715.         return self</font>
<font color="black"> 716. </font>
<font color="red"> 717.     def __exit__(self, type, value, tb):</font>
<font color="red"> 718.         self.stream.close()</font>
<font color="black"> 719. </font>
<font color="black"> 720. ###</font>
<font color="black"> 721. </font>
<font color="red"> 722. class StreamRecoder:</font>
<font color="black"> 723. </font>
<font color="black"> 724.     &quot;&quot;&quot; StreamRecoder instances provide a frontend - backend</font>
<font color="black"> 725.         view of encoding data.</font>
<font color="black"> 726. </font>
<font color="black"> 727.         They use the complete set of APIs returned by the</font>
<font color="black"> 728.         codecs.lookup() function to implement their task.</font>
<font color="black"> 729. </font>
<font color="black"> 730.         Data written to the stream is first decoded into an</font>
<font color="black"> 731.         intermediate format (which is dependent on the given codec</font>
<font color="black"> 732.         combination) and then written to the stream using an instance</font>
<font color="black"> 733.         of the provided Writer class.</font>
<font color="black"> 734. </font>
<font color="black"> 735.         In the other direction, data is read from the stream using a</font>
<font color="black"> 736.         Reader instance and then return encoded data to the caller.</font>
<font color="black"> 737. </font>
<font color="red"> 738.     &quot;&quot;&quot;</font>
<font color="black"> 739.     # Optional attributes set by the file wrappers below</font>
<font color="red"> 740.     data_encoding = 'unknown'</font>
<font color="red"> 741.     file_encoding = 'unknown'</font>
<font color="black"> 742. </font>
<font color="black"> 743.     def __init__(self, stream, encode, decode, Reader, Writer,</font>
<font color="red"> 744.                  errors='strict'):</font>
<font color="black"> 745. </font>
<font color="black"> 746.         &quot;&quot;&quot; Creates a StreamRecoder instance which implements a two-way</font>
<font color="black"> 747.             conversion: encode and decode work on the frontend (the</font>
<font color="black"> 748.             input to .read() and output of .write()) while</font>
<font color="black"> 749.             Reader and Writer work on the backend (reading and</font>
<font color="black"> 750.             writing to the stream).</font>
<font color="black"> 751. </font>
<font color="black"> 752.             You can use these objects to do transparent direct</font>
<font color="black"> 753.             recodings from e.g. latin-1 to utf-8 and back.</font>
<font color="black"> 754. </font>
<font color="black"> 755.             stream must be a file-like object.</font>
<font color="black"> 756. </font>
<font color="black"> 757.             encode, decode must adhere to the Codec interface, Reader,</font>
<font color="black"> 758.             Writer must be factory functions or classes providing the</font>
<font color="black"> 759.             StreamReader, StreamWriter interface resp.</font>
<font color="black"> 760. </font>
<font color="black"> 761.             encode and decode are needed for the frontend translation,</font>
<font color="black"> 762.             Reader and Writer for the backend translation. Unicode is</font>
<font color="black"> 763.             used as intermediate encoding.</font>
<font color="black"> 764. </font>
<font color="black"> 765.             Error handling is done in the same way as defined for the</font>
<font color="black"> 766.             StreamWriter/Readers.</font>
<font color="black"> 767. </font>
<font color="black"> 768.         &quot;&quot;&quot;</font>
<font color="red"> 769.         self.stream = stream</font>
<font color="red"> 770.         self.encode = encode</font>
<font color="red"> 771.         self.decode = decode</font>
<font color="red"> 772.         self.reader = Reader(stream, errors)</font>
<font color="red"> 773.         self.writer = Writer(stream, errors)</font>
<font color="red"> 774.         self.errors = errors</font>
<font color="black"> 775. </font>
<font color="red"> 776.     def read(self, size=-1):</font>
<font color="black"> 777. </font>
<font color="red"> 778.         data = self.reader.read(size)</font>
<font color="red"> 779.         data, bytesencoded = self.encode(data, self.errors)</font>
<font color="red"> 780.         return data</font>
<font color="black"> 781. </font>
<font color="red"> 782.     def readline(self, size=None):</font>
<font color="black"> 783. </font>
<font color="red"> 784.         if size is None:</font>
<font color="red"> 785.             data = self.reader.readline()</font>
<font color="black"> 786.         else:</font>
<font color="red"> 787.             data = self.reader.readline(size)</font>
<font color="red"> 788.         data, bytesencoded = self.encode(data, self.errors)</font>
<font color="red"> 789.         return data</font>
<font color="black"> 790. </font>
<font color="red"> 791.     def readlines(self, sizehint=None):</font>
<font color="black"> 792. </font>
<font color="red"> 793.         data = self.reader.read()</font>
<font color="red"> 794.         data, bytesencoded = self.encode(data, self.errors)</font>
<font color="red"> 795.         return data.splitlines(1)</font>
<font color="black"> 796. </font>
<font color="red"> 797.     def next(self):</font>
<font color="black"> 798. </font>
<font color="black"> 799.         &quot;&quot;&quot; Return the next decoded line from the input stream.&quot;&quot;&quot;</font>
<font color="red"> 800.         data = self.reader.next()</font>
<font color="red"> 801.         data, bytesencoded = self.encode(data, self.errors)</font>
<font color="red"> 802.         return data</font>
<font color="black"> 803. </font>
<font color="red"> 804.     def __iter__(self):</font>
<font color="red"> 805.         return self</font>
<font color="black"> 806. </font>
<font color="red"> 807.     def write(self, data):</font>
<font color="black"> 808. </font>
<font color="red"> 809.         data, bytesdecoded = self.decode(data, self.errors)</font>
<font color="red"> 810.         return self.writer.write(data)</font>
<font color="black"> 811. </font>
<font color="red"> 812.     def writelines(self, list):</font>
<font color="black"> 813. </font>
<font color="red"> 814.         data = ''.join(list)</font>
<font color="red"> 815.         data, bytesdecoded = self.decode(data, self.errors)</font>
<font color="red"> 816.         return self.writer.write(data)</font>
<font color="black"> 817. </font>
<font color="red"> 818.     def reset(self):</font>
<font color="black"> 819. </font>
<font color="red"> 820.         self.reader.reset()</font>
<font color="red"> 821.         self.writer.reset()</font>
<font color="black"> 822. </font>
<font color="black"> 823.     def __getattr__(self, name,</font>
<font color="red"> 824.                     getattr=getattr):</font>
<font color="black"> 825. </font>
<font color="black"> 826.         &quot;&quot;&quot; Inherit all other methods from the underlying stream.</font>
<font color="black"> 827.         &quot;&quot;&quot;</font>
<font color="red"> 828.         return getattr(self.stream, name)</font>
<font color="black"> 829. </font>
<font color="red"> 830.     def __enter__(self):</font>
<font color="red"> 831.         return self</font>
<font color="black"> 832. </font>
<font color="red"> 833.     def __exit__(self, type, value, tb):</font>
<font color="red"> 834.         self.stream.close()</font>
<font color="black"> 835. </font>
<font color="black"> 836. ### Shortcuts</font>
<font color="black"> 837. </font>
<font color="red"> 838. def open(filename, mode='rb', encoding=None, errors='strict', buffering=1):</font>
<font color="black"> 839. </font>
<font color="black"> 840.     &quot;&quot;&quot; Open an encoded file using the given mode and return</font>
<font color="black"> 841.         a wrapped version providing transparent encoding/decoding.</font>
<font color="black"> 842. </font>
<font color="black"> 843.         Note: The wrapped version will only accept the object format</font>
<font color="black"> 844.         defined by the codecs, i.e. Unicode objects for most builtin</font>
<font color="black"> 845.         codecs. Output is also codec dependent and will usually be</font>
<font color="black"> 846.         Unicode as well.</font>
<font color="black"> 847. </font>
<font color="black"> 848.         Files are always opened in binary mode, even if no binary mode</font>
<font color="black"> 849.         was specified. This is done to avoid data loss due to encodings</font>
<font color="black"> 850.         using 8-bit values. The default file mode is 'rb' meaning to</font>
<font color="black"> 851.         open the file in binary read mode.</font>
<font color="black"> 852. </font>
<font color="black"> 853.         encoding specifies the encoding which is to be used for the</font>
<font color="black"> 854.         file.</font>
<font color="black"> 855. </font>
<font color="black"> 856.         errors may be given to define the error handling. It defaults</font>
<font color="black"> 857.         to 'strict' which causes ValueErrors to be raised in case an</font>
<font color="black"> 858.         encoding error occurs.</font>
<font color="black"> 859. </font>
<font color="black"> 860.         buffering has the same meaning as for the builtin open() API.</font>
<font color="black"> 861.         It defaults to line buffered.</font>
<font color="black"> 862. </font>
<font color="black"> 863.         The returned wrapped file object provides an extra attribute</font>
<font color="black"> 864.         .encoding which allows querying the used encoding. This</font>
<font color="black"> 865.         attribute is only available if an encoding was specified as</font>
<font color="black"> 866.         parameter.</font>
<font color="black"> 867. </font>
<font color="black"> 868.     &quot;&quot;&quot;</font>
<font color="red"> 869.     if encoding is not None:</font>
<font color="red"> 870.         if 'U' in mode:</font>
<font color="black"> 871.             # No automatic conversion of '\n' is done on reading and writing</font>
<font color="red"> 872.             mode = mode.strip().replace('U', '')</font>
<font color="red"> 873.             if mode[:1] not in set('rwa'):</font>
<font color="red"> 874.                 mode = 'r' + mode</font>
<font color="red"> 875.         if 'b' not in mode:</font>
<font color="black"> 876.             # Force opening of the file in binary mode</font>
<font color="red"> 877.             mode = mode + 'b'</font>
<font color="red"> 878.     file = __builtin__.open(filename, mode, buffering)</font>
<font color="red"> 879.     if encoding is None:</font>
<font color="red"> 880.         return file</font>
<font color="red"> 881.     info = lookup(encoding)</font>
<font color="red"> 882.     srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)</font>
<font color="black"> 883.     # Add attributes to simplify introspection</font>
<font color="red"> 884.     srw.encoding = encoding</font>
<font color="red"> 885.     return srw</font>
<font color="black"> 886. </font>
<font color="red"> 887. def EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):</font>
<font color="black"> 888. </font>
<font color="black"> 889.     &quot;&quot;&quot; Return a wrapped version of file which provides transparent</font>
<font color="black"> 890.         encoding translation.</font>
<font color="black"> 891. </font>
<font color="black"> 892.         Strings written to the wrapped file are interpreted according</font>
<font color="black"> 893.         to the given data_encoding and then written to the original</font>
<font color="black"> 894.         file as string using file_encoding. The intermediate encoding</font>
<font color="black"> 895.         will usually be Unicode but depends on the specified codecs.</font>
<font color="black"> 896. </font>
<font color="black"> 897.         Strings are read from the file using file_encoding and then</font>
<font color="black"> 898.         passed back to the caller as string using data_encoding.</font>
<font color="black"> 899. </font>
<font color="black"> 900.         If file_encoding is not given, it defaults to data_encoding.</font>
<font color="black"> 901. </font>
<font color="black"> 902.         errors may be given to define the error handling. It defaults</font>
<font color="black"> 903.         to 'strict' which causes ValueErrors to be raised in case an</font>
<font color="black"> 904.         encoding error occurs.</font>
<font color="black"> 905. </font>
<font color="black"> 906.         The returned wrapped file object provides two extra attributes</font>
<font color="black"> 907.         .data_encoding and .file_encoding which reflect the given</font>
<font color="black"> 908.         parameters of the same name. The attributes can be used for</font>
<font color="black"> 909.         introspection by Python programs.</font>
<font color="black"> 910. </font>
<font color="black"> 911.     &quot;&quot;&quot;</font>
<font color="red"> 912.     if file_encoding is None:</font>
<font color="red"> 913.         file_encoding = data_encoding</font>
<font color="red"> 914.     data_info = lookup(data_encoding)</font>
<font color="red"> 915.     file_info = lookup(file_encoding)</font>
<font color="red"> 916.     sr = StreamRecoder(file, data_info.encode, data_info.decode,</font>
<font color="red"> 917.                        file_info.streamreader, file_info.streamwriter, errors)</font>
<font color="black"> 918.     # Add attributes to simplify introspection</font>
<font color="red"> 919.     sr.data_encoding = data_encoding</font>
<font color="red"> 920.     sr.file_encoding = file_encoding</font>
<font color="red"> 921.     return sr</font>
<font color="black"> 922. </font>
<font color="black"> 923. ### Helpers for codec lookup</font>
<font color="black"> 924. </font>
<font color="red"> 925. def getencoder(encoding):</font>
<font color="black"> 926. </font>
<font color="black"> 927.     &quot;&quot;&quot; Lookup up the codec for the given encoding and return</font>
<font color="black"> 928.         its encoder function.</font>
<font color="black"> 929. </font>
<font color="black"> 930.         Raises a LookupError in case the encoding cannot be found.</font>
<font color="black"> 931. </font>
<font color="black"> 932.     &quot;&quot;&quot;</font>
<font color="red"> 933.     return lookup(encoding).encode</font>
<font color="black"> 934. </font>
<font color="red"> 935. def getdecoder(encoding):</font>
<font color="black"> 936. </font>
<font color="black"> 937.     &quot;&quot;&quot; Lookup up the codec for the given encoding and return</font>
<font color="black"> 938.         its decoder function.</font>
<font color="black"> 939. </font>
<font color="black"> 940.         Raises a LookupError in case the encoding cannot be found.</font>
<font color="black"> 941. </font>
<font color="black"> 942.     &quot;&quot;&quot;</font>
<font color="red"> 943.     return lookup(encoding).decode</font>
<font color="black"> 944. </font>
<font color="red"> 945. def getincrementalencoder(encoding):</font>
<font color="black"> 946. </font>
<font color="black"> 947.     &quot;&quot;&quot; Lookup up the codec for the given encoding and return</font>
<font color="black"> 948.         its IncrementalEncoder class or factory function.</font>
<font color="black"> 949. </font>
<font color="black"> 950.         Raises a LookupError in case the encoding cannot be found</font>
<font color="black"> 951.         or the codecs doesn't provide an incremental encoder.</font>
<font color="black"> 952. </font>
<font color="black"> 953.     &quot;&quot;&quot;</font>
<font color="red"> 954.     encoder = lookup(encoding).incrementalencoder</font>
<font color="red"> 955.     if encoder is None:</font>
<font color="red"> 956.         raise LookupError(encoding)</font>
<font color="red"> 957.     return encoder</font>
<font color="black"> 958. </font>
<font color="red"> 959. def getincrementaldecoder(encoding):</font>
<font color="black"> 960. </font>
<font color="black"> 961.     &quot;&quot;&quot; Lookup up the codec for the given encoding and return</font>
<font color="black"> 962.         its IncrementalDecoder class or factory function.</font>
<font color="black"> 963. </font>
<font color="black"> 964.         Raises a LookupError in case the encoding cannot be found</font>
<font color="black"> 965.         or the codecs doesn't provide an incremental decoder.</font>
<font color="black"> 966. </font>
<font color="black"> 967.     &quot;&quot;&quot;</font>
<font color="red"> 968.     decoder = lookup(encoding).incrementaldecoder</font>
<font color="red"> 969.     if decoder is None:</font>
<font color="red"> 970.         raise LookupError(encoding)</font>
<font color="red"> 971.     return decoder</font>
<font color="black"> 972. </font>
<font color="red"> 973. def getreader(encoding):</font>
<font color="black"> 974. </font>
<font color="black"> 975.     &quot;&quot;&quot; Lookup up the codec for the given encoding and return</font>
<font color="black"> 976.         its StreamReader class or factory function.</font>
<font color="black"> 977. </font>
<font color="black"> 978.         Raises a LookupError in case the encoding cannot be found.</font>
<font color="black"> 979. </font>
<font color="black"> 980.     &quot;&quot;&quot;</font>
<font color="red"> 981.     return lookup(encoding).streamreader</font>
<font color="black"> 982. </font>
<font color="red"> 983. def getwriter(encoding):</font>
<font color="black"> 984. </font>
<font color="black"> 985.     &quot;&quot;&quot; Lookup up the codec for the given encoding and return</font>
<font color="black"> 986.         its StreamWriter class or factory function.</font>
<font color="black"> 987. </font>
<font color="black"> 988.         Raises a LookupError in case the encoding cannot be found.</font>
<font color="black"> 989. </font>
<font color="black"> 990.     &quot;&quot;&quot;</font>
<font color="red"> 991.     return lookup(encoding).streamwriter</font>
<font color="black"> 992. </font>
<font color="red"> 993. def iterencode(iterator, encoding, errors='strict', **kwargs):</font>
<font color="black"> 994.     &quot;&quot;&quot;</font>
<font color="black"> 995.     Encoding iterator.</font>
<font color="black"> 996. </font>
<font color="black"> 997.     Encodes the input strings from the iterator using a IncrementalEncoder.</font>
<font color="black"> 998. </font>
<font color="black"> 999.     errors and kwargs are passed through to the IncrementalEncoder</font>
<font color="black">1000.     constructor.</font>
<font color="black">1001.     &quot;&quot;&quot;</font>
<font color="red">1002.     encoder = getincrementalencoder(encoding)(errors, **kwargs)</font>
<font color="red">1003.     for input in iterator:</font>
<font color="red">1004.         output = encoder.encode(input)</font>
<font color="red">1005.         if output:</font>
<font color="red">1006.             yield output</font>
<font color="red">1007.     output = encoder.encode(&quot;&quot;, True)</font>
<font color="red">1008.     if output:</font>
<font color="red">1009.         yield output</font>
<font color="black">1010. </font>
<font color="red">1011. def iterdecode(iterator, encoding, errors='strict', **kwargs):</font>
<font color="black">1012.     &quot;&quot;&quot;</font>
<font color="black">1013.     Decoding iterator.</font>
<font color="black">1014. </font>
<font color="black">1015.     Decodes the input strings from the iterator using a IncrementalDecoder.</font>
<font color="black">1016. </font>
<font color="black">1017.     errors and kwargs are passed through to the IncrementalDecoder</font>
<font color="black">1018.     constructor.</font>
<font color="black">1019.     &quot;&quot;&quot;</font>
<font color="red">1020.     decoder = getincrementaldecoder(encoding)(errors, **kwargs)</font>
<font color="red">1021.     for input in iterator:</font>
<font color="red">1022.         output = decoder.decode(input)</font>
<font color="red">1023.         if output:</font>
<font color="red">1024.             yield output</font>
<font color="red">1025.     output = decoder.decode(&quot;&quot;, True)</font>
<font color="red">1026.     if output:</font>
<font color="red">1027.         yield output</font>
<font color="black">1028. </font>
<font color="black">1029. ### Helpers for charmap-based codecs</font>
<font color="black">1030. </font>
<font color="red">1031. def make_identity_dict(rng):</font>
<font color="black">1032. </font>
<font color="black">1033.     &quot;&quot;&quot; make_identity_dict(rng) -&gt; dict</font>
<font color="black">1034. </font>
<font color="black">1035.         Return a dictionary where elements of the rng sequence are</font>
<font color="black">1036.         mapped to themselves.</font>
<font color="black">1037. </font>
<font color="black">1038.     &quot;&quot;&quot;</font>
<font color="red">1039.     res = {}</font>
<font color="red">1040.     for i in rng:</font>
<font color="red">1041.         res[i]=i</font>
<font color="red">1042.     return res</font>
<font color="black">1043. </font>
<font color="red">1044. def make_encoding_map(decoding_map):</font>
<font color="black">1045. </font>
<font color="black">1046.     &quot;&quot;&quot; Creates an encoding map from a decoding map.</font>
<font color="black">1047. </font>
<font color="black">1048.         If a target mapping in the decoding map occurs multiple</font>
<font color="black">1049.         times, then that target is mapped to None (undefined mapping),</font>
<font color="black">1050.         causing an exception when encountered by the charmap codec</font>
<font color="black">1051.         during translation.</font>
<font color="black">1052. </font>
<font color="black">1053.         One example where this happens is cp875.py which decodes</font>
<font color="black">1054.         multiple character to \u001a.</font>
<font color="black">1055. </font>
<font color="black">1056.     &quot;&quot;&quot;</font>
<font color="red">1057.     m = {}</font>
<font color="red">1058.     for k,v in decoding_map.items():</font>
<font color="red">1059.         if not v in m:</font>
<font color="red">1060.             m[v] = k</font>
<font color="black">1061.         else:</font>
<font color="red">1062.             m[v] = None</font>
<font color="red">1063.     return m</font>
<font color="black">1064. </font>
<font color="black">1065. ### error handlers</font>
<font color="black">1066. </font>
<font color="red">1067. try:</font>
<font color="red">1068.     strict_errors = lookup_error(&quot;strict&quot;)</font>
<font color="red">1069.     ignore_errors = lookup_error(&quot;ignore&quot;)</font>
<font color="red">1070.     replace_errors = lookup_error(&quot;replace&quot;)</font>
<font color="red">1071.     xmlcharrefreplace_errors = lookup_error(&quot;xmlcharrefreplace&quot;)</font>
<font color="red">1072.     backslashreplace_errors = lookup_error(&quot;backslashreplace&quot;)</font>
<font color="red">1073. except LookupError:</font>
<font color="black">1074.     # In --disable-unicode builds, these error handler are missing</font>
<font color="red">1075.     strict_errors = None</font>
<font color="red">1076.     ignore_errors = None</font>
<font color="red">1077.     replace_errors = None</font>
<font color="red">1078.     xmlcharrefreplace_errors = None</font>
<font color="red">1079.     backslashreplace_errors = None</font>
<font color="black">1080. </font>
<font color="black">1081. # Tell modulefinder that using codecs probably needs the encodings</font>
<font color="black">1082. # package</font>
<font color="red">1083. _false = 0</font>
<font color="red">1084. if _false:</font>
<font color="red">1085.     import encodings</font>
<font color="black">1086. </font>
<font color="black">1087. ### Tests</font>
<font color="black">1088. </font>
<font color="red">1089. if __name__ == '__main__':</font>
<font color="black">1090. </font>
<font color="black">1091.     # Make stdout translate Latin-1 output into UTF-8 output</font>
<font color="red">1092.     sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')</font>
<font color="black">1093. </font>
<font color="black">1094.     # Have stdin translate Latin-1 input into UTF-8 input</font>
<font color="red">1095.     sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')</font>
</pre>

