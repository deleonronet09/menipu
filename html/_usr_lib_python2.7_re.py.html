source file: <b>/usr/lib/python2.7/re.py</b><br>


file stats: <b>139 lines, 40 executed: 28.8% covered</b>
<pre>
<font color="black">   1. #</font>
<font color="black">   2. # Secret Labs' Regular Expression Engine</font>
<font color="black">   3. #</font>
<font color="black">   4. # re-compatible interface for the sre matching engine</font>
<font color="black">   5. #</font>
<font color="black">   6. # Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.</font>
<font color="black">   7. #</font>
<font color="black">   8. # This version of the SRE library can be redistributed under CNRI's</font>
<font color="black">   9. # Python 1.6 license.  For any other use, please contact Secret Labs</font>
<font color="black">  10. # AB (info@pythonware.com).</font>
<font color="black">  11. #</font>
<font color="black">  12. # Portions of this engine have been developed in cooperation with</font>
<font color="black">  13. # CNRI.  Hewlett-Packard provided funding for 1.6 integration and</font>
<font color="black">  14. # other compatibility work.</font>
<font color="black">  15. #</font>
<font color="black">  16. </font>
<font color="black">  17. r&quot;&quot;&quot;Support for regular expressions (RE).</font>
<font color="black">  18. </font>
<font color="black">  19. This module provides regular expression matching operations similar to</font>
<font color="black">  20. those found in Perl.  It supports both 8-bit and Unicode strings; both</font>
<font color="black">  21. the pattern and the strings being processed can contain null bytes and</font>
<font color="black">  22. characters outside the US ASCII range.</font>
<font color="black">  23. </font>
<font color="black">  24. Regular expressions can contain both special and ordinary characters.</font>
<font color="black">  25. Most ordinary characters, like &quot;A&quot;, &quot;a&quot;, or &quot;0&quot;, are the simplest</font>
<font color="black">  26. regular expressions; they simply match themselves.  You can</font>
<font color="black">  27. concatenate ordinary characters, so last matches the string 'last'.</font>
<font color="black">  28. </font>
<font color="black">  29. The special characters are:</font>
<font color="black">  30.     &quot;.&quot;      Matches any character except a newline.</font>
<font color="black">  31.     &quot;^&quot;      Matches the start of the string.</font>
<font color="black">  32.     &quot;$&quot;      Matches the end of the string or just before the newline at</font>
<font color="black">  33.              the end of the string.</font>
<font color="black">  34.     &quot;*&quot;      Matches 0 or more (greedy) repetitions of the preceding RE.</font>
<font color="black">  35.              Greedy means that it will match as many repetitions as possible.</font>
<font color="black">  36.     &quot;+&quot;      Matches 1 or more (greedy) repetitions of the preceding RE.</font>
<font color="black">  37.     &quot;?&quot;      Matches 0 or 1 (greedy) of the preceding RE.</font>
<font color="black">  38.     *?,+?,?? Non-greedy versions of the previous three special characters.</font>
<font color="black">  39.     {m,n}    Matches from m to n repetitions of the preceding RE.</font>
<font color="black">  40.     {m,n}?   Non-greedy version of the above.</font>
<font color="black">  41.     &quot;\\&quot;     Either escapes special characters or signals a special sequence.</font>
<font color="black">  42.     []       Indicates a set of characters.</font>
<font color="black">  43.              A &quot;^&quot; as the first character indicates a complementing set.</font>
<font color="black">  44.     &quot;|&quot;      A|B, creates an RE that will match either A or B.</font>
<font color="black">  45.     (...)    Matches the RE inside the parentheses.</font>
<font color="black">  46.              The contents can be retrieved or matched later in the string.</font>
<font color="black">  47.     (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).</font>
<font color="black">  48.     (?:...)  Non-grouping version of regular parentheses.</font>
<font color="black">  49.     (?P&lt;name&gt;...) The substring matched by the group is accessible by name.</font>
<font color="black">  50.     (?P=name)     Matches the text matched earlier by the group named name.</font>
<font color="black">  51.     (?#...)  A comment; ignored.</font>
<font color="black">  52.     (?=...)  Matches if ... matches next, but doesn't consume the string.</font>
<font color="black">  53.     (?!...)  Matches if ... doesn't match next.</font>
<font color="black">  54.     (?&lt;=...) Matches if preceded by ... (must be fixed length).</font>
<font color="black">  55.     (?&lt;!...) Matches if not preceded by ... (must be fixed length).</font>
<font color="black">  56.     (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,</font>
<font color="black">  57.                        the (optional) no pattern otherwise.</font>
<font color="black">  58. </font>
<font color="black">  59. The special sequences consist of &quot;\\&quot; and a character from the list</font>
<font color="black">  60. below.  If the ordinary character is not on the list, then the</font>
<font color="black">  61. resulting RE will match the second character.</font>
<font color="black">  62.     \number  Matches the contents of the group of the same number.</font>
<font color="black">  63.     \A       Matches only at the start of the string.</font>
<font color="black">  64.     \Z       Matches only at the end of the string.</font>
<font color="black">  65.     \b       Matches the empty string, but only at the start or end of a word.</font>
<font color="black">  66.     \B       Matches the empty string, but not at the start or end of a word.</font>
<font color="black">  67.     \d       Matches any decimal digit; equivalent to the set [0-9].</font>
<font color="black">  68.     \D       Matches any non-digit character; equivalent to the set [^0-9].</font>
<font color="black">  69.     \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].</font>
<font color="black">  70.     \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].</font>
<font color="black">  71.     \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].</font>
<font color="black">  72.              With LOCALE, it will match the set [0-9_] plus characters defined</font>
<font color="black">  73.              as letters for the current locale.</font>
<font color="black">  74.     \W       Matches the complement of \w.</font>
<font color="black">  75.     \\       Matches a literal backslash.</font>
<font color="black">  76. </font>
<font color="black">  77. This module exports the following functions:</font>
<font color="black">  78.     match    Match a regular expression pattern to the beginning of a string.</font>
<font color="black">  79.     search   Search a string for the presence of a pattern.</font>
<font color="black">  80.     sub      Substitute occurrences of a pattern found in a string.</font>
<font color="black">  81.     subn     Same as sub, but also return the number of substitutions made.</font>
<font color="black">  82.     split    Split a string by the occurrences of a pattern.</font>
<font color="black">  83.     findall  Find all occurrences of a pattern in a string.</font>
<font color="black">  84.     finditer Return an iterator yielding a match object for each match.</font>
<font color="black">  85.     compile  Compile a pattern into a RegexObject.</font>
<font color="black">  86.     purge    Clear the regular expression cache.</font>
<font color="black">  87.     escape   Backslash all non-alphanumerics in a string.</font>
<font color="black">  88. </font>
<font color="black">  89. Some of the functions in this module takes flags as optional parameters:</font>
<font color="black">  90.     I  IGNORECASE  Perform case-insensitive matching.</font>
<font color="black">  91.     L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.</font>
<font color="black">  92.     M  MULTILINE   &quot;^&quot; matches the beginning of lines (after a newline)</font>
<font color="black">  93.                    as well as the string.</font>
<font color="black">  94.                    &quot;$&quot; matches the end of lines (before a newline) as well</font>
<font color="black">  95.                    as the end of the string.</font>
<font color="black">  96.     S  DOTALL      &quot;.&quot; matches any character at all, including the newline.</font>
<font color="black">  97.     X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.</font>
<font color="black">  98.     U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.</font>
<font color="black">  99. </font>
<font color="black"> 100. This module also defines an exception 'error'.</font>
<font color="black"> 101. </font>
<font color="red"> 102. &quot;&quot;&quot;</font>
<font color="black"> 103. </font>
<font color="red"> 104. import sys</font>
<font color="red"> 105. import sre_compile</font>
<font color="red"> 106. import sre_parse</font>
<font color="black"> 107. </font>
<font color="black"> 108. # public symbols</font>
<font color="red"> 109. __all__ = [ &quot;match&quot;, &quot;search&quot;, &quot;sub&quot;, &quot;subn&quot;, &quot;split&quot;, &quot;findall&quot;,</font>
<font color="red"> 110.     &quot;compile&quot;, &quot;purge&quot;, &quot;template&quot;, &quot;escape&quot;, &quot;I&quot;, &quot;L&quot;, &quot;M&quot;, &quot;S&quot;, &quot;X&quot;,</font>
<font color="red"> 111.     &quot;U&quot;, &quot;IGNORECASE&quot;, &quot;LOCALE&quot;, &quot;MULTILINE&quot;, &quot;DOTALL&quot;, &quot;VERBOSE&quot;,</font>
<font color="red"> 112.     &quot;UNICODE&quot;, &quot;error&quot; ]</font>
<font color="black"> 113. </font>
<font color="red"> 114. __version__ = &quot;2.2.1&quot;</font>
<font color="black"> 115. </font>
<font color="black"> 116. # flags</font>
<font color="red"> 117. I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE # ignore case</font>
<font color="red"> 118. L = LOCALE = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale</font>
<font color="red"> 119. U = UNICODE = sre_compile.SRE_FLAG_UNICODE # assume unicode locale</font>
<font color="red"> 120. M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline</font>
<font color="red"> 121. S = DOTALL = sre_compile.SRE_FLAG_DOTALL # make dot match newline</font>
<font color="red"> 122. X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments</font>
<font color="black"> 123. </font>
<font color="black"> 124. # sre extensions (experimental, don't rely on these)</font>
<font color="red"> 125. T = TEMPLATE = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking</font>
<font color="red"> 126. DEBUG = sre_compile.SRE_FLAG_DEBUG # dump pattern after compilation</font>
<font color="black"> 127. </font>
<font color="black"> 128. # sre exception</font>
<font color="red"> 129. error = sre_compile.error</font>
<font color="black"> 130. </font>
<font color="black"> 131. # --------------------------------------------------------------------</font>
<font color="black"> 132. # public interface</font>
<font color="black"> 133. </font>
<font color="red"> 134. def match(pattern, string, flags=0):</font>
<font color="black"> 135.     &quot;&quot;&quot;Try to apply the pattern at the start of the string, returning</font>
<font color="black"> 136.     a match object, or None if no match was found.&quot;&quot;&quot;</font>
<font color="green"> 137.     return _compile(pattern, flags).match(string)</font>
<font color="black"> 138. </font>
<font color="red"> 139. def search(pattern, string, flags=0):</font>
<font color="black"> 140.     &quot;&quot;&quot;Scan through string looking for a match to the pattern, returning</font>
<font color="black"> 141.     a match object, or None if no match was found.&quot;&quot;&quot;</font>
<font color="green"> 142.     return _compile(pattern, flags).search(string)</font>
<font color="black"> 143. </font>
<font color="red"> 144. def sub(pattern, repl, string, count=0, flags=0):</font>
<font color="black"> 145.     &quot;&quot;&quot;Return the string obtained by replacing the leftmost</font>
<font color="black"> 146.     non-overlapping occurrences of the pattern in string by the</font>
<font color="black"> 147.     replacement repl.  repl can be either a string or a callable;</font>
<font color="black"> 148.     if a string, backslash escapes in it are processed.  If it is</font>
<font color="black"> 149.     a callable, it's passed the match object and must return</font>
<font color="black"> 150.     a replacement string to be used.&quot;&quot;&quot;</font>
<font color="red"> 151.     return _compile(pattern, flags).sub(repl, string, count)</font>
<font color="black"> 152. </font>
<font color="red"> 153. def subn(pattern, repl, string, count=0, flags=0):</font>
<font color="black"> 154.     &quot;&quot;&quot;Return a 2-tuple containing (new_string, number).</font>
<font color="black"> 155.     new_string is the string obtained by replacing the leftmost</font>
<font color="black"> 156.     non-overlapping occurrences of the pattern in the source</font>
<font color="black"> 157.     string by the replacement repl.  number is the number of</font>
<font color="black"> 158.     substitutions that were made. repl can be either a string or a</font>
<font color="black"> 159.     callable; if a string, backslash escapes in it are processed.</font>
<font color="black"> 160.     If it is a callable, it's passed the match object and must</font>
<font color="black"> 161.     return a replacement string to be used.&quot;&quot;&quot;</font>
<font color="red"> 162.     return _compile(pattern, flags).subn(repl, string, count)</font>
<font color="black"> 163. </font>
<font color="red"> 164. def split(pattern, string, maxsplit=0, flags=0):</font>
<font color="black"> 165.     &quot;&quot;&quot;Split the source string by the occurrences of the pattern,</font>
<font color="black"> 166.     returning a list containing the resulting substrings.&quot;&quot;&quot;</font>
<font color="red"> 167.     return _compile(pattern, flags).split(string, maxsplit)</font>
<font color="black"> 168. </font>
<font color="red"> 169. def findall(pattern, string, flags=0):</font>
<font color="black"> 170.     &quot;&quot;&quot;Return a list of all non-overlapping matches in the string.</font>
<font color="black"> 171. </font>
<font color="black"> 172.     If one or more groups are present in the pattern, return a</font>
<font color="black"> 173.     list of groups; this will be a list of tuples if the pattern</font>
<font color="black"> 174.     has more than one group.</font>
<font color="black"> 175. </font>
<font color="black"> 176.     Empty matches are included in the result.&quot;&quot;&quot;</font>
<font color="red"> 177.     return _compile(pattern, flags).findall(string)</font>
<font color="black"> 178. </font>
<font color="red"> 179. if sys.hexversion &gt;= 0x02020000:</font>
<font color="red"> 180.     __all__.append(&quot;finditer&quot;)</font>
<font color="red"> 181.     def finditer(pattern, string, flags=0):</font>
<font color="black"> 182.         &quot;&quot;&quot;Return an iterator over all non-overlapping matches in the</font>
<font color="black"> 183.         string.  For each match, the iterator returns a match object.</font>
<font color="black"> 184. </font>
<font color="black"> 185.         Empty matches are included in the result.&quot;&quot;&quot;</font>
<font color="red"> 186.         return _compile(pattern, flags).finditer(string)</font>
<font color="black"> 187. </font>
<font color="red"> 188. def compile(pattern, flags=0):</font>
<font color="black"> 189.     &quot;Compile a regular expression pattern, returning a pattern object.&quot;</font>
<font color="green"> 190.     return _compile(pattern, flags)</font>
<font color="black"> 191. </font>
<font color="red"> 192. def purge():</font>
<font color="black"> 193.     &quot;Clear the regular expression cache&quot;</font>
<font color="red"> 194.     _cache.clear()</font>
<font color="red"> 195.     _cache_repl.clear()</font>
<font color="black"> 196. </font>
<font color="red"> 197. def template(pattern, flags=0):</font>
<font color="black"> 198.     &quot;Compile a template pattern, returning a pattern object&quot;</font>
<font color="red"> 199.     return _compile(pattern, flags|T)</font>
<font color="black"> 200. </font>
<font color="red"> 201. _alphanum = frozenset(</font>
<font color="red"> 202.     &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)</font>
<font color="black"> 203. </font>
<font color="red"> 204. def escape(pattern):</font>
<font color="black"> 205.     &quot;Escape all non-alphanumeric characters in pattern.&quot;</font>
<font color="green"> 206.     s = list(pattern)</font>
<font color="green"> 207.     alphanum = _alphanum</font>
<font color="green"> 208.     for i, c in enumerate(pattern):</font>
<font color="green"> 209.         if c not in alphanum:</font>
<font color="green"> 210.             if c == &quot;\000&quot;:</font>
<font color="red"> 211.                 s[i] = &quot;\\000&quot;</font>
<font color="black"> 212.             else:</font>
<font color="green"> 213.                 s[i] = &quot;\\&quot; + c</font>
<font color="green"> 214.     return pattern[:0].join(s)</font>
<font color="black"> 215. </font>
<font color="black"> 216. # --------------------------------------------------------------------</font>
<font color="black"> 217. # internals</font>
<font color="black"> 218. </font>
<font color="red"> 219. _cache = {}</font>
<font color="red"> 220. _cache_repl = {}</font>
<font color="black"> 221. </font>
<font color="red"> 222. _pattern_type = type(sre_compile.compile(&quot;&quot;, 0))</font>
<font color="black"> 223. </font>
<font color="red"> 224. _MAXCACHE = 100</font>
<font color="black"> 225. </font>
<font color="red"> 226. def _compile(*key):</font>
<font color="black"> 227.     # internal: compile pattern</font>
<font color="green"> 228.     pattern, flags = key</font>
<font color="green"> 229.     bypass_cache = flags &amp; DEBUG</font>
<font color="green"> 230.     if not bypass_cache:</font>
<font color="green"> 231.         cachekey = (type(key[0]),) + key</font>
<font color="green"> 232.         p = _cache.get(cachekey)</font>
<font color="green"> 233.         if p is not None:</font>
<font color="green"> 234.             return p</font>
<font color="green"> 235.     if isinstance(pattern, _pattern_type):</font>
<font color="red"> 236.         if flags:</font>
<font color="red"> 237.             raise ValueError('Cannot process flags argument with a compiled pattern')</font>
<font color="red"> 238.         return pattern</font>
<font color="green"> 239.     if not sre_compile.isstring(pattern):</font>
<font color="red"> 240.         raise TypeError, &quot;first argument must be string or compiled pattern&quot;</font>
<font color="green"> 241.     try:</font>
<font color="green"> 242.         p = sre_compile.compile(pattern, flags)</font>
<font color="red"> 243.     except error, v:</font>
<font color="red"> 244.         raise error, v # invalid expression</font>
<font color="green"> 245.     if not bypass_cache:</font>
<font color="green"> 246.         if len(_cache) &gt;= _MAXCACHE:</font>
<font color="green"> 247.             _cache.clear()</font>
<font color="green"> 248.         _cache[cachekey] = p</font>
<font color="green"> 249.     return p</font>
<font color="black"> 250. </font>
<font color="red"> 251. def _compile_repl(*key):</font>
<font color="black"> 252.     # internal: compile replacement pattern</font>
<font color="green"> 253.     p = _cache_repl.get(key)</font>
<font color="green"> 254.     if p is not None:</font>
<font color="green"> 255.         return p</font>
<font color="green"> 256.     repl, pattern = key</font>
<font color="green"> 257.     try:</font>
<font color="green"> 258.         p = sre_parse.parse_template(repl, pattern)</font>
<font color="red"> 259.     except error, v:</font>
<font color="red"> 260.         raise error, v # invalid expression</font>
<font color="green"> 261.     if len(_cache_repl) &gt;= _MAXCACHE:</font>
<font color="red"> 262.         _cache_repl.clear()</font>
<font color="green"> 263.     _cache_repl[key] = p</font>
<font color="green"> 264.     return p</font>
<font color="black"> 265. </font>
<font color="red"> 266. def _expand(pattern, match, template):</font>
<font color="black"> 267.     # internal: match.expand implementation hook</font>
<font color="red"> 268.     template = sre_parse.parse_template(template, pattern)</font>
<font color="red"> 269.     return sre_parse.expand_template(template, match)</font>
<font color="black"> 270. </font>
<font color="red"> 271. def _subx(pattern, template):</font>
<font color="black"> 272.     # internal: pattern.sub/subn implementation helper</font>
<font color="green"> 273.     template = _compile_repl(template, pattern)</font>
<font color="green"> 274.     if not template[0] and len(template[1]) == 1:</font>
<font color="black"> 275.         # literal replacement</font>
<font color="red"> 276.         return template[1][0]</font>
<font color="green"> 277.     def filter(match, template=template):</font>
<font color="green"> 278.         return sre_parse.expand_template(template, match)</font>
<font color="green"> 279.     return filter</font>
<font color="black"> 280. </font>
<font color="black"> 281. # register myself for pickling</font>
<font color="black"> 282. </font>
<font color="red"> 283. import copy_reg</font>
<font color="black"> 284. </font>
<font color="red"> 285. def _pickle(p):</font>
<font color="red"> 286.     return _compile, (p.pattern, p.flags)</font>
<font color="black"> 287. </font>
<font color="red"> 288. copy_reg.pickle(_pattern_type, _pickle, _compile)</font>
<font color="black"> 289. </font>
<font color="black"> 290. # --------------------------------------------------------------------</font>
<font color="black"> 291. # experimental stuff (see python-dev discussions for details)</font>
<font color="black"> 292. </font>
<font color="red"> 293. class Scanner:</font>
<font color="red"> 294.     def __init__(self, lexicon, flags=0):</font>
<font color="red"> 295.         from sre_constants import BRANCH, SUBPATTERN</font>
<font color="red"> 296.         self.lexicon = lexicon</font>
<font color="black"> 297.         # combine phrases into a compound pattern</font>
<font color="red"> 298.         p = []</font>
<font color="red"> 299.         s = sre_parse.Pattern()</font>
<font color="red"> 300.         s.flags = flags</font>
<font color="red"> 301.         for phrase, action in lexicon:</font>
<font color="red"> 302.             p.append(sre_parse.SubPattern(s, [</font>
<font color="red"> 303.                 (SUBPATTERN, (len(p)+1, sre_parse.parse(phrase, flags))),</font>
<font color="black"> 304.                 ]))</font>
<font color="red"> 305.         s.groups = len(p)+1</font>
<font color="red"> 306.         p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])</font>
<font color="red"> 307.         self.scanner = sre_compile.compile(p)</font>
<font color="red"> 308.     def scan(self, string):</font>
<font color="red"> 309.         result = []</font>
<font color="red"> 310.         append = result.append</font>
<font color="red"> 311.         match = self.scanner.scanner(string).match</font>
<font color="red"> 312.         i = 0</font>
<font color="red"> 313.         while 1:</font>
<font color="red"> 314.             m = match()</font>
<font color="red"> 315.             if not m:</font>
<font color="red"> 316.                 break</font>
<font color="red"> 317.             j = m.end()</font>
<font color="red"> 318.             if i == j:</font>
<font color="red"> 319.                 break</font>
<font color="red"> 320.             action = self.lexicon[m.lastindex-1][1]</font>
<font color="red"> 321.             if hasattr(action, '__call__'):</font>
<font color="red"> 322.                 self.match = m</font>
<font color="red"> 323.                 action = action(self, m.group())</font>
<font color="red"> 324.             if action is not None:</font>
<font color="red"> 325.                 append(action)</font>
<font color="red"> 326.             i = j</font>
<font color="red"> 327.         return result, string[i:]</font>
</pre>

