source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/compiler.py</b><br>


file stats: <b>1147 lines, 168 executed: 14.6% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.compiler</font>
<font color="black">   4.     ~~~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Compiles nodes into python code.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">   9.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. from itertools import chain</font>
<font color="green">  12. from copy import deepcopy</font>
<font color="green">  13. from keyword import iskeyword as is_python_keyword</font>
<font color="green">  14. from jinja2 import nodes</font>
<font color="green">  15. from jinja2.nodes import EvalContext</font>
<font color="green">  16. from jinja2.visitor import NodeVisitor</font>
<font color="green">  17. from jinja2.exceptions import TemplateAssertionError</font>
<font color="green">  18. from jinja2.utils import Markup, concat, escape</font>
<font color="green">  19. from jinja2._compat import range_type, text_type, string_types, \</font>
<font color="black">  20.      iteritems, NativeStringIO, imap</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="green">  23. operators = {</font>
<font color="green">  24.     'eq':       '==',</font>
<font color="green">  25.     'ne':       '!=',</font>
<font color="green">  26.     'gt':       '&gt;',</font>
<font color="green">  27.     'gteq':     '&gt;=',</font>
<font color="green">  28.     'lt':       '&lt;',</font>
<font color="green">  29.     'lteq':     '&lt;=',</font>
<font color="green">  30.     'in':       'in',</font>
<font color="green">  31.     'notin':    'not in'</font>
<font color="black">  32. }</font>
<font color="black">  33. </font>
<font color="black">  34. # what method to iterate over items do we want to use for dict iteration</font>
<font color="black">  35. # in generated code?  on 2.x let's go with iteritems, on 3.x with items</font>
<font color="green">  36. if hasattr(dict, 'iteritems'):</font>
<font color="green">  37.     dict_item_iter = 'iteritems'</font>
<font color="black">  38. else:</font>
<font color="red">  39.     dict_item_iter = 'items'</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="black">  42. # does if 0: dummy(x) get us x into the scope?</font>
<font color="green">  43. def unoptimize_before_dead_code():</font>
<font color="green">  44.     x = 42</font>
<font color="green">  45.     def f():</font>
<font color="red">  46.         if 0: dummy(x)</font>
<font color="green">  47.     return f</font>
<font color="black">  48. </font>
<font color="black">  49. # The getattr is necessary for pypy which does not set this attribute if</font>
<font color="black">  50. # no closure is on the function</font>
<font color="green">  51. unoptimize_before_dead_code = bool(</font>
<font color="green">  52.     getattr(unoptimize_before_dead_code(), '__closure__', None))</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. def generate(node, environment, name, filename, stream=None,</font>
<font color="green">  56.              defer_init=False):</font>
<font color="black">  57.     &quot;&quot;&quot;Generate the python source for a node tree.&quot;&quot;&quot;</font>
<font color="red">  58.     if not isinstance(node, nodes.Template):</font>
<font color="red">  59.         raise TypeError('Can\'t compile non template nodes')</font>
<font color="red">  60.     generator = environment.code_generator_class(environment, name, filename,</font>
<font color="red">  61.                                                  stream, defer_init)</font>
<font color="red">  62.     generator.visit(node)</font>
<font color="red">  63.     if stream is None:</font>
<font color="red">  64.         return generator.stream.getvalue()</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="green">  67. def has_safe_repr(value):</font>
<font color="black">  68.     &quot;&quot;&quot;Does the node have a safe representation?&quot;&quot;&quot;</font>
<font color="red">  69.     if value is None or value is NotImplemented or value is Ellipsis:</font>
<font color="red">  70.         return True</font>
<font color="red">  71.     if isinstance(value, (bool, int, float, complex, range_type,</font>
<font color="red">  72.             Markup) + string_types):</font>
<font color="red">  73.         return True</font>
<font color="red">  74.     if isinstance(value, (tuple, list, set, frozenset)):</font>
<font color="red">  75.         for item in value:</font>
<font color="red">  76.             if not has_safe_repr(item):</font>
<font color="red">  77.                 return False</font>
<font color="red">  78.         return True</font>
<font color="red">  79.     elif isinstance(value, dict):</font>
<font color="red">  80.         for key, value in iteritems(value):</font>
<font color="red">  81.             if not has_safe_repr(key):</font>
<font color="red">  82.                 return False</font>
<font color="red">  83.             if not has_safe_repr(value):</font>
<font color="red">  84.                 return False</font>
<font color="red">  85.         return True</font>
<font color="red">  86.     return False</font>
<font color="black">  87. </font>
<font color="black">  88. </font>
<font color="green">  89. def find_undeclared(nodes, names):</font>
<font color="black">  90.     &quot;&quot;&quot;Check if the names passed are accessed undeclared.  The return value</font>
<font color="black">  91.     is a set of all the undeclared names from the sequence of names found.</font>
<font color="black">  92.     &quot;&quot;&quot;</font>
<font color="red">  93.     visitor = UndeclaredNameVisitor(names)</font>
<font color="red">  94.     try:</font>
<font color="red">  95.         for node in nodes:</font>
<font color="red">  96.             visitor.visit(node)</font>
<font color="red">  97.     except VisitorExit:</font>
<font color="red">  98.         pass</font>
<font color="red">  99.     return visitor.undeclared</font>
<font color="black"> 100. </font>
<font color="black"> 101. </font>
<font color="green"> 102. class Identifiers(object):</font>
<font color="green"> 103.     &quot;&quot;&quot;Tracks the status of identifiers in frames.&quot;&quot;&quot;</font>
<font color="black"> 104. </font>
<font color="green"> 105.     def __init__(self):</font>
<font color="black"> 106.         # variables that are known to be declared (probably from outer</font>
<font color="black"> 107.         # frames or because they are special for the frame)</font>
<font color="red"> 108.         self.declared = set()</font>
<font color="black"> 109. </font>
<font color="black"> 110.         # undeclared variables from outer scopes</font>
<font color="red"> 111.         self.outer_undeclared = set()</font>
<font color="black"> 112. </font>
<font color="black"> 113.         # names that are accessed without being explicitly declared by</font>
<font color="black"> 114.         # this one or any of the outer scopes.  Names can appear both in</font>
<font color="black"> 115.         # declared and undeclared.</font>
<font color="red"> 116.         self.undeclared = set()</font>
<font color="black"> 117. </font>
<font color="black"> 118.         # names that are declared locally</font>
<font color="red"> 119.         self.declared_locally = set()</font>
<font color="black"> 120. </font>
<font color="black"> 121.         # names that are declared by parameters</font>
<font color="red"> 122.         self.declared_parameter = set()</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def add_special(self, name):</font>
<font color="black"> 125.         &quot;&quot;&quot;Register a special name like `loop`.&quot;&quot;&quot;</font>
<font color="red"> 126.         self.undeclared.discard(name)</font>
<font color="red"> 127.         self.declared.add(name)</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def is_declared(self, name):</font>
<font color="black"> 130.         &quot;&quot;&quot;Check if a name is declared in this or an outer scope.&quot;&quot;&quot;</font>
<font color="red"> 131.         if name in self.declared_locally or name in self.declared_parameter:</font>
<font color="red"> 132.             return True</font>
<font color="red"> 133.         return name in self.declared</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def copy(self):</font>
<font color="red"> 136.         return deepcopy(self)</font>
<font color="black"> 137. </font>
<font color="black"> 138. </font>
<font color="green"> 139. class Frame(object):</font>
<font color="green"> 140.     &quot;&quot;&quot;Holds compile time information for us.&quot;&quot;&quot;</font>
<font color="black"> 141. </font>
<font color="green"> 142.     def __init__(self, eval_ctx, parent=None):</font>
<font color="red"> 143.         self.eval_ctx = eval_ctx</font>
<font color="red"> 144.         self.identifiers = Identifiers()</font>
<font color="black"> 145. </font>
<font color="black"> 146.         # a toplevel frame is the root + soft frames such as if conditions.</font>
<font color="red"> 147.         self.toplevel = False</font>
<font color="black"> 148. </font>
<font color="black"> 149.         # the root frame is basically just the outermost frame, so no if</font>
<font color="black"> 150.         # conditions.  This information is used to optimize inheritance</font>
<font color="black"> 151.         # situations.</font>
<font color="red"> 152.         self.rootlevel = False</font>
<font color="black"> 153. </font>
<font color="black"> 154.         # in some dynamic inheritance situations the compiler needs to add</font>
<font color="black"> 155.         # write tests around output statements.</font>
<font color="red"> 156.         self.require_output_check = parent and parent.require_output_check</font>
<font color="black"> 157. </font>
<font color="black"> 158.         # inside some tags we are using a buffer rather than yield statements.</font>
<font color="black"> 159.         # this for example affects {% filter %} or {% macro %}.  If a frame</font>
<font color="black"> 160.         # is buffered this variable points to the name of the list used as</font>
<font color="black"> 161.         # buffer.</font>
<font color="red"> 162.         self.buffer = None</font>
<font color="black"> 163. </font>
<font color="black"> 164.         # the name of the block we're in, otherwise None.</font>
<font color="red"> 165.         self.block = parent and parent.block or None</font>
<font color="black"> 166. </font>
<font color="black"> 167.         # a set of actually assigned names</font>
<font color="red"> 168.         self.assigned_names = set()</font>
<font color="black"> 169. </font>
<font color="black"> 170.         # the parent of this frame</font>
<font color="red"> 171.         self.parent = parent</font>
<font color="black"> 172. </font>
<font color="red"> 173.         if parent is not None:</font>
<font color="red"> 174.             self.identifiers.declared.update(</font>
<font color="black"> 175.                 parent.identifiers.declared |</font>
<font color="red"> 176.                 parent.identifiers.declared_parameter |</font>
<font color="red"> 177.                 parent.assigned_names</font>
<font color="black"> 178.             )</font>
<font color="red"> 179.             self.identifiers.outer_undeclared.update(</font>
<font color="red"> 180.                 parent.identifiers.undeclared -</font>
<font color="red"> 181.                 self.identifiers.declared</font>
<font color="black"> 182.             )</font>
<font color="red"> 183.             self.buffer = parent.buffer</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def copy(self):</font>
<font color="black"> 186.         &quot;&quot;&quot;Create a copy of the current one.&quot;&quot;&quot;</font>
<font color="red"> 187.         rv = object.__new__(self.__class__)</font>
<font color="red"> 188.         rv.__dict__.update(self.__dict__)</font>
<font color="red"> 189.         rv.identifiers = object.__new__(self.identifiers.__class__)</font>
<font color="red"> 190.         rv.identifiers.__dict__.update(self.identifiers.__dict__)</font>
<font color="red"> 191.         return rv</font>
<font color="black"> 192. </font>
<font color="green"> 193.     def inspect(self, nodes):</font>
<font color="black"> 194.         &quot;&quot;&quot;Walk the node and check for identifiers.  If the scope is hard (eg:</font>
<font color="black"> 195.         enforce on a python level) overrides from outer scopes are tracked</font>
<font color="black"> 196.         differently.</font>
<font color="black"> 197.         &quot;&quot;&quot;</font>
<font color="red"> 198.         visitor = FrameIdentifierVisitor(self.identifiers)</font>
<font color="red"> 199.         for node in nodes:</font>
<font color="red"> 200.             visitor.visit(node)</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def find_shadowed(self, extra=()):</font>
<font color="black"> 203.         &quot;&quot;&quot;Find all the shadowed names.  extra is an iterable of variables</font>
<font color="black"> 204.         that may be defined with `add_special` which may occour scoped.</font>
<font color="black"> 205.         &quot;&quot;&quot;</font>
<font color="red"> 206.         i = self.identifiers</font>
<font color="red"> 207.         return (i.declared | i.outer_undeclared) &amp; \</font>
<font color="red"> 208.                (i.declared_locally | i.declared_parameter) | \</font>
<font color="red"> 209.                set(x for x in extra if i.is_declared(x))</font>
<font color="black"> 210. </font>
<font color="green"> 211.     def inner(self):</font>
<font color="black"> 212.         &quot;&quot;&quot;Return an inner frame.&quot;&quot;&quot;</font>
<font color="red"> 213.         return Frame(self.eval_ctx, self)</font>
<font color="black"> 214. </font>
<font color="green"> 215.     def soft(self):</font>
<font color="black"> 216.         &quot;&quot;&quot;Return a soft frame.  A soft frame may not be modified as</font>
<font color="black"> 217.         standalone thing as it shares the resources with the frame it</font>
<font color="black"> 218.         was created of, but it's not a rootlevel frame any longer.</font>
<font color="black"> 219.         &quot;&quot;&quot;</font>
<font color="red"> 220.         rv = self.copy()</font>
<font color="red"> 221.         rv.rootlevel = False</font>
<font color="red"> 222.         return rv</font>
<font color="black"> 223. </font>
<font color="green"> 224.     __copy__ = copy</font>
<font color="black"> 225. </font>
<font color="black"> 226. </font>
<font color="green"> 227. class VisitorExit(RuntimeError):</font>
<font color="green"> 228.     &quot;&quot;&quot;Exception used by the `UndeclaredNameVisitor` to signal a stop.&quot;&quot;&quot;</font>
<font color="black"> 229. </font>
<font color="black"> 230. </font>
<font color="green"> 231. class DependencyFinderVisitor(NodeVisitor):</font>
<font color="green"> 232.     &quot;&quot;&quot;A visitor that collects filter and test calls.&quot;&quot;&quot;</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def __init__(self):</font>
<font color="red"> 235.         self.filters = set()</font>
<font color="red"> 236.         self.tests = set()</font>
<font color="black"> 237. </font>
<font color="green"> 238.     def visit_Filter(self, node):</font>
<font color="red"> 239.         self.generic_visit(node)</font>
<font color="red"> 240.         self.filters.add(node.name)</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def visit_Test(self, node):</font>
<font color="red"> 243.         self.generic_visit(node)</font>
<font color="red"> 244.         self.tests.add(node.name)</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def visit_Block(self, node):</font>
<font color="black"> 247.         &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;</font>
<font color="black"> 248. </font>
<font color="black"> 249. </font>
<font color="green"> 250. class UndeclaredNameVisitor(NodeVisitor):</font>
<font color="black"> 251.     &quot;&quot;&quot;A visitor that checks if a name is accessed without being</font>
<font color="black"> 252.     declared.  This is different from the frame visitor as it will</font>
<font color="black"> 253.     not stop at closure frames.</font>
<font color="green"> 254.     &quot;&quot;&quot;</font>
<font color="black"> 255. </font>
<font color="green"> 256.     def __init__(self, names):</font>
<font color="red"> 257.         self.names = set(names)</font>
<font color="red"> 258.         self.undeclared = set()</font>
<font color="black"> 259. </font>
<font color="green"> 260.     def visit_Name(self, node):</font>
<font color="red"> 261.         if node.ctx == 'load' and node.name in self.names:</font>
<font color="red"> 262.             self.undeclared.add(node.name)</font>
<font color="red"> 263.             if self.undeclared == self.names:</font>
<font color="red"> 264.                 raise VisitorExit()</font>
<font color="black"> 265.         else:</font>
<font color="red"> 266.             self.names.discard(node.name)</font>
<font color="black"> 267. </font>
<font color="green"> 268.     def visit_Block(self, node):</font>
<font color="black"> 269.         &quot;&quot;&quot;Stop visiting a blocks.&quot;&quot;&quot;</font>
<font color="black"> 270. </font>
<font color="black"> 271. </font>
<font color="green"> 272. class FrameIdentifierVisitor(NodeVisitor):</font>
<font color="green"> 273.     &quot;&quot;&quot;A visitor for `Frame.inspect`.&quot;&quot;&quot;</font>
<font color="black"> 274. </font>
<font color="green"> 275.     def __init__(self, identifiers):</font>
<font color="red"> 276.         self.identifiers = identifiers</font>
<font color="black"> 277. </font>
<font color="green"> 278.     def visit_Name(self, node):</font>
<font color="black"> 279.         &quot;&quot;&quot;All assignments to names go through this function.&quot;&quot;&quot;</font>
<font color="red"> 280.         if node.ctx == 'store':</font>
<font color="red"> 281.             self.identifiers.declared_locally.add(node.name)</font>
<font color="red"> 282.         elif node.ctx == 'param':</font>
<font color="red"> 283.             self.identifiers.declared_parameter.add(node.name)</font>
<font color="red"> 284.         elif node.ctx == 'load' and not \</font>
<font color="red"> 285.              self.identifiers.is_declared(node.name):</font>
<font color="red"> 286.             self.identifiers.undeclared.add(node.name)</font>
<font color="black"> 287. </font>
<font color="green"> 288.     def visit_If(self, node):</font>
<font color="red"> 289.         self.visit(node.test)</font>
<font color="red"> 290.         real_identifiers = self.identifiers</font>
<font color="black"> 291. </font>
<font color="red"> 292.         old_names = real_identifiers.declared_locally | \</font>
<font color="red"> 293.                     real_identifiers.declared_parameter</font>
<font color="black"> 294. </font>
<font color="red"> 295.         def inner_visit(nodes):</font>
<font color="red"> 296.             if not nodes:</font>
<font color="red"> 297.                 return set()</font>
<font color="red"> 298.             self.identifiers = real_identifiers.copy()</font>
<font color="red"> 299.             for subnode in nodes:</font>
<font color="red"> 300.                 self.visit(subnode)</font>
<font color="red"> 301.             rv = self.identifiers.declared_locally - old_names</font>
<font color="black"> 302.             # we have to remember the undeclared variables of this branch</font>
<font color="black"> 303.             # because we will have to pull them.</font>
<font color="red"> 304.             real_identifiers.undeclared.update(self.identifiers.undeclared)</font>
<font color="red"> 305.             self.identifiers = real_identifiers</font>
<font color="red"> 306.             return rv</font>
<font color="black"> 307. </font>
<font color="red"> 308.         body = inner_visit(node.body)</font>
<font color="red"> 309.         else_ = inner_visit(node.else_ or ())</font>
<font color="black"> 310. </font>
<font color="black"> 311.         # the differences between the two branches are also pulled as</font>
<font color="black"> 312.         # undeclared variables</font>
<font color="red"> 313.         real_identifiers.undeclared.update(body.symmetric_difference(else_) -</font>
<font color="red"> 314.                                            real_identifiers.declared)</font>
<font color="black"> 315. </font>
<font color="black"> 316.         # remember those that are declared.</font>
<font color="red"> 317.         real_identifiers.declared_locally.update(body | else_)</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def visit_Macro(self, node):</font>
<font color="red"> 320.         self.identifiers.declared_locally.add(node.name)</font>
<font color="black"> 321. </font>
<font color="green"> 322.     def visit_Import(self, node):</font>
<font color="red"> 323.         self.generic_visit(node)</font>
<font color="red"> 324.         self.identifiers.declared_locally.add(node.target)</font>
<font color="black"> 325. </font>
<font color="green"> 326.     def visit_FromImport(self, node):</font>
<font color="red"> 327.         self.generic_visit(node)</font>
<font color="red"> 328.         for name in node.names:</font>
<font color="red"> 329.             if isinstance(name, tuple):</font>
<font color="red"> 330.                 self.identifiers.declared_locally.add(name[1])</font>
<font color="black"> 331.             else:</font>
<font color="red"> 332.                 self.identifiers.declared_locally.add(name)</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def visit_Assign(self, node):</font>
<font color="black"> 335.         &quot;&quot;&quot;Visit assignments in the correct order.&quot;&quot;&quot;</font>
<font color="red"> 336.         self.visit(node.node)</font>
<font color="red"> 337.         self.visit(node.target)</font>
<font color="black"> 338. </font>
<font color="green"> 339.     def visit_For(self, node):</font>
<font color="black"> 340.         &quot;&quot;&quot;Visiting stops at for blocks.  However the block sequence</font>
<font color="black"> 341.         is visited as part of the outer scope.</font>
<font color="black"> 342.         &quot;&quot;&quot;</font>
<font color="red"> 343.         self.visit(node.iter)</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def visit_CallBlock(self, node):</font>
<font color="red"> 346.         self.visit(node.call)</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def visit_FilterBlock(self, node):</font>
<font color="red"> 349.         self.visit(node.filter)</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def visit_AssignBlock(self, node):</font>
<font color="black"> 352.         &quot;&quot;&quot;Stop visiting at block assigns.&quot;&quot;&quot;</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def visit_Scope(self, node):</font>
<font color="black"> 355.         &quot;&quot;&quot;Stop visiting at scopes.&quot;&quot;&quot;</font>
<font color="black"> 356. </font>
<font color="green"> 357.     def visit_Block(self, node):</font>
<font color="black"> 358.         &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;</font>
<font color="black"> 359. </font>
<font color="black"> 360. </font>
<font color="green"> 361. class CompilerExit(Exception):</font>
<font color="black"> 362.     &quot;&quot;&quot;Raised if the compiler encountered a situation where it just</font>
<font color="black"> 363.     doesn't make sense to further process the code.  Any block that</font>
<font color="black"> 364.     raises such an exception is not further processed.</font>
<font color="green"> 365.     &quot;&quot;&quot;</font>
<font color="black"> 366. </font>
<font color="black"> 367. </font>
<font color="green"> 368. class CodeGenerator(NodeVisitor):</font>
<font color="black"> 369. </font>
<font color="green"> 370.     def __init__(self, environment, name, filename, stream=None,</font>
<font color="green"> 371.                  defer_init=False):</font>
<font color="red"> 372.         if stream is None:</font>
<font color="red"> 373.             stream = NativeStringIO()</font>
<font color="red"> 374.         self.environment = environment</font>
<font color="red"> 375.         self.name = name</font>
<font color="red"> 376.         self.filename = filename</font>
<font color="red"> 377.         self.stream = stream</font>
<font color="red"> 378.         self.created_block_context = False</font>
<font color="red"> 379.         self.defer_init = defer_init</font>
<font color="black"> 380. </font>
<font color="black"> 381.         # aliases for imports</font>
<font color="red"> 382.         self.import_aliases = {}</font>
<font color="black"> 383. </font>
<font color="black"> 384.         # a registry for all blocks.  Because blocks are moved out</font>
<font color="black"> 385.         # into the global python scope they are registered here</font>
<font color="red"> 386.         self.blocks = {}</font>
<font color="black"> 387. </font>
<font color="black"> 388.         # the number of extends statements so far</font>
<font color="red"> 389.         self.extends_so_far = 0</font>
<font color="black"> 390. </font>
<font color="black"> 391.         # some templates have a rootlevel extends.  In this case we</font>
<font color="black"> 392.         # can safely assume that we're a child template and do some</font>
<font color="black"> 393.         # more optimizations.</font>
<font color="red"> 394.         self.has_known_extends = False</font>
<font color="black"> 395. </font>
<font color="black"> 396.         # the current line number</font>
<font color="red"> 397.         self.code_lineno = 1</font>
<font color="black"> 398. </font>
<font color="black"> 399.         # registry of all filters and tests (global, not block local)</font>
<font color="red"> 400.         self.tests = {}</font>
<font color="red"> 401.         self.filters = {}</font>
<font color="black"> 402. </font>
<font color="black"> 403.         # the debug information</font>
<font color="red"> 404.         self.debug_info = []</font>
<font color="red"> 405.         self._write_debug_info = None</font>
<font color="black"> 406. </font>
<font color="black"> 407.         # the number of new lines before the next write()</font>
<font color="red"> 408.         self._new_lines = 0</font>
<font color="black"> 409. </font>
<font color="black"> 410.         # the line number of the last written statement</font>
<font color="red"> 411.         self._last_line = 0</font>
<font color="black"> 412. </font>
<font color="black"> 413.         # true if nothing was written so far.</font>
<font color="red"> 414.         self._first_write = True</font>
<font color="black"> 415. </font>
<font color="black"> 416.         # used by the `temporary_identifier` method to get new</font>
<font color="black"> 417.         # unique, temporary identifier</font>
<font color="red"> 418.         self._last_identifier = 0</font>
<font color="black"> 419. </font>
<font color="black"> 420.         # the current indentation</font>
<font color="red"> 421.         self._indentation = 0</font>
<font color="black"> 422. </font>
<font color="black"> 423.     # -- Various compilation helpers</font>
<font color="black"> 424. </font>
<font color="green"> 425.     def fail(self, msg, lineno):</font>
<font color="black"> 426.         &quot;&quot;&quot;Fail with a :exc:`TemplateAssertionError`.&quot;&quot;&quot;</font>
<font color="red"> 427.         raise TemplateAssertionError(msg, lineno, self.name, self.filename)</font>
<font color="black"> 428. </font>
<font color="green"> 429.     def temporary_identifier(self):</font>
<font color="black"> 430.         &quot;&quot;&quot;Get a new unique identifier.&quot;&quot;&quot;</font>
<font color="red"> 431.         self._last_identifier += 1</font>
<font color="red"> 432.         return 't_%d' % self._last_identifier</font>
<font color="black"> 433. </font>
<font color="green"> 434.     def buffer(self, frame):</font>
<font color="black"> 435.         &quot;&quot;&quot;Enable buffering for the frame from that point onwards.&quot;&quot;&quot;</font>
<font color="red"> 436.         frame.buffer = self.temporary_identifier()</font>
<font color="red"> 437.         self.writeline('%s = []' % frame.buffer)</font>
<font color="black"> 438. </font>
<font color="green"> 439.     def return_buffer_contents(self, frame):</font>
<font color="black"> 440.         &quot;&quot;&quot;Return the buffer contents of the frame.&quot;&quot;&quot;</font>
<font color="red"> 441.         if frame.eval_ctx.volatile:</font>
<font color="red"> 442.             self.writeline('if context.eval_ctx.autoescape:')</font>
<font color="red"> 443.             self.indent()</font>
<font color="red"> 444.             self.writeline('return Markup(concat(%s))' % frame.buffer)</font>
<font color="red"> 445.             self.outdent()</font>
<font color="red"> 446.             self.writeline('else:')</font>
<font color="red"> 447.             self.indent()</font>
<font color="red"> 448.             self.writeline('return concat(%s)' % frame.buffer)</font>
<font color="red"> 449.             self.outdent()</font>
<font color="red"> 450.         elif frame.eval_ctx.autoescape:</font>
<font color="red"> 451.             self.writeline('return Markup(concat(%s))' % frame.buffer)</font>
<font color="black"> 452.         else:</font>
<font color="red"> 453.             self.writeline('return concat(%s)' % frame.buffer)</font>
<font color="black"> 454. </font>
<font color="green"> 455.     def indent(self):</font>
<font color="black"> 456.         &quot;&quot;&quot;Indent by one.&quot;&quot;&quot;</font>
<font color="red"> 457.         self._indentation += 1</font>
<font color="black"> 458. </font>
<font color="green"> 459.     def outdent(self, step=1):</font>
<font color="black"> 460.         &quot;&quot;&quot;Outdent by step.&quot;&quot;&quot;</font>
<font color="red"> 461.         self._indentation -= step</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def start_write(self, frame, node=None):</font>
<font color="black"> 464.         &quot;&quot;&quot;Yield or write into the frame buffer.&quot;&quot;&quot;</font>
<font color="red"> 465.         if frame.buffer is None:</font>
<font color="red"> 466.             self.writeline('yield ', node)</font>
<font color="black"> 467.         else:</font>
<font color="red"> 468.             self.writeline('%s.append(' % frame.buffer, node)</font>
<font color="black"> 469. </font>
<font color="green"> 470.     def end_write(self, frame):</font>
<font color="black"> 471.         &quot;&quot;&quot;End the writing process started by `start_write`.&quot;&quot;&quot;</font>
<font color="red"> 472.         if frame.buffer is not None:</font>
<font color="red"> 473.             self.write(')')</font>
<font color="black"> 474. </font>
<font color="green"> 475.     def simple_write(self, s, frame, node=None):</font>
<font color="black"> 476.         &quot;&quot;&quot;Simple shortcut for start_write + write + end_write.&quot;&quot;&quot;</font>
<font color="red"> 477.         self.start_write(frame, node)</font>
<font color="red"> 478.         self.write(s)</font>
<font color="red"> 479.         self.end_write(frame)</font>
<font color="black"> 480. </font>
<font color="green"> 481.     def blockvisit(self, nodes, frame):</font>
<font color="black"> 482.         &quot;&quot;&quot;Visit a list of nodes as block in a frame.  If the current frame</font>
<font color="black"> 483.         is no buffer a dummy ``if 0: yield None`` is written automatically</font>
<font color="black"> 484.         unless the force_generator parameter is set to False.</font>
<font color="black"> 485.         &quot;&quot;&quot;</font>
<font color="red"> 486.         if frame.buffer is None:</font>
<font color="red"> 487.             self.writeline('if 0: yield None')</font>
<font color="black"> 488.         else:</font>
<font color="red"> 489.             self.writeline('pass')</font>
<font color="red"> 490.         try:</font>
<font color="red"> 491.             for node in nodes:</font>
<font color="red"> 492.                 self.visit(node, frame)</font>
<font color="red"> 493.         except CompilerExit:</font>
<font color="red"> 494.             pass</font>
<font color="black"> 495. </font>
<font color="green"> 496.     def write(self, x):</font>
<font color="black"> 497.         &quot;&quot;&quot;Write a string into the output stream.&quot;&quot;&quot;</font>
<font color="red"> 498.         if self._new_lines:</font>
<font color="red"> 499.             if not self._first_write:</font>
<font color="red"> 500.                 self.stream.write('\n' * self._new_lines)</font>
<font color="red"> 501.                 self.code_lineno += self._new_lines</font>
<font color="red"> 502.                 if self._write_debug_info is not None:</font>
<font color="red"> 503.                     self.debug_info.append((self._write_debug_info,</font>
<font color="red"> 504.                                             self.code_lineno))</font>
<font color="red"> 505.                     self._write_debug_info = None</font>
<font color="red"> 506.             self._first_write = False</font>
<font color="red"> 507.             self.stream.write('    ' * self._indentation)</font>
<font color="red"> 508.             self._new_lines = 0</font>
<font color="red"> 509.         self.stream.write(x)</font>
<font color="black"> 510. </font>
<font color="green"> 511.     def writeline(self, x, node=None, extra=0):</font>
<font color="black"> 512.         &quot;&quot;&quot;Combination of newline and write.&quot;&quot;&quot;</font>
<font color="red"> 513.         self.newline(node, extra)</font>
<font color="red"> 514.         self.write(x)</font>
<font color="black"> 515. </font>
<font color="green"> 516.     def newline(self, node=None, extra=0):</font>
<font color="black"> 517.         &quot;&quot;&quot;Add one or more newlines before the next write.&quot;&quot;&quot;</font>
<font color="red"> 518.         self._new_lines = max(self._new_lines, 1 + extra)</font>
<font color="red"> 519.         if node is not None and node.lineno != self._last_line:</font>
<font color="red"> 520.             self._write_debug_info = node.lineno</font>
<font color="red"> 521.             self._last_line = node.lineno</font>
<font color="black"> 522. </font>
<font color="green"> 523.     def signature(self, node, frame, extra_kwargs=None):</font>
<font color="black"> 524.         &quot;&quot;&quot;Writes a function call to the stream for the current node.</font>
<font color="black"> 525.         A leading comma is added automatically.  The extra keyword</font>
<font color="black"> 526.         arguments may not include python keywords otherwise a syntax</font>
<font color="black"> 527.         error could occour.  The extra keyword arguments should be given</font>
<font color="black"> 528.         as python dict.</font>
<font color="black"> 529.         &quot;&quot;&quot;</font>
<font color="black"> 530.         # if any of the given keyword arguments is a python keyword</font>
<font color="black"> 531.         # we have to make sure that no invalid call is created.</font>
<font color="red"> 532.         kwarg_workaround = False</font>
<font color="red"> 533.         for kwarg in chain((x.key for x in node.kwargs), extra_kwargs or ()):</font>
<font color="red"> 534.             if is_python_keyword(kwarg):</font>
<font color="red"> 535.                 kwarg_workaround = True</font>
<font color="red"> 536.                 break</font>
<font color="black"> 537. </font>
<font color="red"> 538.         for arg in node.args:</font>
<font color="red"> 539.             self.write(', ')</font>
<font color="red"> 540.             self.visit(arg, frame)</font>
<font color="black"> 541. </font>
<font color="red"> 542.         if not kwarg_workaround:</font>
<font color="red"> 543.             for kwarg in node.kwargs:</font>
<font color="red"> 544.                 self.write(', ')</font>
<font color="red"> 545.                 self.visit(kwarg, frame)</font>
<font color="red"> 546.             if extra_kwargs is not None:</font>
<font color="red"> 547.                 for key, value in iteritems(extra_kwargs):</font>
<font color="red"> 548.                     self.write(', %s=%s' % (key, value))</font>
<font color="red"> 549.         if node.dyn_args:</font>
<font color="red"> 550.             self.write(', *')</font>
<font color="red"> 551.             self.visit(node.dyn_args, frame)</font>
<font color="black"> 552. </font>
<font color="red"> 553.         if kwarg_workaround:</font>
<font color="red"> 554.             if node.dyn_kwargs is not None:</font>
<font color="red"> 555.                 self.write(', **dict({')</font>
<font color="black"> 556.             else:</font>
<font color="red"> 557.                 self.write(', **{')</font>
<font color="red"> 558.             for kwarg in node.kwargs:</font>
<font color="red"> 559.                 self.write('%r: ' % kwarg.key)</font>
<font color="red"> 560.                 self.visit(kwarg.value, frame)</font>
<font color="red"> 561.                 self.write(', ')</font>
<font color="red"> 562.             if extra_kwargs is not None:</font>
<font color="red"> 563.                 for key, value in iteritems(extra_kwargs):</font>
<font color="red"> 564.                     self.write('%r: %s, ' % (key, value))</font>
<font color="red"> 565.             if node.dyn_kwargs is not None:</font>
<font color="red"> 566.                 self.write('}, **')</font>
<font color="red"> 567.                 self.visit(node.dyn_kwargs, frame)</font>
<font color="red"> 568.                 self.write(')')</font>
<font color="black"> 569.             else:</font>
<font color="red"> 570.                 self.write('}')</font>
<font color="black"> 571. </font>
<font color="red"> 572.         elif node.dyn_kwargs is not None:</font>
<font color="red"> 573.             self.write(', **')</font>
<font color="red"> 574.             self.visit(node.dyn_kwargs, frame)</font>
<font color="black"> 575. </font>
<font color="green"> 576.     def pull_locals(self, frame):</font>
<font color="black"> 577.         &quot;&quot;&quot;Pull all the references identifiers into the local scope.&quot;&quot;&quot;</font>
<font color="red"> 578.         for name in frame.identifiers.undeclared:</font>
<font color="red"> 579.             self.writeline('l_%s = context.resolve(%r)' % (name, name))</font>
<font color="black"> 580. </font>
<font color="green"> 581.     def pull_dependencies(self, nodes):</font>
<font color="black"> 582.         &quot;&quot;&quot;Pull all the dependencies.&quot;&quot;&quot;</font>
<font color="red"> 583.         visitor = DependencyFinderVisitor()</font>
<font color="red"> 584.         for node in nodes:</font>
<font color="red"> 585.             visitor.visit(node)</font>
<font color="red"> 586.         for dependency in 'filters', 'tests':</font>
<font color="red"> 587.             mapping = getattr(self, dependency)</font>
<font color="red"> 588.             for name in getattr(visitor, dependency):</font>
<font color="red"> 589.                 if name not in mapping:</font>
<font color="red"> 590.                     mapping[name] = self.temporary_identifier()</font>
<font color="red"> 591.                 self.writeline('%s = environment.%s[%r]' %</font>
<font color="red"> 592.                                (mapping[name], dependency, name))</font>
<font color="black"> 593. </font>
<font color="green"> 594.     def unoptimize_scope(self, frame):</font>
<font color="black"> 595.         &quot;&quot;&quot;Disable Python optimizations for the frame.&quot;&quot;&quot;</font>
<font color="black"> 596.         # XXX: this is not that nice but it has no real overhead.  It</font>
<font color="black"> 597.         # mainly works because python finds the locals before dead code</font>
<font color="black"> 598.         # is removed.  If that breaks we have to add a dummy function</font>
<font color="black"> 599.         # that just accepts the arguments and does nothing.</font>
<font color="red"> 600.         if frame.identifiers.declared:</font>
<font color="red"> 601.             self.writeline('%sdummy(%s)' % (</font>
<font color="red"> 602.                 unoptimize_before_dead_code and 'if 0: ' or '',</font>
<font color="red"> 603.                 ', '.join('l_' + name for name in frame.identifiers.declared)</font>
<font color="black"> 604.             ))</font>
<font color="black"> 605. </font>
<font color="green"> 606.     def push_scope(self, frame, extra_vars=()):</font>
<font color="black"> 607.         &quot;&quot;&quot;This function returns all the shadowed variables in a dict</font>
<font color="black"> 608.         in the form name: alias and will write the required assignments</font>
<font color="black"> 609.         into the current scope.  No indentation takes place.</font>
<font color="black"> 610. </font>
<font color="black"> 611.         This also predefines locally declared variables from the loop</font>
<font color="black"> 612.         body because under some circumstances it may be the case that</font>
<font color="black"> 613. </font>
<font color="black"> 614.         `extra_vars` is passed to `Frame.find_shadowed`.</font>
<font color="black"> 615.         &quot;&quot;&quot;</font>
<font color="red"> 616.         aliases = {}</font>
<font color="red"> 617.         for name in frame.find_shadowed(extra_vars):</font>
<font color="red"> 618.             aliases[name] = ident = self.temporary_identifier()</font>
<font color="red"> 619.             self.writeline('%s = l_%s' % (ident, name))</font>
<font color="red"> 620.         to_declare = set()</font>
<font color="red"> 621.         for name in frame.identifiers.declared_locally:</font>
<font color="red"> 622.             if name not in aliases:</font>
<font color="red"> 623.                 to_declare.add('l_' + name)</font>
<font color="red"> 624.         if to_declare:</font>
<font color="red"> 625.             self.writeline(' = '.join(to_declare) + ' = missing')</font>
<font color="red"> 626.         return aliases</font>
<font color="black"> 627. </font>
<font color="green"> 628.     def pop_scope(self, aliases, frame):</font>
<font color="black"> 629.         &quot;&quot;&quot;Restore all aliases and delete unused variables.&quot;&quot;&quot;</font>
<font color="red"> 630.         for name, alias in iteritems(aliases):</font>
<font color="red"> 631.             self.writeline('l_%s = %s' % (name, alias))</font>
<font color="red"> 632.         to_delete = set()</font>
<font color="red"> 633.         for name in frame.identifiers.declared_locally:</font>
<font color="red"> 634.             if name not in aliases:</font>
<font color="red"> 635.                 to_delete.add('l_' + name)</font>
<font color="red"> 636.         if to_delete:</font>
<font color="black"> 637.             # we cannot use the del statement here because enclosed</font>
<font color="black"> 638.             # scopes can trigger a SyntaxError:</font>
<font color="black"> 639.             #   a = 42; b = lambda: a; del a</font>
<font color="red"> 640.             self.writeline(' = '.join(to_delete) + ' = missing')</font>
<font color="black"> 641. </font>
<font color="green"> 642.     def function_scoping(self, node, frame, children=None,</font>
<font color="green"> 643.                          find_special=True):</font>
<font color="black"> 644.         &quot;&quot;&quot;In Jinja a few statements require the help of anonymous</font>
<font color="black"> 645.         functions.  Those are currently macros and call blocks and in</font>
<font color="black"> 646.         the future also recursive loops.  As there is currently</font>
<font color="black"> 647.         technical limitation that doesn't allow reading and writing a</font>
<font color="black"> 648.         variable in a scope where the initial value is coming from an</font>
<font color="black"> 649.         outer scope, this function tries to fall back with a common</font>
<font color="black"> 650.         error message.  Additionally the frame passed is modified so</font>
<font color="black"> 651.         that the argumetns are collected and callers are looked up.</font>
<font color="black"> 652. </font>
<font color="black"> 653.         This will return the modified frame.</font>
<font color="black"> 654.         &quot;&quot;&quot;</font>
<font color="black"> 655.         # we have to iterate twice over it, make sure that works</font>
<font color="red"> 656.         if children is None:</font>
<font color="red"> 657.             children = node.iter_child_nodes()</font>
<font color="red"> 658.         children = list(children)</font>
<font color="red"> 659.         func_frame = frame.inner()</font>
<font color="red"> 660.         func_frame.inspect(children)</font>
<font color="black"> 661. </font>
<font color="black"> 662.         # variables that are undeclared (accessed before declaration) and</font>
<font color="black"> 663.         # declared locally *and* part of an outside scope raise a template</font>
<font color="black"> 664.         # assertion error. Reason: we can't generate reasonable code from</font>
<font color="black"> 665.         # it without aliasing all the variables.</font>
<font color="black"> 666.         # this could be fixed in Python 3 where we have the nonlocal</font>
<font color="black"> 667.         # keyword or if we switch to bytecode generation</font>
<font color="black"> 668.         overridden_closure_vars = (</font>
<font color="black"> 669.             func_frame.identifiers.undeclared &amp;</font>
<font color="red"> 670.             func_frame.identifiers.declared &amp;</font>
<font color="red"> 671.             (func_frame.identifiers.declared_locally |</font>
<font color="red"> 672.              func_frame.identifiers.declared_parameter)</font>
<font color="black"> 673.         )</font>
<font color="red"> 674.         if overridden_closure_vars:</font>
<font color="red"> 675.             self.fail('It\'s not possible to set and access variables '</font>
<font color="black"> 676.                       'derived from an outer scope! (affects: %s)' %</font>
<font color="red"> 677.                       ', '.join(sorted(overridden_closure_vars)), node.lineno)</font>
<font color="black"> 678. </font>
<font color="black"> 679.         # remove variables from a closure from the frame's undeclared</font>
<font color="black"> 680.         # identifiers.</font>
<font color="red"> 681.         func_frame.identifiers.undeclared -= (</font>
<font color="red"> 682.             func_frame.identifiers.undeclared &amp;</font>
<font color="red"> 683.             func_frame.identifiers.declared</font>
<font color="black"> 684.         )</font>
<font color="black"> 685. </font>
<font color="black"> 686.         # no special variables for this scope, abort early</font>
<font color="red"> 687.         if not find_special:</font>
<font color="red"> 688.             return func_frame</font>
<font color="black"> 689. </font>
<font color="red"> 690.         func_frame.accesses_kwargs = False</font>
<font color="red"> 691.         func_frame.accesses_varargs = False</font>
<font color="red"> 692.         func_frame.accesses_caller = False</font>
<font color="red"> 693.         func_frame.arguments = args = ['l_' + x.name for x in node.args]</font>
<font color="black"> 694. </font>
<font color="red"> 695.         undeclared = find_undeclared(children, ('caller', 'kwargs', 'varargs'))</font>
<font color="black"> 696. </font>
<font color="red"> 697.         if 'caller' in undeclared:</font>
<font color="red"> 698.             func_frame.accesses_caller = True</font>
<font color="red"> 699.             func_frame.identifiers.add_special('caller')</font>
<font color="red"> 700.             args.append('l_caller')</font>
<font color="red"> 701.         if 'kwargs' in undeclared:</font>
<font color="red"> 702.             func_frame.accesses_kwargs = True</font>
<font color="red"> 703.             func_frame.identifiers.add_special('kwargs')</font>
<font color="red"> 704.             args.append('l_kwargs')</font>
<font color="red"> 705.         if 'varargs' in undeclared:</font>
<font color="red"> 706.             func_frame.accesses_varargs = True</font>
<font color="red"> 707.             func_frame.identifiers.add_special('varargs')</font>
<font color="red"> 708.             args.append('l_varargs')</font>
<font color="red"> 709.         return func_frame</font>
<font color="black"> 710. </font>
<font color="green"> 711.     def macro_body(self, node, frame, children=None):</font>
<font color="black"> 712.         &quot;&quot;&quot;Dump the function def of a macro or call block.&quot;&quot;&quot;</font>
<font color="red"> 713.         frame = self.function_scoping(node, frame, children)</font>
<font color="black"> 714.         # macros are delayed, they never require output checks</font>
<font color="red"> 715.         frame.require_output_check = False</font>
<font color="red"> 716.         args = frame.arguments</font>
<font color="black"> 717.         # XXX: this is an ugly fix for the loop nesting bug</font>
<font color="black"> 718.         # (tests.test_old_bugs.test_loop_call_bug).  This works around</font>
<font color="black"> 719.         # a identifier nesting problem we have in general.  It's just more</font>
<font color="black"> 720.         # likely to happen in loops which is why we work around it.  The</font>
<font color="black"> 721.         # real solution would be &quot;nonlocal&quot; all the identifiers that are</font>
<font color="black"> 722.         # leaking into a new python frame and might be used both unassigned</font>
<font color="black"> 723.         # and assigned.</font>
<font color="red"> 724.         if 'loop' in frame.identifiers.declared:</font>
<font color="red"> 725.             args = args + ['l_loop=l_loop']</font>
<font color="red"> 726.         self.writeline('def macro(%s):' % ', '.join(args), node)</font>
<font color="red"> 727.         self.indent()</font>
<font color="red"> 728.         self.buffer(frame)</font>
<font color="red"> 729.         self.pull_locals(frame)</font>
<font color="red"> 730.         self.blockvisit(node.body, frame)</font>
<font color="red"> 731.         self.return_buffer_contents(frame)</font>
<font color="red"> 732.         self.outdent()</font>
<font color="red"> 733.         return frame</font>
<font color="black"> 734. </font>
<font color="green"> 735.     def macro_def(self, node, frame):</font>
<font color="black"> 736.         &quot;&quot;&quot;Dump the macro definition for the def created by macro_body.&quot;&quot;&quot;</font>
<font color="red"> 737.         arg_tuple = ', '.join(repr(x.name) for x in node.args)</font>
<font color="red"> 738.         name = getattr(node, 'name', None)</font>
<font color="red"> 739.         if len(node.args) == 1:</font>
<font color="red"> 740.             arg_tuple += ','</font>
<font color="red"> 741.         self.write('Macro(environment, macro, %r, (%s), (' %</font>
<font color="red"> 742.                    (name, arg_tuple))</font>
<font color="red"> 743.         for arg in node.defaults:</font>
<font color="red"> 744.             self.visit(arg, frame)</font>
<font color="red"> 745.             self.write(', ')</font>
<font color="red"> 746.         self.write('), %r, %r, %r)' % (</font>
<font color="red"> 747.             bool(frame.accesses_kwargs),</font>
<font color="red"> 748.             bool(frame.accesses_varargs),</font>
<font color="red"> 749.             bool(frame.accesses_caller)</font>
<font color="black"> 750.         ))</font>
<font color="black"> 751. </font>
<font color="green"> 752.     def position(self, node):</font>
<font color="black"> 753.         &quot;&quot;&quot;Return a human readable position for the node.&quot;&quot;&quot;</font>
<font color="red"> 754.         rv = 'line %d' % node.lineno</font>
<font color="red"> 755.         if self.name is not None:</font>
<font color="red"> 756.             rv += ' in ' + repr(self.name)</font>
<font color="red"> 757.         return rv</font>
<font color="black"> 758. </font>
<font color="black"> 759.     # -- Statement Visitors</font>
<font color="black"> 760. </font>
<font color="green"> 761.     def visit_Template(self, node, frame=None):</font>
<font color="red"> 762.         assert frame is None, 'no root frame allowed'</font>
<font color="red"> 763.         eval_ctx = EvalContext(self.environment, self.name)</font>
<font color="black"> 764. </font>
<font color="red"> 765.         from jinja2.runtime import __all__ as exported</font>
<font color="red"> 766.         self.writeline('from __future__ import division')</font>
<font color="red"> 767.         self.writeline('from jinja2.runtime import ' + ', '.join(exported))</font>
<font color="red"> 768.         if not unoptimize_before_dead_code:</font>
<font color="red"> 769.             self.writeline('dummy = lambda *x: None')</font>
<font color="black"> 770. </font>
<font color="black"> 771.         # if we want a deferred initialization we cannot move the</font>
<font color="black"> 772.         # environment into a local name</font>
<font color="red"> 773.         envenv = not self.defer_init and ', environment=environment' or ''</font>
<font color="black"> 774. </font>
<font color="black"> 775.         # do we have an extends tag at all?  If not, we can save some</font>
<font color="black"> 776.         # overhead by just not processing any inheritance code.</font>
<font color="red"> 777.         have_extends = node.find(nodes.Extends) is not None</font>
<font color="black"> 778. </font>
<font color="black"> 779.         # find all blocks</font>
<font color="red"> 780.         for block in node.find_all(nodes.Block):</font>
<font color="red"> 781.             if block.name in self.blocks:</font>
<font color="red"> 782.                 self.fail('block %r defined twice' % block.name, block.lineno)</font>
<font color="red"> 783.             self.blocks[block.name] = block</font>
<font color="black"> 784. </font>
<font color="black"> 785.         # find all imports and import them</font>
<font color="red"> 786.         for import_ in node.find_all(nodes.ImportedName):</font>
<font color="red"> 787.             if import_.importname not in self.import_aliases:</font>
<font color="red"> 788.                 imp = import_.importname</font>
<font color="red"> 789.                 self.import_aliases[imp] = alias = self.temporary_identifier()</font>
<font color="red"> 790.                 if '.' in imp:</font>
<font color="red"> 791.                     module, obj = imp.rsplit('.', 1)</font>
<font color="red"> 792.                     self.writeline('from %s import %s as %s' %</font>
<font color="red"> 793.                                    (module, obj, alias))</font>
<font color="black"> 794.                 else:</font>
<font color="red"> 795.                     self.writeline('import %s as %s' % (imp, alias))</font>
<font color="black"> 796. </font>
<font color="black"> 797.         # add the load name</font>
<font color="red"> 798.         self.writeline('name = %r' % self.name)</font>
<font color="black"> 799. </font>
<font color="black"> 800.         # generate the root render function.</font>
<font color="red"> 801.         self.writeline('def root(context%s):' % envenv, extra=1)</font>
<font color="black"> 802. </font>
<font color="black"> 803.         # process the root</font>
<font color="red"> 804.         frame = Frame(eval_ctx)</font>
<font color="red"> 805.         frame.inspect(node.body)</font>
<font color="red"> 806.         frame.toplevel = frame.rootlevel = True</font>
<font color="red"> 807.         frame.require_output_check = have_extends and not self.has_known_extends</font>
<font color="red"> 808.         self.indent()</font>
<font color="red"> 809.         if have_extends:</font>
<font color="red"> 810.             self.writeline('parent_template = None')</font>
<font color="red"> 811.         if 'self' in find_undeclared(node.body, ('self',)):</font>
<font color="red"> 812.             frame.identifiers.add_special('self')</font>
<font color="red"> 813.             self.writeline('l_self = TemplateReference(context)')</font>
<font color="red"> 814.         self.pull_locals(frame)</font>
<font color="red"> 815.         self.pull_dependencies(node.body)</font>
<font color="red"> 816.         self.blockvisit(node.body, frame)</font>
<font color="red"> 817.         self.outdent()</font>
<font color="black"> 818. </font>
<font color="black"> 819.         # make sure that the parent root is called.</font>
<font color="red"> 820.         if have_extends:</font>
<font color="red"> 821.             if not self.has_known_extends:</font>
<font color="red"> 822.                 self.indent()</font>
<font color="red"> 823.                 self.writeline('if parent_template is not None:')</font>
<font color="red"> 824.             self.indent()</font>
<font color="red"> 825.             self.writeline('for event in parent_template.'</font>
<font color="black"> 826.                            'root_render_func(context):')</font>
<font color="red"> 827.             self.indent()</font>
<font color="red"> 828.             self.writeline('yield event')</font>
<font color="red"> 829.             self.outdent(2 + (not self.has_known_extends))</font>
<font color="black"> 830. </font>
<font color="black"> 831.         # at this point we now have the blocks collected and can visit them too.</font>
<font color="red"> 832.         for name, block in iteritems(self.blocks):</font>
<font color="red"> 833.             block_frame = Frame(eval_ctx)</font>
<font color="red"> 834.             block_frame.inspect(block.body)</font>
<font color="red"> 835.             block_frame.block = name</font>
<font color="red"> 836.             self.writeline('def block_%s(context%s):' % (name, envenv),</font>
<font color="red"> 837.                            block, 1)</font>
<font color="red"> 838.             self.indent()</font>
<font color="red"> 839.             undeclared = find_undeclared(block.body, ('self', 'super'))</font>
<font color="red"> 840.             if 'self' in undeclared:</font>
<font color="red"> 841.                 block_frame.identifiers.add_special('self')</font>
<font color="red"> 842.                 self.writeline('l_self = TemplateReference(context)')</font>
<font color="red"> 843.             if 'super' in undeclared:</font>
<font color="red"> 844.                 block_frame.identifiers.add_special('super')</font>
<font color="red"> 845.                 self.writeline('l_super = context.super(%r, '</font>
<font color="red"> 846.                                'block_%s)' % (name, name))</font>
<font color="red"> 847.             self.pull_locals(block_frame)</font>
<font color="red"> 848.             self.pull_dependencies(block.body)</font>
<font color="red"> 849.             self.blockvisit(block.body, block_frame)</font>
<font color="red"> 850.             self.outdent()</font>
<font color="black"> 851. </font>
<font color="red"> 852.         self.writeline('blocks = {%s}' % ', '.join('%r: block_%s' % (x, x)</font>
<font color="red"> 853.                                                    for x in self.blocks),</font>
<font color="red"> 854.                        extra=1)</font>
<font color="black"> 855. </font>
<font color="black"> 856.         # add a function that returns the debug info</font>
<font color="red"> 857.         self.writeline('debug_info = %r' % '&amp;'.join('%s=%s' % x for x</font>
<font color="red"> 858.                                                     in self.debug_info))</font>
<font color="black"> 859. </font>
<font color="green"> 860.     def visit_Block(self, node, frame):</font>
<font color="black"> 861.         &quot;&quot;&quot;Call a block and register it for the template.&quot;&quot;&quot;</font>
<font color="red"> 862.         level = 1</font>
<font color="red"> 863.         if frame.toplevel:</font>
<font color="black"> 864.             # if we know that we are a child template, there is no need to</font>
<font color="black"> 865.             # check if we are one</font>
<font color="red"> 866.             if self.has_known_extends:</font>
<font color="red"> 867.                 return</font>
<font color="red"> 868.             if self.extends_so_far &gt; 0:</font>
<font color="red"> 869.                 self.writeline('if parent_template is None:')</font>
<font color="red"> 870.                 self.indent()</font>
<font color="red"> 871.                 level += 1</font>
<font color="red"> 872.         context = node.scoped and 'context.derived(locals())' or 'context'</font>
<font color="red"> 873.         self.writeline('for event in context.blocks[%r][0](%s):' % (</font>
<font color="red"> 874.                        node.name, context), node)</font>
<font color="red"> 875.         self.indent()</font>
<font color="red"> 876.         self.simple_write('event', frame)</font>
<font color="red"> 877.         self.outdent(level)</font>
<font color="black"> 878. </font>
<font color="green"> 879.     def visit_Extends(self, node, frame):</font>
<font color="black"> 880.         &quot;&quot;&quot;Calls the extender.&quot;&quot;&quot;</font>
<font color="red"> 881.         if not frame.toplevel:</font>
<font color="red"> 882.             self.fail('cannot use extend from a non top-level scope',</font>
<font color="red"> 883.                       node.lineno)</font>
<font color="black"> 884. </font>
<font color="black"> 885.         # if the number of extends statements in general is zero so</font>
<font color="black"> 886.         # far, we don't have to add a check if something extended</font>
<font color="black"> 887.         # the template before this one.</font>
<font color="red"> 888.         if self.extends_so_far &gt; 0:</font>
<font color="black"> 889. </font>
<font color="black"> 890.             # if we have a known extends we just add a template runtime</font>
<font color="black"> 891.             # error into the generated code.  We could catch that at compile</font>
<font color="black"> 892.             # time too, but i welcome it not to confuse users by throwing the</font>
<font color="black"> 893.             # same error at different times just &quot;because we can&quot;.</font>
<font color="red"> 894.             if not self.has_known_extends:</font>
<font color="red"> 895.                 self.writeline('if parent_template is not None:')</font>
<font color="red"> 896.                 self.indent()</font>
<font color="red"> 897.             self.writeline('raise TemplateRuntimeError(%r)' %</font>
<font color="red"> 898.                            'extended multiple times')</font>
<font color="black"> 899. </font>
<font color="black"> 900.             # if we have a known extends already we don't need that code here</font>
<font color="black"> 901.             # as we know that the template execution will end here.</font>
<font color="red"> 902.             if self.has_known_extends:</font>
<font color="red"> 903.                 raise CompilerExit()</font>
<font color="black"> 904.             else:</font>
<font color="red"> 905.                 self.outdent()</font>
<font color="black"> 906. </font>
<font color="red"> 907.         self.writeline('parent_template = environment.get_template(', node)</font>
<font color="red"> 908.         self.visit(node.template, frame)</font>
<font color="red"> 909.         self.write(', %r)' % self.name)</font>
<font color="red"> 910.         self.writeline('for name, parent_block in parent_template.'</font>
<font color="red"> 911.                        'blocks.%s():' % dict_item_iter)</font>
<font color="red"> 912.         self.indent()</font>
<font color="red"> 913.         self.writeline('context.blocks.setdefault(name, []).'</font>
<font color="black"> 914.                        'append(parent_block)')</font>
<font color="red"> 915.         self.outdent()</font>
<font color="black"> 916. </font>
<font color="black"> 917.         # if this extends statement was in the root level we can take</font>
<font color="black"> 918.         # advantage of that information and simplify the generated code</font>
<font color="black"> 919.         # in the top level from this point onwards</font>
<font color="red"> 920.         if frame.rootlevel:</font>
<font color="red"> 921.             self.has_known_extends = True</font>
<font color="black"> 922. </font>
<font color="black"> 923.         # and now we have one more</font>
<font color="red"> 924.         self.extends_so_far += 1</font>
<font color="black"> 925. </font>
<font color="green"> 926.     def visit_Include(self, node, frame):</font>
<font color="black"> 927.         &quot;&quot;&quot;Handles includes.&quot;&quot;&quot;</font>
<font color="red"> 928.         if node.with_context:</font>
<font color="red"> 929.             self.unoptimize_scope(frame)</font>
<font color="red"> 930.         if node.ignore_missing:</font>
<font color="red"> 931.             self.writeline('try:')</font>
<font color="red"> 932.             self.indent()</font>
<font color="black"> 933. </font>
<font color="red"> 934.         func_name = 'get_or_select_template'</font>
<font color="red"> 935.         if isinstance(node.template, nodes.Const):</font>
<font color="red"> 936.             if isinstance(node.template.value, string_types):</font>
<font color="red"> 937.                 func_name = 'get_template'</font>
<font color="red"> 938.             elif isinstance(node.template.value, (tuple, list)):</font>
<font color="red"> 939.                 func_name = 'select_template'</font>
<font color="red"> 940.         elif isinstance(node.template, (nodes.Tuple, nodes.List)):</font>
<font color="red"> 941.             func_name = 'select_template'</font>
<font color="black"> 942. </font>
<font color="red"> 943.         self.writeline('template = environment.%s(' % func_name, node)</font>
<font color="red"> 944.         self.visit(node.template, frame)</font>
<font color="red"> 945.         self.write(', %r)' % self.name)</font>
<font color="red"> 946.         if node.ignore_missing:</font>
<font color="red"> 947.             self.outdent()</font>
<font color="red"> 948.             self.writeline('except TemplateNotFound:')</font>
<font color="red"> 949.             self.indent()</font>
<font color="red"> 950.             self.writeline('pass')</font>
<font color="red"> 951.             self.outdent()</font>
<font color="red"> 952.             self.writeline('else:')</font>
<font color="red"> 953.             self.indent()</font>
<font color="black"> 954. </font>
<font color="red"> 955.         if node.with_context:</font>
<font color="red"> 956.             self.writeline('for event in template.root_render_func('</font>
<font color="black"> 957.                            'template.new_context(context.parent, True, '</font>
<font color="black"> 958.                            'locals())):')</font>
<font color="black"> 959.         else:</font>
<font color="red"> 960.             self.writeline('for event in template.module._body_stream:')</font>
<font color="black"> 961. </font>
<font color="red"> 962.         self.indent()</font>
<font color="red"> 963.         self.simple_write('event', frame)</font>
<font color="red"> 964.         self.outdent()</font>
<font color="black"> 965. </font>
<font color="red"> 966.         if node.ignore_missing:</font>
<font color="red"> 967.             self.outdent()</font>
<font color="black"> 968. </font>
<font color="green"> 969.     def visit_Import(self, node, frame):</font>
<font color="black"> 970.         &quot;&quot;&quot;Visit regular imports.&quot;&quot;&quot;</font>
<font color="red"> 971.         if node.with_context:</font>
<font color="red"> 972.             self.unoptimize_scope(frame)</font>
<font color="red"> 973.         self.writeline('l_%s = ' % node.target, node)</font>
<font color="red"> 974.         if frame.toplevel:</font>
<font color="red"> 975.             self.write('context.vars[%r] = ' % node.target)</font>
<font color="red"> 976.         self.write('environment.get_template(')</font>
<font color="red"> 977.         self.visit(node.template, frame)</font>
<font color="red"> 978.         self.write(', %r).' % self.name)</font>
<font color="red"> 979.         if node.with_context:</font>
<font color="red"> 980.             self.write('make_module(context.parent, True, locals())')</font>
<font color="black"> 981.         else:</font>
<font color="red"> 982.             self.write('module')</font>
<font color="red"> 983.         if frame.toplevel and not node.target.startswith('_'):</font>
<font color="red"> 984.             self.writeline('context.exported_vars.discard(%r)' % node.target)</font>
<font color="red"> 985.         frame.assigned_names.add(node.target)</font>
<font color="black"> 986. </font>
<font color="green"> 987.     def visit_FromImport(self, node, frame):</font>
<font color="black"> 988.         &quot;&quot;&quot;Visit named imports.&quot;&quot;&quot;</font>
<font color="red"> 989.         self.newline(node)</font>
<font color="red"> 990.         self.write('included_template = environment.get_template(')</font>
<font color="red"> 991.         self.visit(node.template, frame)</font>
<font color="red"> 992.         self.write(', %r).' % self.name)</font>
<font color="red"> 993.         if node.with_context:</font>
<font color="red"> 994.             self.write('make_module(context.parent, True)')</font>
<font color="black"> 995.         else:</font>
<font color="red"> 996.             self.write('module')</font>
<font color="black"> 997. </font>
<font color="red"> 998.         var_names = []</font>
<font color="red"> 999.         discarded_names = []</font>
<font color="red">1000.         for name in node.names:</font>
<font color="red">1001.             if isinstance(name, tuple):</font>
<font color="red">1002.                 name, alias = name</font>
<font color="black">1003.             else:</font>
<font color="red">1004.                 alias = name</font>
<font color="red">1005.             self.writeline('l_%s = getattr(included_template, '</font>
<font color="red">1006.                            '%r, missing)' % (alias, name))</font>
<font color="red">1007.             self.writeline('if l_%s is missing:' % alias)</font>
<font color="red">1008.             self.indent()</font>
<font color="red">1009.             self.writeline('l_%s = environment.undefined(%r %% '</font>
<font color="black">1010.                            'included_template.__name__, '</font>
<font color="black">1011.                            'name=%r)' %</font>
<font color="red">1012.                            (alias, 'the template %%r (imported on %s) does '</font>
<font color="black">1013.                            'not export the requested name %s' % (</font>
<font color="red">1014.                                 self.position(node),</font>
<font color="red">1015.                                 repr(name)</font>
<font color="red">1016.                            ), name))</font>
<font color="red">1017.             self.outdent()</font>
<font color="red">1018.             if frame.toplevel:</font>
<font color="red">1019.                 var_names.append(alias)</font>
<font color="red">1020.                 if not alias.startswith('_'):</font>
<font color="red">1021.                     discarded_names.append(alias)</font>
<font color="red">1022.             frame.assigned_names.add(alias)</font>
<font color="black">1023. </font>
<font color="red">1024.         if var_names:</font>
<font color="red">1025.             if len(var_names) == 1:</font>
<font color="red">1026.                 name = var_names[0]</font>
<font color="red">1027.                 self.writeline('context.vars[%r] = l_%s' % (name, name))</font>
<font color="black">1028.             else:</font>
<font color="red">1029.                 self.writeline('context.vars.update({%s})' % ', '.join(</font>
<font color="red">1030.                     '%r: l_%s' % (name, name) for name in var_names</font>
<font color="black">1031.                 ))</font>
<font color="red">1032.         if discarded_names:</font>
<font color="red">1033.             if len(discarded_names) == 1:</font>
<font color="red">1034.                 self.writeline('context.exported_vars.discard(%r)' %</font>
<font color="red">1035.                                discarded_names[0])</font>
<font color="black">1036.             else:</font>
<font color="red">1037.                 self.writeline('context.exported_vars.difference_'</font>
<font color="red">1038.                                'update((%s))' % ', '.join(imap(repr, discarded_names)))</font>
<font color="black">1039. </font>
<font color="green">1040.     def visit_For(self, node, frame):</font>
<font color="black">1041.         # when calculating the nodes for the inner frame we have to exclude</font>
<font color="black">1042.         # the iterator contents from it</font>
<font color="red">1043.         children = node.iter_child_nodes(exclude=('iter',))</font>
<font color="red">1044.         if node.recursive:</font>
<font color="red">1045.             loop_frame = self.function_scoping(node, frame, children,</font>
<font color="red">1046.                                                find_special=False)</font>
<font color="black">1047.         else:</font>
<font color="red">1048.             loop_frame = frame.inner()</font>
<font color="red">1049.             loop_frame.inspect(children)</font>
<font color="black">1050. </font>
<font color="black">1051.         # try to figure out if we have an extended loop.  An extended loop</font>
<font color="black">1052.         # is necessary if the loop is in recursive mode if the special loop</font>
<font color="black">1053.         # variable is accessed in the body.</font>
<font color="red">1054.         extended_loop = node.recursive or 'loop' in \</font>
<font color="red">1055.                         find_undeclared(node.iter_child_nodes(</font>
<font color="red">1056.                             only=('body',)), ('loop',))</font>
<font color="black">1057. </font>
<font color="black">1058.         # if we don't have an recursive loop we have to find the shadowed</font>
<font color="black">1059.         # variables at that point.  Because loops can be nested but the loop</font>
<font color="black">1060.         # variable is a special one we have to enforce aliasing for it.</font>
<font color="red">1061.         if not node.recursive:</font>
<font color="red">1062.             aliases = self.push_scope(loop_frame, ('loop',))</font>
<font color="black">1063. </font>
<font color="black">1064.         # otherwise we set up a buffer and add a function def</font>
<font color="black">1065.         else:</font>
<font color="red">1066.             self.writeline('def loop(reciter, loop_render_func, depth=0):', node)</font>
<font color="red">1067.             self.indent()</font>
<font color="red">1068.             self.buffer(loop_frame)</font>
<font color="red">1069.             aliases = {}</font>
<font color="black">1070. </font>
<font color="black">1071.         # make sure the loop variable is a special one and raise a template</font>
<font color="black">1072.         # assertion error if a loop tries to write to loop</font>
<font color="red">1073.         if extended_loop:</font>
<font color="red">1074.             self.writeline('l_loop = missing')</font>
<font color="red">1075.             loop_frame.identifiers.add_special('loop')</font>
<font color="red">1076.         for name in node.find_all(nodes.Name):</font>
<font color="red">1077.             if name.ctx == 'store' and name.name == 'loop':</font>
<font color="red">1078.                 self.fail('Can\'t assign to special loop variable '</font>
<font color="red">1079.                           'in for-loop target', name.lineno)</font>
<font color="black">1080. </font>
<font color="red">1081.         self.pull_locals(loop_frame)</font>
<font color="red">1082.         if node.else_:</font>
<font color="red">1083.             iteration_indicator = self.temporary_identifier()</font>
<font color="red">1084.             self.writeline('%s = 1' % iteration_indicator)</font>
<font color="black">1085. </font>
<font color="black">1086.         # Create a fake parent loop if the else or test section of a</font>
<font color="black">1087.         # loop is accessing the special loop variable and no parent loop</font>
<font color="black">1088.         # exists.</font>
<font color="red">1089.         if 'loop' not in aliases and 'loop' in find_undeclared(</font>
<font color="red">1090.            node.iter_child_nodes(only=('else_', 'test')), ('loop',)):</font>
<font color="red">1091.             self.writeline(&quot;l_loop = environment.undefined(%r, name='loop')&quot; %</font>
<font color="red">1092.                 (&quot;'loop' is undefined. the filter section of a loop as well &quot;</font>
<font color="black">1093.                  &quot;as the else block don't have access to the special 'loop'&quot;</font>
<font color="black">1094.                  &quot; variable of the current loop.  Because there is no parent &quot;</font>
<font color="black">1095.                  &quot;loop it's undefined.  Happened in loop on %s&quot; %</font>
<font color="red">1096.                  self.position(node)))</font>
<font color="black">1097. </font>
<font color="red">1098.         self.writeline('for ', node)</font>
<font color="red">1099.         self.visit(node.target, loop_frame)</font>
<font color="red">1100.         self.write(extended_loop and ', l_loop in LoopContext(' or ' in ')</font>
<font color="black">1101. </font>
<font color="black">1102.         # if we have an extened loop and a node test, we filter in the</font>
<font color="black">1103.         # &quot;outer frame&quot;.</font>
<font color="red">1104.         if extended_loop and node.test is not None:</font>
<font color="red">1105.             self.write('(')</font>
<font color="red">1106.             self.visit(node.target, loop_frame)</font>
<font color="red">1107.             self.write(' for ')</font>
<font color="red">1108.             self.visit(node.target, loop_frame)</font>
<font color="red">1109.             self.write(' in ')</font>
<font color="red">1110.             if node.recursive:</font>
<font color="red">1111.                 self.write('reciter')</font>
<font color="black">1112.             else:</font>
<font color="red">1113.                 self.visit(node.iter, loop_frame)</font>
<font color="red">1114.             self.write(' if (')</font>
<font color="red">1115.             test_frame = loop_frame.copy()</font>
<font color="red">1116.             self.visit(node.test, test_frame)</font>
<font color="red">1117.             self.write('))')</font>
<font color="black">1118. </font>
<font color="red">1119.         elif node.recursive:</font>
<font color="red">1120.             self.write('reciter')</font>
<font color="black">1121.         else:</font>
<font color="red">1122.             self.visit(node.iter, loop_frame)</font>
<font color="black">1123. </font>
<font color="red">1124.         if node.recursive:</font>
<font color="red">1125.             self.write(', loop_render_func, depth):')</font>
<font color="black">1126.         else:</font>
<font color="red">1127.             self.write(extended_loop and '):' or ':')</font>
<font color="black">1128. </font>
<font color="black">1129.         # tests in not extended loops become a continue</font>
<font color="red">1130.         if not extended_loop and node.test is not None:</font>
<font color="red">1131.             self.indent()</font>
<font color="red">1132.             self.writeline('if not ')</font>
<font color="red">1133.             self.visit(node.test, loop_frame)</font>
<font color="red">1134.             self.write(':')</font>
<font color="red">1135.             self.indent()</font>
<font color="red">1136.             self.writeline('continue')</font>
<font color="red">1137.             self.outdent(2)</font>
<font color="black">1138. </font>
<font color="red">1139.         self.indent()</font>
<font color="red">1140.         self.blockvisit(node.body, loop_frame)</font>
<font color="red">1141.         if node.else_:</font>
<font color="red">1142.             self.writeline('%s = 0' % iteration_indicator)</font>
<font color="red">1143.         self.outdent()</font>
<font color="black">1144. </font>
<font color="red">1145.         if node.else_:</font>
<font color="red">1146.             self.writeline('if %s:' % iteration_indicator)</font>
<font color="red">1147.             self.indent()</font>
<font color="red">1148.             self.blockvisit(node.else_, loop_frame)</font>
<font color="red">1149.             self.outdent()</font>
<font color="black">1150. </font>
<font color="black">1151.         # reset the aliases if there are any.</font>
<font color="red">1152.         if not node.recursive:</font>
<font color="red">1153.             self.pop_scope(aliases, loop_frame)</font>
<font color="black">1154. </font>
<font color="black">1155.         # if the node was recursive we have to return the buffer contents</font>
<font color="black">1156.         # and start the iteration code</font>
<font color="red">1157.         if node.recursive:</font>
<font color="red">1158.             self.return_buffer_contents(loop_frame)</font>
<font color="red">1159.             self.outdent()</font>
<font color="red">1160.             self.start_write(frame, node)</font>
<font color="red">1161.             self.write('loop(')</font>
<font color="red">1162.             self.visit(node.iter, frame)</font>
<font color="red">1163.             self.write(', loop)')</font>
<font color="red">1164.             self.end_write(frame)</font>
<font color="black">1165. </font>
<font color="green">1166.     def visit_If(self, node, frame):</font>
<font color="red">1167.         if_frame = frame.soft()</font>
<font color="red">1168.         self.writeline('if ', node)</font>
<font color="red">1169.         self.visit(node.test, if_frame)</font>
<font color="red">1170.         self.write(':')</font>
<font color="red">1171.         self.indent()</font>
<font color="red">1172.         self.blockvisit(node.body, if_frame)</font>
<font color="red">1173.         self.outdent()</font>
<font color="red">1174.         if node.else_:</font>
<font color="red">1175.             self.writeline('else:')</font>
<font color="red">1176.             self.indent()</font>
<font color="red">1177.             self.blockvisit(node.else_, if_frame)</font>
<font color="red">1178.             self.outdent()</font>
<font color="black">1179. </font>
<font color="green">1180.     def visit_Macro(self, node, frame):</font>
<font color="red">1181.         macro_frame = self.macro_body(node, frame)</font>
<font color="red">1182.         self.newline()</font>
<font color="red">1183.         if frame.toplevel:</font>
<font color="red">1184.             if not node.name.startswith('_'):</font>
<font color="red">1185.                 self.write('context.exported_vars.add(%r)' % node.name)</font>
<font color="red">1186.             self.writeline('context.vars[%r] = ' % node.name)</font>
<font color="red">1187.         self.write('l_%s = ' % node.name)</font>
<font color="red">1188.         self.macro_def(node, macro_frame)</font>
<font color="red">1189.         frame.assigned_names.add(node.name)</font>
<font color="black">1190. </font>
<font color="green">1191.     def visit_CallBlock(self, node, frame):</font>
<font color="red">1192.         children = node.iter_child_nodes(exclude=('call',))</font>
<font color="red">1193.         call_frame = self.macro_body(node, frame, children)</font>
<font color="red">1194.         self.writeline('caller = ')</font>
<font color="red">1195.         self.macro_def(node, call_frame)</font>
<font color="red">1196.         self.start_write(frame, node)</font>
<font color="red">1197.         self.visit_Call(node.call, call_frame, forward_caller=True)</font>
<font color="red">1198.         self.end_write(frame)</font>
<font color="black">1199. </font>
<font color="green">1200.     def visit_FilterBlock(self, node, frame):</font>
<font color="red">1201.         filter_frame = frame.inner()</font>
<font color="red">1202.         filter_frame.inspect(node.iter_child_nodes())</font>
<font color="red">1203.         aliases = self.push_scope(filter_frame)</font>
<font color="red">1204.         self.pull_locals(filter_frame)</font>
<font color="red">1205.         self.buffer(filter_frame)</font>
<font color="red">1206.         self.blockvisit(node.body, filter_frame)</font>
<font color="red">1207.         self.start_write(frame, node)</font>
<font color="red">1208.         self.visit_Filter(node.filter, filter_frame)</font>
<font color="red">1209.         self.end_write(frame)</font>
<font color="red">1210.         self.pop_scope(aliases, filter_frame)</font>
<font color="black">1211. </font>
<font color="green">1212.     def visit_ExprStmt(self, node, frame):</font>
<font color="red">1213.         self.newline(node)</font>
<font color="red">1214.         self.visit(node.node, frame)</font>
<font color="black">1215. </font>
<font color="green">1216.     def visit_Output(self, node, frame):</font>
<font color="black">1217.         # if we have a known extends statement, we don't output anything</font>
<font color="black">1218.         # if we are in a require_output_check section</font>
<font color="red">1219.         if self.has_known_extends and frame.require_output_check:</font>
<font color="red">1220.             return</font>
<font color="black">1221. </font>
<font color="red">1222.         allow_constant_finalize = True</font>
<font color="red">1223.         if self.environment.finalize:</font>
<font color="red">1224.             func = self.environment.finalize</font>
<font color="red">1225.             if getattr(func, 'contextfunction', False) or \</font>
<font color="red">1226.                getattr(func, 'evalcontextfunction', False):</font>
<font color="red">1227.                 allow_constant_finalize = False</font>
<font color="red">1228.             elif getattr(func, 'environmentfunction', False):</font>
<font color="red">1229.                 finalize = lambda x: text_type(</font>
<font color="red">1230.                     self.environment.finalize(self.environment, x))</font>
<font color="black">1231.             else:</font>
<font color="red">1232.                 finalize = lambda x: text_type(self.environment.finalize(x))</font>
<font color="black">1233.         else:</font>
<font color="red">1234.             finalize = text_type</font>
<font color="black">1235. </font>
<font color="black">1236.         # if we are inside a frame that requires output checking, we do so</font>
<font color="red">1237.         outdent_later = False</font>
<font color="red">1238.         if frame.require_output_check:</font>
<font color="red">1239.             self.writeline('if parent_template is None:')</font>
<font color="red">1240.             self.indent()</font>
<font color="red">1241.             outdent_later = True</font>
<font color="black">1242. </font>
<font color="black">1243.         # try to evaluate as many chunks as possible into a static</font>
<font color="black">1244.         # string at compile time.</font>
<font color="red">1245.         body = []</font>
<font color="red">1246.         for child in node.nodes:</font>
<font color="red">1247.             try:</font>
<font color="red">1248.                 if not allow_constant_finalize:</font>
<font color="red">1249.                     raise nodes.Impossible()</font>
<font color="red">1250.                 const = child.as_const(frame.eval_ctx)</font>
<font color="red">1251.             except nodes.Impossible:</font>
<font color="red">1252.                 body.append(child)</font>
<font color="red">1253.                 continue</font>
<font color="black">1254.             # the frame can't be volatile here, becaus otherwise the</font>
<font color="black">1255.             # as_const() function would raise an Impossible exception</font>
<font color="black">1256.             # at that point.</font>
<font color="red">1257.             try:</font>
<font color="red">1258.                 if frame.eval_ctx.autoescape:</font>
<font color="red">1259.                     if hasattr(const, '__html__'):</font>
<font color="red">1260.                         const = const.__html__()</font>
<font color="black">1261.                     else:</font>
<font color="red">1262.                         const = escape(const)</font>
<font color="red">1263.                 const = finalize(const)</font>
<font color="red">1264.             except Exception:</font>
<font color="black">1265.                 # if something goes wrong here we evaluate the node</font>
<font color="black">1266.                 # at runtime for easier debugging</font>
<font color="red">1267.                 body.append(child)</font>
<font color="red">1268.                 continue</font>
<font color="red">1269.             if body and isinstance(body[-1], list):</font>
<font color="red">1270.                 body[-1].append(const)</font>
<font color="black">1271.             else:</font>
<font color="red">1272.                 body.append([const])</font>
<font color="black">1273. </font>
<font color="black">1274.         # if we have less than 3 nodes or a buffer we yield or extend/append</font>
<font color="red">1275.         if len(body) &lt; 3 or frame.buffer is not None:</font>
<font color="red">1276.             if frame.buffer is not None:</font>
<font color="black">1277.                 # for one item we append, for more we extend</font>
<font color="red">1278.                 if len(body) == 1:</font>
<font color="red">1279.                     self.writeline('%s.append(' % frame.buffer)</font>
<font color="black">1280.                 else:</font>
<font color="red">1281.                     self.writeline('%s.extend((' % frame.buffer)</font>
<font color="red">1282.                 self.indent()</font>
<font color="red">1283.             for item in body:</font>
<font color="red">1284.                 if isinstance(item, list):</font>
<font color="red">1285.                     val = repr(concat(item))</font>
<font color="red">1286.                     if frame.buffer is None:</font>
<font color="red">1287.                         self.writeline('yield ' + val)</font>
<font color="black">1288.                     else:</font>
<font color="red">1289.                         self.writeline(val + ', ')</font>
<font color="black">1290.                 else:</font>
<font color="red">1291.                     if frame.buffer is None:</font>
<font color="red">1292.                         self.writeline('yield ', item)</font>
<font color="black">1293.                     else:</font>
<font color="red">1294.                         self.newline(item)</font>
<font color="red">1295.                     close = 1</font>
<font color="red">1296.                     if frame.eval_ctx.volatile:</font>
<font color="red">1297.                         self.write('(context.eval_ctx.autoescape and'</font>
<font color="black">1298.                                    ' escape or to_string)(')</font>
<font color="red">1299.                     elif frame.eval_ctx.autoescape:</font>
<font color="red">1300.                         self.write('escape(')</font>
<font color="black">1301.                     else:</font>
<font color="red">1302.                         self.write('to_string(')</font>
<font color="red">1303.                     if self.environment.finalize is not None:</font>
<font color="red">1304.                         self.write('environment.finalize(')</font>
<font color="red">1305.                         if getattr(self.environment.finalize,</font>
<font color="red">1306.                                    &quot;contextfunction&quot;, False):</font>
<font color="red">1307.                             self.write('context, ')</font>
<font color="red">1308.                         close += 1</font>
<font color="red">1309.                     self.visit(item, frame)</font>
<font color="red">1310.                     self.write(')' * close)</font>
<font color="red">1311.                     if frame.buffer is not None:</font>
<font color="red">1312.                         self.write(', ')</font>
<font color="red">1313.             if frame.buffer is not None:</font>
<font color="black">1314.                 # close the open parentheses</font>
<font color="red">1315.                 self.outdent()</font>
<font color="red">1316.                 self.writeline(len(body) == 1 and ')' or '))')</font>
<font color="black">1317. </font>
<font color="black">1318.         # otherwise we create a format string as this is faster in that case</font>
<font color="black">1319.         else:</font>
<font color="red">1320.             format = []</font>
<font color="red">1321.             arguments = []</font>
<font color="red">1322.             for item in body:</font>
<font color="red">1323.                 if isinstance(item, list):</font>
<font color="red">1324.                     format.append(concat(item).replace('%', '%%'))</font>
<font color="black">1325.                 else:</font>
<font color="red">1326.                     format.append('%s')</font>
<font color="red">1327.                     arguments.append(item)</font>
<font color="red">1328.             self.writeline('yield ')</font>
<font color="red">1329.             self.write(repr(concat(format)) + ' % (')</font>
<font color="red">1330.             self.indent()</font>
<font color="red">1331.             for argument in arguments:</font>
<font color="red">1332.                 self.newline(argument)</font>
<font color="red">1333.                 close = 0</font>
<font color="red">1334.                 if frame.eval_ctx.volatile:</font>
<font color="red">1335.                     self.write('(context.eval_ctx.autoescape and'</font>
<font color="black">1336.                                ' escape or to_string)(')</font>
<font color="red">1337.                     close += 1</font>
<font color="red">1338.                 elif frame.eval_ctx.autoescape:</font>
<font color="red">1339.                     self.write('escape(')</font>
<font color="red">1340.                     close += 1</font>
<font color="red">1341.                 if self.environment.finalize is not None:</font>
<font color="red">1342.                     self.write('environment.finalize(')</font>
<font color="red">1343.                     if getattr(self.environment.finalize,</font>
<font color="red">1344.                                'contextfunction', False):</font>
<font color="red">1345.                         self.write('context, ')</font>
<font color="red">1346.                     elif getattr(self.environment.finalize,</font>
<font color="red">1347.                                'evalcontextfunction', False):</font>
<font color="red">1348.                         self.write('context.eval_ctx, ')</font>
<font color="red">1349.                     elif getattr(self.environment.finalize,</font>
<font color="red">1350.                                'environmentfunction', False):</font>
<font color="red">1351.                         self.write('environment, ')</font>
<font color="red">1352.                     close += 1</font>
<font color="red">1353.                 self.visit(argument, frame)</font>
<font color="red">1354.                 self.write(')' * close + ', ')</font>
<font color="red">1355.             self.outdent()</font>
<font color="red">1356.             self.writeline(')')</font>
<font color="black">1357. </font>
<font color="red">1358.         if outdent_later:</font>
<font color="red">1359.             self.outdent()</font>
<font color="black">1360. </font>
<font color="green">1361.     def make_assignment_frame(self, frame):</font>
<font color="black">1362.         # toplevel assignments however go into the local namespace and</font>
<font color="black">1363.         # the current template's context.  We create a copy of the frame</font>
<font color="black">1364.         # here and add a set so that the Name visitor can add the assigned</font>
<font color="black">1365.         # names here.</font>
<font color="red">1366.         if not frame.toplevel:</font>
<font color="red">1367.             return frame</font>
<font color="red">1368.         assignment_frame = frame.copy()</font>
<font color="red">1369.         assignment_frame.toplevel_assignments = set()</font>
<font color="red">1370.         return assignment_frame</font>
<font color="black">1371. </font>
<font color="green">1372.     def export_assigned_vars(self, frame, assignment_frame):</font>
<font color="red">1373.         if not frame.toplevel:</font>
<font color="red">1374.             return</font>
<font color="red">1375.         public_names = [x for x in assignment_frame.toplevel_assignments</font>
<font color="red">1376.                         if not x.startswith('_')]</font>
<font color="red">1377.         if len(assignment_frame.toplevel_assignments) == 1:</font>
<font color="red">1378.             name = next(iter(assignment_frame.toplevel_assignments))</font>
<font color="red">1379.             self.writeline('context.vars[%r] = l_%s' % (name, name))</font>
<font color="black">1380.         else:</font>
<font color="red">1381.             self.writeline('context.vars.update({')</font>
<font color="red">1382.             for idx, name in enumerate(assignment_frame.toplevel_assignments):</font>
<font color="red">1383.                 if idx:</font>
<font color="red">1384.                     self.write(', ')</font>
<font color="red">1385.                 self.write('%r: l_%s' % (name, name))</font>
<font color="red">1386.             self.write('})')</font>
<font color="red">1387.         if public_names:</font>
<font color="red">1388.             if len(public_names) == 1:</font>
<font color="red">1389.                 self.writeline('context.exported_vars.add(%r)' %</font>
<font color="red">1390.                                public_names[0])</font>
<font color="black">1391.             else:</font>
<font color="red">1392.                 self.writeline('context.exported_vars.update((%s))' %</font>
<font color="red">1393.                                ', '.join(imap(repr, public_names)))</font>
<font color="black">1394. </font>
<font color="green">1395.     def visit_Assign(self, node, frame):</font>
<font color="red">1396.         self.newline(node)</font>
<font color="red">1397.         assignment_frame = self.make_assignment_frame(frame)</font>
<font color="red">1398.         self.visit(node.target, assignment_frame)</font>
<font color="red">1399.         self.write(' = ')</font>
<font color="red">1400.         self.visit(node.node, frame)</font>
<font color="red">1401.         self.export_assigned_vars(frame, assignment_frame)</font>
<font color="black">1402. </font>
<font color="green">1403.     def visit_AssignBlock(self, node, frame):</font>
<font color="red">1404.         block_frame = frame.inner()</font>
<font color="red">1405.         block_frame.inspect(node.body)</font>
<font color="red">1406.         aliases = self.push_scope(block_frame)</font>
<font color="red">1407.         self.pull_locals(block_frame)</font>
<font color="red">1408.         self.buffer(block_frame)</font>
<font color="red">1409.         self.blockvisit(node.body, block_frame)</font>
<font color="red">1410.         self.pop_scope(aliases, block_frame)</font>
<font color="black">1411. </font>
<font color="red">1412.         assignment_frame = self.make_assignment_frame(frame)</font>
<font color="red">1413.         self.newline(node)</font>
<font color="red">1414.         self.visit(node.target, assignment_frame)</font>
<font color="red">1415.         self.write(' = concat(%s)' % block_frame.buffer)</font>
<font color="red">1416.         self.export_assigned_vars(frame, assignment_frame)</font>
<font color="black">1417. </font>
<font color="black">1418.     # -- Expression Visitors</font>
<font color="black">1419. </font>
<font color="green">1420.     def visit_Name(self, node, frame):</font>
<font color="red">1421.         if node.ctx == 'store' and frame.toplevel:</font>
<font color="red">1422.             frame.toplevel_assignments.add(node.name)</font>
<font color="red">1423.         self.write('l_' + node.name)</font>
<font color="red">1424.         frame.assigned_names.add(node.name)</font>
<font color="black">1425. </font>
<font color="green">1426.     def visit_Const(self, node, frame):</font>
<font color="red">1427.         val = node.value</font>
<font color="red">1428.         if isinstance(val, float):</font>
<font color="red">1429.             self.write(str(val))</font>
<font color="black">1430.         else:</font>
<font color="red">1431.             self.write(repr(val))</font>
<font color="black">1432. </font>
<font color="green">1433.     def visit_TemplateData(self, node, frame):</font>
<font color="red">1434.         try:</font>
<font color="red">1435.             self.write(repr(node.as_const(frame.eval_ctx)))</font>
<font color="red">1436.         except nodes.Impossible:</font>
<font color="red">1437.             self.write('(context.eval_ctx.autoescape and Markup or identity)(%r)'</font>
<font color="red">1438.                        % node.data)</font>
<font color="black">1439. </font>
<font color="green">1440.     def visit_Tuple(self, node, frame):</font>
<font color="red">1441.         self.write('(')</font>
<font color="red">1442.         idx = -1</font>
<font color="red">1443.         for idx, item in enumerate(node.items):</font>
<font color="red">1444.             if idx:</font>
<font color="red">1445.                 self.write(', ')</font>
<font color="red">1446.             self.visit(item, frame)</font>
<font color="red">1447.         self.write(idx == 0 and ',)' or ')')</font>
<font color="black">1448. </font>
<font color="green">1449.     def visit_List(self, node, frame):</font>
<font color="red">1450.         self.write('[')</font>
<font color="red">1451.         for idx, item in enumerate(node.items):</font>
<font color="red">1452.             if idx:</font>
<font color="red">1453.                 self.write(', ')</font>
<font color="red">1454.             self.visit(item, frame)</font>
<font color="red">1455.         self.write(']')</font>
<font color="black">1456. </font>
<font color="green">1457.     def visit_Dict(self, node, frame):</font>
<font color="red">1458.         self.write('{')</font>
<font color="red">1459.         for idx, item in enumerate(node.items):</font>
<font color="red">1460.             if idx:</font>
<font color="red">1461.                 self.write(', ')</font>
<font color="red">1462.             self.visit(item.key, frame)</font>
<font color="red">1463.             self.write(': ')</font>
<font color="red">1464.             self.visit(item.value, frame)</font>
<font color="red">1465.         self.write('}')</font>
<font color="black">1466. </font>
<font color="green">1467.     def binop(operator, interceptable=True):</font>
<font color="green">1468.         def visitor(self, node, frame):</font>
<font color="red">1469.             if self.environment.sandboxed and \</font>
<font color="red">1470.                operator in self.environment.intercepted_binops:</font>
<font color="red">1471.                 self.write('environment.call_binop(context, %r, ' % operator)</font>
<font color="red">1472.                 self.visit(node.left, frame)</font>
<font color="red">1473.                 self.write(', ')</font>
<font color="red">1474.                 self.visit(node.right, frame)</font>
<font color="black">1475.             else:</font>
<font color="red">1476.                 self.write('(')</font>
<font color="red">1477.                 self.visit(node.left, frame)</font>
<font color="red">1478.                 self.write(' %s ' % operator)</font>
<font color="red">1479.                 self.visit(node.right, frame)</font>
<font color="red">1480.             self.write(')')</font>
<font color="green">1481.         return visitor</font>
<font color="black">1482. </font>
<font color="green">1483.     def uaop(operator, interceptable=True):</font>
<font color="green">1484.         def visitor(self, node, frame):</font>
<font color="red">1485.             if self.environment.sandboxed and \</font>
<font color="red">1486.                operator in self.environment.intercepted_unops:</font>
<font color="red">1487.                 self.write('environment.call_unop(context, %r, ' % operator)</font>
<font color="red">1488.                 self.visit(node.node, frame)</font>
<font color="black">1489.             else:</font>
<font color="red">1490.                 self.write('(' + operator)</font>
<font color="red">1491.                 self.visit(node.node, frame)</font>
<font color="red">1492.             self.write(')')</font>
<font color="green">1493.         return visitor</font>
<font color="black">1494. </font>
<font color="green">1495.     visit_Add = binop('+')</font>
<font color="green">1496.     visit_Sub = binop('-')</font>
<font color="green">1497.     visit_Mul = binop('*')</font>
<font color="green">1498.     visit_Div = binop('/')</font>
<font color="green">1499.     visit_FloorDiv = binop('//')</font>
<font color="green">1500.     visit_Pow = binop('**')</font>
<font color="green">1501.     visit_Mod = binop('%')</font>
<font color="green">1502.     visit_And = binop('and', interceptable=False)</font>
<font color="green">1503.     visit_Or = binop('or', interceptable=False)</font>
<font color="green">1504.     visit_Pos = uaop('+')</font>
<font color="green">1505.     visit_Neg = uaop('-')</font>
<font color="green">1506.     visit_Not = uaop('not ', interceptable=False)</font>
<font color="green">1507.     del binop, uaop</font>
<font color="black">1508. </font>
<font color="green">1509.     def visit_Concat(self, node, frame):</font>
<font color="red">1510.         if frame.eval_ctx.volatile:</font>
<font color="red">1511.             func_name = '(context.eval_ctx.volatile and' \</font>
<font color="black">1512.                         ' markup_join or unicode_join)'</font>
<font color="red">1513.         elif frame.eval_ctx.autoescape:</font>
<font color="red">1514.             func_name = 'markup_join'</font>
<font color="black">1515.         else:</font>
<font color="red">1516.             func_name = 'unicode_join'</font>
<font color="red">1517.         self.write('%s((' % func_name)</font>
<font color="red">1518.         for arg in node.nodes:</font>
<font color="red">1519.             self.visit(arg, frame)</font>
<font color="red">1520.             self.write(', ')</font>
<font color="red">1521.         self.write('))')</font>
<font color="black">1522. </font>
<font color="green">1523.     def visit_Compare(self, node, frame):</font>
<font color="red">1524.         self.visit(node.expr, frame)</font>
<font color="red">1525.         for op in node.ops:</font>
<font color="red">1526.             self.visit(op, frame)</font>
<font color="black">1527. </font>
<font color="green">1528.     def visit_Operand(self, node, frame):</font>
<font color="red">1529.         self.write(' %s ' % operators[node.op])</font>
<font color="red">1530.         self.visit(node.expr, frame)</font>
<font color="black">1531. </font>
<font color="green">1532.     def visit_Getattr(self, node, frame):</font>
<font color="red">1533.         self.write('environment.getattr(')</font>
<font color="red">1534.         self.visit(node.node, frame)</font>
<font color="red">1535.         self.write(', %r)' % node.attr)</font>
<font color="black">1536. </font>
<font color="green">1537.     def visit_Getitem(self, node, frame):</font>
<font color="black">1538.         # slices bypass the environment getitem method.</font>
<font color="red">1539.         if isinstance(node.arg, nodes.Slice):</font>
<font color="red">1540.             self.visit(node.node, frame)</font>
<font color="red">1541.             self.write('[')</font>
<font color="red">1542.             self.visit(node.arg, frame)</font>
<font color="red">1543.             self.write(']')</font>
<font color="black">1544.         else:</font>
<font color="red">1545.             self.write('environment.getitem(')</font>
<font color="red">1546.             self.visit(node.node, frame)</font>
<font color="red">1547.             self.write(', ')</font>
<font color="red">1548.             self.visit(node.arg, frame)</font>
<font color="red">1549.             self.write(')')</font>
<font color="black">1550. </font>
<font color="green">1551.     def visit_Slice(self, node, frame):</font>
<font color="red">1552.         if node.start is not None:</font>
<font color="red">1553.             self.visit(node.start, frame)</font>
<font color="red">1554.         self.write(':')</font>
<font color="red">1555.         if node.stop is not None:</font>
<font color="red">1556.             self.visit(node.stop, frame)</font>
<font color="red">1557.         if node.step is not None:</font>
<font color="red">1558.             self.write(':')</font>
<font color="red">1559.             self.visit(node.step, frame)</font>
<font color="black">1560. </font>
<font color="green">1561.     def visit_Filter(self, node, frame):</font>
<font color="red">1562.         self.write(self.filters[node.name] + '(')</font>
<font color="red">1563.         func = self.environment.filters.get(node.name)</font>
<font color="red">1564.         if func is None:</font>
<font color="red">1565.             self.fail('no filter named %r' % node.name, node.lineno)</font>
<font color="red">1566.         if getattr(func, 'contextfilter', False):</font>
<font color="red">1567.             self.write('context, ')</font>
<font color="red">1568.         elif getattr(func, 'evalcontextfilter', False):</font>
<font color="red">1569.             self.write('context.eval_ctx, ')</font>
<font color="red">1570.         elif getattr(func, 'environmentfilter', False):</font>
<font color="red">1571.             self.write('environment, ')</font>
<font color="black">1572. </font>
<font color="black">1573.         # if the filter node is None we are inside a filter block</font>
<font color="black">1574.         # and want to write to the current buffer</font>
<font color="red">1575.         if node.node is not None:</font>
<font color="red">1576.             self.visit(node.node, frame)</font>
<font color="red">1577.         elif frame.eval_ctx.volatile:</font>
<font color="red">1578.             self.write('(context.eval_ctx.autoescape and'</font>
<font color="black">1579.                        ' Markup(concat(%s)) or concat(%s))' %</font>
<font color="red">1580.                        (frame.buffer, frame.buffer))</font>
<font color="red">1581.         elif frame.eval_ctx.autoescape:</font>
<font color="red">1582.             self.write('Markup(concat(%s))' % frame.buffer)</font>
<font color="black">1583.         else:</font>
<font color="red">1584.             self.write('concat(%s)' % frame.buffer)</font>
<font color="red">1585.         self.signature(node, frame)</font>
<font color="red">1586.         self.write(')')</font>
<font color="black">1587. </font>
<font color="green">1588.     def visit_Test(self, node, frame):</font>
<font color="red">1589.         self.write(self.tests[node.name] + '(')</font>
<font color="red">1590.         if node.name not in self.environment.tests:</font>
<font color="red">1591.             self.fail('no test named %r' % node.name, node.lineno)</font>
<font color="red">1592.         self.visit(node.node, frame)</font>
<font color="red">1593.         self.signature(node, frame)</font>
<font color="red">1594.         self.write(')')</font>
<font color="black">1595. </font>
<font color="green">1596.     def visit_CondExpr(self, node, frame):</font>
<font color="red">1597.         def write_expr2():</font>
<font color="red">1598.             if node.expr2 is not None:</font>
<font color="red">1599.                 return self.visit(node.expr2, frame)</font>
<font color="red">1600.             self.write('environment.undefined(%r)' % ('the inline if-'</font>
<font color="black">1601.                        'expression on %s evaluated to false and '</font>
<font color="red">1602.                        'no else section was defined.' % self.position(node)))</font>
<font color="black">1603. </font>
<font color="red">1604.         self.write('(')</font>
<font color="red">1605.         self.visit(node.expr1, frame)</font>
<font color="red">1606.         self.write(' if ')</font>
<font color="red">1607.         self.visit(node.test, frame)</font>
<font color="red">1608.         self.write(' else ')</font>
<font color="red">1609.         write_expr2()</font>
<font color="red">1610.         self.write(')')</font>
<font color="black">1611. </font>
<font color="green">1612.     def visit_Call(self, node, frame, forward_caller=False):</font>
<font color="red">1613.         if self.environment.sandboxed:</font>
<font color="red">1614.             self.write('environment.call(context, ')</font>
<font color="black">1615.         else:</font>
<font color="red">1616.             self.write('context.call(')</font>
<font color="red">1617.         self.visit(node.node, frame)</font>
<font color="red">1618.         extra_kwargs = forward_caller and {'caller': 'caller'} or None</font>
<font color="red">1619.         self.signature(node, frame, extra_kwargs)</font>
<font color="red">1620.         self.write(')')</font>
<font color="black">1621. </font>
<font color="green">1622.     def visit_Keyword(self, node, frame):</font>
<font color="red">1623.         self.write(node.key + '=')</font>
<font color="red">1624.         self.visit(node.value, frame)</font>
<font color="black">1625. </font>
<font color="black">1626.     # -- Unused nodes for extensions</font>
<font color="black">1627. </font>
<font color="green">1628.     def visit_MarkSafe(self, node, frame):</font>
<font color="red">1629.         self.write('Markup(')</font>
<font color="red">1630.         self.visit(node.expr, frame)</font>
<font color="red">1631.         self.write(')')</font>
<font color="black">1632. </font>
<font color="green">1633.     def visit_MarkSafeIfAutoescape(self, node, frame):</font>
<font color="red">1634.         self.write('(context.eval_ctx.autoescape and Markup or identity)(')</font>
<font color="red">1635.         self.visit(node.expr, frame)</font>
<font color="red">1636.         self.write(')')</font>
<font color="black">1637. </font>
<font color="green">1638.     def visit_EnvironmentAttribute(self, node, frame):</font>
<font color="red">1639.         self.write('environment.' + node.name)</font>
<font color="black">1640. </font>
<font color="green">1641.     def visit_ExtensionAttribute(self, node, frame):</font>
<font color="red">1642.         self.write('environment.extensions[%r].%s' % (node.identifier, node.name))</font>
<font color="black">1643. </font>
<font color="green">1644.     def visit_ImportedName(self, node, frame):</font>
<font color="red">1645.         self.write(self.import_aliases[node.importname])</font>
<font color="black">1646. </font>
<font color="green">1647.     def visit_InternalName(self, node, frame):</font>
<font color="red">1648.         self.write(node.name)</font>
<font color="black">1649. </font>
<font color="green">1650.     def visit_ContextReference(self, node, frame):</font>
<font color="red">1651.         self.write('context')</font>
<font color="black">1652. </font>
<font color="green">1653.     def visit_Continue(self, node, frame):</font>
<font color="red">1654.         self.writeline('continue', node)</font>
<font color="black">1655. </font>
<font color="green">1656.     def visit_Break(self, node, frame):</font>
<font color="red">1657.         self.writeline('break', node)</font>
<font color="black">1658. </font>
<font color="green">1659.     def visit_Scope(self, node, frame):</font>
<font color="red">1660.         scope_frame = frame.inner()</font>
<font color="red">1661.         scope_frame.inspect(node.iter_child_nodes())</font>
<font color="red">1662.         aliases = self.push_scope(scope_frame)</font>
<font color="red">1663.         self.pull_locals(scope_frame)</font>
<font color="red">1664.         self.blockvisit(node.body, scope_frame)</font>
<font color="red">1665.         self.pop_scope(aliases, scope_frame)</font>
<font color="black">1666. </font>
<font color="green">1667.     def visit_EvalContextModifier(self, node, frame):</font>
<font color="red">1668.         for keyword in node.options:</font>
<font color="red">1669.             self.writeline('context.eval_ctx.%s = ' % keyword.key)</font>
<font color="red">1670.             self.visit(keyword.value, frame)</font>
<font color="red">1671.             try:</font>
<font color="red">1672.                 val = keyword.value.as_const(frame.eval_ctx)</font>
<font color="red">1673.             except nodes.Impossible:</font>
<font color="red">1674.                 frame.eval_ctx.volatile = True</font>
<font color="black">1675.             else:</font>
<font color="red">1676.                 setattr(frame.eval_ctx, keyword.key, val)</font>
<font color="black">1677. </font>
<font color="green">1678.     def visit_ScopedEvalContextModifier(self, node, frame):</font>
<font color="red">1679.         old_ctx_name = self.temporary_identifier()</font>
<font color="red">1680.         safed_ctx = frame.eval_ctx.save()</font>
<font color="red">1681.         self.writeline('%s = context.eval_ctx.save()' % old_ctx_name)</font>
<font color="red">1682.         self.visit_EvalContextModifier(node, frame)</font>
<font color="red">1683.         for child in node.body:</font>
<font color="red">1684.             self.visit(child, frame)</font>
<font color="red">1685.         frame.eval_ctx.revert(safed_ctx)</font>
<font color="red">1686.         self.writeline('context.eval_ctx.revert(%s)' % old_ctx_name)</font>
</pre>

