source file: <b>/usr/lib/python2.7/email/base64mime.py</b><br>


file stats: <b>63 lines, 24 executed: 38.1% covered</b>
<pre>
<font color="black">   1. # Copyright (C) 2002-2006 Python Software Foundation</font>
<font color="black">   2. # Author: Ben Gertzfield</font>
<font color="black">   3. # Contact: email-sig@python.org</font>
<font color="black">   4. </font>
<font color="black">   5. &quot;&quot;&quot;Base64 content transfer encoding per RFCs 2045-2047.</font>
<font color="black">   6. </font>
<font color="black">   7. This module handles the content transfer encoding method defined in RFC 2045</font>
<font color="black">   8. to encode arbitrary 8-bit data using the three 8-bit bytes in four 7-bit</font>
<font color="black">   9. characters encoding known as Base64.</font>
<font color="black">  10. </font>
<font color="black">  11. It is used in the MIME standards for email to attach images, audio, and text</font>
<font color="black">  12. using some 8-bit character sets to messages.</font>
<font color="black">  13. </font>
<font color="black">  14. This module provides an interface to encode and decode both headers and bodies</font>
<font color="black">  15. with Base64 encoding.</font>
<font color="black">  16. </font>
<font color="black">  17. RFC 2045 defines a method for including character set information in an</font>
<font color="black">  18. `encoded-word' in a header.  This method is commonly used for 8-bit real names</font>
<font color="black">  19. in To:, From:, Cc:, etc. fields, as well as Subject: lines.</font>
<font color="black">  20. </font>
<font color="black">  21. This module does not do the line wrapping or end-of-line character conversion</font>
<font color="black">  22. necessary for proper internationalized headers; it only does dumb encoding and</font>
<font color="black">  23. decoding.  To deal with the various line wrapping issues, use the email.header</font>
<font color="black">  24. module.</font>
<font color="green">  25. &quot;&quot;&quot;</font>
<font color="black">  26. </font>
<font color="black">  27. __all__ = [</font>
<font color="green">  28.     'base64_len',</font>
<font color="green">  29.     'body_decode',</font>
<font color="green">  30.     'body_encode',</font>
<font color="green">  31.     'decode',</font>
<font color="green">  32.     'decodestring',</font>
<font color="green">  33.     'encode',</font>
<font color="green">  34.     'encodestring',</font>
<font color="green">  35.     'header_encode',</font>
<font color="black">  36.     ]</font>
<font color="black">  37. </font>
<font color="black">  38. </font>
<font color="green">  39. from binascii import b2a_base64, a2b_base64</font>
<font color="green">  40. from email.utils import fix_eols</font>
<font color="black">  41. </font>
<font color="green">  42. CRLF = '\r\n'</font>
<font color="green">  43. NL = '\n'</font>
<font color="green">  44. EMPTYSTRING = ''</font>
<font color="black">  45. </font>
<font color="black">  46. # See also Charset.py</font>
<font color="green">  47. MISC_LEN = 7</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="black">  51. # Helpers</font>
<font color="green">  52. def base64_len(s):</font>
<font color="black">  53.     &quot;&quot;&quot;Return the length of s when it is encoded with base64.&quot;&quot;&quot;</font>
<font color="red">  54.     groups_of_3, leftover = divmod(len(s), 3)</font>
<font color="black">  55.     # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in.</font>
<font color="black">  56.     # Thanks, Tim!</font>
<font color="red">  57.     n = groups_of_3 * 4</font>
<font color="red">  58.     if leftover:</font>
<font color="red">  59.         n += 4</font>
<font color="red">  60.     return n</font>
<font color="black">  61. </font>
<font color="black">  62. </font>
<font color="black">  63. </font>
<font color="green">  64. def header_encode(header, charset='iso-8859-1', keep_eols=False,</font>
<font color="green">  65.                   maxlinelen=76, eol=NL):</font>
<font color="black">  66.     &quot;&quot;&quot;Encode a single header line with Base64 encoding in a given charset.</font>
<font color="black">  67. </font>
<font color="black">  68.     Defined in RFC 2045, this Base64 encoding is identical to normal Base64</font>
<font color="black">  69.     encoding, except that each line must be intelligently wrapped (respecting</font>
<font color="black">  70.     the Base64 encoding), and subsequent lines must start with a space.</font>
<font color="black">  71. </font>
<font color="black">  72.     charset names the character set to use to encode the header.  It defaults</font>
<font color="black">  73.     to iso-8859-1.</font>
<font color="black">  74. </font>
<font color="black">  75.     End-of-line characters (\\r, \\n, \\r\\n) will be automatically converted</font>
<font color="black">  76.     to the canonical email line separator \\r\\n unless the keep_eols</font>
<font color="black">  77.     parameter is True (the default is False).</font>
<font color="black">  78. </font>
<font color="black">  79.     Each line of the header will be terminated in the value of eol, which</font>
<font color="black">  80.     defaults to &quot;\\n&quot;.  Set this to &quot;\\r\\n&quot; if you are using the result of</font>
<font color="black">  81.     this function directly in email.</font>
<font color="black">  82. </font>
<font color="black">  83.     The resulting string will be in the form:</font>
<font color="black">  84. </font>
<font color="black">  85.     &quot;=?charset?b?WW/5ciBtYXp66XLrIHf8eiBhIGhhbXBzdGHuciBBIFlv+XIgbWF6euly?=\\n</font>
<font color="black">  86.       =?charset?b?6yB3/HogYSBoYW1wc3Rh7nIgQkMgWW/5ciBtYXp66XLrIHf8eiBhIGhh?=&quot;</font>
<font color="black">  87. </font>
<font color="black">  88.     with each line wrapped at, at most, maxlinelen characters (defaults to 76</font>
<font color="black">  89.     characters).</font>
<font color="black">  90.     &quot;&quot;&quot;</font>
<font color="black">  91.     # Return empty headers unchanged</font>
<font color="red">  92.     if not header:</font>
<font color="red">  93.         return header</font>
<font color="black">  94. </font>
<font color="red">  95.     if not keep_eols:</font>
<font color="red">  96.         header = fix_eols(header)</font>
<font color="black">  97. </font>
<font color="black">  98.     # Base64 encode each line, in encoded chunks no greater than maxlinelen in</font>
<font color="black">  99.     # length, after the RFC chrome is added in.</font>
<font color="red"> 100.     base64ed = []</font>
<font color="red"> 101.     max_encoded = maxlinelen - len(charset) - MISC_LEN</font>
<font color="red"> 102.     max_unencoded = max_encoded * 3 // 4</font>
<font color="black"> 103. </font>
<font color="red"> 104.     for i in range(0, len(header), max_unencoded):</font>
<font color="red"> 105.         base64ed.append(b2a_base64(header[i:i+max_unencoded]))</font>
<font color="black"> 106. </font>
<font color="black"> 107.     # Now add the RFC chrome to each encoded chunk</font>
<font color="red"> 108.     lines = []</font>
<font color="red"> 109.     for line in base64ed:</font>
<font color="black"> 110.         # Ignore the last character of each line if it is a newline</font>
<font color="red"> 111.         if line.endswith(NL):</font>
<font color="red"> 112.             line = line[:-1]</font>
<font color="black"> 113.         # Add the chrome</font>
<font color="red"> 114.         lines.append('=?%s?b?%s?=' % (charset, line))</font>
<font color="black"> 115.     # Glue the lines together and return it.  BAW: should we be able to</font>
<font color="black"> 116.     # specify the leading whitespace in the joiner?</font>
<font color="red"> 117.     joiner = eol + ' '</font>
<font color="red"> 118.     return joiner.join(lines)</font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="black"> 121. </font>
<font color="green"> 122. def encode(s, binary=True, maxlinelen=76, eol=NL):</font>
<font color="black"> 123.     &quot;&quot;&quot;Encode a string with base64.</font>
<font color="black"> 124. </font>
<font color="black"> 125.     Each line will be wrapped at, at most, maxlinelen characters (defaults to</font>
<font color="black"> 126.     76 characters).</font>
<font color="black"> 127. </font>
<font color="black"> 128.     If binary is False, end-of-line characters will be converted to the</font>
<font color="black"> 129.     canonical email end-of-line sequence \\r\\n.  Otherwise they will be left</font>
<font color="black"> 130.     verbatim (this is the default).</font>
<font color="black"> 131. </font>
<font color="black"> 132.     Each line of encoded text will end with eol, which defaults to &quot;\\n&quot;.  Set</font>
<font color="black"> 133.     this to &quot;\\r\\n&quot; if you will be using the result of this function directly</font>
<font color="black"> 134.     in an email.</font>
<font color="black"> 135.     &quot;&quot;&quot;</font>
<font color="red"> 136.     if not s:</font>
<font color="red"> 137.         return s</font>
<font color="black"> 138. </font>
<font color="red"> 139.     if not binary:</font>
<font color="red"> 140.         s = fix_eols(s)</font>
<font color="black"> 141. </font>
<font color="red"> 142.     encvec = []</font>
<font color="red"> 143.     max_unencoded = maxlinelen * 3 // 4</font>
<font color="red"> 144.     for i in range(0, len(s), max_unencoded):</font>
<font color="black"> 145.         # BAW: should encode() inherit b2a_base64()'s dubious behavior in</font>
<font color="black"> 146.         # adding a newline to the encoded string?</font>
<font color="red"> 147.         enc = b2a_base64(s[i:i + max_unencoded])</font>
<font color="red"> 148.         if enc.endswith(NL) and eol != NL:</font>
<font color="red"> 149.             enc = enc[:-1] + eol</font>
<font color="red"> 150.         encvec.append(enc)</font>
<font color="red"> 151.     return EMPTYSTRING.join(encvec)</font>
<font color="black"> 152. </font>
<font color="black"> 153. </font>
<font color="black"> 154. # For convenience and backwards compatibility w/ standard base64 module</font>
<font color="green"> 155. body_encode = encode</font>
<font color="green"> 156. encodestring = encode</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="black"> 159. </font>
<font color="green"> 160. def decode(s, convert_eols=None):</font>
<font color="black"> 161.     &quot;&quot;&quot;Decode a raw base64 string.</font>
<font color="black"> 162. </font>
<font color="black"> 163.     If convert_eols is set to a string value, all canonical email linefeeds,</font>
<font color="black"> 164.     e.g. &quot;\\r\\n&quot;, in the decoded text will be converted to the value of</font>
<font color="black"> 165.     convert_eols.  os.linesep is a good choice for convert_eols if you are</font>
<font color="black"> 166.     decoding a text attachment.</font>
<font color="black"> 167. </font>
<font color="black"> 168.     This function does not parse a full MIME header value encoded with</font>
<font color="black"> 169.     base64 (like =?iso-8895-1?b?bmloISBuaWgh?=) -- please use the high</font>
<font color="black"> 170.     level email.header class for that functionality.</font>
<font color="black"> 171.     &quot;&quot;&quot;</font>
<font color="red"> 172.     if not s:</font>
<font color="red"> 173.         return s</font>
<font color="black"> 174. </font>
<font color="red"> 175.     dec = a2b_base64(s)</font>
<font color="red"> 176.     if convert_eols:</font>
<font color="red"> 177.         return dec.replace(CRLF, convert_eols)</font>
<font color="red"> 178.     return dec</font>
<font color="black"> 179. </font>
<font color="black"> 180. </font>
<font color="black"> 181. # For convenience and backwards compatibility w/ standard base64 module</font>
<font color="green"> 182. body_decode = decode</font>
<font color="green"> 183. decodestring = decode</font>
</pre>

