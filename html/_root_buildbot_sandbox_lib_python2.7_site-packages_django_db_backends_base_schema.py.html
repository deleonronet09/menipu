source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/backends/base/schema.py</b><br>


file stats: <b>562 lines, 200 executed: 35.6% covered</b>
<pre>
<font color="green">   1. import hashlib</font>
<font color="green">   2. import logging</font>
<font color="black">   3. </font>
<font color="green">   4. from django.db.backends.utils import truncate_name</font>
<font color="green">   5. from django.db.transaction import atomic</font>
<font color="green">   6. from django.utils import six</font>
<font color="green">   7. from django.utils.encoding import force_bytes</font>
<font color="black">   8. </font>
<font color="green">   9. logger = logging.getLogger('django.db.backends.schema')</font>
<font color="black">  10. </font>
<font color="black">  11. </font>
<font color="green">  12. def _related_non_m2m_objects(old_field, new_field):</font>
<font color="black">  13.     # Filters out m2m objects from reverse relations.</font>
<font color="black">  14.     # Returns (old_relation, new_relation) tuples.</font>
<font color="red">  15.     return zip(</font>
<font color="red">  16.         (obj for obj in old_field.model._meta.related_objects if not obj.field.many_to_many),</font>
<font color="red">  17.         (obj for obj in new_field.model._meta.related_objects if not obj.field.many_to_many)</font>
<font color="black">  18.     )</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. class BaseDatabaseSchemaEditor(object):</font>
<font color="black">  22.     &quot;&quot;&quot;</font>
<font color="black">  23.     This class (and its subclasses) are responsible for emitting schema-changing</font>
<font color="black">  24.     statements to the databases - model creation/removal/alteration, field</font>
<font color="black">  25.     renaming, index fiddling, and so on.</font>
<font color="black">  26. </font>
<font color="black">  27.     It is intended to eventually completely replace DatabaseCreation.</font>
<font color="black">  28. </font>
<font color="black">  29.     This class should be used by creating an instance for each set of schema</font>
<font color="black">  30.     changes (e.g. a migration file), and by first calling start(),</font>
<font color="black">  31.     then the relevant actions, and then commit(). This is necessary to allow</font>
<font color="black">  32.     things like circular foreign key references - FKs will only be created once</font>
<font color="black">  33.     commit() is called.</font>
<font color="green">  34.     &quot;&quot;&quot;</font>
<font color="black">  35. </font>
<font color="black">  36.     # Overrideable SQL templates</font>
<font color="green">  37.     sql_create_table = &quot;CREATE TABLE %(table)s (%(definition)s)&quot;</font>
<font color="green">  38.     sql_rename_table = &quot;ALTER TABLE %(old_table)s RENAME TO %(new_table)s&quot;</font>
<font color="green">  39.     sql_retablespace_table = &quot;ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s&quot;</font>
<font color="green">  40.     sql_delete_table = &quot;DROP TABLE %(table)s CASCADE&quot;</font>
<font color="black">  41. </font>
<font color="green">  42.     sql_create_column = &quot;ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s&quot;</font>
<font color="green">  43.     sql_alter_column = &quot;ALTER TABLE %(table)s %(changes)s&quot;</font>
<font color="green">  44.     sql_alter_column_type = &quot;ALTER COLUMN %(column)s TYPE %(type)s&quot;</font>
<font color="green">  45.     sql_alter_column_null = &quot;ALTER COLUMN %(column)s DROP NOT NULL&quot;</font>
<font color="green">  46.     sql_alter_column_not_null = &quot;ALTER COLUMN %(column)s SET NOT NULL&quot;</font>
<font color="green">  47.     sql_alter_column_default = &quot;ALTER COLUMN %(column)s SET DEFAULT %(default)s&quot;</font>
<font color="green">  48.     sql_alter_column_no_default = &quot;ALTER COLUMN %(column)s DROP DEFAULT&quot;</font>
<font color="green">  49.     sql_delete_column = &quot;ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE&quot;</font>
<font color="green">  50.     sql_rename_column = &quot;ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s&quot;</font>
<font color="green">  51.     sql_update_with_default = &quot;UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL&quot;</font>
<font color="black">  52. </font>
<font color="green">  53.     sql_create_check = &quot;ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)&quot;</font>
<font color="green">  54.     sql_delete_check = &quot;ALTER TABLE %(table)s DROP CONSTRAINT %(name)s&quot;</font>
<font color="black">  55. </font>
<font color="green">  56.     sql_create_unique = &quot;ALTER TABLE %(table)s ADD CONSTRAINT %(name)s UNIQUE (%(columns)s)&quot;</font>
<font color="green">  57.     sql_delete_unique = &quot;ALTER TABLE %(table)s DROP CONSTRAINT %(name)s&quot;</font>
<font color="black">  58. </font>
<font color="black">  59.     sql_create_fk = (</font>
<font color="green">  60.         &quot;ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) &quot;</font>
<font color="black">  61.         &quot;REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED&quot;</font>
<font color="black">  62.     )</font>
<font color="green">  63.     sql_create_inline_fk = None</font>
<font color="green">  64.     sql_delete_fk = &quot;ALTER TABLE %(table)s DROP CONSTRAINT %(name)s&quot;</font>
<font color="black">  65. </font>
<font color="green">  66.     sql_create_index = &quot;CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s&quot;</font>
<font color="green">  67.     sql_delete_index = &quot;DROP INDEX %(name)s&quot;</font>
<font color="black">  68. </font>
<font color="green">  69.     sql_create_pk = &quot;ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)&quot;</font>
<font color="green">  70.     sql_delete_pk = &quot;ALTER TABLE %(table)s DROP CONSTRAINT %(name)s&quot;</font>
<font color="black">  71. </font>
<font color="green">  72.     def __init__(self, connection, collect_sql=False):</font>
<font color="green">  73.         self.connection = connection</font>
<font color="green">  74.         self.collect_sql = collect_sql</font>
<font color="green">  75.         if self.collect_sql:</font>
<font color="red">  76.             self.collected_sql = []</font>
<font color="black">  77. </font>
<font color="black">  78.     # State-managing methods</font>
<font color="black">  79. </font>
<font color="green">  80.     def __enter__(self):</font>
<font color="green">  81.         self.deferred_sql = []</font>
<font color="green">  82.         if self.connection.features.can_rollback_ddl:</font>
<font color="green">  83.             self.atomic = atomic(self.connection.alias)</font>
<font color="green">  84.             self.atomic.__enter__()</font>
<font color="green">  85.         return self</font>
<font color="black">  86. </font>
<font color="green">  87.     def __exit__(self, exc_type, exc_value, traceback):</font>
<font color="green">  88.         if exc_type is None:</font>
<font color="green">  89.             for sql in self.deferred_sql:</font>
<font color="green">  90.                 self.execute(sql)</font>
<font color="green">  91.         if self.connection.features.can_rollback_ddl:</font>
<font color="green">  92.             self.atomic.__exit__(exc_type, exc_value, traceback)</font>
<font color="black">  93. </font>
<font color="black">  94.     # Core utility functions</font>
<font color="black">  95. </font>
<font color="green">  96.     def execute(self, sql, params=[]):</font>
<font color="black">  97.         &quot;&quot;&quot;</font>
<font color="black">  98.         Executes the given SQL statement, with optional parameters.</font>
<font color="black">  99.         &quot;&quot;&quot;</font>
<font color="black"> 100.         # Log the command we're running, then run it</font>
<font color="green"> 101.         logger.debug(&quot;%s; (params %r)&quot; % (sql, params))</font>
<font color="green"> 102.         if self.collect_sql:</font>
<font color="red"> 103.             ending = &quot;&quot; if sql.endswith(&quot;;&quot;) else &quot;;&quot;</font>
<font color="red"> 104.             if params is not None:</font>
<font color="red"> 105.                 self.collected_sql.append((sql % tuple(map(self.quote_value, params))) + ending)</font>
<font color="black"> 106.             else:</font>
<font color="red"> 107.                 self.collected_sql.append(sql + ending)</font>
<font color="black"> 108.         else:</font>
<font color="green"> 109.             with self.connection.cursor() as cursor:</font>
<font color="green"> 110.                 cursor.execute(sql, params)</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def quote_name(self, name):</font>
<font color="green"> 113.         return self.connection.ops.quote_name(name)</font>
<font color="black"> 114. </font>
<font color="green"> 115.     @classmethod</font>
<font color="black"> 116.     def _digest(cls, *args):</font>
<font color="black"> 117.         &quot;&quot;&quot;</font>
<font color="black"> 118.         Generates a 32-bit digest of a set of arguments that can be used to</font>
<font color="black"> 119.         shorten identifying names.</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="green"> 121.         h = hashlib.md5()</font>
<font color="green"> 122.         for arg in args:</font>
<font color="green"> 123.             h.update(force_bytes(arg))</font>
<font color="green"> 124.         return h.hexdigest()[:8]</font>
<font color="black"> 125. </font>
<font color="black"> 126.     # Field &lt;-&gt; database mapping functions</font>
<font color="black"> 127. </font>
<font color="green"> 128.     def column_sql(self, model, field, include_default=False):</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="black"> 130.         Takes a field and returns its column definition.</font>
<font color="black"> 131.         The field must already have had set_attributes_from_name called.</font>
<font color="black"> 132.         &quot;&quot;&quot;</font>
<font color="black"> 133.         # Get the column's type and use that as the basis of the SQL</font>
<font color="green"> 134.         db_params = field.db_parameters(connection=self.connection)</font>
<font color="green"> 135.         sql = db_params['type']</font>
<font color="green"> 136.         params = []</font>
<font color="black"> 137.         # Check for fields that aren't actually columns (e.g. M2M)</font>
<font color="green"> 138.         if sql is None:</font>
<font color="red"> 139.             return None, None</font>
<font color="black"> 140.         # Work out nullability</font>
<font color="green"> 141.         null = field.null</font>
<font color="black"> 142.         # If we were told to include a default value, do so</font>
<font color="green"> 143.         include_default = include_default and not self.skip_default(field)</font>
<font color="green"> 144.         if include_default:</font>
<font color="red"> 145.             default_value = self.effective_default(field)</font>
<font color="red"> 146.             if default_value is not None:</font>
<font color="red"> 147.                 if self.connection.features.requires_literal_defaults:</font>
<font color="black"> 148.                     # Some databases can't take defaults as a parameter (oracle)</font>
<font color="black"> 149.                     # If this is the case, the individual schema backend should</font>
<font color="black"> 150.                     # implement prepare_default</font>
<font color="red"> 151.                     sql += &quot; DEFAULT %s&quot; % self.prepare_default(default_value)</font>
<font color="black"> 152.                 else:</font>
<font color="red"> 153.                     sql += &quot; DEFAULT %s&quot;</font>
<font color="red"> 154.                     params += [default_value]</font>
<font color="black"> 155.         # Oracle treats the empty string ('') as null, so coerce the null</font>
<font color="black"> 156.         # option whenever '' is a possible value.</font>
<font color="green"> 157.         if (field.empty_strings_allowed and not field.primary_key and</font>
<font color="green"> 158.                 self.connection.features.interprets_empty_strings_as_nulls):</font>
<font color="red"> 159.             null = True</font>
<font color="green"> 160.         if null and not self.connection.features.implied_column_null:</font>
<font color="green"> 161.             sql += &quot; NULL&quot;</font>
<font color="green"> 162.         elif not null:</font>
<font color="green"> 163.             sql += &quot; NOT NULL&quot;</font>
<font color="black"> 164.         # Primary key/unique outputs</font>
<font color="green"> 165.         if field.primary_key:</font>
<font color="green"> 166.             sql += &quot; PRIMARY KEY&quot;</font>
<font color="green"> 167.         elif field.unique:</font>
<font color="green"> 168.             sql += &quot; UNIQUE&quot;</font>
<font color="black"> 169.         # Optionally add the tablespace if it's an implicitly indexed column</font>
<font color="green"> 170.         tablespace = field.db_tablespace or model._meta.db_tablespace</font>
<font color="green"> 171.         if tablespace and self.connection.features.supports_tablespaces and field.unique:</font>
<font color="red"> 172.             sql += &quot; %s&quot; % self.connection.ops.tablespace_sql(tablespace, inline=True)</font>
<font color="black"> 173.         # Return the sql</font>
<font color="green"> 174.         return sql, params</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def skip_default(self, field):</font>
<font color="black"> 177.         &quot;&quot;&quot;</font>
<font color="black"> 178.         Some backends don't accept default values for certain columns types</font>
<font color="black"> 179.         (i.e. MySQL longtext and longblob).</font>
<font color="black"> 180.         &quot;&quot;&quot;</font>
<font color="red"> 181.         return False</font>
<font color="black"> 182. </font>
<font color="green"> 183.     def prepare_default(self, value):</font>
<font color="black"> 184.         &quot;&quot;&quot;</font>
<font color="black"> 185.         Only used for backends which have requires_literal_defaults feature</font>
<font color="black"> 186.         &quot;&quot;&quot;</font>
<font color="red"> 187.         raise NotImplementedError(</font>
<font color="red"> 188.             'subclasses of BaseDatabaseSchemaEditor for backends which have '</font>
<font color="black"> 189.             'requires_literal_defaults must provide a prepare_default() method'</font>
<font color="black"> 190.         )</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def effective_default(self, field):</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="black"> 194.         Returns a field's effective database default value</font>
<font color="black"> 195.         &quot;&quot;&quot;</font>
<font color="red"> 196.         if field.has_default():</font>
<font color="red"> 197.             default = field.get_default()</font>
<font color="red"> 198.         elif not field.null and field.blank and field.empty_strings_allowed:</font>
<font color="red"> 199.             if field.get_internal_type() == &quot;BinaryField&quot;:</font>
<font color="red"> 200.                 default = six.binary_type()</font>
<font color="black"> 201.             else:</font>
<font color="red"> 202.                 default = six.text_type()</font>
<font color="black"> 203.         else:</font>
<font color="red"> 204.             default = None</font>
<font color="black"> 205.         # If it's a callable, call it</font>
<font color="red"> 206.         if six.callable(default):</font>
<font color="red"> 207.             default = default()</font>
<font color="black"> 208.         # Run it through the field's get_db_prep_save method so we can send it</font>
<font color="black"> 209.         # to the database.</font>
<font color="red"> 210.         default = field.get_db_prep_save(default, self.connection)</font>
<font color="red"> 211.         return default</font>
<font color="black"> 212. </font>
<font color="green"> 213.     def quote_value(self, value):</font>
<font color="black"> 214.         &quot;&quot;&quot;</font>
<font color="black"> 215.         Returns a quoted version of the value so it's safe to use in an SQL</font>
<font color="black"> 216.         string. This is not safe against injection from user code; it is</font>
<font color="black"> 217.         intended only for use in making SQL scripts or preparing default values</font>
<font color="black"> 218.         for particularly tricky backends (defaults are not user-defined, though,</font>
<font color="black"> 219.         so this is safe).</font>
<font color="black"> 220.         &quot;&quot;&quot;</font>
<font color="red"> 221.         raise NotImplementedError()</font>
<font color="black"> 222. </font>
<font color="black"> 223.     # Actions</font>
<font color="black"> 224. </font>
<font color="green"> 225.     def create_model(self, model):</font>
<font color="black"> 226.         &quot;&quot;&quot;</font>
<font color="black"> 227.         Takes a model and creates a table for it in the database.</font>
<font color="black"> 228.         Will also create any accompanying indexes or unique constraints.</font>
<font color="black"> 229.         &quot;&quot;&quot;</font>
<font color="black"> 230.         # Create column SQL, add FK deferreds if needed</font>
<font color="green"> 231.         column_sqls = []</font>
<font color="green"> 232.         params = []</font>
<font color="green"> 233.         for field in model._meta.local_fields:</font>
<font color="black"> 234.             # SQL</font>
<font color="green"> 235.             definition, extra_params = self.column_sql(model, field)</font>
<font color="green"> 236.             if definition is None:</font>
<font color="red"> 237.                 continue</font>
<font color="black"> 238.             # Check constraints can go on the column SQL here</font>
<font color="green"> 239.             db_params = field.db_parameters(connection=self.connection)</font>
<font color="green"> 240.             if db_params['check']:</font>
<font color="red"> 241.                 definition += &quot; CHECK (%s)&quot; % db_params['check']</font>
<font color="black"> 242.             # Autoincrement SQL (for backends with inline variant)</font>
<font color="green"> 243.             col_type_suffix = field.db_type_suffix(connection=self.connection)</font>
<font color="green"> 244.             if col_type_suffix:</font>
<font color="green"> 245.                 definition += &quot; %s&quot; % col_type_suffix</font>
<font color="green"> 246.             params.extend(extra_params)</font>
<font color="black"> 247.             # FK</font>
<font color="green"> 248.             if field.remote_field and field.db_constraint:</font>
<font color="green"> 249.                 to_table = field.remote_field.model._meta.db_table</font>
<font color="green"> 250.                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column</font>
<font color="green"> 251.                 if self.connection.features.supports_foreign_keys:</font>
<font color="red"> 252.                     self.deferred_sql.append(self._create_fk_sql(model, field, &quot;_fk_%(to_table)s_%(to_column)s&quot;))</font>
<font color="green"> 253.                 elif self.sql_create_inline_fk:</font>
<font color="green"> 254.                     definition += &quot; &quot; + self.sql_create_inline_fk % {</font>
<font color="green"> 255.                         &quot;to_table&quot;: self.quote_name(to_table),</font>
<font color="green"> 256.                         &quot;to_column&quot;: self.quote_name(to_column),</font>
<font color="black"> 257.                     }</font>
<font color="black"> 258.             # Add the SQL to our big list</font>
<font color="green"> 259.             column_sqls.append(&quot;%s %s&quot; % (</font>
<font color="green"> 260.                 self.quote_name(field.column),</font>
<font color="green"> 261.                 definition,</font>
<font color="black"> 262.             ))</font>
<font color="black"> 263.             # Autoincrement SQL (for backends with post table definition variant)</font>
<font color="green"> 264.             if field.get_internal_type() == &quot;AutoField&quot;:</font>
<font color="green"> 265.                 autoinc_sql = self.connection.ops.autoinc_sql(model._meta.db_table, field.column)</font>
<font color="green"> 266.                 if autoinc_sql:</font>
<font color="red"> 267.                     self.deferred_sql.extend(autoinc_sql)</font>
<font color="black"> 268. </font>
<font color="black"> 269.         # Add any unique_togethers (always deferred, as some fields might be</font>
<font color="black"> 270.         # created afterwards, like geometry fields with some backends)</font>
<font color="green"> 271.         for fields in model._meta.unique_together:</font>
<font color="green"> 272.             columns = [model._meta.get_field(field).column for field in fields]</font>
<font color="green"> 273.             self.deferred_sql.append(self._create_unique_sql(model, columns))</font>
<font color="black"> 274.         # Make the table</font>
<font color="green"> 275.         sql = self.sql_create_table % {</font>
<font color="green"> 276.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="green"> 277.             &quot;definition&quot;: &quot;, &quot;.join(column_sqls)</font>
<font color="black"> 278.         }</font>
<font color="green"> 279.         if model._meta.db_tablespace:</font>
<font color="red"> 280.             tablespace_sql = self.connection.ops.tablespace_sql(model._meta.db_tablespace)</font>
<font color="red"> 281.             if tablespace_sql:</font>
<font color="red"> 282.                 sql += ' ' + tablespace_sql</font>
<font color="black"> 283.         # Prevent using [] as params, in the case a literal '%' is used in the definition</font>
<font color="green"> 284.         self.execute(sql, params or None)</font>
<font color="black"> 285. </font>
<font color="black"> 286.         # Add any field index and index_together's (deferred as SQLite3 _remake_table needs it)</font>
<font color="green"> 287.         self.deferred_sql.extend(self._model_indexes_sql(model))</font>
<font color="black"> 288. </font>
<font color="black"> 289.         # Make M2M tables</font>
<font color="green"> 290.         for field in model._meta.local_many_to_many:</font>
<font color="green"> 291.             if field.remote_field.through._meta.auto_created:</font>
<font color="green"> 292.                 self.create_model(field.remote_field.through)</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def delete_model(self, model):</font>
<font color="black"> 295.         &quot;&quot;&quot;</font>
<font color="black"> 296.         Deletes a model from the database.</font>
<font color="black"> 297.         &quot;&quot;&quot;</font>
<font color="black"> 298.         # Handle auto-created intermediary models</font>
<font color="red"> 299.         for field in model._meta.local_many_to_many:</font>
<font color="red"> 300.             if field.remote_field.through._meta.auto_created:</font>
<font color="red"> 301.                 self.delete_model(field.remote_field.through)</font>
<font color="black"> 302. </font>
<font color="black"> 303.         # Delete the table</font>
<font color="red"> 304.         self.execute(self.sql_delete_table % {</font>
<font color="red"> 305.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="black"> 306.         })</font>
<font color="black"> 307. </font>
<font color="green"> 308.     def alter_unique_together(self, model, old_unique_together, new_unique_together):</font>
<font color="black"> 309.         &quot;&quot;&quot;</font>
<font color="black"> 310.         Deals with a model changing its unique_together.</font>
<font color="black"> 311.         Note: The input unique_togethers must be doubly-nested, not the single-</font>
<font color="black"> 312.         nested [&quot;foo&quot;, &quot;bar&quot;] format.</font>
<font color="black"> 313.         &quot;&quot;&quot;</font>
<font color="red"> 314.         olds = set(tuple(fields) for fields in old_unique_together)</font>
<font color="red"> 315.         news = set(tuple(fields) for fields in new_unique_together)</font>
<font color="black"> 316.         # Deleted uniques</font>
<font color="red"> 317.         for fields in olds.difference(news):</font>
<font color="red"> 318.             self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)</font>
<font color="black"> 319.         # Created uniques</font>
<font color="red"> 320.         for fields in news.difference(olds):</font>
<font color="red"> 321.             columns = [model._meta.get_field(field).column for field in fields]</font>
<font color="red"> 322.             self.execute(self._create_unique_sql(model, columns))</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def alter_index_together(self, model, old_index_together, new_index_together):</font>
<font color="black"> 325.         &quot;&quot;&quot;</font>
<font color="black"> 326.         Deals with a model changing its index_together.</font>
<font color="black"> 327.         Note: The input index_togethers must be doubly-nested, not the single-</font>
<font color="black"> 328.         nested [&quot;foo&quot;, &quot;bar&quot;] format.</font>
<font color="black"> 329.         &quot;&quot;&quot;</font>
<font color="red"> 330.         olds = set(tuple(fields) for fields in old_index_together)</font>
<font color="red"> 331.         news = set(tuple(fields) for fields in new_index_together)</font>
<font color="black"> 332.         # Deleted indexes</font>
<font color="red"> 333.         for fields in olds.difference(news):</font>
<font color="red"> 334.             self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)</font>
<font color="black"> 335.         # Created indexes</font>
<font color="red"> 336.         for field_names in news.difference(olds):</font>
<font color="red"> 337.             fields = [model._meta.get_field(field) for field in field_names]</font>
<font color="red"> 338.             self.execute(self._create_index_sql(model, fields, suffix=&quot;_idx&quot;))</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):</font>
<font color="red"> 341.         columns = [model._meta.get_field(field).column for field in fields]</font>
<font color="red"> 342.         constraint_names = self._constraint_names(model, columns, **constraint_kwargs)</font>
<font color="red"> 343.         if len(constraint_names) != 1:</font>
<font color="red"> 344.             raise ValueError(&quot;Found wrong number (%s) of constraints for %s(%s)&quot; % (</font>
<font color="red"> 345.                 len(constraint_names),</font>
<font color="red"> 346.                 model._meta.db_table,</font>
<font color="red"> 347.                 &quot;, &quot;.join(columns),</font>
<font color="black"> 348.             ))</font>
<font color="red"> 349.         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def alter_db_table(self, model, old_db_table, new_db_table):</font>
<font color="black"> 352.         &quot;&quot;&quot;</font>
<font color="black"> 353.         Renames the table a model points to.</font>
<font color="black"> 354.         &quot;&quot;&quot;</font>
<font color="green"> 355.         if old_db_table == new_db_table:</font>
<font color="red"> 356.             return</font>
<font color="green"> 357.         self.execute(self.sql_rename_table % {</font>
<font color="green"> 358.             &quot;old_table&quot;: self.quote_name(old_db_table),</font>
<font color="green"> 359.             &quot;new_table&quot;: self.quote_name(new_db_table),</font>
<font color="black"> 360.         })</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):</font>
<font color="black"> 363.         &quot;&quot;&quot;</font>
<font color="black"> 364.         Moves a model's table between tablespaces</font>
<font color="black"> 365.         &quot;&quot;&quot;</font>
<font color="red"> 366.         self.execute(self.sql_retablespace_table % {</font>
<font color="red"> 367.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 368.             &quot;old_tablespace&quot;: self.quote_name(old_db_tablespace),</font>
<font color="red"> 369.             &quot;new_tablespace&quot;: self.quote_name(new_db_tablespace),</font>
<font color="black"> 370.         })</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def add_field(self, model, field):</font>
<font color="black"> 373.         &quot;&quot;&quot;</font>
<font color="black"> 374.         Creates a field on a model.</font>
<font color="black"> 375.         Usually involves adding a column, but may involve adding a</font>
<font color="black"> 376.         table instead (for M2M fields)</font>
<font color="black"> 377.         &quot;&quot;&quot;</font>
<font color="black"> 378.         # Special-case implicit M2M tables</font>
<font color="red"> 379.         if field.many_to_many and field.remote_field.through._meta.auto_created:</font>
<font color="red"> 380.             return self.create_model(field.remote_field.through)</font>
<font color="black"> 381.         # Get the column's definition</font>
<font color="red"> 382.         definition, params = self.column_sql(model, field, include_default=True)</font>
<font color="black"> 383.         # It might not actually have a column behind it</font>
<font color="red"> 384.         if definition is None:</font>
<font color="red"> 385.             return</font>
<font color="black"> 386.         # Check constraints can go on the column SQL here</font>
<font color="red"> 387.         db_params = field.db_parameters(connection=self.connection)</font>
<font color="red"> 388.         if db_params['check']:</font>
<font color="red"> 389.             definition += &quot; CHECK (%s)&quot; % db_params['check']</font>
<font color="black"> 390.         # Build the SQL and run it</font>
<font color="red"> 391.         sql = self.sql_create_column % {</font>
<font color="red"> 392.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 393.             &quot;column&quot;: self.quote_name(field.column),</font>
<font color="red"> 394.             &quot;definition&quot;: definition,</font>
<font color="black"> 395.         }</font>
<font color="red"> 396.         self.execute(sql, params)</font>
<font color="black"> 397.         # Drop the default if we need to</font>
<font color="black"> 398.         # (Django usually does not use in-database defaults)</font>
<font color="red"> 399.         if not self.skip_default(field) and field.default is not None:</font>
<font color="red"> 400.             sql = self.sql_alter_column % {</font>
<font color="red"> 401.                 &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 402.                 &quot;changes&quot;: self.sql_alter_column_no_default % {</font>
<font color="red"> 403.                     &quot;column&quot;: self.quote_name(field.column),</font>
<font color="black"> 404.                 }</font>
<font color="black"> 405.             }</font>
<font color="red"> 406.             self.execute(sql)</font>
<font color="black"> 407.         # Add an index, if required</font>
<font color="red"> 408.         if field.db_index and not field.unique:</font>
<font color="red"> 409.             self.deferred_sql.append(self._create_index_sql(model, [field]))</font>
<font color="black"> 410.         # Add any FK constraints later</font>
<font color="red"> 411.         if field.remote_field and self.connection.features.supports_foreign_keys and field.db_constraint:</font>
<font color="red"> 412.             self.deferred_sql.append(self._create_fk_sql(model, field, &quot;_fk_%(to_table)s_%(to_column)s&quot;))</font>
<font color="black"> 413.         # Reset connection if required</font>
<font color="red"> 414.         if self.connection.features.connection_persists_old_columns:</font>
<font color="red"> 415.             self.connection.close()</font>
<font color="black"> 416. </font>
<font color="green"> 417.     def remove_field(self, model, field):</font>
<font color="black"> 418.         &quot;&quot;&quot;</font>
<font color="black"> 419.         Removes a field from a model. Usually involves deleting a column,</font>
<font color="black"> 420.         but for M2Ms may involve deleting a table.</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="black"> 422.         # Special-case implicit M2M tables</font>
<font color="red"> 423.         if field.many_to_many and field.remote_field.through._meta.auto_created:</font>
<font color="red"> 424.             return self.delete_model(field.remote_field.through)</font>
<font color="black"> 425.         # It might not actually have a column behind it</font>
<font color="red"> 426.         if field.db_parameters(connection=self.connection)['type'] is None:</font>
<font color="red"> 427.             return</font>
<font color="black"> 428.         # Drop any FK constraints, MySQL requires explicit deletion</font>
<font color="red"> 429.         if field.remote_field:</font>
<font color="red"> 430.             fk_names = self._constraint_names(model, [field.column], foreign_key=True)</font>
<font color="red"> 431.             for fk_name in fk_names:</font>
<font color="red"> 432.                 self.execute(self._delete_constraint_sql(self.sql_delete_fk, model, fk_name))</font>
<font color="black"> 433.         # Delete the column</font>
<font color="red"> 434.         sql = self.sql_delete_column % {</font>
<font color="red"> 435.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 436.             &quot;column&quot;: self.quote_name(field.column),</font>
<font color="black"> 437.         }</font>
<font color="red"> 438.         self.execute(sql)</font>
<font color="black"> 439.         # Reset connection if required</font>
<font color="red"> 440.         if self.connection.features.connection_persists_old_columns:</font>
<font color="red"> 441.             self.connection.close()</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def alter_field(self, model, old_field, new_field, strict=False):</font>
<font color="black"> 444.         &quot;&quot;&quot;</font>
<font color="black"> 445.         Allows a field's type, uniqueness, nullability, default, column,</font>
<font color="black"> 446.         constraints etc. to be modified.</font>
<font color="black"> 447.         Requires a copy of the old field as well so we can only perform</font>
<font color="black"> 448.         changes that are required.</font>
<font color="black"> 449.         If strict is true, raises errors if the old column does not match old_field precisely.</font>
<font color="black"> 450.         &quot;&quot;&quot;</font>
<font color="black"> 451.         # Ensure this field is even column-based</font>
<font color="green"> 452.         old_db_params = old_field.db_parameters(connection=self.connection)</font>
<font color="green"> 453.         old_type = old_db_params['type']</font>
<font color="green"> 454.         new_db_params = new_field.db_parameters(connection=self.connection)</font>
<font color="green"> 455.         new_type = new_db_params['type']</font>
<font color="green"> 456.         if ((old_type is None and old_field.remote_field is None) or</font>
<font color="green"> 457.                 (new_type is None and new_field.remote_field is None)):</font>
<font color="red"> 458.             raise ValueError(</font>
<font color="red"> 459.                 &quot;Cannot alter field %s into %s - they do not properly define &quot;</font>
<font color="black"> 460.                 &quot;db_type (are you using a badly-written custom field?)&quot; %</font>
<font color="red"> 461.                 (old_field, new_field),</font>
<font color="black"> 462.             )</font>
<font color="green"> 463.         elif old_type is None and new_type is None and (</font>
<font color="red"> 464.                 old_field.remote_field.through and new_field.remote_field.through and</font>
<font color="red"> 465.                 old_field.remote_field.through._meta.auto_created and</font>
<font color="red"> 466.                 new_field.remote_field.through._meta.auto_created):</font>
<font color="red"> 467.             return self._alter_many_to_many(model, old_field, new_field, strict)</font>
<font color="green"> 468.         elif old_type is None and new_type is None and (</font>
<font color="red"> 469.                 old_field.remote_field.through and new_field.remote_field.through and</font>
<font color="red"> 470.                 not old_field.remote_field.through._meta.auto_created and</font>
<font color="red"> 471.                 not new_field.remote_field.through._meta.auto_created):</font>
<font color="black"> 472.             # Both sides have through models; this is a no-op.</font>
<font color="red"> 473.             return</font>
<font color="green"> 474.         elif old_type is None or new_type is None:</font>
<font color="red"> 475.             raise ValueError(</font>
<font color="red"> 476.                 &quot;Cannot alter field %s into %s - they are not compatible types &quot;</font>
<font color="black"> 477.                 &quot;(you cannot alter to or from M2M fields, or add or remove &quot;</font>
<font color="red"> 478.                 &quot;through= on M2M fields)&quot; % (old_field, new_field)</font>
<font color="black"> 479.             )</font>
<font color="black"> 480. </font>
<font color="green"> 481.         self._alter_field(model, old_field, new_field, old_type, new_type,</font>
<font color="green"> 482.                           old_db_params, new_db_params, strict)</font>
<font color="black"> 483. </font>
<font color="black"> 484.     def _alter_field(self, model, old_field, new_field, old_type, new_type,</font>
<font color="green"> 485.                      old_db_params, new_db_params, strict=False):</font>
<font color="black"> 486.         &quot;&quot;&quot;Actually perform a &quot;physical&quot; (non-ManyToMany) field update.&quot;&quot;&quot;</font>
<font color="black"> 487. </font>
<font color="black"> 488.         # Drop any FK constraints, we'll remake them later</font>
<font color="red"> 489.         fks_dropped = set()</font>
<font color="red"> 490.         if old_field.remote_field and old_field.db_constraint:</font>
<font color="red"> 491.             fk_names = self._constraint_names(model, [old_field.column], foreign_key=True)</font>
<font color="red"> 492.             if strict and len(fk_names) != 1:</font>
<font color="red"> 493.                 raise ValueError(&quot;Found wrong number (%s) of foreign key constraints for %s.%s&quot; % (</font>
<font color="red"> 494.                     len(fk_names),</font>
<font color="red"> 495.                     model._meta.db_table,</font>
<font color="red"> 496.                     old_field.column,</font>
<font color="black"> 497.                 ))</font>
<font color="red"> 498.             for fk_name in fk_names:</font>
<font color="red"> 499.                 fks_dropped.add((old_field.column,))</font>
<font color="red"> 500.                 self.execute(self._delete_constraint_sql(self.sql_delete_fk, model, fk_name))</font>
<font color="black"> 501.         # Has unique been removed?</font>
<font color="red"> 502.         if old_field.unique and (not new_field.unique or (not old_field.primary_key and new_field.primary_key)):</font>
<font color="black"> 503.             # Find the unique constraint for this field</font>
<font color="red"> 504.             constraint_names = self._constraint_names(model, [old_field.column], unique=True)</font>
<font color="red"> 505.             if strict and len(constraint_names) != 1:</font>
<font color="red"> 506.                 raise ValueError(&quot;Found wrong number (%s) of unique constraints for %s.%s&quot; % (</font>
<font color="red"> 507.                     len(constraint_names),</font>
<font color="red"> 508.                     model._meta.db_table,</font>
<font color="red"> 509.                     old_field.column,</font>
<font color="black"> 510.                 ))</font>
<font color="red"> 511.             for constraint_name in constraint_names:</font>
<font color="red"> 512.                 self.execute(self._delete_constraint_sql(self.sql_delete_unique, model, constraint_name))</font>
<font color="black"> 513.         # Drop incoming FK constraints if we're a primary key and things are going</font>
<font color="black"> 514.         # to change.</font>
<font color="red"> 515.         if old_field.primary_key and new_field.primary_key and old_type != new_type:</font>
<font color="black"> 516.             # '_meta.related_field' also contains M2M reverse fields, these</font>
<font color="black"> 517.             # will be filtered out</font>
<font color="red"> 518.             for _old_rel, new_rel in _related_non_m2m_objects(old_field, new_field):</font>
<font color="red"> 519.                 rel_fk_names = self._constraint_names(</font>
<font color="red"> 520.                     new_rel.related_model, [new_rel.field.column], foreign_key=True</font>
<font color="black"> 521.                 )</font>
<font color="red"> 522.                 for fk_name in rel_fk_names:</font>
<font color="red"> 523.                     self.execute(self._delete_constraint_sql(self.sql_delete_fk, new_rel.related_model, fk_name))</font>
<font color="black"> 524.         # Removed an index? (no strict check, as multiple indexes are possible)</font>
<font color="red"> 525.         if (old_field.db_index and not new_field.db_index and</font>
<font color="red"> 526.                 not old_field.unique and not</font>
<font color="red"> 527.                 (not new_field.unique and old_field.unique)):</font>
<font color="black"> 528.             # Find the index for this field</font>
<font color="red"> 529.             index_names = self._constraint_names(model, [old_field.column], index=True)</font>
<font color="red"> 530.             for index_name in index_names:</font>
<font color="red"> 531.                 self.execute(self._delete_constraint_sql(self.sql_delete_index, model, index_name))</font>
<font color="black"> 532.         # Change check constraints?</font>
<font color="red"> 533.         if old_db_params['check'] != new_db_params['check'] and old_db_params['check']:</font>
<font color="red"> 534.             constraint_names = self._constraint_names(model, [old_field.column], check=True)</font>
<font color="red"> 535.             if strict and len(constraint_names) != 1:</font>
<font color="red"> 536.                 raise ValueError(&quot;Found wrong number (%s) of check constraints for %s.%s&quot; % (</font>
<font color="red"> 537.                     len(constraint_names),</font>
<font color="red"> 538.                     model._meta.db_table,</font>
<font color="red"> 539.                     old_field.column,</font>
<font color="black"> 540.                 ))</font>
<font color="red"> 541.             for constraint_name in constraint_names:</font>
<font color="red"> 542.                 self.execute(self._delete_constraint_sql(self.sql_delete_check, model, constraint_name))</font>
<font color="black"> 543.         # Have they renamed the column?</font>
<font color="red"> 544.         if old_field.column != new_field.column:</font>
<font color="red"> 545.             self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))</font>
<font color="black"> 546.         # Next, start accumulating actions to do</font>
<font color="red"> 547.         actions = []</font>
<font color="red"> 548.         null_actions = []</font>
<font color="red"> 549.         post_actions = []</font>
<font color="black"> 550.         # Type change?</font>
<font color="red"> 551.         if old_type != new_type:</font>
<font color="red"> 552.             fragment, other_actions = self._alter_column_type_sql(</font>
<font color="red"> 553.                 model._meta.db_table, old_field, new_field, new_type</font>
<font color="black"> 554.             )</font>
<font color="red"> 555.             actions.append(fragment)</font>
<font color="red"> 556.             post_actions.extend(other_actions)</font>
<font color="black"> 557.         # When changing a column NULL constraint to NOT NULL with a given</font>
<font color="black"> 558.         # default value, we need to perform 4 steps:</font>
<font color="black"> 559.         #  1. Add a default for new incoming writes</font>
<font color="black"> 560.         #  2. Update existing NULL rows with new default</font>
<font color="black"> 561.         #  3. Replace NULL constraint with NOT NULL</font>
<font color="black"> 562.         #  4. Drop the default again.</font>
<font color="black"> 563.         # Default change?</font>
<font color="red"> 564.         old_default = self.effective_default(old_field)</font>
<font color="red"> 565.         new_default = self.effective_default(new_field)</font>
<font color="black"> 566.         needs_database_default = (</font>
<font color="red"> 567.             old_default != new_default and</font>
<font color="red"> 568.             new_default is not None and</font>
<font color="red"> 569.             not self.skip_default(new_field)</font>
<font color="black"> 570.         )</font>
<font color="red"> 571.         if needs_database_default:</font>
<font color="red"> 572.             if self.connection.features.requires_literal_defaults:</font>
<font color="black"> 573.                 # Some databases can't take defaults as a parameter (oracle)</font>
<font color="black"> 574.                 # If this is the case, the individual schema backend should</font>
<font color="black"> 575.                 # implement prepare_default</font>
<font color="red"> 576.                 actions.append((</font>
<font color="red"> 577.                     self.sql_alter_column_default % {</font>
<font color="red"> 578.                         &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 579.                         &quot;default&quot;: self.prepare_default(new_default),</font>
<font color="black"> 580.                     },</font>
<font color="red"> 581.                     [],</font>
<font color="black"> 582.                 ))</font>
<font color="black"> 583.             else:</font>
<font color="red"> 584.                 actions.append((</font>
<font color="red"> 585.                     self.sql_alter_column_default % {</font>
<font color="red"> 586.                         &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 587.                         &quot;default&quot;: &quot;%s&quot;,</font>
<font color="black"> 588.                     },</font>
<font color="red"> 589.                     [new_default],</font>
<font color="black"> 590.                 ))</font>
<font color="black"> 591.         # Nullability change?</font>
<font color="red"> 592.         if old_field.null != new_field.null:</font>
<font color="red"> 593.             if (self.connection.features.interprets_empty_strings_as_nulls and</font>
<font color="red"> 594.                     new_field.get_internal_type() in (&quot;CharField&quot;, &quot;TextField&quot;)):</font>
<font color="black"> 595.                 # The field is nullable in the database anyway, leave it alone</font>
<font color="red"> 596.                 pass</font>
<font color="red"> 597.             elif new_field.null:</font>
<font color="red"> 598.                 null_actions.append((</font>
<font color="red"> 599.                     self.sql_alter_column_null % {</font>
<font color="red"> 600.                         &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 601.                         &quot;type&quot;: new_type,</font>
<font color="black"> 602.                     },</font>
<font color="red"> 603.                     [],</font>
<font color="black"> 604.                 ))</font>
<font color="black"> 605.             else:</font>
<font color="red"> 606.                 null_actions.append((</font>
<font color="red"> 607.                     self.sql_alter_column_not_null % {</font>
<font color="red"> 608.                         &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 609.                         &quot;type&quot;: new_type,</font>
<font color="black"> 610.                     },</font>
<font color="red"> 611.                     [],</font>
<font color="black"> 612.                 ))</font>
<font color="black"> 613.         # Only if we have a default and there is a change from NULL to NOT NULL</font>
<font color="black"> 614.         four_way_default_alteration = (</font>
<font color="red"> 615.             new_field.has_default() and</font>
<font color="red"> 616.             (old_field.null and not new_field.null)</font>
<font color="black"> 617.         )</font>
<font color="red"> 618.         if actions or null_actions:</font>
<font color="red"> 619.             if not four_way_default_alteration:</font>
<font color="black"> 620.                 # If we don't have to do a 4-way default alteration we can</font>
<font color="black"> 621.                 # directly run a (NOT) NULL alteration</font>
<font color="red"> 622.                 actions = actions + null_actions</font>
<font color="black"> 623.             # Combine actions together if we can (e.g. postgres)</font>
<font color="red"> 624.             if self.connection.features.supports_combined_alters and actions:</font>
<font color="red"> 625.                 sql, params = tuple(zip(*actions))</font>
<font color="red"> 626.                 actions = [(&quot;, &quot;.join(sql), sum(params, []))]</font>
<font color="black"> 627.             # Apply those actions</font>
<font color="red"> 628.             for sql, params in actions:</font>
<font color="red"> 629.                 self.execute(</font>
<font color="red"> 630.                     self.sql_alter_column % {</font>
<font color="red"> 631.                         &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 632.                         &quot;changes&quot;: sql,</font>
<font color="black"> 633.                     },</font>
<font color="red"> 634.                     params,</font>
<font color="black"> 635.                 )</font>
<font color="red"> 636.             if four_way_default_alteration:</font>
<font color="black"> 637.                 # Update existing rows with default value</font>
<font color="red"> 638.                 self.execute(</font>
<font color="red"> 639.                     self.sql_update_with_default % {</font>
<font color="red"> 640.                         &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 641.                         &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 642.                         &quot;default&quot;: &quot;%s&quot;,</font>
<font color="black"> 643.                     },</font>
<font color="red"> 644.                     [new_default],</font>
<font color="black"> 645.                 )</font>
<font color="black"> 646.                 # Since we didn't run a NOT NULL change before we need to do it</font>
<font color="black"> 647.                 # now</font>
<font color="red"> 648.                 for sql, params in null_actions:</font>
<font color="red"> 649.                     self.execute(</font>
<font color="red"> 650.                         self.sql_alter_column % {</font>
<font color="red"> 651.                             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 652.                             &quot;changes&quot;: sql,</font>
<font color="black"> 653.                         },</font>
<font color="red"> 654.                         params,</font>
<font color="black"> 655.                     )</font>
<font color="red"> 656.         if post_actions:</font>
<font color="red"> 657.             for sql, params in post_actions:</font>
<font color="red"> 658.                 self.execute(sql, params)</font>
<font color="black"> 659.         # Added a unique?</font>
<font color="red"> 660.         if (not old_field.unique and new_field.unique) or (</font>
<font color="red"> 661.             old_field.primary_key and not new_field.primary_key and new_field.unique</font>
<font color="black"> 662.         ):</font>
<font color="red"> 663.             self.execute(self._create_unique_sql(model, [new_field.column]))</font>
<font color="black"> 664.         # Added an index?</font>
<font color="red"> 665.         if (not old_field.db_index and new_field.db_index and</font>
<font color="red"> 666.                 not new_field.unique and not</font>
<font color="red"> 667.                 (not old_field.unique and new_field.unique)):</font>
<font color="red"> 668.             self.execute(self._create_index_sql(model, [new_field], suffix=&quot;_uniq&quot;))</font>
<font color="black"> 669.         # Type alteration on primary key? Then we need to alter the column</font>
<font color="black"> 670.         # referring to us.</font>
<font color="red"> 671.         rels_to_update = []</font>
<font color="red"> 672.         if old_field.primary_key and new_field.primary_key and old_type != new_type:</font>
<font color="red"> 673.             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))</font>
<font color="black"> 674.         # Changed to become primary key?</font>
<font color="black"> 675.         # Note that we don't detect unsetting of a PK, as we assume another field</font>
<font color="black"> 676.         # will always come along and replace it.</font>
<font color="red"> 677.         if not old_field.primary_key and new_field.primary_key:</font>
<font color="black"> 678.             # First, drop the old PK</font>
<font color="red"> 679.             constraint_names = self._constraint_names(model, primary_key=True)</font>
<font color="red"> 680.             if strict and len(constraint_names) != 1:</font>
<font color="red"> 681.                 raise ValueError(&quot;Found wrong number (%s) of PK constraints for %s&quot; % (</font>
<font color="red"> 682.                     len(constraint_names),</font>
<font color="red"> 683.                     model._meta.db_table,</font>
<font color="black"> 684.                 ))</font>
<font color="red"> 685.             for constraint_name in constraint_names:</font>
<font color="red"> 686.                 self.execute(self._delete_constraint_sql(self.sql_delete_pk, model, constraint_name))</font>
<font color="black"> 687.             # Make the new one</font>
<font color="red"> 688.             self.execute(</font>
<font color="red"> 689.                 self.sql_create_pk % {</font>
<font color="red"> 690.                     &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 691.                     &quot;name&quot;: self.quote_name(self._create_index_name(model, [new_field.column], suffix=&quot;_pk&quot;)),</font>
<font color="red"> 692.                     &quot;columns&quot;: self.quote_name(new_field.column),</font>
<font color="black"> 693.                 }</font>
<font color="black"> 694.             )</font>
<font color="black"> 695.             # Update all referencing columns</font>
<font color="red"> 696.             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))</font>
<font color="black"> 697.         # Handle our type alters on the other end of rels from the PK stuff above</font>
<font color="red"> 698.         for old_rel, new_rel in rels_to_update:</font>
<font color="red"> 699.             rel_db_params = new_rel.field.db_parameters(connection=self.connection)</font>
<font color="red"> 700.             rel_type = rel_db_params['type']</font>
<font color="red"> 701.             fragment, other_actions = self._alter_column_type_sql(</font>
<font color="red"> 702.                 new_rel.related_model._meta.db_table, old_rel.field, new_rel.field, rel_type</font>
<font color="black"> 703.             )</font>
<font color="red"> 704.             self.execute(</font>
<font color="red"> 705.                 self.sql_alter_column % {</font>
<font color="red"> 706.                     &quot;table&quot;: self.quote_name(new_rel.related_model._meta.db_table),</font>
<font color="red"> 707.                     &quot;changes&quot;: fragment[0],</font>
<font color="black"> 708.                 },</font>
<font color="red"> 709.                 fragment[1],</font>
<font color="black"> 710.             )</font>
<font color="red"> 711.             for sql, params in other_actions:</font>
<font color="red"> 712.                 self.execute(sql, params)</font>
<font color="black"> 713.         # Does it have a foreign key?</font>
<font color="red"> 714.         if (new_field.remote_field and</font>
<font color="red"> 715.                 (fks_dropped or not old_field.remote_field or not old_field.db_constraint) and</font>
<font color="red"> 716.                 new_field.db_constraint):</font>
<font color="red"> 717.             self.execute(self._create_fk_sql(model, new_field, &quot;_fk_%(to_table)s_%(to_column)s&quot;))</font>
<font color="black"> 718.         # Rebuild FKs that pointed to us if we previously had to drop them</font>
<font color="red"> 719.         if old_field.primary_key and new_field.primary_key and old_type != new_type:</font>
<font color="red"> 720.             for rel in new_field.model._meta.related_objects:</font>
<font color="red"> 721.                 if not rel.many_to_many:</font>
<font color="red"> 722.                     self.execute(self._create_fk_sql(rel.related_model, rel.field, &quot;_fk&quot;))</font>
<font color="black"> 723.         # Does it have check constraints we need to add?</font>
<font color="red"> 724.         if old_db_params['check'] != new_db_params['check'] and new_db_params['check']:</font>
<font color="red"> 725.             self.execute(</font>
<font color="red"> 726.                 self.sql_create_check % {</font>
<font color="red"> 727.                     &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 728.                     &quot;name&quot;: self.quote_name(self._create_index_name(model, [new_field.column], suffix=&quot;_check&quot;)),</font>
<font color="red"> 729.                     &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 730.                     &quot;check&quot;: new_db_params['check'],</font>
<font color="black"> 731.                 }</font>
<font color="black"> 732.             )</font>
<font color="black"> 733.         # Drop the default if we need to</font>
<font color="black"> 734.         # (Django usually does not use in-database defaults)</font>
<font color="red"> 735.         if needs_database_default:</font>
<font color="red"> 736.             sql = self.sql_alter_column % {</font>
<font color="red"> 737.                 &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 738.                 &quot;changes&quot;: self.sql_alter_column_no_default % {</font>
<font color="red"> 739.                     &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="black"> 740.                 }</font>
<font color="black"> 741.             }</font>
<font color="red"> 742.             self.execute(sql)</font>
<font color="black"> 743.         # Reset connection if required</font>
<font color="red"> 744.         if self.connection.features.connection_persists_old_columns:</font>
<font color="red"> 745.             self.connection.close()</font>
<font color="black"> 746. </font>
<font color="green"> 747.     def _alter_column_type_sql(self, table, old_field, new_field, new_type):</font>
<font color="black"> 748.         &quot;&quot;&quot;</font>
<font color="black"> 749.         Hook to specialize column type alteration for different backends,</font>
<font color="black"> 750.         for cases when a creation type is different to an alteration type</font>
<font color="black"> 751.         (e.g. SERIAL in PostgreSQL, PostGIS fields).</font>
<font color="black"> 752. </font>
<font color="black"> 753.         Should return two things; an SQL fragment of (sql, params) to insert</font>
<font color="black"> 754.         into an ALTER TABLE statement, and a list of extra (sql, params) tuples</font>
<font color="black"> 755.         to run once the field is altered.</font>
<font color="black"> 756.         &quot;&quot;&quot;</font>
<font color="black"> 757.         return (</font>
<font color="black"> 758.             (</font>
<font color="red"> 759.                 self.sql_alter_column_type % {</font>
<font color="red"> 760.                     &quot;column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 761.                     &quot;type&quot;: new_type,</font>
<font color="black"> 762.                 },</font>
<font color="red"> 763.                 [],</font>
<font color="black"> 764.             ),</font>
<font color="red"> 765.             [],</font>
<font color="black"> 766.         )</font>
<font color="black"> 767. </font>
<font color="green"> 768.     def _alter_many_to_many(self, model, old_field, new_field, strict):</font>
<font color="black"> 769.         &quot;&quot;&quot;</font>
<font color="black"> 770.         Alters M2Ms to repoint their to= endpoints.</font>
<font color="black"> 771.         &quot;&quot;&quot;</font>
<font color="black"> 772.         # Rename the through table</font>
<font color="red"> 773.         if old_field.remote_field.through._meta.db_table != new_field.remote_field.through._meta.db_table:</font>
<font color="red"> 774.             self.alter_db_table(old_field.remote_field.through, old_field.remote_field.through._meta.db_table,</font>
<font color="red"> 775.                                 new_field.remote_field.through._meta.db_table)</font>
<font color="black"> 776.         # Repoint the FK to the other side</font>
<font color="red"> 777.         self.alter_field(</font>
<font color="red"> 778.             new_field.remote_field.through,</font>
<font color="black"> 779.             # We need the field that points to the target model, so we can tell alter_field to change it -</font>
<font color="black"> 780.             # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)</font>
<font color="red"> 781.             old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),</font>
<font color="red"> 782.             new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),</font>
<font color="black"> 783.         )</font>
<font color="red"> 784.         self.alter_field(</font>
<font color="red"> 785.             new_field.remote_field.through,</font>
<font color="black"> 786.             # for self-referential models we need to alter field from the other end too</font>
<font color="red"> 787.             old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),</font>
<font color="red"> 788.             new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),</font>
<font color="black"> 789.         )</font>
<font color="black"> 790. </font>
<font color="green"> 791.     def _create_index_name(self, model, column_names, suffix=&quot;&quot;):</font>
<font color="black"> 792.         &quot;&quot;&quot;</font>
<font color="black"> 793.         Generates a unique name for an index/unique constraint.</font>
<font color="black"> 794.         &quot;&quot;&quot;</font>
<font color="black"> 795.         # If there is just one column in the index, use a default algorithm from Django</font>
<font color="green"> 796.         if len(column_names) == 1 and not suffix:</font>
<font color="green"> 797.             return truncate_name(</font>
<font color="green"> 798.                 '%s_%s' % (model._meta.db_table, self._digest(column_names[0])),</font>
<font color="green"> 799.                 self.connection.ops.max_name_length()</font>
<font color="black"> 800.             )</font>
<font color="black"> 801.         # Else generate the name for the index using a different algorithm</font>
<font color="green"> 802.         table_name = model._meta.db_table.replace('&quot;', '').replace('.', '_')</font>
<font color="green"> 803.         index_unique_name = '_%s' % self._digest(table_name, *column_names)</font>
<font color="green"> 804.         max_length = self.connection.ops.max_name_length() or 200</font>
<font color="black"> 805.         # If the index name is too long, truncate it</font>
<font color="green"> 806.         index_name = ('%s_%s%s%s' % (</font>
<font color="green"> 807.             table_name, column_names[0], index_unique_name, suffix,</font>
<font color="green"> 808.         )).replace('&quot;', '').replace('.', '_')</font>
<font color="green"> 809.         if len(index_name) &gt; max_length:</font>
<font color="red"> 810.             part = ('_%s%s%s' % (column_names[0], index_unique_name, suffix))</font>
<font color="red"> 811.             index_name = '%s%s' % (table_name[:(max_length - len(part))], part)</font>
<font color="black"> 812.         # It shouldn't start with an underscore (Oracle hates this)</font>
<font color="green"> 813.         if index_name[0] == &quot;_&quot;:</font>
<font color="red"> 814.             index_name = index_name[1:]</font>
<font color="black"> 815.         # If it's STILL too long, just hash it down</font>
<font color="green"> 816.         if len(index_name) &gt; max_length:</font>
<font color="red"> 817.             index_name = hashlib.md5(force_bytes(index_name)).hexdigest()[:max_length]</font>
<font color="black"> 818.         # It can't start with a number on Oracle, so prepend D if we need to</font>
<font color="green"> 819.         if index_name[0].isdigit():</font>
<font color="red"> 820.             index_name = &quot;D%s&quot; % index_name[:-1]</font>
<font color="green"> 821.         return index_name</font>
<font color="black"> 822. </font>
<font color="green"> 823.     def _create_index_sql(self, model, fields, suffix=&quot;&quot;, sql=None):</font>
<font color="black"> 824.         &quot;&quot;&quot;</font>
<font color="black"> 825.         Return the SQL statement to create the index for one or several fields.</font>
<font color="black"> 826.         `sql` can be specified if the syntax differs from the standard (GIS</font>
<font color="black"> 827.         indexes, ...).</font>
<font color="black"> 828.         &quot;&quot;&quot;</font>
<font color="green"> 829.         if len(fields) == 1 and fields[0].db_tablespace:</font>
<font color="red"> 830.             tablespace_sql = self.connection.ops.tablespace_sql(fields[0].db_tablespace)</font>
<font color="green"> 831.         elif model._meta.db_tablespace:</font>
<font color="red"> 832.             tablespace_sql = self.connection.ops.tablespace_sql(model._meta.db_tablespace)</font>
<font color="black"> 833.         else:</font>
<font color="green"> 834.             tablespace_sql = &quot;&quot;</font>
<font color="green"> 835.         if tablespace_sql:</font>
<font color="red"> 836.             tablespace_sql = &quot; &quot; + tablespace_sql</font>
<font color="black"> 837. </font>
<font color="green"> 838.         columns = [field.column for field in fields]</font>
<font color="green"> 839.         sql_create_index = sql or self.sql_create_index</font>
<font color="green"> 840.         return sql_create_index % {</font>
<font color="green"> 841.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="green"> 842.             &quot;name&quot;: self.quote_name(self._create_index_name(model, columns, suffix=suffix)),</font>
<font color="green"> 843.             &quot;columns&quot;: &quot;, &quot;.join(self.quote_name(column) for column in columns),</font>
<font color="green"> 844.             &quot;extra&quot;: tablespace_sql,</font>
<font color="black"> 845.         }</font>
<font color="black"> 846. </font>
<font color="green"> 847.     def _model_indexes_sql(self, model):</font>
<font color="black"> 848.         &quot;&quot;&quot;</font>
<font color="black"> 849.         Return all index SQL statements (field indexes, index_together) for the</font>
<font color="black"> 850.         specified model, as a list.</font>
<font color="black"> 851.         &quot;&quot;&quot;</font>
<font color="green"> 852.         if not model._meta.managed or model._meta.proxy or model._meta.swapped:</font>
<font color="red"> 853.             return []</font>
<font color="green"> 854.         output = []</font>
<font color="green"> 855.         for field in model._meta.local_fields:</font>
<font color="green"> 856.             if field.db_index and not field.unique:</font>
<font color="green"> 857.                 output.append(self._create_index_sql(model, [field], suffix=&quot;&quot;))</font>
<font color="black"> 858. </font>
<font color="green"> 859.         for field_names in model._meta.index_together:</font>
<font color="red"> 860.             fields = [model._meta.get_field(field) for field in field_names]</font>
<font color="red"> 861.             output.append(self._create_index_sql(model, fields, suffix=&quot;_idx&quot;))</font>
<font color="green"> 862.         return output</font>
<font color="black"> 863. </font>
<font color="green"> 864.     def _rename_field_sql(self, table, old_field, new_field, new_type):</font>
<font color="red"> 865.         return self.sql_rename_column % {</font>
<font color="red"> 866.             &quot;table&quot;: self.quote_name(table),</font>
<font color="red"> 867.             &quot;old_column&quot;: self.quote_name(old_field.column),</font>
<font color="red"> 868.             &quot;new_column&quot;: self.quote_name(new_field.column),</font>
<font color="red"> 869.             &quot;type&quot;: new_type,</font>
<font color="black"> 870.         }</font>
<font color="black"> 871. </font>
<font color="green"> 872.     def _create_fk_sql(self, model, field, suffix):</font>
<font color="red"> 873.         from_table = model._meta.db_table</font>
<font color="red"> 874.         from_column = field.column</font>
<font color="red"> 875.         to_table = field.target_field.model._meta.db_table</font>
<font color="red"> 876.         to_column = field.target_field.column</font>
<font color="red"> 877.         suffix = suffix % {</font>
<font color="red"> 878.             &quot;to_table&quot;: to_table,</font>
<font color="red"> 879.             &quot;to_column&quot;: to_column,</font>
<font color="black"> 880.         }</font>
<font color="black"> 881. </font>
<font color="red"> 882.         return self.sql_create_fk % {</font>
<font color="red"> 883.             &quot;table&quot;: self.quote_name(from_table),</font>
<font color="red"> 884.             &quot;name&quot;: self.quote_name(self._create_index_name(model, [from_column], suffix=suffix)),</font>
<font color="red"> 885.             &quot;column&quot;: self.quote_name(from_column),</font>
<font color="red"> 886.             &quot;to_table&quot;: self.quote_name(to_table),</font>
<font color="red"> 887.             &quot;to_column&quot;: self.quote_name(to_column),</font>
<font color="black"> 888.         }</font>
<font color="black"> 889. </font>
<font color="green"> 890.     def _create_unique_sql(self, model, columns):</font>
<font color="green"> 891.         return self.sql_create_unique % {</font>
<font color="green"> 892.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="green"> 893.             &quot;name&quot;: self.quote_name(self._create_index_name(model, columns, suffix=&quot;_uniq&quot;)),</font>
<font color="green"> 894.             &quot;columns&quot;: &quot;, &quot;.join(self.quote_name(column) for column in columns),</font>
<font color="black"> 895.         }</font>
<font color="black"> 896. </font>
<font color="green"> 897.     def _delete_constraint_sql(self, template, model, name):</font>
<font color="red"> 898.         return template % {</font>
<font color="red"> 899.             &quot;table&quot;: self.quote_name(model._meta.db_table),</font>
<font color="red"> 900.             &quot;name&quot;: self.quote_name(name),</font>
<font color="black"> 901.         }</font>
<font color="black"> 902. </font>
<font color="green"> 903.     def _constraint_names(self, model, column_names=None, unique=None,</font>
<font color="green"> 904.                           primary_key=None, index=None, foreign_key=None,</font>
<font color="green"> 905.                           check=None):</font>
<font color="black"> 906.         &quot;&quot;&quot;</font>
<font color="black"> 907.         Returns all constraint names matching the columns and conditions</font>
<font color="black"> 908.         &quot;&quot;&quot;</font>
<font color="red"> 909.         column_names = list(column_names) if column_names else None</font>
<font color="red"> 910.         with self.connection.cursor() as cursor:</font>
<font color="red"> 911.             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)</font>
<font color="red"> 912.         result = []</font>
<font color="red"> 913.         for name, infodict in constraints.items():</font>
<font color="red"> 914.             if column_names is None or column_names == infodict['columns']:</font>
<font color="red"> 915.                 if unique is not None and infodict['unique'] != unique:</font>
<font color="red"> 916.                     continue</font>
<font color="red"> 917.                 if primary_key is not None and infodict['primary_key'] != primary_key:</font>
<font color="red"> 918.                     continue</font>
<font color="red"> 919.                 if index is not None and infodict['index'] != index:</font>
<font color="red"> 920.                     continue</font>
<font color="red"> 921.                 if check is not None and infodict['check'] != check:</font>
<font color="red"> 922.                     continue</font>
<font color="red"> 923.                 if foreign_key is not None and not infodict['foreign_key']:</font>
<font color="red"> 924.                     continue</font>
<font color="red"> 925.                 result.append(name)</font>
<font color="red"> 926.         return result</font>
</pre>

