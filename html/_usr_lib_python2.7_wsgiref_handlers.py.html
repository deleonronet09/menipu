source file: <b>/usr/lib/python2.7/wsgiref/handlers.py</b><br>


file stats: <b>209 lines, 72 executed: 34.4% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Base classes for server/gateway implementations&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="green">   3. from types import StringType</font>
<font color="green">   4. from util import FileWrapper, guess_scheme, is_hop_by_hop</font>
<font color="green">   5. from headers import Headers</font>
<font color="black">   6. </font>
<font color="green">   7. import sys, os, time</font>
<font color="black">   8. </font>
<font color="green">   9. __all__ = ['BaseHandler', 'SimpleHandler', 'BaseCGIHandler', 'CGIHandler']</font>
<font color="black">  10. </font>
<font color="green">  11. try:</font>
<font color="green">  12.     dict</font>
<font color="red">  13. except NameError:</font>
<font color="red">  14.     def dict(items):</font>
<font color="red">  15.         d = {}</font>
<font color="red">  16.         for k,v in items:</font>
<font color="red">  17.             d[k] = v</font>
<font color="red">  18.         return d</font>
<font color="black">  19. </font>
<font color="black">  20. # Uncomment for 2.2 compatibility.</font>
<font color="black">  21. #try:</font>
<font color="black">  22. #    True</font>
<font color="black">  23. #    False</font>
<font color="black">  24. #except NameError:</font>
<font color="black">  25. #    True = not None</font>
<font color="black">  26. #    False = not True</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="black">  29. # Weekday and month names for HTTP date/time formatting; always English!</font>
<font color="green">  30. _weekdayname = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;]</font>
<font color="green">  31. _monthname = [None, # Dummy so we can use 1-based month numbers</font>
<font color="green">  32.               &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,</font>
<font color="green">  33.               &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]</font>
<font color="black">  34. </font>
<font color="green">  35. def format_date_time(timestamp):</font>
<font color="red">  36.     year, month, day, hh, mm, ss, wd, y, z = time.gmtime(timestamp)</font>
<font color="red">  37.     return &quot;%s, %02d %3s %4d %02d:%02d:%02d GMT&quot; % (</font>
<font color="red">  38.         _weekdayname[wd], day, _monthname[month], year, hh, mm, ss</font>
<font color="black">  39.     )</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. class BaseHandler:</font>
<font color="green">  43.     &quot;&quot;&quot;Manage the invocation of a WSGI application&quot;&quot;&quot;</font>
<font color="black">  44. </font>
<font color="black">  45.     # Configuration parameters; can override per-subclass or per-instance</font>
<font color="green">  46.     wsgi_version = (1,0)</font>
<font color="green">  47.     wsgi_multithread = True</font>
<font color="green">  48.     wsgi_multiprocess = True</font>
<font color="green">  49.     wsgi_run_once = False</font>
<font color="black">  50. </font>
<font color="green">  51.     origin_server = True    # We are transmitting direct to client</font>
<font color="green">  52.     http_version  = &quot;1.0&quot;   # Version that should be used for response</font>
<font color="green">  53.     server_software = None  # String name of server software, if any</font>
<font color="black">  54. </font>
<font color="black">  55.     # os_environ is used to supply configuration from the OS environment:</font>
<font color="black">  56.     # by default it's a copy of 'os.environ' as of import time, but you can</font>
<font color="black">  57.     # override this in e.g. your __init__ method.</font>
<font color="green">  58.     os_environ = dict(os.environ.items())</font>
<font color="black">  59. </font>
<font color="black">  60.     # Collaborator classes</font>
<font color="green">  61.     wsgi_file_wrapper = FileWrapper     # set to None to disable</font>
<font color="green">  62.     headers_class = Headers             # must be a Headers-like class</font>
<font color="black">  63. </font>
<font color="black">  64.     # Error handling (also per-subclass or per-instance)</font>
<font color="green">  65.     traceback_limit = None  # Print entire traceback to self.get_stderr()</font>
<font color="green">  66.     error_status = &quot;500 Internal Server Error&quot;</font>
<font color="green">  67.     error_headers = [('Content-Type','text/plain')]</font>
<font color="green">  68.     error_body = &quot;A server error occurred.  Please contact the administrator.&quot;</font>
<font color="black">  69. </font>
<font color="black">  70.     # State variables (don't mess with these)</font>
<font color="green">  71.     status = result = None</font>
<font color="green">  72.     headers_sent = False</font>
<font color="green">  73.     headers = None</font>
<font color="green">  74.     bytes_sent = 0</font>
<font color="black">  75. </font>
<font color="green">  76.     def run(self, application):</font>
<font color="black">  77.         &quot;&quot;&quot;Invoke the application&quot;&quot;&quot;</font>
<font color="black">  78.         # Note to self: don't move the close()!  Asynchronous servers shouldn't</font>
<font color="black">  79.         # call close() from finish_response(), so if you close() anywhere but</font>
<font color="black">  80.         # the double-error branch here, you'll break asynchronous servers by</font>
<font color="black">  81.         # prematurely closing.  Async servers must return from 'run()' without</font>
<font color="black">  82.         # closing if there might still be output to iterate over.</font>
<font color="red">  83.         try:</font>
<font color="red">  84.             self.setup_environ()</font>
<font color="red">  85.             self.result = application(self.environ, self.start_response)</font>
<font color="red">  86.             self.finish_response()</font>
<font color="red">  87.         except:</font>
<font color="red">  88.             try:</font>
<font color="red">  89.                 self.handle_error()</font>
<font color="red">  90.             except:</font>
<font color="black">  91.                 # If we get an error handling an error, just give up already!</font>
<font color="red">  92.                 self.close()</font>
<font color="red">  93.                 raise   # ...and let the actual server figure it out.</font>
<font color="black">  94. </font>
<font color="black">  95. </font>
<font color="green">  96.     def setup_environ(self):</font>
<font color="black">  97.         &quot;&quot;&quot;Set up the environment for one request&quot;&quot;&quot;</font>
<font color="black">  98. </font>
<font color="red">  99.         env = self.environ = self.os_environ.copy()</font>
<font color="red"> 100.         self.add_cgi_vars()</font>
<font color="black"> 101. </font>
<font color="red"> 102.         env['wsgi.input']        = self.get_stdin()</font>
<font color="red"> 103.         env['wsgi.errors']       = self.get_stderr()</font>
<font color="red"> 104.         env['wsgi.version']      = self.wsgi_version</font>
<font color="red"> 105.         env['wsgi.run_once']     = self.wsgi_run_once</font>
<font color="red"> 106.         env['wsgi.url_scheme']   = self.get_scheme()</font>
<font color="red"> 107.         env['wsgi.multithread']  = self.wsgi_multithread</font>
<font color="red"> 108.         env['wsgi.multiprocess'] = self.wsgi_multiprocess</font>
<font color="black"> 109. </font>
<font color="red"> 110.         if self.wsgi_file_wrapper is not None:</font>
<font color="red"> 111.             env['wsgi.file_wrapper'] = self.wsgi_file_wrapper</font>
<font color="black"> 112. </font>
<font color="red"> 113.         if self.origin_server and self.server_software:</font>
<font color="red"> 114.             env.setdefault('SERVER_SOFTWARE',self.server_software)</font>
<font color="black"> 115. </font>
<font color="black"> 116. </font>
<font color="green"> 117.     def finish_response(self):</font>
<font color="black"> 118.         &quot;&quot;&quot;Send any iterable data, then close self and the iterable</font>
<font color="black"> 119. </font>
<font color="black"> 120.         Subclasses intended for use in asynchronous servers will</font>
<font color="black"> 121.         want to redefine this method, such that it sets up callbacks</font>
<font color="black"> 122.         in the event loop to iterate over the data, and to call</font>
<font color="black"> 123.         'self.close()' once the response is finished.</font>
<font color="black"> 124.         &quot;&quot;&quot;</font>
<font color="red"> 125.         try:</font>
<font color="red"> 126.             if not self.result_is_file() or not self.sendfile():</font>
<font color="red"> 127.                 for data in self.result:</font>
<font color="red"> 128.                     self.write(data)</font>
<font color="red"> 129.                 self.finish_content()</font>
<font color="black"> 130.         finally:</font>
<font color="red"> 131.             self.close()</font>
<font color="black"> 132. </font>
<font color="black"> 133. </font>
<font color="green"> 134.     def get_scheme(self):</font>
<font color="black"> 135.         &quot;&quot;&quot;Return the URL scheme being used&quot;&quot;&quot;</font>
<font color="red"> 136.         return guess_scheme(self.environ)</font>
<font color="black"> 137. </font>
<font color="black"> 138. </font>
<font color="green"> 139.     def set_content_length(self):</font>
<font color="black"> 140.         &quot;&quot;&quot;Compute Content-Length or switch to chunked encoding if possible&quot;&quot;&quot;</font>
<font color="red"> 141.         try:</font>
<font color="red"> 142.             blocks = len(self.result)</font>
<font color="red"> 143.         except (TypeError,AttributeError,NotImplementedError):</font>
<font color="red"> 144.             pass</font>
<font color="black"> 145.         else:</font>
<font color="red"> 146.             if blocks==1:</font>
<font color="red"> 147.                 self.headers['Content-Length'] = str(self.bytes_sent)</font>
<font color="red"> 148.                 return</font>
<font color="black"> 149.         # XXX Try for chunked encoding if origin server and client is 1.1</font>
<font color="black"> 150. </font>
<font color="black"> 151. </font>
<font color="green"> 152.     def cleanup_headers(self):</font>
<font color="black"> 153.         &quot;&quot;&quot;Make any necessary header changes or defaults</font>
<font color="black"> 154. </font>
<font color="black"> 155.         Subclasses can extend this to add other defaults.</font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="red"> 157.         if 'Content-Length' not in self.headers:</font>
<font color="red"> 158.             self.set_content_length()</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def start_response(self, status, headers,exc_info=None):</font>
<font color="black"> 161.         &quot;&quot;&quot;'start_response()' callable as specified by PEP 333&quot;&quot;&quot;</font>
<font color="black"> 162. </font>
<font color="red"> 163.         if exc_info:</font>
<font color="red"> 164.             try:</font>
<font color="red"> 165.                 if self.headers_sent:</font>
<font color="black"> 166.                     # Re-raise original exception if headers sent</font>
<font color="red"> 167.                     raise exc_info[0], exc_info[1], exc_info[2]</font>
<font color="black"> 168.             finally:</font>
<font color="red"> 169.                 exc_info = None        # avoid dangling circular ref</font>
<font color="red"> 170.         elif self.headers is not None:</font>
<font color="red"> 171.             raise AssertionError(&quot;Headers already set!&quot;)</font>
<font color="black"> 172. </font>
<font color="red"> 173.         assert type(status) is StringType,&quot;Status must be a string&quot;</font>
<font color="red"> 174.         assert len(status)&gt;=4,&quot;Status must be at least 4 characters&quot;</font>
<font color="red"> 175.         assert int(status[:3]),&quot;Status message must begin w/3-digit code&quot;</font>
<font color="red"> 176.         assert status[3]==&quot; &quot;, &quot;Status message must have a space after code&quot;</font>
<font color="black"> 177.         if __debug__:</font>
<font color="red"> 178.             for name,val in headers:</font>
<font color="red"> 179.                 assert type(name) is StringType,&quot;Header names must be strings&quot;</font>
<font color="red"> 180.                 assert type(val) is StringType,&quot;Header values must be strings&quot;</font>
<font color="red"> 181.                 assert not is_hop_by_hop(name),&quot;Hop-by-hop headers not allowed&quot;</font>
<font color="red"> 182.         self.status = status</font>
<font color="red"> 183.         self.headers = self.headers_class(headers)</font>
<font color="red"> 184.         return self.write</font>
<font color="black"> 185. </font>
<font color="black"> 186. </font>
<font color="green"> 187.     def send_preamble(self):</font>
<font color="black"> 188.         &quot;&quot;&quot;Transmit version/status/date/server, via self._write()&quot;&quot;&quot;</font>
<font color="red"> 189.         if self.origin_server:</font>
<font color="red"> 190.             if self.client_is_modern():</font>
<font color="red"> 191.                 self._write('HTTP/%s %s\r\n' % (self.http_version,self.status))</font>
<font color="red"> 192.                 if 'Date' not in self.headers:</font>
<font color="red"> 193.                     self._write(</font>
<font color="red"> 194.                         'Date: %s\r\n' % format_date_time(time.time())</font>
<font color="black"> 195.                     )</font>
<font color="red"> 196.                 if self.server_software and 'Server' not in self.headers:</font>
<font color="red"> 197.                     self._write('Server: %s\r\n' % self.server_software)</font>
<font color="black"> 198.         else:</font>
<font color="red"> 199.             self._write('Status: %s\r\n' % self.status)</font>
<font color="black"> 200. </font>
<font color="green"> 201.     def write(self, data):</font>
<font color="black"> 202.         &quot;&quot;&quot;'write()' callable as specified by PEP 333&quot;&quot;&quot;</font>
<font color="black"> 203. </font>
<font color="red"> 204.         assert type(data) is StringType,&quot;write() argument must be string&quot;</font>
<font color="black"> 205. </font>
<font color="red"> 206.         if not self.status:</font>
<font color="red"> 207.             raise AssertionError(&quot;write() before start_response()&quot;)</font>
<font color="black"> 208. </font>
<font color="red"> 209.         elif not self.headers_sent:</font>
<font color="black"> 210.             # Before the first output, send the stored headers</font>
<font color="red"> 211.             self.bytes_sent = len(data)    # make sure we know content-length</font>
<font color="red"> 212.             self.send_headers()</font>
<font color="black"> 213.         else:</font>
<font color="red"> 214.             self.bytes_sent += len(data)</font>
<font color="black"> 215. </font>
<font color="black"> 216.         # XXX check Content-Length and truncate if too many bytes written?</font>
<font color="red"> 217.         self._write(data)</font>
<font color="red"> 218.         self._flush()</font>
<font color="black"> 219. </font>
<font color="black"> 220. </font>
<font color="green"> 221.     def sendfile(self):</font>
<font color="black"> 222.         &quot;&quot;&quot;Platform-specific file transmission</font>
<font color="black"> 223. </font>
<font color="black"> 224.         Override this method in subclasses to support platform-specific</font>
<font color="black"> 225.         file transmission.  It is only called if the application's</font>
<font color="black"> 226.         return iterable ('self.result') is an instance of</font>
<font color="black"> 227.         'self.wsgi_file_wrapper'.</font>
<font color="black"> 228. </font>
<font color="black"> 229.         This method should return a true value if it was able to actually</font>
<font color="black"> 230.         transmit the wrapped file-like object using a platform-specific</font>
<font color="black"> 231.         approach.  It should return a false value if normal iteration</font>
<font color="black"> 232.         should be used instead.  An exception can be raised to indicate</font>
<font color="black"> 233.         that transmission was attempted, but failed.</font>
<font color="black"> 234. </font>
<font color="black"> 235.         NOTE: this method should call 'self.send_headers()' if</font>
<font color="black"> 236.         'self.headers_sent' is false and it is going to attempt direct</font>
<font color="black"> 237.         transmission of the file.</font>
<font color="black"> 238.         &quot;&quot;&quot;</font>
<font color="red"> 239.         return False   # No platform-specific transmission by default</font>
<font color="black"> 240. </font>
<font color="black"> 241. </font>
<font color="green"> 242.     def finish_content(self):</font>
<font color="black"> 243.         &quot;&quot;&quot;Ensure headers and content have both been sent&quot;&quot;&quot;</font>
<font color="red"> 244.         if not self.headers_sent:</font>
<font color="black"> 245.             # Only zero Content-Length if not set by the application (so</font>
<font color="black"> 246.             # that HEAD requests can be satisfied properly, see #3839)</font>
<font color="red"> 247.             self.headers.setdefault('Content-Length', &quot;0&quot;)</font>
<font color="red"> 248.             self.send_headers()</font>
<font color="black"> 249.         else:</font>
<font color="red"> 250.             pass # XXX check if content-length was too short?</font>
<font color="black"> 251. </font>
<font color="green"> 252.     def close(self):</font>
<font color="black"> 253.         &quot;&quot;&quot;Close the iterable (if needed) and reset all instance vars</font>
<font color="black"> 254. </font>
<font color="black"> 255.         Subclasses may want to also drop the client connection.</font>
<font color="black"> 256.         &quot;&quot;&quot;</font>
<font color="red"> 257.         try:</font>
<font color="red"> 258.             if hasattr(self.result,'close'):</font>
<font color="red"> 259.                 self.result.close()</font>
<font color="black"> 260.         finally:</font>
<font color="red"> 261.             self.result = self.headers = self.status = self.environ = None</font>
<font color="red"> 262.             self.bytes_sent = 0; self.headers_sent = False</font>
<font color="black"> 263. </font>
<font color="black"> 264. </font>
<font color="green"> 265.     def send_headers(self):</font>
<font color="black"> 266.         &quot;&quot;&quot;Transmit headers to the client, via self._write()&quot;&quot;&quot;</font>
<font color="red"> 267.         self.cleanup_headers()</font>
<font color="red"> 268.         self.headers_sent = True</font>
<font color="red"> 269.         if not self.origin_server or self.client_is_modern():</font>
<font color="red"> 270.             self.send_preamble()</font>
<font color="red"> 271.             self._write(str(self.headers))</font>
<font color="black"> 272. </font>
<font color="black"> 273. </font>
<font color="green"> 274.     def result_is_file(self):</font>
<font color="black"> 275.         &quot;&quot;&quot;True if 'self.result' is an instance of 'self.wsgi_file_wrapper'&quot;&quot;&quot;</font>
<font color="red"> 276.         wrapper = self.wsgi_file_wrapper</font>
<font color="red"> 277.         return wrapper is not None and isinstance(self.result,wrapper)</font>
<font color="black"> 278. </font>
<font color="black"> 279. </font>
<font color="green"> 280.     def client_is_modern(self):</font>
<font color="black"> 281.         &quot;&quot;&quot;True if client can accept status and headers&quot;&quot;&quot;</font>
<font color="red"> 282.         return self.environ['SERVER_PROTOCOL'].upper() != 'HTTP/0.9'</font>
<font color="black"> 283. </font>
<font color="black"> 284. </font>
<font color="green"> 285.     def log_exception(self,exc_info):</font>
<font color="black"> 286.         &quot;&quot;&quot;Log the 'exc_info' tuple in the server log</font>
<font color="black"> 287. </font>
<font color="black"> 288.         Subclasses may override to retarget the output or change its format.</font>
<font color="black"> 289.         &quot;&quot;&quot;</font>
<font color="red"> 290.         try:</font>
<font color="red"> 291.             from traceback import print_exception</font>
<font color="red"> 292.             stderr = self.get_stderr()</font>
<font color="red"> 293.             print_exception(</font>
<font color="red"> 294.                 exc_info[0], exc_info[1], exc_info[2],</font>
<font color="red"> 295.                 self.traceback_limit, stderr</font>
<font color="black"> 296.             )</font>
<font color="red"> 297.             stderr.flush()</font>
<font color="black"> 298.         finally:</font>
<font color="red"> 299.             exc_info = None</font>
<font color="black"> 300. </font>
<font color="green"> 301.     def handle_error(self):</font>
<font color="black"> 302.         &quot;&quot;&quot;Log current error, and send error output to client if possible&quot;&quot;&quot;</font>
<font color="red"> 303.         self.log_exception(sys.exc_info())</font>
<font color="red"> 304.         if not self.headers_sent:</font>
<font color="red"> 305.             self.result = self.error_output(self.environ, self.start_response)</font>
<font color="red"> 306.             self.finish_response()</font>
<font color="black"> 307.         # XXX else: attempt advanced recovery techniques for HTML or text?</font>
<font color="black"> 308. </font>
<font color="green"> 309.     def error_output(self, environ, start_response):</font>
<font color="black"> 310.         &quot;&quot;&quot;WSGI mini-app to create error output</font>
<font color="black"> 311. </font>
<font color="black"> 312.         By default, this just uses the 'error_status', 'error_headers',</font>
<font color="black"> 313.         and 'error_body' attributes to generate an output page.  It can</font>
<font color="black"> 314.         be overridden in a subclass to dynamically generate diagnostics,</font>
<font color="black"> 315.         choose an appropriate message for the user's preferred language, etc.</font>
<font color="black"> 316. </font>
<font color="black"> 317.         Note, however, that it's not recommended from a security perspective to</font>
<font color="black"> 318.         spit out diagnostics to any old user; ideally, you should have to do</font>
<font color="black"> 319.         something special to enable diagnostic output, which is why we don't</font>
<font color="black"> 320.         include any here!</font>
<font color="black"> 321.         &quot;&quot;&quot;</font>
<font color="red"> 322.         start_response(self.error_status,self.error_headers[:],sys.exc_info())</font>
<font color="red"> 323.         return [self.error_body]</font>
<font color="black"> 324. </font>
<font color="black"> 325. </font>
<font color="black"> 326.     # Pure abstract methods; *must* be overridden in subclasses</font>
<font color="black"> 327. </font>
<font color="green"> 328.     def _write(self,data):</font>
<font color="black"> 329.         &quot;&quot;&quot;Override in subclass to buffer data for send to client</font>
<font color="black"> 330. </font>
<font color="black"> 331.         It's okay if this method actually transmits the data; BaseHandler</font>
<font color="black"> 332.         just separates write and flush operations for greater efficiency</font>
<font color="black"> 333.         when the underlying system actually has such a distinction.</font>
<font color="black"> 334.         &quot;&quot;&quot;</font>
<font color="red"> 335.         raise NotImplementedError</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def _flush(self):</font>
<font color="black"> 338.         &quot;&quot;&quot;Override in subclass to force sending of recent '_write()' calls</font>
<font color="black"> 339. </font>
<font color="black"> 340.         It's okay if this method is a no-op (i.e., if '_write()' actually</font>
<font color="black"> 341.         sends the data.</font>
<font color="black"> 342.         &quot;&quot;&quot;</font>
<font color="red"> 343.         raise NotImplementedError</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def get_stdin(self):</font>
<font color="black"> 346.         &quot;&quot;&quot;Override in subclass to return suitable 'wsgi.input'&quot;&quot;&quot;</font>
<font color="red"> 347.         raise NotImplementedError</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def get_stderr(self):</font>
<font color="black"> 350.         &quot;&quot;&quot;Override in subclass to return suitable 'wsgi.errors'&quot;&quot;&quot;</font>
<font color="red"> 351.         raise NotImplementedError</font>
<font color="black"> 352. </font>
<font color="green"> 353.     def add_cgi_vars(self):</font>
<font color="black"> 354.         &quot;&quot;&quot;Override in subclass to insert CGI variables in 'self.environ'&quot;&quot;&quot;</font>
<font color="red"> 355.         raise NotImplementedError</font>
<font color="black"> 356. </font>
<font color="black"> 357. </font>
<font color="green"> 358. class SimpleHandler(BaseHandler):</font>
<font color="black"> 359.     &quot;&quot;&quot;Handler that's just initialized with streams, environment, etc.</font>
<font color="black"> 360. </font>
<font color="black"> 361.     This handler subclass is intended for synchronous HTTP/1.0 origin servers,</font>
<font color="black"> 362.     and handles sending the entire response output, given the correct inputs.</font>
<font color="black"> 363. </font>
<font color="black"> 364.     Usage::</font>
<font color="black"> 365. </font>
<font color="black"> 366.         handler = SimpleHandler(</font>
<font color="black"> 367.             inp,out,err,env, multithread=False, multiprocess=True</font>
<font color="black"> 368.         )</font>
<font color="green"> 369.         handler.run(app)&quot;&quot;&quot;</font>
<font color="black"> 370. </font>
<font color="black"> 371.     def __init__(self,stdin,stdout,stderr,environ,</font>
<font color="green"> 372.         multithread=True, multiprocess=False</font>
<font color="black"> 373.     ):</font>
<font color="red"> 374.         self.stdin = stdin</font>
<font color="red"> 375.         self.stdout = stdout</font>
<font color="red"> 376.         self.stderr = stderr</font>
<font color="red"> 377.         self.base_env = environ</font>
<font color="red"> 378.         self.wsgi_multithread = multithread</font>
<font color="red"> 379.         self.wsgi_multiprocess = multiprocess</font>
<font color="black"> 380. </font>
<font color="green"> 381.     def get_stdin(self):</font>
<font color="red"> 382.         return self.stdin</font>
<font color="black"> 383. </font>
<font color="green"> 384.     def get_stderr(self):</font>
<font color="red"> 385.         return self.stderr</font>
<font color="black"> 386. </font>
<font color="green"> 387.     def add_cgi_vars(self):</font>
<font color="red"> 388.         self.environ.update(self.base_env)</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def _write(self,data):</font>
<font color="red"> 391.         self.stdout.write(data)</font>
<font color="red"> 392.         self._write = self.stdout.write</font>
<font color="black"> 393. </font>
<font color="green"> 394.     def _flush(self):</font>
<font color="red"> 395.         self.stdout.flush()</font>
<font color="red"> 396.         self._flush = self.stdout.flush</font>
<font color="black"> 397. </font>
<font color="black"> 398. </font>
<font color="green"> 399. class BaseCGIHandler(SimpleHandler):</font>
<font color="black"> 400. </font>
<font color="black"> 401.     &quot;&quot;&quot;CGI-like systems using input/output/error streams and environ mapping</font>
<font color="black"> 402. </font>
<font color="black"> 403.     Usage::</font>
<font color="black"> 404. </font>
<font color="black"> 405.         handler = BaseCGIHandler(inp,out,err,env)</font>
<font color="black"> 406.         handler.run(app)</font>
<font color="black"> 407. </font>
<font color="black"> 408.     This handler class is useful for gateway protocols like ReadyExec and</font>
<font color="black"> 409.     FastCGI, that have usable input/output/error streams and an environment</font>
<font color="black"> 410.     mapping.  It's also the base class for CGIHandler, which just uses</font>
<font color="black"> 411.     sys.stdin, os.environ, and so on.</font>
<font color="black"> 412. </font>
<font color="black"> 413.     The constructor also takes keyword arguments 'multithread' and</font>
<font color="black"> 414.     'multiprocess' (defaulting to 'True' and 'False' respectively) to control</font>
<font color="black"> 415.     the configuration sent to the application.  It sets 'origin_server' to</font>
<font color="black"> 416.     False (to enable CGI-like output), and assumes that 'wsgi.run_once' is</font>
<font color="black"> 417.     False.</font>
<font color="green"> 418.     &quot;&quot;&quot;</font>
<font color="black"> 419. </font>
<font color="green"> 420.     origin_server = False</font>
<font color="black"> 421. </font>
<font color="black"> 422. </font>
<font color="green"> 423. class CGIHandler(BaseCGIHandler):</font>
<font color="black"> 424. </font>
<font color="black"> 425.     &quot;&quot;&quot;CGI-based invocation via sys.stdin/stdout/stderr and os.environ</font>
<font color="black"> 426. </font>
<font color="black"> 427.     Usage::</font>
<font color="black"> 428. </font>
<font color="black"> 429.         CGIHandler().run(app)</font>
<font color="black"> 430. </font>
<font color="black"> 431.     The difference between this class and BaseCGIHandler is that it always</font>
<font color="black"> 432.     uses 'wsgi.run_once' of 'True', 'wsgi.multithread' of 'False', and</font>
<font color="black"> 433.     'wsgi.multiprocess' of 'True'.  It does not take any initialization</font>
<font color="black"> 434.     parameters, but always uses 'sys.stdin', 'os.environ', and friends.</font>
<font color="black"> 435. </font>
<font color="black"> 436.     If you need to override any of these parameters, use BaseCGIHandler</font>
<font color="black"> 437.     instead.</font>
<font color="green"> 438.     &quot;&quot;&quot;</font>
<font color="black"> 439. </font>
<font color="green"> 440.     wsgi_run_once = True</font>
<font color="black"> 441.     # Do not allow os.environ to leak between requests in Google App Engine</font>
<font color="black"> 442.     # and other multi-run CGI use cases.  This is not easily testable.</font>
<font color="black"> 443.     # See http://bugs.python.org/issue7250</font>
<font color="green"> 444.     os_environ = {}</font>
<font color="black"> 445. </font>
<font color="green"> 446.     def __init__(self):</font>
<font color="red"> 447.         BaseCGIHandler.__init__(</font>
<font color="red"> 448.             self, sys.stdin, sys.stdout, sys.stderr, dict(os.environ.items()),</font>
<font color="red"> 449.             multithread=False, multiprocess=True</font>
<font color="black"> 450.         )</font>
</pre>

