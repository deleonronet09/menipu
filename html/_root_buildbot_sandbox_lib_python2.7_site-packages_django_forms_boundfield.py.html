source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/forms/boundfield.py</b><br>


file stats: <b>127 lines, 32 executed: 25.2% covered</b>
<pre>
<font color="green">   1. from __future__ import unicode_literals</font>
<font color="black">   2. </font>
<font color="green">   3. import datetime</font>
<font color="black">   4. </font>
<font color="green">   5. from django.forms.utils import flatatt, pretty_name</font>
<font color="green">   6. from django.forms.widgets import Textarea, TextInput</font>
<font color="green">   7. from django.utils import six</font>
<font color="green">   8. from django.utils.encoding import (</font>
<font color="black">   9.     force_text, python_2_unicode_compatible, smart_text,</font>
<font color="black">  10. )</font>
<font color="green">  11. from django.utils.html import conditional_escape, format_html, html_safe</font>
<font color="green">  12. from django.utils.safestring import mark_safe</font>
<font color="green">  13. from django.utils.translation import ugettext_lazy as _</font>
<font color="black">  14. </font>
<font color="green">  15. __all__ = ('BoundField',)</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. UNSET = object()</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. @html_safe</font>
<font color="green">  22. @python_2_unicode_compatible</font>
<font color="green">  23. class BoundField(object):</font>
<font color="green">  24.     &quot;A Field plus data&quot;</font>
<font color="green">  25.     def __init__(self, form, field, name):</font>
<font color="red">  26.         self.form = form</font>
<font color="red">  27.         self.field = field</font>
<font color="red">  28.         self.name = name</font>
<font color="red">  29.         self.html_name = form.add_prefix(name)</font>
<font color="red">  30.         self.html_initial_name = form.add_initial_prefix(name)</font>
<font color="red">  31.         self.html_initial_id = form.add_initial_prefix(self.auto_id)</font>
<font color="red">  32.         if self.field.label is None:</font>
<font color="red">  33.             self.label = pretty_name(name)</font>
<font color="black">  34.         else:</font>
<font color="red">  35.             self.label = self.field.label</font>
<font color="red">  36.         self.help_text = field.help_text or ''</font>
<font color="red">  37.         self._initial_value = UNSET</font>
<font color="black">  38. </font>
<font color="green">  39.     def __str__(self):</font>
<font color="black">  40.         &quot;&quot;&quot;Renders this field as an HTML widget.&quot;&quot;&quot;</font>
<font color="red">  41.         if self.field.show_hidden_initial:</font>
<font color="red">  42.             return self.as_widget() + self.as_hidden(only_initial=True)</font>
<font color="red">  43.         return self.as_widget()</font>
<font color="black">  44. </font>
<font color="green">  45.     def __iter__(self):</font>
<font color="black">  46.         &quot;&quot;&quot;</font>
<font color="black">  47.         Yields rendered strings that comprise all widgets in this BoundField.</font>
<font color="black">  48. </font>
<font color="black">  49.         This really is only useful for RadioSelect widgets, so that you can</font>
<font color="black">  50.         iterate over individual radio buttons in a template.</font>
<font color="black">  51.         &quot;&quot;&quot;</font>
<font color="red">  52.         id_ = self.field.widget.attrs.get('id') or self.auto_id</font>
<font color="red">  53.         attrs = {'id': id_} if id_ else {}</font>
<font color="red">  54.         for subwidget in self.field.widget.subwidgets(self.html_name, self.value(), attrs):</font>
<font color="red">  55.             yield subwidget</font>
<font color="black">  56. </font>
<font color="green">  57.     def __len__(self):</font>
<font color="red">  58.         return len(list(self.__iter__()))</font>
<font color="black">  59. </font>
<font color="green">  60.     def __getitem__(self, idx):</font>
<font color="black">  61.         # Prevent unnecessary reevaluation when accessing BoundField's attrs</font>
<font color="black">  62.         # from templates.</font>
<font color="red">  63.         if not isinstance(idx, six.integer_types):</font>
<font color="red">  64.             raise TypeError</font>
<font color="red">  65.         return list(self.__iter__())[idx]</font>
<font color="black">  66. </font>
<font color="green">  67.     @property</font>
<font color="black">  68.     def errors(self):</font>
<font color="black">  69.         &quot;&quot;&quot;</font>
<font color="black">  70.         Returns an ErrorList for this field. Returns an empty ErrorList</font>
<font color="black">  71.         if there are none.</font>
<font color="black">  72.         &quot;&quot;&quot;</font>
<font color="red">  73.         return self.form.errors.get(self.name, self.form.error_class())</font>
<font color="black">  74. </font>
<font color="green">  75.     def as_widget(self, widget=None, attrs=None, only_initial=False):</font>
<font color="black">  76.         &quot;&quot;&quot;</font>
<font color="black">  77.         Renders the field by rendering the passed widget, adding any HTML</font>
<font color="black">  78.         attributes passed as attrs.  If no widget is specified, then the</font>
<font color="black">  79.         field's default widget will be used.</font>
<font color="black">  80.         &quot;&quot;&quot;</font>
<font color="red">  81.         if not widget:</font>
<font color="red">  82.             widget = self.field.widget</font>
<font color="black">  83. </font>
<font color="red">  84.         if self.field.localize:</font>
<font color="red">  85.             widget.is_localized = True</font>
<font color="black">  86. </font>
<font color="red">  87.         attrs = attrs or {}</font>
<font color="red">  88.         if self.field.disabled:</font>
<font color="red">  89.             attrs['disabled'] = True</font>
<font color="red">  90.         auto_id = self.auto_id</font>
<font color="red">  91.         if auto_id and 'id' not in attrs and 'id' not in widget.attrs:</font>
<font color="red">  92.             if not only_initial:</font>
<font color="red">  93.                 attrs['id'] = auto_id</font>
<font color="black">  94.             else:</font>
<font color="red">  95.                 attrs['id'] = self.html_initial_id</font>
<font color="black">  96. </font>
<font color="red">  97.         if not only_initial:</font>
<font color="red">  98.             name = self.html_name</font>
<font color="black">  99.         else:</font>
<font color="red"> 100.             name = self.html_initial_name</font>
<font color="red"> 101.         return force_text(widget.render(name, self.value(), attrs=attrs))</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def as_text(self, attrs=None, **kwargs):</font>
<font color="black"> 104.         &quot;&quot;&quot;</font>
<font color="black"> 105.         Returns a string of HTML for representing this as an &lt;input type=&quot;text&quot;&gt;.</font>
<font color="black"> 106.         &quot;&quot;&quot;</font>
<font color="red"> 107.         return self.as_widget(TextInput(), attrs, **kwargs)</font>
<font color="black"> 108. </font>
<font color="green"> 109.     def as_textarea(self, attrs=None, **kwargs):</font>
<font color="black"> 110.         &quot;Returns a string of HTML for representing this as a &lt;textarea&gt;.&quot;</font>
<font color="red"> 111.         return self.as_widget(Textarea(), attrs, **kwargs)</font>
<font color="black"> 112. </font>
<font color="green"> 113.     def as_hidden(self, attrs=None, **kwargs):</font>
<font color="black"> 114.         &quot;&quot;&quot;</font>
<font color="black"> 115.         Returns a string of HTML for representing this as an &lt;input type=&quot;hidden&quot;&gt;.</font>
<font color="black"> 116.         &quot;&quot;&quot;</font>
<font color="red"> 117.         return self.as_widget(self.field.hidden_widget(), attrs, **kwargs)</font>
<font color="black"> 118. </font>
<font color="green"> 119.     @property</font>
<font color="black"> 120.     def data(self):</font>
<font color="black"> 121.         &quot;&quot;&quot;</font>
<font color="black"> 122.         Returns the data for this BoundField, or None if it wasn't given.</font>
<font color="black"> 123.         &quot;&quot;&quot;</font>
<font color="red"> 124.         return self.field.widget.value_from_datadict(self.form.data, self.form.files, self.html_name)</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def value(self):</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         Returns the value for this BoundField, using the initial value if</font>
<font color="black"> 129.         the form is not bound or the data otherwise.</font>
<font color="black"> 130.         &quot;&quot;&quot;</font>
<font color="red"> 131.         if not self.form.is_bound:</font>
<font color="red"> 132.             data = self.form.initial.get(self.name, self.field.initial)</font>
<font color="red"> 133.             if callable(data):</font>
<font color="red"> 134.                 if self._initial_value is not UNSET:</font>
<font color="red"> 135.                     data = self._initial_value</font>
<font color="black"> 136.                 else:</font>
<font color="red"> 137.                     data = data()</font>
<font color="black"> 138.                     # If this is an auto-generated default date, nix the</font>
<font color="black"> 139.                     # microseconds for standardized handling. See #22502.</font>
<font color="red"> 140.                     if (isinstance(data, (datetime.datetime, datetime.time)) and</font>
<font color="red"> 141.                             not self.field.widget.supports_microseconds):</font>
<font color="red"> 142.                         data = data.replace(microsecond=0)</font>
<font color="red"> 143.                     self._initial_value = data</font>
<font color="black"> 144.         else:</font>
<font color="red"> 145.             data = self.field.bound_data(</font>
<font color="red"> 146.                 self.data, self.form.initial.get(self.name, self.field.initial)</font>
<font color="black"> 147.             )</font>
<font color="red"> 148.         return self.field.prepare_value(data)</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def label_tag(self, contents=None, attrs=None, label_suffix=None):</font>
<font color="black"> 151.         &quot;&quot;&quot;</font>
<font color="black"> 152.         Wraps the given contents in a &lt;label&gt;, if the field has an ID attribute.</font>
<font color="black"> 153.         contents should be 'mark_safe'd to avoid HTML escaping. If contents</font>
<font color="black"> 154.         aren't given, uses the field's HTML-escaped label.</font>
<font color="black"> 155. </font>
<font color="black"> 156.         If attrs are given, they're used as HTML attributes on the &lt;label&gt; tag.</font>
<font color="black"> 157. </font>
<font color="black"> 158.         label_suffix allows overriding the form's label_suffix.</font>
<font color="black"> 159.         &quot;&quot;&quot;</font>
<font color="red"> 160.         contents = contents or self.label</font>
<font color="red"> 161.         if label_suffix is None:</font>
<font color="red"> 162.             label_suffix = (self.field.label_suffix if self.field.label_suffix is not None</font>
<font color="red"> 163.                             else self.form.label_suffix)</font>
<font color="black"> 164.         # Only add the suffix if the label does not end in punctuation.</font>
<font color="black"> 165.         # Translators: If found as last label character, these punctuation</font>
<font color="black"> 166.         # characters will prevent the default label_suffix to be appended to the label</font>
<font color="red"> 167.         if label_suffix and contents and contents[-1] not in _(':?.!'):</font>
<font color="red"> 168.             contents = format_html('{}{}', contents, label_suffix)</font>
<font color="red"> 169.         widget = self.field.widget</font>
<font color="red"> 170.         id_ = widget.attrs.get('id') or self.auto_id</font>
<font color="red"> 171.         if id_:</font>
<font color="red"> 172.             id_for_label = widget.id_for_label(id_)</font>
<font color="red"> 173.             if id_for_label:</font>
<font color="red"> 174.                 attrs = dict(attrs or {}, **{'for': id_for_label})</font>
<font color="red"> 175.             if self.field.required and hasattr(self.form, 'required_css_class'):</font>
<font color="red"> 176.                 attrs = attrs or {}</font>
<font color="red"> 177.                 if 'class' in attrs:</font>
<font color="red"> 178.                     attrs['class'] += ' ' + self.form.required_css_class</font>
<font color="black"> 179.                 else:</font>
<font color="red"> 180.                     attrs['class'] = self.form.required_css_class</font>
<font color="red"> 181.             attrs = flatatt(attrs) if attrs else ''</font>
<font color="red"> 182.             contents = format_html('&lt;label{}&gt;{}&lt;/label&gt;', attrs, contents)</font>
<font color="black"> 183.         else:</font>
<font color="red"> 184.             contents = conditional_escape(contents)</font>
<font color="red"> 185.         return mark_safe(contents)</font>
<font color="black"> 186. </font>
<font color="green"> 187.     def css_classes(self, extra_classes=None):</font>
<font color="black"> 188.         &quot;&quot;&quot;</font>
<font color="black"> 189.         Returns a string of space-separated CSS classes for this field.</font>
<font color="black"> 190.         &quot;&quot;&quot;</font>
<font color="red"> 191.         if hasattr(extra_classes, 'split'):</font>
<font color="red"> 192.             extra_classes = extra_classes.split()</font>
<font color="red"> 193.         extra_classes = set(extra_classes or [])</font>
<font color="red"> 194.         if self.errors and hasattr(self.form, 'error_css_class'):</font>
<font color="red"> 195.             extra_classes.add(self.form.error_css_class)</font>
<font color="red"> 196.         if self.field.required and hasattr(self.form, 'required_css_class'):</font>
<font color="red"> 197.             extra_classes.add(self.form.required_css_class)</font>
<font color="red"> 198.         return ' '.join(extra_classes)</font>
<font color="black"> 199. </font>
<font color="green"> 200.     @property</font>
<font color="black"> 201.     def is_hidden(self):</font>
<font color="black"> 202.         &quot;Returns True if this BoundField's widget is hidden.&quot;</font>
<font color="red"> 203.         return self.field.widget.is_hidden</font>
<font color="black"> 204. </font>
<font color="green"> 205.     @property</font>
<font color="black"> 206.     def auto_id(self):</font>
<font color="black"> 207.         &quot;&quot;&quot;</font>
<font color="black"> 208.         Calculates and returns the ID attribute for this BoundField, if the</font>
<font color="black"> 209.         associated Form has specified auto_id. Returns an empty string otherwise.</font>
<font color="black"> 210.         &quot;&quot;&quot;</font>
<font color="red"> 211.         auto_id = self.form.auto_id</font>
<font color="red"> 212.         if auto_id and '%s' in smart_text(auto_id):</font>
<font color="red"> 213.             return smart_text(auto_id) % self.html_name</font>
<font color="red"> 214.         elif auto_id:</font>
<font color="red"> 215.             return self.html_name</font>
<font color="red"> 216.         return ''</font>
<font color="black"> 217. </font>
<font color="green"> 218.     @property</font>
<font color="black"> 219.     def id_for_label(self):</font>
<font color="black"> 220.         &quot;&quot;&quot;</font>
<font color="black"> 221.         Wrapper around the field widget's `id_for_label` method.</font>
<font color="black"> 222.         Useful, for example, for focusing on this field regardless of whether</font>
<font color="black"> 223.         it has a single widget or a MultiWidget.</font>
<font color="black"> 224.         &quot;&quot;&quot;</font>
<font color="red"> 225.         widget = self.field.widget</font>
<font color="red"> 226.         id_ = widget.attrs.get('id') or self.auto_id</font>
<font color="red"> 227.         return widget.id_for_label(id_)</font>
</pre>

