source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/utils/functional.py</b><br>


file stats: <b>212 lines, 131 executed: 61.8% covered</b>
<pre>
<font color="green">   1. import copy</font>
<font color="green">   2. import operator</font>
<font color="green">   3. from functools import total_ordering, wraps</font>
<font color="black">   4. </font>
<font color="green">   5. from django.utils import six</font>
<font color="black">   6. </font>
<font color="black">   7. </font>
<font color="black">   8. # You can't trivially replace this with `functools.partial` because this binds</font>
<font color="black">   9. # to classes and returns bound instances, whereas functools.partial (on</font>
<font color="black">  10. # CPython) is a type and its instances don't bind.</font>
<font color="green">  11. def curry(_curried_func, *args, **kwargs):</font>
<font color="green">  12.     def _curried(*moreargs, **morekwargs):</font>
<font color="red">  13.         return _curried_func(*(args + moreargs), **dict(kwargs, **morekwargs))</font>
<font color="green">  14.     return _curried</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. class cached_property(object):</font>
<font color="black">  18.     &quot;&quot;&quot;</font>
<font color="black">  19.     Decorator that converts a method with a single self argument into a</font>
<font color="black">  20.     property cached on the instance.</font>
<font color="black">  21. </font>
<font color="black">  22.     Optional ``name`` argument allows you to make cached properties of other</font>
<font color="black">  23.     methods. (e.g.  url = cached_property(get_absolute_url, name='url') )</font>
<font color="green">  24.     &quot;&quot;&quot;</font>
<font color="green">  25.     def __init__(self, func, name=None):</font>
<font color="green">  26.         self.func = func</font>
<font color="green">  27.         self.__doc__ = getattr(func, '__doc__')</font>
<font color="green">  28.         self.name = name or func.__name__</font>
<font color="black">  29. </font>
<font color="green">  30.     def __get__(self, instance, type=None):</font>
<font color="green">  31.         if instance is None:</font>
<font color="red">  32.             return self</font>
<font color="green">  33.         res = instance.__dict__[self.name] = self.func(instance)</font>
<font color="green">  34.         return res</font>
<font color="black">  35. </font>
<font color="black">  36. </font>
<font color="green">  37. class Promise(object):</font>
<font color="black">  38.     &quot;&quot;&quot;</font>
<font color="black">  39.     This is just a base class for the proxy class created in</font>
<font color="black">  40.     the closure of the lazy function. It can be used to recognize</font>
<font color="black">  41.     promises in code.</font>
<font color="green">  42.     &quot;&quot;&quot;</font>
<font color="green">  43.     pass</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. def lazy(func, *resultclasses):</font>
<font color="black">  47.     &quot;&quot;&quot;</font>
<font color="black">  48.     Turns any callable into a lazy evaluated callable. You need to give result</font>
<font color="black">  49.     classes or types -- at least one is needed so that the automatic forcing of</font>
<font color="black">  50.     the lazy evaluation code is triggered. Results are not memoized; the</font>
<font color="black">  51.     function is evaluated on every access.</font>
<font color="black">  52.     &quot;&quot;&quot;</font>
<font color="black">  53. </font>
<font color="green">  54.     @total_ordering</font>
<font color="green">  55.     class __proxy__(Promise):</font>
<font color="black">  56.         &quot;&quot;&quot;</font>
<font color="black">  57.         Encapsulate a function call and act as a proxy for methods that are</font>
<font color="black">  58.         called on the result of that function. The function is not evaluated</font>
<font color="black">  59.         until one of the methods on the result is called.</font>
<font color="green">  60.         &quot;&quot;&quot;</font>
<font color="green">  61.         __prepared = False</font>
<font color="black">  62. </font>
<font color="green">  63.         def __init__(self, args, kw):</font>
<font color="green">  64.             self.__args = args</font>
<font color="green">  65.             self.__kw = kw</font>
<font color="green">  66.             if not self.__prepared:</font>
<font color="green">  67.                 self.__prepare_class__()</font>
<font color="green">  68.             self.__prepared = True</font>
<font color="black">  69. </font>
<font color="green">  70.         def __reduce__(self):</font>
<font color="black">  71.             return (</font>
<font color="red">  72.                 _lazy_proxy_unpickle,</font>
<font color="red">  73.                 (func, self.__args, self.__kw) + resultclasses</font>
<font color="black">  74.             )</font>
<font color="black">  75. </font>
<font color="green">  76.         @classmethod</font>
<font color="black">  77.         def __prepare_class__(cls):</font>
<font color="green">  78.             for resultclass in resultclasses:</font>
<font color="green">  79.                 for type_ in resultclass.mro():</font>
<font color="green">  80.                     for method_name in type_.__dict__.keys():</font>
<font color="black">  81.                         # All __promise__ return the same wrapper method, they</font>
<font color="black">  82.                         # look up the correct implementation when called.</font>
<font color="green">  83.                         if hasattr(cls, method_name):</font>
<font color="green">  84.                             continue</font>
<font color="green">  85.                         meth = cls.__promise__(method_name)</font>
<font color="green">  86.                         setattr(cls, method_name, meth)</font>
<font color="green">  87.             cls._delegate_bytes = bytes in resultclasses</font>
<font color="green">  88.             cls._delegate_text = six.text_type in resultclasses</font>
<font color="green">  89.             assert not (cls._delegate_bytes and cls._delegate_text), (</font>
<font color="red">  90.                 &quot;Cannot call lazy() with both bytes and text return types.&quot;)</font>
<font color="green">  91.             if cls._delegate_text:</font>
<font color="green">  92.                 if six.PY3:</font>
<font color="red">  93.                     cls.__str__ = cls.__text_cast</font>
<font color="black">  94.                 else:</font>
<font color="green">  95.                     cls.__unicode__ = cls.__text_cast</font>
<font color="green">  96.                     cls.__str__ = cls.__bytes_cast_encoded</font>
<font color="green">  97.             elif cls._delegate_bytes:</font>
<font color="red">  98.                 if six.PY3:</font>
<font color="red">  99.                     cls.__bytes__ = cls.__bytes_cast</font>
<font color="black"> 100.                 else:</font>
<font color="red"> 101.                     cls.__str__ = cls.__bytes_cast</font>
<font color="black"> 102. </font>
<font color="green"> 103.         @classmethod</font>
<font color="black"> 104.         def __promise__(cls, method_name):</font>
<font color="black"> 105.             # Builds a wrapper around some magic method</font>
<font color="green"> 106.             def __wrapper__(self, *args, **kw):</font>
<font color="black"> 107.                 # Automatically triggers the evaluation of a lazy value and</font>
<font color="black"> 108.                 # applies the given magic method of the result type.</font>
<font color="green"> 109.                 res = func(*self.__args, **self.__kw)</font>
<font color="green"> 110.                 return getattr(res, method_name)(*args, **kw)</font>
<font color="green"> 111.             return __wrapper__</font>
<font color="black"> 112. </font>
<font color="green"> 113.         def __text_cast(self):</font>
<font color="green"> 114.             return func(*self.__args, **self.__kw)</font>
<font color="black"> 115. </font>
<font color="green"> 116.         def __bytes_cast(self):</font>
<font color="red"> 117.             return bytes(func(*self.__args, **self.__kw))</font>
<font color="black"> 118. </font>
<font color="green"> 119.         def __bytes_cast_encoded(self):</font>
<font color="red"> 120.             return func(*self.__args, **self.__kw).encode('utf-8')</font>
<font color="black"> 121. </font>
<font color="green"> 122.         def __cast(self):</font>
<font color="red"> 123.             if self._delegate_bytes:</font>
<font color="red"> 124.                 return self.__bytes_cast()</font>
<font color="red"> 125.             elif self._delegate_text:</font>
<font color="red"> 126.                 return self.__text_cast()</font>
<font color="black"> 127.             else:</font>
<font color="red"> 128.                 return func(*self.__args, **self.__kw)</font>
<font color="black"> 129. </font>
<font color="green"> 130.         def __str__(self):</font>
<font color="black"> 131.             # object defines __str__(), so __prepare_class__() won't overload</font>
<font color="black"> 132.             # a __str__() method from the proxied class.</font>
<font color="red"> 133.             return str(self.__cast())</font>
<font color="black"> 134. </font>
<font color="green"> 135.         def __ne__(self, other):</font>
<font color="red"> 136.             if isinstance(other, Promise):</font>
<font color="red"> 137.                 other = other.__cast()</font>
<font color="red"> 138.             return self.__cast() != other</font>
<font color="black"> 139. </font>
<font color="green"> 140.         def __eq__(self, other):</font>
<font color="red"> 141.             if isinstance(other, Promise):</font>
<font color="red"> 142.                 other = other.__cast()</font>
<font color="red"> 143.             return self.__cast() == other</font>
<font color="black"> 144. </font>
<font color="green"> 145.         def __lt__(self, other):</font>
<font color="red"> 146.             if isinstance(other, Promise):</font>
<font color="red"> 147.                 other = other.__cast()</font>
<font color="red"> 148.             return self.__cast() &lt; other</font>
<font color="black"> 149. </font>
<font color="green"> 150.         def __hash__(self):</font>
<font color="red"> 151.             return hash(self.__cast())</font>
<font color="black"> 152. </font>
<font color="green"> 153.         def __mod__(self, rhs):</font>
<font color="red"> 154.             if self._delegate_bytes and six.PY2:</font>
<font color="red"> 155.                 return bytes(self) % rhs</font>
<font color="red"> 156.             elif self._delegate_text:</font>
<font color="red"> 157.                 return six.text_type(self) % rhs</font>
<font color="red"> 158.             return self.__cast() % rhs</font>
<font color="black"> 159. </font>
<font color="green"> 160.         def __deepcopy__(self, memo):</font>
<font color="black"> 161.             # Instances of this class are effectively immutable. It's just a</font>
<font color="black"> 162.             # collection of functions. So we don't need to do anything</font>
<font color="black"> 163.             # complicated for copying.</font>
<font color="red"> 164.             memo[id(self)] = self</font>
<font color="red"> 165.             return self</font>
<font color="black"> 166. </font>
<font color="green"> 167.     @wraps(func)</font>
<font color="black"> 168.     def __wrapper__(*args, **kw):</font>
<font color="black"> 169.         # Creates the proxy object, instead of the actual value.</font>
<font color="green"> 170.         return __proxy__(args, kw)</font>
<font color="black"> 171. </font>
<font color="green"> 172.     return __wrapper__</font>
<font color="black"> 173. </font>
<font color="black"> 174. </font>
<font color="green"> 175. def _lazy_proxy_unpickle(func, args, kwargs, *resultclasses):</font>
<font color="red"> 176.     return lazy(func, *resultclasses)(*args, **kwargs)</font>
<font color="black"> 177. </font>
<font color="black"> 178. </font>
<font color="green"> 179. def allow_lazy(func, *resultclasses):</font>
<font color="black"> 180.     &quot;&quot;&quot;</font>
<font color="black"> 181.     A decorator that allows a function to be called with one or more lazy</font>
<font color="black"> 182.     arguments. If none of the args are lazy, the function is evaluated</font>
<font color="black"> 183.     immediately, otherwise a __proxy__ is returned that will evaluate the</font>
<font color="black"> 184.     function when needed.</font>
<font color="black"> 185.     &quot;&quot;&quot;</font>
<font color="green"> 186.     lazy_func = lazy(func, *resultclasses)</font>
<font color="black"> 187. </font>
<font color="green"> 188.     @wraps(func)</font>
<font color="black"> 189.     def wrapper(*args, **kwargs):</font>
<font color="green"> 190.         for arg in list(args) + list(kwargs.values()):</font>
<font color="green"> 191.             if isinstance(arg, Promise):</font>
<font color="green"> 192.                 break</font>
<font color="black"> 193.         else:</font>
<font color="green"> 194.             return func(*args, **kwargs)</font>
<font color="green"> 195.         return lazy_func(*args, **kwargs)</font>
<font color="green"> 196.     return wrapper</font>
<font color="black"> 197. </font>
<font color="green"> 198. empty = object()</font>
<font color="black"> 199. </font>
<font color="black"> 200. </font>
<font color="green"> 201. def new_method_proxy(func):</font>
<font color="green"> 202.     def inner(self, *args):</font>
<font color="red"> 203.         if self._wrapped is empty:</font>
<font color="red"> 204.             self._setup()</font>
<font color="red"> 205.         return func(self._wrapped, *args)</font>
<font color="green"> 206.     return inner</font>
<font color="black"> 207. </font>
<font color="black"> 208. </font>
<font color="green"> 209. class LazyObject(object):</font>
<font color="black"> 210.     &quot;&quot;&quot;</font>
<font color="black"> 211.     A wrapper for another class that can be used to delay instantiation of the</font>
<font color="black"> 212.     wrapped class.</font>
<font color="black"> 213. </font>
<font color="black"> 214.     By subclassing, you have the opportunity to intercept and alter the</font>
<font color="black"> 215.     instantiation. If you don't need to do that, use SimpleLazyObject.</font>
<font color="green"> 216.     &quot;&quot;&quot;</font>
<font color="black"> 217. </font>
<font color="black"> 218.     # Avoid infinite recursion when tracing __init__ (#19456).</font>
<font color="green"> 219.     _wrapped = None</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def __init__(self):</font>
<font color="green"> 222.         self._wrapped = empty</font>
<font color="black"> 223. </font>
<font color="green"> 224.     __getattr__ = new_method_proxy(getattr)</font>
<font color="black"> 225. </font>
<font color="green"> 226.     def __setattr__(self, name, value):</font>
<font color="green"> 227.         if name == &quot;_wrapped&quot;:</font>
<font color="black"> 228.             # Assign to __dict__ to avoid infinite __setattr__ loops.</font>
<font color="green"> 229.             self.__dict__[&quot;_wrapped&quot;] = value</font>
<font color="black"> 230.         else:</font>
<font color="green"> 231.             if self._wrapped is empty:</font>
<font color="red"> 232.                 self._setup()</font>
<font color="green"> 233.             setattr(self._wrapped, name, value)</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def __delattr__(self, name):</font>
<font color="red"> 236.         if name == &quot;_wrapped&quot;:</font>
<font color="red"> 237.             raise TypeError(&quot;can't delete _wrapped.&quot;)</font>
<font color="red"> 238.         if self._wrapped is empty:</font>
<font color="red"> 239.             self._setup()</font>
<font color="red"> 240.         delattr(self._wrapped, name)</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def _setup(self):</font>
<font color="black"> 243.         &quot;&quot;&quot;</font>
<font color="black"> 244.         Must be implemented by subclasses to initialize the wrapped object.</font>
<font color="black"> 245.         &quot;&quot;&quot;</font>
<font color="red"> 246.         raise NotImplementedError('subclasses of LazyObject must provide a _setup() method')</font>
<font color="black"> 247. </font>
<font color="black"> 248.     # Because we have messed with __class__ below, we confuse pickle as to what</font>
<font color="black"> 249.     # class we are pickling. We're going to have to initialize the wrapped</font>
<font color="black"> 250.     # object to successfully pickle it, so we might as well just pickle the</font>
<font color="black"> 251.     # wrapped object since they're supposed to act the same way.</font>
<font color="black"> 252.     #</font>
<font color="black"> 253.     # Unfortunately, if we try to simply act like the wrapped object, the ruse</font>
<font color="black"> 254.     # will break down when pickle gets our id(). Thus we end up with pickle</font>
<font color="black"> 255.     # thinking, in effect, that we are a distinct object from the wrapped</font>
<font color="black"> 256.     # object, but with the same __dict__. This can cause problems (see #25389).</font>
<font color="black"> 257.     #</font>
<font color="black"> 258.     # So instead, we define our own __reduce__ method and custom unpickler. We</font>
<font color="black"> 259.     # pickle the wrapped object as the unpickler's argument, so that pickle</font>
<font color="black"> 260.     # will pickle it normally, and then the unpickler simply returns its</font>
<font color="black"> 261.     # argument.</font>
<font color="green"> 262.     def __reduce__(self):</font>
<font color="red"> 263.         if self._wrapped is empty:</font>
<font color="red"> 264.             self._setup()</font>
<font color="red"> 265.         return (unpickle_lazyobject, (self._wrapped,))</font>
<font color="black"> 266. </font>
<font color="black"> 267.     # We have to explicitly override __getstate__ so that older versions of</font>
<font color="black"> 268.     # pickle don't try to pickle the __dict__ (which in the case of a</font>
<font color="black"> 269.     # SimpleLazyObject may contain a lambda). The value will end up being</font>
<font color="black"> 270.     # ignored by our __reduce__ and custom unpickler.</font>
<font color="green"> 271.     def __getstate__(self):</font>
<font color="red"> 272.         return {}</font>
<font color="black"> 273. </font>
<font color="green"> 274.     def __deepcopy__(self, memo):</font>
<font color="red"> 275.         if self._wrapped is empty:</font>
<font color="black"> 276.             # We have to use type(self), not self.__class__, because the</font>
<font color="black"> 277.             # latter is proxied.</font>
<font color="red"> 278.             result = type(self)()</font>
<font color="red"> 279.             memo[id(self)] = result</font>
<font color="red"> 280.             return result</font>
<font color="red"> 281.         return copy.deepcopy(self._wrapped, memo)</font>
<font color="black"> 282. </font>
<font color="green"> 283.     if six.PY3:</font>
<font color="red"> 284.         __bytes__ = new_method_proxy(bytes)</font>
<font color="red"> 285.         __str__ = new_method_proxy(str)</font>
<font color="red"> 286.         __bool__ = new_method_proxy(bool)</font>
<font color="black"> 287.     else:</font>
<font color="green"> 288.         __str__ = new_method_proxy(str)</font>
<font color="green"> 289.         __unicode__ = new_method_proxy(unicode)  # NOQA: unicode undefined on PY3</font>
<font color="green"> 290.         __nonzero__ = new_method_proxy(bool)</font>
<font color="black"> 291. </font>
<font color="black"> 292.     # Introspection support</font>
<font color="green"> 293.     __dir__ = new_method_proxy(dir)</font>
<font color="black"> 294. </font>
<font color="black"> 295.     # Need to pretend to be the wrapped class, for the sake of objects that</font>
<font color="black"> 296.     # care about this (especially in equality tests)</font>
<font color="green"> 297.     __class__ = property(new_method_proxy(operator.attrgetter(&quot;__class__&quot;)))</font>
<font color="green"> 298.     __eq__ = new_method_proxy(operator.eq)</font>
<font color="green"> 299.     __ne__ = new_method_proxy(operator.ne)</font>
<font color="green"> 300.     __hash__ = new_method_proxy(hash)</font>
<font color="black"> 301. </font>
<font color="black"> 302.     # List/Tuple/Dictionary methods support</font>
<font color="green"> 303.     __getitem__ = new_method_proxy(operator.getitem)</font>
<font color="green"> 304.     __setitem__ = new_method_proxy(operator.setitem)</font>
<font color="green"> 305.     __delitem__ = new_method_proxy(operator.delitem)</font>
<font color="green"> 306.     __iter__ = new_method_proxy(iter)</font>
<font color="green"> 307.     __len__ = new_method_proxy(len)</font>
<font color="green"> 308.     __contains__ = new_method_proxy(operator.contains)</font>
<font color="black"> 309. </font>
<font color="black"> 310. </font>
<font color="green"> 311. def unpickle_lazyobject(wrapped):</font>
<font color="black"> 312.     &quot;&quot;&quot;</font>
<font color="black"> 313.     Used to unpickle lazy objects. Just return its argument, which will be the</font>
<font color="black"> 314.     wrapped object.</font>
<font color="black"> 315.     &quot;&quot;&quot;</font>
<font color="red"> 316.     return wrapped</font>
<font color="green"> 317. unpickle_lazyobject.__safe_for_unpickling__ = True</font>
<font color="black"> 318. </font>
<font color="black"> 319. </font>
<font color="green"> 320. class SimpleLazyObject(LazyObject):</font>
<font color="black"> 321.     &quot;&quot;&quot;</font>
<font color="black"> 322.     A lazy object initialized from any function.</font>
<font color="black"> 323. </font>
<font color="black"> 324.     Designed for compound objects of unknown type. For builtins or objects of</font>
<font color="black"> 325.     known type, use django.utils.functional.lazy.</font>
<font color="green"> 326.     &quot;&quot;&quot;</font>
<font color="green"> 327.     def __init__(self, func):</font>
<font color="black"> 328.         &quot;&quot;&quot;</font>
<font color="black"> 329.         Pass in a callable that returns the object to be wrapped.</font>
<font color="black"> 330. </font>
<font color="black"> 331.         If copies are made of the resulting SimpleLazyObject, which can happen</font>
<font color="black"> 332.         in various circumstances within Django, then you must ensure that the</font>
<font color="black"> 333.         callable can be safely run more than once and will return the same</font>
<font color="black"> 334.         value.</font>
<font color="black"> 335.         &quot;&quot;&quot;</font>
<font color="green"> 336.         self.__dict__['_setupfunc'] = func</font>
<font color="green"> 337.         super(SimpleLazyObject, self).__init__()</font>
<font color="black"> 338. </font>
<font color="green"> 339.     def _setup(self):</font>
<font color="red"> 340.         self._wrapped = self._setupfunc()</font>
<font color="black"> 341. </font>
<font color="black"> 342.     # Return a meaningful representation of the lazy object for debugging</font>
<font color="black"> 343.     # without evaluating the wrapped object.</font>
<font color="green"> 344.     def __repr__(self):</font>
<font color="red"> 345.         if self._wrapped is empty:</font>
<font color="red"> 346.             repr_attr = self._setupfunc</font>
<font color="black"> 347.         else:</font>
<font color="red"> 348.             repr_attr = self._wrapped</font>
<font color="red"> 349.         return '&lt;%s: %r&gt;' % (type(self).__name__, repr_attr)</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def __deepcopy__(self, memo):</font>
<font color="red"> 352.         if self._wrapped is empty:</font>
<font color="black"> 353.             # We have to use SimpleLazyObject, not self.__class__, because the</font>
<font color="black"> 354.             # latter is proxied.</font>
<font color="red"> 355.             result = SimpleLazyObject(self._setupfunc)</font>
<font color="red"> 356.             memo[id(self)] = result</font>
<font color="red"> 357.             return result</font>
<font color="red"> 358.         return copy.deepcopy(self._wrapped, memo)</font>
<font color="black"> 359. </font>
<font color="black"> 360. </font>
<font color="green"> 361. class lazy_property(property):</font>
<font color="black"> 362.     &quot;&quot;&quot;</font>
<font color="black"> 363.     A property that works with subclasses by wrapping the decorated</font>
<font color="black"> 364.     functions of the base class.</font>
<font color="green"> 365.     &quot;&quot;&quot;</font>
<font color="green"> 366.     def __new__(cls, fget=None, fset=None, fdel=None, doc=None):</font>
<font color="red"> 367.         if fget is not None:</font>
<font color="red"> 368.             @wraps(fget)</font>
<font color="red"> 369.             def fget(instance, instance_type=None, name=fget.__name__):</font>
<font color="red"> 370.                 return getattr(instance, name)()</font>
<font color="red"> 371.         if fset is not None:</font>
<font color="red"> 372.             @wraps(fset)</font>
<font color="red"> 373.             def fset(instance, value, name=fset.__name__):</font>
<font color="red"> 374.                 return getattr(instance, name)(value)</font>
<font color="red"> 375.         if fdel is not None:</font>
<font color="red"> 376.             @wraps(fdel)</font>
<font color="red"> 377.             def fdel(instance, name=fdel.__name__):</font>
<font color="red"> 378.                 return getattr(instance, name)()</font>
<font color="red"> 379.         return property(fget, fset, fdel, doc)</font>
<font color="black"> 380. </font>
<font color="black"> 381. </font>
<font color="green"> 382. def partition(predicate, values):</font>
<font color="black"> 383.     &quot;&quot;&quot;</font>
<font color="black"> 384.     Splits the values into two sets, based on the return value of the function</font>
<font color="black"> 385.     (True/False). e.g.:</font>
<font color="black"> 386. </font>
<font color="black"> 387.         &gt;&gt;&gt; partition(lambda x: x &gt; 3, range(5))</font>
<font color="black"> 388.         [0, 1, 2, 3], [4]</font>
<font color="black"> 389.     &quot;&quot;&quot;</font>
<font color="green"> 390.     results = ([], [])</font>
<font color="green"> 391.     for item in values:</font>
<font color="green"> 392.         results[predicate(item)].append(item)</font>
<font color="green"> 393.     return results</font>
</pre>

