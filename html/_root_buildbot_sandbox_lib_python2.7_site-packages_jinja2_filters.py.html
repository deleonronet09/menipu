source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/jinja2/filters.py</b><br>


file stats: <b>407 lines, 130 executed: 31.9% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3.     jinja2.filters</font>
<font color="black">   4.     ~~~~~~~~~~~~~~</font>
<font color="black">   5. </font>
<font color="black">   6.     Bundled jinja filters.</font>
<font color="black">   7. </font>
<font color="black">   8.     :copyright: (c) 2010 by the Jinja Team.</font>
<font color="black">   9.     :license: BSD, see LICENSE for more details.</font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. import re</font>
<font color="green">  12. import math</font>
<font color="black">  13. </font>
<font color="green">  14. from random import choice</font>
<font color="green">  15. from operator import itemgetter</font>
<font color="green">  16. from itertools import groupby</font>
<font color="green">  17. from jinja2.utils import Markup, escape, pformat, urlize, soft_unicode, \</font>
<font color="black">  18.      unicode_urlencode</font>
<font color="green">  19. from jinja2.runtime import Undefined</font>
<font color="green">  20. from jinja2.exceptions import FilterArgumentError</font>
<font color="green">  21. from jinja2._compat import imap, string_types, text_type, iteritems</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="green">  24. _word_re = re.compile(r'\w+(?u)')</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. def contextfilter(f):</font>
<font color="black">  28.     &quot;&quot;&quot;Decorator for marking context dependent filters. The current</font>
<font color="black">  29.     :class:`Context` will be passed as first argument.</font>
<font color="black">  30.     &quot;&quot;&quot;</font>
<font color="green">  31.     f.contextfilter = True</font>
<font color="green">  32.     return f</font>
<font color="black">  33. </font>
<font color="black">  34. </font>
<font color="green">  35. def evalcontextfilter(f):</font>
<font color="black">  36.     &quot;&quot;&quot;Decorator for marking eval-context dependent filters.  An eval</font>
<font color="black">  37.     context object is passed as first argument.  For more information</font>
<font color="black">  38.     about the eval context, see :ref:`eval-context`.</font>
<font color="black">  39. </font>
<font color="black">  40.     .. versionadded:: 2.4</font>
<font color="black">  41.     &quot;&quot;&quot;</font>
<font color="green">  42.     f.evalcontextfilter = True</font>
<font color="green">  43.     return f</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. def environmentfilter(f):</font>
<font color="black">  47.     &quot;&quot;&quot;Decorator for marking evironment dependent filters.  The current</font>
<font color="black">  48.     :class:`Environment` is passed to the filter as first argument.</font>
<font color="black">  49.     &quot;&quot;&quot;</font>
<font color="green">  50.     f.environmentfilter = True</font>
<font color="green">  51.     return f</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. def make_attrgetter(environment, attribute):</font>
<font color="black">  55.     &quot;&quot;&quot;Returns a callable that looks up the given attribute from a</font>
<font color="black">  56.     passed object with the rules of the environment.  Dots are allowed</font>
<font color="black">  57.     to access attributes of attributes.  Integer parts in paths are</font>
<font color="black">  58.     looked up as integers.</font>
<font color="black">  59.     &quot;&quot;&quot;</font>
<font color="red">  60.     if not isinstance(attribute, string_types) \</font>
<font color="red">  61.        or ('.' not in attribute and not attribute.isdigit()):</font>
<font color="red">  62.         return lambda x: environment.getitem(x, attribute)</font>
<font color="red">  63.     attribute = attribute.split('.')</font>
<font color="red">  64.     def attrgetter(item):</font>
<font color="red">  65.         for part in attribute:</font>
<font color="red">  66.             if part.isdigit():</font>
<font color="red">  67.                 part = int(part)</font>
<font color="red">  68.             item = environment.getitem(item, part)</font>
<font color="red">  69.         return item</font>
<font color="red">  70.     return attrgetter</font>
<font color="black">  71. </font>
<font color="black">  72. </font>
<font color="green">  73. def do_forceescape(value):</font>
<font color="black">  74.     &quot;&quot;&quot;Enforce HTML escaping.  This will probably double escape variables.&quot;&quot;&quot;</font>
<font color="red">  75.     if hasattr(value, '__html__'):</font>
<font color="red">  76.         value = value.__html__()</font>
<font color="red">  77.     return escape(text_type(value))</font>
<font color="black">  78. </font>
<font color="black">  79. </font>
<font color="green">  80. def do_urlencode(value):</font>
<font color="black">  81.     &quot;&quot;&quot;Escape strings for use in URLs (uses UTF-8 encoding).  It accepts both</font>
<font color="black">  82.     dictionaries and regular strings as well as pairwise iterables.</font>
<font color="black">  83. </font>
<font color="black">  84.     .. versionadded:: 2.7</font>
<font color="black">  85.     &quot;&quot;&quot;</font>
<font color="red">  86.     itemiter = None</font>
<font color="red">  87.     if isinstance(value, dict):</font>
<font color="red">  88.         itemiter = iteritems(value)</font>
<font color="red">  89.     elif not isinstance(value, string_types):</font>
<font color="red">  90.         try:</font>
<font color="red">  91.             itemiter = iter(value)</font>
<font color="red">  92.         except TypeError:</font>
<font color="red">  93.             pass</font>
<font color="red">  94.     if itemiter is None:</font>
<font color="red">  95.         return unicode_urlencode(value)</font>
<font color="red">  96.     return u'&amp;'.join(unicode_urlencode(k) + '=' +</font>
<font color="black">  97.                      unicode_urlencode(v, for_qs=True)</font>
<font color="red">  98.                      for k, v in itemiter)</font>
<font color="black">  99. </font>
<font color="black"> 100. </font>
<font color="green"> 101. @evalcontextfilter</font>
<font color="green"> 102. def do_replace(eval_ctx, s, old, new, count=None):</font>
<font color="black"> 103.     &quot;&quot;&quot;Return a copy of the value with all occurrences of a substring</font>
<font color="black"> 104.     replaced with a new one. The first argument is the substring</font>
<font color="black"> 105.     that should be replaced, the second is the replacement string.</font>
<font color="black"> 106.     If the optional third argument ``count`` is given, only the first</font>
<font color="black"> 107.     ``count`` occurrences are replaced:</font>
<font color="black"> 108. </font>
<font color="black"> 109.     .. sourcecode:: jinja</font>
<font color="black"> 110. </font>
<font color="black"> 111.         {{ &quot;Hello World&quot;|replace(&quot;Hello&quot;, &quot;Goodbye&quot;) }}</font>
<font color="black"> 112.             -&gt; Goodbye World</font>
<font color="black"> 113. </font>
<font color="black"> 114.         {{ &quot;aaaaargh&quot;|replace(&quot;a&quot;, &quot;d'oh, &quot;, 2) }}</font>
<font color="black"> 115.             -&gt; d'oh, d'oh, aaargh</font>
<font color="black"> 116.     &quot;&quot;&quot;</font>
<font color="red"> 117.     if count is None:</font>
<font color="red"> 118.         count = -1</font>
<font color="red"> 119.     if not eval_ctx.autoescape:</font>
<font color="red"> 120.         return text_type(s).replace(text_type(old), text_type(new), count)</font>
<font color="red"> 121.     if hasattr(old, '__html__') or hasattr(new, '__html__') and \</font>
<font color="red"> 122.        not hasattr(s, '__html__'):</font>
<font color="red"> 123.         s = escape(s)</font>
<font color="black"> 124.     else:</font>
<font color="red"> 125.         s = soft_unicode(s)</font>
<font color="red"> 126.     return s.replace(soft_unicode(old), soft_unicode(new), count)</font>
<font color="black"> 127. </font>
<font color="black"> 128. </font>
<font color="green"> 129. def do_upper(s):</font>
<font color="black"> 130.     &quot;&quot;&quot;Convert a value to uppercase.&quot;&quot;&quot;</font>
<font color="red"> 131.     return soft_unicode(s).upper()</font>
<font color="black"> 132. </font>
<font color="black"> 133. </font>
<font color="green"> 134. def do_lower(s):</font>
<font color="black"> 135.     &quot;&quot;&quot;Convert a value to lowercase.&quot;&quot;&quot;</font>
<font color="red"> 136.     return soft_unicode(s).lower()</font>
<font color="black"> 137. </font>
<font color="black"> 138. </font>
<font color="green"> 139. @evalcontextfilter</font>
<font color="green"> 140. def do_xmlattr(_eval_ctx, d, autospace=True):</font>
<font color="black"> 141.     &quot;&quot;&quot;Create an SGML/XML attribute string based on the items in a dict.</font>
<font color="black"> 142.     All values that are neither `none` nor `undefined` are automatically</font>
<font color="black"> 143.     escaped:</font>
<font color="black"> 144. </font>
<font color="black"> 145.     .. sourcecode:: html+jinja</font>
<font color="black"> 146. </font>
<font color="black"> 147.         &lt;ul{{ {'class': 'my_list', 'missing': none,</font>
<font color="black"> 148.                 'id': 'list-%d'|format(variable)}|xmlattr }}&gt;</font>
<font color="black"> 149.         ...</font>
<font color="black"> 150.         &lt;/ul&gt;</font>
<font color="black"> 151. </font>
<font color="black"> 152.     Results in something like this:</font>
<font color="black"> 153. </font>
<font color="black"> 154.     .. sourcecode:: html</font>
<font color="black"> 155. </font>
<font color="black"> 156.         &lt;ul class=&quot;my_list&quot; id=&quot;list-42&quot;&gt;</font>
<font color="black"> 157.         ...</font>
<font color="black"> 158.         &lt;/ul&gt;</font>
<font color="black"> 159. </font>
<font color="black"> 160.     As you can see it automatically prepends a space in front of the item</font>
<font color="black"> 161.     if the filter returned something unless the second parameter is false.</font>
<font color="black"> 162.     &quot;&quot;&quot;</font>
<font color="red"> 163.     rv = u' '.join(</font>
<font color="red"> 164.         u'%s=&quot;%s&quot;' % (escape(key), escape(value))</font>
<font color="red"> 165.         for key, value in iteritems(d)</font>
<font color="red"> 166.         if value is not None and not isinstance(value, Undefined)</font>
<font color="black"> 167.     )</font>
<font color="red"> 168.     if autospace and rv:</font>
<font color="red"> 169.         rv = u' ' + rv</font>
<font color="red"> 170.     if _eval_ctx.autoescape:</font>
<font color="red"> 171.         rv = Markup(rv)</font>
<font color="red"> 172.     return rv</font>
<font color="black"> 173. </font>
<font color="black"> 174. </font>
<font color="green"> 175. def do_capitalize(s):</font>
<font color="black"> 176.     &quot;&quot;&quot;Capitalize a value. The first character will be uppercase, all others</font>
<font color="black"> 177.     lowercase.</font>
<font color="black"> 178.     &quot;&quot;&quot;</font>
<font color="red"> 179.     return soft_unicode(s).capitalize()</font>
<font color="black"> 180. </font>
<font color="black"> 181. </font>
<font color="green"> 182. def do_title(s):</font>
<font color="black"> 183.     &quot;&quot;&quot;Return a titlecased version of the value. I.e. words will start with</font>
<font color="black"> 184.     uppercase letters, all remaining characters are lowercase.</font>
<font color="black"> 185.     &quot;&quot;&quot;</font>
<font color="red"> 186.     rv = []</font>
<font color="red"> 187.     for item in re.compile(r'([-\s]+)(?u)').split(soft_unicode(s)):</font>
<font color="red"> 188.         if not item:</font>
<font color="red"> 189.             continue</font>
<font color="red"> 190.         rv.append(item[0].upper() + item[1:].lower())</font>
<font color="red"> 191.     return ''.join(rv)</font>
<font color="black"> 192. </font>
<font color="black"> 193. </font>
<font color="green"> 194. def do_dictsort(value, case_sensitive=False, by='key'):</font>
<font color="black"> 195.     &quot;&quot;&quot;Sort a dict and yield (key, value) pairs. Because python dicts are</font>
<font color="black"> 196.     unsorted you may want to use this function to order them by either</font>
<font color="black"> 197.     key or value:</font>
<font color="black"> 198. </font>
<font color="black"> 199.     .. sourcecode:: jinja</font>
<font color="black"> 200. </font>
<font color="black"> 201.         {% for item in mydict|dictsort %}</font>
<font color="black"> 202.             sort the dict by key, case insensitive</font>
<font color="black"> 203. </font>
<font color="black"> 204.         {% for item in mydict|dictsort(true) %}</font>
<font color="black"> 205.             sort the dict by key, case sensitive</font>
<font color="black"> 206. </font>
<font color="black"> 207.         {% for item in mydict|dictsort(false, 'value') %}</font>
<font color="black"> 208.             sort the dict by value, case insensitive</font>
<font color="black"> 209.     &quot;&quot;&quot;</font>
<font color="red"> 210.     if by == 'key':</font>
<font color="red"> 211.         pos = 0</font>
<font color="red"> 212.     elif by == 'value':</font>
<font color="red"> 213.         pos = 1</font>
<font color="black"> 214.     else:</font>
<font color="red"> 215.         raise FilterArgumentError('You can only sort by either '</font>
<font color="black"> 216.                                   '&quot;key&quot; or &quot;value&quot;')</font>
<font color="red"> 217.     def sort_func(item):</font>
<font color="red"> 218.         value = item[pos]</font>
<font color="red"> 219.         if isinstance(value, string_types) and not case_sensitive:</font>
<font color="red"> 220.             value = value.lower()</font>
<font color="red"> 221.         return value</font>
<font color="black"> 222. </font>
<font color="red"> 223.     return sorted(value.items(), key=sort_func)</font>
<font color="black"> 224. </font>
<font color="black"> 225. </font>
<font color="green"> 226. @environmentfilter</font>
<font color="green"> 227. def do_sort(environment, value, reverse=False, case_sensitive=False,</font>
<font color="green"> 228.             attribute=None):</font>
<font color="black"> 229.     &quot;&quot;&quot;Sort an iterable.  Per default it sorts ascending, if you pass it</font>
<font color="black"> 230.     true as first argument it will reverse the sorting.</font>
<font color="black"> 231. </font>
<font color="black"> 232.     If the iterable is made of strings the third parameter can be used to</font>
<font color="black"> 233.     control the case sensitiveness of the comparison which is disabled by</font>
<font color="black"> 234.     default.</font>
<font color="black"> 235. </font>
<font color="black"> 236.     .. sourcecode:: jinja</font>
<font color="black"> 237. </font>
<font color="black"> 238.         {% for item in iterable|sort %}</font>
<font color="black"> 239.             ...</font>
<font color="black"> 240.         {% endfor %}</font>
<font color="black"> 241. </font>
<font color="black"> 242.     It is also possible to sort by an attribute (for example to sort</font>
<font color="black"> 243.     by the date of an object) by specifying the `attribute` parameter:</font>
<font color="black"> 244. </font>
<font color="black"> 245.     .. sourcecode:: jinja</font>
<font color="black"> 246. </font>
<font color="black"> 247.         {% for item in iterable|sort(attribute='date') %}</font>
<font color="black"> 248.             ...</font>
<font color="black"> 249.         {% endfor %}</font>
<font color="black"> 250. </font>
<font color="black"> 251.     .. versionchanged:: 2.6</font>
<font color="black"> 252.        The `attribute` parameter was added.</font>
<font color="black"> 253.     &quot;&quot;&quot;</font>
<font color="red"> 254.     if not case_sensitive:</font>
<font color="red"> 255.         def sort_func(item):</font>
<font color="red"> 256.             if isinstance(item, string_types):</font>
<font color="red"> 257.                 item = item.lower()</font>
<font color="red"> 258.             return item</font>
<font color="black"> 259.     else:</font>
<font color="red"> 260.         sort_func = None</font>
<font color="red"> 261.     if attribute is not None:</font>
<font color="red"> 262.         getter = make_attrgetter(environment, attribute)</font>
<font color="red"> 263.         def sort_func(item, processor=sort_func or (lambda x: x)):</font>
<font color="red"> 264.             return processor(getter(item))</font>
<font color="red"> 265.     return sorted(value, key=sort_func, reverse=reverse)</font>
<font color="black"> 266. </font>
<font color="black"> 267. </font>
<font color="green"> 268. def do_default(value, default_value=u'', boolean=False):</font>
<font color="black"> 269.     &quot;&quot;&quot;If the value is undefined it will return the passed default value,</font>
<font color="black"> 270.     otherwise the value of the variable:</font>
<font color="black"> 271. </font>
<font color="black"> 272.     .. sourcecode:: jinja</font>
<font color="black"> 273. </font>
<font color="black"> 274.         {{ my_variable|default('my_variable is not defined') }}</font>
<font color="black"> 275. </font>
<font color="black"> 276.     This will output the value of ``my_variable`` if the variable was</font>
<font color="black"> 277.     defined, otherwise ``'my_variable is not defined'``. If you want</font>
<font color="black"> 278.     to use default with variables that evaluate to false you have to</font>
<font color="black"> 279.     set the second parameter to `true`:</font>
<font color="black"> 280. </font>
<font color="black"> 281.     .. sourcecode:: jinja</font>
<font color="black"> 282. </font>
<font color="black"> 283.         {{ ''|default('the string was empty', true) }}</font>
<font color="black"> 284.     &quot;&quot;&quot;</font>
<font color="red"> 285.     if isinstance(value, Undefined) or (boolean and not value):</font>
<font color="red"> 286.         return default_value</font>
<font color="red"> 287.     return value</font>
<font color="black"> 288. </font>
<font color="black"> 289. </font>
<font color="green"> 290. @evalcontextfilter</font>
<font color="green"> 291. def do_join(eval_ctx, value, d=u'', attribute=None):</font>
<font color="black"> 292.     &quot;&quot;&quot;Return a string which is the concatenation of the strings in the</font>
<font color="black"> 293.     sequence. The separator between elements is an empty string per</font>
<font color="black"> 294.     default, you can define it with the optional parameter:</font>
<font color="black"> 295. </font>
<font color="black"> 296.     .. sourcecode:: jinja</font>
<font color="black"> 297. </font>
<font color="black"> 298.         {{ [1, 2, 3]|join('|') }}</font>
<font color="black"> 299.             -&gt; 1|2|3</font>
<font color="black"> 300. </font>
<font color="black"> 301.         {{ [1, 2, 3]|join }}</font>
<font color="black"> 302.             -&gt; 123</font>
<font color="black"> 303. </font>
<font color="black"> 304.     It is also possible to join certain attributes of an object:</font>
<font color="black"> 305. </font>
<font color="black"> 306.     .. sourcecode:: jinja</font>
<font color="black"> 307. </font>
<font color="black"> 308.         {{ users|join(', ', attribute='username') }}</font>
<font color="black"> 309. </font>
<font color="black"> 310.     .. versionadded:: 2.6</font>
<font color="black"> 311.        The `attribute` parameter was added.</font>
<font color="black"> 312.     &quot;&quot;&quot;</font>
<font color="red"> 313.     if attribute is not None:</font>
<font color="red"> 314.         value = imap(make_attrgetter(eval_ctx.environment, attribute), value)</font>
<font color="black"> 315. </font>
<font color="black"> 316.     # no automatic escaping?  joining is a lot eaiser then</font>
<font color="red"> 317.     if not eval_ctx.autoescape:</font>
<font color="red"> 318.         return text_type(d).join(imap(text_type, value))</font>
<font color="black"> 319. </font>
<font color="black"> 320.     # if the delimiter doesn't have an html representation we check</font>
<font color="black"> 321.     # if any of the items has.  If yes we do a coercion to Markup</font>
<font color="red"> 322.     if not hasattr(d, '__html__'):</font>
<font color="red"> 323.         value = list(value)</font>
<font color="red"> 324.         do_escape = False</font>
<font color="red"> 325.         for idx, item in enumerate(value):</font>
<font color="red"> 326.             if hasattr(item, '__html__'):</font>
<font color="red"> 327.                 do_escape = True</font>
<font color="black"> 328.             else:</font>
<font color="red"> 329.                 value[idx] = text_type(item)</font>
<font color="red"> 330.         if do_escape:</font>
<font color="red"> 331.             d = escape(d)</font>
<font color="black"> 332.         else:</font>
<font color="red"> 333.             d = text_type(d)</font>
<font color="red"> 334.         return d.join(value)</font>
<font color="black"> 335. </font>
<font color="black"> 336.     # no html involved, to normal joining</font>
<font color="red"> 337.     return soft_unicode(d).join(imap(soft_unicode, value))</font>
<font color="black"> 338. </font>
<font color="black"> 339. </font>
<font color="green"> 340. def do_center(value, width=80):</font>
<font color="black"> 341.     &quot;&quot;&quot;Centers the value in a field of a given width.&quot;&quot;&quot;</font>
<font color="red"> 342.     return text_type(value).center(width)</font>
<font color="black"> 343. </font>
<font color="black"> 344. </font>
<font color="green"> 345. @environmentfilter</font>
<font color="black"> 346. def do_first(environment, seq):</font>
<font color="black"> 347.     &quot;&quot;&quot;Return the first item of a sequence.&quot;&quot;&quot;</font>
<font color="red"> 348.     try:</font>
<font color="red"> 349.         return next(iter(seq))</font>
<font color="red"> 350.     except StopIteration:</font>
<font color="red"> 351.         return environment.undefined('No first item, sequence was empty.')</font>
<font color="black"> 352. </font>
<font color="black"> 353. </font>
<font color="green"> 354. @environmentfilter</font>
<font color="black"> 355. def do_last(environment, seq):</font>
<font color="black"> 356.     &quot;&quot;&quot;Return the last item of a sequence.&quot;&quot;&quot;</font>
<font color="red"> 357.     try:</font>
<font color="red"> 358.         return next(iter(reversed(seq)))</font>
<font color="red"> 359.     except StopIteration:</font>
<font color="red"> 360.         return environment.undefined('No last item, sequence was empty.')</font>
<font color="black"> 361. </font>
<font color="black"> 362. </font>
<font color="green"> 363. @environmentfilter</font>
<font color="black"> 364. def do_random(environment, seq):</font>
<font color="black"> 365.     &quot;&quot;&quot;Return a random item from the sequence.&quot;&quot;&quot;</font>
<font color="red"> 366.     try:</font>
<font color="red"> 367.         return choice(seq)</font>
<font color="red"> 368.     except IndexError:</font>
<font color="red"> 369.         return environment.undefined('No random item, sequence was empty.')</font>
<font color="black"> 370. </font>
<font color="black"> 371. </font>
<font color="green"> 372. def do_filesizeformat(value, binary=False):</font>
<font color="black"> 373.     &quot;&quot;&quot;Format the value like a 'human-readable' file size (i.e. 13 kB,</font>
<font color="black"> 374.     4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,</font>
<font color="black"> 375.     Giga, etc.), if the second parameter is set to `True` the binary</font>
<font color="black"> 376.     prefixes are used (Mebi, Gibi).</font>
<font color="black"> 377.     &quot;&quot;&quot;</font>
<font color="red"> 378.     bytes = float(value)</font>
<font color="red"> 379.     base = binary and 1024 or 1000</font>
<font color="black"> 380.     prefixes = [</font>
<font color="red"> 381.         (binary and 'KiB' or 'kB'),</font>
<font color="red"> 382.         (binary and 'MiB' or 'MB'),</font>
<font color="red"> 383.         (binary and 'GiB' or 'GB'),</font>
<font color="red"> 384.         (binary and 'TiB' or 'TB'),</font>
<font color="red"> 385.         (binary and 'PiB' or 'PB'),</font>
<font color="red"> 386.         (binary and 'EiB' or 'EB'),</font>
<font color="red"> 387.         (binary and 'ZiB' or 'ZB'),</font>
<font color="red"> 388.         (binary and 'YiB' or 'YB')</font>
<font color="black"> 389.     ]</font>
<font color="red"> 390.     if bytes == 1:</font>
<font color="red"> 391.         return '1 Byte'</font>
<font color="red"> 392.     elif bytes &lt; base:</font>
<font color="red"> 393.         return '%d Bytes' % bytes</font>
<font color="black"> 394.     else:</font>
<font color="red"> 395.         for i, prefix in enumerate(prefixes):</font>
<font color="red"> 396.             unit = base ** (i + 2)</font>
<font color="red"> 397.             if bytes &lt; unit:</font>
<font color="red"> 398.                 return '%.1f %s' % ((base * bytes / unit), prefix)</font>
<font color="red"> 399.         return '%.1f %s' % ((base * bytes / unit), prefix)</font>
<font color="black"> 400. </font>
<font color="black"> 401. </font>
<font color="green"> 402. def do_pprint(value, verbose=False):</font>
<font color="black"> 403.     &quot;&quot;&quot;Pretty print a variable. Useful for debugging.</font>
<font color="black"> 404. </font>
<font color="black"> 405.     With Jinja 1.2 onwards you can pass it a parameter.  If this parameter</font>
<font color="black"> 406.     is truthy the output will be more verbose (this requires `pretty`)</font>
<font color="black"> 407.     &quot;&quot;&quot;</font>
<font color="red"> 408.     return pformat(value, verbose=verbose)</font>
<font color="black"> 409. </font>
<font color="black"> 410. </font>
<font color="green"> 411. @evalcontextfilter</font>
<font color="green"> 412. def do_urlize(eval_ctx, value, trim_url_limit=None, nofollow=False,</font>
<font color="green"> 413.               target=None):</font>
<font color="black"> 414.     &quot;&quot;&quot;Converts URLs in plain text into clickable links.</font>
<font color="black"> 415. </font>
<font color="black"> 416.     If you pass the filter an additional integer it will shorten the urls</font>
<font color="black"> 417.     to that number. Also a third argument exists that makes the urls</font>
<font color="black"> 418.     &quot;nofollow&quot;:</font>
<font color="black"> 419. </font>
<font color="black"> 420.     .. sourcecode:: jinja</font>
<font color="black"> 421. </font>
<font color="black"> 422.         {{ mytext|urlize(40, true) }}</font>
<font color="black"> 423.             links are shortened to 40 chars and defined with rel=&quot;nofollow&quot;</font>
<font color="black"> 424. </font>
<font color="black"> 425.     If *target* is specified, the ``target`` attribute will be added to the</font>
<font color="black"> 426.     ``&lt;a&gt;`` tag:</font>
<font color="black"> 427. </font>
<font color="black"> 428.     .. sourcecode:: jinja</font>
<font color="black"> 429. </font>
<font color="black"> 430.        {{ mytext|urlize(40, target='_blank') }}</font>
<font color="black"> 431. </font>
<font color="black"> 432.     .. versionchanged:: 2.8+</font>
<font color="black"> 433.        The *target* parameter was added.</font>
<font color="black"> 434.     &quot;&quot;&quot;</font>
<font color="red"> 435.     rv = urlize(value, trim_url_limit, nofollow, target)</font>
<font color="red"> 436.     if eval_ctx.autoescape:</font>
<font color="red"> 437.         rv = Markup(rv)</font>
<font color="red"> 438.     return rv</font>
<font color="black"> 439. </font>
<font color="black"> 440. </font>
<font color="green"> 441. def do_indent(s, width=4, indentfirst=False):</font>
<font color="black"> 442.     &quot;&quot;&quot;Return a copy of the passed string, each line indented by</font>
<font color="black"> 443.     4 spaces. The first line is not indented. If you want to</font>
<font color="black"> 444.     change the number of spaces or indent the first line too</font>
<font color="black"> 445.     you can pass additional parameters to the filter:</font>
<font color="black"> 446. </font>
<font color="black"> 447.     .. sourcecode:: jinja</font>
<font color="black"> 448. </font>
<font color="black"> 449.         {{ mytext|indent(2, true) }}</font>
<font color="black"> 450.             indent by two spaces and indent the first line too.</font>
<font color="black"> 451.     &quot;&quot;&quot;</font>
<font color="red"> 452.     indention = u' ' * width</font>
<font color="red"> 453.     rv = (u'\n' + indention).join(s.splitlines())</font>
<font color="red"> 454.     if indentfirst:</font>
<font color="red"> 455.         rv = indention + rv</font>
<font color="red"> 456.     return rv</font>
<font color="black"> 457. </font>
<font color="black"> 458. </font>
<font color="green"> 459. def do_truncate(s, length=255, killwords=False, end='...'):</font>
<font color="black"> 460.     &quot;&quot;&quot;Return a truncated copy of the string. The length is specified</font>
<font color="black"> 461.     with the first parameter which defaults to ``255``. If the second</font>
<font color="black"> 462.     parameter is ``true`` the filter will cut the text at length. Otherwise</font>
<font color="black"> 463.     it will discard the last word. If the text was in fact</font>
<font color="black"> 464.     truncated it will append an ellipsis sign (``&quot;...&quot;``). If you want a</font>
<font color="black"> 465.     different ellipsis sign than ``&quot;...&quot;`` you can specify it using the</font>
<font color="black"> 466.     third parameter.</font>
<font color="black"> 467. </font>
<font color="black"> 468.     .. sourcecode:: jinja</font>
<font color="black"> 469. </font>
<font color="black"> 470.         {{ &quot;foo bar baz&quot;|truncate(9) }}</font>
<font color="black"> 471.             -&gt; &quot;foo ...&quot;</font>
<font color="black"> 472.         {{ &quot;foo bar baz&quot;|truncate(9, True) }}</font>
<font color="black"> 473.             -&gt; &quot;foo ba...&quot;</font>
<font color="black"> 474. </font>
<font color="black"> 475.     &quot;&quot;&quot;</font>
<font color="red"> 476.     if len(s) &lt;= length:</font>
<font color="red"> 477.         return s</font>
<font color="red"> 478.     elif killwords:</font>
<font color="red"> 479.         return s[:length - len(end)] + end</font>
<font color="black"> 480. </font>
<font color="red"> 481.     result = s[:length - len(end)].rsplit(' ', 1)[0]</font>
<font color="red"> 482.     if len(result) &lt; length:</font>
<font color="red"> 483.         result += ' '</font>
<font color="red"> 484.     return result + end</font>
<font color="black"> 485. </font>
<font color="black"> 486. </font>
<font color="green"> 487. @environmentfilter</font>
<font color="green"> 488. def do_wordwrap(environment, s, width=79, break_long_words=True,</font>
<font color="green"> 489.                 wrapstring=None):</font>
<font color="black"> 490.     &quot;&quot;&quot;</font>
<font color="black"> 491.     Return a copy of the string passed to the filter wrapped after</font>
<font color="black"> 492.     ``79`` characters.  You can override this default using the first</font>
<font color="black"> 493.     parameter.  If you set the second parameter to `false` Jinja will not</font>
<font color="black"> 494.     split words apart if they are longer than `width`. By default, the newlines</font>
<font color="black"> 495.     will be the default newlines for the environment, but this can be changed</font>
<font color="black"> 496.     using the wrapstring keyword argument.</font>
<font color="black"> 497. </font>
<font color="black"> 498.     .. versionadded:: 2.7</font>
<font color="black"> 499.        Added support for the `wrapstring` parameter.</font>
<font color="black"> 500.     &quot;&quot;&quot;</font>
<font color="red"> 501.     if not wrapstring:</font>
<font color="red"> 502.         wrapstring = environment.newline_sequence</font>
<font color="red"> 503.     import textwrap</font>
<font color="red"> 504.     return wrapstring.join(textwrap.wrap(s, width=width, expand_tabs=False,</font>
<font color="red"> 505.                                    replace_whitespace=False,</font>
<font color="red"> 506.                                    break_long_words=break_long_words))</font>
<font color="black"> 507. </font>
<font color="black"> 508. </font>
<font color="green"> 509. def do_wordcount(s):</font>
<font color="black"> 510.     &quot;&quot;&quot;Count the words in that string.&quot;&quot;&quot;</font>
<font color="red"> 511.     return len(_word_re.findall(s))</font>
<font color="black"> 512. </font>
<font color="black"> 513. </font>
<font color="green"> 514. def do_int(value, default=0, base=10):</font>
<font color="black"> 515.     &quot;&quot;&quot;Convert the value into an integer. If the</font>
<font color="black"> 516.     conversion doesn't work it will return ``0``. You can</font>
<font color="black"> 517.     override this default using the first parameter. You</font>
<font color="black"> 518.     can also override the default base (10) in the second</font>
<font color="black"> 519.     parameter, which handles input with prefixes such as</font>
<font color="black"> 520.     0b, 0o and 0x for bases 2, 8 and 16 respectively.</font>
<font color="black"> 521.     &quot;&quot;&quot;</font>
<font color="red"> 522.     try:</font>
<font color="red"> 523.         return int(value, base)</font>
<font color="red"> 524.     except (TypeError, ValueError):</font>
<font color="black"> 525.         # this quirk is necessary so that &quot;42.23&quot;|int gives 42.</font>
<font color="red"> 526.         try:</font>
<font color="red"> 527.             return int(float(value))</font>
<font color="red"> 528.         except (TypeError, ValueError):</font>
<font color="red"> 529.             return default</font>
<font color="black"> 530. </font>
<font color="black"> 531. </font>
<font color="green"> 532. def do_float(value, default=0.0):</font>
<font color="black"> 533.     &quot;&quot;&quot;Convert the value into a floating point number. If the</font>
<font color="black"> 534.     conversion doesn't work it will return ``0.0``. You can</font>
<font color="black"> 535.     override this default using the first parameter.</font>
<font color="black"> 536.     &quot;&quot;&quot;</font>
<font color="red"> 537.     try:</font>
<font color="red"> 538.         return float(value)</font>
<font color="red"> 539.     except (TypeError, ValueError):</font>
<font color="red"> 540.         return default</font>
<font color="black"> 541. </font>
<font color="black"> 542. </font>
<font color="green"> 543. def do_format(value, *args, **kwargs):</font>
<font color="black"> 544.     &quot;&quot;&quot;</font>
<font color="black"> 545.     Apply python string formatting on an object:</font>
<font color="black"> 546. </font>
<font color="black"> 547.     .. sourcecode:: jinja</font>
<font color="black"> 548. </font>
<font color="black"> 549.         {{ &quot;%s - %s&quot;|format(&quot;Hello?&quot;, &quot;Foo!&quot;) }}</font>
<font color="black"> 550.             -&gt; Hello? - Foo!</font>
<font color="black"> 551.     &quot;&quot;&quot;</font>
<font color="red"> 552.     if args and kwargs:</font>
<font color="red"> 553.         raise FilterArgumentError('can\'t handle positional and keyword '</font>
<font color="black"> 554.                                   'arguments at the same time')</font>
<font color="red"> 555.     return soft_unicode(value) % (kwargs or args)</font>
<font color="black"> 556. </font>
<font color="black"> 557. </font>
<font color="green"> 558. def do_trim(value):</font>
<font color="black"> 559.     &quot;&quot;&quot;Strip leading and trailing whitespace.&quot;&quot;&quot;</font>
<font color="red"> 560.     return soft_unicode(value).strip()</font>
<font color="black"> 561. </font>
<font color="black"> 562. </font>
<font color="green"> 563. def do_striptags(value):</font>
<font color="black"> 564.     &quot;&quot;&quot;Strip SGML/XML tags and replace adjacent whitespace by one space.</font>
<font color="black"> 565.     &quot;&quot;&quot;</font>
<font color="red"> 566.     if hasattr(value, '__html__'):</font>
<font color="red"> 567.         value = value.__html__()</font>
<font color="red"> 568.     return Markup(text_type(value)).striptags()</font>
<font color="black"> 569. </font>
<font color="black"> 570. </font>
<font color="green"> 571. def do_slice(value, slices, fill_with=None):</font>
<font color="black"> 572.     &quot;&quot;&quot;Slice an iterator and return a list of lists containing</font>
<font color="black"> 573.     those items. Useful if you want to create a div containing</font>
<font color="black"> 574.     three ul tags that represent columns:</font>
<font color="black"> 575. </font>
<font color="black"> 576.     .. sourcecode:: html+jinja</font>
<font color="black"> 577. </font>
<font color="black"> 578.         &lt;div class=&quot;columwrapper&quot;&gt;</font>
<font color="black"> 579.           {%- for column in items|slice(3) %}</font>
<font color="black"> 580.             &lt;ul class=&quot;column-{{ loop.index }}&quot;&gt;</font>
<font color="black"> 581.             {%- for item in column %}</font>
<font color="black"> 582.               &lt;li&gt;{{ item }}&lt;/li&gt;</font>
<font color="black"> 583.             {%- endfor %}</font>
<font color="black"> 584.             &lt;/ul&gt;</font>
<font color="black"> 585.           {%- endfor %}</font>
<font color="black"> 586.         &lt;/div&gt;</font>
<font color="black"> 587. </font>
<font color="black"> 588.     If you pass it a second argument it's used to fill missing</font>
<font color="black"> 589.     values on the last iteration.</font>
<font color="black"> 590.     &quot;&quot;&quot;</font>
<font color="red"> 591.     seq = list(value)</font>
<font color="red"> 592.     length = len(seq)</font>
<font color="red"> 593.     items_per_slice = length // slices</font>
<font color="red"> 594.     slices_with_extra = length % slices</font>
<font color="red"> 595.     offset = 0</font>
<font color="red"> 596.     for slice_number in range(slices):</font>
<font color="red"> 597.         start = offset + slice_number * items_per_slice</font>
<font color="red"> 598.         if slice_number &lt; slices_with_extra:</font>
<font color="red"> 599.             offset += 1</font>
<font color="red"> 600.         end = offset + (slice_number + 1) * items_per_slice</font>
<font color="red"> 601.         tmp = seq[start:end]</font>
<font color="red"> 602.         if fill_with is not None and slice_number &gt;= slices_with_extra:</font>
<font color="red"> 603.             tmp.append(fill_with)</font>
<font color="red"> 604.         yield tmp</font>
<font color="black"> 605. </font>
<font color="black"> 606. </font>
<font color="green"> 607. def do_batch(value, linecount, fill_with=None):</font>
<font color="black"> 608.     &quot;&quot;&quot;</font>
<font color="black"> 609.     A filter that batches items. It works pretty much like `slice`</font>
<font color="black"> 610.     just the other way round. It returns a list of lists with the</font>
<font color="black"> 611.     given number of items. If you provide a second parameter this</font>
<font color="black"> 612.     is used to fill up missing items. See this example:</font>
<font color="black"> 613. </font>
<font color="black"> 614.     .. sourcecode:: html+jinja</font>
<font color="black"> 615. </font>
<font color="black"> 616.         &lt;table&gt;</font>
<font color="black"> 617.         {%- for row in items|batch(3, '&amp;nbsp;') %}</font>
<font color="black"> 618.           &lt;tr&gt;</font>
<font color="black"> 619.           {%- for column in row %}</font>
<font color="black"> 620.             &lt;td&gt;{{ column }}&lt;/td&gt;</font>
<font color="black"> 621.           {%- endfor %}</font>
<font color="black"> 622.           &lt;/tr&gt;</font>
<font color="black"> 623.         {%- endfor %}</font>
<font color="black"> 624.         &lt;/table&gt;</font>
<font color="black"> 625.     &quot;&quot;&quot;</font>
<font color="red"> 626.     tmp = []</font>
<font color="red"> 627.     for item in value:</font>
<font color="red"> 628.         if len(tmp) == linecount:</font>
<font color="red"> 629.             yield tmp</font>
<font color="red"> 630.             tmp = []</font>
<font color="red"> 631.         tmp.append(item)</font>
<font color="red"> 632.     if tmp:</font>
<font color="red"> 633.         if fill_with is not None and len(tmp) &lt; linecount:</font>
<font color="red"> 634.             tmp += [fill_with] * (linecount - len(tmp))</font>
<font color="red"> 635.         yield tmp</font>
<font color="black"> 636. </font>
<font color="black"> 637. </font>
<font color="green"> 638. def do_round(value, precision=0, method='common'):</font>
<font color="black"> 639.     &quot;&quot;&quot;Round the number to a given precision. The first</font>
<font color="black"> 640.     parameter specifies the precision (default is ``0``), the</font>
<font color="black"> 641.     second the rounding method:</font>
<font color="black"> 642. </font>
<font color="black"> 643.     - ``'common'`` rounds either up or down</font>
<font color="black"> 644.     - ``'ceil'`` always rounds up</font>
<font color="black"> 645.     - ``'floor'`` always rounds down</font>
<font color="black"> 646. </font>
<font color="black"> 647.     If you don't specify a method ``'common'`` is used.</font>
<font color="black"> 648. </font>
<font color="black"> 649.     .. sourcecode:: jinja</font>
<font color="black"> 650. </font>
<font color="black"> 651.         {{ 42.55|round }}</font>
<font color="black"> 652.             -&gt; 43.0</font>
<font color="black"> 653.         {{ 42.55|round(1, 'floor') }}</font>
<font color="black"> 654.             -&gt; 42.5</font>
<font color="black"> 655. </font>
<font color="black"> 656.     Note that even if rounded to 0 precision, a float is returned.  If</font>
<font color="black"> 657.     you need a real integer, pipe it through `int`:</font>
<font color="black"> 658. </font>
<font color="black"> 659.     .. sourcecode:: jinja</font>
<font color="black"> 660. </font>
<font color="black"> 661.         {{ 42.55|round|int }}</font>
<font color="black"> 662.             -&gt; 43</font>
<font color="black"> 663.     &quot;&quot;&quot;</font>
<font color="red"> 664.     if not method in ('common', 'ceil', 'floor'):</font>
<font color="red"> 665.         raise FilterArgumentError('method must be common, ceil or floor')</font>
<font color="red"> 666.     if method == 'common':</font>
<font color="red"> 667.         return round(value, precision)</font>
<font color="red"> 668.     func = getattr(math, method)</font>
<font color="red"> 669.     return func(value * (10 ** precision)) / (10 ** precision)</font>
<font color="black"> 670. </font>
<font color="black"> 671. </font>
<font color="green"> 672. @environmentfilter</font>
<font color="black"> 673. def do_groupby(environment, value, attribute):</font>
<font color="black"> 674.     &quot;&quot;&quot;Group a sequence of objects by a common attribute.</font>
<font color="black"> 675. </font>
<font color="black"> 676.     If you for example have a list of dicts or objects that represent persons</font>
<font color="black"> 677.     with `gender`, `first_name` and `last_name` attributes and you want to</font>
<font color="black"> 678.     group all users by genders you can do something like the following</font>
<font color="black"> 679.     snippet:</font>
<font color="black"> 680. </font>
<font color="black"> 681.     .. sourcecode:: html+jinja</font>
<font color="black"> 682. </font>
<font color="black"> 683.         &lt;ul&gt;</font>
<font color="black"> 684.         {% for group in persons|groupby('gender') %}</font>
<font color="black"> 685.             &lt;li&gt;{{ group.grouper }}&lt;ul&gt;</font>
<font color="black"> 686.             {% for person in group.list %}</font>
<font color="black"> 687.                 &lt;li&gt;{{ person.first_name }} {{ person.last_name }}&lt;/li&gt;</font>
<font color="black"> 688.             {% endfor %}&lt;/ul&gt;&lt;/li&gt;</font>
<font color="black"> 689.         {% endfor %}</font>
<font color="black"> 690.         &lt;/ul&gt;</font>
<font color="black"> 691. </font>
<font color="black"> 692.     Additionally it's possible to use tuple unpacking for the grouper and</font>
<font color="black"> 693.     list:</font>
<font color="black"> 694. </font>
<font color="black"> 695.     .. sourcecode:: html+jinja</font>
<font color="black"> 696. </font>
<font color="black"> 697.         &lt;ul&gt;</font>
<font color="black"> 698.         {% for grouper, list in persons|groupby('gender') %}</font>
<font color="black"> 699.             ...</font>
<font color="black"> 700.         {% endfor %}</font>
<font color="black"> 701.         &lt;/ul&gt;</font>
<font color="black"> 702. </font>
<font color="black"> 703.     As you can see the item we're grouping by is stored in the `grouper`</font>
<font color="black"> 704.     attribute and the `list` contains all the objects that have this grouper</font>
<font color="black"> 705.     in common.</font>
<font color="black"> 706. </font>
<font color="black"> 707.     .. versionchanged:: 2.6</font>
<font color="black"> 708.        It's now possible to use dotted notation to group by the child</font>
<font color="black"> 709.        attribute of another attribute.</font>
<font color="black"> 710.     &quot;&quot;&quot;</font>
<font color="red"> 711.     expr = make_attrgetter(environment, attribute)</font>
<font color="red"> 712.     return sorted(map(_GroupTuple, groupby(sorted(value, key=expr), expr)))</font>
<font color="black"> 713. </font>
<font color="black"> 714. </font>
<font color="green"> 715. class _GroupTuple(tuple):</font>
<font color="green"> 716.     __slots__ = ()</font>
<font color="green"> 717.     grouper = property(itemgetter(0))</font>
<font color="green"> 718.     list = property(itemgetter(1))</font>
<font color="black"> 719. </font>
<font color="green"> 720.     def __new__(cls, xxx_todo_changeme):</font>
<font color="red"> 721.         (key, value) = xxx_todo_changeme</font>
<font color="red"> 722.         return tuple.__new__(cls, (key, list(value)))</font>
<font color="black"> 723. </font>
<font color="black"> 724. </font>
<font color="green"> 725. @environmentfilter</font>
<font color="green"> 726. def do_sum(environment, iterable, attribute=None, start=0):</font>
<font color="black"> 727.     &quot;&quot;&quot;Returns the sum of a sequence of numbers plus the value of parameter</font>
<font color="black"> 728.     'start' (which defaults to 0).  When the sequence is empty it returns</font>
<font color="black"> 729.     start.</font>
<font color="black"> 730. </font>
<font color="black"> 731.     It is also possible to sum up only certain attributes:</font>
<font color="black"> 732. </font>
<font color="black"> 733.     .. sourcecode:: jinja</font>
<font color="black"> 734. </font>
<font color="black"> 735.         Total: {{ items|sum(attribute='price') }}</font>
<font color="black"> 736. </font>
<font color="black"> 737.     .. versionchanged:: 2.6</font>
<font color="black"> 738.        The `attribute` parameter was added to allow suming up over</font>
<font color="black"> 739.        attributes.  Also the `start` parameter was moved on to the right.</font>
<font color="black"> 740.     &quot;&quot;&quot;</font>
<font color="red"> 741.     if attribute is not None:</font>
<font color="red"> 742.         iterable = imap(make_attrgetter(environment, attribute), iterable)</font>
<font color="red"> 743.     return sum(iterable, start)</font>
<font color="black"> 744. </font>
<font color="black"> 745. </font>
<font color="green"> 746. def do_list(value):</font>
<font color="black"> 747.     &quot;&quot;&quot;Convert the value into a list.  If it was a string the returned list</font>
<font color="black"> 748.     will be a list of characters.</font>
<font color="black"> 749.     &quot;&quot;&quot;</font>
<font color="red"> 750.     return list(value)</font>
<font color="black"> 751. </font>
<font color="black"> 752. </font>
<font color="green"> 753. def do_mark_safe(value):</font>
<font color="black"> 754.     &quot;&quot;&quot;Mark the value as safe which means that in an environment with automatic</font>
<font color="black"> 755.     escaping enabled this variable will not be escaped.</font>
<font color="black"> 756.     &quot;&quot;&quot;</font>
<font color="red"> 757.     return Markup(value)</font>
<font color="black"> 758. </font>
<font color="black"> 759. </font>
<font color="green"> 760. def do_mark_unsafe(value):</font>
<font color="black"> 761.     &quot;&quot;&quot;Mark a value as unsafe.  This is the reverse operation for :func:`safe`.&quot;&quot;&quot;</font>
<font color="red"> 762.     return text_type(value)</font>
<font color="black"> 763. </font>
<font color="black"> 764. </font>
<font color="green"> 765. def do_reverse(value):</font>
<font color="black"> 766.     &quot;&quot;&quot;Reverse the object or return an iterator that iterates over it the other</font>
<font color="black"> 767.     way round.</font>
<font color="black"> 768.     &quot;&quot;&quot;</font>
<font color="red"> 769.     if isinstance(value, string_types):</font>
<font color="red"> 770.         return value[::-1]</font>
<font color="red"> 771.     try:</font>
<font color="red"> 772.         return reversed(value)</font>
<font color="red"> 773.     except TypeError:</font>
<font color="red"> 774.         try:</font>
<font color="red"> 775.             rv = list(value)</font>
<font color="red"> 776.             rv.reverse()</font>
<font color="red"> 777.             return rv</font>
<font color="red"> 778.         except TypeError:</font>
<font color="red"> 779.             raise FilterArgumentError('argument must be iterable')</font>
<font color="black"> 780. </font>
<font color="black"> 781. </font>
<font color="green"> 782. @environmentfilter</font>
<font color="black"> 783. def do_attr(environment, obj, name):</font>
<font color="black"> 784.     &quot;&quot;&quot;Get an attribute of an object.  ``foo|attr(&quot;bar&quot;)`` works like</font>
<font color="black"> 785.     ``foo.bar`` just that always an attribute is returned and items are not</font>
<font color="black"> 786.     looked up.</font>
<font color="black"> 787. </font>
<font color="black"> 788.     See :ref:`Notes on subscriptions &lt;notes-on-subscriptions&gt;` for more details.</font>
<font color="black"> 789.     &quot;&quot;&quot;</font>
<font color="red"> 790.     try:</font>
<font color="red"> 791.         name = str(name)</font>
<font color="red"> 792.     except UnicodeError:</font>
<font color="red"> 793.         pass</font>
<font color="black"> 794.     else:</font>
<font color="red"> 795.         try:</font>
<font color="red"> 796.             value = getattr(obj, name)</font>
<font color="red"> 797.         except AttributeError:</font>
<font color="red"> 798.             pass</font>
<font color="black"> 799.         else:</font>
<font color="red"> 800.             if environment.sandboxed and not \</font>
<font color="red"> 801.                environment.is_safe_attribute(obj, name, value):</font>
<font color="red"> 802.                 return environment.unsafe_undefined(obj, name)</font>
<font color="red"> 803.             return value</font>
<font color="red"> 804.     return environment.undefined(obj=obj, name=name)</font>
<font color="black"> 805. </font>
<font color="black"> 806. </font>
<font color="green"> 807. @contextfilter</font>
<font color="black"> 808. def do_map(*args, **kwargs):</font>
<font color="black"> 809.     &quot;&quot;&quot;Applies a filter on a sequence of objects or looks up an attribute.</font>
<font color="black"> 810.     This is useful when dealing with lists of objects but you are really</font>
<font color="black"> 811.     only interested in a certain value of it.</font>
<font color="black"> 812. </font>
<font color="black"> 813.     The basic usage is mapping on an attribute.  Imagine you have a list</font>
<font color="black"> 814.     of users but you are only interested in a list of usernames:</font>
<font color="black"> 815. </font>
<font color="black"> 816.     .. sourcecode:: jinja</font>
<font color="black"> 817. </font>
<font color="black"> 818.         Users on this page: {{ users|map(attribute='username')|join(', ') }}</font>
<font color="black"> 819. </font>
<font color="black"> 820.     Alternatively you can let it invoke a filter by passing the name of the</font>
<font color="black"> 821.     filter and the arguments afterwards.  A good example would be applying a</font>
<font color="black"> 822.     text conversion filter on a sequence:</font>
<font color="black"> 823. </font>
<font color="black"> 824.     .. sourcecode:: jinja</font>
<font color="black"> 825. </font>
<font color="black"> 826.         Users on this page: {{ titles|map('lower')|join(', ') }}</font>
<font color="black"> 827. </font>
<font color="black"> 828.     .. versionadded:: 2.7</font>
<font color="black"> 829.     &quot;&quot;&quot;</font>
<font color="red"> 830.     context = args[0]</font>
<font color="red"> 831.     seq = args[1]</font>
<font color="black"> 832. </font>
<font color="red"> 833.     if len(args) == 2 and 'attribute' in kwargs:</font>
<font color="red"> 834.         attribute = kwargs.pop('attribute')</font>
<font color="red"> 835.         if kwargs:</font>
<font color="red"> 836.             raise FilterArgumentError('Unexpected keyword argument %r' %</font>
<font color="red"> 837.                 next(iter(kwargs)))</font>
<font color="red"> 838.         func = make_attrgetter(context.environment, attribute)</font>
<font color="black"> 839.     else:</font>
<font color="red"> 840.         try:</font>
<font color="red"> 841.             name = args[2]</font>
<font color="red"> 842.             args = args[3:]</font>
<font color="red"> 843.         except LookupError:</font>
<font color="red"> 844.             raise FilterArgumentError('map requires a filter argument')</font>
<font color="red"> 845.         func = lambda item: context.environment.call_filter(</font>
<font color="red"> 846.             name, item, args, kwargs, context=context)</font>
<font color="black"> 847. </font>
<font color="red"> 848.     if seq:</font>
<font color="red"> 849.         for item in seq:</font>
<font color="red"> 850.             yield func(item)</font>
<font color="black"> 851. </font>
<font color="black"> 852. </font>
<font color="green"> 853. @contextfilter</font>
<font color="black"> 854. def do_select(*args, **kwargs):</font>
<font color="black"> 855.     &quot;&quot;&quot;Filters a sequence of objects by applying a test to the object and only</font>
<font color="black"> 856.     selecting the ones with the test succeeding.</font>
<font color="black"> 857. </font>
<font color="black"> 858.     Example usage:</font>
<font color="black"> 859. </font>
<font color="black"> 860.     .. sourcecode:: jinja</font>
<font color="black"> 861. </font>
<font color="black"> 862.         {{ numbers|select(&quot;odd&quot;) }}</font>
<font color="black"> 863.         {{ numbers|select(&quot;odd&quot;) }}</font>
<font color="black"> 864. </font>
<font color="black"> 865.     .. versionadded:: 2.7</font>
<font color="black"> 866.     &quot;&quot;&quot;</font>
<font color="red"> 867.     return _select_or_reject(args, kwargs, lambda x: x, False)</font>
<font color="black"> 868. </font>
<font color="black"> 869. </font>
<font color="green"> 870. @contextfilter</font>
<font color="black"> 871. def do_reject(*args, **kwargs):</font>
<font color="black"> 872.     &quot;&quot;&quot;Filters a sequence of objects by applying a test to the object and</font>
<font color="black"> 873.     rejecting the ones with the test succeeding.</font>
<font color="black"> 874. </font>
<font color="black"> 875.     Example usage:</font>
<font color="black"> 876. </font>
<font color="black"> 877.     .. sourcecode:: jinja</font>
<font color="black"> 878. </font>
<font color="black"> 879.         {{ numbers|reject(&quot;odd&quot;) }}</font>
<font color="black"> 880. </font>
<font color="black"> 881.     .. versionadded:: 2.7</font>
<font color="black"> 882.     &quot;&quot;&quot;</font>
<font color="red"> 883.     return _select_or_reject(args, kwargs, lambda x: not x, False)</font>
<font color="black"> 884. </font>
<font color="black"> 885. </font>
<font color="green"> 886. @contextfilter</font>
<font color="black"> 887. def do_selectattr(*args, **kwargs):</font>
<font color="black"> 888.     &quot;&quot;&quot;Filters a sequence of objects by applying a test to an attribute of an</font>
<font color="black"> 889.     object and only selecting the ones with the test succeeding.</font>
<font color="black"> 890. </font>
<font color="black"> 891.     Example usage:</font>
<font color="black"> 892. </font>
<font color="black"> 893.     .. sourcecode:: jinja</font>
<font color="black"> 894. </font>
<font color="black"> 895.         {{ users|selectattr(&quot;is_active&quot;) }}</font>
<font color="black"> 896.         {{ users|selectattr(&quot;email&quot;, &quot;none&quot;) }}</font>
<font color="black"> 897. </font>
<font color="black"> 898.     .. versionadded:: 2.7</font>
<font color="black"> 899.     &quot;&quot;&quot;</font>
<font color="red"> 900.     return _select_or_reject(args, kwargs, lambda x: x, True)</font>
<font color="black"> 901. </font>
<font color="black"> 902. </font>
<font color="green"> 903. @contextfilter</font>
<font color="black"> 904. def do_rejectattr(*args, **kwargs):</font>
<font color="black"> 905.     &quot;&quot;&quot;Filters a sequence of objects by applying a test to an attribute of an</font>
<font color="black"> 906.     object or the attribute and rejecting the ones with the test succeeding.</font>
<font color="black"> 907. </font>
<font color="black"> 908.     .. sourcecode:: jinja</font>
<font color="black"> 909. </font>
<font color="black"> 910.         {{ users|rejectattr(&quot;is_active&quot;) }}</font>
<font color="black"> 911.         {{ users|rejectattr(&quot;email&quot;, &quot;none&quot;) }}</font>
<font color="black"> 912. </font>
<font color="black"> 913.     .. versionadded:: 2.7</font>
<font color="black"> 914.     &quot;&quot;&quot;</font>
<font color="red"> 915.     return _select_or_reject(args, kwargs, lambda x: not x, True)</font>
<font color="black"> 916. </font>
<font color="black"> 917. </font>
<font color="green"> 918. def _select_or_reject(args, kwargs, modfunc, lookup_attr):</font>
<font color="red"> 919.     context = args[0]</font>
<font color="red"> 920.     seq = args[1]</font>
<font color="red"> 921.     if lookup_attr:</font>
<font color="red"> 922.         try:</font>
<font color="red"> 923.             attr = args[2]</font>
<font color="red"> 924.         except LookupError:</font>
<font color="red"> 925.             raise FilterArgumentError('Missing parameter for attribute name')</font>
<font color="red"> 926.         transfunc = make_attrgetter(context.environment, attr)</font>
<font color="red"> 927.         off = 1</font>
<font color="black"> 928.     else:</font>
<font color="red"> 929.         off = 0</font>
<font color="red"> 930.         transfunc = lambda x: x</font>
<font color="black"> 931. </font>
<font color="red"> 932.     try:</font>
<font color="red"> 933.         name = args[2 + off]</font>
<font color="red"> 934.         args = args[3 + off:]</font>
<font color="red"> 935.         func = lambda item: context.environment.call_test(</font>
<font color="red"> 936.             name, item, args, kwargs)</font>
<font color="red"> 937.     except LookupError:</font>
<font color="red"> 938.         func = bool</font>
<font color="black"> 939. </font>
<font color="red"> 940.     if seq:</font>
<font color="red"> 941.         for item in seq:</font>
<font color="red"> 942.             if modfunc(func(transfunc(item))):</font>
<font color="red"> 943.                 yield item</font>
<font color="black"> 944. </font>
<font color="black"> 945. </font>
<font color="green"> 946. FILTERS = {</font>
<font color="green"> 947.     'abs':                  abs,</font>
<font color="green"> 948.     'attr':                 do_attr,</font>
<font color="green"> 949.     'batch':                do_batch,</font>
<font color="green"> 950.     'capitalize':           do_capitalize,</font>
<font color="green"> 951.     'center':               do_center,</font>
<font color="green"> 952.     'count':                len,</font>
<font color="green"> 953.     'd':                    do_default,</font>
<font color="green"> 954.     'default':              do_default,</font>
<font color="green"> 955.     'dictsort':             do_dictsort,</font>
<font color="green"> 956.     'e':                    escape,</font>
<font color="green"> 957.     'escape':               escape,</font>
<font color="green"> 958.     'filesizeformat':       do_filesizeformat,</font>
<font color="green"> 959.     'first':                do_first,</font>
<font color="green"> 960.     'float':                do_float,</font>
<font color="green"> 961.     'forceescape':          do_forceescape,</font>
<font color="green"> 962.     'format':               do_format,</font>
<font color="green"> 963.     'groupby':              do_groupby,</font>
<font color="green"> 964.     'indent':               do_indent,</font>
<font color="green"> 965.     'int':                  do_int,</font>
<font color="green"> 966.     'join':                 do_join,</font>
<font color="green"> 967.     'last':                 do_last,</font>
<font color="green"> 968.     'length':               len,</font>
<font color="green"> 969.     'list':                 do_list,</font>
<font color="green"> 970.     'lower':                do_lower,</font>
<font color="green"> 971.     'map':                  do_map,</font>
<font color="green"> 972.     'pprint':               do_pprint,</font>
<font color="green"> 973.     'random':               do_random,</font>
<font color="green"> 974.     'reject':               do_reject,</font>
<font color="green"> 975.     'rejectattr':           do_rejectattr,</font>
<font color="green"> 976.     'replace':              do_replace,</font>
<font color="green"> 977.     'reverse':              do_reverse,</font>
<font color="green"> 978.     'round':                do_round,</font>
<font color="green"> 979.     'safe':                 do_mark_safe,</font>
<font color="green"> 980.     'select':               do_select,</font>
<font color="green"> 981.     'selectattr':           do_selectattr,</font>
<font color="green"> 982.     'slice':                do_slice,</font>
<font color="green"> 983.     'sort':                 do_sort,</font>
<font color="green"> 984.     'string':               soft_unicode,</font>
<font color="green"> 985.     'striptags':            do_striptags,</font>
<font color="green"> 986.     'sum':                  do_sum,</font>
<font color="green"> 987.     'title':                do_title,</font>
<font color="green"> 988.     'trim':                 do_trim,</font>
<font color="green"> 989.     'truncate':             do_truncate,</font>
<font color="green"> 990.     'upper':                do_upper,</font>
<font color="green"> 991.     'urlencode':            do_urlencode,</font>
<font color="green"> 992.     'urlize':               do_urlize,</font>
<font color="green"> 993.     'wordcount':            do_wordcount,</font>
<font color="green"> 994.     'wordwrap':             do_wordwrap,</font>
<font color="green"> 995.     'xmlattr':              do_xmlattr,</font>
<font color="black"> 996. }</font>
</pre>

