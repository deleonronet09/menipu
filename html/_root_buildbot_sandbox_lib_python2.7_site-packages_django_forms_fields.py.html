source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/forms/fields.py</b><br>


file stats: <b>773 lines, 269 executed: 34.8% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Field classes.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. from __future__ import unicode_literals</font>
<font color="black">   6. </font>
<font color="green">   7. import copy</font>
<font color="green">   8. import datetime</font>
<font color="green">   9. import os</font>
<font color="green">  10. import re</font>
<font color="green">  11. import sys</font>
<font color="green">  12. import uuid</font>
<font color="green">  13. import warnings</font>
<font color="green">  14. from decimal import Decimal, DecimalException</font>
<font color="green">  15. from io import BytesIO</font>
<font color="black">  16. </font>
<font color="green">  17. from django.core import validators</font>
<font color="green">  18. from django.core.exceptions import ValidationError</font>
<font color="black">  19. # Provide this import for backwards compatibility.</font>
<font color="green">  20. from django.core.validators import EMPTY_VALUES  # NOQA</font>
<font color="green">  21. from django.forms.boundfield import BoundField</font>
<font color="green">  22. from django.forms.utils import from_current_timezone, to_current_timezone</font>
<font color="green">  23. from django.forms.widgets import (</font>
<font color="black">  24.     FILE_INPUT_CONTRADICTION, CheckboxInput, ClearableFileInput, DateInput,</font>
<font color="black">  25.     DateTimeInput, EmailInput, HiddenInput, MultipleHiddenInput,</font>
<font color="black">  26.     NullBooleanSelect, NumberInput, Select, SelectMultiple,</font>
<font color="black">  27.     SplitDateTimeWidget, SplitHiddenDateTimeWidget, TextInput, TimeInput,</font>
<font color="black">  28.     URLInput,</font>
<font color="black">  29. )</font>
<font color="green">  30. from django.utils import formats, six</font>
<font color="green">  31. from django.utils.dateparse import parse_duration</font>
<font color="green">  32. from django.utils.deprecation import (</font>
<font color="black">  33.     RemovedInDjango110Warning, RenameMethodsBase,</font>
<font color="black">  34. )</font>
<font color="green">  35. from django.utils.duration import duration_string</font>
<font color="green">  36. from django.utils.encoding import force_str, force_text, smart_text</font>
<font color="green">  37. from django.utils.ipv6 import clean_ipv6_address</font>
<font color="green">  38. from django.utils.six.moves.urllib.parse import urlsplit, urlunsplit</font>
<font color="green">  39. from django.utils.translation import ugettext_lazy as _, ungettext_lazy</font>
<font color="black">  40. </font>
<font color="black">  41. __all__ = (</font>
<font color="black">  42.     'Field', 'CharField', 'IntegerField',</font>
<font color="black">  43.     'DateField', 'TimeField', 'DateTimeField', 'DurationField',</font>
<font color="black">  44.     'RegexField', 'EmailField', 'FileField', 'ImageField', 'URLField',</font>
<font color="black">  45.     'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',</font>
<font color="black">  46.     'ComboField', 'MultiValueField', 'FloatField', 'DecimalField',</font>
<font color="black">  47.     'SplitDateTimeField', 'GenericIPAddressField', 'FilePathField',</font>
<font color="green">  48.     'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField', 'UUIDField',</font>
<font color="black">  49. )</font>
<font color="black">  50. </font>
<font color="black">  51. </font>
<font color="green">  52. class RenameFieldMethods(RenameMethodsBase):</font>
<font color="black">  53.     renamed_methods = (</font>
<font color="green">  54.         ('_has_changed', 'has_changed', RemovedInDjango110Warning),</font>
<font color="black">  55.     )</font>
<font color="black">  56. </font>
<font color="black">  57. </font>
<font color="green">  58. class Field(six.with_metaclass(RenameFieldMethods, object)):</font>
<font color="green">  59.     widget = TextInput  # Default widget to use when rendering this type of Field.</font>
<font color="green">  60.     hidden_widget = HiddenInput  # Default widget to use when rendering this as &quot;hidden&quot;.</font>
<font color="green">  61.     default_validators = []  # Default set of validators</font>
<font color="black">  62.     # Add an 'invalid' entry to default_error_message if you want a specific</font>
<font color="black">  63.     # field error message not raised by the field validators.</font>
<font color="green">  64.     default_error_messages = {</font>
<font color="green">  65.         'required': _('This field is required.'),</font>
<font color="black">  66.     }</font>
<font color="green">  67.     empty_values = list(validators.EMPTY_VALUES)</font>
<font color="black">  68. </font>
<font color="black">  69.     # Tracks each time a Field instance is created. Used to retain order.</font>
<font color="green">  70.     creation_counter = 0</font>
<font color="black">  71. </font>
<font color="green">  72.     def __init__(self, required=True, widget=None, label=None, initial=None,</font>
<font color="green">  73.                  help_text='', error_messages=None, show_hidden_initial=False,</font>
<font color="green">  74.                  validators=[], localize=False, disabled=False, label_suffix=None):</font>
<font color="black">  75.         # required -- Boolean that specifies whether the field is required.</font>
<font color="black">  76.         #             True by default.</font>
<font color="black">  77.         # widget -- A Widget class, or instance of a Widget class, that should</font>
<font color="black">  78.         #           be used for this Field when displaying it. Each Field has a</font>
<font color="black">  79.         #           default Widget that it'll use if you don't specify this. In</font>
<font color="black">  80.         #           most cases, the default widget is TextInput.</font>
<font color="black">  81.         # label -- A verbose name for this field, for use in displaying this</font>
<font color="black">  82.         #          field in a form. By default, Django will use a &quot;pretty&quot;</font>
<font color="black">  83.         #          version of the form field name, if the Field is part of a</font>
<font color="black">  84.         #          Form.</font>
<font color="black">  85.         # initial -- A value to use in this Field's initial display. This value</font>
<font color="black">  86.         #            is *not* used as a fallback if data isn't given.</font>
<font color="black">  87.         # help_text -- An optional string to use as &quot;help text&quot; for this Field.</font>
<font color="black">  88.         # error_messages -- An optional dictionary to override the default</font>
<font color="black">  89.         #                   messages that the field will raise.</font>
<font color="black">  90.         # show_hidden_initial -- Boolean that specifies if it is needed to render a</font>
<font color="black">  91.         #                        hidden widget with initial value after widget.</font>
<font color="black">  92.         # validators -- List of additional validators to use</font>
<font color="black">  93.         # localize -- Boolean that specifies if the field should be localized.</font>
<font color="black">  94.         # disabled -- Boolean that specifies whether the field is disabled, that</font>
<font color="black">  95.         #             is its widget is shown in the form but not editable.</font>
<font color="black">  96.         # label_suffix -- Suffix to be added to the label. Overrides</font>
<font color="black">  97.         #                 form's label_suffix.</font>
<font color="green">  98.         self.required, self.label, self.initial = required, label, initial</font>
<font color="green">  99.         self.show_hidden_initial = show_hidden_initial</font>
<font color="green"> 100.         self.help_text = help_text</font>
<font color="green"> 101.         self.disabled = disabled</font>
<font color="green"> 102.         self.label_suffix = label_suffix</font>
<font color="green"> 103.         widget = widget or self.widget</font>
<font color="green"> 104.         if isinstance(widget, type):</font>
<font color="green"> 105.             widget = widget()</font>
<font color="black"> 106. </font>
<font color="black"> 107.         # Trigger the localization machinery if needed.</font>
<font color="green"> 108.         self.localize = localize</font>
<font color="green"> 109.         if self.localize:</font>
<font color="red"> 110.             widget.is_localized = True</font>
<font color="black"> 111. </font>
<font color="black"> 112.         # Let the widget know whether it should display as required.</font>
<font color="green"> 113.         widget.is_required = self.required</font>
<font color="black"> 114. </font>
<font color="black"> 115.         # Hook into self.widget_attrs() for any Field-specific HTML attributes.</font>
<font color="green"> 116.         extra_attrs = self.widget_attrs(widget)</font>
<font color="green"> 117.         if extra_attrs:</font>
<font color="green"> 118.             widget.attrs.update(extra_attrs)</font>
<font color="black"> 119. </font>
<font color="green"> 120.         self.widget = widget</font>
<font color="black"> 121. </font>
<font color="black"> 122.         # Increase the creation counter, and save our local copy.</font>
<font color="green"> 123.         self.creation_counter = Field.creation_counter</font>
<font color="green"> 124.         Field.creation_counter += 1</font>
<font color="black"> 125. </font>
<font color="green"> 126.         messages = {}</font>
<font color="green"> 127.         for c in reversed(self.__class__.__mro__):</font>
<font color="green"> 128.             messages.update(getattr(c, 'default_error_messages', {}))</font>
<font color="green"> 129.         messages.update(error_messages or {})</font>
<font color="green"> 130.         self.error_messages = messages</font>
<font color="black"> 131. </font>
<font color="green"> 132.         self.validators = self.default_validators + validators</font>
<font color="green"> 133.         super(Field, self).__init__()</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def prepare_value(self, value):</font>
<font color="red"> 136.         return value</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def to_python(self, value):</font>
<font color="red"> 139.         return value</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def validate(self, value):</font>
<font color="red"> 142.         if value in self.empty_values and self.required:</font>
<font color="red"> 143.             raise ValidationError(self.error_messages['required'], code='required')</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def run_validators(self, value):</font>
<font color="red"> 146.         if value in self.empty_values:</font>
<font color="red"> 147.             return</font>
<font color="red"> 148.         errors = []</font>
<font color="red"> 149.         for v in self.validators:</font>
<font color="red"> 150.             try:</font>
<font color="red"> 151.                 v(value)</font>
<font color="red"> 152.             except ValidationError as e:</font>
<font color="red"> 153.                 if hasattr(e, 'code') and e.code in self.error_messages:</font>
<font color="red"> 154.                     e.message = self.error_messages[e.code]</font>
<font color="red"> 155.                 errors.extend(e.error_list)</font>
<font color="red"> 156.         if errors:</font>
<font color="red"> 157.             raise ValidationError(errors)</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def clean(self, value):</font>
<font color="black"> 160.         &quot;&quot;&quot;</font>
<font color="black"> 161.         Validates the given value and returns its &quot;cleaned&quot; value as an</font>
<font color="black"> 162.         appropriate Python object.</font>
<font color="black"> 163. </font>
<font color="black"> 164.         Raises ValidationError for any errors.</font>
<font color="black"> 165.         &quot;&quot;&quot;</font>
<font color="red"> 166.         value = self.to_python(value)</font>
<font color="red"> 167.         self.validate(value)</font>
<font color="red"> 168.         self.run_validators(value)</font>
<font color="red"> 169.         return value</font>
<font color="black"> 170. </font>
<font color="green"> 171.     def bound_data(self, data, initial):</font>
<font color="black"> 172.         &quot;&quot;&quot;</font>
<font color="black"> 173.         Return the value that should be shown for this field on render of a</font>
<font color="black"> 174.         bound form, given the submitted POST data for the field and the initial</font>
<font color="black"> 175.         data, if any.</font>
<font color="black"> 176. </font>
<font color="black"> 177.         For most fields, this will simply be data; FileFields need to handle it</font>
<font color="black"> 178.         a bit differently.</font>
<font color="black"> 179.         &quot;&quot;&quot;</font>
<font color="red"> 180.         return data</font>
<font color="black"> 181. </font>
<font color="green"> 182.     def widget_attrs(self, widget):</font>
<font color="black"> 183.         &quot;&quot;&quot;</font>
<font color="black"> 184.         Given a Widget instance (*not* a Widget class), returns a dictionary of</font>
<font color="black"> 185.         any HTML attributes that should be added to the Widget, based on this</font>
<font color="black"> 186.         Field.</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="green"> 188.         return {}</font>
<font color="black"> 189. </font>
<font color="green"> 190.     def has_changed(self, initial, data):</font>
<font color="black"> 191.         &quot;&quot;&quot;</font>
<font color="black"> 192.         Return True if data differs from initial.</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="black"> 194.         # For purposes of seeing whether something has changed, None is</font>
<font color="black"> 195.         # the same as an empty string, if the data or initial value we get</font>
<font color="black"> 196.         # is None, replace it w/ ''.</font>
<font color="red"> 197.         initial_value = initial if initial is not None else ''</font>
<font color="red"> 198.         try:</font>
<font color="red"> 199.             data = self.to_python(data)</font>
<font color="red"> 200.             if hasattr(self, '_coerce'):</font>
<font color="red"> 201.                 data = self._coerce(data)</font>
<font color="red"> 202.                 initial_value = self._coerce(initial_value)</font>
<font color="red"> 203.         except ValidationError:</font>
<font color="red"> 204.             return True</font>
<font color="red"> 205.         data_value = data if data is not None else ''</font>
<font color="red"> 206.         return initial_value != data_value</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def get_bound_field(self, form, field_name):</font>
<font color="black"> 209.         &quot;&quot;&quot;</font>
<font color="black"> 210.         Return a BoundField instance that will be used when accessing the form</font>
<font color="black"> 211.         field in a template.</font>
<font color="black"> 212.         &quot;&quot;&quot;</font>
<font color="red"> 213.         return BoundField(form, self, field_name)</font>
<font color="black"> 214. </font>
<font color="green"> 215.     def __deepcopy__(self, memo):</font>
<font color="red"> 216.         result = copy.copy(self)</font>
<font color="red"> 217.         memo[id(self)] = result</font>
<font color="red"> 218.         result.widget = copy.deepcopy(self.widget, memo)</font>
<font color="red"> 219.         result.validators = self.validators[:]</font>
<font color="red"> 220.         return result</font>
<font color="black"> 221. </font>
<font color="black"> 222. </font>
<font color="green"> 223. class CharField(Field):</font>
<font color="green"> 224.     def __init__(self, max_length=None, min_length=None, strip=True, *args, **kwargs):</font>
<font color="green"> 225.         self.max_length = max_length</font>
<font color="green"> 226.         self.min_length = min_length</font>
<font color="green"> 227.         self.strip = strip</font>
<font color="green"> 228.         super(CharField, self).__init__(*args, **kwargs)</font>
<font color="green"> 229.         if min_length is not None:</font>
<font color="red"> 230.             self.validators.append(validators.MinLengthValidator(int(min_length)))</font>
<font color="green"> 231.         if max_length is not None:</font>
<font color="green"> 232.             self.validators.append(validators.MaxLengthValidator(int(max_length)))</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def to_python(self, value):</font>
<font color="black"> 235.         &quot;Returns a Unicode object.&quot;</font>
<font color="red"> 236.         if value in self.empty_values:</font>
<font color="red"> 237.             return ''</font>
<font color="red"> 238.         value = force_text(value)</font>
<font color="red"> 239.         if self.strip:</font>
<font color="red"> 240.             value = value.strip()</font>
<font color="red"> 241.         return value</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def widget_attrs(self, widget):</font>
<font color="green"> 244.         attrs = super(CharField, self).widget_attrs(widget)</font>
<font color="green"> 245.         if self.max_length is not None:</font>
<font color="black"> 246.             # The HTML attribute is maxlength, not max_length.</font>
<font color="green"> 247.             attrs.update({'maxlength': str(self.max_length)})</font>
<font color="green"> 248.         return attrs</font>
<font color="black"> 249. </font>
<font color="black"> 250. </font>
<font color="green"> 251. class IntegerField(Field):</font>
<font color="green"> 252.     widget = NumberInput</font>
<font color="green"> 253.     default_error_messages = {</font>
<font color="green"> 254.         'invalid': _('Enter a whole number.'),</font>
<font color="black"> 255.     }</font>
<font color="green"> 256.     re_decimal = re.compile(r'\.0*\s*$')</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def __init__(self, max_value=None, min_value=None, *args, **kwargs):</font>
<font color="red"> 259.         self.max_value, self.min_value = max_value, min_value</font>
<font color="red"> 260.         if kwargs.get('localize') and self.widget == NumberInput:</font>
<font color="black"> 261.             # Localized number input is not well supported on most browsers</font>
<font color="red"> 262.             kwargs.setdefault('widget', super(IntegerField, self).widget)</font>
<font color="red"> 263.         super(IntegerField, self).__init__(*args, **kwargs)</font>
<font color="black"> 264. </font>
<font color="red"> 265.         if max_value is not None:</font>
<font color="red"> 266.             self.validators.append(validators.MaxValueValidator(max_value))</font>
<font color="red"> 267.         if min_value is not None:</font>
<font color="red"> 268.             self.validators.append(validators.MinValueValidator(min_value))</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def to_python(self, value):</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="black"> 272.         Validates that int() can be called on the input. Returns the result</font>
<font color="black"> 273.         of int(). Returns None for empty values.</font>
<font color="black"> 274.         &quot;&quot;&quot;</font>
<font color="red"> 275.         value = super(IntegerField, self).to_python(value)</font>
<font color="red"> 276.         if value in self.empty_values:</font>
<font color="red"> 277.             return None</font>
<font color="red"> 278.         if self.localize:</font>
<font color="red"> 279.             value = formats.sanitize_separators(value)</font>
<font color="black"> 280.         # Strip trailing decimal and zeros.</font>
<font color="red"> 281.         try:</font>
<font color="red"> 282.             value = int(self.re_decimal.sub('', str(value)))</font>
<font color="red"> 283.         except (ValueError, TypeError):</font>
<font color="red"> 284.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="red"> 285.         return value</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def widget_attrs(self, widget):</font>
<font color="red"> 288.         attrs = super(IntegerField, self).widget_attrs(widget)</font>
<font color="red"> 289.         if isinstance(widget, NumberInput):</font>
<font color="red"> 290.             if self.min_value is not None:</font>
<font color="red"> 291.                 attrs['min'] = self.min_value</font>
<font color="red"> 292.             if self.max_value is not None:</font>
<font color="red"> 293.                 attrs['max'] = self.max_value</font>
<font color="red"> 294.         return attrs</font>
<font color="black"> 295. </font>
<font color="black"> 296. </font>
<font color="green"> 297. class FloatField(IntegerField):</font>
<font color="green"> 298.     default_error_messages = {</font>
<font color="green"> 299.         'invalid': _('Enter a number.'),</font>
<font color="black"> 300.     }</font>
<font color="black"> 301. </font>
<font color="green"> 302.     def to_python(self, value):</font>
<font color="black"> 303.         &quot;&quot;&quot;</font>
<font color="black"> 304.         Validates that float() can be called on the input. Returns the result</font>
<font color="black"> 305.         of float(). Returns None for empty values.</font>
<font color="black"> 306.         &quot;&quot;&quot;</font>
<font color="red"> 307.         value = super(IntegerField, self).to_python(value)</font>
<font color="red"> 308.         if value in self.empty_values:</font>
<font color="red"> 309.             return None</font>
<font color="red"> 310.         if self.localize:</font>
<font color="red"> 311.             value = formats.sanitize_separators(value)</font>
<font color="red"> 312.         try:</font>
<font color="red"> 313.             value = float(value)</font>
<font color="red"> 314.         except (ValueError, TypeError):</font>
<font color="red"> 315.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="red"> 316.         return value</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def validate(self, value):</font>
<font color="red"> 319.         super(FloatField, self).validate(value)</font>
<font color="black"> 320. </font>
<font color="black"> 321.         # Check for NaN (which is the only thing not equal to itself) and +/- infinity</font>
<font color="red"> 322.         if value != value or value in (Decimal('Inf'), Decimal('-Inf')):</font>
<font color="red"> 323.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="black"> 324. </font>
<font color="red"> 325.         return value</font>
<font color="black"> 326. </font>
<font color="green"> 327.     def widget_attrs(self, widget):</font>
<font color="red"> 328.         attrs = super(FloatField, self).widget_attrs(widget)</font>
<font color="red"> 329.         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:</font>
<font color="red"> 330.             attrs.setdefault('step', 'any')</font>
<font color="red"> 331.         return attrs</font>
<font color="black"> 332. </font>
<font color="black"> 333. </font>
<font color="green"> 334. class DecimalField(IntegerField):</font>
<font color="green"> 335.     default_error_messages = {</font>
<font color="green"> 336.         'invalid': _('Enter a number.'),</font>
<font color="black"> 337.     }</font>
<font color="black"> 338. </font>
<font color="green"> 339.     def __init__(self, max_value=None, min_value=None, max_digits=None, decimal_places=None, *args, **kwargs):</font>
<font color="red"> 340.         self.max_digits, self.decimal_places = max_digits, decimal_places</font>
<font color="red"> 341.         super(DecimalField, self).__init__(max_value, min_value, *args, **kwargs)</font>
<font color="red"> 342.         self.validators.append(validators.DecimalValidator(max_digits, decimal_places))</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def to_python(self, value):</font>
<font color="black"> 345.         &quot;&quot;&quot;</font>
<font color="black"> 346.         Validates that the input is a decimal number. Returns a Decimal</font>
<font color="black"> 347.         instance. Returns None for empty values. Ensures that there are no more</font>
<font color="black"> 348.         than max_digits in the number, and no more than decimal_places digits</font>
<font color="black"> 349.         after the decimal point.</font>
<font color="black"> 350.         &quot;&quot;&quot;</font>
<font color="red"> 351.         if value in self.empty_values:</font>
<font color="red"> 352.             return None</font>
<font color="red"> 353.         if self.localize:</font>
<font color="red"> 354.             value = formats.sanitize_separators(value)</font>
<font color="red"> 355.         value = smart_text(value).strip()</font>
<font color="red"> 356.         try:</font>
<font color="red"> 357.             value = Decimal(value)</font>
<font color="red"> 358.         except DecimalException:</font>
<font color="red"> 359.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="red"> 360.         return value</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def validate(self, value):</font>
<font color="red"> 363.         super(DecimalField, self).validate(value)</font>
<font color="red"> 364.         if value in self.empty_values:</font>
<font color="red"> 365.             return</font>
<font color="black"> 366.         # Check for NaN, Inf and -Inf values. We can't compare directly for NaN,</font>
<font color="black"> 367.         # since it is never equal to itself. However, NaN is the only value that</font>
<font color="black"> 368.         # isn't equal to itself, so we can use this to identify NaN</font>
<font color="red"> 369.         if value != value or value == Decimal(&quot;Inf&quot;) or value == Decimal(&quot;-Inf&quot;):</font>
<font color="red"> 370.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def widget_attrs(self, widget):</font>
<font color="red"> 373.         attrs = super(DecimalField, self).widget_attrs(widget)</font>
<font color="red"> 374.         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:</font>
<font color="red"> 375.             if self.decimal_places is not None:</font>
<font color="black"> 376.                 # Use exponential notation for small values since they might</font>
<font color="black"> 377.                 # be parsed as 0 otherwise. ref #20765</font>
<font color="red"> 378.                 step = str(Decimal('1') / 10 ** self.decimal_places).lower()</font>
<font color="black"> 379.             else:</font>
<font color="red"> 380.                 step = 'any'</font>
<font color="red"> 381.             attrs.setdefault('step', step)</font>
<font color="red"> 382.         return attrs</font>
<font color="black"> 383. </font>
<font color="black"> 384. </font>
<font color="green"> 385. class BaseTemporalField(Field):</font>
<font color="black"> 386. </font>
<font color="green"> 387.     def __init__(self, input_formats=None, *args, **kwargs):</font>
<font color="green"> 388.         super(BaseTemporalField, self).__init__(*args, **kwargs)</font>
<font color="green"> 389.         if input_formats is not None:</font>
<font color="red"> 390.             self.input_formats = input_formats</font>
<font color="black"> 391. </font>
<font color="green"> 392.     def to_python(self, value):</font>
<font color="black"> 393.         # Try to coerce the value to unicode.</font>
<font color="red"> 394.         unicode_value = force_text(value, strings_only=True)</font>
<font color="red"> 395.         if isinstance(unicode_value, six.text_type):</font>
<font color="red"> 396.             value = unicode_value.strip()</font>
<font color="black"> 397.         # If unicode, try to strptime against each input format.</font>
<font color="red"> 398.         if isinstance(value, six.text_type):</font>
<font color="red"> 399.             for format in self.input_formats:</font>
<font color="red"> 400.                 try:</font>
<font color="red"> 401.                     return self.strptime(value, format)</font>
<font color="red"> 402.                 except (ValueError, TypeError):</font>
<font color="red"> 403.                     continue</font>
<font color="red"> 404.         raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def strptime(self, value, format):</font>
<font color="red"> 407.         raise NotImplementedError('Subclasses must define this method.')</font>
<font color="black"> 408. </font>
<font color="black"> 409. </font>
<font color="green"> 410. class DateField(BaseTemporalField):</font>
<font color="green"> 411.     widget = DateInput</font>
<font color="green"> 412.     input_formats = formats.get_format_lazy('DATE_INPUT_FORMATS')</font>
<font color="green"> 413.     default_error_messages = {</font>
<font color="green"> 414.         'invalid': _('Enter a valid date.'),</font>
<font color="black"> 415.     }</font>
<font color="black"> 416. </font>
<font color="green"> 417.     def to_python(self, value):</font>
<font color="black"> 418.         &quot;&quot;&quot;</font>
<font color="black"> 419.         Validates that the input can be converted to a date. Returns a Python</font>
<font color="black"> 420.         datetime.date object.</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="red"> 422.         if value in self.empty_values:</font>
<font color="red"> 423.             return None</font>
<font color="red"> 424.         if isinstance(value, datetime.datetime):</font>
<font color="red"> 425.             return value.date()</font>
<font color="red"> 426.         if isinstance(value, datetime.date):</font>
<font color="red"> 427.             return value</font>
<font color="red"> 428.         return super(DateField, self).to_python(value)</font>
<font color="black"> 429. </font>
<font color="green"> 430.     def strptime(self, value, format):</font>
<font color="red"> 431.         return datetime.datetime.strptime(force_str(value), format).date()</font>
<font color="black"> 432. </font>
<font color="black"> 433. </font>
<font color="green"> 434. class TimeField(BaseTemporalField):</font>
<font color="green"> 435.     widget = TimeInput</font>
<font color="green"> 436.     input_formats = formats.get_format_lazy('TIME_INPUT_FORMATS')</font>
<font color="green"> 437.     default_error_messages = {</font>
<font color="green"> 438.         'invalid': _('Enter a valid time.')</font>
<font color="black"> 439.     }</font>
<font color="black"> 440. </font>
<font color="green"> 441.     def to_python(self, value):</font>
<font color="black"> 442.         &quot;&quot;&quot;</font>
<font color="black"> 443.         Validates that the input can be converted to a time. Returns a Python</font>
<font color="black"> 444.         datetime.time object.</font>
<font color="black"> 445.         &quot;&quot;&quot;</font>
<font color="red"> 446.         if value in self.empty_values:</font>
<font color="red"> 447.             return None</font>
<font color="red"> 448.         if isinstance(value, datetime.time):</font>
<font color="red"> 449.             return value</font>
<font color="red"> 450.         return super(TimeField, self).to_python(value)</font>
<font color="black"> 451. </font>
<font color="green"> 452.     def strptime(self, value, format):</font>
<font color="red"> 453.         return datetime.datetime.strptime(force_str(value), format).time()</font>
<font color="black"> 454. </font>
<font color="black"> 455. </font>
<font color="green"> 456. class DateTimeField(BaseTemporalField):</font>
<font color="green"> 457.     widget = DateTimeInput</font>
<font color="green"> 458.     input_formats = formats.get_format_lazy('DATETIME_INPUT_FORMATS')</font>
<font color="green"> 459.     default_error_messages = {</font>
<font color="green"> 460.         'invalid': _('Enter a valid date/time.'),</font>
<font color="black"> 461.     }</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def prepare_value(self, value):</font>
<font color="red"> 464.         if isinstance(value, datetime.datetime):</font>
<font color="red"> 465.             value = to_current_timezone(value)</font>
<font color="red"> 466.         return value</font>
<font color="black"> 467. </font>
<font color="green"> 468.     def to_python(self, value):</font>
<font color="black"> 469.         &quot;&quot;&quot;</font>
<font color="black"> 470.         Validates that the input can be converted to a datetime. Returns a</font>
<font color="black"> 471.         Python datetime.datetime object.</font>
<font color="black"> 472.         &quot;&quot;&quot;</font>
<font color="red"> 473.         if value in self.empty_values:</font>
<font color="red"> 474.             return None</font>
<font color="red"> 475.         if isinstance(value, datetime.datetime):</font>
<font color="red"> 476.             return from_current_timezone(value)</font>
<font color="red"> 477.         if isinstance(value, datetime.date):</font>
<font color="red"> 478.             result = datetime.datetime(value.year, value.month, value.day)</font>
<font color="red"> 479.             return from_current_timezone(result)</font>
<font color="red"> 480.         result = super(DateTimeField, self).to_python(value)</font>
<font color="red"> 481.         return from_current_timezone(result)</font>
<font color="black"> 482. </font>
<font color="green"> 483.     def strptime(self, value, format):</font>
<font color="red"> 484.         return datetime.datetime.strptime(force_str(value), format)</font>
<font color="black"> 485. </font>
<font color="black"> 486. </font>
<font color="green"> 487. class DurationField(Field):</font>
<font color="green"> 488.     default_error_messages = {</font>
<font color="green"> 489.         'invalid': _('Enter a valid duration.'),</font>
<font color="black"> 490.     }</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def prepare_value(self, value):</font>
<font color="red"> 493.         if isinstance(value, datetime.timedelta):</font>
<font color="red"> 494.             return duration_string(value)</font>
<font color="red"> 495.         return value</font>
<font color="black"> 496. </font>
<font color="green"> 497.     def to_python(self, value):</font>
<font color="red"> 498.         if value in self.empty_values:</font>
<font color="red"> 499.             return None</font>
<font color="red"> 500.         if isinstance(value, datetime.timedelta):</font>
<font color="red"> 501.             return value</font>
<font color="red"> 502.         value = parse_duration(value)</font>
<font color="red"> 503.         if value is None:</font>
<font color="red"> 504.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="red"> 505.         return value</font>
<font color="black"> 506. </font>
<font color="black"> 507. </font>
<font color="green"> 508. class RegexField(CharField):</font>
<font color="green"> 509.     def __init__(self, regex, max_length=None, min_length=None, error_message=None, *args, **kwargs):</font>
<font color="black"> 510.         &quot;&quot;&quot;</font>
<font color="black"> 511.         regex can be either a string or a compiled regular expression object.</font>
<font color="black"> 512.         error_message is an optional error message to use, if</font>
<font color="black"> 513.         'Enter a valid value' is too generic for you.</font>
<font color="black"> 514.         &quot;&quot;&quot;</font>
<font color="red"> 515.         kwargs.setdefault('strip', False)</font>
<font color="black"> 516.         # error_message is just kept for backwards compatibility:</font>
<font color="red"> 517.         if error_message is not None:</font>
<font color="red"> 518.             warnings.warn(</font>
<font color="red"> 519.                 &quot;The 'error_message' argument is deprecated. Use &quot;</font>
<font color="black"> 520.                 &quot;Field.error_messages['invalid'] instead.&quot;,</font>
<font color="red"> 521.                 RemovedInDjango110Warning, stacklevel=2</font>
<font color="black"> 522.             )</font>
<font color="red"> 523.             error_messages = kwargs.get('error_messages') or {}</font>
<font color="red"> 524.             error_messages['invalid'] = error_message</font>
<font color="red"> 525.             kwargs['error_messages'] = error_messages</font>
<font color="red"> 526.         super(RegexField, self).__init__(max_length, min_length, *args, **kwargs)</font>
<font color="red"> 527.         self._set_regex(regex)</font>
<font color="black"> 528. </font>
<font color="green"> 529.     def _get_regex(self):</font>
<font color="red"> 530.         return self._regex</font>
<font color="black"> 531. </font>
<font color="green"> 532.     def _set_regex(self, regex):</font>
<font color="red"> 533.         if isinstance(regex, six.string_types):</font>
<font color="red"> 534.             regex = re.compile(regex, re.UNICODE)</font>
<font color="red"> 535.         self._regex = regex</font>
<font color="red"> 536.         if hasattr(self, '_regex_validator') and self._regex_validator in self.validators:</font>
<font color="red"> 537.             self.validators.remove(self._regex_validator)</font>
<font color="red"> 538.         self._regex_validator = validators.RegexValidator(regex=regex)</font>
<font color="red"> 539.         self.validators.append(self._regex_validator)</font>
<font color="black"> 540. </font>
<font color="green"> 541.     regex = property(_get_regex, _set_regex)</font>
<font color="black"> 542. </font>
<font color="black"> 543. </font>
<font color="green"> 544. class EmailField(CharField):</font>
<font color="green"> 545.     widget = EmailInput</font>
<font color="green"> 546.     default_validators = [validators.validate_email]</font>
<font color="black"> 547. </font>
<font color="green"> 548.     def clean(self, value):</font>
<font color="red"> 549.         value = self.to_python(value).strip()</font>
<font color="red"> 550.         return super(EmailField, self).clean(value)</font>
<font color="black"> 551. </font>
<font color="black"> 552. </font>
<font color="green"> 553. class FileField(Field):</font>
<font color="green"> 554.     widget = ClearableFileInput</font>
<font color="green"> 555.     default_error_messages = {</font>
<font color="green"> 556.         'invalid': _(&quot;No file was submitted. Check the encoding type on the form.&quot;),</font>
<font color="green"> 557.         'missing': _(&quot;No file was submitted.&quot;),</font>
<font color="green"> 558.         'empty': _(&quot;The submitted file is empty.&quot;),</font>
<font color="green"> 559.         'max_length': ungettext_lazy(</font>
<font color="green"> 560.             'Ensure this filename has at most %(max)d character (it has %(length)d).',</font>
<font color="green"> 561.             'Ensure this filename has at most %(max)d characters (it has %(length)d).',</font>
<font color="green"> 562.             'max'),</font>
<font color="green"> 563.         'contradiction': _('Please either submit a file or check the clear checkbox, not both.')</font>
<font color="black"> 564.     }</font>
<font color="black"> 565. </font>
<font color="green"> 566.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 567.         self.max_length = kwargs.pop('max_length', None)</font>
<font color="red"> 568.         self.allow_empty_file = kwargs.pop('allow_empty_file', False)</font>
<font color="red"> 569.         super(FileField, self).__init__(*args, **kwargs)</font>
<font color="black"> 570. </font>
<font color="green"> 571.     def to_python(self, data):</font>
<font color="red"> 572.         if data in self.empty_values:</font>
<font color="red"> 573.             return None</font>
<font color="black"> 574. </font>
<font color="black"> 575.         # UploadedFile objects should have name and size attributes.</font>
<font color="red"> 576.         try:</font>
<font color="red"> 577.             file_name = data.name</font>
<font color="red"> 578.             file_size = data.size</font>
<font color="red"> 579.         except AttributeError:</font>
<font color="red"> 580.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="black"> 581. </font>
<font color="red"> 582.         if self.max_length is not None and len(file_name) &gt; self.max_length:</font>
<font color="red"> 583.             params = {'max': self.max_length, 'length': len(file_name)}</font>
<font color="red"> 584.             raise ValidationError(self.error_messages['max_length'], code='max_length', params=params)</font>
<font color="red"> 585.         if not file_name:</font>
<font color="red"> 586.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="red"> 587.         if not self.allow_empty_file and not file_size:</font>
<font color="red"> 588.             raise ValidationError(self.error_messages['empty'], code='empty')</font>
<font color="black"> 589. </font>
<font color="red"> 590.         return data</font>
<font color="black"> 591. </font>
<font color="green"> 592.     def clean(self, data, initial=None):</font>
<font color="black"> 593.         # If the widget got contradictory inputs, we raise a validation error</font>
<font color="red"> 594.         if data is FILE_INPUT_CONTRADICTION:</font>
<font color="red"> 595.             raise ValidationError(self.error_messages['contradiction'], code='contradiction')</font>
<font color="black"> 596.         # False means the field value should be cleared; further validation is</font>
<font color="black"> 597.         # not needed.</font>
<font color="red"> 598.         if data is False:</font>
<font color="red"> 599.             if not self.required:</font>
<font color="red"> 600.                 return False</font>
<font color="black"> 601.             # If the field is required, clearing is not possible (the widget</font>
<font color="black"> 602.             # shouldn't return False data in that case anyway). False is not</font>
<font color="black"> 603.             # in self.empty_value; if a False value makes it this far</font>
<font color="black"> 604.             # it should be validated from here on out as None (so it will be</font>
<font color="black"> 605.             # caught by the required check).</font>
<font color="red"> 606.             data = None</font>
<font color="red"> 607.         if not data and initial:</font>
<font color="red"> 608.             return initial</font>
<font color="red"> 609.         return super(FileField, self).clean(data)</font>
<font color="black"> 610. </font>
<font color="green"> 611.     def bound_data(self, data, initial):</font>
<font color="red"> 612.         if data in (None, FILE_INPUT_CONTRADICTION):</font>
<font color="red"> 613.             return initial</font>
<font color="red"> 614.         return data</font>
<font color="black"> 615. </font>
<font color="green"> 616.     def has_changed(self, initial, data):</font>
<font color="red"> 617.         if data is None:</font>
<font color="red"> 618.             return False</font>
<font color="red"> 619.         return True</font>
<font color="black"> 620. </font>
<font color="black"> 621. </font>
<font color="green"> 622. class ImageField(FileField):</font>
<font color="green"> 623.     default_error_messages = {</font>
<font color="green"> 624.         'invalid_image': _(</font>
<font color="green"> 625.             &quot;Upload a valid image. The file you uploaded was either not an &quot;</font>
<font color="black"> 626.             &quot;image or a corrupted image.&quot;</font>
<font color="black"> 627.         ),</font>
<font color="black"> 628.     }</font>
<font color="black"> 629. </font>
<font color="green"> 630.     def to_python(self, data):</font>
<font color="black"> 631.         &quot;&quot;&quot;</font>
<font color="black"> 632.         Checks that the file-upload field data contains a valid image (GIF, JPG,</font>
<font color="black"> 633.         PNG, possibly others -- whatever the Python Imaging Library supports).</font>
<font color="black"> 634.         &quot;&quot;&quot;</font>
<font color="red"> 635.         f = super(ImageField, self).to_python(data)</font>
<font color="red"> 636.         if f is None:</font>
<font color="red"> 637.             return None</font>
<font color="black"> 638. </font>
<font color="red"> 639.         from PIL import Image</font>
<font color="black"> 640. </font>
<font color="black"> 641.         # We need to get a file object for Pillow. We might have a path or we might</font>
<font color="black"> 642.         # have to read the data into memory.</font>
<font color="red"> 643.         if hasattr(data, 'temporary_file_path'):</font>
<font color="red"> 644.             file = data.temporary_file_path()</font>
<font color="black"> 645.         else:</font>
<font color="red"> 646.             if hasattr(data, 'read'):</font>
<font color="red"> 647.                 file = BytesIO(data.read())</font>
<font color="black"> 648.             else:</font>
<font color="red"> 649.                 file = BytesIO(data['content'])</font>
<font color="black"> 650. </font>
<font color="red"> 651.         try:</font>
<font color="black"> 652.             # load() could spot a truncated JPEG, but it loads the entire</font>
<font color="black"> 653.             # image in memory, which is a DoS vector. See #3848 and #18520.</font>
<font color="red"> 654.             image = Image.open(file)</font>
<font color="black"> 655.             # verify() must be called immediately after the constructor.</font>
<font color="red"> 656.             image.verify()</font>
<font color="black"> 657. </font>
<font color="black"> 658.             # Annotating so subclasses can reuse it for their own validation</font>
<font color="red"> 659.             f.image = image</font>
<font color="black"> 660.             # Pillow doesn't detect the MIME type of all formats. In those</font>
<font color="black"> 661.             # cases, content_type will be None.</font>
<font color="red"> 662.             f.content_type = Image.MIME.get(image.format)</font>
<font color="red"> 663.         except Exception:</font>
<font color="black"> 664.             # Pillow doesn't recognize it as an image.</font>
<font color="red"> 665.             six.reraise(ValidationError, ValidationError(</font>
<font color="red"> 666.                 self.error_messages['invalid_image'],</font>
<font color="red"> 667.                 code='invalid_image',</font>
<font color="red"> 668.             ), sys.exc_info()[2])</font>
<font color="red"> 669.         if hasattr(f, 'seek') and callable(f.seek):</font>
<font color="red"> 670.             f.seek(0)</font>
<font color="red"> 671.         return f</font>
<font color="black"> 672. </font>
<font color="black"> 673. </font>
<font color="green"> 674. class URLField(CharField):</font>
<font color="green"> 675.     widget = URLInput</font>
<font color="green"> 676.     default_error_messages = {</font>
<font color="green"> 677.         'invalid': _('Enter a valid URL.'),</font>
<font color="black"> 678.     }</font>
<font color="green"> 679.     default_validators = [validators.URLValidator()]</font>
<font color="black"> 680. </font>
<font color="green"> 681.     def to_python(self, value):</font>
<font color="black"> 682. </font>
<font color="red"> 683.         def split_url(url):</font>
<font color="black"> 684.             &quot;&quot;&quot;</font>
<font color="black"> 685.             Returns a list of url parts via ``urlparse.urlsplit`` (or raises a</font>
<font color="black"> 686.             ``ValidationError`` exception for certain).</font>
<font color="black"> 687.             &quot;&quot;&quot;</font>
<font color="red"> 688.             try:</font>
<font color="red"> 689.                 return list(urlsplit(url))</font>
<font color="red"> 690.             except ValueError:</font>
<font color="black"> 691.                 # urlparse.urlsplit can raise a ValueError with some</font>
<font color="black"> 692.                 # misformatted URLs.</font>
<font color="red"> 693.                 raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="black"> 694. </font>
<font color="red"> 695.         value = super(URLField, self).to_python(value)</font>
<font color="red"> 696.         if value:</font>
<font color="red"> 697.             url_fields = split_url(value)</font>
<font color="red"> 698.             if not url_fields[0]:</font>
<font color="black"> 699.                 # If no URL scheme given, assume http://</font>
<font color="red"> 700.                 url_fields[0] = 'http'</font>
<font color="red"> 701.             if not url_fields[1]:</font>
<font color="black"> 702.                 # Assume that if no domain is provided, that the path segment</font>
<font color="black"> 703.                 # contains the domain.</font>
<font color="red"> 704.                 url_fields[1] = url_fields[2]</font>
<font color="red"> 705.                 url_fields[2] = ''</font>
<font color="black"> 706.                 # Rebuild the url_fields list, since the domain segment may now</font>
<font color="black"> 707.                 # contain the path too.</font>
<font color="red"> 708.                 url_fields = split_url(urlunsplit(url_fields))</font>
<font color="red"> 709.             value = urlunsplit(url_fields)</font>
<font color="red"> 710.         return value</font>
<font color="black"> 711. </font>
<font color="green"> 712.     def clean(self, value):</font>
<font color="red"> 713.         value = self.to_python(value).strip()</font>
<font color="red"> 714.         return super(URLField, self).clean(value)</font>
<font color="black"> 715. </font>
<font color="black"> 716. </font>
<font color="green"> 717. class BooleanField(Field):</font>
<font color="green"> 718.     widget = CheckboxInput</font>
<font color="black"> 719. </font>
<font color="green"> 720.     def to_python(self, value):</font>
<font color="black"> 721.         &quot;&quot;&quot;Returns a Python boolean object.&quot;&quot;&quot;</font>
<font color="black"> 722.         # Explicitly check for the string 'False', which is what a hidden field</font>
<font color="black"> 723.         # will submit for False. Also check for '0', since this is what</font>
<font color="black"> 724.         # RadioSelect will provide. Because bool(&quot;True&quot;) == bool('1') == True,</font>
<font color="black"> 725.         # we don't need to handle that explicitly.</font>
<font color="red"> 726.         if isinstance(value, six.string_types) and value.lower() in ('false', '0'):</font>
<font color="red"> 727.             value = False</font>
<font color="black"> 728.         else:</font>
<font color="red"> 729.             value = bool(value)</font>
<font color="red"> 730.         return super(BooleanField, self).to_python(value)</font>
<font color="black"> 731. </font>
<font color="green"> 732.     def validate(self, value):</font>
<font color="red"> 733.         if not value and self.required:</font>
<font color="red"> 734.             raise ValidationError(self.error_messages['required'], code='required')</font>
<font color="black"> 735. </font>
<font color="green"> 736.     def has_changed(self, initial, data):</font>
<font color="black"> 737.         # Sometimes data or initial could be None or '' which should be the</font>
<font color="black"> 738.         # same thing as False.</font>
<font color="red"> 739.         if initial == 'False':</font>
<font color="black"> 740.             # show_hidden_initial may have transformed False to 'False'</font>
<font color="red"> 741.             initial = False</font>
<font color="red"> 742.         return bool(initial) != bool(data)</font>
<font color="black"> 743. </font>
<font color="black"> 744. </font>
<font color="green"> 745. class NullBooleanField(BooleanField):</font>
<font color="black"> 746.     &quot;&quot;&quot;</font>
<font color="black"> 747.     A field whose valid values are None, True and False. Invalid values are</font>
<font color="black"> 748.     cleaned to None.</font>
<font color="green"> 749.     &quot;&quot;&quot;</font>
<font color="green"> 750.     widget = NullBooleanSelect</font>
<font color="black"> 751. </font>
<font color="green"> 752.     def to_python(self, value):</font>
<font color="black"> 753.         &quot;&quot;&quot;</font>
<font color="black"> 754.         Explicitly checks for the string 'True' and 'False', which is what a</font>
<font color="black"> 755.         hidden field will submit for True and False, for 'true' and 'false',</font>
<font color="black"> 756.         which are likely to be returned by JavaScript serializations of forms,</font>
<font color="black"> 757.         and for '1' and '0', which is what a RadioField will submit. Unlike</font>
<font color="black"> 758.         the Booleanfield we need to explicitly check for True, because we are</font>
<font color="black"> 759.         not using the bool() function</font>
<font color="black"> 760.         &quot;&quot;&quot;</font>
<font color="red"> 761.         if value in (True, 'True', 'true', '1'):</font>
<font color="red"> 762.             return True</font>
<font color="red"> 763.         elif value in (False, 'False', 'false', '0'):</font>
<font color="red"> 764.             return False</font>
<font color="black"> 765.         else:</font>
<font color="red"> 766.             return None</font>
<font color="black"> 767. </font>
<font color="green"> 768.     def validate(self, value):</font>
<font color="red"> 769.         pass</font>
<font color="black"> 770. </font>
<font color="green"> 771.     def has_changed(self, initial, data):</font>
<font color="black"> 772.         # None (unknown) and False (No) are not the same</font>
<font color="red"> 773.         if initial is not None:</font>
<font color="red"> 774.             initial = bool(initial)</font>
<font color="red"> 775.         if data is not None:</font>
<font color="red"> 776.             data = bool(data)</font>
<font color="red"> 777.         return initial != data</font>
<font color="black"> 778. </font>
<font color="black"> 779. </font>
<font color="green"> 780. class CallableChoiceIterator(object):</font>
<font color="green"> 781.     def __init__(self, choices_func):</font>
<font color="red"> 782.         self.choices_func = choices_func</font>
<font color="black"> 783. </font>
<font color="green"> 784.     def __iter__(self):</font>
<font color="red"> 785.         for e in self.choices_func():</font>
<font color="red"> 786.             yield e</font>
<font color="black"> 787. </font>
<font color="black"> 788. </font>
<font color="green"> 789. class ChoiceField(Field):</font>
<font color="green"> 790.     widget = Select</font>
<font color="green"> 791.     default_error_messages = {</font>
<font color="green"> 792.         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),</font>
<font color="black"> 793.     }</font>
<font color="black"> 794. </font>
<font color="green"> 795.     def __init__(self, choices=(), required=True, widget=None, label=None,</font>
<font color="green"> 796.                  initial=None, help_text='', *args, **kwargs):</font>
<font color="green"> 797.         super(ChoiceField, self).__init__(required=required, widget=widget, label=label,</font>
<font color="green"> 798.                                         initial=initial, help_text=help_text, *args, **kwargs)</font>
<font color="green"> 799.         self.choices = choices</font>
<font color="black"> 800. </font>
<font color="green"> 801.     def __deepcopy__(self, memo):</font>
<font color="red"> 802.         result = super(ChoiceField, self).__deepcopy__(memo)</font>
<font color="red"> 803.         result._choices = copy.deepcopy(self._choices, memo)</font>
<font color="red"> 804.         return result</font>
<font color="black"> 805. </font>
<font color="green"> 806.     def _get_choices(self):</font>
<font color="red"> 807.         return self._choices</font>
<font color="black"> 808. </font>
<font color="green"> 809.     def _set_choices(self, value):</font>
<font color="black"> 810.         # Setting choices also sets the choices on the widget.</font>
<font color="black"> 811.         # choices can be any iterable, but we call list() on it because</font>
<font color="black"> 812.         # it will be consumed more than once.</font>
<font color="green"> 813.         if callable(value):</font>
<font color="red"> 814.             value = CallableChoiceIterator(value)</font>
<font color="black"> 815.         else:</font>
<font color="green"> 816.             value = list(value)</font>
<font color="black"> 817. </font>
<font color="green"> 818.         self._choices = self.widget.choices = value</font>
<font color="black"> 819. </font>
<font color="green"> 820.     choices = property(_get_choices, _set_choices)</font>
<font color="black"> 821. </font>
<font color="green"> 822.     def to_python(self, value):</font>
<font color="black"> 823.         &quot;Returns a Unicode object.&quot;</font>
<font color="red"> 824.         if value in self.empty_values:</font>
<font color="red"> 825.             return ''</font>
<font color="red"> 826.         return smart_text(value)</font>
<font color="black"> 827. </font>
<font color="green"> 828.     def validate(self, value):</font>
<font color="black"> 829.         &quot;&quot;&quot;</font>
<font color="black"> 830.         Validates that the input is in self.choices.</font>
<font color="black"> 831.         &quot;&quot;&quot;</font>
<font color="red"> 832.         super(ChoiceField, self).validate(value)</font>
<font color="red"> 833.         if value and not self.valid_value(value):</font>
<font color="red"> 834.             raise ValidationError(</font>
<font color="red"> 835.                 self.error_messages['invalid_choice'],</font>
<font color="red"> 836.                 code='invalid_choice',</font>
<font color="red"> 837.                 params={'value': value},</font>
<font color="black"> 838.             )</font>
<font color="black"> 839. </font>
<font color="green"> 840.     def valid_value(self, value):</font>
<font color="black"> 841.         &quot;Check to see if the provided value is a valid choice&quot;</font>
<font color="red"> 842.         text_value = force_text(value)</font>
<font color="red"> 843.         for k, v in self.choices:</font>
<font color="red"> 844.             if isinstance(v, (list, tuple)):</font>
<font color="black"> 845.                 # This is an optgroup, so look inside the group for options</font>
<font color="red"> 846.                 for k2, v2 in v:</font>
<font color="red"> 847.                     if value == k2 or text_value == force_text(k2):</font>
<font color="red"> 848.                         return True</font>
<font color="black"> 849.             else:</font>
<font color="red"> 850.                 if value == k or text_value == force_text(k):</font>
<font color="red"> 851.                     return True</font>
<font color="red"> 852.         return False</font>
<font color="black"> 853. </font>
<font color="black"> 854. </font>
<font color="green"> 855. class TypedChoiceField(ChoiceField):</font>
<font color="green"> 856.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 857.         self.coerce = kwargs.pop('coerce', lambda val: val)</font>
<font color="red"> 858.         self.empty_value = kwargs.pop('empty_value', '')</font>
<font color="red"> 859.         super(TypedChoiceField, self).__init__(*args, **kwargs)</font>
<font color="black"> 860. </font>
<font color="green"> 861.     def _coerce(self, value):</font>
<font color="black"> 862.         &quot;&quot;&quot;</font>
<font color="black"> 863.         Validate that the value can be coerced to the right type (if not empty).</font>
<font color="black"> 864.         &quot;&quot;&quot;</font>
<font color="red"> 865.         if value == self.empty_value or value in self.empty_values:</font>
<font color="red"> 866.             return self.empty_value</font>
<font color="red"> 867.         try:</font>
<font color="red"> 868.             value = self.coerce(value)</font>
<font color="red"> 869.         except (ValueError, TypeError, ValidationError):</font>
<font color="red"> 870.             raise ValidationError(</font>
<font color="red"> 871.                 self.error_messages['invalid_choice'],</font>
<font color="red"> 872.                 code='invalid_choice',</font>
<font color="red"> 873.                 params={'value': value},</font>
<font color="black"> 874.             )</font>
<font color="red"> 875.         return value</font>
<font color="black"> 876. </font>
<font color="green"> 877.     def clean(self, value):</font>
<font color="red"> 878.         value = super(TypedChoiceField, self).clean(value)</font>
<font color="red"> 879.         return self._coerce(value)</font>
<font color="black"> 880. </font>
<font color="black"> 881. </font>
<font color="green"> 882. class MultipleChoiceField(ChoiceField):</font>
<font color="green"> 883.     hidden_widget = MultipleHiddenInput</font>
<font color="green"> 884.     widget = SelectMultiple</font>
<font color="green"> 885.     default_error_messages = {</font>
<font color="green"> 886.         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),</font>
<font color="green"> 887.         'invalid_list': _('Enter a list of values.'),</font>
<font color="black"> 888.     }</font>
<font color="black"> 889. </font>
<font color="green"> 890.     def to_python(self, value):</font>
<font color="red"> 891.         if not value:</font>
<font color="red"> 892.             return []</font>
<font color="red"> 893.         elif not isinstance(value, (list, tuple)):</font>
<font color="red"> 894.             raise ValidationError(self.error_messages['invalid_list'], code='invalid_list')</font>
<font color="red"> 895.         return [smart_text(val) for val in value]</font>
<font color="black"> 896. </font>
<font color="green"> 897.     def validate(self, value):</font>
<font color="black"> 898.         &quot;&quot;&quot;</font>
<font color="black"> 899.         Validates that the input is a list or tuple.</font>
<font color="black"> 900.         &quot;&quot;&quot;</font>
<font color="red"> 901.         if self.required and not value:</font>
<font color="red"> 902.             raise ValidationError(self.error_messages['required'], code='required')</font>
<font color="black"> 903.         # Validate that each value in the value list is in self.choices.</font>
<font color="red"> 904.         for val in value:</font>
<font color="red"> 905.             if not self.valid_value(val):</font>
<font color="red"> 906.                 raise ValidationError(</font>
<font color="red"> 907.                     self.error_messages['invalid_choice'],</font>
<font color="red"> 908.                     code='invalid_choice',</font>
<font color="red"> 909.                     params={'value': val},</font>
<font color="black"> 910.                 )</font>
<font color="black"> 911. </font>
<font color="green"> 912.     def has_changed(self, initial, data):</font>
<font color="red"> 913.         if initial is None:</font>
<font color="red"> 914.             initial = []</font>
<font color="red"> 915.         if data is None:</font>
<font color="red"> 916.             data = []</font>
<font color="red"> 917.         if len(initial) != len(data):</font>
<font color="red"> 918.             return True</font>
<font color="red"> 919.         initial_set = set(force_text(value) for value in initial)</font>
<font color="red"> 920.         data_set = set(force_text(value) for value in data)</font>
<font color="red"> 921.         return data_set != initial_set</font>
<font color="black"> 922. </font>
<font color="black"> 923. </font>
<font color="green"> 924. class TypedMultipleChoiceField(MultipleChoiceField):</font>
<font color="green"> 925.     def __init__(self, *args, **kwargs):</font>
<font color="red"> 926.         self.coerce = kwargs.pop('coerce', lambda val: val)</font>
<font color="red"> 927.         self.empty_value = kwargs.pop('empty_value', [])</font>
<font color="red"> 928.         super(TypedMultipleChoiceField, self).__init__(*args, **kwargs)</font>
<font color="black"> 929. </font>
<font color="green"> 930.     def _coerce(self, value):</font>
<font color="black"> 931.         &quot;&quot;&quot;</font>
<font color="black"> 932.         Validates that the values are in self.choices and can be coerced to the</font>
<font color="black"> 933.         right type.</font>
<font color="black"> 934.         &quot;&quot;&quot;</font>
<font color="red"> 935.         if value == self.empty_value or value in self.empty_values:</font>
<font color="red"> 936.             return self.empty_value</font>
<font color="red"> 937.         new_value = []</font>
<font color="red"> 938.         for choice in value:</font>
<font color="red"> 939.             try:</font>
<font color="red"> 940.                 new_value.append(self.coerce(choice))</font>
<font color="red"> 941.             except (ValueError, TypeError, ValidationError):</font>
<font color="red"> 942.                 raise ValidationError(</font>
<font color="red"> 943.                     self.error_messages['invalid_choice'],</font>
<font color="red"> 944.                     code='invalid_choice',</font>
<font color="red"> 945.                     params={'value': choice},</font>
<font color="black"> 946.                 )</font>
<font color="red"> 947.         return new_value</font>
<font color="black"> 948. </font>
<font color="green"> 949.     def clean(self, value):</font>
<font color="red"> 950.         value = super(TypedMultipleChoiceField, self).clean(value)</font>
<font color="red"> 951.         return self._coerce(value)</font>
<font color="black"> 952. </font>
<font color="green"> 953.     def validate(self, value):</font>
<font color="red"> 954.         if value != self.empty_value:</font>
<font color="red"> 955.             super(TypedMultipleChoiceField, self).validate(value)</font>
<font color="red"> 956.         elif self.required:</font>
<font color="red"> 957.             raise ValidationError(self.error_messages['required'], code='required')</font>
<font color="black"> 958. </font>
<font color="black"> 959. </font>
<font color="green"> 960. class ComboField(Field):</font>
<font color="black"> 961.     &quot;&quot;&quot;</font>
<font color="black"> 962.     A Field whose clean() method calls multiple Field clean() methods.</font>
<font color="green"> 963.     &quot;&quot;&quot;</font>
<font color="green"> 964.     def __init__(self, fields=(), *args, **kwargs):</font>
<font color="red"> 965.         super(ComboField, self).__init__(*args, **kwargs)</font>
<font color="black"> 966.         # Set 'required' to False on the individual fields, because the</font>
<font color="black"> 967.         # required validation will be handled by ComboField, not by those</font>
<font color="black"> 968.         # individual fields.</font>
<font color="red"> 969.         for f in fields:</font>
<font color="red"> 970.             f.required = False</font>
<font color="red"> 971.         self.fields = fields</font>
<font color="black"> 972. </font>
<font color="green"> 973.     def clean(self, value):</font>
<font color="black"> 974.         &quot;&quot;&quot;</font>
<font color="black"> 975.         Validates the given value against all of self.fields, which is a</font>
<font color="black"> 976.         list of Field instances.</font>
<font color="black"> 977.         &quot;&quot;&quot;</font>
<font color="red"> 978.         super(ComboField, self).clean(value)</font>
<font color="red"> 979.         for field in self.fields:</font>
<font color="red"> 980.             value = field.clean(value)</font>
<font color="red"> 981.         return value</font>
<font color="black"> 982. </font>
<font color="black"> 983. </font>
<font color="green"> 984. class MultiValueField(Field):</font>
<font color="black"> 985.     &quot;&quot;&quot;</font>
<font color="black"> 986.     A Field that aggregates the logic of multiple Fields.</font>
<font color="black"> 987. </font>
<font color="black"> 988.     Its clean() method takes a &quot;decompressed&quot; list of values, which are then</font>
<font color="black"> 989.     cleaned into a single value according to self.fields. Each value in</font>
<font color="black"> 990.     this list is cleaned by the corresponding field -- the first value is</font>
<font color="black"> 991.     cleaned by the first field, the second value is cleaned by the second</font>
<font color="black"> 992.     field, etc. Once all fields are cleaned, the list of clean values is</font>
<font color="black"> 993.     &quot;compressed&quot; into a single value.</font>
<font color="black"> 994. </font>
<font color="black"> 995.     Subclasses should not have to implement clean(). Instead, they must</font>
<font color="black"> 996.     implement compress(), which takes a list of valid values and returns a</font>
<font color="black"> 997.     &quot;compressed&quot; version of those values -- a single value.</font>
<font color="black"> 998. </font>
<font color="black"> 999.     You'll probably want to use this with MultiWidget.</font>
<font color="green">1000.     &quot;&quot;&quot;</font>
<font color="green">1001.     default_error_messages = {</font>
<font color="green">1002.         'invalid': _('Enter a list of values.'),</font>
<font color="green">1003.         'incomplete': _('Enter a complete value.'),</font>
<font color="black">1004.     }</font>
<font color="black">1005. </font>
<font color="green">1006.     def __init__(self, fields=(), *args, **kwargs):</font>
<font color="red">1007.         self.require_all_fields = kwargs.pop('require_all_fields', True)</font>
<font color="red">1008.         super(MultiValueField, self).__init__(*args, **kwargs)</font>
<font color="red">1009.         for f in fields:</font>
<font color="red">1010.             f.error_messages.setdefault('incomplete',</font>
<font color="red">1011.                                         self.error_messages['incomplete'])</font>
<font color="red">1012.             if self.require_all_fields:</font>
<font color="black">1013.                 # Set 'required' to False on the individual fields, because the</font>
<font color="black">1014.                 # required validation will be handled by MultiValueField, not</font>
<font color="black">1015.                 # by those individual fields.</font>
<font color="red">1016.                 f.required = False</font>
<font color="red">1017.         self.fields = fields</font>
<font color="black">1018. </font>
<font color="green">1019.     def __deepcopy__(self, memo):</font>
<font color="red">1020.         result = super(MultiValueField, self).__deepcopy__(memo)</font>
<font color="red">1021.         result.fields = tuple(x.__deepcopy__(memo) for x in self.fields)</font>
<font color="red">1022.         return result</font>
<font color="black">1023. </font>
<font color="green">1024.     def validate(self, value):</font>
<font color="red">1025.         pass</font>
<font color="black">1026. </font>
<font color="green">1027.     def clean(self, value):</font>
<font color="black">1028.         &quot;&quot;&quot;</font>
<font color="black">1029.         Validates every value in the given list. A value is validated against</font>
<font color="black">1030.         the corresponding Field in self.fields.</font>
<font color="black">1031. </font>
<font color="black">1032.         For example, if this MultiValueField was instantiated with</font>
<font color="black">1033.         fields=(DateField(), TimeField()), clean() would call</font>
<font color="black">1034.         DateField.clean(value[0]) and TimeField.clean(value[1]).</font>
<font color="black">1035.         &quot;&quot;&quot;</font>
<font color="red">1036.         clean_data = []</font>
<font color="red">1037.         errors = []</font>
<font color="red">1038.         if not value or isinstance(value, (list, tuple)):</font>
<font color="red">1039.             if not value or not [v for v in value if v not in self.empty_values]:</font>
<font color="red">1040.                 if self.required:</font>
<font color="red">1041.                     raise ValidationError(self.error_messages['required'], code='required')</font>
<font color="black">1042.                 else:</font>
<font color="red">1043.                     return self.compress([])</font>
<font color="black">1044.         else:</font>
<font color="red">1045.             raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="red">1046.         for i, field in enumerate(self.fields):</font>
<font color="red">1047.             try:</font>
<font color="red">1048.                 field_value = value[i]</font>
<font color="red">1049.             except IndexError:</font>
<font color="red">1050.                 field_value = None</font>
<font color="red">1051.             if field_value in self.empty_values:</font>
<font color="red">1052.                 if self.require_all_fields:</font>
<font color="black">1053.                     # Raise a 'required' error if the MultiValueField is</font>
<font color="black">1054.                     # required and any field is empty.</font>
<font color="red">1055.                     if self.required:</font>
<font color="red">1056.                         raise ValidationError(self.error_messages['required'], code='required')</font>
<font color="red">1057.                 elif field.required:</font>
<font color="black">1058.                     # Otherwise, add an 'incomplete' error to the list of</font>
<font color="black">1059.                     # collected errors and skip field cleaning, if a required</font>
<font color="black">1060.                     # field is empty.</font>
<font color="red">1061.                     if field.error_messages['incomplete'] not in errors:</font>
<font color="red">1062.                         errors.append(field.error_messages['incomplete'])</font>
<font color="red">1063.                     continue</font>
<font color="red">1064.             try:</font>
<font color="red">1065.                 clean_data.append(field.clean(field_value))</font>
<font color="red">1066.             except ValidationError as e:</font>
<font color="black">1067.                 # Collect all validation errors in a single list, which we'll</font>
<font color="black">1068.                 # raise at the end of clean(), rather than raising a single</font>
<font color="black">1069.                 # exception for the first error we encounter. Skip duplicates.</font>
<font color="red">1070.                 errors.extend(m for m in e.error_list if m not in errors)</font>
<font color="red">1071.         if errors:</font>
<font color="red">1072.             raise ValidationError(errors)</font>
<font color="black">1073. </font>
<font color="red">1074.         out = self.compress(clean_data)</font>
<font color="red">1075.         self.validate(out)</font>
<font color="red">1076.         self.run_validators(out)</font>
<font color="red">1077.         return out</font>
<font color="black">1078. </font>
<font color="green">1079.     def compress(self, data_list):</font>
<font color="black">1080.         &quot;&quot;&quot;</font>
<font color="black">1081.         Returns a single value for the given list of values. The values can be</font>
<font color="black">1082.         assumed to be valid.</font>
<font color="black">1083. </font>
<font color="black">1084.         For example, if this MultiValueField was instantiated with</font>
<font color="black">1085.         fields=(DateField(), TimeField()), this might return a datetime</font>
<font color="black">1086.         object created by combining the date and time in data_list.</font>
<font color="black">1087.         &quot;&quot;&quot;</font>
<font color="red">1088.         raise NotImplementedError('Subclasses must implement this method.')</font>
<font color="black">1089. </font>
<font color="green">1090.     def has_changed(self, initial, data):</font>
<font color="red">1091.         if initial is None:</font>
<font color="red">1092.             initial = ['' for x in range(0, len(data))]</font>
<font color="black">1093.         else:</font>
<font color="red">1094.             if not isinstance(initial, list):</font>
<font color="red">1095.                 initial = self.widget.decompress(initial)</font>
<font color="red">1096.         for field, initial, data in zip(self.fields, initial, data):</font>
<font color="red">1097.             try:</font>
<font color="red">1098.                 initial = field.to_python(initial)</font>
<font color="red">1099.             except ValidationError:</font>
<font color="red">1100.                 return True</font>
<font color="red">1101.             if field.has_changed(initial, data):</font>
<font color="red">1102.                 return True</font>
<font color="red">1103.         return False</font>
<font color="black">1104. </font>
<font color="black">1105. </font>
<font color="green">1106. class FilePathField(ChoiceField):</font>
<font color="green">1107.     def __init__(self, path, match=None, recursive=False, allow_files=True,</font>
<font color="green">1108.                  allow_folders=False, required=True, widget=None, label=None,</font>
<font color="green">1109.                  initial=None, help_text='', *args, **kwargs):</font>
<font color="red">1110.         self.path, self.match, self.recursive = path, match, recursive</font>
<font color="red">1111.         self.allow_files, self.allow_folders = allow_files, allow_folders</font>
<font color="red">1112.         super(FilePathField, self).__init__(choices=(), required=required,</font>
<font color="red">1113.             widget=widget, label=label, initial=initial, help_text=help_text,</font>
<font color="red">1114.             *args, **kwargs)</font>
<font color="black">1115. </font>
<font color="red">1116.         if self.required:</font>
<font color="red">1117.             self.choices = []</font>
<font color="black">1118.         else:</font>
<font color="red">1119.             self.choices = [(&quot;&quot;, &quot;---------&quot;)]</font>
<font color="black">1120. </font>
<font color="red">1121.         if self.match is not None:</font>
<font color="red">1122.             self.match_re = re.compile(self.match)</font>
<font color="black">1123. </font>
<font color="red">1124.         if recursive:</font>
<font color="red">1125.             for root, dirs, files in sorted(os.walk(self.path)):</font>
<font color="red">1126.                 if self.allow_files:</font>
<font color="red">1127.                     for f in files:</font>
<font color="red">1128.                         if self.match is None or self.match_re.search(f):</font>
<font color="red">1129.                             f = os.path.join(root, f)</font>
<font color="red">1130.                             self.choices.append((f, f.replace(path, &quot;&quot;, 1)))</font>
<font color="red">1131.                 if self.allow_folders:</font>
<font color="red">1132.                     for f in dirs:</font>
<font color="red">1133.                         if f == '__pycache__':</font>
<font color="red">1134.                             continue</font>
<font color="red">1135.                         if self.match is None or self.match_re.search(f):</font>
<font color="red">1136.                             f = os.path.join(root, f)</font>
<font color="red">1137.                             self.choices.append((f, f.replace(path, &quot;&quot;, 1)))</font>
<font color="black">1138.         else:</font>
<font color="red">1139.             try:</font>
<font color="red">1140.                 for f in sorted(os.listdir(self.path)):</font>
<font color="red">1141.                     if f == '__pycache__':</font>
<font color="red">1142.                         continue</font>
<font color="red">1143.                     full_file = os.path.join(self.path, f)</font>
<font color="red">1144.                     if (((self.allow_files and os.path.isfile(full_file)) or</font>
<font color="red">1145.                             (self.allow_folders and os.path.isdir(full_file))) and</font>
<font color="red">1146.                             (self.match is None or self.match_re.search(f))):</font>
<font color="red">1147.                         self.choices.append((full_file, f))</font>
<font color="red">1148.             except OSError:</font>
<font color="red">1149.                 pass</font>
<font color="black">1150. </font>
<font color="red">1151.         self.widget.choices = self.choices</font>
<font color="black">1152. </font>
<font color="black">1153. </font>
<font color="green">1154. class SplitDateTimeField(MultiValueField):</font>
<font color="green">1155.     widget = SplitDateTimeWidget</font>
<font color="green">1156.     hidden_widget = SplitHiddenDateTimeWidget</font>
<font color="green">1157.     default_error_messages = {</font>
<font color="green">1158.         'invalid_date': _('Enter a valid date.'),</font>
<font color="green">1159.         'invalid_time': _('Enter a valid time.'),</font>
<font color="black">1160.     }</font>
<font color="black">1161. </font>
<font color="green">1162.     def __init__(self, input_date_formats=None, input_time_formats=None, *args, **kwargs):</font>
<font color="red">1163.         errors = self.default_error_messages.copy()</font>
<font color="red">1164.         if 'error_messages' in kwargs:</font>
<font color="red">1165.             errors.update(kwargs['error_messages'])</font>
<font color="red">1166.         localize = kwargs.get('localize', False)</font>
<font color="black">1167.         fields = (</font>
<font color="red">1168.             DateField(input_formats=input_date_formats,</font>
<font color="red">1169.                       error_messages={'invalid': errors['invalid_date']},</font>
<font color="red">1170.                       localize=localize),</font>
<font color="red">1171.             TimeField(input_formats=input_time_formats,</font>
<font color="red">1172.                       error_messages={'invalid': errors['invalid_time']},</font>
<font color="red">1173.                       localize=localize),</font>
<font color="black">1174.         )</font>
<font color="red">1175.         super(SplitDateTimeField, self).__init__(fields, *args, **kwargs)</font>
<font color="black">1176. </font>
<font color="green">1177.     def compress(self, data_list):</font>
<font color="red">1178.         if data_list:</font>
<font color="black">1179.             # Raise a validation error if time or date is empty</font>
<font color="black">1180.             # (possible if SplitDateTimeField has required=False).</font>
<font color="red">1181.             if data_list[0] in self.empty_values:</font>
<font color="red">1182.                 raise ValidationError(self.error_messages['invalid_date'], code='invalid_date')</font>
<font color="red">1183.             if data_list[1] in self.empty_values:</font>
<font color="red">1184.                 raise ValidationError(self.error_messages['invalid_time'], code='invalid_time')</font>
<font color="red">1185.             result = datetime.datetime.combine(*data_list)</font>
<font color="red">1186.             return from_current_timezone(result)</font>
<font color="red">1187.         return None</font>
<font color="black">1188. </font>
<font color="black">1189. </font>
<font color="green">1190. class GenericIPAddressField(CharField):</font>
<font color="green">1191.     def __init__(self, protocol='both', unpack_ipv4=False, *args, **kwargs):</font>
<font color="red">1192.         self.unpack_ipv4 = unpack_ipv4</font>
<font color="red">1193.         self.default_validators = validators.ip_address_validators(protocol, unpack_ipv4)[0]</font>
<font color="red">1194.         super(GenericIPAddressField, self).__init__(*args, **kwargs)</font>
<font color="black">1195. </font>
<font color="green">1196.     def to_python(self, value):</font>
<font color="red">1197.         if value in self.empty_values:</font>
<font color="red">1198.             return ''</font>
<font color="red">1199.         value = value.strip()</font>
<font color="red">1200.         if value and ':' in value:</font>
<font color="red">1201.             return clean_ipv6_address(value, self.unpack_ipv4)</font>
<font color="red">1202.         return value</font>
<font color="black">1203. </font>
<font color="black">1204. </font>
<font color="green">1205. class SlugField(CharField):</font>
<font color="green">1206.     default_validators = [validators.validate_slug]</font>
<font color="black">1207. </font>
<font color="green">1208.     def __init__(self, *args, **kwargs):</font>
<font color="red">1209.         self.allow_unicode = kwargs.pop('allow_unicode', False)</font>
<font color="red">1210.         if self.allow_unicode:</font>
<font color="red">1211.             self.default_validators = [validators.validate_unicode_slug]</font>
<font color="red">1212.         super(SlugField, self).__init__(*args, **kwargs)</font>
<font color="black">1213. </font>
<font color="black">1214. </font>
<font color="green">1215. class UUIDField(CharField):</font>
<font color="green">1216.     default_error_messages = {</font>
<font color="green">1217.         'invalid': _('Enter a valid UUID.'),</font>
<font color="black">1218.     }</font>
<font color="black">1219. </font>
<font color="green">1220.     def prepare_value(self, value):</font>
<font color="red">1221.         if isinstance(value, uuid.UUID):</font>
<font color="red">1222.             return value.hex</font>
<font color="red">1223.         return value</font>
<font color="black">1224. </font>
<font color="green">1225.     def to_python(self, value):</font>
<font color="red">1226.         value = super(UUIDField, self).to_python(value)</font>
<font color="red">1227.         if value in self.empty_values:</font>
<font color="red">1228.             return None</font>
<font color="red">1229.         if not isinstance(value, uuid.UUID):</font>
<font color="red">1230.             try:</font>
<font color="red">1231.                 value = uuid.UUID(value)</font>
<font color="red">1232.             except ValueError:</font>
<font color="red">1233.                 raise ValidationError(self.error_messages['invalid'], code='invalid')</font>
<font color="red">1234.         return value</font>
</pre>

