source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/query.py</b><br>


file stats: <b>967 lines, 325 executed: 33.6% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. The main QuerySet implementation. This provides the public API for the ORM.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. import copy</font>
<font color="green">   6. import sys</font>
<font color="green">   7. import warnings</font>
<font color="green">   8. from collections import OrderedDict, deque</font>
<font color="black">   9. </font>
<font color="green">  10. from django.conf import settings</font>
<font color="green">  11. from django.core import exceptions</font>
<font color="green">  12. from django.db import (</font>
<font color="black">  13.     DJANGO_VERSION_PICKLE_KEY, IntegrityError, connections, router,</font>
<font color="black">  14.     transaction,</font>
<font color="black">  15. )</font>
<font color="green">  16. from django.db.models import sql</font>
<font color="green">  17. from django.db.models.constants import LOOKUP_SEP</font>
<font color="green">  18. from django.db.models.deletion import Collector</font>
<font color="green">  19. from django.db.models.expressions import F, Date, DateTime</font>
<font color="green">  20. from django.db.models.fields import AutoField</font>
<font color="green">  21. from django.db.models.query_utils import (</font>
<font color="black">  22.     Q, InvalidQuery, check_rel_lookup_compatibility, deferred_class_factory,</font>
<font color="black">  23. )</font>
<font color="green">  24. from django.db.models.sql.constants import CURSOR</font>
<font color="green">  25. from django.utils import six, timezone</font>
<font color="green">  26. from django.utils.functional import partition</font>
<font color="green">  27. from django.utils.version import get_version</font>
<font color="black">  28. </font>
<font color="black">  29. # The maximum number of items to display in a QuerySet.__repr__</font>
<font color="green">  30. REPR_OUTPUT_SIZE = 20</font>
<font color="black">  31. </font>
<font color="black">  32. # Pull into this namespace for backwards compatibility.</font>
<font color="green">  33. EmptyResultSet = sql.EmptyResultSet</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. class BaseIterable(object):</font>
<font color="green">  37.     def __init__(self, queryset):</font>
<font color="green">  38.         self.queryset = queryset</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. class ModelIterable(BaseIterable):</font>
<font color="black">  42.     &quot;&quot;&quot;</font>
<font color="black">  43.     Iterable that yields a model instance for each row.</font>
<font color="green">  44.     &quot;&quot;&quot;</font>
<font color="black">  45. </font>
<font color="green">  46.     def __iter__(self):</font>
<font color="green">  47.         queryset = self.queryset</font>
<font color="green">  48.         db = queryset.db</font>
<font color="green">  49.         compiler = queryset.query.get_compiler(using=db)</font>
<font color="black">  50.         # Execute the query. This will also fill compiler.select, klass_info,</font>
<font color="black">  51.         # and annotations.</font>
<font color="green">  52.         results = compiler.execute_sql()</font>
<font color="green">  53.         select, klass_info, annotation_col_map = (compiler.select, compiler.klass_info,</font>
<font color="green">  54.                                                   compiler.annotation_col_map)</font>
<font color="green">  55.         if klass_info is None:</font>
<font color="red">  56.             return</font>
<font color="green">  57.         model_cls = klass_info['model']</font>
<font color="green">  58.         select_fields = klass_info['select_fields']</font>
<font color="green">  59.         model_fields_start, model_fields_end = select_fields[0], select_fields[-1] + 1</font>
<font color="green">  60.         init_list = [f[0].target.attname</font>
<font color="green">  61.                      for f in select[model_fields_start:model_fields_end]]</font>
<font color="green">  62.         if len(init_list) != len(model_cls._meta.concrete_fields):</font>
<font color="red">  63.             init_set = set(init_list)</font>
<font color="red">  64.             skip = [f.attname for f in model_cls._meta.concrete_fields</font>
<font color="red">  65.                     if f.attname not in init_set]</font>
<font color="red">  66.             model_cls = deferred_class_factory(model_cls, skip)</font>
<font color="green">  67.         related_populators = get_related_populators(klass_info, select, db)</font>
<font color="green">  68.         for row in compiler.results_iter(results):</font>
<font color="green">  69.             obj = model_cls.from_db(db, init_list, row[model_fields_start:model_fields_end])</font>
<font color="green">  70.             if related_populators:</font>
<font color="red">  71.                 for rel_populator in related_populators:</font>
<font color="red">  72.                     rel_populator.populate(row, obj)</font>
<font color="green">  73.             if annotation_col_map:</font>
<font color="red">  74.                 for attr_name, col_pos in annotation_col_map.items():</font>
<font color="red">  75.                     setattr(obj, attr_name, row[col_pos])</font>
<font color="black">  76. </font>
<font color="black">  77.             # Add the known related objects to the model, if there are any</font>
<font color="green">  78.             if queryset._known_related_objects:</font>
<font color="red">  79.                 for field, rel_objs in queryset._known_related_objects.items():</font>
<font color="black">  80.                     # Avoid overwriting objects loaded e.g. by select_related</font>
<font color="red">  81.                     if hasattr(obj, field.get_cache_name()):</font>
<font color="red">  82.                         continue</font>
<font color="red">  83.                     pk = getattr(obj, field.get_attname())</font>
<font color="red">  84.                     try:</font>
<font color="red">  85.                         rel_obj = rel_objs[pk]</font>
<font color="red">  86.                     except KeyError:</font>
<font color="red">  87.                         pass  # may happen in qs1 | qs2 scenarios</font>
<font color="black">  88.                     else:</font>
<font color="red">  89.                         setattr(obj, field.name, rel_obj)</font>
<font color="black">  90. </font>
<font color="green">  91.             yield obj</font>
<font color="black">  92. </font>
<font color="black">  93. </font>
<font color="green">  94. class ValuesIterable(BaseIterable):</font>
<font color="black">  95.     &quot;&quot;&quot;</font>
<font color="black">  96.     Iterable returned by QuerySet.values() that yields a dict</font>
<font color="black">  97.     for each row.</font>
<font color="green">  98.     &quot;&quot;&quot;</font>
<font color="black">  99. </font>
<font color="green"> 100.     def __iter__(self):</font>
<font color="red"> 101.         queryset = self.queryset</font>
<font color="red"> 102.         query = queryset.query</font>
<font color="red"> 103.         compiler = query.get_compiler(queryset.db)</font>
<font color="black"> 104. </font>
<font color="red"> 105.         field_names = list(query.values_select)</font>
<font color="red"> 106.         extra_names = list(query.extra_select)</font>
<font color="red"> 107.         annotation_names = list(query.annotation_select)</font>
<font color="black"> 108. </font>
<font color="black"> 109.         # extra(select=...) cols are always at the start of the row.</font>
<font color="red"> 110.         names = extra_names + field_names + annotation_names</font>
<font color="black"> 111. </font>
<font color="red"> 112.         for row in compiler.results_iter():</font>
<font color="red"> 113.             yield dict(zip(names, row))</font>
<font color="black"> 114. </font>
<font color="black"> 115. </font>
<font color="green"> 116. class ValuesListIterable(BaseIterable):</font>
<font color="black"> 117.     &quot;&quot;&quot;</font>
<font color="black"> 118.     Iterable returned by QuerySet.values_list(flat=False)</font>
<font color="black"> 119.     that yields a tuple for each row.</font>
<font color="green"> 120.     &quot;&quot;&quot;</font>
<font color="black"> 121. </font>
<font color="green"> 122.     def __iter__(self):</font>
<font color="green"> 123.         queryset = self.queryset</font>
<font color="green"> 124.         query = queryset.query</font>
<font color="green"> 125.         compiler = query.get_compiler(queryset.db)</font>
<font color="black"> 126. </font>
<font color="green"> 127.         if not query.extra_select and not query.annotation_select:</font>
<font color="green"> 128.             for row in compiler.results_iter():</font>
<font color="green"> 129.                 yield tuple(row)</font>
<font color="black"> 130.         else:</font>
<font color="red"> 131.             field_names = list(query.values_select)</font>
<font color="red"> 132.             extra_names = list(query.extra_select)</font>
<font color="red"> 133.             annotation_names = list(query.annotation_select)</font>
<font color="black"> 134. </font>
<font color="black"> 135.             # extra(select=...) cols are always at the start of the row.</font>
<font color="red"> 136.             names = extra_names + field_names + annotation_names</font>
<font color="black"> 137. </font>
<font color="red"> 138.             if queryset._fields:</font>
<font color="black"> 139.                 # Reorder according to fields.</font>
<font color="red"> 140.                 fields = list(queryset._fields) + [f for f in annotation_names if f not in queryset._fields]</font>
<font color="black"> 141.             else:</font>
<font color="red"> 142.                 fields = names</font>
<font color="black"> 143. </font>
<font color="red"> 144.             for row in compiler.results_iter():</font>
<font color="red"> 145.                 data = dict(zip(names, row))</font>
<font color="red"> 146.                 yield tuple(data[f] for f in fields)</font>
<font color="black"> 147. </font>
<font color="black"> 148. </font>
<font color="green"> 149. class FlatValuesListIterable(BaseIterable):</font>
<font color="black"> 150.     &quot;&quot;&quot;</font>
<font color="black"> 151.     Iterable returned by QuerySet.values_list(flat=True) that</font>
<font color="black"> 152.     yields single values.</font>
<font color="green"> 153.     &quot;&quot;&quot;</font>
<font color="black"> 154. </font>
<font color="green"> 155.     def __iter__(self):</font>
<font color="red"> 156.         queryset = self.queryset</font>
<font color="red"> 157.         compiler = queryset.query.get_compiler(queryset.db)</font>
<font color="red"> 158.         for row in compiler.results_iter():</font>
<font color="red"> 159.             yield row[0]</font>
<font color="black"> 160. </font>
<font color="black"> 161. </font>
<font color="green"> 162. class QuerySet(object):</font>
<font color="black"> 163.     &quot;&quot;&quot;</font>
<font color="black"> 164.     Represents a lazy database lookup for a set of objects.</font>
<font color="green"> 165.     &quot;&quot;&quot;</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def __init__(self, model=None, query=None, using=None, hints=None):</font>
<font color="green"> 168.         self.model = model</font>
<font color="green"> 169.         self._db = using</font>
<font color="green"> 170.         self._hints = hints or {}</font>
<font color="green"> 171.         self.query = query or sql.Query(self.model)</font>
<font color="green"> 172.         self._result_cache = None</font>
<font color="green"> 173.         self._sticky_filter = False</font>
<font color="green"> 174.         self._for_write = False</font>
<font color="green"> 175.         self._prefetch_related_lookups = []</font>
<font color="green"> 176.         self._prefetch_done = False</font>
<font color="green"> 177.         self._known_related_objects = {}  # {rel_field, {pk: rel_obj}}</font>
<font color="green"> 178.         self._iterable_class = ModelIterable</font>
<font color="green"> 179.         self._fields = None</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def as_manager(cls):</font>
<font color="black"> 182.         # Address the circular dependency between `Queryset` and `Manager`.</font>
<font color="red"> 183.         from django.db.models.manager import Manager</font>
<font color="red"> 184.         manager = Manager.from_queryset(cls)()</font>
<font color="red"> 185.         manager._built_with_as_manager = True</font>
<font color="red"> 186.         return manager</font>
<font color="green"> 187.     as_manager.queryset_only = True</font>
<font color="green"> 188.     as_manager = classmethod(as_manager)</font>
<font color="black"> 189. </font>
<font color="black"> 190.     ########################</font>
<font color="black"> 191.     # PYTHON MAGIC METHODS #</font>
<font color="black"> 192.     ########################</font>
<font color="black"> 193. </font>
<font color="green"> 194.     def __deepcopy__(self, memo):</font>
<font color="black"> 195.         &quot;&quot;&quot;</font>
<font color="black"> 196.         Deep copy of a QuerySet doesn't populate the cache</font>
<font color="black"> 197.         &quot;&quot;&quot;</font>
<font color="red"> 198.         obj = self.__class__()</font>
<font color="red"> 199.         for k, v in self.__dict__.items():</font>
<font color="red"> 200.             if k == '_result_cache':</font>
<font color="red"> 201.                 obj.__dict__[k] = None</font>
<font color="black"> 202.             else:</font>
<font color="red"> 203.                 obj.__dict__[k] = copy.deepcopy(v, memo)</font>
<font color="red"> 204.         return obj</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def __getstate__(self):</font>
<font color="black"> 207.         &quot;&quot;&quot;</font>
<font color="black"> 208.         Allows the QuerySet to be pickled.</font>
<font color="black"> 209.         &quot;&quot;&quot;</font>
<font color="black"> 210.         # Force the cache to be fully populated.</font>
<font color="red"> 211.         self._fetch_all()</font>
<font color="red"> 212.         obj_dict = self.__dict__.copy()</font>
<font color="red"> 213.         obj_dict[DJANGO_VERSION_PICKLE_KEY] = get_version()</font>
<font color="red"> 214.         return obj_dict</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def __setstate__(self, state):</font>
<font color="red"> 217.         msg = None</font>
<font color="red"> 218.         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)</font>
<font color="red"> 219.         if pickled_version:</font>
<font color="red"> 220.             current_version = get_version()</font>
<font color="red"> 221.             if current_version != pickled_version:</font>
<font color="red"> 222.                 msg = (&quot;Pickled queryset instance's Django version %s does&quot;</font>
<font color="black"> 223.                     &quot; not match the current version %s.&quot;</font>
<font color="red"> 224.                     % (pickled_version, current_version))</font>
<font color="black"> 225.         else:</font>
<font color="red"> 226.             msg = &quot;Pickled queryset instance's Django version is not specified.&quot;</font>
<font color="black"> 227. </font>
<font color="red"> 228.         if msg:</font>
<font color="red"> 229.             warnings.warn(msg, RuntimeWarning, stacklevel=2)</font>
<font color="black"> 230. </font>
<font color="red"> 231.         self.__dict__.update(state)</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def __repr__(self):</font>
<font color="red"> 234.         data = list(self[:REPR_OUTPUT_SIZE + 1])</font>
<font color="red"> 235.         if len(data) &gt; REPR_OUTPUT_SIZE:</font>
<font color="red"> 236.             data[-1] = &quot;...(remaining elements truncated)...&quot;</font>
<font color="red"> 237.         return repr(data)</font>
<font color="black"> 238. </font>
<font color="green"> 239.     def __len__(self):</font>
<font color="green"> 240.         self._fetch_all()</font>
<font color="green"> 241.         return len(self._result_cache)</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def __iter__(self):</font>
<font color="black"> 244.         &quot;&quot;&quot;</font>
<font color="black"> 245.         The queryset iterator protocol uses three nested iterators in the</font>
<font color="black"> 246.         default case:</font>
<font color="black"> 247.             1. sql.compiler:execute_sql()</font>
<font color="black"> 248.                - Returns 100 rows at time (constants.GET_ITERATOR_CHUNK_SIZE)</font>
<font color="black"> 249.                  using cursor.fetchmany(). This part is responsible for</font>
<font color="black"> 250.                  doing some column masking, and returning the rows in chunks.</font>
<font color="black"> 251.             2. sql/compiler.results_iter()</font>
<font color="black"> 252.                - Returns one row at time. At this point the rows are still just</font>
<font color="black"> 253.                  tuples. In some cases the return values are converted to</font>
<font color="black"> 254.                  Python values at this location.</font>
<font color="black"> 255.             3. self.iterator()</font>
<font color="black"> 256.                - Responsible for turning the rows into model objects.</font>
<font color="black"> 257.         &quot;&quot;&quot;</font>
<font color="green"> 258.         self._fetch_all()</font>
<font color="green"> 259.         return iter(self._result_cache)</font>
<font color="black"> 260. </font>
<font color="green"> 261.     def __bool__(self):</font>
<font color="red"> 262.         self._fetch_all()</font>
<font color="red"> 263.         return bool(self._result_cache)</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def __nonzero__(self):      # Python 2 compatibility</font>
<font color="red"> 266.         return type(self).__bool__(self)</font>
<font color="black"> 267. </font>
<font color="green"> 268.     def __getitem__(self, k):</font>
<font color="black"> 269.         &quot;&quot;&quot;</font>
<font color="black"> 270.         Retrieves an item or slice from the set of results.</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="red"> 272.         if not isinstance(k, (slice,) + six.integer_types):</font>
<font color="red"> 273.             raise TypeError</font>
<font color="red"> 274.         assert ((not isinstance(k, slice) and (k &gt;= 0)) or</font>
<font color="red"> 275.                 (isinstance(k, slice) and (k.start is None or k.start &gt;= 0) and</font>
<font color="red"> 276.                  (k.stop is None or k.stop &gt;= 0))), \</font>
<font color="red"> 277.             &quot;Negative indexing is not supported.&quot;</font>
<font color="black"> 278. </font>
<font color="red"> 279.         if self._result_cache is not None:</font>
<font color="red"> 280.             return self._result_cache[k]</font>
<font color="black"> 281. </font>
<font color="red"> 282.         if isinstance(k, slice):</font>
<font color="red"> 283.             qs = self._clone()</font>
<font color="red"> 284.             if k.start is not None:</font>
<font color="red"> 285.                 start = int(k.start)</font>
<font color="black"> 286.             else:</font>
<font color="red"> 287.                 start = None</font>
<font color="red"> 288.             if k.stop is not None:</font>
<font color="red"> 289.                 stop = int(k.stop)</font>
<font color="black"> 290.             else:</font>
<font color="red"> 291.                 stop = None</font>
<font color="red"> 292.             qs.query.set_limits(start, stop)</font>
<font color="red"> 293.             return list(qs)[::k.step] if k.step else qs</font>
<font color="black"> 294. </font>
<font color="red"> 295.         qs = self._clone()</font>
<font color="red"> 296.         qs.query.set_limits(k, k + 1)</font>
<font color="red"> 297.         return list(qs)[0]</font>
<font color="black"> 298. </font>
<font color="green"> 299.     def __and__(self, other):</font>
<font color="red"> 300.         self._merge_sanity_check(other)</font>
<font color="red"> 301.         if isinstance(other, EmptyQuerySet):</font>
<font color="red"> 302.             return other</font>
<font color="red"> 303.         if isinstance(self, EmptyQuerySet):</font>
<font color="red"> 304.             return self</font>
<font color="red"> 305.         combined = self._clone()</font>
<font color="red"> 306.         combined._merge_known_related_objects(other)</font>
<font color="red"> 307.         combined.query.combine(other.query, sql.AND)</font>
<font color="red"> 308.         return combined</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def __or__(self, other):</font>
<font color="red"> 311.         self._merge_sanity_check(other)</font>
<font color="red"> 312.         if isinstance(self, EmptyQuerySet):</font>
<font color="red"> 313.             return other</font>
<font color="red"> 314.         if isinstance(other, EmptyQuerySet):</font>
<font color="red"> 315.             return self</font>
<font color="red"> 316.         combined = self._clone()</font>
<font color="red"> 317.         combined._merge_known_related_objects(other)</font>
<font color="red"> 318.         combined.query.combine(other.query, sql.OR)</font>
<font color="red"> 319.         return combined</font>
<font color="black"> 320. </font>
<font color="black"> 321.     ####################################</font>
<font color="black"> 322.     # METHODS THAT DO DATABASE QUERIES #</font>
<font color="black"> 323.     ####################################</font>
<font color="black"> 324. </font>
<font color="green"> 325.     def iterator(self):</font>
<font color="black"> 326.         &quot;&quot;&quot;</font>
<font color="black"> 327.         An iterator over the results from applying this QuerySet to the</font>
<font color="black"> 328.         database.</font>
<font color="black"> 329.         &quot;&quot;&quot;</font>
<font color="green"> 330.         return iter(self._iterable_class(self))</font>
<font color="black"> 331. </font>
<font color="green"> 332.     def aggregate(self, *args, **kwargs):</font>
<font color="black"> 333.         &quot;&quot;&quot;</font>
<font color="black"> 334.         Returns a dictionary containing the calculations (aggregation)</font>
<font color="black"> 335.         over the current queryset</font>
<font color="black"> 336. </font>
<font color="black"> 337.         If args is present the expression is passed as a kwarg using</font>
<font color="black"> 338.         the Aggregate object's default alias.</font>
<font color="black"> 339.         &quot;&quot;&quot;</font>
<font color="red"> 340.         if self.query.distinct_fields:</font>
<font color="red"> 341.             raise NotImplementedError(&quot;aggregate() + distinct(fields) not implemented.&quot;)</font>
<font color="red"> 342.         for arg in args:</font>
<font color="black"> 343.             # The default_alias property may raise a TypeError, so we use</font>
<font color="black"> 344.             # a try/except construct rather than hasattr in order to remain</font>
<font color="black"> 345.             # consistent between PY2 and PY3 (hasattr would swallow</font>
<font color="black"> 346.             # the TypeError on PY2).</font>
<font color="red"> 347.             try:</font>
<font color="red"> 348.                 arg.default_alias</font>
<font color="red"> 349.             except (AttributeError, TypeError):</font>
<font color="red"> 350.                 raise TypeError(&quot;Complex aggregates require an alias&quot;)</font>
<font color="red"> 351.             kwargs[arg.default_alias] = arg</font>
<font color="black"> 352. </font>
<font color="red"> 353.         query = self.query.clone()</font>
<font color="red"> 354.         for (alias, aggregate_expr) in kwargs.items():</font>
<font color="red"> 355.             query.add_annotation(aggregate_expr, alias, is_summary=True)</font>
<font color="red"> 356.             if not query.annotations[alias].contains_aggregate:</font>
<font color="red"> 357.                 raise TypeError(&quot;%s is not an aggregate expression&quot; % alias)</font>
<font color="red"> 358.         return query.get_aggregation(self.db, kwargs.keys())</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def count(self):</font>
<font color="black"> 361.         &quot;&quot;&quot;</font>
<font color="black"> 362.         Performs a SELECT COUNT() and returns the number of records as an</font>
<font color="black"> 363.         integer.</font>
<font color="black"> 364. </font>
<font color="black"> 365.         If the QuerySet is already fully cached this simply returns the length</font>
<font color="black"> 366.         of the cached results set to avoid multiple SELECT COUNT(*) calls.</font>
<font color="black"> 367.         &quot;&quot;&quot;</font>
<font color="red"> 368.         if self._result_cache is not None:</font>
<font color="red"> 369.             return len(self._result_cache)</font>
<font color="black"> 370. </font>
<font color="red"> 371.         return self.query.get_count(using=self.db)</font>
<font color="black"> 372. </font>
<font color="green"> 373.     def get(self, *args, **kwargs):</font>
<font color="black"> 374.         &quot;&quot;&quot;</font>
<font color="black"> 375.         Performs the query and returns a single object matching the given</font>
<font color="black"> 376.         keyword arguments.</font>
<font color="black"> 377.         &quot;&quot;&quot;</font>
<font color="green"> 378.         clone = self.filter(*args, **kwargs)</font>
<font color="green"> 379.         if self.query.can_filter() and not self.query.distinct_fields:</font>
<font color="green"> 380.             clone = clone.order_by()</font>
<font color="green"> 381.         num = len(clone)</font>
<font color="green"> 382.         if num == 1:</font>
<font color="red"> 383.             return clone._result_cache[0]</font>
<font color="green"> 384.         if not num:</font>
<font color="green"> 385.             raise self.model.DoesNotExist(</font>
<font color="green"> 386.                 &quot;%s matching query does not exist.&quot; %</font>
<font color="green"> 387.                 self.model._meta.object_name</font>
<font color="black"> 388.             )</font>
<font color="red"> 389.         raise self.model.MultipleObjectsReturned(</font>
<font color="red"> 390.             &quot;get() returned more than one %s -- it returned %s!&quot; %</font>
<font color="red"> 391.             (self.model._meta.object_name, num)</font>
<font color="black"> 392.         )</font>
<font color="black"> 393. </font>
<font color="green"> 394.     def create(self, **kwargs):</font>
<font color="black"> 395.         &quot;&quot;&quot;</font>
<font color="black"> 396.         Creates a new object with the given kwargs, saving it to the database</font>
<font color="black"> 397.         and returning the created object.</font>
<font color="black"> 398.         &quot;&quot;&quot;</font>
<font color="green"> 399.         obj = self.model(**kwargs)</font>
<font color="green"> 400.         self._for_write = True</font>
<font color="green"> 401.         obj.save(force_insert=True, using=self.db)</font>
<font color="green"> 402.         return obj</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def _populate_pk_values(self, objs):</font>
<font color="green"> 405.         for obj in objs:</font>
<font color="green"> 406.             if obj.pk is None:</font>
<font color="green"> 407.                 obj.pk = obj._meta.pk.get_pk_value_on_save(obj)</font>
<font color="black"> 408. </font>
<font color="green"> 409.     def bulk_create(self, objs, batch_size=None):</font>
<font color="black"> 410.         &quot;&quot;&quot;</font>
<font color="black"> 411.         Inserts each of the instances into the database. This does *not* call</font>
<font color="black"> 412.         save() on each of the instances, does not send any pre/post save</font>
<font color="black"> 413.         signals, and does not set the primary key attribute if it is an</font>
<font color="black"> 414.         autoincrement field. Multi-table models are not supported.</font>
<font color="black"> 415.         &quot;&quot;&quot;</font>
<font color="black"> 416.         # So this case is fun. When you bulk insert you don't get the primary</font>
<font color="black"> 417.         # keys back (if it's an autoincrement), so you can't insert into the</font>
<font color="black"> 418.         # child tables which references this. There are two workarounds, 1)</font>
<font color="black"> 419.         # this could be implemented if you didn't have an autoincrement pk,</font>
<font color="black"> 420.         # and 2) you could do it by doing O(n) normal inserts into the parent</font>
<font color="black"> 421.         # tables to get the primary keys back, and then doing a single bulk</font>
<font color="black"> 422.         # insert into the childmost table. Some databases might allow doing</font>
<font color="black"> 423.         # this by using RETURNING clause for the insert query. We're punting</font>
<font color="black"> 424.         # on these for now because they are relatively rare cases.</font>
<font color="green"> 425.         assert batch_size is None or batch_size &gt; 0</font>
<font color="black"> 426.         # Check that the parents share the same concrete model with the our</font>
<font color="black"> 427.         # model to detect the inheritance pattern ConcreteGrandParent -&gt;</font>
<font color="black"> 428.         # MultiTableParent -&gt; ProxyChild. Simply checking self.model._meta.proxy</font>
<font color="black"> 429.         # would not identify that case as involving multiple tables.</font>
<font color="green"> 430.         for parent in self.model._meta.get_parent_list():</font>
<font color="red"> 431.             if parent._meta.concrete_model is not self.model._meta.concrete_model:</font>
<font color="red"> 432.                 raise ValueError(&quot;Can't bulk create a multi-table inherited model&quot;)</font>
<font color="green"> 433.         if not objs:</font>
<font color="green"> 434.             return objs</font>
<font color="green"> 435.         self._for_write = True</font>
<font color="green"> 436.         connection = connections[self.db]</font>
<font color="green"> 437.         fields = self.model._meta.concrete_fields</font>
<font color="green"> 438.         objs = list(objs)</font>
<font color="green"> 439.         self._populate_pk_values(objs)</font>
<font color="green"> 440.         with transaction.atomic(using=self.db, savepoint=False):</font>
<font color="green"> 441.             if (connection.features.can_combine_inserts_with_and_without_auto_increment_pk</font>
<font color="red"> 442.                     and self.model._meta.has_auto_field):</font>
<font color="red"> 443.                 self._batched_insert(objs, fields, batch_size)</font>
<font color="black"> 444.             else:</font>
<font color="green"> 445.                 objs_with_pk, objs_without_pk = partition(lambda o: o.pk is None, objs)</font>
<font color="green"> 446.                 if objs_with_pk:</font>
<font color="red"> 447.                     self._batched_insert(objs_with_pk, fields, batch_size)</font>
<font color="green"> 448.                 if objs_without_pk:</font>
<font color="green"> 449.                     fields = [f for f in fields if not isinstance(f, AutoField)]</font>
<font color="green"> 450.                     self._batched_insert(objs_without_pk, fields, batch_size)</font>
<font color="black"> 451. </font>
<font color="green"> 452.         return objs</font>
<font color="black"> 453. </font>
<font color="green"> 454.     def get_or_create(self, defaults=None, **kwargs):</font>
<font color="black"> 455.         &quot;&quot;&quot;</font>
<font color="black"> 456.         Looks up an object with the given kwargs, creating one if necessary.</font>
<font color="black"> 457.         Returns a tuple of (object, created), where created is a boolean</font>
<font color="black"> 458.         specifying whether an object was created.</font>
<font color="black"> 459.         &quot;&quot;&quot;</font>
<font color="green"> 460.         lookup, params = self._extract_model_params(defaults, **kwargs)</font>
<font color="black"> 461.         # The get() needs to be targeted at the write database in order</font>
<font color="black"> 462.         # to avoid potential transaction consistency problems.</font>
<font color="green"> 463.         self._for_write = True</font>
<font color="green"> 464.         try:</font>
<font color="green"> 465.             return self.get(**lookup), False</font>
<font color="green"> 466.         except self.model.DoesNotExist:</font>
<font color="green"> 467.             return self._create_object_from_params(lookup, params)</font>
<font color="black"> 468. </font>
<font color="green"> 469.     def update_or_create(self, defaults=None, **kwargs):</font>
<font color="black"> 470.         &quot;&quot;&quot;</font>
<font color="black"> 471.         Looks up an object with the given kwargs, updating one with defaults</font>
<font color="black"> 472.         if it exists, otherwise creates a new one.</font>
<font color="black"> 473.         Returns a tuple (object, created), where created is a boolean</font>
<font color="black"> 474.         specifying whether an object was created.</font>
<font color="black"> 475.         &quot;&quot;&quot;</font>
<font color="red"> 476.         defaults = defaults or {}</font>
<font color="red"> 477.         lookup, params = self._extract_model_params(defaults, **kwargs)</font>
<font color="red"> 478.         self._for_write = True</font>
<font color="red"> 479.         try:</font>
<font color="red"> 480.             obj = self.get(**lookup)</font>
<font color="red"> 481.         except self.model.DoesNotExist:</font>
<font color="red"> 482.             obj, created = self._create_object_from_params(lookup, params)</font>
<font color="red"> 483.             if created:</font>
<font color="red"> 484.                 return obj, created</font>
<font color="red"> 485.         for k, v in six.iteritems(defaults):</font>
<font color="red"> 486.             setattr(obj, k, v)</font>
<font color="black"> 487. </font>
<font color="red"> 488.         with transaction.atomic(using=self.db, savepoint=False):</font>
<font color="red"> 489.             obj.save(using=self.db)</font>
<font color="red"> 490.         return obj, False</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def _create_object_from_params(self, lookup, params):</font>
<font color="black"> 493.         &quot;&quot;&quot;</font>
<font color="black"> 494.         Tries to create an object using passed params.</font>
<font color="black"> 495.         Used by get_or_create and update_or_create</font>
<font color="black"> 496.         &quot;&quot;&quot;</font>
<font color="green"> 497.         try:</font>
<font color="green"> 498.             with transaction.atomic(using=self.db):</font>
<font color="green"> 499.                 obj = self.create(**params)</font>
<font color="green"> 500.             return obj, True</font>
<font color="red"> 501.         except IntegrityError:</font>
<font color="red"> 502.             exc_info = sys.exc_info()</font>
<font color="red"> 503.             try:</font>
<font color="red"> 504.                 return self.get(**lookup), False</font>
<font color="red"> 505.             except self.model.DoesNotExist:</font>
<font color="red"> 506.                 pass</font>
<font color="red"> 507.             six.reraise(*exc_info)</font>
<font color="black"> 508. </font>
<font color="green"> 509.     def _extract_model_params(self, defaults, **kwargs):</font>
<font color="black"> 510.         &quot;&quot;&quot;</font>
<font color="black"> 511.         Prepares `lookup` (kwargs that are valid model attributes), `params`</font>
<font color="black"> 512.         (for creating a model instance) based on given kwargs; for use by</font>
<font color="black"> 513.         get_or_create and update_or_create.</font>
<font color="black"> 514.         &quot;&quot;&quot;</font>
<font color="green"> 515.         defaults = defaults or {}</font>
<font color="green"> 516.         lookup = kwargs.copy()</font>
<font color="green"> 517.         for f in self.model._meta.fields:</font>
<font color="green"> 518.             if f.attname in lookup:</font>
<font color="green"> 519.                 lookup[f.name] = lookup.pop(f.attname)</font>
<font color="green"> 520.         params = {k: v for k, v in kwargs.items() if LOOKUP_SEP not in k}</font>
<font color="green"> 521.         params.update(defaults)</font>
<font color="green"> 522.         return lookup, params</font>
<font color="black"> 523. </font>
<font color="green"> 524.     def _earliest_or_latest(self, field_name=None, direction=&quot;-&quot;):</font>
<font color="black"> 525.         &quot;&quot;&quot;</font>
<font color="black"> 526.         Returns the latest object, according to the model's</font>
<font color="black"> 527.         'get_latest_by' option or optional given field_name.</font>
<font color="black"> 528.         &quot;&quot;&quot;</font>
<font color="red"> 529.         order_by = field_name or getattr(self.model._meta, 'get_latest_by')</font>
<font color="red"> 530.         assert bool(order_by), &quot;earliest() and latest() require either a &quot;\</font>
<font color="black"> 531.             &quot;field_name parameter or 'get_latest_by' in the model&quot;</font>
<font color="red"> 532.         assert self.query.can_filter(), \</font>
<font color="red"> 533.             &quot;Cannot change a query once a slice has been taken.&quot;</font>
<font color="red"> 534.         obj = self._clone()</font>
<font color="red"> 535.         obj.query.set_limits(high=1)</font>
<font color="red"> 536.         obj.query.clear_ordering(force_empty=True)</font>
<font color="red"> 537.         obj.query.add_ordering('%s%s' % (direction, order_by))</font>
<font color="red"> 538.         return obj.get()</font>
<font color="black"> 539. </font>
<font color="green"> 540.     def earliest(self, field_name=None):</font>
<font color="red"> 541.         return self._earliest_or_latest(field_name=field_name, direction=&quot;&quot;)</font>
<font color="black"> 542. </font>
<font color="green"> 543.     def latest(self, field_name=None):</font>
<font color="red"> 544.         return self._earliest_or_latest(field_name=field_name, direction=&quot;-&quot;)</font>
<font color="black"> 545. </font>
<font color="green"> 546.     def first(self):</font>
<font color="black"> 547.         &quot;&quot;&quot;</font>
<font color="black"> 548.         Returns the first object of a query, returns None if no match is found.</font>
<font color="black"> 549.         &quot;&quot;&quot;</font>
<font color="red"> 550.         objects = list((self if self.ordered else self.order_by('pk'))[:1])</font>
<font color="red"> 551.         if objects:</font>
<font color="red"> 552.             return objects[0]</font>
<font color="red"> 553.         return None</font>
<font color="black"> 554. </font>
<font color="green"> 555.     def last(self):</font>
<font color="black"> 556.         &quot;&quot;&quot;</font>
<font color="black"> 557.         Returns the last object of a query, returns None if no match is found.</font>
<font color="black"> 558.         &quot;&quot;&quot;</font>
<font color="red"> 559.         objects = list((self.reverse() if self.ordered else self.order_by('-pk'))[:1])</font>
<font color="red"> 560.         if objects:</font>
<font color="red"> 561.             return objects[0]</font>
<font color="red"> 562.         return None</font>
<font color="black"> 563. </font>
<font color="green"> 564.     def in_bulk(self, id_list):</font>
<font color="black"> 565.         &quot;&quot;&quot;</font>
<font color="black"> 566.         Returns a dictionary mapping each of the given IDs to the object with</font>
<font color="black"> 567.         that ID.</font>
<font color="black"> 568.         &quot;&quot;&quot;</font>
<font color="red"> 569.         assert self.query.can_filter(), \</font>
<font color="red"> 570.             &quot;Cannot use 'limit' or 'offset' with in_bulk&quot;</font>
<font color="red"> 571.         if not id_list:</font>
<font color="red"> 572.             return {}</font>
<font color="red"> 573.         qs = self.filter(pk__in=id_list).order_by()</font>
<font color="red"> 574.         return {obj._get_pk_val(): obj for obj in qs}</font>
<font color="black"> 575. </font>
<font color="green"> 576.     def delete(self):</font>
<font color="black"> 577.         &quot;&quot;&quot;</font>
<font color="black"> 578.         Deletes the records in the current QuerySet.</font>
<font color="black"> 579.         &quot;&quot;&quot;</font>
<font color="red"> 580.         assert self.query.can_filter(), \</font>
<font color="red"> 581.             &quot;Cannot use 'limit' or 'offset' with delete.&quot;</font>
<font color="black"> 582. </font>
<font color="red"> 583.         if self._fields is not None:</font>
<font color="red"> 584.             raise TypeError(&quot;Cannot call delete() after .values() or .values_list()&quot;)</font>
<font color="black"> 585. </font>
<font color="red"> 586.         del_query = self._clone()</font>
<font color="black"> 587. </font>
<font color="black"> 588.         # The delete is actually 2 queries - one to find related objects,</font>
<font color="black"> 589.         # and one to delete. Make sure that the discovery of related</font>
<font color="black"> 590.         # objects is performed on the same database as the deletion.</font>
<font color="red"> 591.         del_query._for_write = True</font>
<font color="black"> 592. </font>
<font color="black"> 593.         # Disable non-supported fields.</font>
<font color="red"> 594.         del_query.query.select_for_update = False</font>
<font color="red"> 595.         del_query.query.select_related = False</font>
<font color="red"> 596.         del_query.query.clear_ordering(force_empty=True)</font>
<font color="black"> 597. </font>
<font color="red"> 598.         collector = Collector(using=del_query.db)</font>
<font color="red"> 599.         collector.collect(del_query)</font>
<font color="red"> 600.         deleted, _rows_count = collector.delete()</font>
<font color="black"> 601. </font>
<font color="black"> 602.         # Clear the result cache, in case this QuerySet gets reused.</font>
<font color="red"> 603.         self._result_cache = None</font>
<font color="red"> 604.         return deleted, _rows_count</font>
<font color="black"> 605. </font>
<font color="green"> 606.     delete.alters_data = True</font>
<font color="green"> 607.     delete.queryset_only = True</font>
<font color="black"> 608. </font>
<font color="green"> 609.     def _raw_delete(self, using):</font>
<font color="black"> 610.         &quot;&quot;&quot;</font>
<font color="black"> 611.         Deletes objects found from the given queryset in single direct SQL</font>
<font color="black"> 612.         query. No signals are sent, and there is no protection for cascades.</font>
<font color="black"> 613.         &quot;&quot;&quot;</font>
<font color="red"> 614.         return sql.DeleteQuery(self.model).delete_qs(self, using)</font>
<font color="green"> 615.     _raw_delete.alters_data = True</font>
<font color="black"> 616. </font>
<font color="green"> 617.     def update(self, **kwargs):</font>
<font color="black"> 618.         &quot;&quot;&quot;</font>
<font color="black"> 619.         Updates all elements in the current QuerySet, setting all the given</font>
<font color="black"> 620.         fields to the appropriate values.</font>
<font color="black"> 621.         &quot;&quot;&quot;</font>
<font color="red"> 622.         assert self.query.can_filter(), \</font>
<font color="red"> 623.             &quot;Cannot update a query once a slice has been taken.&quot;</font>
<font color="red"> 624.         self._for_write = True</font>
<font color="red"> 625.         query = self.query.clone(sql.UpdateQuery)</font>
<font color="red"> 626.         query.add_update_values(kwargs)</font>
<font color="red"> 627.         with transaction.atomic(using=self.db, savepoint=False):</font>
<font color="red"> 628.             rows = query.get_compiler(self.db).execute_sql(CURSOR)</font>
<font color="red"> 629.         self._result_cache = None</font>
<font color="red"> 630.         return rows</font>
<font color="green"> 631.     update.alters_data = True</font>
<font color="black"> 632. </font>
<font color="green"> 633.     def _update(self, values):</font>
<font color="black"> 634.         &quot;&quot;&quot;</font>
<font color="black"> 635.         A version of update that accepts field objects instead of field names.</font>
<font color="black"> 636.         Used primarily for model saving and not intended for use by general</font>
<font color="black"> 637.         code (it requires too much poking around at model internals to be</font>
<font color="black"> 638.         useful at that level).</font>
<font color="black"> 639.         &quot;&quot;&quot;</font>
<font color="red"> 640.         assert self.query.can_filter(), \</font>
<font color="red"> 641.             &quot;Cannot update a query once a slice has been taken.&quot;</font>
<font color="red"> 642.         query = self.query.clone(sql.UpdateQuery)</font>
<font color="red"> 643.         query.add_update_fields(values)</font>
<font color="red"> 644.         self._result_cache = None</font>
<font color="red"> 645.         return query.get_compiler(self.db).execute_sql(CURSOR)</font>
<font color="green"> 646.     _update.alters_data = True</font>
<font color="green"> 647.     _update.queryset_only = False</font>
<font color="black"> 648. </font>
<font color="green"> 649.     def exists(self):</font>
<font color="red"> 650.         if self._result_cache is None:</font>
<font color="red"> 651.             return self.query.has_results(using=self.db)</font>
<font color="red"> 652.         return bool(self._result_cache)</font>
<font color="black"> 653. </font>
<font color="green"> 654.     def _prefetch_related_objects(self):</font>
<font color="black"> 655.         # This method can only be called once the result cache has been filled.</font>
<font color="red"> 656.         prefetch_related_objects(self._result_cache, self._prefetch_related_lookups)</font>
<font color="red"> 657.         self._prefetch_done = True</font>
<font color="black"> 658. </font>
<font color="black"> 659.     ##################################################</font>
<font color="black"> 660.     # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #</font>
<font color="black"> 661.     ##################################################</font>
<font color="black"> 662. </font>
<font color="green"> 663.     def raw(self, raw_query, params=None, translations=None, using=None):</font>
<font color="red"> 664.         if using is None:</font>
<font color="red"> 665.             using = self.db</font>
<font color="red"> 666.         return RawQuerySet(raw_query, model=self.model,</font>
<font color="red"> 667.                 params=params, translations=translations,</font>
<font color="red"> 668.                 using=using)</font>
<font color="black"> 669. </font>
<font color="green"> 670.     def _values(self, *fields):</font>
<font color="green"> 671.         clone = self._clone()</font>
<font color="green"> 672.         clone._fields = fields</font>
<font color="black"> 673. </font>
<font color="green"> 674.         query = clone.query</font>
<font color="green"> 675.         query.select_related = False</font>
<font color="green"> 676.         query.clear_deferred_loading()</font>
<font color="green"> 677.         query.clear_select_fields()</font>
<font color="black"> 678. </font>
<font color="green"> 679.         if query.group_by is True:</font>
<font color="red"> 680.             query.add_fields((f.attname for f in self.model._meta.concrete_fields), False)</font>
<font color="red"> 681.             query.set_group_by()</font>
<font color="red"> 682.             query.clear_select_fields()</font>
<font color="black"> 683. </font>
<font color="green"> 684.         if fields:</font>
<font color="green"> 685.             field_names = []</font>
<font color="green"> 686.             extra_names = []</font>
<font color="green"> 687.             annotation_names = []</font>
<font color="green"> 688.             if not query._extra and not query._annotations:</font>
<font color="black"> 689.                 # Shortcut - if there are no extra or annotations, then</font>
<font color="black"> 690.                 # the values() clause must be just field names.</font>
<font color="green"> 691.                 field_names = list(fields)</font>
<font color="black"> 692.             else:</font>
<font color="red"> 693.                 query.default_cols = False</font>
<font color="red"> 694.                 for f in fields:</font>
<font color="red"> 695.                     if f in query.extra_select:</font>
<font color="red"> 696.                         extra_names.append(f)</font>
<font color="red"> 697.                     elif f in query.annotation_select:</font>
<font color="red"> 698.                         annotation_names.append(f)</font>
<font color="black"> 699.                     else:</font>
<font color="red"> 700.                         field_names.append(f)</font>
<font color="green"> 701.             query.set_extra_mask(extra_names)</font>
<font color="green"> 702.             query.set_annotation_mask(annotation_names)</font>
<font color="black"> 703.         else:</font>
<font color="red"> 704.             field_names = [f.attname for f in self.model._meta.concrete_fields]</font>
<font color="black"> 705. </font>
<font color="green"> 706.         query.values_select = field_names</font>
<font color="green"> 707.         query.add_fields(field_names, True)</font>
<font color="black"> 708. </font>
<font color="green"> 709.         return clone</font>
<font color="black"> 710. </font>
<font color="green"> 711.     def values(self, *fields):</font>
<font color="red"> 712.         clone = self._values(*fields)</font>
<font color="red"> 713.         clone._iterable_class = ValuesIterable</font>
<font color="red"> 714.         return clone</font>
<font color="black"> 715. </font>
<font color="green"> 716.     def values_list(self, *fields, **kwargs):</font>
<font color="green"> 717.         flat = kwargs.pop('flat', False)</font>
<font color="green"> 718.         if kwargs:</font>
<font color="red"> 719.             raise TypeError('Unexpected keyword arguments to values_list: %s'</font>
<font color="red"> 720.                     % (list(kwargs),))</font>
<font color="black"> 721. </font>
<font color="green"> 722.         if flat and len(fields) &gt; 1:</font>
<font color="red"> 723.             raise TypeError(&quot;'flat' is not valid when values_list is called with more than one field.&quot;)</font>
<font color="black"> 724. </font>
<font color="green"> 725.         clone = self._values(*fields)</font>
<font color="green"> 726.         clone._iterable_class = FlatValuesListIterable if flat else ValuesListIterable</font>
<font color="green"> 727.         return clone</font>
<font color="black"> 728. </font>
<font color="green"> 729.     def dates(self, field_name, kind, order='ASC'):</font>
<font color="black"> 730.         &quot;&quot;&quot;</font>
<font color="black"> 731.         Returns a list of date objects representing all available dates for</font>
<font color="black"> 732.         the given field_name, scoped to 'kind'.</font>
<font color="black"> 733.         &quot;&quot;&quot;</font>
<font color="red"> 734.         assert kind in (&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), \</font>
<font color="red"> 735.             &quot;'kind' must be one of 'year', 'month' or 'day'.&quot;</font>
<font color="red"> 736.         assert order in ('ASC', 'DESC'), \</font>
<font color="red"> 737.             &quot;'order' must be either 'ASC' or 'DESC'.&quot;</font>
<font color="red"> 738.         return self.annotate(</font>
<font color="red"> 739.             datefield=Date(field_name, kind),</font>
<font color="red"> 740.             plain_field=F(field_name)</font>
<font color="black"> 741.         ).values_list(</font>
<font color="red"> 742.             'datefield', flat=True</font>
<font color="red"> 743.         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datefield')</font>
<font color="black"> 744. </font>
<font color="green"> 745.     def datetimes(self, field_name, kind, order='ASC', tzinfo=None):</font>
<font color="black"> 746.         &quot;&quot;&quot;</font>
<font color="black"> 747.         Returns a list of datetime objects representing all available</font>
<font color="black"> 748.         datetimes for the given field_name, scoped to 'kind'.</font>
<font color="black"> 749.         &quot;&quot;&quot;</font>
<font color="red"> 750.         assert kind in (&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;), \</font>
<font color="red"> 751.             &quot;'kind' must be one of 'year', 'month', 'day', 'hour', 'minute' or 'second'.&quot;</font>
<font color="red"> 752.         assert order in ('ASC', 'DESC'), \</font>
<font color="red"> 753.             &quot;'order' must be either 'ASC' or 'DESC'.&quot;</font>
<font color="red"> 754.         if settings.USE_TZ:</font>
<font color="red"> 755.             if tzinfo is None:</font>
<font color="red"> 756.                 tzinfo = timezone.get_current_timezone()</font>
<font color="black"> 757.         else:</font>
<font color="red"> 758.             tzinfo = None</font>
<font color="red"> 759.         return self.annotate(</font>
<font color="red"> 760.             datetimefield=DateTime(field_name, kind, tzinfo),</font>
<font color="red"> 761.             plain_field=F(field_name)</font>
<font color="black"> 762.         ).values_list(</font>
<font color="red"> 763.             'datetimefield', flat=True</font>
<font color="red"> 764.         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')</font>
<font color="black"> 765. </font>
<font color="green"> 766.     def none(self):</font>
<font color="black"> 767.         &quot;&quot;&quot;</font>
<font color="black"> 768.         Returns an empty QuerySet.</font>
<font color="black"> 769.         &quot;&quot;&quot;</font>
<font color="red"> 770.         clone = self._clone()</font>
<font color="red"> 771.         clone.query.set_empty()</font>
<font color="red"> 772.         return clone</font>
<font color="black"> 773. </font>
<font color="black"> 774.     ##################################################################</font>
<font color="black"> 775.     # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #</font>
<font color="black"> 776.     ##################################################################</font>
<font color="black"> 777. </font>
<font color="green"> 778.     def all(self):</font>
<font color="black"> 779.         &quot;&quot;&quot;</font>
<font color="black"> 780.         Returns a new QuerySet that is a copy of the current one. This allows a</font>
<font color="black"> 781.         QuerySet to proxy for a model manager in some cases.</font>
<font color="black"> 782.         &quot;&quot;&quot;</font>
<font color="red"> 783.         return self._clone()</font>
<font color="black"> 784. </font>
<font color="green"> 785.     def filter(self, *args, **kwargs):</font>
<font color="black"> 786.         &quot;&quot;&quot;</font>
<font color="black"> 787.         Returns a new QuerySet instance with the args ANDed to the existing</font>
<font color="black"> 788.         set.</font>
<font color="black"> 789.         &quot;&quot;&quot;</font>
<font color="green"> 790.         return self._filter_or_exclude(False, *args, **kwargs)</font>
<font color="black"> 791. </font>
<font color="green"> 792.     def exclude(self, *args, **kwargs):</font>
<font color="black"> 793.         &quot;&quot;&quot;</font>
<font color="black"> 794.         Returns a new QuerySet instance with NOT (args) ANDed to the existing</font>
<font color="black"> 795.         set.</font>
<font color="black"> 796.         &quot;&quot;&quot;</font>
<font color="red"> 797.         return self._filter_or_exclude(True, *args, **kwargs)</font>
<font color="black"> 798. </font>
<font color="green"> 799.     def _filter_or_exclude(self, negate, *args, **kwargs):</font>
<font color="green"> 800.         if args or kwargs:</font>
<font color="green"> 801.             assert self.query.can_filter(), \</font>
<font color="red"> 802.                 &quot;Cannot filter a query once a slice has been taken.&quot;</font>
<font color="black"> 803. </font>
<font color="green"> 804.         clone = self._clone()</font>
<font color="green"> 805.         if negate:</font>
<font color="red"> 806.             clone.query.add_q(~Q(*args, **kwargs))</font>
<font color="black"> 807.         else:</font>
<font color="green"> 808.             clone.query.add_q(Q(*args, **kwargs))</font>
<font color="green"> 809.         return clone</font>
<font color="black"> 810. </font>
<font color="green"> 811.     def complex_filter(self, filter_obj):</font>
<font color="black"> 812.         &quot;&quot;&quot;</font>
<font color="black"> 813.         Returns a new QuerySet instance with filter_obj added to the filters.</font>
<font color="black"> 814. </font>
<font color="black"> 815.         filter_obj can be a Q object (or anything with an add_to_query()</font>
<font color="black"> 816.         method) or a dictionary of keyword lookup arguments.</font>
<font color="black"> 817. </font>
<font color="black"> 818.         This exists to support framework features such as 'limit_choices_to',</font>
<font color="black"> 819.         and usually it will be more natural to use other methods.</font>
<font color="black"> 820.         &quot;&quot;&quot;</font>
<font color="red"> 821.         if isinstance(filter_obj, Q) or hasattr(filter_obj, 'add_to_query'):</font>
<font color="red"> 822.             clone = self._clone()</font>
<font color="red"> 823.             clone.query.add_q(filter_obj)</font>
<font color="red"> 824.             return clone</font>
<font color="black"> 825.         else:</font>
<font color="red"> 826.             return self._filter_or_exclude(None, **filter_obj)</font>
<font color="black"> 827. </font>
<font color="green"> 828.     def select_for_update(self, nowait=False):</font>
<font color="black"> 829.         &quot;&quot;&quot;</font>
<font color="black"> 830.         Returns a new QuerySet instance that will select objects with a</font>
<font color="black"> 831.         FOR UPDATE lock.</font>
<font color="black"> 832.         &quot;&quot;&quot;</font>
<font color="red"> 833.         obj = self._clone()</font>
<font color="red"> 834.         obj._for_write = True</font>
<font color="red"> 835.         obj.query.select_for_update = True</font>
<font color="red"> 836.         obj.query.select_for_update_nowait = nowait</font>
<font color="red"> 837.         return obj</font>
<font color="black"> 838. </font>
<font color="green"> 839.     def select_related(self, *fields):</font>
<font color="black"> 840.         &quot;&quot;&quot;</font>
<font color="black"> 841.         Returns a new QuerySet instance that will select related objects.</font>
<font color="black"> 842. </font>
<font color="black"> 843.         If fields are specified, they must be ForeignKey fields and only those</font>
<font color="black"> 844.         related objects are included in the selection.</font>
<font color="black"> 845. </font>
<font color="black"> 846.         If select_related(None) is called, the list is cleared.</font>
<font color="black"> 847.         &quot;&quot;&quot;</font>
<font color="black"> 848. </font>
<font color="red"> 849.         if self._fields is not None:</font>
<font color="red"> 850.             raise TypeError(&quot;Cannot call select_related() after .values() or .values_list()&quot;)</font>
<font color="black"> 851. </font>
<font color="red"> 852.         obj = self._clone()</font>
<font color="red"> 853.         if fields == (None,):</font>
<font color="red"> 854.             obj.query.select_related = False</font>
<font color="red"> 855.         elif fields:</font>
<font color="red"> 856.             obj.query.add_select_related(fields)</font>
<font color="black"> 857.         else:</font>
<font color="red"> 858.             obj.query.select_related = True</font>
<font color="red"> 859.         return obj</font>
<font color="black"> 860. </font>
<font color="green"> 861.     def prefetch_related(self, *lookups):</font>
<font color="black"> 862.         &quot;&quot;&quot;</font>
<font color="black"> 863.         Returns a new QuerySet instance that will prefetch the specified</font>
<font color="black"> 864.         Many-To-One and Many-To-Many related objects when the QuerySet is</font>
<font color="black"> 865.         evaluated.</font>
<font color="black"> 866. </font>
<font color="black"> 867.         When prefetch_related() is called more than once, the list of lookups to</font>
<font color="black"> 868.         prefetch is appended to. If prefetch_related(None) is called, the list</font>
<font color="black"> 869.         is cleared.</font>
<font color="black"> 870.         &quot;&quot;&quot;</font>
<font color="red"> 871.         clone = self._clone()</font>
<font color="red"> 872.         if lookups == (None,):</font>
<font color="red"> 873.             clone._prefetch_related_lookups = []</font>
<font color="black"> 874.         else:</font>
<font color="red"> 875.             clone._prefetch_related_lookups.extend(lookups)</font>
<font color="red"> 876.         return clone</font>
<font color="black"> 877. </font>
<font color="green"> 878.     def annotate(self, *args, **kwargs):</font>
<font color="black"> 879.         &quot;&quot;&quot;</font>
<font color="black"> 880.         Return a query set in which the returned objects have been annotated</font>
<font color="black"> 881.         with extra data or aggregations.</font>
<font color="black"> 882.         &quot;&quot;&quot;</font>
<font color="red"> 883.         annotations = OrderedDict()  # To preserve ordering of args</font>
<font color="red"> 884.         for arg in args:</font>
<font color="black"> 885.             # The default_alias property may raise a TypeError, so we use</font>
<font color="black"> 886.             # a try/except construct rather than hasattr in order to remain</font>
<font color="black"> 887.             # consistent between PY2 and PY3 (hasattr would swallow</font>
<font color="black"> 888.             # the TypeError on PY2).</font>
<font color="red"> 889.             try:</font>
<font color="red"> 890.                 if arg.default_alias in kwargs:</font>
<font color="red"> 891.                     raise ValueError(&quot;The named annotation '%s' conflicts with the &quot;</font>
<font color="black"> 892.                                      &quot;default name for another annotation.&quot;</font>
<font color="red"> 893.                                      % arg.default_alias)</font>
<font color="red"> 894.             except (AttributeError, TypeError):</font>
<font color="red"> 895.                 raise TypeError(&quot;Complex annotations require an alias&quot;)</font>
<font color="red"> 896.             annotations[arg.default_alias] = arg</font>
<font color="red"> 897.         annotations.update(kwargs)</font>
<font color="black"> 898. </font>
<font color="red"> 899.         clone = self._clone()</font>
<font color="red"> 900.         names = self._fields</font>
<font color="red"> 901.         if names is None:</font>
<font color="red"> 902.             names = {f.name for f in self.model._meta.get_fields()}</font>
<font color="black"> 903. </font>
<font color="red"> 904.         for alias, annotation in annotations.items():</font>
<font color="red"> 905.             if alias in names:</font>
<font color="red"> 906.                 raise ValueError(&quot;The annotation '%s' conflicts with a field on &quot;</font>
<font color="red"> 907.                                  &quot;the model.&quot; % alias)</font>
<font color="red"> 908.             clone.query.add_annotation(annotation, alias, is_summary=False)</font>
<font color="black"> 909. </font>
<font color="red"> 910.         for alias, annotation in clone.query.annotations.items():</font>
<font color="red"> 911.             if alias in annotations and annotation.contains_aggregate:</font>
<font color="red"> 912.                 if clone._fields is None:</font>
<font color="red"> 913.                     clone.query.group_by = True</font>
<font color="black"> 914.                 else:</font>
<font color="red"> 915.                     clone.query.set_group_by()</font>
<font color="red"> 916.                 break</font>
<font color="black"> 917. </font>
<font color="red"> 918.         return clone</font>
<font color="black"> 919. </font>
<font color="green"> 920.     def order_by(self, *field_names):</font>
<font color="black"> 921.         &quot;&quot;&quot;</font>
<font color="black"> 922.         Returns a new QuerySet instance with the ordering changed.</font>
<font color="black"> 923.         &quot;&quot;&quot;</font>
<font color="green"> 924.         assert self.query.can_filter(), \</font>
<font color="red"> 925.             &quot;Cannot reorder a query once a slice has been taken.&quot;</font>
<font color="green"> 926.         obj = self._clone()</font>
<font color="green"> 927.         obj.query.clear_ordering(force_empty=False)</font>
<font color="green"> 928.         obj.query.add_ordering(*field_names)</font>
<font color="green"> 929.         return obj</font>
<font color="black"> 930. </font>
<font color="green"> 931.     def distinct(self, *field_names):</font>
<font color="black"> 932.         &quot;&quot;&quot;</font>
<font color="black"> 933.         Returns a new QuerySet instance that will select only distinct results.</font>
<font color="black"> 934.         &quot;&quot;&quot;</font>
<font color="red"> 935.         assert self.query.can_filter(), \</font>
<font color="red"> 936.             &quot;Cannot create distinct fields once a slice has been taken.&quot;</font>
<font color="red"> 937.         obj = self._clone()</font>
<font color="red"> 938.         obj.query.add_distinct_fields(*field_names)</font>
<font color="red"> 939.         return obj</font>
<font color="black"> 940. </font>
<font color="green"> 941.     def extra(self, select=None, where=None, params=None, tables=None,</font>
<font color="green"> 942.               order_by=None, select_params=None):</font>
<font color="black"> 943.         &quot;&quot;&quot;</font>
<font color="black"> 944.         Adds extra SQL fragments to the query.</font>
<font color="black"> 945.         &quot;&quot;&quot;</font>
<font color="red"> 946.         assert self.query.can_filter(), \</font>
<font color="red"> 947.             &quot;Cannot change a query once a slice has been taken&quot;</font>
<font color="red"> 948.         clone = self._clone()</font>
<font color="red"> 949.         clone.query.add_extra(select, select_params, where, params, tables, order_by)</font>
<font color="red"> 950.         return clone</font>
<font color="black"> 951. </font>
<font color="green"> 952.     def reverse(self):</font>
<font color="black"> 953.         &quot;&quot;&quot;</font>
<font color="black"> 954.         Reverses the ordering of the QuerySet.</font>
<font color="black"> 955.         &quot;&quot;&quot;</font>
<font color="red"> 956.         clone = self._clone()</font>
<font color="red"> 957.         clone.query.standard_ordering = not clone.query.standard_ordering</font>
<font color="red"> 958.         return clone</font>
<font color="black"> 959. </font>
<font color="green"> 960.     def defer(self, *fields):</font>
<font color="black"> 961.         &quot;&quot;&quot;</font>
<font color="black"> 962.         Defers the loading of data for certain fields until they are accessed.</font>
<font color="black"> 963.         The set of fields to defer is added to any existing set of deferred</font>
<font color="black"> 964.         fields. The only exception to this is if None is passed in as the only</font>
<font color="black"> 965.         parameter, in which case all deferrals are removed (None acts as a</font>
<font color="black"> 966.         reset option).</font>
<font color="black"> 967.         &quot;&quot;&quot;</font>
<font color="red"> 968.         if self._fields is not None:</font>
<font color="red"> 969.             raise TypeError(&quot;Cannot call defer() after .values() or .values_list()&quot;)</font>
<font color="red"> 970.         clone = self._clone()</font>
<font color="red"> 971.         if fields == (None,):</font>
<font color="red"> 972.             clone.query.clear_deferred_loading()</font>
<font color="black"> 973.         else:</font>
<font color="red"> 974.             clone.query.add_deferred_loading(fields)</font>
<font color="red"> 975.         return clone</font>
<font color="black"> 976. </font>
<font color="green"> 977.     def only(self, *fields):</font>
<font color="black"> 978.         &quot;&quot;&quot;</font>
<font color="black"> 979.         Essentially, the opposite of defer. Only the fields passed into this</font>
<font color="black"> 980.         method and that are not already specified as deferred are loaded</font>
<font color="black"> 981.         immediately when the queryset is evaluated.</font>
<font color="black"> 982.         &quot;&quot;&quot;</font>
<font color="red"> 983.         if self._fields is not None:</font>
<font color="red"> 984.             raise TypeError(&quot;Cannot call only() after .values() or .values_list()&quot;)</font>
<font color="red"> 985.         if fields == (None,):</font>
<font color="black"> 986.             # Can only pass None to defer(), not only(), as the rest option.</font>
<font color="black"> 987.             # That won't stop people trying to do this, so let's be explicit.</font>
<font color="red"> 988.             raise TypeError(&quot;Cannot pass None as an argument to only().&quot;)</font>
<font color="red"> 989.         clone = self._clone()</font>
<font color="red"> 990.         clone.query.add_immediate_loading(fields)</font>
<font color="red"> 991.         return clone</font>
<font color="black"> 992. </font>
<font color="green"> 993.     def using(self, alias):</font>
<font color="black"> 994.         &quot;&quot;&quot;</font>
<font color="black"> 995.         Selects which database this QuerySet should execute its query against.</font>
<font color="black"> 996.         &quot;&quot;&quot;</font>
<font color="green"> 997.         clone = self._clone()</font>
<font color="green"> 998.         clone._db = alias</font>
<font color="green"> 999.         return clone</font>
<font color="black">1000. </font>
<font color="black">1001.     ###################################</font>
<font color="black">1002.     # PUBLIC INTROSPECTION ATTRIBUTES #</font>
<font color="black">1003.     ###################################</font>
<font color="black">1004. </font>
<font color="green">1005.     def ordered(self):</font>
<font color="black">1006.         &quot;&quot;&quot;</font>
<font color="black">1007.         Returns True if the QuerySet is ordered -- i.e. has an order_by()</font>
<font color="black">1008.         clause or a default ordering on the model.</font>
<font color="black">1009.         &quot;&quot;&quot;</font>
<font color="red">1010.         if self.query.extra_order_by or self.query.order_by:</font>
<font color="red">1011.             return True</font>
<font color="red">1012.         elif self.query.default_ordering and self.query.get_meta().ordering:</font>
<font color="red">1013.             return True</font>
<font color="black">1014.         else:</font>
<font color="red">1015.             return False</font>
<font color="green">1016.     ordered = property(ordered)</font>
<font color="black">1017. </font>
<font color="green">1018.     @property</font>
<font color="black">1019.     def db(self):</font>
<font color="black">1020.         &quot;Return the database that will be used if this query is executed now&quot;</font>
<font color="green">1021.         if self._for_write:</font>
<font color="green">1022.             return self._db or router.db_for_write(self.model, **self._hints)</font>
<font color="green">1023.         return self._db or router.db_for_read(self.model, **self._hints)</font>
<font color="black">1024. </font>
<font color="black">1025.     ###################</font>
<font color="black">1026.     # PRIVATE METHODS #</font>
<font color="black">1027.     ###################</font>
<font color="black">1028. </font>
<font color="green">1029.     def _insert(self, objs, fields, return_id=False, raw=False, using=None):</font>
<font color="black">1030.         &quot;&quot;&quot;</font>
<font color="black">1031.         Inserts a new record for the given model. This provides an interface to</font>
<font color="black">1032.         the InsertQuery class and is how Model.save() is implemented.</font>
<font color="black">1033.         &quot;&quot;&quot;</font>
<font color="green">1034.         self._for_write = True</font>
<font color="green">1035.         if using is None:</font>
<font color="red">1036.             using = self.db</font>
<font color="green">1037.         query = sql.InsertQuery(self.model)</font>
<font color="green">1038.         query.insert_values(fields, objs, raw=raw)</font>
<font color="green">1039.         return query.get_compiler(using=using).execute_sql(return_id)</font>
<font color="green">1040.     _insert.alters_data = True</font>
<font color="green">1041.     _insert.queryset_only = False</font>
<font color="black">1042. </font>
<font color="green">1043.     def _batched_insert(self, objs, fields, batch_size):</font>
<font color="black">1044.         &quot;&quot;&quot;</font>
<font color="black">1045.         A little helper method for bulk_insert to insert the bulk one batch</font>
<font color="black">1046.         at a time. Inserts recursively a batch from the front of the bulk and</font>
<font color="black">1047.         then _batched_insert() the remaining objects again.</font>
<font color="black">1048.         &quot;&quot;&quot;</font>
<font color="green">1049.         if not objs:</font>
<font color="red">1050.             return</font>
<font color="green">1051.         ops = connections[self.db].ops</font>
<font color="green">1052.         batch_size = (batch_size or max(ops.bulk_batch_size(fields, objs), 1))</font>
<font color="green">1053.         for batch in [objs[i:i + batch_size]</font>
<font color="green">1054.                       for i in range(0, len(objs), batch_size)]:</font>
<font color="green">1055.             self.model._base_manager._insert(batch, fields=fields,</font>
<font color="green">1056.                                              using=self.db)</font>
<font color="black">1057. </font>
<font color="green">1058.     def _clone(self, **kwargs):</font>
<font color="green">1059.         query = self.query.clone()</font>
<font color="green">1060.         if self._sticky_filter:</font>
<font color="red">1061.             query.filter_is_sticky = True</font>
<font color="green">1062.         clone = self.__class__(model=self.model, query=query, using=self._db, hints=self._hints)</font>
<font color="green">1063.         clone._for_write = self._for_write</font>
<font color="green">1064.         clone._prefetch_related_lookups = self._prefetch_related_lookups[:]</font>
<font color="green">1065.         clone._known_related_objects = self._known_related_objects</font>
<font color="green">1066.         clone._iterable_class = self._iterable_class</font>
<font color="green">1067.         clone._fields = self._fields</font>
<font color="black">1068. </font>
<font color="green">1069.         clone.__dict__.update(kwargs)</font>
<font color="green">1070.         return clone</font>
<font color="black">1071. </font>
<font color="green">1072.     def _fetch_all(self):</font>
<font color="green">1073.         if self._result_cache is None:</font>
<font color="green">1074.             self._result_cache = list(self.iterator())</font>
<font color="green">1075.         if self._prefetch_related_lookups and not self._prefetch_done:</font>
<font color="red">1076.             self._prefetch_related_objects()</font>
<font color="black">1077. </font>
<font color="green">1078.     def _next_is_sticky(self):</font>
<font color="black">1079.         &quot;&quot;&quot;</font>
<font color="black">1080.         Indicates that the next filter call and the one following that should</font>
<font color="black">1081.         be treated as a single filter. This is only important when it comes to</font>
<font color="black">1082.         determining when to reuse tables for many-to-many filters. Required so</font>
<font color="black">1083.         that we can filter naturally on the results of related managers.</font>
<font color="black">1084. </font>
<font color="black">1085.         This doesn't return a clone of the current QuerySet (it returns</font>
<font color="black">1086.         &quot;self&quot;). The method is only used internally and should be immediately</font>
<font color="black">1087.         followed by a filter() that does create a clone.</font>
<font color="black">1088.         &quot;&quot;&quot;</font>
<font color="red">1089.         self._sticky_filter = True</font>
<font color="red">1090.         return self</font>
<font color="black">1091. </font>
<font color="green">1092.     def _merge_sanity_check(self, other):</font>
<font color="black">1093.         &quot;&quot;&quot;</font>
<font color="black">1094.         Checks that we are merging two comparable QuerySet classes.</font>
<font color="black">1095.         &quot;&quot;&quot;</font>
<font color="red">1096.         if self._fields is not None and (</font>
<font color="red">1097.                 set(self.query.values_select) != set(other.query.values_select) or</font>
<font color="red">1098.                 set(self.query.extra_select) != set(other.query.extra_select) or</font>
<font color="red">1099.                 set(self.query.annotation_select) != set(other.query.annotation_select)):</font>
<font color="red">1100.             raise TypeError(&quot;Merging '%s' classes must involve the same values in each case.&quot;</font>
<font color="red">1101.                     % self.__class__.__name__)</font>
<font color="black">1102. </font>
<font color="green">1103.     def _merge_known_related_objects(self, other):</font>
<font color="black">1104.         &quot;&quot;&quot;</font>
<font color="black">1105.         Keep track of all known related objects from either QuerySet instance.</font>
<font color="black">1106.         &quot;&quot;&quot;</font>
<font color="red">1107.         for field, objects in other._known_related_objects.items():</font>
<font color="red">1108.             self._known_related_objects.setdefault(field, {}).update(objects)</font>
<font color="black">1109. </font>
<font color="green">1110.     def _prepare(self):</font>
<font color="red">1111.         if self._fields is not None:</font>
<font color="black">1112.             # values() queryset can only be used as nested queries</font>
<font color="black">1113.             # if they are set up to select only a single field.</font>
<font color="red">1114.             if len(self._fields or self.model._meta.concrete_fields) &gt; 1:</font>
<font color="red">1115.                 raise TypeError('Cannot use multi-field values as a filter value.')</font>
<font color="red">1116.         return self</font>
<font color="black">1117. </font>
<font color="green">1118.     def _as_sql(self, connection):</font>
<font color="black">1119.         &quot;&quot;&quot;</font>
<font color="black">1120.         Returns the internal query's SQL and parameters (as a tuple).</font>
<font color="black">1121.         &quot;&quot;&quot;</font>
<font color="red">1122.         if self._fields is not None:</font>
<font color="black">1123.             # values() queryset can only be used as nested queries</font>
<font color="black">1124.             # if they are set up to select only a single field.</font>
<font color="red">1125.             if len(self._fields or self.model._meta.concrete_fields) &gt; 1:</font>
<font color="red">1126.                 raise TypeError('Cannot use multi-field values as a filter value.')</font>
<font color="red">1127.             clone = self._clone()</font>
<font color="black">1128.         else:</font>
<font color="red">1129.             clone = self.values('pk')</font>
<font color="black">1130. </font>
<font color="red">1131.         if clone._db is None or connection == connections[clone._db]:</font>
<font color="red">1132.             return clone.query.get_compiler(connection=connection).as_nested_sql()</font>
<font color="red">1133.         raise ValueError(&quot;Can't do subqueries with queries on different DBs.&quot;)</font>
<font color="black">1134. </font>
<font color="black">1135.     # When used as part of a nested query, a queryset will never be an &quot;always</font>
<font color="black">1136.     # empty&quot; result.</font>
<font color="green">1137.     value_annotation = True</font>
<font color="black">1138. </font>
<font color="green">1139.     def _add_hints(self, **hints):</font>
<font color="black">1140.         &quot;&quot;&quot;</font>
<font color="black">1141.         Update hinting information for later use by Routers</font>
<font color="black">1142.         &quot;&quot;&quot;</font>
<font color="black">1143.         # If there is any hinting information, add it to what we already know.</font>
<font color="black">1144.         # If we have a new hint for an existing key, overwrite with the new value.</font>
<font color="red">1145.         self._hints.update(hints)</font>
<font color="black">1146. </font>
<font color="green">1147.     def _has_filters(self):</font>
<font color="black">1148.         &quot;&quot;&quot;</font>
<font color="black">1149.         Checks if this QuerySet has any filtering going on. Note that this</font>
<font color="black">1150.         isn't equivalent for checking if all objects are present in results,</font>
<font color="black">1151.         for example qs[1:]._has_filters() -&gt; False.</font>
<font color="black">1152.         &quot;&quot;&quot;</font>
<font color="red">1153.         return self.query.has_filters()</font>
<font color="black">1154. </font>
<font color="green">1155.     def is_compatible_query_object_type(self, opts, field):</font>
<font color="black">1156.         &quot;&quot;&quot;</font>
<font color="black">1157.         Check that using this queryset as the rhs value for a lookup is</font>
<font color="black">1158.         allowed. The opts are the options of the relation's target we are</font>
<font color="black">1159.         querying against. For example in .filter(author__in=Author.objects.all())</font>
<font color="black">1160.         the opts would be Author's (from the author field) and self.model would</font>
<font color="black">1161.         be Author.objects.all() queryset's .model (Author also). The field is</font>
<font color="black">1162.         the related field on the lhs side.</font>
<font color="black">1163.         &quot;&quot;&quot;</font>
<font color="black">1164.         # We trust that users of values() know what they are doing.</font>
<font color="red">1165.         if self._fields is not None:</font>
<font color="red">1166.             return True</font>
<font color="red">1167.         return check_rel_lookup_compatibility(self.model, opts, field)</font>
<font color="green">1168.     is_compatible_query_object_type.queryset_only = True</font>
<font color="black">1169. </font>
<font color="black">1170. </font>
<font color="green">1171. class InstanceCheckMeta(type):</font>
<font color="green">1172.     def __instancecheck__(self, instance):</font>
<font color="red">1173.         return instance.query.is_empty()</font>
<font color="black">1174. </font>
<font color="black">1175. </font>
<font color="green">1176. class EmptyQuerySet(six.with_metaclass(InstanceCheckMeta)):</font>
<font color="black">1177.     &quot;&quot;&quot;</font>
<font color="black">1178.     Marker class usable for checking if a queryset is empty by .none():</font>
<font color="black">1179.         isinstance(qs.none(), EmptyQuerySet) -&gt; True</font>
<font color="green">1180.     &quot;&quot;&quot;</font>
<font color="black">1181. </font>
<font color="green">1182.     def __init__(self, *args, **kwargs):</font>
<font color="red">1183.         raise TypeError(&quot;EmptyQuerySet can't be instantiated&quot;)</font>
<font color="black">1184. </font>
<font color="black">1185. </font>
<font color="green">1186. class RawQuerySet(object):</font>
<font color="black">1187.     &quot;&quot;&quot;</font>
<font color="black">1188.     Provides an iterator which converts the results of raw SQL queries into</font>
<font color="black">1189.     annotated model instances.</font>
<font color="green">1190.     &quot;&quot;&quot;</font>
<font color="green">1191.     def __init__(self, raw_query, model=None, query=None, params=None,</font>
<font color="green">1192.             translations=None, using=None, hints=None):</font>
<font color="red">1193.         self.raw_query = raw_query</font>
<font color="red">1194.         self.model = model</font>
<font color="red">1195.         self._db = using</font>
<font color="red">1196.         self._hints = hints or {}</font>
<font color="red">1197.         self.query = query or sql.RawQuery(sql=raw_query, using=self.db, params=params)</font>
<font color="red">1198.         self.params = params or ()</font>
<font color="red">1199.         self.translations = translations or {}</font>
<font color="black">1200. </font>
<font color="green">1201.     def resolve_model_init_order(self):</font>
<font color="black">1202.         &quot;&quot;&quot;</font>
<font color="black">1203.         Resolve the init field names and value positions</font>
<font color="black">1204.         &quot;&quot;&quot;</font>
<font color="red">1205.         model_init_fields = [f for f in self.model._meta.fields if f.column in self.columns]</font>
<font color="red">1206.         annotation_fields = [(column, pos) for pos, column in enumerate(self.columns)</font>
<font color="red">1207.                              if column not in self.model_fields]</font>
<font color="red">1208.         model_init_order = [self.columns.index(f.column) for f in model_init_fields]</font>
<font color="red">1209.         model_init_names = [f.attname for f in model_init_fields]</font>
<font color="red">1210.         return model_init_names, model_init_order, annotation_fields</font>
<font color="black">1211. </font>
<font color="green">1212.     def __iter__(self):</font>
<font color="black">1213.         # Cache some things for performance reasons outside the loop.</font>
<font color="red">1214.         db = self.db</font>
<font color="red">1215.         compiler = connections[db].ops.compiler('SQLCompiler')(</font>
<font color="red">1216.             self.query, connections[db], db</font>
<font color="black">1217.         )</font>
<font color="black">1218. </font>
<font color="red">1219.         query = iter(self.query)</font>
<font color="black">1220. </font>
<font color="red">1221.         try:</font>
<font color="red">1222.             model_init_names, model_init_pos, annotation_fields = self.resolve_model_init_order()</font>
<font color="black">1223. </font>
<font color="black">1224.             # Find out which model's fields are not present in the query.</font>
<font color="red">1225.             skip = set()</font>
<font color="red">1226.             for field in self.model._meta.fields:</font>
<font color="red">1227.                 if field.attname not in model_init_names:</font>
<font color="red">1228.                     skip.add(field.attname)</font>
<font color="red">1229.             if skip:</font>
<font color="red">1230.                 if self.model._meta.pk.attname in skip:</font>
<font color="red">1231.                     raise InvalidQuery('Raw query must include the primary key')</font>
<font color="red">1232.                 model_cls = deferred_class_factory(self.model, skip)</font>
<font color="black">1233.             else:</font>
<font color="red">1234.                 model_cls = self.model</font>
<font color="red">1235.             fields = [self.model_fields.get(c) for c in self.columns]</font>
<font color="red">1236.             converters = compiler.get_converters([</font>
<font color="red">1237.                 f.get_col(f.model._meta.db_table) if f else None for f in fields</font>
<font color="black">1238.             ])</font>
<font color="red">1239.             for values in query:</font>
<font color="red">1240.                 if converters:</font>
<font color="red">1241.                     values = compiler.apply_converters(values, converters)</font>
<font color="black">1242.                 # Associate fields to values</font>
<font color="red">1243.                 model_init_values = [values[pos] for pos in model_init_pos]</font>
<font color="red">1244.                 instance = model_cls.from_db(db, model_init_names, model_init_values)</font>
<font color="red">1245.                 if annotation_fields:</font>
<font color="red">1246.                     for column, pos in annotation_fields:</font>
<font color="red">1247.                         setattr(instance, column, values[pos])</font>
<font color="red">1248.                 yield instance</font>
<font color="black">1249.         finally:</font>
<font color="black">1250.             # Done iterating the Query. If it has its own cursor, close it.</font>
<font color="red">1251.             if hasattr(self.query, 'cursor') and self.query.cursor:</font>
<font color="red">1252.                 self.query.cursor.close()</font>
<font color="black">1253. </font>
<font color="green">1254.     def __repr__(self):</font>
<font color="red">1255.         return &quot;&lt;RawQuerySet: %s&gt;&quot; % self.query</font>
<font color="black">1256. </font>
<font color="green">1257.     def __getitem__(self, k):</font>
<font color="red">1258.         return list(self)[k]</font>
<font color="black">1259. </font>
<font color="green">1260.     @property</font>
<font color="black">1261.     def db(self):</font>
<font color="black">1262.         &quot;Return the database that will be used if this query is executed now&quot;</font>
<font color="red">1263.         return self._db or router.db_for_read(self.model, **self._hints)</font>
<font color="black">1264. </font>
<font color="green">1265.     def using(self, alias):</font>
<font color="black">1266.         &quot;&quot;&quot;</font>
<font color="black">1267.         Selects which database this Raw QuerySet should execute its query against.</font>
<font color="black">1268.         &quot;&quot;&quot;</font>
<font color="red">1269.         return RawQuerySet(self.raw_query, model=self.model,</font>
<font color="red">1270.                 query=self.query.clone(using=alias),</font>
<font color="red">1271.                 params=self.params, translations=self.translations,</font>
<font color="red">1272.                 using=alias)</font>
<font color="black">1273. </font>
<font color="green">1274.     @property</font>
<font color="black">1275.     def columns(self):</font>
<font color="black">1276.         &quot;&quot;&quot;</font>
<font color="black">1277.         A list of model field names in the order they'll appear in the</font>
<font color="black">1278.         query results.</font>
<font color="black">1279.         &quot;&quot;&quot;</font>
<font color="red">1280.         if not hasattr(self, '_columns'):</font>
<font color="red">1281.             self._columns = self.query.get_columns()</font>
<font color="black">1282. </font>
<font color="black">1283.             # Adjust any column names which don't match field names</font>
<font color="red">1284.             for (query_name, model_name) in self.translations.items():</font>
<font color="red">1285.                 try:</font>
<font color="red">1286.                     index = self._columns.index(query_name)</font>
<font color="red">1287.                     self._columns[index] = model_name</font>
<font color="red">1288.                 except ValueError:</font>
<font color="black">1289.                     # Ignore translations for non-existent column names</font>
<font color="red">1290.                     pass</font>
<font color="black">1291. </font>
<font color="red">1292.         return self._columns</font>
<font color="black">1293. </font>
<font color="green">1294.     @property</font>
<font color="black">1295.     def model_fields(self):</font>
<font color="black">1296.         &quot;&quot;&quot;</font>
<font color="black">1297.         A dict mapping column names to model field names.</font>
<font color="black">1298.         &quot;&quot;&quot;</font>
<font color="red">1299.         if not hasattr(self, '_model_fields'):</font>
<font color="red">1300.             converter = connections[self.db].introspection.table_name_converter</font>
<font color="red">1301.             self._model_fields = {}</font>
<font color="red">1302.             for field in self.model._meta.fields:</font>
<font color="red">1303.                 name, column = field.get_attname_column()</font>
<font color="red">1304.                 self._model_fields[converter(column)] = field</font>
<font color="red">1305.         return self._model_fields</font>
<font color="black">1306. </font>
<font color="black">1307. </font>
<font color="green">1308. class Prefetch(object):</font>
<font color="green">1309.     def __init__(self, lookup, queryset=None, to_attr=None):</font>
<font color="black">1310.         # `prefetch_through` is the path we traverse to perform the prefetch.</font>
<font color="red">1311.         self.prefetch_through = lookup</font>
<font color="black">1312.         # `prefetch_to` is the path to the attribute that stores the result.</font>
<font color="red">1313.         self.prefetch_to = lookup</font>
<font color="red">1314.         if to_attr:</font>
<font color="red">1315.             self.prefetch_to = LOOKUP_SEP.join(lookup.split(LOOKUP_SEP)[:-1] + [to_attr])</font>
<font color="black">1316. </font>
<font color="red">1317.         self.queryset = queryset</font>
<font color="red">1318.         self.to_attr = to_attr</font>
<font color="black">1319. </font>
<font color="green">1320.     def add_prefix(self, prefix):</font>
<font color="red">1321.         self.prefetch_through = LOOKUP_SEP.join([prefix, self.prefetch_through])</font>
<font color="red">1322.         self.prefetch_to = LOOKUP_SEP.join([prefix, self.prefetch_to])</font>
<font color="black">1323. </font>
<font color="green">1324.     def get_current_prefetch_through(self, level):</font>
<font color="red">1325.         return LOOKUP_SEP.join(self.prefetch_through.split(LOOKUP_SEP)[:level + 1])</font>
<font color="black">1326. </font>
<font color="green">1327.     def get_current_prefetch_to(self, level):</font>
<font color="red">1328.         return LOOKUP_SEP.join(self.prefetch_to.split(LOOKUP_SEP)[:level + 1])</font>
<font color="black">1329. </font>
<font color="green">1330.     def get_current_to_attr(self, level):</font>
<font color="red">1331.         parts = self.prefetch_to.split(LOOKUP_SEP)</font>
<font color="red">1332.         to_attr = parts[level]</font>
<font color="red">1333.         as_attr = self.to_attr and level == len(parts) - 1</font>
<font color="red">1334.         return to_attr, as_attr</font>
<font color="black">1335. </font>
<font color="green">1336.     def get_current_queryset(self, level):</font>
<font color="red">1337.         if self.get_current_prefetch_to(level) == self.prefetch_to:</font>
<font color="red">1338.             return self.queryset</font>
<font color="red">1339.         return None</font>
<font color="black">1340. </font>
<font color="green">1341.     def __eq__(self, other):</font>
<font color="red">1342.         if isinstance(other, Prefetch):</font>
<font color="red">1343.             return self.prefetch_to == other.prefetch_to</font>
<font color="red">1344.         return False</font>
<font color="black">1345. </font>
<font color="green">1346.     def __hash__(self):</font>
<font color="red">1347.         return hash(self.__class__) ^ hash(self.prefetch_to)</font>
<font color="black">1348. </font>
<font color="black">1349. </font>
<font color="green">1350. def normalize_prefetch_lookups(lookups, prefix=None):</font>
<font color="black">1351.     &quot;&quot;&quot;</font>
<font color="black">1352.     Helper function that normalize lookups into Prefetch objects.</font>
<font color="black">1353.     &quot;&quot;&quot;</font>
<font color="red">1354.     ret = []</font>
<font color="red">1355.     for lookup in lookups:</font>
<font color="red">1356.         if not isinstance(lookup, Prefetch):</font>
<font color="red">1357.             lookup = Prefetch(lookup)</font>
<font color="red">1358.         if prefix:</font>
<font color="red">1359.             lookup.add_prefix(prefix)</font>
<font color="red">1360.         ret.append(lookup)</font>
<font color="red">1361.     return ret</font>
<font color="black">1362. </font>
<font color="black">1363. </font>
<font color="green">1364. def prefetch_related_objects(result_cache, related_lookups):</font>
<font color="black">1365.     &quot;&quot;&quot;</font>
<font color="black">1366.     Helper function for prefetch_related functionality</font>
<font color="black">1367. </font>
<font color="black">1368.     Populates prefetched objects caches for a list of results</font>
<font color="black">1369.     from a QuerySet</font>
<font color="black">1370.     &quot;&quot;&quot;</font>
<font color="black">1371. </font>
<font color="red">1372.     if len(result_cache) == 0:</font>
<font color="red">1373.         return  # nothing to do</font>
<font color="black">1374. </font>
<font color="red">1375.     related_lookups = normalize_prefetch_lookups(related_lookups)</font>
<font color="black">1376. </font>
<font color="black">1377.     # We need to be able to dynamically add to the list of prefetch_related</font>
<font color="black">1378.     # lookups that we look up (see below).  So we need some book keeping to</font>
<font color="black">1379.     # ensure we don't do duplicate work.</font>
<font color="red">1380.     done_queries = {}    # dictionary of things like 'foo__bar': [results]</font>
<font color="black">1381. </font>
<font color="red">1382.     auto_lookups = set()  # we add to this as we go through.</font>
<font color="red">1383.     followed_descriptors = set()  # recursion protection</font>
<font color="black">1384. </font>
<font color="red">1385.     all_lookups = deque(related_lookups)</font>
<font color="red">1386.     while all_lookups:</font>
<font color="red">1387.         lookup = all_lookups.popleft()</font>
<font color="red">1388.         if lookup.prefetch_to in done_queries:</font>
<font color="red">1389.             if lookup.queryset:</font>
<font color="red">1390.                 raise ValueError(&quot;'%s' lookup was already seen with a different queryset. &quot;</font>
<font color="red">1391.                                  &quot;You may need to adjust the ordering of your lookups.&quot; % lookup.prefetch_to)</font>
<font color="black">1392. </font>
<font color="red">1393.             continue</font>
<font color="black">1394. </font>
<font color="black">1395.         # Top level, the list of objects to decorate is the result cache</font>
<font color="black">1396.         # from the primary QuerySet. It won't be for deeper levels.</font>
<font color="red">1397.         obj_list = result_cache</font>
<font color="black">1398. </font>
<font color="red">1399.         through_attrs = lookup.prefetch_through.split(LOOKUP_SEP)</font>
<font color="red">1400.         for level, through_attr in enumerate(through_attrs):</font>
<font color="black">1401.             # Prepare main instances</font>
<font color="red">1402.             if len(obj_list) == 0:</font>
<font color="red">1403.                 break</font>
<font color="black">1404. </font>
<font color="red">1405.             prefetch_to = lookup.get_current_prefetch_to(level)</font>
<font color="red">1406.             if prefetch_to in done_queries:</font>
<font color="black">1407.                 # Skip any prefetching, and any object preparation</font>
<font color="red">1408.                 obj_list = done_queries[prefetch_to]</font>
<font color="red">1409.                 continue</font>
<font color="black">1410. </font>
<font color="black">1411.             # Prepare objects:</font>
<font color="red">1412.             good_objects = True</font>
<font color="red">1413.             for obj in obj_list:</font>
<font color="black">1414.                 # Since prefetching can re-use instances, it is possible to have</font>
<font color="black">1415.                 # the same instance multiple times in obj_list, so obj might</font>
<font color="black">1416.                 # already be prepared.</font>
<font color="red">1417.                 if not hasattr(obj, '_prefetched_objects_cache'):</font>
<font color="red">1418.                     try:</font>
<font color="red">1419.                         obj._prefetched_objects_cache = {}</font>
<font color="red">1420.                     except AttributeError:</font>
<font color="black">1421.                         # Must be in a QuerySet subclass that is not returning</font>
<font color="black">1422.                         # Model instances, either in Django or 3rd</font>
<font color="black">1423.                         # party. prefetch_related() doesn't make sense, so quit</font>
<font color="black">1424.                         # now.</font>
<font color="red">1425.                         good_objects = False</font>
<font color="red">1426.                         break</font>
<font color="red">1427.             if not good_objects:</font>
<font color="red">1428.                 break</font>
<font color="black">1429. </font>
<font color="black">1430.             # Descend down tree</font>
<font color="black">1431. </font>
<font color="black">1432.             # We assume that objects retrieved are homogeneous (which is the premise</font>
<font color="black">1433.             # of prefetch_related), so what applies to first object applies to all.</font>
<font color="red">1434.             first_obj = obj_list[0]</font>
<font color="red">1435.             prefetcher, descriptor, attr_found, is_fetched = get_prefetcher(first_obj, through_attr)</font>
<font color="black">1436. </font>
<font color="red">1437.             if not attr_found:</font>
<font color="red">1438.                 raise AttributeError(&quot;Cannot find '%s' on %s object, '%s' is an invalid &quot;</font>
<font color="black">1439.                                      &quot;parameter to prefetch_related()&quot; %</font>
<font color="red">1440.                                      (through_attr, first_obj.__class__.__name__, lookup.prefetch_through))</font>
<font color="black">1441. </font>
<font color="red">1442.             if level == len(through_attrs) - 1 and prefetcher is None:</font>
<font color="black">1443.                 # Last one, this *must* resolve to something that supports</font>
<font color="black">1444.                 # prefetching, otherwise there is no point adding it and the</font>
<font color="black">1445.                 # developer asking for it has made a mistake.</font>
<font color="red">1446.                 raise ValueError(&quot;'%s' does not resolve to an item that supports &quot;</font>
<font color="black">1447.                                  &quot;prefetching - this is an invalid parameter to &quot;</font>
<font color="red">1448.                                  &quot;prefetch_related().&quot; % lookup.prefetch_through)</font>
<font color="black">1449. </font>
<font color="red">1450.             if prefetcher is not None and not is_fetched:</font>
<font color="red">1451.                 obj_list, additional_lookups = prefetch_one_level(obj_list, prefetcher, lookup, level)</font>
<font color="black">1452.                 # We need to ensure we don't keep adding lookups from the</font>
<font color="black">1453.                 # same relationships to stop infinite recursion. So, if we</font>
<font color="black">1454.                 # are already on an automatically added lookup, don't add</font>
<font color="black">1455.                 # the new lookups from relationships we've seen already.</font>
<font color="red">1456.                 if not (lookup in auto_lookups and descriptor in followed_descriptors):</font>
<font color="red">1457.                     done_queries[prefetch_to] = obj_list</font>
<font color="red">1458.                     new_lookups = normalize_prefetch_lookups(additional_lookups, prefetch_to)</font>
<font color="red">1459.                     auto_lookups.update(new_lookups)</font>
<font color="red">1460.                     all_lookups.extendleft(new_lookups)</font>
<font color="red">1461.                 followed_descriptors.add(descriptor)</font>
<font color="black">1462.             else:</font>
<font color="black">1463.                 # Either a singly related object that has already been fetched</font>
<font color="black">1464.                 # (e.g. via select_related), or hopefully some other property</font>
<font color="black">1465.                 # that doesn't support prefetching but needs to be traversed.</font>
<font color="black">1466. </font>
<font color="black">1467.                 # We replace the current list of parent objects with the list</font>
<font color="black">1468.                 # of related objects, filtering out empty or missing values so</font>
<font color="black">1469.                 # that we can continue with nullable or reverse relations.</font>
<font color="red">1470.                 new_obj_list = []</font>
<font color="red">1471.                 for obj in obj_list:</font>
<font color="red">1472.                     try:</font>
<font color="red">1473.                         new_obj = getattr(obj, through_attr)</font>
<font color="red">1474.                     except exceptions.ObjectDoesNotExist:</font>
<font color="red">1475.                         continue</font>
<font color="red">1476.                     if new_obj is None:</font>
<font color="red">1477.                         continue</font>
<font color="black">1478.                     # We special-case `list` rather than something more generic</font>
<font color="black">1479.                     # like `Iterable` because we don't want to accidentally match</font>
<font color="black">1480.                     # user models that define __iter__.</font>
<font color="red">1481.                     if isinstance(new_obj, list):</font>
<font color="red">1482.                         new_obj_list.extend(new_obj)</font>
<font color="black">1483.                     else:</font>
<font color="red">1484.                         new_obj_list.append(new_obj)</font>
<font color="red">1485.                 obj_list = new_obj_list</font>
<font color="black">1486. </font>
<font color="black">1487. </font>
<font color="green">1488. def get_prefetcher(instance, attr):</font>
<font color="black">1489.     &quot;&quot;&quot;</font>
<font color="black">1490.     For the attribute 'attr' on the given instance, finds</font>
<font color="black">1491.     an object that has a get_prefetch_queryset().</font>
<font color="black">1492.     Returns a 4 tuple containing:</font>
<font color="black">1493.     (the object with get_prefetch_queryset (or None),</font>
<font color="black">1494.      the descriptor object representing this relationship (or None),</font>
<font color="black">1495.      a boolean that is False if the attribute was not found at all,</font>
<font color="black">1496.      a boolean that is True if the attribute has already been fetched)</font>
<font color="black">1497.     &quot;&quot;&quot;</font>
<font color="red">1498.     prefetcher = None</font>
<font color="red">1499.     is_fetched = False</font>
<font color="black">1500. </font>
<font color="black">1501.     # For singly related objects, we have to avoid getting the attribute</font>
<font color="black">1502.     # from the object, as this will trigger the query. So we first try</font>
<font color="black">1503.     # on the class, in order to get the descriptor object.</font>
<font color="red">1504.     rel_obj_descriptor = getattr(instance.__class__, attr, None)</font>
<font color="red">1505.     if rel_obj_descriptor is None:</font>
<font color="red">1506.         attr_found = hasattr(instance, attr)</font>
<font color="black">1507.     else:</font>
<font color="red">1508.         attr_found = True</font>
<font color="red">1509.         if rel_obj_descriptor:</font>
<font color="black">1510.             # singly related object, descriptor object has the</font>
<font color="black">1511.             # get_prefetch_queryset() method.</font>
<font color="red">1512.             if hasattr(rel_obj_descriptor, 'get_prefetch_queryset'):</font>
<font color="red">1513.                 prefetcher = rel_obj_descriptor</font>
<font color="red">1514.                 if rel_obj_descriptor.is_cached(instance):</font>
<font color="red">1515.                     is_fetched = True</font>
<font color="black">1516.             else:</font>
<font color="black">1517.                 # descriptor doesn't support prefetching, so we go ahead and get</font>
<font color="black">1518.                 # the attribute on the instance rather than the class to</font>
<font color="black">1519.                 # support many related managers</font>
<font color="red">1520.                 rel_obj = getattr(instance, attr)</font>
<font color="red">1521.                 if hasattr(rel_obj, 'get_prefetch_queryset'):</font>
<font color="red">1522.                     prefetcher = rel_obj</font>
<font color="red">1523.     return prefetcher, rel_obj_descriptor, attr_found, is_fetched</font>
<font color="black">1524. </font>
<font color="black">1525. </font>
<font color="green">1526. def prefetch_one_level(instances, prefetcher, lookup, level):</font>
<font color="black">1527.     &quot;&quot;&quot;</font>
<font color="black">1528.     Helper function for prefetch_related_objects</font>
<font color="black">1529. </font>
<font color="black">1530.     Runs prefetches on all instances using the prefetcher object,</font>
<font color="black">1531.     assigning results to relevant caches in instance.</font>
<font color="black">1532. </font>
<font color="black">1533.     The prefetched objects are returned, along with any additional</font>
<font color="black">1534.     prefetches that must be done due to prefetch_related lookups</font>
<font color="black">1535.     found from default managers.</font>
<font color="black">1536.     &quot;&quot;&quot;</font>
<font color="black">1537.     # prefetcher must have a method get_prefetch_queryset() which takes a list</font>
<font color="black">1538.     # of instances, and returns a tuple:</font>
<font color="black">1539. </font>
<font color="black">1540.     # (queryset of instances of self.model that are related to passed in instances,</font>
<font color="black">1541.     #  callable that gets value to be matched for returned instances,</font>
<font color="black">1542.     #  callable that gets value to be matched for passed in instances,</font>
<font color="black">1543.     #  boolean that is True for singly related objects,</font>
<font color="black">1544.     #  cache name to assign to).</font>
<font color="black">1545. </font>
<font color="black">1546.     # The 'values to be matched' must be hashable as they will be used</font>
<font color="black">1547.     # in a dictionary.</font>
<font color="black">1548. </font>
<font color="black">1549.     rel_qs, rel_obj_attr, instance_attr, single, cache_name = (</font>
<font color="red">1550.         prefetcher.get_prefetch_queryset(instances, lookup.get_current_queryset(level)))</font>
<font color="black">1551.     # We have to handle the possibility that the QuerySet we just got back</font>
<font color="black">1552.     # contains some prefetch_related lookups. We don't want to trigger the</font>
<font color="black">1553.     # prefetch_related functionality by evaluating the query. Rather, we need</font>
<font color="black">1554.     # to merge in the prefetch_related lookups.</font>
<font color="black">1555.     # Copy the lookups in case it is a Prefetch object which could be reused</font>
<font color="black">1556.     # later (happens in nested prefetch_related).</font>
<font color="black">1557.     additional_lookups = [</font>
<font color="red">1558.         copy.copy(additional_lookup) for additional_lookup</font>
<font color="red">1559.         in getattr(rel_qs, '_prefetch_related_lookups', [])</font>
<font color="black">1560.     ]</font>
<font color="red">1561.     if additional_lookups:</font>
<font color="black">1562.         # Don't need to clone because the manager should have given us a fresh</font>
<font color="black">1563.         # instance, so we access an internal instead of using public interface</font>
<font color="black">1564.         # for performance reasons.</font>
<font color="red">1565.         rel_qs._prefetch_related_lookups = []</font>
<font color="black">1566. </font>
<font color="red">1567.     all_related_objects = list(rel_qs)</font>
<font color="black">1568. </font>
<font color="red">1569.     rel_obj_cache = {}</font>
<font color="red">1570.     for rel_obj in all_related_objects:</font>
<font color="red">1571.         rel_attr_val = rel_obj_attr(rel_obj)</font>
<font color="red">1572.         rel_obj_cache.setdefault(rel_attr_val, []).append(rel_obj)</font>
<font color="black">1573. </font>
<font color="red">1574.     to_attr, as_attr = lookup.get_current_to_attr(level)</font>
<font color="black">1575.     # Make sure `to_attr` does not conflict with a field.</font>
<font color="red">1576.     if as_attr and instances:</font>
<font color="black">1577.         # We assume that objects retrieved are homogeneous (which is the premise</font>
<font color="black">1578.         # of prefetch_related), so what applies to first object applies to all.</font>
<font color="red">1579.         model = instances[0].__class__</font>
<font color="red">1580.         try:</font>
<font color="red">1581.             model._meta.get_field(to_attr)</font>
<font color="red">1582.         except exceptions.FieldDoesNotExist:</font>
<font color="red">1583.             pass</font>
<font color="black">1584.         else:</font>
<font color="red">1585.             msg = 'to_attr={} conflicts with a field on the {} model.'</font>
<font color="red">1586.             raise ValueError(msg.format(to_attr, model.__name__))</font>
<font color="black">1587. </font>
<font color="red">1588.     for obj in instances:</font>
<font color="red">1589.         instance_attr_val = instance_attr(obj)</font>
<font color="red">1590.         vals = rel_obj_cache.get(instance_attr_val, [])</font>
<font color="black">1591. </font>
<font color="red">1592.         if single:</font>
<font color="red">1593.             val = vals[0] if vals else None</font>
<font color="red">1594.             to_attr = to_attr if as_attr else cache_name</font>
<font color="red">1595.             setattr(obj, to_attr, val)</font>
<font color="black">1596.         else:</font>
<font color="red">1597.             if as_attr:</font>
<font color="red">1598.                 setattr(obj, to_attr, vals)</font>
<font color="black">1599.             else:</font>
<font color="black">1600.                 # Cache in the QuerySet.all().</font>
<font color="red">1601.                 qs = getattr(obj, to_attr).all()</font>
<font color="red">1602.                 qs._result_cache = vals</font>
<font color="black">1603.                 # We don't want the individual qs doing prefetch_related now,</font>
<font color="black">1604.                 # since we have merged this into the current work.</font>
<font color="red">1605.                 qs._prefetch_done = True</font>
<font color="red">1606.                 obj._prefetched_objects_cache[cache_name] = qs</font>
<font color="red">1607.     return all_related_objects, additional_lookups</font>
<font color="black">1608. </font>
<font color="black">1609. </font>
<font color="green">1610. class RelatedPopulator(object):</font>
<font color="black">1611.     &quot;&quot;&quot;</font>
<font color="black">1612.     RelatedPopulator is used for select_related() object instantiation.</font>
<font color="black">1613. </font>
<font color="black">1614.     The idea is that each select_related() model will be populated by a</font>
<font color="black">1615.     different RelatedPopulator instance. The RelatedPopulator instances get</font>
<font color="black">1616.     klass_info and select (computed in SQLCompiler) plus the used db as</font>
<font color="black">1617.     input for initialization. That data is used to compute which columns</font>
<font color="black">1618.     to use, how to instantiate the model, and how to populate the links</font>
<font color="black">1619.     between the objects.</font>
<font color="black">1620. </font>
<font color="black">1621.     The actual creation of the objects is done in populate() method. This</font>
<font color="black">1622.     method gets row and from_obj as input and populates the select_related()</font>
<font color="black">1623.     model instance.</font>
<font color="green">1624.     &quot;&quot;&quot;</font>
<font color="green">1625.     def __init__(self, klass_info, select, db):</font>
<font color="red">1626.         self.db = db</font>
<font color="black">1627.         # Pre-compute needed attributes. The attributes are:</font>
<font color="black">1628.         #  - model_cls: the possibly deferred model class to instantiate</font>
<font color="black">1629.         #  - either:</font>
<font color="black">1630.         #    - cols_start, cols_end: usually the columns in the row are</font>
<font color="black">1631.         #      in the same order model_cls.__init__ expects them, so we</font>
<font color="black">1632.         #      can instantiate by model_cls(*row[cols_start:cols_end])</font>
<font color="black">1633.         #    - reorder_for_init: When select_related descends to a child</font>
<font color="black">1634.         #      class, then we want to reuse the already selected parent</font>
<font color="black">1635.         #      data. However, in this case the parent data isn't necessarily</font>
<font color="black">1636.         #      in the same order that Model.__init__ expects it to be, so</font>
<font color="black">1637.         #      we have to reorder the parent data. The reorder_for_init</font>
<font color="black">1638.         #      attribute contains a function used to reorder the field data</font>
<font color="black">1639.         #      in the order __init__ expects it.</font>
<font color="black">1640.         #  - pk_idx: the index of the primary key field in the reordered</font>
<font color="black">1641.         #    model data. Used to check if a related object exists at all.</font>
<font color="black">1642.         #  - init_list: the field attnames fetched from the database. For</font>
<font color="black">1643.         #    deferred models this isn't the same as all attnames of the</font>
<font color="black">1644.         #    model's fields.</font>
<font color="black">1645.         #  - related_populators: a list of RelatedPopulator instances if</font>
<font color="black">1646.         #    select_related() descends to related models from this model.</font>
<font color="black">1647.         #  - cache_name, reverse_cache_name: the names to use for setattr</font>
<font color="black">1648.         #    when assigning the fetched object to the from_obj. If the</font>
<font color="black">1649.         #    reverse_cache_name is set, then we also set the reverse link.</font>
<font color="red">1650.         select_fields = klass_info['select_fields']</font>
<font color="red">1651.         from_parent = klass_info['from_parent']</font>
<font color="red">1652.         if not from_parent:</font>
<font color="red">1653.             self.cols_start = select_fields[0]</font>
<font color="red">1654.             self.cols_end = select_fields[-1] + 1</font>
<font color="black">1655.             self.init_list = [</font>
<font color="red">1656.                 f[0].target.attname for f in select[self.cols_start:self.cols_end]</font>
<font color="black">1657.             ]</font>
<font color="red">1658.             self.reorder_for_init = None</font>
<font color="black">1659.         else:</font>
<font color="black">1660.             model_init_attnames = [</font>
<font color="red">1661.                 f.attname for f in klass_info['model']._meta.concrete_fields</font>
<font color="black">1662.             ]</font>
<font color="red">1663.             reorder_map = []</font>
<font color="red">1664.             for idx in select_fields:</font>
<font color="red">1665.                 field = select[idx][0].target</font>
<font color="red">1666.                 init_pos = model_init_attnames.index(field.attname)</font>
<font color="red">1667.                 reorder_map.append((init_pos, field.attname, idx))</font>
<font color="red">1668.             reorder_map.sort()</font>
<font color="red">1669.             self.init_list = [v[1] for v in reorder_map]</font>
<font color="red">1670.             pos_list = [row_pos for _, _, row_pos in reorder_map]</font>
<font color="black">1671. </font>
<font color="red">1672.             def reorder_for_init(row):</font>
<font color="red">1673.                 return [row[row_pos] for row_pos in pos_list]</font>
<font color="red">1674.             self.reorder_for_init = reorder_for_init</font>
<font color="black">1675. </font>
<font color="red">1676.         self.model_cls = self.get_deferred_cls(klass_info, self.init_list)</font>
<font color="red">1677.         self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)</font>
<font color="red">1678.         self.related_populators = get_related_populators(klass_info, select, self.db)</font>
<font color="red">1679.         field = klass_info['field']</font>
<font color="red">1680.         reverse = klass_info['reverse']</font>
<font color="red">1681.         self.reverse_cache_name = None</font>
<font color="red">1682.         if reverse:</font>
<font color="red">1683.             self.cache_name = field.remote_field.get_cache_name()</font>
<font color="red">1684.             self.reverse_cache_name = field.get_cache_name()</font>
<font color="black">1685.         else:</font>
<font color="red">1686.             self.cache_name = field.get_cache_name()</font>
<font color="red">1687.             if field.unique:</font>
<font color="red">1688.                 self.reverse_cache_name = field.remote_field.get_cache_name()</font>
<font color="black">1689. </font>
<font color="green">1690.     def get_deferred_cls(self, klass_info, init_list):</font>
<font color="red">1691.         model_cls = klass_info['model']</font>
<font color="red">1692.         if len(init_list) != len(model_cls._meta.concrete_fields):</font>
<font color="red">1693.             init_set = set(init_list)</font>
<font color="black">1694.             skip = [</font>
<font color="red">1695.                 f.attname for f in model_cls._meta.concrete_fields</font>
<font color="red">1696.                 if f.attname not in init_set</font>
<font color="black">1697.             ]</font>
<font color="red">1698.             model_cls = deferred_class_factory(model_cls, skip)</font>
<font color="red">1699.         return model_cls</font>
<font color="black">1700. </font>
<font color="green">1701.     def populate(self, row, from_obj):</font>
<font color="red">1702.         if self.reorder_for_init:</font>
<font color="red">1703.             obj_data = self.reorder_for_init(row)</font>
<font color="black">1704.         else:</font>
<font color="red">1705.             obj_data = row[self.cols_start:self.cols_end]</font>
<font color="red">1706.         if obj_data[self.pk_idx] is None:</font>
<font color="red">1707.             obj = None</font>
<font color="black">1708.         else:</font>
<font color="red">1709.             obj = self.model_cls.from_db(self.db, self.init_list, obj_data)</font>
<font color="red">1710.         if obj and self.related_populators:</font>
<font color="red">1711.             for rel_iter in self.related_populators:</font>
<font color="red">1712.                 rel_iter.populate(row, obj)</font>
<font color="red">1713.         setattr(from_obj, self.cache_name, obj)</font>
<font color="red">1714.         if obj and self.reverse_cache_name:</font>
<font color="red">1715.             setattr(obj, self.reverse_cache_name, from_obj)</font>
<font color="black">1716. </font>
<font color="black">1717. </font>
<font color="green">1718. def get_related_populators(klass_info, select, db):</font>
<font color="green">1719.     iterators = []</font>
<font color="green">1720.     related_klass_infos = klass_info.get('related_klass_infos', [])</font>
<font color="green">1721.     for rel_klass_info in related_klass_infos:</font>
<font color="red">1722.         rel_cls = RelatedPopulator(rel_klass_info, select, db)</font>
<font color="red">1723.         iterators.append(rel_cls)</font>
<font color="green">1724.     return iterators</font>
</pre>

