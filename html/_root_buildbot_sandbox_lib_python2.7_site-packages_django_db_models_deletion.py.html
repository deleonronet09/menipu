source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/db/models/deletion.py</b><br>


file stats: <b>194 lines, 27 executed: 13.9% covered</b>
<pre>
<font color="green">   1. from collections import Counter, OrderedDict</font>
<font color="green">   2. from itertools import chain</font>
<font color="green">   3. from operator import attrgetter</font>
<font color="black">   4. </font>
<font color="green">   5. from django.db import IntegrityError, connections, transaction</font>
<font color="green">   6. from django.db.models import signals, sql</font>
<font color="green">   7. from django.utils import six</font>
<font color="black">   8. </font>
<font color="black">   9. </font>
<font color="green">  10. class ProtectedError(IntegrityError):</font>
<font color="green">  11.     def __init__(self, msg, protected_objects):</font>
<font color="red">  12.         self.protected_objects = protected_objects</font>
<font color="red">  13.         super(ProtectedError, self).__init__(msg, protected_objects)</font>
<font color="black">  14. </font>
<font color="black">  15. </font>
<font color="green">  16. def CASCADE(collector, field, sub_objs, using):</font>
<font color="red">  17.     collector.collect(sub_objs, source=field.remote_field.model,</font>
<font color="red">  18.                       source_attr=field.name, nullable=field.null)</font>
<font color="red">  19.     if field.null and not connections[using].features.can_defer_constraint_checks:</font>
<font color="red">  20.         collector.add_field_update(field, None, sub_objs)</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="green">  23. def PROTECT(collector, field, sub_objs, using):</font>
<font color="red">  24.     raise ProtectedError(&quot;Cannot delete some instances of model '%s' because &quot;</font>
<font color="black">  25.         &quot;they are referenced through a protected foreign key: '%s.%s'&quot; % (</font>
<font color="red">  26.             field.remote_field.model.__name__, sub_objs[0].__class__.__name__, field.name</font>
<font color="black">  27.         ),</font>
<font color="red">  28.         sub_objs</font>
<font color="black">  29.     )</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. def SET(value):</font>
<font color="red">  33.     if callable(value):</font>
<font color="red">  34.         def set_on_delete(collector, field, sub_objs, using):</font>
<font color="red">  35.             collector.add_field_update(field, value(), sub_objs)</font>
<font color="black">  36.     else:</font>
<font color="red">  37.         def set_on_delete(collector, field, sub_objs, using):</font>
<font color="red">  38.             collector.add_field_update(field, value, sub_objs)</font>
<font color="red">  39.     set_on_delete.deconstruct = lambda: ('django.db.models.SET', (value,), {})</font>
<font color="red">  40.     return set_on_delete</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. def SET_NULL(collector, field, sub_objs, using):</font>
<font color="red">  44.     collector.add_field_update(field, None, sub_objs)</font>
<font color="black">  45. </font>
<font color="black">  46. </font>
<font color="green">  47. def SET_DEFAULT(collector, field, sub_objs, using):</font>
<font color="red">  48.     collector.add_field_update(field, field.get_default(), sub_objs)</font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="green">  51. def DO_NOTHING(collector, field, sub_objs, using):</font>
<font color="red">  52.     pass</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. def get_candidate_relations_to_delete(opts):</font>
<font color="black">  56.     # Collect models that contain candidate relations to delete. This may include</font>
<font color="black">  57.     # relations coming from proxy models.</font>
<font color="red">  58.     candidate_models = {opts}</font>
<font color="red">  59.     candidate_models = candidate_models.union(opts.concrete_model._meta.proxied_children)</font>
<font color="black">  60.     # For each model, get all candidate fields.</font>
<font color="red">  61.     candidate_model_fields = set(chain.from_iterable(</font>
<font color="red">  62.         opts.get_fields(include_hidden=True) for opts in candidate_models</font>
<font color="black">  63.     ))</font>
<font color="black">  64.     # The candidate relations are the ones that come from N-1 and 1-1 relations.</font>
<font color="black">  65.     # N-N  (i.e., many-to-many) relations aren't candidates for deletion.</font>
<font color="black">  66.     return (</font>
<font color="red">  67.         f for f in candidate_model_fields</font>
<font color="red">  68.         if f.auto_created and not f.concrete and (f.one_to_one or f.one_to_many)</font>
<font color="black">  69.     )</font>
<font color="black">  70. </font>
<font color="black">  71. </font>
<font color="green">  72. class Collector(object):</font>
<font color="green">  73.     def __init__(self, using):</font>
<font color="red">  74.         self.using = using</font>
<font color="black">  75.         # Initially, {model: {instances}}, later values become lists.</font>
<font color="red">  76.         self.data = {}</font>
<font color="red">  77.         self.field_updates = {}  # {model: {(field, value): {instances}}}</font>
<font color="black">  78.         # fast_deletes is a list of queryset-likes that can be deleted without</font>
<font color="black">  79.         # fetching the objects into memory.</font>
<font color="red">  80.         self.fast_deletes = []</font>
<font color="black">  81. </font>
<font color="black">  82.         # Tracks deletion-order dependency for databases without transactions</font>
<font color="black">  83.         # or ability to defer constraint checks. Only concrete model classes</font>
<font color="black">  84.         # should be included, as the dependencies exist only between actual</font>
<font color="black">  85.         # database tables; proxy models are represented here by their concrete</font>
<font color="black">  86.         # parent.</font>
<font color="red">  87.         self.dependencies = {}  # {model: {models}}</font>
<font color="black">  88. </font>
<font color="green">  89.     def add(self, objs, source=None, nullable=False, reverse_dependency=False):</font>
<font color="black">  90.         &quot;&quot;&quot;</font>
<font color="black">  91.         Adds 'objs' to the collection of objects to be deleted.  If the call is</font>
<font color="black">  92.         the result of a cascade, 'source' should be the model that caused it,</font>
<font color="black">  93.         and 'nullable' should be set to True if the relation can be null.</font>
<font color="black">  94. </font>
<font color="black">  95.         Returns a list of all objects that were not already collected.</font>
<font color="black">  96.         &quot;&quot;&quot;</font>
<font color="red">  97.         if not objs:</font>
<font color="red">  98.             return []</font>
<font color="red">  99.         new_objs = []</font>
<font color="red"> 100.         model = objs[0].__class__</font>
<font color="red"> 101.         instances = self.data.setdefault(model, set())</font>
<font color="red"> 102.         for obj in objs:</font>
<font color="red"> 103.             if obj not in instances:</font>
<font color="red"> 104.                 new_objs.append(obj)</font>
<font color="red"> 105.         instances.update(new_objs)</font>
<font color="black"> 106.         # Nullable relationships can be ignored -- they are nulled out before</font>
<font color="black"> 107.         # deleting, and therefore do not affect the order in which objects have</font>
<font color="black"> 108.         # to be deleted.</font>
<font color="red"> 109.         if source is not None and not nullable:</font>
<font color="red"> 110.             if reverse_dependency:</font>
<font color="red"> 111.                 source, model = model, source</font>
<font color="red"> 112.             self.dependencies.setdefault(</font>
<font color="red"> 113.                 source._meta.concrete_model, set()).add(model._meta.concrete_model)</font>
<font color="red"> 114.         return new_objs</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def add_field_update(self, field, value, objs):</font>
<font color="black"> 117.         &quot;&quot;&quot;</font>
<font color="black"> 118.         Schedules a field update. 'objs' must be a homogeneous iterable</font>
<font color="black"> 119.         collection of model instances (e.g. a QuerySet).</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="red"> 121.         if not objs:</font>
<font color="red"> 122.             return</font>
<font color="red"> 123.         model = objs[0].__class__</font>
<font color="red"> 124.         self.field_updates.setdefault(</font>
<font color="red"> 125.             model, {}).setdefault(</font>
<font color="red"> 126.             (field, value), set()).update(objs)</font>
<font color="black"> 127. </font>
<font color="green"> 128.     def can_fast_delete(self, objs, from_field=None):</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="black"> 130.         Determines if the objects in the given queryset-like can be</font>
<font color="black"> 131.         fast-deleted. This can be done if there are no cascades, no</font>
<font color="black"> 132.         parents and no signal listeners for the object class.</font>
<font color="black"> 133. </font>
<font color="black"> 134.         The 'from_field' tells where we are coming from - we need this to</font>
<font color="black"> 135.         determine if the objects are in fact to be deleted. Allows also</font>
<font color="black"> 136.         skipping parent -&gt; child -&gt; parent chain preventing fast delete of</font>
<font color="black"> 137.         the child.</font>
<font color="black"> 138.         &quot;&quot;&quot;</font>
<font color="red"> 139.         if from_field and from_field.remote_field.on_delete is not CASCADE:</font>
<font color="red"> 140.             return False</font>
<font color="red"> 141.         if not (hasattr(objs, 'model') and hasattr(objs, '_raw_delete')):</font>
<font color="red"> 142.             return False</font>
<font color="red"> 143.         model = objs.model</font>
<font color="red"> 144.         if (signals.pre_delete.has_listeners(model)</font>
<font color="red"> 145.                 or signals.post_delete.has_listeners(model)</font>
<font color="red"> 146.                 or signals.m2m_changed.has_listeners(model)):</font>
<font color="red"> 147.             return False</font>
<font color="black"> 148.         # The use of from_field comes from the need to avoid cascade back to</font>
<font color="black"> 149.         # parent when parent delete is cascading to child.</font>
<font color="red"> 150.         opts = model._meta</font>
<font color="red"> 151.         if any(link != from_field for link in opts.concrete_model._meta.parents.values()):</font>
<font color="red"> 152.             return False</font>
<font color="black"> 153.         # Foreign keys pointing to this model, both from m2m and other</font>
<font color="black"> 154.         # models.</font>
<font color="red"> 155.         for related in get_candidate_relations_to_delete(opts):</font>
<font color="red"> 156.             if related.field.remote_field.on_delete is not DO_NOTHING:</font>
<font color="red"> 157.                 return False</font>
<font color="red"> 158.         for field in model._meta.virtual_fields:</font>
<font color="red"> 159.             if hasattr(field, 'bulk_related_objects'):</font>
<font color="black"> 160.                 # It's something like generic foreign key.</font>
<font color="red"> 161.                 return False</font>
<font color="red"> 162.         return True</font>
<font color="black"> 163. </font>
<font color="green"> 164.     def get_del_batches(self, objs, field):</font>
<font color="black"> 165.         &quot;&quot;&quot;</font>
<font color="black"> 166.         Returns the objs in suitably sized batches for the used connection.</font>
<font color="black"> 167.         &quot;&quot;&quot;</font>
<font color="red"> 168.         conn_batch_size = max(</font>
<font color="red"> 169.             connections[self.using].ops.bulk_batch_size([field.name], objs), 1)</font>
<font color="red"> 170.         if len(objs) &gt; conn_batch_size:</font>
<font color="red"> 171.             return [objs[i:i + conn_batch_size]</font>
<font color="red"> 172.                     for i in range(0, len(objs), conn_batch_size)]</font>
<font color="black"> 173.         else:</font>
<font color="red"> 174.             return [objs]</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def collect(self, objs, source=None, nullable=False, collect_related=True,</font>
<font color="green"> 177.             source_attr=None, reverse_dependency=False, keep_parents=False):</font>
<font color="black"> 178.         &quot;&quot;&quot;</font>
<font color="black"> 179.         Adds 'objs' to the collection of objects to be deleted as well as all</font>
<font color="black"> 180.         parent instances.  'objs' must be a homogeneous iterable collection of</font>
<font color="black"> 181.         model instances (e.g. a QuerySet).  If 'collect_related' is True,</font>
<font color="black"> 182.         related objects will be handled by their respective on_delete handler.</font>
<font color="black"> 183. </font>
<font color="black"> 184.         If the call is the result of a cascade, 'source' should be the model</font>
<font color="black"> 185.         that caused it and 'nullable' should be set to True, if the relation</font>
<font color="black"> 186.         can be null.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         If 'reverse_dependency' is True, 'source' will be deleted before the</font>
<font color="black"> 189.         current model, rather than after. (Needed for cascading to parent</font>
<font color="black"> 190.         models, the one case in which the cascade follows the forwards</font>
<font color="black"> 191.         direction of an FK rather than the reverse direction.)</font>
<font color="black"> 192. </font>
<font color="black"> 193.         If 'keep_parents' is True, data of parent model's will be not deleted.</font>
<font color="black"> 194.         &quot;&quot;&quot;</font>
<font color="red"> 195.         if self.can_fast_delete(objs):</font>
<font color="red"> 196.             self.fast_deletes.append(objs)</font>
<font color="red"> 197.             return</font>
<font color="red"> 198.         new_objs = self.add(objs, source, nullable,</font>
<font color="red"> 199.                             reverse_dependency=reverse_dependency)</font>
<font color="red"> 200.         if not new_objs:</font>
<font color="red"> 201.             return</font>
<font color="black"> 202. </font>
<font color="red"> 203.         model = new_objs[0].__class__</font>
<font color="black"> 204. </font>
<font color="red"> 205.         if not keep_parents:</font>
<font color="black"> 206.             # Recursively collect concrete model's parent models, but not their</font>
<font color="black"> 207.             # related objects. These will be found by meta.get_fields()</font>
<font color="red"> 208.             concrete_model = model._meta.concrete_model</font>
<font color="red"> 209.             for ptr in six.itervalues(concrete_model._meta.parents):</font>
<font color="red"> 210.                 if ptr:</font>
<font color="black"> 211.                     # FIXME: This seems to be buggy and execute a query for each</font>
<font color="black"> 212.                     # parent object fetch. We have the parent data in the obj,</font>
<font color="black"> 213.                     # but we don't have a nice way to turn that data into parent</font>
<font color="black"> 214.                     # object instance.</font>
<font color="red"> 215.                     parent_objs = [getattr(obj, ptr.name) for obj in new_objs]</font>
<font color="red"> 216.                     self.collect(parent_objs, source=model,</font>
<font color="red"> 217.                                  source_attr=ptr.remote_field.related_name,</font>
<font color="red"> 218.                                  collect_related=False,</font>
<font color="red"> 219.                                  reverse_dependency=True)</font>
<font color="red"> 220.         if collect_related:</font>
<font color="red"> 221.             for related in get_candidate_relations_to_delete(model._meta):</font>
<font color="red"> 222.                 field = related.field</font>
<font color="red"> 223.                 if field.remote_field.on_delete == DO_NOTHING:</font>
<font color="red"> 224.                     continue</font>
<font color="red"> 225.                 batches = self.get_del_batches(new_objs, field)</font>
<font color="red"> 226.                 for batch in batches:</font>
<font color="red"> 227.                     sub_objs = self.related_objects(related, batch)</font>
<font color="red"> 228.                     if self.can_fast_delete(sub_objs, from_field=field):</font>
<font color="red"> 229.                         self.fast_deletes.append(sub_objs)</font>
<font color="red"> 230.                     elif sub_objs:</font>
<font color="red"> 231.                         field.remote_field.on_delete(self, field, sub_objs, self.using)</font>
<font color="red"> 232.             for field in model._meta.virtual_fields:</font>
<font color="red"> 233.                 if hasattr(field, 'bulk_related_objects'):</font>
<font color="black"> 234.                     # It's something like generic foreign key.</font>
<font color="red"> 235.                     sub_objs = field.bulk_related_objects(new_objs, self.using)</font>
<font color="red"> 236.                     self.collect(sub_objs, source=model, nullable=True)</font>
<font color="black"> 237. </font>
<font color="green"> 238.     def related_objects(self, related, objs):</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="black"> 240.         Gets a QuerySet of objects related to ``objs`` via the relation ``related``.</font>
<font color="black"> 241.         &quot;&quot;&quot;</font>
<font color="red"> 242.         return related.related_model._base_manager.using(self.using).filter(</font>
<font color="red"> 243.             **{&quot;%s__in&quot; % related.field.name: objs}</font>
<font color="black"> 244.         )</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def instances_with_model(self):</font>
<font color="red"> 247.         for model, instances in six.iteritems(self.data):</font>
<font color="red"> 248.             for obj in instances:</font>
<font color="red"> 249.                 yield model, obj</font>
<font color="black"> 250. </font>
<font color="green"> 251.     def sort(self):</font>
<font color="red"> 252.         sorted_models = []</font>
<font color="red"> 253.         concrete_models = set()</font>
<font color="red"> 254.         models = list(self.data)</font>
<font color="red"> 255.         while len(sorted_models) &lt; len(models):</font>
<font color="red"> 256.             found = False</font>
<font color="red"> 257.             for model in models:</font>
<font color="red"> 258.                 if model in sorted_models:</font>
<font color="red"> 259.                     continue</font>
<font color="red"> 260.                 dependencies = self.dependencies.get(model._meta.concrete_model)</font>
<font color="red"> 261.                 if not (dependencies and dependencies.difference(concrete_models)):</font>
<font color="red"> 262.                     sorted_models.append(model)</font>
<font color="red"> 263.                     concrete_models.add(model._meta.concrete_model)</font>
<font color="red"> 264.                     found = True</font>
<font color="red"> 265.             if not found:</font>
<font color="red"> 266.                 return</font>
<font color="red"> 267.         self.data = OrderedDict((model, self.data[model])</font>
<font color="red"> 268.                                 for model in sorted_models)</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def delete(self):</font>
<font color="black"> 271.         # sort instance collections</font>
<font color="red"> 272.         for model, instances in self.data.items():</font>
<font color="red"> 273.             self.data[model] = sorted(instances, key=attrgetter(&quot;pk&quot;))</font>
<font color="black"> 274. </font>
<font color="black"> 275.         # if possible, bring the models in an order suitable for databases that</font>
<font color="black"> 276.         # don't support transactions or cannot defer constraint checks until the</font>
<font color="black"> 277.         # end of a transaction.</font>
<font color="red"> 278.         self.sort()</font>
<font color="black"> 279.         # number of objects deleted for each model label</font>
<font color="red"> 280.         deleted_counter = Counter()</font>
<font color="black"> 281. </font>
<font color="red"> 282.         with transaction.atomic(using=self.using, savepoint=False):</font>
<font color="black"> 283.             # send pre_delete signals</font>
<font color="red"> 284.             for model, obj in self.instances_with_model():</font>
<font color="red"> 285.                 if not model._meta.auto_created:</font>
<font color="red"> 286.                     signals.pre_delete.send(</font>
<font color="red"> 287.                         sender=model, instance=obj, using=self.using</font>
<font color="black"> 288.                     )</font>
<font color="black"> 289. </font>
<font color="black"> 290.             # fast deletes</font>
<font color="red"> 291.             for qs in self.fast_deletes:</font>
<font color="red"> 292.                 count = qs._raw_delete(using=self.using)</font>
<font color="red"> 293.                 deleted_counter[qs.model._meta.label] += count</font>
<font color="black"> 294. </font>
<font color="black"> 295.             # update fields</font>
<font color="red"> 296.             for model, instances_for_fieldvalues in six.iteritems(self.field_updates):</font>
<font color="red"> 297.                 query = sql.UpdateQuery(model)</font>
<font color="red"> 298.                 for (field, value), instances in six.iteritems(instances_for_fieldvalues):</font>
<font color="red"> 299.                     query.update_batch([obj.pk for obj in instances],</font>
<font color="red"> 300.                                        {field.name: value}, self.using)</font>
<font color="black"> 301. </font>
<font color="black"> 302.             # reverse instance collections</font>
<font color="red"> 303.             for instances in six.itervalues(self.data):</font>
<font color="red"> 304.                 instances.reverse()</font>
<font color="black"> 305. </font>
<font color="black"> 306.             # delete instances</font>
<font color="red"> 307.             for model, instances in six.iteritems(self.data):</font>
<font color="red"> 308.                 query = sql.DeleteQuery(model)</font>
<font color="red"> 309.                 pk_list = [obj.pk for obj in instances]</font>
<font color="red"> 310.                 count = query.delete_batch(pk_list, self.using)</font>
<font color="red"> 311.                 deleted_counter[model._meta.label] += count</font>
<font color="black"> 312. </font>
<font color="red"> 313.                 if not model._meta.auto_created:</font>
<font color="red"> 314.                     for obj in instances:</font>
<font color="red"> 315.                         signals.post_delete.send(</font>
<font color="red"> 316.                             sender=model, instance=obj, using=self.using</font>
<font color="black"> 317.                         )</font>
<font color="black"> 318. </font>
<font color="black"> 319.         # update collected instances</font>
<font color="red"> 320.         for model, instances_for_fieldvalues in six.iteritems(self.field_updates):</font>
<font color="red"> 321.             for (field, value), instances in six.iteritems(instances_for_fieldvalues):</font>
<font color="red"> 322.                 for obj in instances:</font>
<font color="red"> 323.                     setattr(obj, field.attname, value)</font>
<font color="red"> 324.         for model, instances in six.iteritems(self.data):</font>
<font color="red"> 325.             for instance in instances:</font>
<font color="red"> 326.                 setattr(instance, model._meta.pk.attname, None)</font>
<font color="red"> 327.         return sum(deleted_counter.values()), dict(deleted_counter)</font>
</pre>

