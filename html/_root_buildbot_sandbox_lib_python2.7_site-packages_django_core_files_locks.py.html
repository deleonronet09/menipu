source file: <b>/root/buildbot/sandbox/lib/python2.7/site-packages/django/core/files/locks.py</b><br>


file stats: <b>63 lines, 12 executed: 19.0% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. Portable file locking utilities.</font>
<font color="black">   3. </font>
<font color="black">   4. Based partially on an example by Jonathan Feignberg in the Python</font>
<font color="black">   5. Cookbook [1] (licensed under the Python Software License) and a ctypes port by</font>
<font color="black">   6. Anatoly Techtonik for Roundup [2] (license [3]).</font>
<font color="black">   7. </font>
<font color="black">   8. [1] http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65203</font>
<font color="black">   9. [2] http://sourceforge.net/p/roundup/code/ci/default/tree/roundup/backends/portalocker.py</font>
<font color="black">  10. [3] http://sourceforge.net/p/roundup/code/ci/default/tree/COPYING.txt</font>
<font color="black">  11. </font>
<font color="black">  12. Example Usage::</font>
<font color="black">  13. </font>
<font color="black">  14.     &gt;&gt;&gt; from django.core.files import locks</font>
<font color="black">  15.     &gt;&gt;&gt; with open('./file', 'wb') as f:</font>
<font color="black">  16.     ...     locks.lock(f, locks.LOCK_EX)</font>
<font color="black">  17.     ...     f.write('Django')</font>
<font color="green">  18. &quot;&quot;&quot;</font>
<font color="green">  19. import os</font>
<font color="black">  20. </font>
<font color="green">  21. __all__ = ('LOCK_EX', 'LOCK_SH', 'LOCK_NB', 'lock', 'unlock')</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="green">  24. def _fd(f):</font>
<font color="black">  25.     &quot;&quot;&quot;Get a filedescriptor from something which could be a file or an fd.&quot;&quot;&quot;</font>
<font color="red">  26.     return f.fileno() if hasattr(f, 'fileno') else f</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. if os.name == 'nt':</font>
<font color="red">  30.     import msvcrt</font>
<font color="red">  31.     from ctypes import (sizeof, c_ulong, c_void_p, c_int64,</font>
<font color="black">  32.                         Structure, Union, POINTER, windll, byref)</font>
<font color="red">  33.     from ctypes.wintypes import BOOL, DWORD, HANDLE</font>
<font color="black">  34. </font>
<font color="red">  35.     LOCK_SH = 0  # the default</font>
<font color="red">  36.     LOCK_NB = 0x1  # LOCKFILE_FAIL_IMMEDIATELY</font>
<font color="red">  37.     LOCK_EX = 0x2  # LOCKFILE_EXCLUSIVE_LOCK</font>
<font color="black">  38. </font>
<font color="black">  39.     # --- Adapted from the pyserial project ---</font>
<font color="black">  40.     # detect size of ULONG_PTR</font>
<font color="red">  41.     if sizeof(c_ulong) != sizeof(c_void_p):</font>
<font color="red">  42.         ULONG_PTR = c_int64</font>
<font color="black">  43.     else:</font>
<font color="red">  44.         ULONG_PTR = c_ulong</font>
<font color="red">  45.     PVOID = c_void_p</font>
<font color="black">  46. </font>
<font color="black">  47.     # --- Union inside Structure by stackoverflow:3480240 ---</font>
<font color="red">  48.     class _OFFSET(Structure):</font>
<font color="black">  49.         _fields_ = [</font>
<font color="red">  50.             ('Offset', DWORD),</font>
<font color="red">  51.             ('OffsetHigh', DWORD)]</font>
<font color="black">  52. </font>
<font color="red">  53.     class _OFFSET_UNION(Union):</font>
<font color="red">  54.         _anonymous_ = ['_offset']</font>
<font color="black">  55.         _fields_ = [</font>
<font color="red">  56.             ('_offset', _OFFSET),</font>
<font color="red">  57.             ('Pointer', PVOID)]</font>
<font color="black">  58. </font>
<font color="red">  59.     class OVERLAPPED(Structure):</font>
<font color="red">  60.         _anonymous_ = ['_offset_union']</font>
<font color="black">  61.         _fields_ = [</font>
<font color="red">  62.             ('Internal', ULONG_PTR),</font>
<font color="red">  63.             ('InternalHigh', ULONG_PTR),</font>
<font color="red">  64.             ('_offset_union', _OFFSET_UNION),</font>
<font color="red">  65.             ('hEvent', HANDLE)]</font>
<font color="black">  66. </font>
<font color="red">  67.     LPOVERLAPPED = POINTER(OVERLAPPED)</font>
<font color="black">  68. </font>
<font color="black">  69.     # --- Define function prototypes for extra safety ---</font>
<font color="red">  70.     LockFileEx = windll.kernel32.LockFileEx</font>
<font color="red">  71.     LockFileEx.restype = BOOL</font>
<font color="red">  72.     LockFileEx.argtypes = [HANDLE, DWORD, DWORD, DWORD, DWORD, LPOVERLAPPED]</font>
<font color="red">  73.     UnlockFileEx = windll.kernel32.UnlockFileEx</font>
<font color="red">  74.     UnlockFileEx.restype = BOOL</font>
<font color="red">  75.     UnlockFileEx.argtypes = [HANDLE, DWORD, DWORD, DWORD, LPOVERLAPPED]</font>
<font color="black">  76. </font>
<font color="red">  77.     def lock(f, flags):</font>
<font color="red">  78.         hfile = msvcrt.get_osfhandle(_fd(f))</font>
<font color="red">  79.         overlapped = OVERLAPPED()</font>
<font color="red">  80.         ret = LockFileEx(hfile, flags, 0, 0, 0xFFFF0000, byref(overlapped))</font>
<font color="red">  81.         return bool(ret)</font>
<font color="black">  82. </font>
<font color="red">  83.     def unlock(f):</font>
<font color="red">  84.         hfile = msvcrt.get_osfhandle(_fd(f))</font>
<font color="red">  85.         overlapped = OVERLAPPED()</font>
<font color="red">  86.         ret = UnlockFileEx(hfile, 0, 0, 0xFFFF0000, byref(overlapped))</font>
<font color="red">  87.         return bool(ret)</font>
<font color="black">  88. else:</font>
<font color="green">  89.     try:</font>
<font color="green">  90.         import fcntl</font>
<font color="green">  91.         LOCK_SH = fcntl.LOCK_SH  # shared lock</font>
<font color="green">  92.         LOCK_NB = fcntl.LOCK_NB  # non-blocking</font>
<font color="green">  93.         LOCK_EX = fcntl.LOCK_EX</font>
<font color="red">  94.     except (ImportError, AttributeError):</font>
<font color="black">  95.         # File locking is not supported.</font>
<font color="red">  96.         LOCK_EX = LOCK_SH = LOCK_NB = 0</font>
<font color="black">  97. </font>
<font color="black">  98.         # Dummy functions that don't do anything.</font>
<font color="red">  99.         def lock(f, flags):</font>
<font color="black"> 100.             # File is not locked</font>
<font color="red"> 101.             return False</font>
<font color="black"> 102. </font>
<font color="red"> 103.         def unlock(f):</font>
<font color="black"> 104.             # File is unlocked</font>
<font color="red"> 105.             return True</font>
<font color="black"> 106.     else:</font>
<font color="green"> 107.         def lock(f, flags):</font>
<font color="red"> 108.             ret = fcntl.flock(_fd(f), flags)</font>
<font color="red"> 109.             return (ret == 0)</font>
<font color="black"> 110. </font>
<font color="green"> 111.         def unlock(f):</font>
<font color="red"> 112.             ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)</font>
<font color="red"> 113.             return (ret == 0)</font>
</pre>

